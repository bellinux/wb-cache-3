274|10000|Public
25|$|Abductive logic {{programming}} {{has been used}} for fault diagnosis, planning, natural language processing and machine learning. It has also been used to interpret <b>Negation</b> <b>as</b> <b>Failure</b> as a form of abductive reasoning.|$|E
25|$|Pure Prolog {{was soon}} extended, however, to include <b>negation</b> <b>as</b> <b>failure,</b> in which {{negative}} {{conditions of the}} form not(Bi) are shown by trying and failing to solve the corresponding positive conditions Bi.|$|E
25|$|The {{fact that}} Horn clauses {{can be given}} a {{procedural}} interpretation and, vice versa, that goal-reduction procedures {{can be understood as}} Horn clauses + backward reasoning means that logic programs combine declarative and procedural representations of knowledge. The inclusion of <b>negation</b> <b>as</b> <b>failure</b> means that logic programming is a kind of non-monotonic logic.|$|E
40|$|Abstract. The paper {{presents}} ATP – {{a system}} for automated theorem proving based on ordered linear resolution with marked literals, its putting into the base of prolog-like language and some applications. This resolution system is especially put into the base of prolog-like language, as the surrogate for the concept of <b>negation</b> <b>as</b> definite <b>failure.</b> This logical complete deductive base is used for building a descriptive logical programming language LOGPRO, which enables eliminating the defects of PROLOG-system (the expansion concerning Horn clauses, escaping <b>negation</b> treatment <b>as</b> definite <b>failure),</b> but keeping the main properties of PROLOG-language and possibilities of its expansions. Some features of the system when it is used as the base for time-table and scheduling, a technique for the implicational problem resolving for generalized data dependencies and intelligent tutoring system are described. 1...|$|R
40|$|Abstract: Functional-logic {{programming}} amalgamates some of {{the main}} features of both functional and logic styles into a single paradigm. Nevertheless, negation is a widely investigated feature in logic programming that has not received much attention in such programming style. It is not difficult to incorporate some kind of <b>negation</b> <b>as</b> finite <b>failure</b> for ground goals, but we are interested in a constructive version able to deal with non-ground goals. With this aim, in previous works we have built a formal framework for checking (finite) failure of reduction. In this paper we adapt it for implementing a prototype for a functional-logic language with constructive <b>failure</b> <b>as</b> the natural counterpart to negation in logic programming...|$|R
40|$|This {{paper is}} a {{contribution}} to the foundation of negation by failure. It presents a view of <b>negation</b> by <b>failure</b> <b>as</b> a modal provability notion. Negation by failure is a central notion in Logic Programming and is used extensively in practice. There are various attempts at its foundations each with its own difficultie...|$|R
2500|$|The {{built-in}} Prolog predicate \+/1 provides <b>negation</b> <b>as</b> <b>failure,</b> {{which allows}} for non-monotonic reasoning. The goal \+ illegal(X) in the rule ...|$|E
2500|$|In {{the context}} of logic programming, this idea leads {{to the need to}} {{distinguish}} between two kinds of negation— <b>negation</b> <b>as</b> <b>failure,</b> discussed above, and strong negation, which is denoted here by [...]. The following example, illustrating {{the difference between the two}} kinds of negation, belongs to John McCarthy. A school bus may cross railway tracks under the condition that there is no approaching train. If we do not necessarily know whether a train is approaching then the rule using <b>negation</b> <b>as</b> <b>failure</b> ...|$|E
2500|$|As an {{alternative}} to the completion semantics, <b>negation</b> <b>as</b> <b>failure</b> can also be interpreted epistemically, as in the stable model semantics of answer set programming. In this interpretation not(Bi) means literally that Bi is not known or not believed. The epistemic interpretation has the advantage that it can be combined very simply with classical negation, as in [...] "extended logic programming", to formalise such phrases as [...] "the contrary can not be shown", where [...] "contrary" [...] is classical negation and [...] "can not be shown" [...] is the epistemic interpretation of <b>negation</b> <b>as</b> <b>failure.</b>|$|E
40|$|AbstractSLDNF-resolution is a {{standard}} operational semantics for <b>negation</b> <b>as</b> (finite) <b>failure.</b> For some programs and goals, SLDNF-resolution is incomplete {{with respect to the}} Kunen semantics (program completion in three-valued logic). Intuitively, the reason for incompleteness is floundering. This fact, however, has not been proven formally. The existing papers study syntactic classes of programs and goals for which SLDNF-resolution is complete. We prove completeness of SLDNF-resolution for arbitrary programs, fair selection rules, and nonfloundering queries. For this, we need an appropriate notion of floundering. We introduce two versions of this notion, one simple but crude, the other more sophisticated. To {{be able to deal with}} fairness, we introduce an alternative definition of SLDNF-resolution. We also show how the three-valued completion semantics can be expressed in terms of the classical two-valued logic...|$|R
40|$|This paper {{presents}} a declarative semantics of logic programs which possibly contain inconsistent information. We introduce a multi-valued interpretation of logic programs and present the extended well-founded semantics for paraconsistent logic programs. In this setting, a meaningful information is still {{available in the}} presence of an inconsistent information in a program and any fact which is affected by an inconsistent information is distinguished from the others. The well-founded semantics is also extended to disjunctive paraconsistent logic programs. 1 Introduction Recent studies have greatly enriched an expressive power of logic programming as a tool for knowledge representation. Handling classical <b>negation</b> <b>as</b> well <b>as</b> <b>negation</b> by <b>failure</b> in a program is one of such extension. An extended logic program, which is introduced by Gelfond and Lifschitz [GL 90], distinguishes two types of negation and enables us to deal with explicit <b>negation</b> <b>as</b> well <b>as</b> default <b>negation</b> in a pro [...] ...|$|R
40|$|SLD {{resolution}} with <b>negation</b> <b>as</b> finite <b>failure</b> (or SLDNF) {{reflects the}} procedural interpretation of Horn-clause predicate logic as {{a programming language}} and forms the computational basis for Prolog systems. Despite its advantages in memory management, SLDNF is often not appropriate for query evaluation for three reasons: a) it may not terminate due to infinite positive recursion; b) it may not terminate due to infinite recursion through negation; and c) it may repeatedly evaluate the same clause body literal, leading to unacceptable performance. We address all three problems for goal-oriented query evaluation of arbitrary programs by presenting an extension of SLDNF, called SLG resolution, with the following distinctive features: (i) SLG resolution is a partial deduction procedure, consisting of several transformations. Each query is transformed step by step into a set of answer clauses; (ii) SLG resolution is sound and search space complete for all non-floundering queries with respec [...] ...|$|R
2500|$|The {{concept of}} a stable model, or answer set, is used to define a {{declarative}} semantics for logic programs with <b>negation</b> <b>as</b> <b>failure.</b> This {{is one of several}} standard approaches to the meaning of negation in logic programming, along with program completion and the well-founded semantics. The stable model semantics is the basis of ...|$|E
2500|$|The logical {{status of}} <b>negation</b> <b>as</b> <b>failure</b> was {{unresolved}} until Keith Clark [...] showed that, under certain natural conditions, it is a correct (and sometimes complete) implementation of classical negation {{with respect to}} the completion of the program. Completion amounts roughly to regarding the set of all the program clauses with the same predicate on the left hand side, say ...|$|E
2500|$|Despite its {{simplicity}} compared with classical logic, {{this combination of}} Horn clauses and <b>negation</b> <b>as</b> <b>failure</b> {{has proved to be}} surprisingly expressive. For example, it provides a natural representation for the common-sense laws of cause and effect, as formalised by both the situation calculus and event calculus. It has also been shown to correspond quite naturally to the semi-formal language of legislation. In particular, Prakken and Sartor credit the representation of the British Nationality Act as a logic program with being [...] "hugely influential for the development of computational representations of legislation, showing how logic programming enables intuitively appealing representations that can be directly deployed to generate automatic inferences".|$|E
40|$|In {{this paper}} {{we present a}} new {{interpretation}} of failure, a concept to {{which a lot of}} attention is being paid in the field of artificial intelligence research, especially due to the rise of the programming language PROLOG that treats <b>negation</b> <b>as</b> procedural <b>failure.</b> Our interpretation of failure, however, does not originate from research in the foundations of PROLOG. We present it here as an outcome of research on so-called dialogue logics, a tradition in logic research that envisages a logical proof as a formaliz/ed discussion between conflicting parties. Systems of formalized discussion that show the same logical behaviour as standard logical systems can be build. We show how such a system with additional fall operator can be used for the treatment of phenomena that are also relevant for natural language discourse. In the paper the following will be analyzed: negative questions, the paradox of the small number, and conditionals...|$|R
40|$|We {{propose a}} new, "top-down" {{definition}} of SLDNF-resolution which retains {{the spirit of}} the original definition but avoids the difficulties noted in the literature. We compare it with the "bottom-up" definition of Kunen [Kun 89]. 1 The problem The notion of SLD-resolution of Kowalski [Kow 74] allows us to resolve only positive literals. As a result it is not adequate to compute with general programs. Clark [Cla 79] proposed to incorporate the <b>negation</b> <b>as</b> finite <b>failure</b> rule. This leads to an extension of SLD-resolution called SLDNF-resolution. The intuition behind it is quite simple: for a ground atom A, :A succeeds iff A finitely fails, :A finitely fails iff A succeeds. (The restriction to ground atoms was originally introduced to ensure soundness of SLDNFresolution.) However, this intuition is difficult to formalize. For example, consider the general program P = fA /Ag. The query :A neither succeeds nor finitely fails, since the query A neither succeeds nor finitely fails. So it is [...] ...|$|R
40|$|Abstract Paraconsistent logics are {{generally}} considered somewhat esoteric. Moreover, some-one {{argued that they}} simply not exist, because paraconsistent negations are not negations. The aim of this work is to provide some valid reasons to reject both these assumptions. <b>Negation</b> <b>as</b> finite <b>failure</b> (NAF) is the stan-dard way to compute negation, used, for instance, by all the known (to me) Prolog implementations. Despite its well-known drawbacks, {{it is the only}} ef-fective way to compute negation in logic program-ming. Moreover, none has ever argued that NAF is not a “negation”, in the proper sense, although it is not a “classical negation”. It is quite simple to show that NAF exhibits paraconsistent behaviors, and this is yet another way to show that paraconsistent negations can be “true negations”. Moreover, this implies that studies on paraconsistency are not so esoteric as they can appear at a first sight: for instance, they can provide the logics community with a clean def-inition of what a “negation ” is...|$|R
5000|$|In Planner, <b>negation</b> <b>as</b> <b>failure</b> {{could be}} {{implemented}} as follows: ...|$|E
5000|$|... #Subtitle level 2: Relation {{to other}} {{theories}} of <b>negation</b> <b>as</b> <b>failure</b> ...|$|E
5000|$|The event {{calculus}} {{was originally}} formulated {{as a set}} of Horn clauses augmented with <b>negation</b> <b>as</b> <b>failure</b> and could be run as a Prolog program. In fact, circumscription is one of the several semantics that can be given to <b>negation</b> <b>as</b> <b>failure,</b> and is closely related to the completion semantics (in which [...] "if" [...] is interpreted as [...] "if and only if" [...] - [...] see logic programming).|$|E
40|$|In {{this paper}} we propose a denotational {{semantics}} for Prolog and an approach to the abstract interpretation of Prolog programs; we deal with the control rules of Prolog and the cut operator. Moreover, we get a simple denotation for <b>negation</b> <b>as</b> finite <b>failure.</b> The abstract analysis is proposed both for computed answers analysis and for call patterns analysis. In both cases the abstract semantics is finitely computable. Two examples show the usefulness of our approach for the analysis of Prolog programs. 1 Introduction A semantics can be useful as a tool for program understanding, as a tool for defining an equivalence relation between programs (in relation to program transformations), or as a tool for program analysis. The latter is our main interest. The first question to be answered is why we look for a new semantics of a subset of Prolog (more precisely, of Prolog without database and set operations). There exist many formalizations for subsets of Prolog, and there exists even a for [...] ...|$|R
40|$|We {{advocate}} a declarative approach to proving properties of logic programs. Total correctness can be separated into correctness, completeness and clean termination; the latter includes non-floundering. Only clean termination {{depends on the}} operational semantics, in particular on the selection rule. We show {{how to deal with}} correctness and completeness in a declarative way, treating programs only from the logical point of view. Specifications used in this approach are interpretations (or theories). We point out that specifications for correctness may differ from those for completeness, as usually there are answers which are neither considered erroneous nor required to be computed. We present proof methods for correctness and completeness for definite programs and generalize them to normal programs. For normal programs we use the 3 -valued completion semantics; this is a standard semantics corresponding to <b>negation</b> <b>as</b> finite <b>failure.</b> The proof methods employ solely the classical 2 -valued logic. We use a 2 -valued characterization of the 3 -valued completion semantics which may be of separate interest. The presented methods are compared with an approach based on operational semantics. We also employ the ideas of this work to generalize a known method of proving termination of normal programs. Comment: To appear in Theory and Practice of Logic Programming (TPLP). 44 page...|$|R
40|$|A {{solution}} to the problem of specificity in a resource [...] oriented deductive approach to actions and change is presented. Specificity originates in the problem of overloading methods in object oriented frameworks but can be observed in general applications of actions and change in logic. We give a uniform {{solution to}} the problem of specificity culminating in a completed equational logic program with an equational theory. We show the soundness and completeness of SLDENF [...] resolution, ie. SLD [...] resolution augmented by <b>negation</b> [...] <b>as</b> [...] <b>failure</b> and by an equational theory, wrt the completed program. Finally, the expressiveness of our approach for performing general reasoning about actions, change, and causality is demonstrated. 1 Introduction Logic plays a fundamental role for intelligent behavior. Especially the pioneers in Artificial Intelligence realized the importance of logic and deduction for their field. However, classical logic seems to lack some properties to adequately represent human [...] ...|$|R
5000|$|The {{built-in}} Prolog predicate [...] provides <b>negation</b> <b>as</b> <b>failure,</b> {{which allows}} for non-monotonic reasoning. The goal [...] in the rule ...|$|E
50|$|<b>Negation</b> <b>as</b> <b>failure</b> {{is related}} to the closed-world assumption, as it amounts to believing false every {{predicate}} that cannot be proved to be true.|$|E
5000|$|In {{the context}} of logic programming, this idea leads {{to the need to}} {{distinguish}} between two kinds of negation — <b>negation</b> <b>as</b> <b>failure,</b> discussed above, and strong negation, which is denoted here by [...] The following example, illustrating {{the difference between the two}} kinds of negation, belongs to John McCarthy. A school bus may cross railway tracks under the condition that there is no approaching train. If we do not necessarily know whether a train is approaching then the rule using <b>negation</b> <b>as</b> <b>failure</b> ...|$|E
40|$|DISLOG is {{a system}} for {{reasoning}} in disjunctive deductive databases. It seeks to combine features of disjunctive logic programming, such as the support for incomplete information, with those of deductive databases, such as all [...] result inference capabilities. Several basic operators are provided for logical and non [...] monotonic reasoning: The logical consequence operator derives all logically implied disjunctive clauses from a disjunctive database. The non [...] monotonic operators are semantically founded on generalizations of the well [...] known closed [...] world [...] assumption and the <b>negation</b> [...] <b>as</b> [...] <b>failure</b> concept. Reasoning in disjunctive deductive databases is very complex, even for small examples. Many different optimization techniques are integrated in DISLOG {{to speed up the}} application performance. The clause tree is used as a data structure that allows for an efficient and transparent evaluation. The DISLOG [...] system has been developed in PROLOG [...] currently a core part of DISLOG is reimplemented [...] ...|$|R
3000|$|..., such as addition, multiplication, subtraction, <b>negation,</b> <b>as</b> well as {{left shift}} and their compositions, are T-functions. However, {{rotations}} and right shift operations are not.|$|R
5000|$|It {{appears that}} {{different}} tenses use {{different forms of}} <b>negation,</b> <b>as</b> in the following sentences: ...|$|R
5000|$|SLDNF [...] is an {{extension}} of SLD resolution to deal with <b>negation</b> <b>as</b> <b>failure.</b> In SLDNF, goal clauses can contain <b>negation</b> <b>as</b> <b>failure</b> literals, say of the form , which can be selected only if they contain no variables. When such a variable-free literal is selected, a subproof (or subcomputation) is attempted to determine whether there is an SLDNF refutation starting from the corresponding unnegated literal [...] as top clause. The selected subgoal [...] succeeds if the subproof fails, and it fails if the subproof succeeds.|$|E
50|$|The stable model {{semantics}}, {{which is}} used to give a semantics to logic programming with <b>negation</b> <b>as</b> <b>failure,</b> {{can be seen as a}} simplified form of autoepistemic logic.|$|E
5000|$|As an {{alternative}} to the completion semantics, <b>negation</b> <b>as</b> <b>failure</b> can also be interpreted epistemically, as in the stable model semantics of answer set programming. In this interpretation not(Bi) means literally that Bi is not known or not believed. The epistemic interpretation has the advantage that it can be combined very simply with classical negation, as in [...] "extended logic programming", to formalise such phrases as [...] "the contrary can not be shown", where [...] "contrary" [...] is classical negation and [...] "can not be shown" [...] is the epistemic interpretation of <b>negation</b> <b>as</b> <b>failure.</b>|$|E
40|$|Abstract. In this {{exploratory}} {{paper we}} introduce CHR ¬, {{an extension of}} the CHR language with <b>negation</b> <b>as</b> absence, an established feature in production rule systems. <b>Negation</b> <b>as</b> absence is a procedural notion that allows a more concise and clean programming style. We propose a formal operational semantics for CHR ¬ close to CHR’s refined operational semantics. We illustrate and motivate its properties with examples. ...|$|R
5000|$|The {{original}} {{system of}} axioms for propositional infinite-valued Łukasiewicz logic used implication and <b>negation</b> <b>as</b> the primitive connectives: ...|$|R
5|$|Schaefer, Renate. <b>Negation</b> <b>as</b> {{a form of}} {{expression}} with {{particular attention to the}} language of the Angelus Silesius (Dissertation) Universität Bonn, 1958.|$|R
