105|10000|Public
2500|$|If {{we start}} with an {{arbitrary}} formula C of classical logic, and apply these equivalences repeatedly to replace the left hand sides with the right hand sides in C, then we will obtain a formula C' [...] which is logically equivalent to C but which has the property that C' [...] contains no implications, and ¬ appears in front of atomic formulae only. Such a formula {{is said to be}} in <b>negation</b> <b>normal</b> <b>form</b> and it is possible to prove formally that every formula C of classical logic has a logically equivalent formula C' [...] in <b>negation</b> <b>normal</b> <b>form.</b> That is, C is satisfiable if and only if C' [...] is satisfiable.|$|E
2500|$|The {{necessity}} of considering {{positive and negative}} satisfaction separately {{is a consequence of}} the fact that in dependence logic, as in the logic of branching quantifiers or in IF logic, the law of the excluded middle does not hold; alternatively, one may assume that all formulas are in <b>negation</b> <b>normal</b> <b>form,</b> using De Morgan's relations in order to define universal quantification and conjunction from existential quantification and disjunction respectively, and consider positive satisfaction alone.|$|E
2500|$|The aim of tableaux is to {{generate}} progressively simpler formulae until pairs of opposite literals are produced or no other rule can be applied. Negation {{can be treated}} by initially making formulae in <b>negation</b> <b>normal</b> <b>form,</b> so that negation only occurs in front of literals. Alternatively, one can use De Morgan's laws during {{the expansion of the}} tableau, so that for example [...] is treated as [...] Rules that introduce or remove a pair of negations (such as in [...] ) are also used in this case (otherwise, there would be no way of expanding a formula like : ...|$|E
50|$|Boolean {{functions}} are often represented by sentences in propositional logic, and sometimes as multivariate polynomials over GF(2), but more efficient representations are binary decision diagrams (BDD), <b>negation</b> <b>normal</b> <b>forms,</b> and propositional directed acyclic graphs (PDAG).|$|R
40|$|Hintikka {{describes}} the semantical games for Independence Friendly logic (IF-logic) {{in terms of}} the game rules. In this paper we elaborate in detail how the standard extensive game model serves as a mathematical model for these games. We intend the game model to be a framework in which we can reason with mathematical rigor about strategies, hence about truth and falsity in GTS. We discuss <b>negation</b> <b>normal</b> <b>forms,</b> and compare the notion of Skolem function with the game theoretical notion of strategy...|$|R
40|$|Although the {{equivalence}} of two Ordered Binary Decision Diagrams (OBDDs) can {{be decided}} in polynomial time, the equivalence of two Free Binary Decision Diagrams (FBDDs) is only known to be probabilistically decidable in polynomial time. FBDDs are a strict superset of OBDDs, and are more succinct than OBDDs, which explains the interest in testing their equivalence. We show that the probabilistic equivalence test for FBDDs holds for the class of deterministic, decomposable <b>negation</b> <b>normal</b> <b>forms</b> (d-DNNFs), which forms a strict superset of FBDDs and is more succinct than FBDDs. Ou...|$|R
5000|$|<b>Negation</b> <b>normal</b> <b>form</b> {{is not a}} {{canonical}} form: for example, [...] and [...] are equivalent, and {{are both}} in <b>negation</b> <b>normal</b> <b>form.</b>|$|E
50|$|Convert to <b>negation</b> <b>normal</b> <b>form.</b>|$|E
5000|$|All the {{formulas}} of LTL can {{be transformed}} into <b>negation</b> <b>normal</b> <b>form,</b> where ...|$|E
40|$|Abstract. This paper {{continues}} {{the line of}} research on the representation and compilation of propositional knowledge bases with propositional directed acyclic graphs (PDAG), <b>negation</b> <b>normal</b> <b>forms</b> (NNF), and binary decision diagrams (BDD). The idea is to permit variables with more than two states and to explicitly represent them in their most natural way. The resulting representation languages are analyzed according to their succinctness, supported queries, and supported transformations. The paper shows that most results from PDAGs, NNFs, and BDDs can be generalized to their corresponding multi-state extension. This implies that the entire knowledge compilation map is extensible from propositional to multi-state variables. ...|$|R
50|$|In {{extensions}} of classical propositional logic, the duality still holds (that is, to any logical operator one {{can always find}} its dual), since {{in the presence of}} the identities governing negation, one may always introduce an operator that is the De Morgan dual of another. This leads to an important property of logics based on classical logic, namely the existence of <b>negation</b> <b>normal</b> forms: any formula is equivalent to another formula where negations only occur applied to the non-logical atoms of the formula. The existence of <b>negation</b> <b>normal</b> <b>forms</b> drives many applications, for example in digital circuit design, where it is used to manipulate the types of logic gates, and in formal logic, where it is needed to find the conjunctive <b>normal</b> <b>form</b> and disjunctive <b>normal</b> <b>form</b> of a formula. Computer programmers use them to simplify or properly negate complicated logical conditions. They are also often useful in computations in elementary probability theory.|$|R
40|$|In {{this paper}} we prove a space lower bound of n^Ω(k) for {{non-deterministic}} (syntactic) read-once branching programs (nrobps) on functions expressible as cnfs with treewidth at most k of their primal graphs. This lower bound rules {{out the possibility}} of fixed-parameter space complexity of nrobps parameterized by k. We use lower bound for nrobps to obtain a quasi-polynomial separation between Free Binary Decision Diagrams and Decision Decomposable <b>Negation</b> <b>Normal</b> <b>Forms,</b> essentially matching the existing upper bound introduced by Beame et al. and thus proving the tightness of the latter. Comment: Significantly simplified proof of the main combinatorial lemma. AROSRN replaced back by NROBP due to their equivalenc...|$|R
50|$|A formula in <b>negation</b> <b>normal</b> <b>form</b> can be {{put into}} the {{stronger}} conjunctive normal form or disjunctive normal form by applying distributivity.|$|E
5000|$|Every binary {{decision}} diagram (BDD) and every <b>negation</b> <b>normal</b> <b>form</b> (NNF) {{are also a}} PDAG with some particular properties. The following pictures represent the Boolean function [...] : ...|$|E
5000|$|In {{mathematical}} logic, {{a formula}} is in <b>negation</b> <b>normal</b> <b>form</b> if the negation operator ( [...] , [...] ) is only applied to {{variables and the}} only other allowed Boolean operators are conjunction ( [...] , [...] ) and disjunction ( [...] , [...] ).|$|E
40|$|This paper {{continues}} {{the line of}} research on knowledge compilation {{in the context of}} <b>Negation</b> <b>Normal</b> <b>Forms</b> (NNF) and Binary Decision Diagrams (BDD). The idea is to analyze different target languages according to their succinctness and the classes of queries and transformations supported in polytime. We identify a new property called simple-negation, which is an implicit restriction of all NNFs and BDDs. The removal of this restriction leads to Propositional Directed Acyclic Graphs (PDAG), a more general family of graph-based languages for representing Boolean functions or propositional theories. With respect to certain NNF-based languages, we will show that corresponding PDAG-based languages are at least as succinct and support the same transformations. The most interesting language even supports the same queries and an additional transformation, making it more flexible...|$|R
40|$|Abstract—We study {{efficient}} {{translations of}} Regular Linear Temporal Logic (RLTL) into automata on infinite words. RLTL is a temporal logic that fuses Linear Temporal Logic (LTL) with regular expressions, extending its expressive power to all ω-regular languages. The first contribution {{of this paper}} is a novel bottom up translation from RLTL into alternating parity automata of linear size that requires only colors 0, 1 and 2. Moreover, the resulting automata enjoy the stratified internal structure of hesitant automata. Our translation is defined inductively for every operator, and does not require an upfront transformation of the expression into a <b>normal</b> <b>form.</b> Our construction builds at every step two automata: one equivalent to the formula and another to its complement. Inspired by this construction, our second contribution is to extend RLTL with new operators, including universal sequential composition, that enrich the logic with duality laws and <b>negation</b> <b>normal</b> <b>forms.</b> The third contribution is a ranking translation of the resulting alternating automata into non-deterministic Büchi automata. To provide this efficient translation we introduce the notion of stratified rankings, and show how the translation is optimal for the LTL fragment of the logic. Keywords-temporal logic; formal verification; formal methods; I...|$|R
40|$|Thesis (Ph. D.) [...] University of Washington, 2012 The age of Big Data {{has brought}} with itself {{datasets}} {{which are not}} just big, but also much more complicated. These datasets are constructed from disparate, unreliable and noisy sources, many times in an ad-hoc way because careful data cleaning and integration is too time consuming and not always necessary anymore. Representing the uncertainty hidden in these datasets is necessary to get meaningful query answers and Probabilistic Databases have come up as arguably the most popular solution to this problem. Their application to practical problems though has been held back because (i) the common models they use are not rich enough to capture the dependencies in these problems, and (ii) unlike traditional databases, query evaluation for probabilistic databases can be very expensive and unpredictable. This dissertation addresses these challenges by first proposing a new model for probabilistic databases that is rich enough to capture the dependencies found in most practical applications, while still allowing for a translation to considerably simpler and well-studied models. Our model leverages existing models from AI literature that combine probability theory with logic. The main challenge of query evaluation over probabilistic databases is that it requires solving probabilistic inference which is a notoriously hard problem. This dissertation studies this problem via both (i) foundational results that give new theoretical insights about existing probabilistic inference algorithms, like Read-Once Formulas, Tree-Decompositions, Binary Decision Diagrams, <b>Negation</b> <b>Normal</b> <b>Forms,</b> when applied to the setting of probabilistic databases, which {{as we will see}} have their own distinct challenges and expectations, and (ii) building a robust system where the above ideas are leveraged for efficient and reliable query evaluation...|$|R
50|$|Adnan Darwiche and his {{collaborators}} have shown that BDDs are one of several normal forms for Boolean functions, each induced by a different combination of requirements. Another important normal form identified by Darwiche is Decomposable <b>Negation</b> <b>Normal</b> <b>Form</b> or DNNF.|$|E
5000|$|The allowed {{moves in}} the {{semantic}} game [...] {{are determined by the}} synctactical structure of the formula under consideration.For simplicity, we first assume that [...] is in <b>negation</b> <b>normal</b> <b>form,</b> with negations symbols occurring only in front of atomic subformulas.|$|E
5000|$|If {{we start}} with an {{arbitrary}} formula C of classical logic, and apply these equivalences repeatedly to replace the left hand sides with the right hand sides in C, then we will obtain a formula C' [...] which is logically equivalent to C but which has the property that C' [...] contains no implications, and ¬ appears in front of atomic formulae only. Such a formula {{is said to be}} in <b>negation</b> <b>normal</b> <b>form</b> and it is possible to prove formally that every formula C of classical logic has a logically equivalent formula C' [...] in <b>negation</b> <b>normal</b> <b>form.</b> That is, C is satisfiable if and only if C' [...] is satisfiable.|$|E
40|$|We provide {{syntactic}} characterizations for {{a number}} of propositional model-based belief revision and update operators proposed in the literature, as well as algorithms based on these characterizations. 1 Introduction In this paper, we provide syntactic characterizations and algorithms {{for a number}} of belief change operators proposed in the literature. We already characterized Winslett's `possible models approach' (PMA) update operators in [del Val, 1992 b], where we explored in depth some of the operators in the PMA family, provided algorithms to compute them and experimentally showed that they could be of practical value for (small) updates of quite large databases. In this paper, we show how other operators can be characterized in a very similar way, and show how to design algorithms for computing the result of applying these operators to disjunctive, <b>negation</b> and conjunctive <b>normal</b> <b>form</b> (DNF, NNF and CNF, respectively) databases, which return a database in the same format. The i [...] ...|$|R
40|$|Abstract. We {{describe}} a new algorithm for compiling conjunctive <b>normal</b> <b>form</b> (CNF) into Deterministic Decomposable <b>Negation</b> <b>Normal</b> (d-DNNF), {{which is a}} tractable logical form that permits model counting in polynomial time. The new implementation is based on latest techniques from both the SAT and OBDD literatures, {{and appears to be}} orders of magnitude more efficient than previous algorithms for this purpose. We compare our compiler experimentally to state of the art model counters, OBDD compilers, and previous CNF 2 dDNNF compilers. ...|$|R
5000|$|They are however {{respectively}} {{equivalent to}} the following formulae in <b>negation</b> <b>normal</b> form: ...|$|R
5000|$|More generally, if [...] {{is not in}} <b>negation</b> <b>normal</b> <b>form,</b> we can state, as a {{rule for}} negation, that, when a game [...] is reached, the players begin playing a dual game [...] in which the roles of Verifiers and Falsifier are switched.|$|E
50|$|Using {{the above}} equivalences for {{negation}} propagation, {{it is possible}} to derive the normal form. This normal form allows R, true, false, and ∧ to appear in the formula, which are not fundamental operators of LTL. Note that the transformation to the <b>negation</b> <b>normal</b> <b>form</b> does not blow up the size of the formula. This normal form is useful in translation from LTL to Büchi automaton.|$|E
50|$|In {{computer}} science, {{a binary}} decision diagram (BDD) or branching {{program is a}} data structure {{that is used to}} represent a Boolean function. On a more abstract level, BDDs can be considered as a compressed representation of sets or relations. Unlike other compressed representations, operations are performed directly on the compressed representation, i.e. without decompression. Other data structures used to represent a Boolean function include <b>negation</b> <b>normal</b> <b>form</b> (NNF), and propositional directed acyclic graph (PDAG).|$|E
5000|$|A head <b>normal</b> <b>form</b> is {{not always}} a <b>normal</b> <b>form,</b> because the applied {{arguments}} [...] need not be normal. However, the converse is true: any <b>normal</b> <b>form</b> is also a head <b>normal</b> <b>form.</b> In fact, the <b>normal</b> <b>forms</b> are exactly the head <b>normal</b> <b>forms</b> in which the subterms [...] are themselves <b>normal</b> <b>forms.</b> This gives an inductive syntactic description of <b>normal</b> <b>forms.</b>|$|R
50|$|The third <b>normal</b> <b>form,</b> Boyce-Codd <b>normal</b> <b>form,</b> fourth <b>normal</b> <b>form</b> {{and fifth}} <b>normal</b> <b>form</b> are special {{cases of the}} domain/key <b>normal</b> <b>form.</b> All have either functional, multi-valued or join {{dependencies}} that can be converted into (super)keys. The domains on those <b>normal</b> <b>forms</b> were unconstrained so all domain constraints are satisfied. However, transforming a higher <b>normal</b> <b>form</b> into domain/key <b>normal</b> <b>form</b> {{is not always a}} dependency-preserving transformation and therefore not always possible.|$|R
50|$|Here two {{algorithms}} {{are presented}} for the construction. The first one provides a declarative {{and easy to}} understand construction. The second one provides an algorithmic and efficient construction. Both the algorithms assume that the input formula f is constructed using the set of propositional variables AP and f is in <b>negation</b> <b>normal</b> form.For each LTL formula f' without ¬ as top symbol, let neg(f') = ¬f', neg(¬f') = f'.For a special case f'=true, let neg(true) = false.|$|R
5000|$|The {{necessity}} of considering {{positive and negative}} satisfaction separately {{is a consequence of}} the fact that in dependence logic, as in the logic of branching quantifiers or in IF logic, the law of the excluded middle does not hold; alternatively, one may assume that all formulas are in <b>negation</b> <b>normal</b> <b>form,</b> using De Morgan's relations in order to define universal quantification and conjunction from existential quantification and disjunction respectively, and consider positive satisfaction alone.|$|E
50|$|ANF is {{a normal}} form, which means that two {{equivalent}} formulas will convert to the same ANF, easily showing whether two formulas are equivalent for automated theorem proving. Unlike other normal forms, it can be represented as a simple list of lists of variable names. Conjunctive and disjunctive normal forms also require recording whether each variable is negated or not. <b>Negation</b> <b>normal</b> <b>form</b> is unsuitable for that purpose, since it doesn't use equality as its equivalence relation: a &or; &not;a isn't reduced {{to the same thing}} as 1, even though they're equal.|$|E
5000|$|The aim of tableaux is to {{generate}} progressively simpler formulae until pairs of opposite literals are produced or no other rule can be applied. Negation {{can be treated}} by initially making formulae in <b>negation</b> <b>normal</b> <b>form,</b> so that negation only occurs in front of literals. Alternatively, one can use De Morgan's laws during {{the expansion of the}} tableau, so that for example [...] is treated as [...] Rules that introduce or remove a pair of negations (such as in [...] ) are also used in this case (otherwise, there would be no way of expanding a formula like : ...|$|E
50|$|An {{arbitrary}} propositional formula {{may have}} a very complicated structure. It is often convenient to work with formulas that have simpler <b>forms,</b> known as <b>normal</b> <b>forms.</b> Some common <b>normal</b> <b>forms</b> include conjunctive <b>normal</b> <b>form</b> and disjunctive <b>normal</b> <b>form.</b> Any propositional formula {{can be reduced to}} its conjunctive or disjunctive <b>normal</b> <b>form.</b>|$|R
40|$|A key {{is simple}} if it {{consists}} of a single attribute. It is shown that if a relation schema is in third <b>normal</b> <b>form</b> and every key is simple, then it is in projection-join <b>normal</b> <b>form</b> (sometimes called fifth <b>normal</b> <b>form),</b> the ultimate <b>normal</b> <b>form</b> with respect to projections and joins. Furthermore, it is shown that if a relation schema is in Boyce-Codd <b>normal</b> <b>form</b> and some key is simple, then it is in fourth <b>normal</b> <b>form</b> (but not necessarily projection-join <b>normal</b> <b>form).</b> These results give the database designer simple sufficient conditions, {{defined in terms of}} functional dependencies alone, that guarantee that the schema being designed is automatically in higher <b>normal</b> <b>forms...</b>|$|R
50|$|Relations are {{classified}} {{based upon the}} types of anomalies to which they're vulnerable. A database that's in the first <b>normal</b> <b>form</b> is vulnerable to all types of anomalies, while a database that's in the domain/key <b>normal</b> <b>form</b> has no modification anomalies. <b>Normal</b> <b>forms</b> are hierarchical in nature. That is, the lowest level is the first <b>normal</b> <b>form,</b> and the database cannot meet the requirements for higher level <b>normal</b> <b>forms</b> without first having met all {{the requirements of the}} lesser <b>normal</b> <b>forms.</b>|$|R
