1|5|Public
50|$|A Group 2 OPR {{instruction}} that {{has none of}} the microprogrammed bits set is another <b>No-Op</b> <b>instruction.</b>|$|E
2500|$|A NOP-sled is {{the oldest}} and most widely known {{technique}} for successfully exploiting a stack buffer overflow. It solves the problem of finding the exact address of the buffer by effectively increasing the size of the target area. To do this, much larger sections of the stack are corrupted with the <b>no-op</b> machine <b>instruction.</b> At the end of the attacker-supplied data, after the <b>no-op</b> <b>instructions,</b> the attacker places an instruction to perform a relative jump {{to the top of the}} buffer where the shellcode is located. This collection of no-ops is referred to as the [...] "NOP-sled" [...] because if the return address is overwritten with any address within the no-op region of the buffer, the execution will [...] "slide" [...] down the no-ops until it is redirected to the actual malicious code by the jump at the end. This technique requires the attacker to guess where on the stack the NOP-sled is instead of the comparatively small shellcode.|$|R
25|$|Because of the {{popularity}} of this technique, many vendors of intrusion prevention systems will search for this pattern of <b>no-op</b> machine <b>instructions</b> {{in an attempt to}} detect shellcode in use. It {{is important to note that}} a NOP-sled does not necessarily contain only traditional no-op machine instructions; any instruction that does not corrupt the machine state to a point where the shellcode will not run can be used in place of the hardware assisted no-op. As a result, it has become common practice for exploit writers to compose the no-op sled with randomly chosen instructions which will have no real effect on the shellcode execution.|$|R
40|$|The {{intent of}} a NULL OBJECT is to {{encapsulate}} {{the absence of}} an object by providing a substitutable alternative that offers suitable default do nothing behavior. In short, a design where &quot;nothing will come of nothing &quot; [Shakespeare 1605]. NULL OBJECT is a tactical pattern that has been discovered time and again, and not only in object-oriented systems: null file devices (/dev/null on Unix and NUL on Microsoft systems), <b>no-op</b> machine <b>instructions,</b> terminators on Ethernet cables, etc. The pattern has been documented in a variety of forms by many authors, varying widely in structure and length: from a thorough and structured GOF-like form [Woolf 1998] to a brief thumbnail-like production-rule form [Henney 1997]. This paper is derived from a previously published article [Henney 1999] and includes the aforementioned thumbnail. The aim of the current work is to update and capture the latest understanding of the pattern and its implications, also addressing a wide audience by documenting the pattern primarily with respect to Java and UML. Thumbnail if � An object reference may be optionally null and � This reference must be checked before every use and � The result of a null check is to do nothing or assign a suitable default value then � Provide a class derived from the object reference's type and � Implement all its methods to do nothing or provide default results and � Use an instance of this class whenever the object reference would have been nul...|$|R

