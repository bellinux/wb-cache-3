16|16|Public
50|$|Object Query Language (OQL). The ODMG OQL was a {{declarative}} (<b>nonprocedural)</b> <b>language</b> for query and updating. It used SQL as a basis, where possible, though OQL supports {{more powerful}} object-oriented capabilities.|$|E
50|$|NPL (for <b>NonProcedural</b> <b>Language)</b> was a {{relational}} database language developed by T.D. Truitt et al. in 1980 for Apple II and MS-DOS.In general, a non-procedural language (also called a declarative language) requires the programmer to specify what the program should do, rather than (as with a procedural language) providing the sequential steps indicating how the program should perform its task(s).|$|E
5000|$|Laura Haas’s work {{dramatically}} {{changed the}} research and practice of information integration. She led the Starburst project on extensible database systems, showing how diverse information could be integrated into a relational database. Her research was the foundation for IBM's DB2 LUW query processor. She was the overall architect for Garlic, a novel data federation system that provides integrated access to many data sources from a high-level <b>nonprocedural</b> <b>language,</b> and personally invented and implemented query optimization techniques that allowed Garlic to process queries efficiently, exploiting {{the capabilities of the}} underlying data sources. [...] Haas led the development of IBM InfoSphere Federation Server based on this technology, and was the technical lead of the IBM team which helped establish the enterprise information integration market. Laura also led the Clio project, inventing the concept and basic algorithms for schema mapping, and embodying them in the first tool to compute necessary transformations to bring data from diverse sources into a common format automatically. [...] She continues to provide thought leadership and to pursue new research around information integration, most recently in the context of Big Data, through her role as the Director of IBM Research’s Accelerated Discovery Lab.|$|E
40|$|The goal of Reverse Software Engineering is the reuse of old {{outdated}} {{programs in}} developing new systems which have an enhanced functionality and employ modern programming languages and new computer architectures. Mere transliteration of programs {{from the source}} language to the object language does not support enhancing the functionality {{and the use of}} newer computer architectures. The main concept in this report is to generate a specification of the source programs in an intermediate <b>nonprocedural,</b> mathematically oriented <b>language.</b> This specification is purely descriptive and independent of the notion of the computer. It may serve as the medium for manually improving reliability and expanding functionally. The modified specification can be translated automatically into optimized object programs in the desired new language and for the new platforms. This report juxtaposes and correlates two classes of computer programming languages: procedural vs. <b>nonprocedural.</b> The <b>nonprocedural</b> <b>languages</b> are also called rule based, equational, functional or assertive. Non-procedural languages are noted for the absence of "side effects " and the freeing of a user from "thinking like a computer " when composing or studying a procedural <b>language</b> program. <b>Nonprocedural</b> <b>languages</b> are therefore advantageous for software development and maintenance. Non procedural languages us...|$|R
40|$|This {{report is}} {{a survey of}} nonprocedural {{communication}} between users and application software in interactive data-processing systems. It includes {{a description of the}} main features of interactive systems, a classification of the potential users of application software, and a definition of the <b>nonprocedural</b> interface. <b>Nonprocedural</b> <b>languages</b> are classified into a number of broad groups and illustrated with examples. Finally, future trends in user-computer interfaces and possible developments in manager-oriented languages are discussed...|$|R
40|$|The present {{paper is}} {{a survey of}} nonprocedural {{communication}} between a user and application software in interactive data processing systems. It includes {{a description of the}} main features of interactive systems, a classification of potential users of application software, and a definition of the nonprocedural interface. An annotated classification of the main types of <b>nonprocedural</b> <b>languages</b> is presented. Future trends in user-computer interfaces and possible developments of languages for managers are mentioned as well...|$|R
40|$|Abstract: The {{application}} of <b>nonprocedural</b> <b>language</b> NORMA for the segmentation of different kind images is considered. The Norma {{language is a}} tool aimed for automated solution of the grid-oriented problems on parallel conputer systems. This language eliminate the programming phase which isnecessary to pass from computational formulas, derived by an application specialist, to a computer program. The results of 2 -D and 3 -D images development are indicated. Note: Publication language:russia...|$|E
40|$|Abstract: The {{application}} of <b>nonprocedural</b> <b>language</b> NORMA for {{the solution of}} the nonstationary gas dynamics problems is considered. The Norma language is a tool aimed at automated solution of the mathematical physics problems on parallel computer systems. This language eliminates the programming phase, which is necessary to pass from computational formulas, derived by an applic tion specialist to a computer program. The solution results for some two-dimensional gas dynamics problems are indicated. Note: Publication language:russia...|$|E
40|$|In {{this paper}} how a pure denotative (<b>nonprocedural)</b> <b>language</b> {{based on the}} lambda {{calculus}} can be provided with purely denotative analogs of the various constructs - such as while loops, blocks, case statements and the like - of conventional imperative structured programming languages. They can be simulated quite adequately using only two simple tools: phrases, which are compound expressions not unlike blocks, and pronouns, special variables not unlike keywords between which certain relationships are 'understood' to hold...|$|E
40|$|This paper {{attempts}} to describe {{some of the}} basic characteristics and issues involving the class of programming languages commonly referred to as "nonprocedural " or "very high level". The paper discusses major issues such as terminology, rela-tiveness, and arbitrary sequencing. Five features of <b>nonprocedural</b> <b>languages</b> are described, and a number of specific languages are discussed brief-ly. A short history of the subject is included. I t is characteristic of the programming f ie ld that much time and energy has been, and wi l l con-tinue to be, spent on terminology. This is per-haps an indication of the youth as well as th...|$|R
40|$|ARCA is a {{programming}} notation {{intended for}} interactive specification and manipulation of combinatorial graphs. The {{main body of}} this report is a technical description of ARCA sufficiently detailed to allow an interpreter to be developed. Some simple illustrative programs are included. ARCA incorporates variables for denoting primitive data elements (essentially vertices, edges and scalars), and diagrams (essentially embedded graphs). A novel feature {{is the use of}} two kinds of variable: the one storing values (as in conventional procedural languages), the other functional definitions (as in <b>nonprocedural</b> <b>languages).</b> By means of such variables, algebraic expressions over the algebra of primitive data elements may represent either explicit values or formulae. The potential applications and limitations of ARCA, and more general "algebraic notations" defined using similar principles, are briefly discussed...|$|R
40|$|Abstract: This {{book is the}} User Guide on {{compiler}} and configurator for Norma language programs. It {{describes the}} DOS and UNIX implementation, compiler and configurator structure, its running, options and other features. The <b>nonprocedural</b> Norma <b>language</b> is a tool aimed for automated solution of the grid-oriented problems on parallel computer systems. This language eliminates the programming phase {{that is necessary to}} pass from computational formulas, derived by an application specialist, to a computer program. Note: Publication language:russia...|$|R
40|$|The {{relational}} model of data, the XRM Relational Memory System, and the SEQUEL language have been covered in previous papers and are reviewed. SEQUEL is a relational data sublanguage intended for ad hoc interactive problem solving by non-computer specialists. A version of SEQUEL {{that has been}} implemented in a prototype interpreter is described. The interpreter is designed to minimize the data accessing operations required to respond to an arbitrary query. The optimization algorithms designed for this purpose are described. Key Words and Phrases: {{relational model}}, query language, <b>nonprocedural</b> <b>language,</b> database, dat...|$|E
40|$|The Problem Specification (PS) <b>nonprocedural</b> <b>{{language}}</b> is a {{very high}} level language for algorithm specification. PS is suitable for nonprogrammers, who can specify a problem using mathematically-oriented equations; for expert programmers, who can prototype different versions of a software system for evaluation; and for those who wish to use specifications for portions (if not all) of a program. PS has data types and modules similar to Modula- 2. The compiler generates C code. In this paper, we first show PS by example, and then discuss efEiciency issues in scheduling and code generation...|$|E
40|$|The {{emergence}} of pervasive networked data sources, such as web services, sensors, and mobile devices, enables context-sensitive, mobile applications. We {{have developed a}} programming model for writing such applications, in which entities called composers accept data from one or more sources, and act as sources of higher-level data. We have defined and implemented a <b>nonprocedural</b> <b>language,</b> iQL, specifying the behavior of composers. An iQL programmer expresses requirements for data sources rather than identifying specific sources; a runtime system discovers appropriate data sources, binds to them, and rebinds when properties of data sources change. The language has powerful operators useful in composition...|$|E
40|$|Abstract: The {{definition}} {{and implementation of}} control points for the Norma language is considered. The <b>nonprocedural</b> Norma <b>language</b> is a tool aimed for automated solution of the grid-oriented problems on parallel computer systems. This language eliminates the programming phase {{that is necessary to}} pass from computational formulas, derived by an application specialist, to a computer program. The control points may be used for writing the calculated variables during the calculation and then for the ability to start the calculations not from the begin of program, but from the last passed control point. Note: Publication language:russia...|$|R
40|$|Tree pattern {{matching}} {{is a fundamental}} operation that is used {{in a number of}} programming tasks such as mechanical theorem proving, term rewriting, symbolic computation, and <b>nonprocedural</b> programming <b>languages.</b> In this paper, we present new sequential algorithms for nonlinear {{pattern matching}} in trees. Our algorithm improves upon know tree pattern matching algorithms in important aspects such as time performance, ease of integration with several reduction strategies and ability to avoid unnecessary computation steps on match attempts that fail. The expected time complexity of our algorithm is linear in the sum of the sizes of the two trees...|$|R
40|$|Abstract: This {{article is}} {{dedicated}} to the Debugger for the parallel programs on the NORMA language (with external Fortran modules). Authors investigate the problems of debugging the parallel programs. The principal decisions of these problems, when languages NORMA and Fortran are used, are described. The common model of debugger’s implementation is listed, the components and their communicating interaction is described. The <b>nonprocedural</b> Norma <b>language</b> is a tool aimed for automated solution of the grid-oriented problems on parallel computer systems. This language eliminates the programming phase that is necessary to pass from computational formulas, derived by an application specialist, to a computer program. Note: Publication language:russia...|$|R
40|$|FMS is a FILE MAINTENANCE SYSTEM {{that permits}} the users to store, manipulate, retrieve, and list {{any amount of}} data. FMS can be invoked through English-like FMS activities, a <b>nonprocedural</b> <b>language.</b> With FMS, the user can input and access data without knowing how or where the data is {{actually}} stored. The FHS activities simplify communication between user and the computer by eliminating the need to translate a request into a computer program and then debug it. FMS {{can also be used}} as a front-end subsystem of an a request into a FMS can also be used application software system for handling data input and maintenance...|$|E
40|$|An {{algorithm}} can {{be regarded}} as consisting of a logic component, which specifies the knowledge to be used in solving problems, and a control component, which determines the problem-solving strategies by means of which that knowledge is used. The logic component determines the meaning of the algorithm whereas the control component only affects its effkiency. The effkiency of an algorithm can often be improved by improving the control component without changing the logic of the algorithm. We argue that computer programs would be more often correct and more easily improved and modified if their logic and control aspects were identified and separated in the program text. Key Words and Phrases: control language, logic programming, <b>nonprocedural</b> <b>language,</b> programming methodology, program specification, relational data structures CR Categories: 3. 64, 4. 20, 4. 30, 5. 21, 5. 2...|$|E
40|$|Software specification, modeling, and {{prototyping}} {{activities are}} often performed {{at different stages}} in a software development project by individuals who use different specialized notations. The need to manually interpret and transform information passed between stages can significantly decrease productivity and {{can serve as a}} potential source of error. Durra is a <b>nonprocedural</b> <b>language</b> designed to support the development of distributed applications consisting of multiple, concurrent, large-grained tasks executing in a heterogeneous network. Durra provides a framework through which one can specify the structure of an application in conjunction with its behavior, timing, and implementation dependencies. These specifications may be validated by passing behavioral and timing information associated with each Durra task description to a run-time interpreter. Similarly, software prototypes may be constructed by directing this information to a suitable source code generator. We have already [...] ...|$|E
40|$|Abstract—Subtree {{matching}} is {{an important}} problem in Computer Science on which a number of tasks, such as mechanical theorem proving, term-rewriting, symbolic computation and <b>nonprocedural</b> programming <b>languages</b> are based on. A systematic approach {{to the construction of}} subtree pattern matchers by deterministic pushdown automata, which read subject trees in prefix notation, is presented. The method is analogous to the construction of string pattern matchers: for a given pattern, a nondeterministic pushdown automaton is created and then it is determinised. In addition, it is shown that the size of the resulting deterministic pushdown automata directly corresponds {{to the size of the}} existing string pattern matchers based on finite automata. I...|$|R
40|$|Many Linear Programming (LP) {{practitioners}} formulate {{and document}} their models with block schematics of LP matrices. They subscribe to neither the column-wise emphasis of commercial matrix generators nor to the constraint orientation of recently proposed "modelling languages. " PAM is a <b>nonprocedural</b> modeling <b>language</b> {{in which the}} practitioner describes an LP matrix {{with a set of}} two-dimensional tables: a table representing the block schematic of the matrix and supporting data tables. A computer program processes these tables to produce an LP matrix ready for optimization. This paper describes block-wise model formulation, discusses the relationships of the data to the model, presents an overview of PAM's matrix generation language, and gives some experience with a prototype system. linear programming, formulation, matrix generation...|$|R
40|$|Ordered, labeled {{trees are}} trees {{in which each}} node has a label and the left-to-right order of its {{children}} (if it has any) is fixed. Such trees have many applications in vision, pattern recognition, molecular biology, programming compilation and natural language processing. Many of the applications involve comparing trees or retrieving/extracting information from a repository of trees. Examples include classification of unknown patterns, analysis of newly sequenced RNA structures, semantic taxonomy for dictionary definitions, generation of interpreters for <b>nonprocedural</b> programming <b>languages,</b> and automatic error recovery and correction for programming languages. Previous systems use exact matching (or generalized regular expression matching) for tree comparison. This paper presents a system, called Approximate-Tree-By-Example (ATBE), which allows inexact matching of trees. The ATBE system interacts with the user through a simple, but powerful query language; graphical devices a [...] ...|$|R
40|$|The use {{of linear}} {{programming}} is impeded by the efort required {{to express a}} model as a matrix and to collect and handle An data. experimental interactive system called LPMODEL simpl$es the development of linear programming models. It frees the user from the necessity of expressing the model as a matrix. LPMODEL provides a <b>nonprocedural</b> <b>language</b> for constructing a model in terminology that is natural to the problem, using ordinary algebraic expressions. With this language, the user can express a model concisely by generic constraints which the system interprets {{in conjunction with a}} data base to generate a concrete model for optimization. The design of the system and its terminology and data base sub-systems are discussed. An informal description is given of the modeling language which involves both ordinary arithmetic oper-ations and symbolic operations with associated semantics. Expe...|$|E
40|$|This report {{describes}} {{modifications to}} the MODEL language and processor to facilitate automatic implementation of solution procedures for systems of simultaneous equations. MODEL is {{a very high level}} <b>nonprocedural</b> <b>language</b> for specifying computational tasks. The MODEL processor compiles a specification in the MODEL language into a computer program in PL/I. The purpose of the current modifications is to allow users with relatively little programming expertise to solve complex mathematical systems involving sets of simultaneous equations quickly and efficiently using an automatic program generation approach to modelling. The primary application which has motivated these modifications is that of Project LINK, an international econometric model composed of independent constituent country/region models which are linked together into a complex network of simultaneous equations. This report presents the rationale behind these modifications, describes the syntax, semantics, scheduling and code generation of specifications containing simultaneous equations, and illustrates these facilities in applications to two small national models from the LINK system and to a novel linkage mechanism used t...|$|E
40|$|Data flow is {{a mode of}} {{parallel}} computation in which parallelism in a program can be exploited at the fine grained as well as macro level. A data flow computer executes a data dependency graph rather than the program counter controlled sequence of instructions executed by conventional machines. Nonprocedural languages appear to be especially appropriate high level languages for data flow computers. Nonprocedural languages have only two statement forms: data description and assertion. The assertions enumerate the relationships among the data. A data dependency graph is also a suitable representation for a <b>nonprocedural</b> <b>language</b> program (or specification). This research is concerned with translating the dependency graph form of a specification to a program graph for a data flow machine. Specifications in the MODEL language are translated into an intermediate form, the data flow template. The template is a language-independent representation of the specification. The template is then translated into a data flow language (Manchester Dataflow) for the Manchester University machine. The translation consists of creating an array graph to represent the specification; generating the data flo...|$|E
40|$|Discussed is a {{high-level}} data base management language {{that provides the}} user with a convenient and unijied interface to query, update, dejine, and control a data base. When the user performs an operation against the data base, he jills in {{an example of a}} solution to that operation in skeleton ta-bles that can be associated with actual tables in the data base. The system is currently being used experimentally for various applications. Query-by-Example: a data base language by M. M. Zloof Query-by-E~ample&quot; ~ is {{a high-level}} data base management language that provides a convenient and unified style to query, update, define, and control a relational data base. The philosophy of Query-by-Example is to require the user to know very little in order to get started and to minimize the number of concepts that he subsequently has to learn in order to understand and use the whole language. The language syntax is simple, yet it covers a wide variety of complex transactions. This is achieved through the use of the same operations for retrieval, manipulation, definition, and control (to the extent possible). The language operations should mimic, as much as possible, manual table manipulation, thus capturing the simplicity, symmetry and neutrality of the relational The formulation of a transaction should capture the user's thought process, thereby providing freedom to formulate a transaction. The system should allow the user to create and drop tables dynamically from the data base; it must also provide the user with a dynamic capability for defining control statements and security features. The architecture of the Query-by-Example language addresses all the requirements just mentioned. The results of various psychological studies of the language 7 show that it requires less than three hours of instruction for nonprogrammers to acquire the skill to make fairly complicated queries. Such queries would otherwise require the user to know first order predicate calculus. Other <b>nonprocedural</b> <b>languages</b> that deal with the same topic are SEQUEL ^ and QUEL. &apos...|$|R
40|$|We propose an {{object-oriented}} {{data model}} that generalizes the relational, hierarchical, and network models. A database scheme {{in this model}} is a directed graph, whose leaves represent data and whose internal nodes represent connections among the data. Instances are constructed from objects, which have separate names and values. We define a logic for the model, and describe a <b>nonprocedural</b> query <b>language</b> {{that is based on}} the logic. We also describe an algebraic query language and show that it is equivalent to the logical language. A preliminary version of this paper, under the title "A new approach to database logic", appeared in Proc. 3 rd ACM Symp. on Principles of Database Systems, Waterloo, April 1984, pp. 86 - 96. For a more extensive coverage of the material presented here the reader is referred to the first author's Ph. D. dissertation The logical data model: a new approach to database logic, Dept. of Computer Science, Stanford University, 1985. 1 1. Introduction Research in da [...] ...|$|R
40|$|This paper {{presents}} an algorithm for translating concurrent procedural <b>language</b> programs into <b>nonprocedural,</b> mathematical <b>language</b> programs, called specifications. The {{goal is to}} achieve reuse of old existing programs in developing new systems, through having them explained automatically and facilitating their modification. Mathematical languages are widely believed to be superior to procedural languages. Unlike procedural languages, mathematical languages do not have "side effects " and are oblivious to computer concepts. Thus mathematical languages free the user of having to "think like a computer " when developing or modifying a program. Its mathematical semantics make proving software correctness easier and improves software reliability. The specification can then be used to generate automatically highly efficient procedural language programs for computer system. The translation algorithm centers around {{the difference in the}} meaning of variables in procedural and mathematical languages. In a procedural language a variable may be assigned many values. In a mathematical language, however, a variable may be assigned only one value. The translation algorithm focuses on renaming variables in a procedural language program so that each variable is assigned only one value...|$|R
40|$|The goal of Reverse Software Engineering is the reuse of old {{outdated}} {{programs in}} developing new systems which have an enhanced functionality and employ modern programming languages and new computer architectures. Mere transliteration of programs {{from the source}} language to the object language does not support enhancing the functionality {{and the use of}} newer computer architectures. The main concept in this report is to generate a specification of the source programs in an intermediate nonprocedural, mathematically oriented language. This specification is purely descriptive and independent of the notion of the computer. It may serve as the medium for manually improving reliability and expanding functionally. The modified specification can be translated automatically into optimized object programs in the desired new language and for the new platforms. This report juxtaposes and correlates two classes of computer programming languages: procedural vs. nonprocedural. The nonprocedural languages are also called rule based, equational, functional or assertive. Non-procedural languages are noted for the absence of 2 ̆ 2 side effects 2 ̆ 2 and the freeing of a user from 2 ̆ 2 thinking like a computer 2 ̆ 2 when composing or studying a procedural language program. Nonprocedural languages are therefore advantageous for software development and maintenance. Non procedural languages use mathematical semantics and therefore are more suitable for analysis of the correctness and for improving the reliability of software. The difference in semantics between the two classes of languages centers on the meaning of variables. In a procedural language a variable may be assigned multiple values, while in a <b>nonprocedural</b> <b>language</b> a variable may assume one and only one value. The latter is the same convention as used in mathematics. The translation algorithm presented in this report consists of renaming variables and expanding the logic and control in the procedural program until each variable is assigned one and only one value. The translation into equations can then be performed directly. The source program and object specification are equivalent in that there is a one to one equality of values of respective variables. The specification that results from these transformations is then further simplified to make it easy to learn and understand it when performing maintenance. The presentation of translation algorithms in this report utilizes FORTRAN as the source language and MODEL as the object language. MODEL is an equational language, where rules are expressed as algebraic equations. MODEL has an effective translation into the object procedural languages PL/ 1, C and Ada...|$|E

