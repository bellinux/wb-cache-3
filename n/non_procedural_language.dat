0|751|Public
40|$|Probably {{building}} <b>non</b> <b>procedural</b> <b>languages</b> is {{the most}} prospective way for parallel programming just because <b>non</b> <b>procedural</b> means no fixed way for execution. The article consists of 3 parts. In first part we consider formal systems for definition a named datasets and studying an expression power of different subclasses. In the second part we consider a complexity of algorithms of building sets by the definitions. In third part we consider a fullness and flexibility {{of the class of}} program based data set definitions. Comment: 20 pages, will be printed in "Programming" magazine of RA...|$|R
40|$|The work {{described}} in this paper is related to three areas in the programming world : logic, functional and object 							programming. The main objective is essentially pedagogical since it is question here to make a synthesis on <b>non</b> <b>procedural</b> <b>languages.</b> To achieve this, we have considered many construction types, each one represents the one of evoked programming. Many fully-documented environments {{have been developed for}} writing constructions of any type, transforming them in order to evaluate them by showing the work really accomplished in the least detail. Facultad de Informátic...|$|R
40|$|The {{processing}} of multi database transactions requires {{not only a}} powerful <b>non</b> <b>procedural</b> user <b>language</b> to express a query on several databases but also the possibility to specify the execution control of such queries. In this paper, we show how transaction control {{can be added to}} MSQL queries. A minimal set of language primitives is combined with the VPL (Vienna Parallel Logic) language so that the dynamic formulation of MSQL queries with explicit control specification is supported...|$|R
40|$|The goal of Reverse Software Engineering is the reuse of old {{outdated}} {{programs in}} developing new systems which have an enhanced functionality and employ modern programming languages and new computer architectures. Mere transliteration of programs {{from the source}} language to the object language does not support enhancing the functionality {{and the use of}} newer computer architectures. The main concept in this report is to generate a specification of the source programs in an intermediate nonprocedural, mathematically oriented language. This specification is purely descriptive and independent of the notion of the computer. It may serve as the medium for manually improving reliability and expanding functionally. The modified specification can be translated automatically into optimized object programs in the desired new language and for the new platforms. This report juxtaposes and correlates two classes of computer programming languages: procedural vs. nonprocedural. The nonprocedural languages are also called rule based, equational, functional or assertive. Non-procedural languages are noted for the absence of "side effects " and the freeing of a user from "thinking like a computer " when composing or studying a <b>procedural</b> <b>language</b> program. Nonprocedural languages are therefore advantageous for software development and maintenance. <b>Non</b> <b>procedural</b> <b>languages</b> us...|$|R
40|$|The goal of Reverse Software Engineering is the reuse of old {{outdated}} {{programs in}} developing new systems which have an enhanced functionality and employ modern programming languages and new computer architectures. Mere transliteration of programs {{from the source}} language to the object language does not support enhancing the functionality {{and the use of}} newer computer architectures. The main concept in this report is to generate a specification of the source programs in an intermediate nonprocedural, mathematically oriented language. This specification is purely descriptive and independent of the notion of the computer. It may serve as the medium for manually improving reliability and expanding functionally. The modified specification can be translated automatically into optimized object programs in the desired new language and for the new platforms. This report juxtaposes and correlates two classes of computer programming languages: procedural vs. nonprocedural. The nonprocedural languages are also called rule based, equational, functional or assertive. Non-procedural languages are noted for the absence of 2 ̆ 2 side effects 2 ̆ 2 and the freeing of a user from 2 ̆ 2 thinking like a computer 2 ̆ 2 when composing or studying a <b>procedural</b> <b>language</b> program. Nonprocedural languages are therefore advantageous for software development and maintenance. <b>Non</b> <b>procedural</b> <b>languages</b> use mathematical semantics and therefore are more suitable for analysis of the correctness and for improving the reliability of software. The difference in semantics between the two classes of languages centers on the meaning of variables. In a <b>procedural</b> <b>language</b> a variable may be assigned multiple values, while in a nonprocedural language a variable may assume one and only one value. The latter is the same convention as used in mathematics. The translation algorithm presented in this report consists of renaming variables and expanding the logic and control in the procedural program until each variable is assigned one and only one value. The translation into equations can then be performed directly. The source program and object specification are equivalent in that there is a one to one equality of values of respective variables. The specification that results from these transformations is then further simplified to make it easy to learn and understand it when performing maintenance. The presentation of translation algorithms in this report utilizes FORTRAN as the source language and MODEL as the object language. MODEL is an equational language, where rules are expressed as algebraic equations. MODEL has an effective translation into the object <b>procedural</b> <b>languages</b> PL/ 1, C and Ada...|$|R
50|$|The {{main feature}} of SQL (<b>non</b> <b>procedural)</b> {{is also a}} {{drawback}} of SQL. One can use control statements like decision making, iterative control if only SQL is to be used. PL/SQL is basically a <b>procedural</b> <b>language,</b> which provides functionality of decision making, iteration and many more features like other <b>procedural</b> programming <b>languages.</b> A PL/SQL program unit {{is one of the}} following: PL/SQL anonymous block, procedure, function, package specification, package body, trigger, type specification, type body, library. Program units are the PL/SQL source code that is compiled, developed and ultimately executed on the database.|$|R
40|$|This paper {{presents}} an algorithm for translating concurrent <b>procedural</b> <b>language</b> programs into nonprocedural, mathematical language programs, called specifications. The {{goal is to}} achieve reuse of old existing programs in developing new systems, through having them explained automatically and facilitating their modification. Mathematical languages are widely believed to be superior to <b>procedural</b> <b>languages.</b> Unlike <b>procedural</b> <b>languages,</b> mathematical languages do not have "side effects " and are oblivious to computer concepts. Thus mathematical languages free the user of having to "think like a computer " when developing or modifying a program. Its mathematical semantics make proving software correctness easier and improves software reliability. The specification can then be used to generate automatically highly efficient <b>procedural</b> <b>language</b> programs for computer system. The translation algorithm centers around {{the difference in the}} meaning of variables in <b>procedural</b> and mathematical <b>languages.</b> In a <b>procedural</b> <b>language</b> a variable may be assigned many values. In a mathematical language, however, a variable may be assigned only one value. The translation algorithm focuses on renaming variables in a <b>procedural</b> <b>language</b> program so that each variable is assigned only one value...|$|R
50|$|PL/SQL works analogously to the {{embedded}} <b>procedural</b> <b>languages</b> {{associated with}} other relational databases. For example, Sybase ASE and Microsoft SQL Server have Transact-SQL, PostgreSQL has PL/pgSQL (which emulates PL/SQL to an extent), and IBM DB2 includes SQL <b>Procedural</b> <b>Language,</b> which {{conforms to the}} ISO SQL’s SQL/PSM standard.|$|R
5000|$|PL/pgSQL (safe), which resembles Oracle's PL/SQL <b>procedural</b> <b>language</b> and SQL/PSM.|$|R
5000|$|Stored procedures, using a <b>procedural</b> <b>language</b> {{that closely}} adheres to SQL/PSM ...|$|R
5000|$|User-defined {{functions}} (UDFs) {{which are}} analogous to functions in <b>procedural</b> <b>languages,</b> ...|$|R
5000|$|<b>Procedural</b> <b>languages</b> allow {{developers}} {{to extend the}} database with custom subroutines (functions), often called stored procedures. These functions {{can be used to}} build triggers (functions invoked upon modification of certain data) and custom aggregate functions. <b>Procedural</b> <b>languages</b> can also be invoked without defining a function, using the [...] "DO" [...] command at SQL level.|$|R
50|$|PL/Perl (Procedural Language/Perl) is a <b>procedural</b> <b>language</b> {{supported}} by the PostgreSQL RDBMS.|$|R
5000|$|Hot Soup Processor is a <b>procedural</b> <b>language,</b> and {{includes}} the following features: ...|$|R
5000|$|The design {{goals of}} PL/Perl were {{to create a}} loadable <b>procedural</b> <b>language</b> that: ...|$|R
5000|$|Swaram - A simple, {{general-purpose}} and <b>procedural</b> <b>language</b> {{designed for}} programming in Tamil.|$|R
40|$|The Object-Z {{notation}} {{is a good}} meta-language {{that can}} be used to specify denotational semantics of programming languages. It has been effectively applied to some categories of languages. These include the <b>procedural</b> <b>languages,</b> the object-oriented <b>procedural</b> <b>languages</b> [9] and specification languages [8]. To widen these catergories, this paper applies Object-Z to the specification of the semantics of a small typed functional language...|$|R
5000|$|Oracle Corporation's PL/SQL <b>procedural</b> <b>language</b> {{includes}} {{a set of}} compiler directives, known as [...] "pragmas".|$|R
50|$|Verilog and Verilog/AMS are not <b>procedural</b> {{programming}} <b>languages,</b> but event-based hardware description languages (HDLs). As such, {{they provide}} sophisticated and powerful language features for definition and synchronization of parallel actions and events. On the other hand, many actions defined in HDL program statements can {{run in parallel}} (somewhat similar to threads and tasklets in <b>procedural</b> <b>languages,</b> but much more fine-grained). However, Verilog/AMS can be coupled with <b>procedural</b> <b>languages</b> like the ANSI C language using the Verilog Procedural Interface of the simulator, which eases testsuite implementation, and allows interaction with legacy code or testbench equipment.|$|R
5000|$|SYMPL is a compiled, imperative, and <b>procedural</b> <b>language.</b> Compared to the Fortran of the day, SYMPL supports: ...|$|R
5000|$|J {{provides}} {{control structures}} (details here) {{similar to other}} <b>procedural</b> <b>languages.</b> Prominent control words in each category include: ...|$|R
5000|$|Stored {{procedures}} (SPs) {{which are}} analogous to procedures or void functions in <b>procedural</b> <b>languages</b> like VB or C, ...|$|R
5000|$|Although PROSE {{was a rich}} block-structured <b>procedural</b> <b>language,</b> {{its focus}} was the {{blending}} of simultaneous-variable mathematical systems such as: ...|$|R
50|$|LOLCODE is {{frequently}} {{criticized for not}} being very esoteric, but rather being an ordinary <b>procedural</b> <b>language</b> utilizing an unusual vocabulary.|$|R
50|$|The Euphoria {{language}} is a general purpose <b>procedural</b> <b>language</b> that focuses on simplicity, legibility, rapid development and performance via several means.|$|R
5000|$|Functional {{programming}} languages support (and heavily use) first-class functions, anonymous {{functions and}} closures, although these concepts are being included in newer <b>procedural</b> <b>languages.</b>|$|R
5000|$|Most SQL {{database}} implementations {{extend their}} SQL capabilities by providing imperative, i.e. <b>procedural</b> <b>languages.</b> Examples {{of these are}} Oracle's PL/SQL and DB2's SQL_PL.|$|R
50|$|The Pick {{operating}} system {{consists of a}} database, dictionary, query <b>language,</b> <b>procedural</b> <b>language</b> (PROC), peripheral management, multi-user management and a compiled BASIC Programming language.|$|R
50|$|This infix {{notation}} {{was introduced to}} make it easier for programmers familiar with C and other <b>procedural</b> <b>languages</b> to understand and write SKILL code.|$|R
5000|$|EGL is {{a target}} {{language}} for modernization of legacy applications {{because of the}} language semantics affinity with <b>procedural</b> <b>languages</b> and legacy 4th generation languages: ...|$|R
50|$|In 2000, renewed efforts {{from the}} European Union {{resulted}} in a Community Patent Regulation proposal, sometimes abbreviated as CPR. It provides that the patent, once it has been granted by the European Patent Office (EPO) {{in one of its}} <b>procedural</b> <b>languages</b> (English, German or French) and published in that language, with a translation of the claims into the two other <b>procedural</b> <b>languages,</b> will be valid without any further translation. This proposal is aimed to achieve a considerable reduction in translation costs.|$|R
50|$|Ezhil {{has four}} basic types, for Numbers, Strings, Logicals and Lists. It {{does not allow}} {{creation}} of new types, being a <b>procedural</b> <b>language</b> without structures or objects.|$|R
5000|$|SNOBOL rivals APL for its {{distinctiveness}} in {{format and}} programming style, both being radically unlike more [...] "standard" [...] <b>procedural</b> <b>languages</b> such as BASIC, Fortran, or C.|$|R
5000|$|The next advance was the {{development}} of <b>procedural</b> <b>languages.</b> These third-generation languages (the first described as high-level languages) use vocabulary related to the problem being solved. For example, ...|$|R
50|$|Note (5): Materialized {{views are}} now {{standard}} {{but can be}} emulated in versions prior to 9.3 with stored procedures and triggers using PL/pgSQL, PL/Perl, PL/Python, or other <b>procedural</b> <b>languages.</b>|$|R
50|$|Static {{classes are}} classes that cannot be {{instantiated}} or inherited from, {{and that only}} allow static members. Their purpose {{is similar to that}} of modules in many <b>procedural</b> <b>languages.</b>|$|R
