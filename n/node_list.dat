31|269|Public
50|$|The # sign {{marks the}} end of the <b>node</b> <b>list</b> and the start of the edge list.|$|E
50|$|The network's {{administration}} {{was set up}} where every area code had an Area Coordinator (AC) which was responsible for maintaining information about the nodes in their area code. The AC reported to the Group Coordinator (GC), which was responsible for updating the node lists for the area codes under them. The GC reported to the Network Coordinator (NC), {{who was responsible for}} sending out <b>node</b> <b>list</b> updates. The NC was the person who was ultimately in charge of WWIVnet.|$|E
50|$|The hash table's key-space {{is taken}} to be circular, like the key-space in the Chord system, and node IDs are 128-bit {{unsigned}} integers representing position in the circular key-space. Node IDs are chosen randomly and uniformly so peers who are adjacent in node ID are geographically diverse. The routing overlay network is formed {{on top of the}} hash table by each peer discovering and exchanging state information consisting of a list of leaf nodes, a neighborhood list, and a routing table. The leaf <b>node</b> <b>list</b> consists of the L/2 closest peers by node ID in each direction around the circle.|$|E
5000|$|... record DoublyLinkedList { DoublyLinkedNode firstNode // {{points to}} first <b>node</b> of <b>list</b> DoublyLinkedNode lastNode // points to last <b>node</b> of <b>list</b> } ...|$|R
50|$|Each beta <b>node</b> outputs WME <b>lists</b> {{which are}} either {{stored in a}} beta memory or sent {{directly}} to a terminal <b>node.</b> WME <b>lists</b> are stored in beta memories whenever the engine will perform additional left activations on subsequent beta nodes.|$|R
5000|$|As a data structure, a tree {{is defined}} as a node (the root), which itself {{consists}} of a value (of some data type, possibly empty), together with a list of references to other <b>nodes</b> (<b>list</b> possibly empty, references possibly null); symbolically: n: v (A node n consists of a value v and a list of references to other nodes.) ...|$|R
30|$|Extract a {{list with}} all {{elements}} in the network (name, type and upstream element and downstream element, if a pipe or connector) and separate them in edges and nodes. The <b>node</b> <b>list</b> is ordered alphanumerically, and each node is numbered sequentially. The same is done for the edge list.|$|E
30|$|In this paper, we {{construct}} the interference node set Ni(v) by discovering two-hop nodes of node v, that is, N_i(v)= _u∈ N(v) N(u), where N(u) is the neighboring node set of node u. Every Hello packet from node n contains not only information of node n itself, {{but also its}} neighbors’ information, which is also known through its neighbors’ Hello packets. By receiving such Hello packets, a node can indirectly obtain its two-hop neighbors’ information. An example of the neighboring maintenance is shown in Fig.  2, where the neighboring <b>node</b> <b>list</b> nb_list, interference neighboring <b>node</b> <b>list</b> intf_list, and channel usage table CUT are shown in its boxes. In this example, node n 3 is the interference neighboring node of n 1, but not its neighboring node. Although this {{makes it difficult for}} n 1 to get n 3 ’s information directly, n 1 can get the information through n 2 ’s Hello packets because n 1 and n 3 are both the neighboring nodes of n 2.|$|E
40|$|Abstract: Problem statement: Network wide {{broadcasting}} is {{a fundamental}} operation in ad hoc networks. In broadcasting, a source node {{sends a message to}} all the other nodes in the network. Unlike in a wired network, a packet transmitted by a node in ad hoc wireless network can reach all neighbors. Therefore, the total number of transmissions (Forwarding nodes) used as the cost criterion for broadcasting. Approach: This study proposes a reliable and efficient broadcasting algorithm using minimized forward <b>node</b> <b>list</b> algorithm which uses 2 -hop neighborhood information more effectively to reduce redundant transmissions in asymmetric Mobile Ad hoc networks that guarantees full delivery. Among the 1 -hop neighbors of the sender, only selected forwarding nodes retransmit the broadcast message. Forwarding nodes are selected such a way that to cover the uncovered 2 -hop neighbors. Results: Simulation results show that the proposed broadcasting algorithm provides high delivery ratio, low broadcast forward ratio, low overhead and minimized delay. Conclusion: In this study, reliable and efficient broadcasting algorithm in asymmetric Mobile Ad Hoc Networks using minimized forward <b>node</b> <b>list</b> algorithm has been proposed which provides low forward ratio, high delivery ratio while suppressing broadcast redundancy...|$|E
5000|$|... #Caption: A graph {{with eight}} vertices, and a tree {{decomposition}} of {{it onto a}} tree with six nodes. Each graph edge connects two vertices that are listed together at some tree node, and each graph vertex is <b>listed</b> at the <b>nodes</b> of a contiguous subtree of the tree. Each tree <b>node</b> <b>lists</b> at most three vertices, so the width of this decomposition is two.|$|R
50|$|In early 1997, Jim Choate and Igor Chudov {{set up the}} Cypherpunks Distributed Remailer, {{a network}} of {{independent}} mailing <b>list</b> <b>nodes</b> intended to eliminate the {{single point of failure}} inherent in a centralized list architecture. At its peak, the Cypherpunks Distributed Remailer included at least seven nodes. By mid-2005, al-qaeda.net ran the only remaining node. In mid 2013, following a brief outage, the al-qaeda.net <b>node's</b> <b>list</b> software was changed from Majordomo to GNU Mailman and subsequently the node was renamed to cpunks.org. The CDR architecture is now defunct, though the list administrator stated in 2013 that he was exploring a way to integrate this functionality with the new mailing list software.|$|R
40|$|An {{algorithm}} is presented that performs set operations (e. g., union or intersection) on two unaligned images represented by linear quadtrees. This algorithm seeks {{to minimize the}} number of nodes that must be searched for or inserted into the disk-based <b>node</b> <b>lists</b> that represent the trees. Windowing and matching operations can also be cast as unaligned set functions; these operations can then be solved by similar algorithms. r 19 ~ Academic press. Inc 1...|$|R
30|$|First, {{update the}} {{neighbor}} <b>node</b> <b>list</b> and calculate the coordinates of the center-hop neighbor list. If there are distance-hop neighbor nodes and mobile nodes {{that are less}} than a quarter of the distance between anchor nodes to coordinate the neighbor node as the center coordinates, the center coordinates of the origin of the left and right half of the width of the roadway to the applied to the width of the roadway width for the anchor box, forming the anchor box border.|$|E
40|$|Problem statement: Network wide {{broadcasting}} is {{a fundamental}} operation in ad hoc&# 13; networks. In broadcasting, a source node {{sends a message to}} all the other nodes in the network. Unlike&# 13; in a wired network, a packet transmitted by a node in ad hoc wireless network can reach all neighbors. &# 13; Therefore, the total number of transmissions (Forwarding nodes) used as the cost criterion for&# 13; broadcasting. Approach: This study proposes a reliable and efficient broadcasting algorithm using&# 13; minimized forward <b>node</b> <b>list</b> algorithm which uses 2 -hop neighborhood information more effectively to&# 13; reduce redundant transmissions in asymmetric Mobile Ad hoc networks that guarantees full delivery. &# 13; Among the 1 -hop neighbors of the sender, only selected forwarding nodes retransmit the broadcast&# 13; message. Forwarding nodes are selected such a way that to cover the uncovered 2 -hop neighbors. &# 13; Results: Simulation results show that the proposed broadcasting algorithm provides high delivery&# 13; ratio, low broadcast forward ratio, low overhead and minimized delay. Conclusion: In this study,&# 13; reliable and efficient broadcasting algorithm in asymmetric Mobile Ad Hoc Networks using minimized&# 13; forward <b>node</b> <b>list</b> algorithm has been proposed which provides low forward ratio, high delivery ratio&# 13; while suppressing broadcast redundancy...|$|E
30|$|Once the {{connectivity}} and <b>node</b> <b>list</b> are {{extracted from}} the numerical model, the computation of all possible routing operating configurations does not depend at all on any interaction with {{the model of the}} production network. This gives the possibility to improve the computational code as much as desired, without depending on the black box simulator. Due to the tree-like structure of the network, and for systems with a small number of wells, there are usually not a large number of combinations to compute; hence, the method should be relatively fast for most cases.|$|E
5000|$|These {{features}} {{resemble those}} of trees, in {{that there is a}} single root node, and an order to the elements. XML has appeared as a first-class data type in other languages. The JavaScript (E4X) extension explicitly defines two specific objects (XML and XMLList), which support XML document nodes and XML <b>node</b> <b>lists</b> as distinct objects and use a dot-notation specifying parent-child relationships. [...] These data structures represent XML documents as a tree structure.|$|R
3000|$|... [l](i, j) and two link lists: the {{insignificant}} <b>nodes</b> link <b>list</b> LIN and {{the significant}} pixels link list LSP. Both Amplitude Quadtree Q [...]...|$|R
25|$|Build each <b>list</b> <b>node</b> {{from one}} pair.|$|R
40|$|While we {{estimate}} the maximum contribution of one light node, we improve {{the reliability of}} estimation by borrowing material and geometry terms from nearby cut nodes. We use bidirectional list to store the nodes on the cut. When a cut node is split, we remove it from the list and insert its two children at the same position in the cut <b>node</b> <b>list.</b> Therefore, the range search to find nearby nodes is simply to traverse in the list. The nearby indices of light node j is computed as: N (j) = k| j− 1 ∑ u=...|$|E
40|$|In this paper, we {{consider}} solving the all-pairs regular path problem on large graphs efficiently. Let G be a graph and r {{be a regular}} path query, and consider finding the answers of r on G. If G is so small that it fits in main memory, it suffices to load entire G into main memory and traverse G to find paths matching r. However, if G is too large and cannot fit in main memory, we need another approach. In this paper, we propose a novel approach based on external memory algorithm. Our algorithm finds the answers matching r by scanning the <b>node</b> <b>list</b> of G sequentially. We made a small experiment, which suggests that our algorithm can solve the problem efficiently...|$|E
40|$|Abstract — Previous {{approaches}} for the Shortest Path Tree (SPT) dynamic update are mainly {{focused on the}} case of one link state change. Little work has been done to the problem of deriving a new SPT based on its old one for multiple link state decrements in a network that applies link-state routing protocols. The complexity of this problem comes from that there is no accurate boundary of nodes to be updated in an updating process and that multiple decrements can be accumulated. In this paper, two dynamic algorithms (MaxR, MinD) are proposed to reduce the times for node updating. Compared with other algorithms for the SPT update of multiple edge weight decrements, our algorithms yield less number of times for node updated during the dynamic update process. Such achievement is attained by the mechanism of part nodes updating in a branch on the SPT after a particular node selection from a built <b>node</b> <b>list.</b> Simulation results are given to show our improvements. I...|$|E
50|$|The {{simplest}} {{implementation of}} a self-organizing list is as a linked list and thus while being efficient in random node inserting and memory allocation, suffers from inefficient accesses to random <b>nodes.</b> A self-organizing <b>list</b> reduces the inefficiency by dynamically rearranging the <b>nodes</b> in the <b>list</b> based on access frequency.|$|R
40|$|This thesis {{deals with}} {{measuring}} transmission {{parameters of the}} Internet network, in particular latency of ping, SSH protocol and bandwidth. The thesis is divided into a theoretical and a practical part. Theoretical part describes PlanetLab network, its brief history and contemporary projects. At the same time, tools for data mining from web pages are described. These information obtained from the theoretical part are used for creating PlanetLab <b>nodes</b> <b>list</b> and for programming applications which measure the network transmission parameters. Applications, <b>list</b> of <b>nodes</b> and obtained data are attached on DVD disc...|$|R
5000|$|Notice {{that the}} <b>nodes</b> in <b>list</b> [...] have been copied, but the nodes in [...] are shared. As a result, the {{original}} lists ( [...] and [...] ) persist {{and have not}} been modified.|$|R
40|$|Abstract—Large {{companies}} have large embedded software systems, where common and reusable software parts are dis-tributed in various interrelated subsystems that also {{have lots of}} uncommon and non-reusable parts. The approach finds software parts {{that may or may}} not be reusable in a particular application engineering project. It is the task of application engineering to figure out whether the identified components and variants are directly reusable and reuse them in application engineering. In Software Product Lines, the identified reusable common and variable components should be generalized and stored into asset bases. In real life, it may be too much effort and costs to generalize application level assets into domain assets and it is just more feasible to try to find reusable common and variable components directly from existing applications. The proposed approach is selectively targeting the component-feature model instead of an inclusive search to improve the identification. We explore the components and their features from a predefined component <b>node</b> <b>list</b> and the features node vector respectively...|$|E
40|$|Abstract — Wireless Sensor Networks (WSN s) are {{comprised}} of {{large number of}} sensor nodes {{which can be used}} for monitoring and controlling physical phenomena in an environment such as healthcare monitoring, battlefield monitoring, enemy detection, tactical surveillance and disaster monitoring. A wireless sensor network consists of many small sensors which is capable of sensing, processing and communicating the events in wireless communication system. The vital role of the sensor networks is data delivery. The sensor nodes in a WSN have typically short battery life. However most of the WSN applications have to run for months or years. This makes energy consumption {{a major factor in the}} design of techniques for energy efficient communication protocols that maximize the lifetime of the network. This paper focuses on the development of a new energy efficient scheduling scheme which not only increases the lifetime of a sensor node but also gives the Priorities for the secured node transactions. The aim of the TORA algorithm is to process the multiple route in finding the shortest path. The basic principle of this protocol is to route the neighbor <b>node</b> <b>list</b> updating each node to the index status...|$|E
40|$|Previous {{approaches}} to the dynamic updating of Shortest Path Trees (SPTs) have in the main focused on just one link state change. Not much {{work has been done}} on the problem of deriving a new SPT from an existing SPT for multiple link state decrements in a network that applies link-state routing protocols such as OSPF and IS-IS. This problem is complex because in the process of updating an SPT there are, firstly, no simple forms of node set to presumable contain all nodes to be updated and, secondly, multiple decrements can be accumulated to make the updating much harder. If we adopt the updating mechanisms engaged in one link state change for the case of multiple link state decrements, the result is node update redundancy, as a node changes several times before it reaches its final state in the new SPT. This paper proposes two dynamic algorithms (MaxR, MinD) for obviating unnecessary node updates by having part nodes updated in a branch on the SPT only after selecting a particular node from a built <b>node</b> <b>list.</b> The algorithm complexity analysis and simulation results show that MaxR and MinD require fewer node updates during dynamic update procedures than do other algorithms for updating SPT of multiple link state decrements. Department of Computin...|$|E
40|$|K. Kennedy {{recently}} conjectured {{that for}} every n node reducible flow graph, there is a sequence of nodes (with repetitions) of length O(n log n) such that all acyclic paths are subsequences thereof. Such a sequence would, {{if it could be}} found easily, enable one to do various kinds of global data flow analyses quickly. We show that for all reducible flow graphs such a sequence does exist, even if the number of edges is much larger than n. If the number of edges is O(n), the <b>node</b> <b>listing</b> can be found in O(n log n) time...|$|R
40|$|By using a {{distributed}} P 2 P {{system where}} the agents reside in in microprocessors already present in most radio nodes like Wi-Fi access points, base stations, TVs connected to Internet etc, these agents can discover other agents over the back-haul network. As a result, client <b>node</b> <b>lists</b> (similar to neighbor lists used in 3 GPP) are created. An {{alternative is to}} use a centralized database. Why this best is done by distributed agents is discussed in this paper along with security considerations. Examples of other applications which will benefit from this system is also presented...|$|R
25|$|Build each <b>list</b> <b>node</b> {{from two}} pairs (to allow for empty lists).|$|R
40|$|Conference Name: 2012 International Conference on Machine Learning and Cybernetics, ICMLC 2012. Conference Address: Xian, Shaanxi, China. Time:July 15, 2012 - July 17, 2012. Hebei University; IEEE Systems, Man and Cybernetics Society; Chongqing University; South China University of Technology; Hong Kong Baptist UniversityDistributed {{coordination}} function (DCF) is a compulsory {{medium access control}} (MAC) scheme in IEEE 802. 11 protocol. In {{order to avoid the}} performance degradation due to hidden nodes, DCF adopts RTS/CTS mechanism to decrease collisions. However, the cost of RTS/CTS sharply increases with the number of wireless nodes. This paper has proposed a cooperative MAC protocol (C-MAC) for time-slotted Ad Hoc networks, which resolves collisions by introducing neighbor nodes information. A scheduling algorithm based on the neighbor <b>node</b> <b>list</b> is used to determine which node can transmit data at a particular time slot. In this paper, we analyze the throughput of IEEE 802. 11 DCF and C-MAC in mathematics. An inference is obtained: when the network topology is fixed, the throughput of C-MAC is higher than the one of DCE The simulation results proves this inference. C-MAC significantly improves DCF in terms of increasing throughput by 20 %鈭? 0 %. Moreover, C-MAC can obviously improve the fairness of wireless nodes. 漏 2012 IEEE...|$|E
40|$|To {{solve the}} problem of task {{scheduling}} in the cloud computing system, this paper proposes a scheduling algorithm for cloud computing based on the driver of dynamic essential path (DDEP). This algorithm applies a predecessor-task layer priority strategy to {{solve the problem}} of constraint relations among task nodes. The strategy assigns different priority values to every task node based on the scheduling order of task node as affected by the constraint relations among task nodes, and the task <b>node</b> <b>list</b> is generated by the different priority value. To address the scheduling order problem in which task nodes have the same priority value, the dynamic essential long path strategy is proposed. This strategy computes the dynamic essential path of the pre-scheduling task nodes based on the actual computation cost and communication cost of task node in the scheduling process. The task node that has the longest dynamic essential path is scheduled first as the completion time of task graph is indirectly influenced by the finishing time of task nodes in the longest dynamic essential path. Finally, we demonstrate the proposed algorithm via simulation experiments using Matlab tools. The experimental results indicate that the proposed algorithm can effectively reduce the task Makespan in most cases and meet a high quality performance objective...|$|E
40|$|The {{explosive}} growth in digital data and its growing role in real-time decision support motivate {{the design of}} high-performance database management systems (DBMSs). Meanwhile, slowdown in supply voltage scaling has stymied improvements in core performance and ushered an era of power-limited chips. These developments motivate the de-sign of DBMS accelerators that (a) maximize utility by ac-celerating the dominant operations, and (b) provide flexibil-ity {{in the choice of}} DBMS, data layout, and data types. We study data analytics workloads on contemporary in-memory databases and find hash index lookups to be the largest single contributor to the overall execution time. The critical path in hash index lookups consists of ALU-intensive key hashing followed by pointer chasing through a <b>node</b> <b>list.</b> Based on these observations, we introduce Widx, an on-chip accelerator for database hash index lookups, which achieves both high performance and flexibility by (1) decoupling key hashing from the list traversal, and (2) processing multiple keys in parallel on a set of programmable walker units. Widx reduces design cost and complexity through its tight integra-tion with a conventional core, thus eliminating the need for a dedicated TLB and cache. An evaluation of Widx on a set of modern data analytics workloads (TPC-H, TPC-DS) us-ing full-system simulation shows an average speedup of 3. 1 x over an aggressive OoO core on bulk hash table operations, while reducing the OoO core energy by 83 %...|$|E
2500|$|... {{function}} insertBeginning(List <b>list,</b> <b>Node</b> newNode) // insert node before current first node ...|$|R
5000|$|Build each <b>list</b> <b>node</b> {{from two}} pairs (to allow for empty lists).|$|R
30|$|As an example, in Fig. 2 c, {{the second}} and third columns give the {{occurrence}} relation and the <b>node</b> occurrence <b>lists,</b> respectively, of the pattern P on the tree T of Fig. 2 a.|$|R
