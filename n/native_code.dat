781|308|Public
25|$|With {{the fourth}} {{generation}} of Apple TV, third-party developers could {{write their own}} applications, removing the main limitations of previous models (see Future above). This application was built in just 5 weeks, from the moment Apple released the new Xcode and API documentation. Apple TV applications can be developed using TVML for the UI or <b>native</b> <b>code.</b> As using <b>native</b> <b>code</b> would have required too much time to develop for the UI, Plex combined advantages of both worlds making a bridge between TVML and <b>native</b> <b>code.</b> XML is sent from the Plex Media Server, and converted to TVML using XSLT.|$|E
25|$|Just-in-time (JIT) compilation: The runtime {{will turn}} ECMA CIL byte codes into <b>native</b> <b>code</b> as the code runs.|$|E
25|$|The Windows Vista Instant Search index {{can also}} be {{accessed}} programmatically using both managed as well as <b>native</b> <b>code.</b> <b>Native</b> <b>code</b> connects to the index catalog by using a Data Source Object retrieved from Windows Vista shell's Indexing Service OLE DB provider. Managed code use the MSIDXS ADO.NET provider with the index catalog name. A catalog on a remote machine {{can also be}} specified using a UNC path. The criteria for the search is specified using a SQL-like syntax.|$|E
40|$|This work {{introduces}} a technique which applies a stack-based intermediate code, also called as bytecodes, {{to reduce the}} size of programs in an embedded system. A hardware interpreter known as the Translation Unit translates bytecodes into <b>native</b> <b>codes</b> before execution. Experiments show that a program written in bytecodes is smaller than one written in <b>native</b> <b>codes</b> by 16 %- 38 %. Keyword: Code-size reduction, Code compression, Embedded system, Bytecode...|$|R
40|$|Network {{programming}} {{is a very}} important technology for next generation of distributed DAQ system. Java has powerful functionality not only in GUI but also in network programming. Execution speed of Java program is slow on Java interpreter. We have investigated various benchmark programs on Java interpreter, Java Just In Time compiler and Java compiler which generates <b>native</b> <b>codes,</b> and evaluated the performance of them in comparison with that of the C <b>native</b> <b>codes.</b> We found that the performance of the Java compiler was nearly as good as that of the C <b>native</b> <b>codes.</b> Hence, a prototype of Java-based DAQ has been developed. Our goal is to establish 3 tier (DAQ client, DAQ server and DAQ database) model for the DAQ...|$|R
40|$|Much of the {{portability}} characteristics {{associated with}} Java-based programs {{is attributable to}} the bytecode representation of Java executables. This aspect of portability and its associated benefits to high-performance computing has been a subject of strong research and debate. In addition, {{there have been several}} very successful efforts aimed at extending Java's usefulness as a high-performance programming language by wrapping codes written in other languages such as C or Fortran (<b>native</b> <b>codes)</b> using Java's JNI specification. A mutual aspect of these complementary disciplines which has been overlooked to a large extent is the portability of <b>native</b> <b>codes</b> which have been JNI-wrapped. This paper addresses this aspect of native-code portability by examining the composition of JNI-wrapped programs and the implications this executable form has on portability. Although not entirely platform independent, JNI-wrapped <b>native</b> <b>codes</b> exhibit a significant degree of portability. This portability en [...] ...|$|R
25|$|Java {{bytecode}} {{can either}} be interpreted at run time by a virtual machine, {{or it can be}} compiled at load time or runtime into <b>native</b> <b>code</b> which runs directly on the computer's hardware. Interpretation is slower than native execution, and compilation at load time or runtime has an initial performance penalty for the compilation. Modern performant JVM implementations all use the compilation approach, so after the initial startup time the performance is equivalent to <b>native</b> <b>code.</b>|$|E
25|$|Users {{can access}} the Windows Search index {{programmatically}} using managed {{as well as}} <b>native</b> <b>code.</b> <b>Native</b> <b>code</b> connects to the index catalog by using a Data Source Object retrieved from the Indexing Service OLE DB provider. Managed code use the MSIDXS ADO.NET provider. One can query a catalog on a remote machine by specifying a UNC path. Programmers specify the criteria for searches using SQL-like syntax. The SQL query can either be created by hand, or by using an implementation of the ISearchQueryHelper interface. Windows Search provides implementations of the interface to convert an AQS or NQS queries to their SQL counterpart.|$|E
25|$|In {{the early}} days of Java (before the HotSpot VM was {{implemented}} in Java 1.3 in 2000) there were some criticisms of performance. However, benchmarks typically report Java as being about 50% slower than C (a language which compiles to <b>native</b> <b>code).</b>|$|E
50|$|Native {{multilingual}} support - Strings {{are represented}} by multibyte string internally. You can use UTF-8, EUC-JP, Shift-JIS or no multibyte encoding. Conversion between <b>native</b> <b>coding</b> system and external coding system is supported by port objects.|$|R
50|$|ACK {{comes with}} a generic linker and {{librarian}} capable of manipulating files in the ACK's own a.out-based format; it will work on files containing EM code as well as <b>native</b> machine <b>code.</b> However, EM code cannot be linked to <b>native</b> machine <b>code</b> without translating the EM binary first.|$|R
5000|$|JEB 2.2 {{introduced}} Android debugging modules for Dalvik and <b>native</b> (Intel, ARM) <b>code.</b> Users can [...] "seamlessly debug Dalvik bytecode and <b>native</b> machine <b>code,</b> for all apps ... {{including those}} that do not explicitly allow debugging".|$|R
25|$|The Mono runtime {{contains}} a code execution engine that translates ECMA CIL byte codes into <b>native</b> <b>code</b> and supports {{a number of}} processors: ARM, MIPS (in 32-bit mode only), SPARC, PowerPC, S390 (in 64-bit mode), x86, x86-64 and IA-64 for 64-bit modes.|$|E
25|$|An {{alternative}} strategy, and {{the only}} sandbox strategy available in systems that {{do not meet the}} Popek and Goldberg virtualization requirements, is where the operating system is not running user programs as <b>native</b> <b>code,</b> but instead either emulates a processor or provides a host for a p-code based system such as Java.|$|E
25|$|Support for {{programming}} languages is added {{by using a}} specific VSPackage called a Language Service. A language service defines various interfaces which the VSPackage implementation can implement to add support for various functionalities. Functionalities that can be added this way include syntax coloring, statement completion, brace matching, parameter information tooltips, member lists and error markers for background compilation. If the interface is implemented, the functionality {{will be available for}} the language. Language services are implemented on a per-language basis. The implementations can reuse code from the parser or the compiler for the language. Language services can be implemented either in <b>native</b> <b>code</b> or managed code. For <b>native</b> <b>code,</b> either the native COM interfaces or the Babel Framework (part of Visual Studio SDK) can be used. For managed code, the MPF includes wrappers for writing managed language services.|$|E
5000|$|Inherit classes (both AJAX.OOP-style {{defined and}} created with <b>native</b> JavaScript <b>code)</b> ...|$|R
5000|$|QML code (including its JavaScript parts) can get {{compiled}} into <b>native</b> C++ <b>code</b> {{through the}} Qt Quick Compiler." ...|$|R
5000|$|While {{many other}} Eiffel compilers {{generate}} C, Java bytecode or bytecode for [...]NET, the Visual Eiffel compiler generates <b>native</b> X86 <b>code.</b>|$|R
25|$|The Choctaw code talkers were a {{group of}} Choctaw Indians from Oklahoma who pioneered the use of Native American {{languages}} as military code. Their exploits {{took place during the}} waning days of World War I. The government of the Choctaw Nation maintains that the men were the first American <b>native</b> <b>code</b> talkers ever to serve in the US military.|$|E
25|$|Microsoft Visual Studio is an {{integrated}} development environment (IDE) from Microsoft. It is used to develop computer programs for Microsoft Windows, as well as web sites, web apps, web services and mobile apps. Visual Studio uses Microsoft software development platforms such as Windows API, Windows Forms, Windows Presentation Foundation, Windows Store and Microsoft Silverlight. It can produce both <b>native</b> <b>code</b> and managed code.|$|E
25|$|Mobli apps were {{initially}} built in HTML5 but {{this approach was}} abandoned due to poor performance. The apps were re-built in <b>native</b> <b>code</b> on iOS and Android while dropping support for BlackBerry in favor of Windows Phone. The new apps, also with a re-designed user experience, were slated to roll out in late 2012 starting with its Windows Phone app.|$|E
2500|$|Meadows, William C. “They Had a Chance to Talk to One Another…” The Role of Incidence in <b>Native</b> American <b>Code</b> Talking. Ethnohistory 56(2):269-284. 2009 ...|$|R
50|$|Some tools have {{a hybrid}} mode, which use JavaScript based UI design SDK, such as Dojo Toolkit, YUI Library, jQuery Mobile, Sencha Touch. And a new JavaScript based Device {{featured}} APIs encapsulation (GeoLoc, Connective, AccMeter, Camera, G sensor, Events, File system, etc.) is plugged into IDE as well, such as PhoneGap (Apache Cordova), Appcelerator. That means a custom APP can use most of mobile device features {{without any of}} 4GL <b>coding</b> or <b>native</b> <b>coding,</b> and make it once developed, deployed anywhere.|$|R
50|$|Compared {{to direct}} {{translation}} into <b>native</b> machine <b>code,</b> a two-stage approach involving translation into p-code and execution by an interpreter or just-in-time compiler offers several advantages.|$|R
25|$|The Glasgow Haskell Compiler (GHC) compiles to <b>native</b> <b>code</b> on many {{different}} processor architectures, and to ANSI C, via {{one of two}} intermediate languages: C--, or in more recent versions, LLVM (formerly Low Level Virtual Machine) bitcode. GHC has become the de facto standard Haskell dialect. There are libraries (e.g., bindings to OpenGL) that work only with GHC. GHC is also distributed with the Haskell platform.|$|E
25|$|The Ericsson Erlang {{implementation}} loads {{virtual machine}} bytecode which {{is converted to}} threaded code at load time. It also includes a <b>native</b> <b>code</b> compiler on most platforms, developed by the High Performance Erlang Project (HiPE) at Uppsala University. Since October 2001 the HiPE system is fully integrated in Ericsson's Open Source Erlang/OTP system. It also supports interpreting, directly from source code via abstract syntax tree, via script as of R11B-5 release of Erlang.|$|E
25|$|Visual Studio {{includes}} a debugger that works {{both as a}} source-level debugger and as a machine-level debugger. It works with both managed code as well as <b>native</b> <b>code</b> {{and can be used}} for debugging applications written in any language supported by Visual Studio. In addition, it can also attach to running processes and monitor and debug those processes. If source code for the running process is available, it displays the code as it is being run. If source code is not available, it can show the disassembly. The Visual Studio debugger can also create memory dumps as well as load them later for debugging. Multi-threaded programs are also supported. The debugger can be configured to be launched when an application running outside the Visual Studio environment crashes.|$|E
50|$|Emulation {{had been}} around for a while as a concept, but FX!32 went one stage further. It {{analyzed}} the way programs worked and, after the program ran, used binary translation to produce dynamic-link library (DLL) files of <b>native</b> Alpha <b>code</b> that the application could execute the next time it ran. This way even in the early 1.0 release, the FX!32 achieved speeds for Win32 x86 applications that ran 40-50% as fast as <b>native</b> x86 <b>code,</b> with a 70% speed projected as likely with improved optimization.|$|R
5000|$|Congressional Gold Medal - <b>Native</b> American <b>Code</b> Talkers. <b>Native</b> American <b>Code</b> Talkers from 25 (33 {{tribes are}} eligible) tribes {{who served in}} World War I and II were awarded the Congressional Gold Medal on November 20, 2013 at the U.S. Capitol. Each tribe {{received}} a gold medal representing their tribe ("Comanche Nation Code Talker" [...] medal) and each code talker of the tribe or their next of kin received a Congressional silver duplicate medal. Seven more tribes/code talkers were to receive medals at a future date.|$|R
50|$|The first Pascal {{compiler}} {{written in}} North America was constructed at the University of Illinois under Donald B. Gillies for the PDP-11 and generated <b>native</b> machine <b>code.</b>|$|R
25|$|With {{the release}} of Word 6.0 in 1993, Microsoft again {{attempted}} to synchronize the version numbers and coordinate product naming across platforms, this time across DOS, Mac OS, and Windows (this was the last version of Word for DOS). It introduced AutoCorrect, which automatically fixed certain typing errors, and AutoFormat, which could reformat many parts of a document at once. While the Windows version received favorable reviews (e.g., from InfoWorld), the Mac OS version was widely derided. Many accused it of being slow, clumsy and memory intensive, and its user interface differed significantly from Word 5.1. In response to user requests, Microsoft offered Word 5 again, after it had been discontinued. Subsequent versions of Word for macOS are no longer direct ports of Word for Windows, instead featuring a mixture of ported code and <b>native</b> <b>code.</b>|$|E
25|$|Microsoft Visual C++: Microsoft Visual C++ is Microsoft's {{implementation}} of the C and C++ compiler and associated languages-services and specific tools for integration with the Visual Studio IDE. It can compile either in C mode or C++ mode. For C, it follows the 1990 version of the ISO C standard with parts of C99 specification along with MS-specific additions {{in the form of}} libraries. For C++, it follows the ANSI C++ specification along with a few C++11 features. It also supports the C++/CLI specification to write managed code, as well as mixed-mode code (a mix of native and managed code). Microsoft positions Visual C++ for development in <b>native</b> <b>code</b> or in code that contains both native as well as managed components. Visual C++ supports COM as well as the MFC library. For MFC development, it provides a set of wizards for creating and customizing MFC boilerplate code, and creating GUI applications using MFC. Visual C++ can also use the Visual Studio forms designer to design UI graphically. Visual C++ can also be used with the Windows API. It also supports the use of intrinsic functions, which are functions recognized by the compiler itself and not implemented as a library. Intrinsic functions are used to expose the SSE instruction set of modern CPUs. Visual C++ also includes the OpenMP (version 2.0) specification.|$|E
500|$|Software may be {{developed}} by third parties for the Windows Mobile operating system. [...] Developers have several options for deploying mobile applications. [...] These include writing <b>native</b> <b>code</b> with Visual C++, managed code {{that works with}} the [...]NET Compact Framework, writing code in Tcl-Tk with eTcl, GCC using CeGCC, Python using PythonCE or server-side code that can be deployed using Internet Explorer Mobile or a mobile client on a user's device. [...] The [...]NET Compact Framework is {{a subset of the}} [...]NET Framework and hence shares many components with software development on desktop clients, application servers, and web servers which have the [...]NET Framework installed, thus integrating networked computing space.|$|E
5000|$|Compiled Java {{code files}} are {{generally}} smaller than code files in C++ as Java bytecode is usually more compact than <b>native</b> machine <b>code</b> and Java programs are never statically linked.|$|R
2500|$|Meadows, William C. [...] "An Honor Long Overdue: The 2013 Congressional Gold and Silver Medal Ceremonies in Honor of <b>Native</b> American <b>Code</b> Talkers". American Indian Research and Culture Journal, 40(2):91-121. 2016.|$|R
2500|$|Meadows, William C. [...] "Honoring the <b>Native</b> American <b>Code</b> Talkers: The Road to the Code Talkers Recognition Act of 2008 (Public Law 110-420)." [...] American Indian Research and Culture Journal. 35(3)3-36. 2011.|$|R
