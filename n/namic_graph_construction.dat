0|934|Public
40|$|<b>Graph</b> <b>construction</b> is the {{essential}} first step for nearly all manifold learning algorithms. While many applications as-sume that a simple k-nearest or -close neighbors graph will accurately model the topology of the underlying manifold, these methods often require expert tuning and may not pro-duce high quality graphs. In this paper, the hyperparameter sensitivity of existing <b>graph</b> <b>construction</b> methods is demon-strated. We then present a new algorithm for unsupervised <b>graph</b> <b>construction,</b> based on minimal assumptions about the input data and its manifold structure...|$|R
40|$|A {{large number}} of call <b>graph</b> <b>construction</b> {{algorithms}} for object-oriented and functional languages have been proposed, each embodying different tradeoffs between analysis cost and call graph precision. In this article we present a unifying framework for understanding call <b>graph</b> <b>construction</b> algorithms and an empirical comparison of a representative set of algorithms. We first present a general parameterized algorithm that encompasses many well-known and novel call <b>graph</b> <b>construction</b> algorithms. We have implemented this general algorithm in the Vortex compiler infrastructure, a mature, multilanguage, optimizing compiler. The Vortex implementation provides a “level playing field ” for meaningful cross-algorithm performance comparisons. The {{costs and benefits of}} a number of call <b>graph</b> <b>construction</b> algorithms are empirically assessed by applying their Vortex implementation to a suite of sizeable (5, 000 to 50, 000 lines of code) Cecil and Java programs. For many of these applications, interprocedural analysis enabled substantial speed-ups over an already highly optimized baseline. Furthermore, a significant fraction of these speed-ups can be obtained {{through the use of a}} scalable, near-linear time call <b>graph</b> <b>construction</b> algorithm...|$|R
5000|$|... #Subtitle level 3: <b>Graph</b> <b>construction</b> on {{discrete}} {{state space}} ...|$|R
5000|$|BCG_MERGE, which gathers graph {{fragments}} {{obtained from}} distributed <b>graph</b> <b>construction</b> ...|$|R
5000|$|... #Subtitle level 3: <b>Graph</b> <b>construction</b> on {{continuous}} {{or large}} state space ...|$|R
40|$|OBJECTIVES: To {{identify}} key {{principles of}} <b>graph</b> <b>construction</b> and to review guidance on <b>graph</b> <b>construction</b> provided by medical journals. STUDY DESIGN AND SETTING: Review of a prevailing model of graph comprehension and survey of authors' instructions for all 120 core medical journals as indexed by PubMed. RESULTS: <b>Graph</b> <b>construction</b> should meet three requirements for optimal graph comprehension: Data symbols should be clearly distinguishable to enable their visual detection. Second, the data should be arranged {{in such a}} way that estimation of values and important relationships in the data is facilitated, and third, there should be a full explanation of all graph elements and of how the data were obtained. Seven journals (5. 8 %) provided recommendations on <b>graph</b> <b>construction.</b> Six journals put emphasis primarily on the explanation of graph elements and, to a lesser extent, on the visual detection of data symbols. Recommendations of the seventh journal focused mostly on how to enhance estimation of important relationships. All journals presented single recommendations whose selection seemed unstructured and not based on key principles of <b>graph</b> <b>construction.</b> CONCLUSION: Medical journals should order their instructions according to the three key aspects of graph constructio...|$|R
5000|$|Pytorch - Python based {{implementation}} of Torch API, allows for dynamic <b>graph</b> <b>construction</b> ...|$|R
3000|$|... can be {{arbitrarily}} large {{from our}} <b>graph</b> <b>construction,</b> the performance ratio can be arbitrarily small.|$|R
5000|$|... 2007 (for 1997): Call <b>Graph</b> <b>Construction</b> in Object-Oriented Languages, David Grove, Greg DeFouw, Jeffrey Dean, and Craig Chambers ...|$|R
40|$|Graph-based Semi-Supervised Learning (SSL) {{methods have}} had {{empirical}} {{success in a}} variety of domains, ranging from natural language processing to bioinformatics. Such methods consist of two phases. In the first phase, a graph is constructed from the available data; in the second phase labels are inferred for unlabeled nodes in the constructed graph. While many algorithms have been developed for label inference, thus far little {{attention has been paid to}} the crucial <b>graph</b> <b>construction</b> phase and only recently has the importance of the <b>graph</b> <b>construction</b> for the resulting success in label inference been recognized. In this report, we shall review some of the recently proposed <b>graph</b> <b>construction</b> methods for graph-based SSL. We shall also present suggestions for future research in this area...|$|R
5000|$|Stage 1: {{assembly}} <b>graph</b> <b>construction.</b> SPAdes employs multisized de Bruijn graph (See below), which detects {{and removes}} bulge/bubble and chimeric reads.|$|R
40|$|Abstract-This study {{presents}} {{a novel approach}} to unsupervised pronunciation grammar generation for nonnative speech recognition. Unsupervised pronunciation grammar generation includes pronunciation variation <b>graph</b> <b>construction,</b> stochastic Markov search and grammar selection. Context-dependent relation and phone broad class information are used for variation <b>graph</b> <b>construction.</b> Confidence measure and co-occurrence frequency are used to select the variants of pronunciation grammar for non-native speech modeling. Experiments show that unsupervised pronunciation grammar generation is suitable {{for the improvement of}} non-native speech recognition. I...|$|R
40|$|International audienceIn this paper, {{we present}} a new {{approach}} to exploring dy- <b>namic</b> <b>graphs.</b> We first propose a new clustering algorithm for dynamic graphs which finds an ideal clustering for each time-step and links the clusters together. The resulting time-varying clusters are then used to define two visual representations. The first view is an overview that shows how clusters evolve over time and provides an interface to find and select interesting time-steps. The second view consists of a node link diagram of a selected time-step which uses the clustering to efficiently define the layout. By using the time-dependant clustering, we ensure the stability of our visualization and preserve user mental map by minimizing node motion, while simultaneously producing an ideal layout for each time step. Also, as the clustering is computed ahead of time, the second view updates in linear time which allows for interactivity even for graphs with upwards {{of tens of thousands of}} nodes...|$|R
5000|$|Hobbs, Arthur M.; Kannan, Lavanya; Lai, Hong-Jian; Lai, Hongyuan; Weng, Guoqing Balanced and 1-balanced <b>graph</b> <b>constructions.</b> Discrete Appl. Math. 158 (2010), no. 14, 1511-1523.|$|R
40|$|The {{first step}} in {{graph-based}} semi-supervised classification is to construct a graph from input data. While the k-nearest neighbor graphs have been the de facto standard method of <b>graph</b> <b>construction,</b> this paper advocates using the less well-known mutual k-nearest neighbor graphs for high-dimensional natural language data. To compare the performance of these two <b>graph</b> <b>construction</b> methods, we run semi-supervised classification methods on both graphs in word sense disambiguation and document classification tasks. The experimental {{results show that the}} mutual k-nearest neighbor graphs, if combined with maximum spanning trees, consistently outperform the k-nearest neighbor graphs. We attribute better performance of the mutual k-nearest neighbor graph to its being more resistive to making hub vertices. The mutual k-nearest neighbor graphs also perform equally well or even better in comparison to the state-of-the-art b-matching <b>graph</b> <b>construction,</b> despite their lower computational complexity. ...|$|R
40|$|We {{investigate}} a graph-based semi-supervised learning approach for labeling semantic components of {{questions such as}} topic, focus, event, etc., for question understanding task. We focus on <b>graph</b> <b>construction</b> to handle learning with dense/sparse graphs and present Relaxed Linear Neighborhoods method, in which each node is linearly constructed from varying sizes of its neighbors based on the density/sparsity of its surrounding. With the new graph representation, we show performance improvements on syntactic and real datasets, primarily due {{to the use of}} unlabeled data and relaxed <b>graph</b> <b>construction.</b> ...|$|R
40|$|AbstractThis paper {{introduces}} the permutation voltage <b>graph</b> <b>construction,</b> {{which is a}} generalization of Gross's ordinary voltage <b>graph</b> <b>construction.</b> It is shown that every covering of a given graph arises from some permutation voltage assignment in a symmetric group and that every regular covering (in the topological sense) arises from some ordinary voltage assignment. These results are related to graph imbedding theory. It is demonstrated that the relationship of permutation voltages to ordinary voltages {{is analogous to the}} relationship of Schreier coset graphs to Cayley graphs...|$|R
40|$|Semi-Supervised Learning (SSL) {{techniques}} {{have become very}} relevant since they require a small set of labeled data. In this scenario, graph-based SSL algorithms provide a powerful framework for modeling manifold structures in high-dimensional spaces and are effective for the propagation of the few initial labels present in training data through the graph. An important step in graph-based SSL methods is the conversion of tabular data into a weighted <b>graph.</b> The <b>graph</b> <b>construction</b> has {{a key role in}} the quality of the classification in graphbased methods. Nevertheless, most of the SSL literature focuses on developing label inference algorithms without studying <b>graph</b> <b>construction</b> methods and its effect on the base algorithm performance. This PhD project aims to study this issue and proposes new methods for <b>graph</b> <b>construction</b> from flat data and improves the performance of the graph-based algorithms. Sao Paulo Research Foundation (FAPESP) (Grant 2011 / 21880 - 3...|$|R
40|$|Existing {{approaches}} to analyzing the asymptotics of graph Laplacians typically assume a well-behaved kernel function with smoothness assumptions. We remove the smoothness assumption and generalize {{the analysis of}} graph Laplacians to include previously unstudied graphs including kNN graphs. We also introduce a kernel-free framework to analyze <b>graph</b> <b>constructions</b> with shrinking neighborhoods in general {{and apply it to}} analyze locally linear embedding (LLE). We also describe how for a given limiting Laplacian operator desirable properties such as a convergent spectrum and sparseness can be achieved choosing the appropriate <b>graph</b> <b>construction.</b> ...|$|R
40|$|This paper {{presents}} {{a new and}} efficient algorithm, ILIGRA, for inverse line <b>graph</b> <b>construction.</b> Given a line graph H, ILIGRA constructs its root graph G with the time complexity being linear {{in the number of}} nodes in H. If ILIGRA does not know whether the given graph H is a line graph, it firstly assumes that H is a line graph and starts its root <b>graph</b> <b>construction.</b> During the root <b>graph</b> <b>construction,</b> ILIGRA checks whether the given graph H is a line graph and ILIGRA stops once it finds H is not a line graph. The time complexity of ILIGRA with line graph checking is linear in the number of links in the given graph H. For sparse line graphs of any size and for dense line graphs of small size, numerical results of the running time show that ILIGRA outperforms all currently available algorithms. Network Architectures & Services (NAS) Electrical Engineering, Mathematics and Computer Scienc...|$|R
5000|$|Each De Bruijn graph is Eulerian and Hamiltonian. The Euler {{cycles and}} Hamiltonian cycles of these graphs (equivalent {{to each other}} via the line <b>graph</b> <b>construction)</b> are De Bruijn sequences.|$|R
3000|$|Keyterm <b>Graph</b> <b>Construction</b> For the keyterms in each cluster, {{we build}} a keyterm graph by {{exploiting}} {{the structure of}} the knowledge graph. The keyterm graph describes the semantic relations among keyterms.|$|R
3000|$|... [*]As a {{comparison}} {{among the different}} <b>graph</b> <b>construction</b> approaches, the adaptive <b>graph</b> <b>construction</b> method obviously outperforms its counterparts. However, no conclusive remark can be drawn between the global and local methods. The global approach performs better than the local approach under view angle changes, but the opposite happens for the clothing and carrying conditions, while almost similar results were obtained for speed variation. As such, we conjecture that the topological structure of the graph has disparate impact on different scenarios. No single graph structure (referring to the global and local graphs) works best for all cases.|$|R
30|$|The semi-supervised K-associated graph, {{proposed}} here, {{consists of}} a modification of the K-associated graph [4] to deal with both labeled and unlabeled data during the <b>graph</b> <b>construction</b> procedure. Therefore, in order to introduce the semi-supervised version, a brief revision of the K-associated graph is presented in Sect.  3.1. It {{is followed by the}} semi-supervised K-associated <b>graph</b> <b>construction</b> presented in detail in Sect.  3.2. Both supervised and semi-supervised K-associated optimal graphs {{can be seen as the}} training process for the KAOG classifier which uses the components of the graph and their purities to classify new data instances, as will be exposed in Sect.  3.3.|$|R
40|$|Abstract. In {{this paper}} we {{introduce}} {{a new class of}} epidemics on networks which we call SI(S/I). SI(S/I) networks differ from SIS networks in allowing an infected individual to become reinfected without first passing to the susceptible state. We use a covering <b>graph</b> <b>construction</b> to compare SIR, SIS, and SI(S/I) networks. Like the SIR networks that cover them, SI(S/I) networks exhibit infection probabilities that are monotone with respect to both transmission probabilities and the initial set of infectives. The same covering <b>graph</b> <b>construction</b> allows us to characterize the recurrent states in a SIS or SI(S/I) network with reinfection. 1...|$|R
40|$|With {{the rapid}} {{development}} of the Internet, nowadays tremendous amounts of data including images and videos, up to millions or billions, can be collected for training machine learning models. Inspired by this trend, this thesis is dedicated to developing large-scale machine learning techniques {{for the purpose of}} making classification and nearest neighbor search practical on gigantic databases. Our first approach is to explore data graphs to aid classification and nearest neighbor search. A graph offers an attractive way of representing data and discovering the essential information such as the neighborhood structure. However, both of the <b>graph</b> <b>construction</b> process and graph-based learning techniques become computationally prohibitive at a large scale. To this end, we present an efficient large <b>graph</b> <b>construction</b> approach and subsequently apply it to develop scalable semi-supervised learning and unsupervised hashing algorithms. Our unique contributions on the graph-related topics include: 1. Large Graph Construction: Conventional neighborhood graphs such as kNN graphs require a quadratic time complexity, which is inadequate for large-scale applications mentioned above. To overcome this bottleneck, we present a novel <b>graph</b> <b>construction</b> approach...|$|R
40|$|The {{analysis}} and verification of higher-order programs raises {{the issue of}} control-flow analysis for higher-order languages. The problem of constructing an accurate call graph for a higher-order program has been the topic of extensive research, and numerous methods for flow analysis, varying in complexity and precision, have been suggested. While termination analysis of higher-order programs has been studied, {{there has been little}} examination of the impact of call <b>graph</b> <b>construction</b> on the precision of termination checking. We examine the effect of various control-flow analysis techniques on a termination analysis for higher-order functional programs. We present a termination checking framework and instantiate this with three call <b>graph</b> <b>constructions</b> varying in precision and complexity, and illustrate by example the impact of the choice of call <b>graph</b> <b>construction.</b> Our second aim is to use the resulting analyses to shed light on the relationship between control-flow analyses. We prove precise inclusions between the classes of programs recognised as terminating by the same termination criterion over different call graph analyses, giving one of the first characterisations of expressive power of flow analyses for higher-order programs...|$|R
40|$|In {{this paper}} we explore the {{relative}} importance of persistent and non-persistent mutex relations in the performance of Graphplan- based planners. We also show the advantages of pre-compiling persistent mutex relations. Using TIM we are able to generate, during a pre-processing analysis, all of the persistent binary mutex relations that would be inferred by Graphplan during each <b>graph</b> <b>construction.</b> We show how the efficient storgae of, and access to, these pre-processed persistent mutexes yields a modest improvement in <b>graph</b> <b>construction</b> performance. We further demonstrate that the process by which these persistent mutexes are identified can, in certain kinds of domain, allow the exploitation of binary mutex relations which are inaccessible to Graphplan. We present The Island of Sodor, a simple planning domain characterizing a class of domains in which certain persistent mutexes are present but are not detectable by Graphplan during <b>graph</b> <b>construction.</b> We show that the exploitation of these hidden binary mutexes makes problems in this kind of domain trivially solvable by STAN, where they are intractable for other Graphplan-based planners...|$|R
40|$|The {{exponential}} {{growth in the}} pursuit of knowledge gleaned from data relationships that are expressed naturally as large and complex graphs is fueling new parallel machine learning algorithms. The nature of these computations is iterative and data-dependent. Recently, frameworks have emerged to perform these computations in a distributed manner at commercial scale. But feeding data to these frameworks is a huge challenge in itself. Since <b>graph</b> <b>construction</b> is a data-parallel problem, Hadoop is well-suited for this task but lacks some elements that would make things easier for data scientists that do not have domain expertise in distributed systems engineering. We developed GraphBuilder, a scalable <b>graph</b> <b>construction</b> software library for Apache Hadoop, to address this gap. GraphBuilder offloads many of the complexities of <b>graph</b> <b>construction,</b> including <b>graph</b> formation, tabulation, compression, transformation, partitioning, output formatting, and serialization. It is written in Java for ease of programming and scales using the MapReduce parallel programming model. We describe the motivation for GraphBuilder, its architecture, and present two case studies that provide a preliminary evaluation. ...|$|R
5000|$|The <b>graph</b> <b>construction</b> {{makes use}} of a {{component}} that is treated as a [...] "black box." [...] To keep the explanation simple, the properties of this component are given without actually defining {{the structure of the}} component.|$|R
40|$|Graph-based semi-supervised {{learning}} has recently {{emerged as a}} promising approach to data-sparse learning problems in natural language processing. All graph-based algorithms rely on a graph that jointly represents labeled and unlabeled data points. The {{problem of how to}} best construct this graph remains largely unsolved. In this paper we introduce a data-driven method that optimizes the representation of the initial feature space for <b>graph</b> <b>construction</b> by means of a supervised classifier. We apply this technique in the framework of label propagation and evaluate it on two different classification tasks, a multi-class lexicon acquisition task and a word sense disambiguation task. Significant improvements are demonstrated over both label propagation using conventional <b>graph</b> <b>construction</b> and state-of-the-art supervised classifiers. ...|$|R
40|$|In object {{oriented}} programming, a Call Graph represents the calling {{relationships between the}} program’s methods. To be more precise, a Call Graph is a rooted directed graph where each node of the graph represents a method and each edge (u, v) represents a method call from method u to method v. Focus of this thesis is on building a framework for Call <b>Graph</b> <b>construction</b> algorithms {{which can be used}} in program analysis. Our framework is able to be initialized by different front-ends and constructs various Call Graph algorithms. Here, we instantiate framework with two bytecode readers (ASM and Soot) as front-ends and implement three Call <b>Graph</b> <b>construction</b> algorithms (CHA, RTA and CTA). At first, we used two above mentioned bytecode readers to read the bytecode of a specific Java program, then we found reachable methods for each invoked method; meanwhile we kept obtained details on our own data structures.   Creating data structures for storing required information about Classes, Methods, Fields and Statements, gives us a great opportunity to implement an independent framework for applying well known Call Graph algorithms. As a result of these data structures, Call <b>Graph</b> <b>construction</b> will not depend on bytecode readers; since, whenever we read the bytecode of a program, we accumulate all necessary points in pre-defined data structures and implement our Call Graphs based on this accumulated data. Finally, the result is a framework for different Call <b>Graph</b> <b>construction</b> algorithms which is the goal of this thesis. We tested and evaluated the algorithms with a variety of programs as the benchmark and compared the bytecode readers besides the three Call Graph algorithms in different aspects...|$|R
40|$|A <b>graph</b> <b>construction</b> that {{produces}} a k-regular graph on n vertices for any choice of k >= 3 and n = m(k+ 1) for integer m >= 2 is described. The number of Hamiltonian cycles in such graphs can be explicitly determined {{as a function of}} n and k, and empirical evidence is provided that suggests that this function gives a tight upper bound on the minimum number of Hamiltonian cycles in k-regular graphs on n vertices for k >= 5 and n >= k + 3. An additional <b>graph</b> <b>construction</b> for 4 -regular graphs is described for which the number of Hamiltonian cycles is superior to the above function in the case when k = 4 and n >= 11...|$|R
40|$|Abstract—Semi-supervised {{dimensionality}} {{reduction is}} very important in mining high-dimensional data {{due to the lack of}} costly labeled data. This paper studies the Semi-supervised Dis-criminant Analysis (SDA) algorithm, which aims at dimension-ality reduction utilizing both limited labeled data and abundant unlabeled data. Different from other relative work, we pay our attention to <b>graph</b> <b>construction,</b> which plays a key role in graph based SSL methods. Inspired by the advances of compressive sensing, we propose a novel <b>graph</b> <b>construction</b> method via group sparsity,which means to constrain the reconstruct data to be sparse for each sample, and constrain the representation in each class to be quite similar. Experimental results show that our method can significantly improve the performance of SDA, and outperform state-of-the-art methods. Keywords-semi-supervised learning; graph construction; s-parsest representation; I...|$|R
40|$|De Bruijn <b>graph</b> <b>construction</b> {{is a basic}} {{component}} in de novo genome assembly for short reads generated from the second-generation sequencing machines. As this component processes {{a large amount of}} data and performs intensive computation, we propose to use the GPU (Graphics Processing Unit) for acceleration. Specifically, we propose a staged algorithm to utilize the GPU for computation over large data sets that do not fit into the GPU memory. We also pipeline the I/O, GPU, and CPU processing to further improve the overall performance. Our preliminary results show that our GPU-accelerated <b>graph</b> <b>construction</b> on an NVIDIA S 1070 server achieves a speedup of around two times over previous performance results on a 1024 -node IBM Blue Gene/L. © 2013 Springer-Verlag...|$|R
40|$|Inference Driven Metric Learning (IDML) for <b>Graph</b> <b>Construction</b> Graph-based semi-supervised {{learning}} (SSL) methods usually {{consist of}} two stages: {{in the first}} stage, a graph is constructed from the set of input instances; {{and in the second}} stage, the available label information along with the constructed graph is used to assign labels to the unlabeled instances. Most of the previously proposed <b>graph</b> <b>construction</b> methods are unsupervised in nature, as they ignore the label information already present in the SSL setting in which they operate. In this paper, we explore how available labeled instances can be used to construct a better graph which is tailored to the current classification task. To achieve this goal, we evaluate effectiveness of various supervised metric learning algorithms during <b>graph</b> <b>construction.</b> Additionally, we propose a new metric learning framework: Inference Driven Metric Learning (IDML), which extends existing supervised metric learning algorithms to exploit widely available unlabeled data during the metric learning step itself. We provide extensive empirical evidence demonstrating that inference over graph constructed using IDML learned metric can lead to significant reduction in classification error, compared to inference over graphs constructed using existing techniques. Finally, we demonstrate how active learning can be successfully incorporated within the the IDML framework to reduc...|$|R
