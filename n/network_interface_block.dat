0|4352|Public
40|$|<b>Network</b> <b>interface</b> <b>blocks</b> {{are basic}} {{part of the}} NetCOPE {{platform}} where they help to the network application designers to deal with problems of implementing the Data Link Layer of the OSI Reference Model, especially the MAC sublayer. This thesis {{is focused on the}} design and implementation of such <b>network</b> <b>interface</b> <b>blocks</b> operating at speed 10 Gb/s. Designed input <b>interface</b> <b>block</b> provides checking of several parts of the Ethernet frame and allows discarding of this frame based on checking results. Output <b>interface</b> <b>block</b> supports replacing frame's Source Address by a pre-set value and provides frame's CRC computation. Both <b>network</b> <b>interface</b> <b>blocks</b> also include a set of frames counters. Implemented <b>network</b> <b>interface</b> <b>blocks</b> were tested on the COMBO card. SystemVerilog verification testbench was also designed for both <b>network</b> <b>interface</b> <b>blocks...</b>|$|R
50|$|Split 50 66 blocks {{are still}} used as <b>network</b> <b>interface</b> <b>blocks</b> in {{distribution}} frames to interconnect circuits with bridging clips, but are primarily limited to narrowband circuits such as POTS/DSL, DS0, or DS1 circuits.|$|R
50|$|To {{enable the}} VoIP communications, the SIP/RTP packets should be {{utilised}} and STUN client {{would be the}} key component for VoIP communications with management of the SIP/RTP packets. A Session Traversal Utilities for NAT (STUN) client is used on some SIP-based VoIP phones as firewalls on <b>network</b> <b>interface</b> sometimes <b>block</b> SIP/RTP packets. Some special mechanism is required in this case to enable routing of SIP packets from one network to other. STUN is used {{in some of the}} sip phones to enable the SIP/RTP packets to cross boundaries of two different IP networks. A packet becomes unroutable between two sip elements if one of the networks uses private IP address range and other is in public IP address range. Stun is a mechanism to enable this border traversal. There are alternate mechanisms for traversal of NAT, STUN is just one of them. STUN or any other NAT traversal mechanism is not required when the two SIP phones connecting are routable from each other and no firewall exists in between.|$|R
40|$|Realization of the economical, reliable, and {{efficient}} ATM <b>interface</b> <b>block</b> becomes an important key to {{development of the}} ATM switching system when we consider new issues raised recently. In this paper, we summarize requirements for the ATM <b>interface</b> <b>block</b> and present the UNI (User <b>Network</b> <b>Interface)</b> /NNI (<b>Network</b> Node <b>Interface)</b> architecture to meet these requirements. We also evaluate {{the performance of the}} multiplexer adopting the various multiplexing schemes and service disciplines. For ATM UNI/NNI interface technologies, we have developed a new policing device using the priority encoding scheme. It can reduce the decision time for policing significantly. We have also designed a new spacer that can space out the clumped cell stream almost perfectly. This algorithm guarantees more than 99 % conformance to the negotiated peak cell rate. Finally, we propose the interface architecture for accommodation of the ABR (Available Bit Rate) transfer capability. The proposed structure that perf [...] ...|$|R
40|$|International audienceThis work {{is devoted}} to {{numerical}} analysis of permeability in rocks with multiple fractures. We propose a discrete approach for porous media with dual porosity. The intact porous rock is first discretized by an assembly of impermeable blocks according to the Voronoi diagram. The pore space of the intact rock is replaced by an equivalent <b>network</b> of <b>interfaces</b> between <b>blocks,</b> which produces the same macroscopic hydraulic conductivity as the intact rock. An induced network of macroscopic fracture or cracks is then introduced into the discrete porous rock. A specific numerical algorithm is developed to solve the obtained dual-porosity discrete porous medium. A series of numerical studies are performed in order to verify {{the efficiency of the}} proposed method and to investigate influences of mesh sensitivity, effects of fracture geometry and distribution. The proposed model is then applied to the study of permeability evolution in rock samples submitted to biaxial compression tests with different confining pressures. It is found that the proposed model is able to correctly reproduce the progressive process of initiation and propagation of fractures and the related evolution of permeability...|$|R
40|$|The IEC 61499 {{standard}} provides {{means to}} specify {{distributed control systems}} in terms of function blocks. For the deployment, each device may hold one or many logical resources, each consisting of a function <b>block</b> <b>network</b> with service <b>interface</b> <b>blocks</b> at the edges. The execution model is event driven (asynchronous), where triggering events {{may be associated with}} data (and seen as a message). In this paper we propose a low complexity implementation technique allowing to asses end-to-end response time of event chains spanning a networked devices. Based on a translation of IEC 61499 to RTFM-tasks and resources, the response time for each task in the system can be derived using established scheduling techniques. In this paper we develop a method to provide safe end-to-end response time taking both intra- and inter-device delivery delays into account. As a use case we study the implementation onto (single-core) ARMcortex based devices communicating over a switched Ethernet network. For the analysis we deﬁne a generic switch model, and an experimental setup allowing us to study the impact of network topology as well as 802. 1 Q quality of service in a mixed critical setting. Our results indicate that safe sub milli-second end-to-end response times can be obtained using the proposed approach. Validerad; 2016; Nivå 1; 20150917 (maalin) </p...|$|R
50|$|Generically, an NID {{may also}} be called a <b>network</b> <b>interface</b> unit (NIU), {{telephone}} <b>network</b> <b>interface</b> (TNI), system <b>network</b> <b>interface</b> (SNI), or telephone network box.|$|R
50|$|A virtual <b>network</b> <b>interface</b> (VIF) is an {{abstract}} virtualized {{representation of a}} computer <b>network</b> <b>interface</b> {{that may or may}} not correspond directly to a <b>network</b> <b>interface</b> controller.|$|R
40|$|Networking servers, such as web servers, {{have been}} widely {{deployed}} in recent years. While developments in the operating system and applications continue to improve server performance, programmable <b>network</b> <b>interfaces</b> with local memory provide new opportunities to improve server performance through extended network services on the <b>network</b> <b>interface.</b> However, due to their embedded nature, programmable processors on the <b>network</b> <b>interface</b> may suffer from inadequate processing power when compared to non-programmable application-specific <b>network</b> <b>interfaces.</b> This thesis first shows that exploiting a multiprocessor architecture and task-level concurrency in <b>network</b> <b>interface</b> processing enables programmable <b>network</b> <b>interfaces</b> to overcome the performance disadvantages over application-specific <b>network</b> <b>interfaces</b> that result from programmability. Then, the thesis presents a network service on a programmable <b>network</b> <b>interface</b> that exploits the storage capacity of the interfaces to alleviate the local I/O interconnect bottleneck, thereby improving server performance. Thus, these two results show that programmable <b>network</b> <b>interfaces</b> can offset the performance disadvantages due to programmability and improve networking server performance through extended network services that exploit their computation power and storage capacity...|$|R
40|$|TCP offload is a {{technique}} to improve TCP/IP networking performance of a network com-puter system by moving (parts of) TCP processing from the host processor to the <b>network</b> <b>interface.</b> There {{are several ways to}} achieve offload. The typical full offload moves all TCP functionalities to the <b>network</b> <b>interface,</b> and TCP processing is performed exclusively on the <b>network</b> <b>interface.</b> However, when the <b>network</b> <b>interface</b> has limited processing power, full offload creates a bottleneck at the <b>network</b> <b>interface</b> and degrades system performance. In contrast, TCP offload based on connection handoff allows the operating system to move a subset of connections to the <b>network</b> <b>interface.</b> This way, both the host processor and the <b>network</b> <b>interface</b> perform TCP processing, and the operating system can control the amount of work performed on the host processor and the <b>network</b> <b>interface.</b> Thus, by us-ing connection handoff, the system can fully utilize the processing power of the <b>network</b> <b>interface</b> without creating a bottleneck in the system. This dissertation presents a design, implementation, and evaluations of handoff-based TCP offload. The design enables the application to transparently exploit offload-capabl...|$|R
50|$|A <b>network</b> <b>interface</b> {{controller}} (NIC, {{also known}} as a <b>network</b> <b>interface</b> card, <b>network</b> adapter, LAN adapter or physical <b>network</b> <b>interface,</b> and by similar terms) is a computer hardware component that connects a computer to a computer network.|$|R
5000|$|... the {{corresponding}} dummy argument specification defines only {{the type and}} rank of the array, not its shape. This information {{has to be made}} available by an explicit interface, often using an <b>interface</b> <b>block</b> (see <b>Interface</b> <b>blocks).</b> Thus we write just ...|$|R
50|$|<b>Network</b> <b>interface</b> - Has API for socket-based <b>network</b> <b>interface,</b> {{including}} IPv6 if the OS supports it.|$|R
5000|$|<b>Network</b> <b>interface</b> layer. The <b>network</b> <b>interface</b> {{layer is}} {{responsible}} for accepting IP datagrams and transmitting them over a specific <b>network.</b> A <b>network</b> <b>interface</b> may consist of a device driver or a complex subsystem that uses its own data link protocol.|$|R
40|$|Distributed-memory {{systems have}} {{traditionally}} had great difficulty performing network I/O at rates proportional to their computational power. The {{problem is that}} the <b>network</b> <b>interface</b> has to support network I/O for a supercomputer, using computational and memory bandwidth resources similar to those of a workstation. As a result, the <b>network</b> <b>interface</b> becomes a bottleneck. We implemented an architecture for network I/O for the iWarp system with the following two key characteristics: first, application-specific tasks are off-loaded from the <b>network</b> <b>interface</b> to the distributed-memory system, and second, these tasks are performed in close cooperation with the application. The <b>network</b> <b>interface</b> has been used by several applications for over a year. In this paper we describe the <b>network</b> <b>interface</b> software that manages the communication between the iWarp distributed-memory system and the <b>network</b> <b>interface,</b> we validate the main features of our <b>network</b> <b>interface</b> architecture based on applicati [...] ...|$|R
5000|$|... #Caption: An ATM <b>network</b> <b>interface</b> in {{the form}} of an {{accessory}} card. A lot of <b>network</b> <b>interfaces</b> are built-in.|$|R
40|$|Networking servers, such as web servers, {{have been}} widely {{deployed}} in recent years. While developments in the operating system and applications continue to improve server performance, programmable <b>network</b> <b>interfaces</b> with local memory provide new opportunities to improve server performance through extended network services on the <b>network</b> <b>interface.</b> However, due to their embedded nature, programmable processors on the <b>network</b> <b>interface</b> may suffer from inadequate processing power when compared to non-programmable application-specific <b>network</b> <b>interfaces...</b>|$|R
40|$|This paper {{proposes a}} novel <b>network</b> <b>interface</b> design method, {{referred}} to as mutual interface definition based method. It decouples resource dependent part (RDP) from resource independent part (RIP) by mutual interface definition. These two parts can be designed independently, thus the design flexibility and reusability of <b>network</b> <b>interface</b> can be enhanced. Moreover, a <b>network</b> <b>interface</b> component library consisting of multiple RDP and RIP components is proposed to be built. The networks-on-chip designers can choose appropriate components from the library to construct <b>network</b> <b>interface</b> design. From the perspective of RDP, the <b>network</b> <b>interface</b> achieves backward compatibility with the existing protocols such as AMBA AHB and OCP. From the perspective of RIP, the <b>network</b> <b>interface</b> provides a configurable structure supporting multicast transfer and adaptive routing algorithm extensions. The proposed <b>network</b> <b>interface</b> designs are implemented in TSMC 90 -nm CMOS standard cell technology and can work at the frequency of 1. 12 GHz to 1. 35 GHz...|$|R
5000|$|... 380Z <b>Network</b> <b>Interface</b> Board (380Z-NET) - a {{proprietary}} 800 kbit/s <b>network</b> <b>interface</b> used to interconnect {{to a network}} of LINK 480Zs.|$|R
40|$|We {{describe}} and evaluate a quad 100 T ethernet <b>network</b> <b>interface</b> built using an Intel IXP 1200 network processor on a commonly available Radisys ENP 2505 PCI board. The <b>network</b> <b>interface</b> exports a raw ethernet interface {{either to the}} host kernel or to user level for cluster computing applications. We describe the firmware architecture and internal design decisions, then evaluate the resulting <b>network</b> <b>interface</b> against 100 T and gigabit <b>network</b> <b>interfaces</b> using CLF, a lightweight reliable datagram layer...|$|R
5000|$|... <b>interface</b> <b>blocks</b> (another scoping unit, see Interface blocks); ...|$|R
50|$|More precisely, if {{a device}} has several <b>network</b> <b>{{interface}}s,</b> then each interface must {{have at least}} one distinct IP address assigned to it. For example, a laptop might have a wireless <b>network</b> <b>interface</b> and a wired <b>network</b> <b>interface</b> using a <b>network</b> cable, and this would require a total of two IP addresses, one per interface. Another example is a mobile phone with a 3G <b>network</b> <b>interface</b> and an interface to a wireless LAN. All routers have to have several <b>network</b> <b>interfaces</b> and typically will have several IP addresses associated with them. It is also possible that an interface can be assigned more than one IP address for various reasons.|$|R
40|$|This paper {{presents}} three {{policies for}} effectively utilizing TCP offload <b>network</b> <b>interfaces</b> that support connection handoff. These policies allow connection handoff {{to reduce the}} computation and memory bandwidth requirements for packet processing on the host processor without causing the resource constraints on the <b>network</b> <b>interface</b> to limit overall system performance. First, prioritizing packet processing on the <b>network</b> <b>interface</b> ensures that its TCP processing does not harm performance of the connections on the host operating system. Second, dynamically adapting the number of connections on the <b>network</b> <b>interface</b> to the current load avoids overloading the <b>network</b> <b>interface.</b> Third, the operating system can predict connection lifetimes to select long-lived connections for handoff to better utilize the <b>network</b> <b>interface.</b> The use {{of the first two}} policies improves web server throughput by 12 – 31 % over the baseline throughput achieved without offload. The third policy helps improve performance when the <b>network</b> <b>interface</b> can only handle a small number of connections at a time. Furthermore, by using a faster offload processor, offloading can improve server throughput by 33 – 72 %. ...|$|R
40|$|In {{this paper}} {{we present a}} <b>network</b> <b>interface</b> for an on-chip <b>network.</b> Our <b>network</b> <b>interface</b> decouples {{computation}} from communication by offering a shared-memory abstraction, which is independent of the network implementation. We use a transactionbased protocol to achieve backward compatibility with existing bus protocols such as AXI, OCP and DTL. Our <b>network</b> <b>interface</b> has a modular architecture, which allows flexible instantiation. It provides both guaranteed and best-effort services via connections. These are configured via <b>network</b> <b>interface</b> ports using the network itself, instead of a separate control interconnect. An example instance of this <b>network</b> <b>interface</b> with 4 ports has an area of 0. 143 mm 2 in a 0. 13 µm technology, and runs at 500 MHz. ...|$|R
40|$|Nodes in the Grid can be {{connected}} through a multi-gigabit network. However, the <b>network</b> <b>interfaces</b> in the nodes {{can become a}} bottleneck for the maximum achievable bandwidth among nodes. This paper proposes an extensible communication architecture to avoid {{the limitations of the}} <b>network</b> <b>interfaces</b> by integrating multiple <b>network</b> <b>interfaces</b> in each node. The proposed solution deploys a technique to balance the network traffic load among multiple <b>network</b> <b>interfaces</b> in a single node. While this technique enhances communication bandwidth among the nodes, it is distributed and does not require any coordination or reservation mechanisms. It achieves the maximum possible bandwidth between any pair of Grid nodes with multiple <b>network</b> <b>interfaces.</b> The experimental evaluation provided good results and demonstrated the benefits of the proposed architecture. 1...|$|R
50|$|A {{wireless}} connection operates at two levels: the wireless <b>network</b> <b>interface</b> (WLAN) and the interface driver executing {{on the platform}} host. The <b>network</b> <b>interface</b> manages the RF communications connection.|$|R
40|$|Abstract. We {{present in}} this paper a <b>network</b> <b>interface</b> {{aggregation}} frame-work for IP tunneling. Our framework periodically measures the level of congestion on routes going through each <b>network</b> <b>interface</b> and based on these measurements, it decides how many flows to send on an outgoing <b>network</b> <b>interface</b> at a time. In this way, we can achieve better inter-flow fairness regarding bandwidth utilization...|$|R
5000|$|... netfilter {{provides}} a state-full packet filter {{which can be}} configured according to <b>network</b> <b>interface,</b> protocol, source and/or destination address, source and/or destination port {{and the state of}} the packet. A network packet traverses several chains between the time it is received by a <b>network</b> <b>interface</b> and the time it is accepted by the host or forwarded to another host. The common chains are INPUT, OUTPUT and FORWARD. The INPUT chain is traversed for all packets as they are received by a <b>network</b> <b>interface,</b> regardless of whether they are to be accepted by the host or forwarded to another host. The OUTPUT chain is traversed for all packets as they are transmitted by a <b>network</b> <b>interface.</b> The FORWARD chain is traversed for those packets are being routed through the host from one <b>network</b> <b>interface</b> to another, such as is the case for a multi-homed system (a system with more than one physical <b>network</b> <b>interface).</b>|$|R
50|$|The {{node number}} {{is used to}} address an {{individual}} computer (or more exactly, a <b>network</b> <b>interface)</b> in the <b>network.</b> Client stations use its <b>network</b> <b>interface</b> card MAC address as the node number.|$|R
5000|$|The <b>Network</b> Driver <b>Interface</b> Specification (NDIS) is an {{application}} programming <b>interface</b> (API) for <b>network</b> <b>interface</b> cards (NICs).|$|R
30|$|Many modern {{portable}} devices have multiple <b>network</b> <b>interfaces</b> {{to communicate with}} different devices. For instance, many portable computers can use more than one NIC (wireless <b>network</b> <b>interface</b> card) to connect with different wireless/heterogeneous networks.|$|R
50|$|Some older {{entertainment}} devices may not feature the appropriate <b>network</b> <b>interfaces</b> required for home network connectivity. In some situations, USB dongles and PCI <b>Network</b> <b>Interface</b> Cards are available as accessories that enable this functionality.|$|R
50|$|By default, {{interface}} {{names are}} dynamic, and each network adapter is assigned the first available name (eth0, eth1...) while the order <b>network</b> <b>interfaces</b> are created may vary. Now ifrename allows {{the user to}} decide what name a <b>network</b> <b>interface</b> will have. It can {{use a variety of}} selectors to match interface names to the <b>network</b> <b>interfaces</b> on the system, the most common selector is the interface MAC address.|$|R
50|$|The host {{has several}} <b>network</b> <b>{{interface}}s.</b> eth0 is the interface {{name of the}} <b>network</b> <b>interface</b> card representing an Ethernet port. ppp0 is a PPPoE interface, which is configured as the default route in this example.|$|R
5000|$|An {{example of}} a module {{containing}} a type definition, <b>interface</b> <b>block</b> and function subprogram is ...|$|R
40|$|Most {{multicast}} algorithms {{proposed in}} the literature assume an arbitrarily long message being communicated as a single packet. Modern networks typically limit {{the size of the}} largest packet, and long messages are packetized and transmitted. Such networks also provide <b>network</b> <b>interface</b> support for nodes, which typically includes a coprocessor and memory, to implement the lower layers of the communication protocol. Such <b>network</b> <b>interfaces</b> can be programmed to support efficient multicasting to eliminate software overhead for higher layers during absorb and retransmit. In this paper, we present an optimal multicast algorithm for systems with such smart <b>network</b> <b>interface</b> support for packetization. Two implementations of smart <b>network</b> <b>interface,</b> the First-Child-First-Served (FCFS) and the First-Packet-First-Served (FPFS), are studied and compared. It is shown that the FPFS <b>network</b> <b>interface</b> support is more practical and efficient. Next, the multicast latency is modeled for the FPFS impleme [...] ...|$|R
