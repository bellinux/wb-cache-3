2|9|Public
5000|$|... 0003 NOOP 00 0000 0000 <b>No-operation</b> <b>{{instruction}},</b> next {{instruction address}} is 0000 0000 HALT 01 0000 8000 Halt, next instruction address is the console (this Halt instruction was stored in 0000 by the STD instruction above) ...|$|E
50|$|However, {{consider}} the following instructions: LD adr -> r10 AND r10,r3 -> r11The data read from the address adr isn't present in the data cache until after the Memory Access stage of the LD instruction. By this time, the AND instruction is already through the ALU. To resolve this would require the data from memory to be passed backwards {{in time to the}} input to the ALU. This is not possible. The solution is to delay the AND instruction by one cycle. The data hazard is detected in the decode stage, and the fetch and decode stages are stalled - they are prevented from flopping their inputs and so stay in the same state for a cycle. The execute, access, and write-back stages downstream see an extra <b>no-operation</b> <b>instruction</b> (NOP) inserted between the LD and AND instructions.|$|E
2500|$|For example, on the IA-32 architecture, here's how two NOP (<b>no-operation)</b> <b>instructions</b> would look, first unencoded: ...|$|R
5000|$|In {{computer}} security, a NOP slide, NOP sled or NOP ramp is {{a sequence}} of NOP (<b>no-operation)</b> <b>instructions</b> meant to [...] "slide" [...] the CPU's instruction execution flow to its final, desired destination whenever the program branches to a memory address anywhere on the slide.|$|R
5000|$|For example, on the IA-32 architecture, here's how two [...] (<b>no-operation)</b> <b>instructions</b> would look, first unencoded: 90 NOP 90 NOPThen encoded into {{a string}} using percent-encoding (using the [...] {{function}} to decode): unescape("%u9090");Next encoded into a string using [...] "\uXXXX"-encoding: [...] "\u9090";And finally encoded into a string using entity encoding: [...] "&#x9090;"or [...] "&#37008;" ...|$|R
25|$|The use of deep packet {{inspection}} (DPI) can detect, at {{the network}} perimeter, very basic remote attempts to exploit buffer overflows by use of attack signatures and heuristics. These are able to block packets which have the signature of a known attack, or if {{a long series of}} <b>No-Operation</b> <b>instructions</b> (known as a NOP-sled) is detected, these were once used when the location of the exploit's payload is slightly variable.|$|R
30|$|Another approach, {{to reduce}} the spatial {{complexity}} of instruction-level power models is presented in [25]. Therein, interinstruction effects have been measured by considering only the additional energy consumption observed when a generic instruction is executed after a <b>no-operation</b> (NOP) <b>instruction.</b>|$|R
5000|$|Operate [...] - [...] increment/decrement register, ones {{complement}} register, negate (twos-complement) register, move register to register, move console switches to register, increment register and skip on test. All the above operate instructions used {{one or more}} of registers A, B, or C. There were also wait and a <b>no-operation</b> operate <b>instructions.</b>|$|R
40|$|The {{problem of}} {{correctly}} recovering assembly instructions from a binary has received much attention and both malware and license validation code often relies on various anti-disassembly techniques {{in order to}} complicate analysis. One well-known anti-disassembly technique is to use overlapping code such that the disassembler starts decoding from an incorrect byte, but still recovers valid code. The actual code {{which is supposed to}} be executed is instead hidden inside a decoy instruction, and is overlapped with the disassembled code. We propose and investigate a new novel anti-disassembly method that allows for exceptional flexibility in the hidden instructions, {{while at the same time}} providing a disassembled main path that is executable. This allows the approach to be very efficient against static linear sweep disassembly, but also to be more difficult to detect using dynamic analysis methods. The idea is to utilize highly redundant instructions, e. g., multibyte <b>no-operation</b> <b>instructions,</b> and embed the hidden code in the configurable portions of those instructions. By carefully selecting wrapping instructions, providing overlaps, the hidden execution path can be crafted with great flexibility. We also provide a detection-algorithm, together with testing results, for testing software such that the hidden execution path can be identified...|$|R
50|$|With NOP-Fills, the {{reliability}} of a system {{in case of a}} disturbed instruction pointer can be improved in some cases. The entire program memory that is not used by the program code is filled with <b>No-Operation</b> (NOP) <b>instructions.</b> In machine code a NOP instruction is often represented by 0x00 (for example, Intel 8051, ATmega16, etc.). The system is kept in a defined state. At the end of the physical program memory, an instruction pointer error handling (IPEH IP-Error-Handler) has to be implemented. In some cases this can be a simple reset.|$|R

