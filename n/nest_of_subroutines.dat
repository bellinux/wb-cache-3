0|10000|Public
50|$|Fortran, {{starting}} with Fortran-90, supports a single level <b>of</b> <b>nested</b> (CONTAINed) <b>subroutines</b> and functions.|$|R
40|$|Abstract In Java bytecode, intra-method subroutines are {{employed}} to represent code in &quot;finally&quot;blocks. The use <b>of</b> such polymorphic <b>subroutines</b> within a method makes bytecode analysis very difficult. Fortunately, such subroutines can be eliminated through recompilation orinlining. Inlining {{is the obvious}} choice since {{it does not require}} changing compilers or access to the source code. It also allows transformation of legacy bytecode. However, thecombination <b>of</b> <b>nested,</b> non-contiguous <b>subroutines</b> with overlapping exception handlers poses a difficult challenge. This paper presents an algorithm that successfully solves allthese problems without producing superfluous instructions...|$|R
40|$|AbstractIn Java bytecode, intra-method subroutines are {{employed}} to represent code in “finally” blocks. The use <b>of</b> such polymorphic <b>subroutines</b> within a method makes bytecode analysis very difficult. Fortunately, such subroutines can be eliminated through recompilation or inlining. Inlining {{is the obvious}} choice since {{it does not require}} changing compilers or access to the source code. It also allows transformation of legacy bytecode. However, the combination <b>of</b> <b>nested,</b> non-contiguous <b>subroutines</b> with overlapping exception handlers poses a difficult challenge. This paper presents an algorithm that successfully solves all these problems without producing superfluous instructions. Furthermore, inlining can be combined with bytecode simplification, using abstract bytecode. We show how this abstration is extended to the full set of instructions and how it simplifies static and dynamic analysis...|$|R
5000|$|Some {{programming}} languages (e.g., Pascal and Ada) support declaration <b>of</b> <b>nested</b> <b>subroutines,</b> {{which are}} allowed to access {{the context of their}} enclosing routines, i.e., the parameters and local variables within the scope of the outer routines. Such static nesting can repeat - a function declared within a function declared within a function... The implementation must provide a means by which a called function at any given static nesting level can reference the enclosing frame at each enclosing nesting level. Commonly this reference is implemented by a pointer to the frame of the most recently activated instance of the enclosing function, called a [...] "downstack link" [...] or [...] "static link", to distinguish it from the [...] "dynamic link" [...] that refers to the immediate caller (which need not be the static parent function).|$|R
40|$|Chip Multiprocessors (CMPs) are flexible, {{high-frequency}} platforms {{on which}} to support Thread-Level Speculation (TLS). However, for TLS to deliver on its promise, CMPs must exploit multiple sources of speculative task-level parallelism, including any <b>nesting</b> levels <b>of</b> both <b>subroutines</b> and loop iterations. Unfortunately, these environments are hard to support in decentralized CMP hardware: since tasks are spawned out-of-order and unpredictably, maintaining key TLS basics such as task ordering and efficient resource allocation is challenging. While the concept of out-of-order spawning is not new, this paper {{is the first to}} propose a set of microarchitectural mechanisms that, altogether, fundamentally enable fast TLS with out-of-order spawn in a CMP. Moreover, we develop a fully-automated TLS compiler for aggressive out-of-order spawn. With our mechanisms, a TLS CMP with 4 4 -issue cores achieves an average speedup of 1. 30 for full SpecInt 2000 applications; the corresponding speedup for in-order-only spawn is 1. 04. Overall, our mechanisms unlock the potential of TLS for the toughest applications. ...|$|R
40|$|This chapter {{sketches}} in {{very general}} terms the cognitive architecture of both language comprehension and production, {{as well as}} the neurobiological infrastructure that makes the human brain ready for language. Focus is on spoken language, since that compares most directly to processing music. It is worth bearing in mind that humans can also interface with language as a cognitive system using sign and text (visual) as well as Braille (tactile); that is to say, the system can connect with input/output processes in any sensory modality. Language processing consists of a complex and <b>nested</b> set <b>of</b> <b>subroutines</b> to get from sound to meaning (in comprehension) or meaning to sound (in production), with remarkable speed and accuracy. The fi rst section outlines a selection of the major constituent operations, from fractionating the input into manageable units to combining and unifying information in the construction of meaning. The next section addresses the neurobiological infrastructure hypothesized to form the basis for language processing. Principal insights are summarized by building on the notion of “brain networks” for speech–sound processing, syntactic processing, and the construction of meaning, bearing in mind that such a neat three-way subdivision overlooks important overlap and shared mechanisms in the neural architecture subserving language processing. Finally, in keeping with the spirit of the volume, some possible relations are highlighted between language and music that arise from the infrastructure developed here. Our characterization of language and its neurobiological foundations is necessarily selective and brief. Our aim is to identify for the reader critical questions that require an answer to have a plausible cognitive neuroscience of language processing...|$|R
50|$|Since these {{holistic}} problem models {{could be}} independently automated and solved {{due to this}} closure, they could be blended into higher wholes by <b>nesting</b> one inside <b>of</b> another, in the manner <b>of</b> <b>subroutines.</b> And users could regard {{them as if they}} were ordinary subroutines.|$|R
5000|$|To save space, programmers {{squeezed}} the lists <b>of</b> <b>subroutine</b> calls into simple lists <b>of</b> <b>subroutine</b> addresses, {{and used a}} small loop to call each subroutine in turn. For example: ...|$|R
40|$|On the {{mainframe}} {{there is}} a library <b>of</b> <b>subroutines</b> for mathematical physics. Many <b>of</b> the <b>subroutines</b> have been translated from FORTRAN into classic BASIC. They make a showcase <b>of</b> <b>subroutines</b> which compute special functions interpolate data and do matrix arithmetic. The showcase is {{under the control of}} True BASIC on a Macintosh Classic II computer from which it can be distributed on disk to other computer...|$|R
50|$|Yet semantically, this {{mathematical}} blending was considerably {{more complex than}} the mechanics <b>of</b> <b>subroutines,</b> because an iterative solution engine was attached to each problem model by its calling operator template above it in the program hierarchy. In its numerical solution process, this engine would take control and would call the problem model subroutine iteratively, not returning to the calling template until its system problem was solved. During some or maybe all of the iterative model-subroutine calls the engine would invoke automatic differentiation of the formulas in the model holarchy with respect to the model's input-unknowns (arguments) defined in the calling template. Additional mechanisms were performed in the semantics to accommodate ubiquitous <b>nesting</b> <b>of</b> these holistic models.|$|R
5000|$|Control {{abstraction}} {{involves the}} use <b>of</b> <b>subroutines</b> and control flow abstractions ...|$|R
50|$|GNU libiberty is a {{software}} library with a collection <b>of</b> <b>subroutines</b> used by various GNU programs.|$|R
50|$|In the {{compiling}} method called threaded code, the {{executable program}} {{is basically a}} sequence <b>of</b> <b>subroutine</b> calls.|$|R
5000|$|There {{were two}} types <b>of</b> <b>{{subroutine}}.</b> One was entirely written in ARGUS. Here is an example, using the subroutine SUBA: ...|$|R
30|$|Series <b>of</b> <b>subroutines</b> {{were written}} in MatLab to perform the {{simulation}} and discrimination procedures on QDF. Below are the important ones.|$|R
5000|$|... is not. This {{is because}} the actual {{invocation}} <b>of</b> <b>subroutine</b> 11 doesnot occur until after its definition in the first example.|$|R
40|$|The {{superpose}} {{of potential}} flow, it {{was started by}} Prof. Lankin, is very easy method, but we are noticing new meaning of it. Our developments for this method are number of potentials superposed and apply of computers. We are able to be handle a great many number of potentials by appling computers and can simulate usefull forms for fluid machinery. Main purpose of this report is programing systems. We experienced that this method is effective, but it need co-working of many reseachers, during many years. The system has main program which consists <b>of</b> <b>subroutines.</b> The points <b>of</b> the system is change <b>of</b> combinations <b>of</b> <b>subroutines.</b> We can get many potential flows by changing <b>of</b> <b>subroutines.</b> For example, {{if we want to}} get two dimensional flows, we put "the sub. PUSS 2 " in the system. When, we need three dimensional flows, we only replace "the sub. PUSS 2 " with "the sub. PUSS 3 ". The same ideas were used for the graphic subroutines. The system has several kinds <b>of</b> <b>subroutines.</b> They can represent stream lines, pressure and velocity distributions along stream lines and other graphic needs for flows...|$|R
50|$|The SOFA (Standards of Fundamental Astronomy) {{software}} libraries are {{a collection}} <b>of</b> <b>subroutines</b> that implement official International Astronomical Union algorithms for astronomical computations.|$|R
40|$|Computer program PSHFT calculates lifetimes {{of variety}} of {{aircraft}} transmissions. Consists of main program, series <b>of</b> <b>subroutines</b> applying to specific configurations, generic <b>subroutines</b> for analysis <b>of</b> properties <b>of</b> components, <b>subroutines</b> for analysis <b>of</b> system, and common block. Main program selects routines used in analysis and {{causes them to}} operate in desired sequence. Series <b>of</b> configuration-specific <b>subroutines</b> put in configuration data, perform force and life analyses for components (with help <b>of</b> generic component-property-analysis <b>subroutines),</b> fill property array, call up system-analysis routines, and finally print out results of analysis for system and components. Written in FORTRAN 77 (IV) ...|$|R
50|$|An object {{contains}} {{a number of}} data fields, like a record, and also a number <b>of</b> <b>subroutines</b> for accessing or modifying them, called methods.|$|R
50|$|There {{are only}} a few CIF {{statements}} and they fall into one of two categories: geometry or control.The geometry statements are: LAYER to switch mask layers, BOX to draw arectangle, WIRE to draw a path, ROUNDFLASH to draw a circle, POLYGON to draw an arbitraryfigure, and CALL to draw a <b>subroutine</b> <b>of</b> other geometry statements.The control statements are DS to start the definition <b>of</b> a <b>subroutine,</b> DF to finish thedefinition <b>of</b> a <b>subroutine,</b> DD to delete the definition <b>of</b> <b>subroutines,</b> 0 through 9 toinclude additional user-specified information, and END to terminate a CIF file.All of these keywords are usually abbreviated to one or two letters that are unique.|$|R
50|$|A wide {{number of}} {{conventions}} for the coding <b>of</b> <b>subroutines</b> have been developed. Pertaining to their naming, many developers {{have adopted the}} approach that the name <b>of</b> a <b>subroutine</b> should be a verb when it does a certain task, an adjective when it makes some inquiry, and a noun when {{it is used to}} substitute variables.|$|R
40|$|This paper {{presents}} {{a new approach}} to acquire effective modules or function nodes in Genetic Programming (GP). Tree structured chromosome can be handled with GP. The performance of GPs highly depends on the design of primitive functions. The aim {{of this paper is to}} propose a method to determine the primitive function nodes. To overcome these difficulties in the GP, various kinds of method were introduced, Automatically Defined Function(ADF), Module Acquisition(MA) and Collective ADF for subroutine acquisition(COAST), for example. With ADF GPs, function nodes are generated as subroutines automatically. ADF GPs still needs complicated parameter setting, the numbers <b>of</b> <b>subroutines,</b> the numbers <b>of</b> arguments for each subroutine, and the structure of ADFs. These parameters are domain dependent and need much trial and error for determination. The problem in ADF GPs is that the functionalities <b>of</b> <b>subroutines</b> are not evaluated while GP operations. This results that the structure <b>of</b> <b>subroutine</b> [...] ...|$|R
50|$|Cython has {{a foreign}} {{function}} interface for invoking C/C++ routines {{and the ability}} to declare the static type <b>of</b> <b>subroutine</b> parameters and results, local variables, and class attributes.|$|R
50|$|NOVAS, an {{integrated}} package <b>of</b> <b>subroutines</b> for the computation {{of a wide}} variety of common astrometric quantities and transformations, in Fortran and C, from the U.S. Naval Observatory.|$|R
50|$|By {{carefully}} using {{blocks of}} line numbers {{that do not}} overlap, programmers can build libraries <b>of</b> <b>subroutines</b> (simulating functions as above) and merge them into new programs as needed.|$|R
40|$|A {{fundamental}} problem in learning from observation and interaction with an environment is defining a good representation, {{that is a}} representation which captures the underlying structure and functionality of the domain. This chapter discusses {{an extension of the}} genetic programming (GP) paradigm {{based on the idea that}} subroutines obtained from blocks of good representations act as building blocks and may enable a faster evolution of even better representations. This GP extension algorithm is called adaptive representation through learning (ARL). It has built-in mechanisms for (1) creation <b>of</b> new <b>subroutines</b> through discovery and generalization of blocks of code; (2) deletion <b>of</b> <b>subroutines.</b> The set <b>of</b> evolved <b>subroutines</b> extracts common knowledge emerging during the evolutionary process and acquires the necessary structure for solving the problem. ARL was successfully tested on the problem of controlling an agent in a dynamic and non-deterministic environment. Results with the automatic discovery <b>of</b> <b>subroutines</b> show the potential to better scale up the GP technique to complex problems...|$|R
50|$|The term toolbox {{is used in}} {{computing}} {{to represent}} a set <b>of</b> <b>subroutines</b> (or functions) and global variables. Typically these implement missing functionality using capabilities available in the core software.|$|R
40|$|Introduction Hierarchical Genetic Programming (HGP) {{extensions}} discover, modify, {{and exploit}} subroutines {{to accelerate the}} evolution of programs [Koza 1992, Rosca and Ballard 1994 a]. The use <b>of</b> <b>subroutines</b> biases the search for good programs and offers the possibility to reuse code. While HGP approaches improve the efficiency and scalability of genetic programming (GP) for many applications [Koza, 1994 b], several issues remain unresolved. The scalability of HGP techniques could be further improved by solving two such issues. One is the characterization of the value <b>of</b> <b>subroutines.</b> Current methods for HGP do not attempt to decide what is relevant, i. e. which blocks <b>of</b> code or <b>subroutines</b> may be worth giving special attention, but employ genetic operations on subroutines at random points. The other issue is the time-course of the generation <b>of</b> new <b>subroutines.</b> Current HGP techniques do not make informed choices to automatically decide wh...|$|R
50|$|The {{other type}} <b>of</b> <b>subroutine</b> was {{delivered}} in machine language with a Macro wrapper. It was normally written by Honeywell staff. The Macro used the command GOSUB {{to call the}} subroutine.|$|R
5000|$|... where a given set of {{specific}} names corresponding to a generic name must all be of functions or all <b>of</b> <b>subroutines.</b> If this interface is within a module, {{then it is}} simply ...|$|R
40|$|Skew-Hamiltonian/Hamiltonian matrix pencils λS −H {{appear in}} many applications, includinglinearquadraticoptimalcontrolproblems, H∞-optimization, certain multi-body systems {{and many other}} areas in applied mathematics, physics, andchemistry. Intheseapplicationsitisnecessarytocomputecertaineigenvalues and/orcorrespondingdeflatingsubspacesofthesematrixpencils. Recentlydeveloped methods exploit and {{preserve}} the skew-Hamiltonian/Hamiltonian structure and hence increase reliability, accuracy and performance of the computations. In this paper we describe the corresponding algorithms which have been implemented in the style <b>of</b> <b>subroutines</b> <b>of</b> the <b>Subroutine</b> Library in Control Theory (SLICOT). Furthermore we address some of their applications. We describe variants for real and complex problems with versions for factored and unfactored matrices S. Impressum...|$|R
40|$|This paper {{presents}} an algorithm for {{the discovery of}} building blocks in genetic programming (GP) called adaptive representation through learning (ARL). The central idea ARL is the adaptation of the problem representation, by extending the set of terminals and functions with a set <b>of</b> evolvable <b>subroutines.</b> The set <b>of</b> <b>subroutines</b> extracts common knowledge emerging during the evolutionary process and acquires the necessary structure for solving the problem. ARL supports subroutine creation and deletion. Subroutine creation or discovery is performed automatically based on the differential parent-offspring fitness and block activation. Subroutine deletion relies on a utility measure similar to schema fitness over a window of past generations. The techuique described is tested {{on the problem of}} controlling an agent in a dynamic and non-deterministic environment. The automatic discovery <b>of</b> <b>subroutines</b> can help scale up the GP technique to complex problems. ...|$|R
50|$|The 1130 {{supported}} only single-precision and double-precision {{binary data}} natively (16 and 32 bits) stored in big-endian format. Standard- and extended-precision floating-point (32 and 48 bits) and decimal data were supported {{through the use}} <b>of</b> <b>subroutines.</b>|$|R
50|$|Potash SU is {{a package}} {{including}} Seismic Unix style codes developed by Balazs Nemeth, {{it provides a}} subroutine called simple window-based first break picker, the figure shows the seismic images {{before and after the}} application <b>of</b> <b>subroutine.</b>|$|R
5000|$|Round {{brackets}} (parentheses) {{are used}} with arrays, both to declare {{them and to}} get a value at a given index in one of them. Visual Basic [...]NET uses round brackets to define the parameters <b>of</b> <b>subroutines</b> or functions.|$|R
