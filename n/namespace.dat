1420|564|Public
5|$|In XML, a <b>namespace</b> is an {{abstract}} domain {{to which a}} collection of element and attribute names can be assigned. The <b>namespace</b> name is a character string which must adhere to the generic URI syntax. However, the name is generally {{not considered to be}} a URI, because the URI specification bases the decision not only on lexical components, but also on their intended use. A <b>namespace</b> name does not necessarily imply any of the semantics of URI schemes; for example, a <b>namespace</b> name beginning with http: may have no connotation {{to the use of the}} HTTP.|$|E
5|$|Originally, the <b>namespace</b> name {{could match}} the syntax of any {{non-empty}} URI reference, but {{the use of}} relative URI references was deprecated by the W3C. A separate W3C specification for namespaces in XML 1.1 permits internationalized resource identifier (IRI) references to {{serve as the basis for}} <b>namespace</b> names in addition to URI references.|$|E
5|$|A C# <b>namespace</b> {{provides}} {{the same level}} of code isolation as a Java package or a C++ , with very similar rules and features to a package.|$|E
50|$|Since version 3.0, CookXml {{is capable}} of dealing with XML {{documents}} with multiple <b>namespaces.</b> For backward compatibility, CookXml also parse XML documents without <b>namespaces</b> or partially utilizing <b>namespaces.</b>|$|R
50|$|Informal <b>namespaces</b> {{are fully}} fledged URN <b>namespaces</b> {{and can be}} {{registered}} in global registration services.|$|R
25|$|XML <b>namespaces</b> {{enable the}} same {{document}} to contain XML elements and attributes taken from different vocabularies, without any naming collisions occurring. Although XML <b>Namespaces</b> {{are not part}} of the XML specification itself, virtually all XML software also supports XML <b>Namespaces.</b>|$|R
5|$|The class statement, which executes a {{block of}} code and {{attaches}} its local <b>namespace</b> to a class, for use in object-oriented programming.|$|E
5|$|The second idea {{means that}} {{processes}} can offer their services to other processes by providing virtual files {{that appear in}} the other processes' <b>namespace.</b> The client process's input/output on such a file becomes inter-process communication between the two processes. This way, Plan 9 generalizes the Unix notion of the filesystem as the central point of access to computing resources. It carries over Unix's idea of device files {{to provide access to}} peripheral devices (mice, removable media, etc.) and the possibility to mount filesystems residing on physically distinct filesystems into a hierarchical <b>namespace,</b> but adds the possibility to mount a connection to a server program that speaks a standardized protocol and treat its services as part of the <b>namespace.</b>|$|E
5|$|Furthermore, the kernel {{can keep}} {{separate}} mount tables for each process, and can thus provide each process {{with its own}} file system <b>namespace.</b> Processes' namespaces can be constructed independently, and the user may work simultaneously with programs that have heterogeneous namespaces. Namespaces {{may be used to}} create an isolated environment similar to chroot, but in a more secure way.|$|E
40|$|XML <b>namespaces</b> {{provide a}} simple method for {{qualifying}} element and attribute names used in Ex-tensible Markup Language documents by associating them with <b>namespaces</b> identified by URI references. SXML is {{representation of the}} XML Infoset {{in the form of}} S-expressions. A support for <b>namespaces</b> in SXML may be considered as a superset to <b>namespaces</b> in XML. In this paper we discuss its design and implementation, and provide a comparison with <b>namespaces</b> in XML. The discussion is illustrated by Dublin Core and Resource Description Framework examples, actively used in digital libraries applications. ...|$|R
50|$|MVEL {{relies on}} Java <b>namespaces</b> and classes, {{but does not}} possess the ability to declare <b>namespaces</b> or classes.|$|R
50|$|Classes {{are used}} {{sometimes}} used as or with <b>namespaces.</b> In programming languages that don't support <b>namespaces</b> (e.g., JavaScript) but do support classes and objects, classes {{are often used}} to substitute for <b>namespaces.</b> These classes are usually not instantiated and consist exclusively of static members.|$|R
5|$|The first idea means that, unlike on most {{operating}} systems, processes (running programs) {{each have}} their own view of the <b>namespace,</b> corresponding to what other operating systems call the file system; a single path name may refer to different resources for different processes. The potential complexity of this setup is controlled {{by a set of}} conventional locations for common resources.|$|E
5|$|A URN is a URI that {{identifies}} a resource by {{name in a}} particular <b>namespace.</b> A URN {{may be used to}} talk about a resource without implying its location or how to access it. For example, in the International Standard Book Number (ISBN) system, ISBN 0-486-27557-4 identifies a specific edition of Shakespeare's play Romeo and Juliet. The URN for that edition would be urn:isbn:0-486-27557-4. To gain access to the book, its location is needed, for which a URL would have to be specified.|$|E
25|$|On 4 April 2002, BrilliantProse, since renamed Featured Articles, {{was moved}} to the Wikipedia <b>namespace</b> from the article <b>namespace.</b>|$|E
50|$|In large {{computer}} programs or documents {{it is not}} uncommon to have hundreds or thousands of identifiers. <b>Namespaces</b> (or a similar technique, see Emulating <b>namespaces)</b> provide a mechanism for hiding local identifiers. They provide a means of grouping logically related identifiers into corresponding <b>namespaces,</b> thereby making the system more modular.|$|R
5000|$|Further, TinyXML has no {{facility}} for handling XML <b>namespaces.</b> Qualified element or attribute names retain their prefixes, as TinyXML makes {{no effort to}} match the prefixes with <b>namespaces.</b>|$|R
50|$|Between 2003 and 2010, info <b>namespaces</b> were {{registered}} by the Online Computer Library Center (OCLC) Office of Research {{on behalf of}} theNational Information Standards Organization (NISO), an American library standards body. About 30 <b>namespaces</b> {{were registered}}.|$|R
25|$|Namespaces are a {{mechanism}} for logically grouping similar classes into a hierarchical structure. This prevents naming conflicts. The structure is implemented using dot-separated words, where the most common top-level <b>namespace</b> is System, such as System.IO and System.Net. There are other top-level namespaces as well, such as Accessibility and Windows. A user can define a <b>namespace</b> by placing elements inside a <b>namespace</b> block.|$|E
25|$|Also on 30 May 2004, with MediaWiki 1.3, the Template <b>namespace</b> was created, {{allowing}} transclusion {{of standard}} texts.|$|E
25|$|For {{both the}} new and the delete {{functions}}, the functions are global, are not in any <b>namespace,</b> {{and do not have}} static linkage.|$|E
50|$|During argument-dependent lookup, other <b>namespaces</b> not {{considered}} during normal lookup may be searched where {{the set of}} <b>namespaces</b> to be searched depends on the types of the function arguments. Specifically, the set of declarations discovered during the ADL process, and considered for resolution of the function name, is the union of the declarations found by normal lookup with the declarations found by looking in the set of <b>namespaces</b> associated with the types of the function arguments.|$|R
50|$|PRISM {{conforms}} to the World Wide Web standard for <b>Namespaces.</b> PRISM <b>namespaces</b> are PRISM (prism:), PRISM Usage Rights (pur:), Dublin Core (dc: and dcterms:), PRISM Inline Metadata (pim:), PRISM Rights Language (prl:), PRISM Aggregator Message (pam:), and PRISM Controlled Vocabulary (pcv:).PRISM incorporated existing industry standards such as Dublin Core and XHTML in order to leverage work {{that had already been}} done in the publishing industry. New elements were created only when required, and were assigned to PRISM specific <b>namespaces.</b>|$|R
50|$|The {{purpose of}} NVDL {{is to provide}} that linkage, based on <b>namespaces.</b> By associating a schema {{validator}} with an NVDL schema, the validator can use multiple schemas to validate a single document, switching between them based on the <b>namespaces</b> used in that document.|$|R
25|$|DOI is a {{registered}} URI under the info URI scheme specified by IETF RFC 4452. info:doi/ is the infoURI <b>Namespace</b> of Digital Object Identifiers.|$|E
25|$|DTDs {{define a}} {{document}} type {{rather than the}} types used by a <b>namespace,</b> thus grouping all constraints for a document in a single collection.|$|E
25|$|SIMD {{support as}} part of the Mono.SIMD <b>namespace,</b> where method calls to special vector types are {{directly}} mapped to the underlying processor CPU SIMD instructions.|$|E
5000|$|... destructors, exceptions, templates, <b>namespaces,</b> {{structured}} loop exits ...|$|R
5000|$|... #Subtitle level 3: <b>Namespaces,</b> subdomains, and {{internationalization}} ...|$|R
50|$|<b>Namespaces</b> are {{a feature}} of the Linux kernel that isolate and {{virtualize}} system resources of a collection of processes. Examples of resources that can be virtualized include process IDs, hostnames, user IDs, network access, interprocess communication, and filesystems. <b>Namespaces</b> are a fundamental aspect of containers on Linux.|$|R
25|$|The {{statement}} {{can also}} be used to define another name for an existing <b>namespace</b> or type. This is sometimes useful when names are too long and less readable.|$|E
25|$|MacPorts (formerly DarwinPorts), Fink, and Homebrew {{are well}} known {{projects}} to port UNIX programs to the Darwin operating system and provide package management. In addition, several standard UNIX package managers—such as RPM, pkgsrc, and Portage—have Darwin ports. Some of these operate in their own <b>namespace</b> {{so as not to}} interfere with the base system.|$|E
25|$|Hierarchical module names. Module {{names are}} allowed to consist of dot-separated {{sequences}} of capitalised identifiers, rather than only one such identifier. This lets modules be named in a hierarchical manner (e.g., Data.List instead of List), although technically modules are still in a single monolithic <b>namespace.</b> This extension was specified in an addendum to Haskell 98 and was in practice universally used.|$|E
50|$|TypeScript {{distinguishes between}} modules and <b>namespaces.</b> Both {{features}} in TypeScript support encapsulation of classes, interfaces, functions and variables into containers. <b>Namespaces</b> (formerly internal modules) utilize immediately-invoked function expression of JavaScript to encapsulate code, whereas modules (formerly external modules) leverage JavaScript library patterns {{to do so}} (AMD or CommonJS).|$|R
5000|$|In {{order to}} ensure the global {{uniqueness}} of URN <b>namespaces,</b> their identifiers (NIDs) are required to be registered with the IANA. Registered <b>namespaces</b> may be [...] "formal" [...] or [...] "informal". An exception to the registration requirement was formerly made for [...] "experimental namespaces", since rescinded by [...] 8141.|$|R
40|$|Archives are {{implemented}} {{as an extension}} of Theorema for representing large bodies of mathematics. They provide various constructs for organizing knowledge bases in a natural way: breaking formulae across cells, grouping them in a hierarchical structure, attaching labels to subhierarchies, disambiguating symbols by the use of <b>namespaces,</b> importing symbols from other <b>namespaces,</b> addressing the domains of categories and functors as <b>namespaces</b> with variable operations. All constructs are logic–internal {{in the sense that they}} have a natural translation to higher–order logic so that "mathematical knowledge management" can be treated by the object logic itself...|$|R
