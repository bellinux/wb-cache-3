0|19|Public
50|$|This {{particular}} <b>notation</b> {{is called}} <b>attribute</b> value matrix (AVM).|$|R
5000|$|Python {{properties}} {{may be used}} {{to allow}} a methodto be invoked with the same syntax as accessing an attribute. Whereas Meyer's UAP would havea single <b>notation</b> for both <b>attribute</b> access and method invocation (method invocation syntax), a language with support for properties still supports separate notations for attributeand method access. Properties allow the <b>attribute</b> <b>notation</b> to be used, but to hide thefact that a method is being invoked instead of simply retrieving or setting a value.|$|R
5000|$|There are {{a number}} of {{notational}} systems for the Jacobi theta functions. The notations given in the Wikipedia article define the original functionwhich is equivalent toHowever, a similar notation is defined somewhat differently in Whittaker and Watson, p. 487:This <b>notation</b> is <b>attributed</b> to [...] "Hermite, H.J.S. Smith and some other mathematicians". They also defineThis is a factor of i off from the definition of [...] as defined in the Wikipedia article. These definitions can be made at least proportional by x = za, but other definitions cannot. Whittaker and Watson, Abramowitz and Stegun, and Gradshteyn and Ryzhik all follow Tannery and Molk, in which ...|$|R
25|$|Leibniz thought symbols were {{important}} for human understanding. He attached so much {{importance to the}} development of good <b>notations</b> that he <b>attributed</b> all his discoveries in mathematics to this. His notation for calculus is an example of his skill in this regard. Peirce, a 19th-century pioneer of semiotics, shared Leibniz's passion for symbols and notation, and his belief that these are essential to a well-running logic and mathematics.|$|R
50|$|DIANA, the Descriptive Intermediate <b>Attributed</b> <b>Notation</b> for Ada, is an {{intermediate}} language {{used to represent}} the semantics of an Ada program. It was originally designed as an interface between the front end (syntactic analysis) and middle (semantic analysis) of the compiler {{on the one hand}} and the back end (code generation and optimization) on the other. It is also used as an internal representation by other language tools.|$|R
50|$|Leibniz thought symbols were {{important}} for human understanding. He attached so much {{importance to the}} development of good <b>notations</b> that he <b>attributed</b> all his discoveries in mathematics to this. His notation for calculus is an example of his skill in this regard. Peirce, a 19th-century pioneer of semiotics, shared Leibniz's passion for symbols and notation, and his belief that these are essential to a well-running logic and mathematics.|$|R
40|$|We {{study the}} {{application}} of Tuplix Calculus in modular financial budget design. We formalize organizational structure using financial transfer networks. We consider the notion of flux of money over a network, {{and a way to}} enforce the matching of influx and outflux for parts of a network. We exploit so-called signed <b>attribute</b> <b>notation</b> to make internal streams visible through encapsulations. Finally, we propose a Tuplix Calculus construct for the definition of data functions...|$|R
5000|$|Fast Infoset is {{a higher}} level format built on ASN.1 forms and <b>notation.</b> Element and <b>attribute</b> names are stored within the octet stream, unlike {{traditional}} ASN.1 encoding schemes. In consequence, The conventional XML file can be recovered from the binary stream without reference the XML Schema, and the XML Schema need not be expressed as an ASN.1 definition. (ASN.1 [...] "Tags" [...] are just type names, e.g. String, Integer, or complex types.) ASN.1 together with ECN is used to define the file format.|$|R
50|$|Monasteries were {{important}} {{contributors to the}} surrounding community. They were centres of intellectual progression and education. They welcomed aspiring priests to come study and learn, allowing them even to challenge doctrine in dialogue with superiors. The earliest forms of musical <b>notation</b> are <b>attributed</b> to a monk named Notker of St Gall, and was spread to musicians throughout Europe {{by way of the}} interconnected monasteries. Since monasteries offered respite for weary pilgrim travellers, monks were obligated also to care for their injuries or emotional needs. Over time, lay people started to make pilgrimages to monasteries instead of just using them as a stop over. By this time, they had sizeable libraries that attracted learned tourists. Families would donate a son in return for blessings. During the plagues, monks helped to till the fields and provide food for the sick.|$|R
40|$|AbstractAttribute grammars are a {{powerful}} specification paradigm for many language processing tasks, particularly semantic analysis of programming languages. Recent attribute grammar systems use dynamic scheduling algorithms to evaluate attributes by need. In this paper, we show how {{to remove the}} need for a generator, by embedding a dynamic approach in a modern, object-oriented programming language to implement a small, lightweight attribute grammar library. The Kiama attribution library has similar features to current generators, including cached, uncached, circular, higher-order and parameterised attributes, and implements new techniques for dynamic extension and variation of attribute equations. We use the Scala programming language because of its combination of object-oriented and functional features, support for domain-specific notations and emphasis on scalability. Unlike generators with specialised <b>notation,</b> Kiama <b>attribute</b> grammars use standard Scala notations such as pattern-matching functions for equations and mixins for composition. A performance analysis shows that our approach is practical for realistic language processing...|$|R
40|$|Igel {{is a small}} XQuery-based web {{application}} for examining a collection of document grammars; in particular, for comparing related document grammars {{to get a better}} overview of their differences and similarities. In its initial form, Igel reads only DTDs and provides only simple lists of constructs in them (elements, <b>attributes,</b> <b>notations,</b> parameter entities). Our continuing work is aimed at making Igel provide more sophisticated and useful information about document grammars and building the application into a useful tool for the analysis (and the maintenance!) of families of related document grammar...|$|R
40|$|Attribute grammars are a {{powerful}} specification paradigm for many language processing tasks, particularly semantic analysis of programming languages. Recent attribute grammar systems use dynamic scheduling algorithms to evaluate attributes by need. In this paper, we show how {{to remove the}} need for a generator, by embedding a dynamic approach in a modern, object-oriented programming language to implement a small, lightweight attribute grammar library. The Kiama attribution library has similar features to current generators, including cached, uncached, circular, higher-order and parameterised attributes, and implements new techniques for dynamic extension and variation of attribute equations. We use the Scala programming language because of its combination of object-oriented and functional features, support for domain-specific notations and emphasis on scalability. Unlike generators with specialised <b>notation,</b> Kiama <b>attribute</b> grammars use standard Scala notations such as pattern-matching functions for equations and mixins for composition. A performance analysis shows that our approach is practical for realistic language processing. 15 page(s...|$|R
40|$|In {{this thesis}} we study the {{performance}} of electronic trading algorithms with a help of machine learning methods. We compare {{the performance of}} developed trading algorithms that trade based on posts (tweets) on Twitter with those that trade based on historic foreign exchange values and technical indicators. Besides the well known methods for text transformation to <b>attribute</b> <b>notation</b> we also use word 2 vec word vectors. We evaluate all the developed text transformation methods and their parameters, first on simpler but related tweet sentiment detection problem and later with trading in simulation environment. We improve developed models' predictions with the prediction combining techniques and we achieve up to 250...|$|R
50|$|In {{comparison}} {{testing of}} reverse Polish notation with algebraic notation, reverse Polish {{has been found}} to lead to faster calculations, for two reasons. Because reverse Polish calculators do not need expressions to be parenthesized, fewer operations need to be entered to perform typical calculations. Additionally, users of reverse Polish calculators made fewer mistakes than for other types of calculator. Later research clarified that the increased speed from reverse Polish <b>notation</b> may be <b>attributed</b> to the smaller number of keystrokes needed to enter this notation, rather than to a smaller cognitive load on its users. However, anecdotal evidence suggests that reverse Polish notation is more difficult for users to learn than algebraic notation.|$|R
40|$|This {{paper is}} a pre-print of: Anthony M. Sloane, Lennart C. L. Kats, Eelco Visser. A Pure Object-Oriented Embedding of Attribute Grammars. In T. Ekman and J. Vinju, editors, Proceedings of the Ninth Workshop on Language Descriptions, Tools, and Applications (LDTA’ 09), Electronic Notes in Theoretical Computer Science. York, United Kingdom, March 2009. Attribute grammars are a {{powerful}} specification paradigm for many language processing tasks, particularly semantic analysis of programming languages. Recent attribute grammar systems use dynamic scheduling algorithms to evaluate attributes by need. In this paper, we show how {{to remove the}} need for a generator, by embedding a dynamic approach in a modern, object-oriented programming language to implement a small, lightweight attribute grammar library. The Kiama attribution library has similar features to current generators, including cached, uncached, circular, higher-order and parameterised attributes, and implements new techniques for dynamic extension and variation of attribute equations. We use the Scala programming language because of its combination of object-oriented and functional features, support for domain-specific notations and emphasis on scalability. Unlike generators with specialised <b>notation,</b> Kiama <b>attribute</b> grammars use standard Scala notations such as pattern-matching functions for equations and mixins for composition. A performance analysis shows that our approach is practical for realistic language processing. Software Computer TechnologyElectrical Engineering, Mathematics and Computer Scienc...|$|R
40|$|This paper {{discusses}} a metrics {{approach for}} analyzing software designs that helps designers engineer quality {{into the design}} product. These metrics gauge project quality as well as design complexity at all times during the design phase. The metrics are developed from primitive design metrics which are predictive, objective and automatable. The architectural design metrics used are comprised of terms related {{to the amount of}} data flowing through the module and the number of invocation sequences through the module. A detailed design metrics component takes into account the structure and complexity of a module. This paper presents empirical results to illustrate the metrics' success in identifying stress points in a software design and demonstrate their relationship {{to the quality of the}} resulting software. To automate the calculation of the design metrics in the Rational environment, DIANA (Descriptive Intermediate <b>Attributed</b> <b>Notation</b> for Ada) was utilized. Provided in the environment a [...] ...|$|R
40|$|AbstractModeling is a {{powerful}} way to represent the desired organization and performance of a particular system {{and how it will}} meet the desired system objectives. There is a multitude of modeling methods, but determining whether the completed model effectively represents the desired system organization can be a challenge. System engineers can inspect the modeled system architecture to determine whether it is acceptable, but few formal methods exist to aid in the performance of this task. In practice, engineers apply heuristics and their experience to identify the characteristics of a “good” architecture. By formalizing these characteristics using logical <b>notation,</b> the quality <b>attributes</b> that constitute a “good” system architecture can be quantified and applied to determine the quality of an architectural model. Because these attributes are defined using a general notation, they can be instantiated using many system architecture tools and can be adapted {{to meet the needs of}} a specific architectural framework or particular project...|$|R
40|$|Language-processors {{that are}} {{constructed}} using top-down recursive-descent with backtracking parsing are highly modular, and are easy to implement and maintain. However, a widely-held inaccurate view is that top-down processors are inherently exponential for ambiguous grammars and cannot accommodate left-recursive syntax rules. It has been known that exponential time and space complexities can be avoided by memoization and compact graph-structured representation, and that left- recursive productions can be accommodated {{through a variety of}} techniques. However, until now, memoization, compact representation, and techniques for handling left-recursion have either been presented independently, or else attempts at their integration have compromised modularity and correctness of the resulting parses. Specifying syntax and semantics to describe formal languages using denotational <b>notation</b> of <b>attribute</b> grammars (AGs) has been widely practiced. However, very little work has shown the usefulness of declarative AGs for constructing computational models of natural language. Previous top-down approaches fall short in accommodating ambiguous and general CFGs with arbitrary semantics in one pass as executable specifications. Existing approaches lack in providing a declarative syntax-semantics interface that can take full advantages of dependencies between attributes of syntactic constituents to model linguistically-motivated cases. This thesis solves these shortcomings by proposing a new modular top-down syntactic and semantic analysis system, which is efficient and accommodates all forms of CFGs. Moreover, this system provides notation to declaratively specify semantics by establishing arbitrary dependencies between attributes of syntactic categories to perform linguistically-motivated tasks such as: building directly-executable natural-language query processors, computing meanings of sentences using compositional semantics, performing contextual disambiguation tasks, modelling restrictive classes of languages etc...|$|R
40|$|Carnatic music, {{a form of}} Indian Art Music, {{has relied}} on an oral {{tradition}} for transferring knowledge across several generations. Over the last two hundred years, the use of prescriptive notations has been adopted for learning, sight-playing and sight-singing. Prescriptive notations offer generic guidelines for a raga rendition and do not include information about the ornamentations or the gamakas, which {{are considered to be}} critical for characterizing a raga. In this paper, we show that prescriptive <b>notations</b> contain raga <b>attributes</b> and can reliably identify a raga of Carnatic music from its octave-folded prescriptive notations. We restrict the notations to 7 notes and suppress the finer note position information. A dictionary based approach captures the statistics of repetitive note patterns within a raga notation. The proposed stochastic models of repetitive note patterns (or SMRNP in short) obtained from raga notations of known compositions, outperforms {{the state of the art}} melody based raga identification technique on an equivalent melodic data corresponding to the same compositions. This in turn shows that for Carnatic music, the note transitions and movements have a greater role in defining the raga structure than the exact note positions...|$|R

