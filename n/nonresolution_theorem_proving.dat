0|10000|Public
50|$|Plaisted's {{research}} interests include term rewriting systems, automated <b>theorem</b> <b>proving,</b> logic programming, and algorithms. His research accomplishments in <b>theorem</b> <b>proving</b> include work on the recursive path ordering, the associative path ordering, abstraction, the simplified and modified problem reduction formats, ground reducibility,nonstandard clause form translations, rigid E-unification, Knuth-Bendix completion, replacement rules in <b>theorem</b> <b>proving,</b> instance-based <b>theorem</b> <b>proving</b> strategies, and semantics in <b>theorem</b> <b>proving.</b>|$|R
50|$|The <b>Theorem</b> <b>Proving</b> System (TPS) is an {{automated}} <b>theorem</b> <b>proving</b> system for first-order and higher-order logic. TPS {{has been developed}} at Carnegie Mellon University. An educational version of it is known as ETPS (Educational <b>Theorem</b> <b>Proving</b> System).|$|R
50|$|The <b>theorem</b> <b>proving</b> systems TPS and ETPSare {{based on}} Q0. In August 2009, TPS won the first-ever competitionamong higher-order <b>theorem</b> <b>proving</b> systems.|$|R
40|$|Abstract. A proof {{document}} for origami <b>theorem</b> <b>proving</b> {{is a record}} of entire process of reasoning about origami construction and <b>theorem</b> <b>proving.</b> It is produced {{at the completion of}} origami <b>theorem</b> <b>proving</b> as a kind of proof certificate. It describes in detail how the whole process of an origami construction and the subsequent <b>theorem</b> <b>proving</b> are carried out in our computational origami system. In particular, it describes logical and algebraic transformations of the prescription of origami construction into mathematical models that in turn become amenable to computation and verification. The structure of the {{proof document}} is detailed using an illustrative example that reveals the importance of such a document in the analysis of origami construction and <b>theorem</b> <b>proving.</b> ...|$|R
40|$|This {{technical}} report is the Emerging Trends {{proceedings of the}} 20 th International Conference on <b>Theorem</b> <b>Proving</b> in Higher Order Logics (TPHOLs 2007), which was held during 10 - 13 September in Kaiserslautern, Germany. TPHOLs covers all aspects of <b>theorem</b> <b>proving</b> in higher order logics as well as related topics in <b>theorem</b> <b>proving</b> and veri&# 64257;cation...|$|R
40|$|Automated <b>theorem</b> <b>proving</b> {{has made}} great {{progress}} {{during the last}} few decades. Proofs of more and more difficult theorems are being found faster and faster. However, the exponential increase {{in the size of the}} search space remains for many <b>theorem</b> <b>proving</b> problems. Logic program analysis and transformation techniques have also made progress {{during the last few}} years and automated <b>theorem</b> <b>proving</b> can benefit from these techniques if they can be made applicable to general <b>theorem</b> <b>proving</b> problems. In this thesis we investigate the applicability of logic program analysis and transformation techniques to automated <b>theorem</b> <b>proving.</b> Our aim is to speed up theorem provers by avoiding useless search. This is done by detecting and deleting parts of the theorem prover and theory under consideration that are not needed for proving a given formula. The analysis and transformation techniques developed for logic programs can be applied in automated <b>theorem</b> <b>proving</b> via a programming technique called [...] ...|$|R
40|$|In {{recent years}} several {{computational}} systems and techniques for <b>theorem</b> <b>proving</b> by analogy have been developed. The obvious practical question, however, {{as to whether}} and when to use analogy has been neglected badly in these developments. This paper addresses this question, identifies situations where analogy is useful, and discusses the merits of <b>theorem</b> <b>proving</b> by analogy in these situations. The results can be generalized to other domains. 1 Introduction <b>Theorem</b> <b>proving</b> by analogy, as sketched in Figure 1, finds a proof for a target theorem guided by a proof or proof plan of a given source theorem {{which is similar to}} the target theorem. Several attempts to implement <b>theorem</b> <b>proving</b> source (given) target source proof ? source theorem target theorem Fig. 1. Analogy in <b>theorem</b> <b>proving</b> ? The work was supported by the HC&M grant CHBICT 930806 and by a grant in the SFB 378 by analogy, e. g. [8, 18, 20, 9, 13], have been published. Most papers about analogy in <b>theorem</b> <b>proving</b> did re [...] ...|$|R
50|$|Automated proof {{checking}} {{differs from}} automated <b>theorem</b> <b>proving</b> in that automated proof checking simply mechanically checks the formal workings {{of an existing}} proof, {{instead of trying to}} develop new proofs or theorems itself. Because of this, the task of automated proof verification is much simpler than that of automated <b>theorem</b> <b>proving,</b> allowing automated proof checking software to be much simpler than automated <b>theorem</b> <b>proving</b> software.|$|R
40|$|Different {{researchers}} use "the {{philosophy of}} automated <b>theorem</b> <b>proving</b> " to cover different concepts, indeed, {{different levels of}} concepts. Some would count such issues as how to efficiently index databases {{as part of the}} philosophy of automated <b>theorem</b> <b>proving.</b> Others wonder about whether formulas should be represented as strings or as trees or as lists, and call this part of the philosophy of automated <b>theorem</b> <b>proving.</b> Yet others concern themselves with what kind of search should be embodied in any automated theorem prover, or to what degree any automated theorem prover should resemble Prolog. Still others debate whether natural deduction or semantic tableaux or resolution is "better", and call this a part of the philosophy of automated <b>theorem</b> <b>proving.</b> Some people wonder whether automated <b>theorem</b> <b>proving</b> should be "human oriented " o...|$|R
40|$|<b>Theorem</b> <b>proving</b> {{and model}} {{checking}} are complementary {{approaches to the}} verification of hardware designs and software algorithms. In <b>theorem</b> <b>proving,</b> the verification task is one of showing that the formal description of the program implies the formal statement of a putative program property, while model checking demonstrates that the program is a model that satisfies the putative property. <b>Theorem</b> <b>proving</b> is completely general but typically requires significant human guidance, whereas model checking though restricted to a limited range of properties of small (essentially) finitestate systems, is largely automatic. This paper is a tutorial on the combined use of <b>theorem</b> <b>proving</b> and model checking as mechanized in the PVS specification and verification environment. Keywords. Mechanical verification, <b>Theorem</b> <b>proving,</b> Model checking 1 Introduction There are both scientific and pragmatic reasons for pursuing the formal verification of hardware and software systems. The scientific reaso [...] ...|$|R
40|$|This book {{contains}} {{an introduction to}} symbolic logic and a thorough discussion of mechanical <b>theorem</b> <b>proving</b> and its applications. The book consists of three major parts. Chapters 2 and 3 constitute an introduction to symbolic logic. Chapters 4 - 9 introduce several techniques in mechanical <b>theorem</b> <b>proving,</b> and Chapters 10 an 11 show how <b>theorem</b> <b>proving</b> {{can be applied to}} various areas such as question answering, problem solving, program analysis, and program synthesis...|$|R
40|$|This paper {{discusses}} {{the relationship between}} transformational programming and <b>theorem</b> <b>proving.</b> It illustrates {{the use of the}} <b>theorem</b> <b>proving</b> environment as a basis for a program construction tool DEBATE 1 (Deduction Based Transformational Environment) which is under construction in University College Dublin. Using a <b>theorem</b> <b>proving</b> framework directly would require the user to be familiar with <b>theorem</b> <b>proving</b> details. The tool user should only be concerned with transformational programming steps and not with <b>theorem</b> <b>proving</b> activities. Therefore a layer of transformational tactics are discussed and presented. These tactics consist of the application of theoremproving tactics. However, they ensure that the user’s only interaction with DEBATE are design decisions required within the transformational programming paradigm. The N Queens problem is used throughout the paper to demonstrate how the Isabelle theorem prover is adapted by a transformation tactic layer so that it may be used as a program construction tool...|$|R
50|$|Interactive <b>Theorem</b> <b>Proving</b> (ITP) is {{an annual}} {{international}} academic {{conference on the}} topic of automated <b>theorem</b> <b>proving,</b> proof assistants and related topics, ranging from theoretical foundations to implementation aspects and applications in program verification, security, and formalization of mathematics.|$|R
40|$|Abstract. In {{this paper}} we discuss the {{similarities}} between program specialisation and inductive <b>theorem</b> <b>proving,</b> and then show how program specialisation {{can be used to}} perform inductive <b>theorem</b> <b>proving.</b> We then study this relationship in more detail for a particular class of problems (verifying infinite state Petri nets) in order to establish a clear link between program specialisation and inductive <b>theorem</b> <b>proving.</b> In particular, we use the program specialiser ecce to generate specifications, hypotheses and proof scripts in the theory format of the proof assistant Isabelle. Then, in many cases, Isabelle can automatically execute these proof scripts and thereby verify the soundness of ecce’s verification process and of the correspondence between program specialisation and inductive <b>theorem</b> <b>proving.</b> ...|$|R
40|$|AbstractWe {{present a}} {{detailed}} {{review of the}} elements of automated <b>theorem</b> <b>proving,</b> emphasizing certain aspects of especial interest to the logic programming community. In particular, we focus heavily on how an automated theorem-proving program can treat equality in a natural and yet effective manner, and how such a program can use strategy to control its reasoning in a sophisticated fashion. With the objective of significantly increasing the scope of logic programming, perhaps some unusually inventive researcher can adapt various procedures we review in this article, and adapt {{them in a way that}} preserves most of the speed offered by logic programming. In turn, although our expertise rests far more in automated <b>theorem</b> <b>proving,</b> we include certain observations concerning the value of logic programming to automated <b>theorem</b> <b>proving</b> in general. In other words, a natural symbiosis between automated <b>theorem</b> <b>proving</b> and logic programming exists, which nicely completes the circle, since logic programming was born of automated <b>theorem</b> <b>proving...</b>|$|R
40|$|Model {{checking}} has {{won some}} industrial acceptance in debugging designs. <b>Theorem</b> <b>proving</b> and formal verification are less popular. An approach built around automated abstractions could integrate <b>theorem</b> <b>proving</b> with model checking in an acceptable way {{and provide a}} bridge between refutation and verification...|$|R
40|$|In this {{contribution}} {{we present}} some work {{we have been}} doing in representing and <b>proving</b> <b>theorems</b> from the area of economics, and mainly we present work we will do in a project in which we will apply mechanised <b>theorem</b> <b>proving</b> tools to a class of economic problems for which very few general tools currently exist. For mechanised <b>theorem</b> <b>proving,</b> the research introduces the field to a new application domain with a large user base; more specifically, the researchers are collaborating with developers working on state-of-the-art theorem provers. For economics, the research will provide tools for handling a hard class of problems; more generally, as the first application of mechanised <b>theorem</b> <b>proving</b> to centrally involve economic theorists, it aims to properly introduce mechanised <b>theorem</b> <b>proving</b> techniques to the discipline. ...|$|R
40|$|The {{simultaneous}} rigid $E$-unification problem arises {{naturally in}} <b>theorem</b> <b>proving</b> with equality. This problem {{has recently been}} shown to be undecidable. This raises the question whether simultaneous rigid $E$-unification can usefully be applied to equality <b>theorem</b> <b>proving.</b> We give some evidence in the affirmative, by presenting a number of common special cases in which a decidable version of this problem suffices for <b>theorem</b> <b>proving</b> with equality. We also present some general decidable methods of a rigid nature {{that can be used for}} equality <b>theorem</b> <b>proving</b> and discuss their complexity. Finally, we give a new proof of undecidability of simultaneous rigid $E$-unification which is based on Post's Correspondence Problem, and has the interesting feature that all the positive equations used are ground equations (that is, contain no variables) ...|$|R
5000|$|... #Article: International Workshop on First-Order <b>Theorem</b> <b>Proving</b> ...|$|R
40|$|Generation {{of machine}} {{executable}} programs from specifications written in higher level languages {{has always been}} an attractive idea. Several attempts have been made in this direction. The basic approach in program generation is the <b>theorem</b> <b>proving</b> approach. In the <b>theorem</b> <b>proving</b> approach the specification is i...|$|R
30|$|The {{following}} <b>theorem</b> <b>proves</b> that MHMM is NP-complete.|$|R
5000|$|Notable <b>theorems</b> <b>proved</b> using {{homology}} {{include the}} following: ...|$|R
40|$|We {{present a}} {{combination}} of raising, explicit variable dependency representation, the liberalized delta-rule, and preservation of solutions for first-order deductive <b>theorem</b> <b>proving.</b> Our main motivation is to provide the foundation for our work on inductive <b>theorem</b> <b>proving,</b> where the preservation of solutions is indispensable. Comment: ii + 40 page...|$|R
40|$|The Advanced Microcontroller Bus Architecture (AMBA) {{is an open}} System-on-Chip bus {{protocol}} for high-performance buses on low-power devices. We demonstrate the combined use of model checking and <b>theorem</b> <b>proving</b> to verify both control and datapath properties in a seamless manner. Key words: System-on-Chip, <b>theorem</b> <b>proving,</b> model checking, tool combination. ...|$|R
50|$|The most {{developed}} subareas of automated reasoning are automated <b>theorem</b> <b>proving</b> (and {{the less}} automated but more pragmatic subfield of interactive <b>theorem</b> <b>proving)</b> and automated proof checking (viewed as guaranteed correct reasoning under fixed assumptions). Extensive work {{has also been}} done in reasoning by analogy induction and abduction.|$|R
50|$|First-order <b>theorem</b> <b>proving</b> {{is one of}} {{the most}} mature subfields of {{automated}} <b>theorem</b> <b>proving.</b> The logic is expressive enough to allow the specification of arbitrary problems, often in a reasonably natural and intuitive way. On the other hand, it is still semi-decidable, and a number of sound and complete calculi have been developed, enabling fully automated systems. More expressive logics, such as higher order logics, allow the convenient expression of a wider range of problems than first order logic, but <b>theorem</b> <b>proving</b> for these logics is less well developed.|$|R
40|$|AbstractIn 1969 Cordell {{presented}} his seminal description of planning as <b>theorem</b> <b>proving</b> {{with the situation}} calculus. The most pleasing feature of Green's account was the negligible gap between high-level logical specification and practical implementation. This paper attempts to reinstate the ideal of planning via <b>theorem</b> <b>proving</b> in a modern guise. In particular, the paper shows that if we adopt the event calculus as our logical formalism and employ abductive logic programming as our <b>theorem</b> <b>proving</b> technique, then the computation performed mirrors closely that of a hand-coded partial-order planning algorithm. Soundness and completeness results for this logic programming implementation are given. Finally the paper shows that, if we extend the event calculus in a natural way to accommodate compound actions, then using the same abductive <b>theorem</b> <b>proving</b> techniques we can obtain a hierarchical planner...|$|R
40|$|Research on {{automated}} {{and interactive}} <b>theorem</b> <b>proving</b> aims at the mechanization of logical reasoning. Aside from {{the development of}} logic calculi it became rapidly apparent that the organization of proof search {{on top of the}} calculi is an essential task in the design of powerful <b>theorem</b> <b>proving</b> systems. Different paradigms of how to organize proof search have emerged in that area of research, the most prominent representatives are generally described by the buzzwords: automated <b>theorem</b> <b>proving,</b> tactical <b>theorem</b> <b>proving</b> and proof planning. Despite their paradigmatic differences, all approaches share a common goal: to find a proof for a given conjecture. In this paper we start with a rational reconstruction of proof search paradigms in the area of proof planning and tactical <b>theorem</b> <b>proving.</b> Guided by similarities between software engineering and proof construction we develop a uniform view that accommodates the various proof search methodologies and eases their comparison. Based on this view, we propose a unified framework that enables the combination of different methodologies for proof construction to take advantage of their individual virtues within specific phases of a proof construction. ...|$|R
50|$|The <b>theorem,</b> <b>proven</b> by Tits, is stated as follows.|$|R
5000|$|... #Subtitle level 2: Automated <b>theorem</b> <b>proving</b> {{and formal}} methods ...|$|R
5000|$|... #Caption: Ceva's {{parallel}} <b>theorem</b> <b>proved</b> by Al-Mu'taman ibn Hūd.|$|R
5000|$|Poincaré-Birkhoff <b>theorem</b> <b>proves</b> the {{existence}} of two fixed points ...|$|R
40|$|Automated <b>theorem</b> <b>proving</b> {{is a well}} {{established}} subject in computer science. The advances made in the algorithmic techniques for automated <b>theorem</b> <b>proving</b> are impressive, see the survey paper [Loveland 1996]. Also, automated <b>theorem</b> <b>proving</b> has found various important applications in computer science. For example, Robinson’s resolution proving method launched a whole new programming paradigm, namely logic programming. Amazingly, although proving {{is the essence of}} mathematics, the advances of automated <b>theorem</b> <b>proving</b> did not have any noticeable influence on the practice of mathematical research and teaching so far. We do believe, however, that automated <b>theorem</b> <b>proving</b> should, could and will have an important impact on the future of mathematics, more precisely on the way how mathematics is &quot;done&quot;. For this to happen we think that the basic paradigm must change from automated <b>theorem</b> <b>proving</b> towards computer−supported theory exploration. In fact, in our view, the paradigm of theory exploration is not only the natural paradigm for using automated or computer−supported proving systems but also for doing mathematics by paper and pencil. In this paper, we will first clarify the paradigm of theory exploration and then give a couple of examples that should illustrate the paradigm. The examples are carried out in the frame of the Theorema system, a system designed to be a common frame for proving, solving, and simplifying mathematical formulae, see [Buchberger et al. 1997, 2000]. � A Rough Distinctio...|$|R
40|$|In {{this thesis}} we develop a {{comprehensive}} human-oriented <b>theorem</b> <b>proving</b> system that integrates several different proof systems. The main <b>theorem</b> <b>proving</b> environment centers around a natural Gentzen first-order logic system. This allows construction of natural proofs, encourages user {{involvement in the}} search for proofs, and facilitates understanding of the resulting proofs. We integrate more abstract automatically generated proofs such as resolution refutations by transforming them to proofs in the Gentzen system. Expansion trees are another proof system used as an intermediate stage in transformations between the abstract and natural systems. They are a compact representation useful for transformations and other computations. We develop a programming language approach to <b>theorem</b> <b>proving</b> based on tactics and tacticals. Our extended tactics provide a method for doing proof transformations, as well as facilitate interactive <b>theorem</b> <b>proving,</b> allowing full integration of interactive and automatic <b>theorem</b> <b>proving.</b> In the system, we explicitly represent proofs in each proof system and view expansion tree proofs as types for Gentzen proof terms. This explicit proof representation allows proofs to be manipulated as meaningful data objects and used in various computations. For example, the proof terms in the natural Gentzen system can be used to obtain natural language explanations of proofs. We foresee several applications for this kind of <b>theorem</b> <b>proving</b> system, such as use a...|$|R
40|$|Abstract. Algorithms and datastructures {{form the}} kernel of any {{efficient}} theorem prover. In this abstract we discuss research on algorithms and datastructures for efficient <b>theorem</b> <b>proving</b> {{based on our}} experience with the theorem prover Vampire. We also briefly overview other works related to algorithms and datastructures, and to efficient <b>theorem</b> <b>proving</b> in general. ...|$|R
50|$|Formal proofs {{often are}} {{constructed}} {{with the help}} of computers in interactive <b>theorem</b> <b>proving.</b> Significantly, these proofs can be checked automatically, also by computer. Checking formal proofs is usually simple, while the problem of finding proofs (automated <b>theorem</b> <b>proving)</b> is usually computationally intractable and/or only semi-decidable, depending upon the formal system in use.|$|R
