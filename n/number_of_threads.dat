740|10000|Public
5|$|DIN valves are {{produced}} in 200 bar and 300 bar pressure ratings. The <b>number</b> <b>of</b> <b>threads</b> and the detail {{configuration of the}} connections is designed to prevent incompatible combinations of filler attachment or regulator attachment with the cylinder valve.|$|E
25|$|Hobbing uses a {{hobbing machine}} with two skew spindles, one mounted {{with a blank}} {{workpiece}} {{and the other with}} the hob. The angle between the hob's spindle (axis) and the workpiece's spindle varies, {{depending on the type of}} product being produced. For example, if a spur gear is being produced, then the hob is angled equal to the helix angle of the hob; if a helical gear is being produced then the angle must be increased by the same amount as the helix angle of the helical gear. The two shafts are rotated at a proportional ratio, which determines the number of teeth on the blank; for example, for a single-threaded hob if the gear ratio is 40:1 the hob rotates 40 times to each turn of the blank, which produces 40 teeth in the blank. If the hob has multiple threads the speed ratio must be multiplied by the <b>number</b> <b>of</b> <b>threads</b> on the hob. The hob is then fed up into the workpiece until the correct tooth depth is obtained. Finally the hob is fed through the workpiece parallel to the blank's axis of rotation.|$|E
2500|$|Thread Pitch = 1/N [...] where N is the <b>number</b> <b>of</b> <b>threads</b> {{per inch}} or mm ...|$|E
50|$|Event-driven {{programming}} hardware description languages such as Verilog have {{a different}} threading model that supports extremely large <b>numbers</b> <b>of</b> <b>threads</b> (for modeling hardware).|$|R
5000|$|<b>Number</b> <b>of</b> teeth, N : How many teeth a gear has, an integer. In {{the case}} of worms, it is the <b>number</b> <b>of</b> <b>thread</b> starts that the worm has.|$|R
50|$|Goldens' {{machining}} facilities handle most operations {{their customers}} need. The operations primarily consist of turning, milling, and drilling operations, although operators perform a limited <b>number</b> <b>of</b> <b>threading,</b> painting, tapping, and sub-assembly operations.|$|R
2500|$|Thread {{engagement}} is {{the length}} or <b>number</b> <b>of</b> <b>threads</b> that are engaged between the screw {{and the female}} threads. Bolted joints are designed so that the bolt shank fails in tension before the threads fail in shear, but for this to hold true, a minimum thread engagement must be achieved. The following equation defines this minimum thread engagement: ...|$|E
2500|$|The {{spinning}} wheel was a medieval invention that increased thread making productivity {{by a factor}} greater than ten. [...] One of the early developments that preceded the Industrial Revolution was the stocking frame (loom) of c. 1589. [...] Later in the Industrial Revolution came the flying shuttle, a simple device that doubled the productivity of weaving. [...] Spinning thread had been a limiting factor in cloth making requiring 10 spinners using the {{spinning wheel}} to supply one weaver. [...] With the spinning jenny a spinner could spin eight threads at once. [...] The water frame (Ptd. 1768) adapted water power to spinning, but it could only spin one thread at a time. The water frame was easy to operate and many could be located in a single building. [...] The spinning mule (1779) allowed a large <b>number</b> <b>of</b> <b>threads</b> to be spun by a single machine using water power. [...] A change in consumer preference for cotton {{at the time of}} increased cloth production resulted in the invention of the cotton gin (Ptd. 1794). [...] Steam power eventually was used as a supplement to water during the Industrial Revolution, and both were used until electrification. [...] A graph of productivity of spinning technologies can be found in Ayres (1989), along with much other data related this article.|$|E
6000|$|For {{studying}} the markings on the fingers themselves, a small folding lens, sold at opticians' shops {{under the name}} of a [...] "linen tester," [...] is very convenient. It is so called because it was originally constructed for the purpose of counting the <b>number</b> <b>of</b> <b>threads</b> in a given space, in a sample of linen. It is equally well adapted for counting the number of ridges in a given space.|$|E
50|$|Programs {{designed}} to require concurrency {{are more difficult}} to debug. Programs {{designed to}} require concurrency will have performance issues when the <b>number</b> <b>of</b> required <b>threads</b> exceeds the <b>number</b> <b>of</b> hardware <b>threads</b> because time slicing artifacts can hit hard.|$|R
40|$|Emerging {{parallel}} architectures {{provide the}} means to efficiently handle more fine-grained and larger <b>numbers</b> <b>of</b> parallel tasks. However, software for parallel programming still does {{not take advantage of}} these new possibilities, retaining the high cost associated with managing large <b>numbers</b> <b>of</b> <b>threads.</b> A significant percentage of this overhead can be attributed to operations on queues. In this paper, we present a methodology to efficiently create and enqueue large <b>numbers</b> <b>of</b> <b>threads</b> for execution. In combination with advances in computer architecture, this reduces cost of handling parallelism and allows applications to express their inherent parallelism in a more fine-grained manner. Our methodology is based on the notion <b>of</b> Batches <b>of</b> <b>Threads,</b> which are teams <b>of</b> <b>threads</b> that are used to insert and extract more than one objects simultaneously from queues. Thus, the cost of operations on queues is amortized among all members of a batch. We define an API, present its implementation in the NthLib threading library and demonstrate how it can be used in real applications. Our experimental evaluation clearly demonstrates that handling operations on queues improves significantly. Furthermore, we show that better load-balancing and locality of memory references, due to larger <b>numbers</b> <b>of</b> <b>thread,</b> can automatically improve performance of applications. ...|$|R
40|$|We present Dreadlocks, an {{efficient}} new shared-memory spin lock that actively detects deadlocks. Instead of spinning on a Boolean value, each thread spins on the lock owner’s per-thread digest, a compact {{representation of a}} portion of the lock’s waits-for graph. Digests can be implemented either as bit vectors (for small <b>numbers</b> <b>of</b> <b>threads)</b> or as Bloom filters (for larger <b>numbers</b> <b>of</b> <b>threads).</b> Updates to digests are propagated dynamically as locks are acquired and released. Dreadlocks can be applied to any spin lock algorithm that allows threads to time out. Experimental results show that Dreadlocks outperform timeouts under many circumstances, and almost never do worse...|$|R
50|$|A {{method to}} alter the {{execution}} features of OpenMP applications. Used to control loop iterations scheduling, default <b>number</b> <b>of</b> <b>threads,</b> etc. For example, OMP_NUM_THREADS is used to specify <b>number</b> <b>of</b> <b>threads</b> for an application.|$|E
50|$|Multiple blocks are {{combined}} {{to form a}} grid. All the blocks in the same grid contain the same <b>number</b> <b>of</b> <b>threads.</b> Since the <b>number</b> <b>of</b> <b>threads</b> in a block is limited to 512, grids {{can be used for}} computations that require a large number of thread blocks to operate in parallel.|$|E
50|$|OS-9/non-68000 {{supports}} POSIX threads. A single {{process can}} start any <b>number</b> <b>of</b> <b>threads.</b>|$|E
5000|$|THREADS (OS/2 only) : Specifies <b>number</b> <b>of</b> {{concurrent}} <b>threads.</b>|$|R
40|$|Abstract — Without {{high-bandwidth}} broadcast, large <b>numbers</b> <b>of</b> cores {{require a}} scalable point-to-point interconnect and a directory protocol. In such cases, a shared, inclusive last level cache (LLC) can improve data sharing and avoid threeway communication for shared reads. However, if inclusion encompasses thread-private data, two problems arise with the shared LLC. First, current memory allocators align stack bases on page boundaries, which {{emerges as a}} source of severe conflict misses for large <b>numbers</b> <b>of</b> <b>threads</b> on data-parallel applications. Second, correctness does not require the private data to reside in the shared directory or the LLC. This paper advocates stack-base randomization that eliminates the major source of conflict misses for large <b>numbers</b> <b>of</b> <b>threads.</b> However, when capacity becomes a limitation for the directory or last-level cache, this is not sufficient. We the...|$|R
3000|$|Proposed {{parallel}} {{version of}} Meijster algorithm was implemented in C using OpenMP directives. Speedup for <b>numbers</b> <b>of</b> <b>threads</b> equal to 1, 2, 4, 8, and 16 were determined. The efficiency measure Ψ (n) {{is given by}} the following formula with n the <b>number</b> <b>of</b> processors: Ψ (n) = seq. time/(n*para. time) (ii) [...]...|$|R
5000|$|The <b>number</b> <b>of</b> <b>threads</b> per {{storage device}} that {{processes}} SCSI commands is configurable.|$|E
5000|$|Thread Pitch = 1/N where N is the <b>number</b> <b>of</b> <b>threads</b> {{per inch}} or mm ...|$|E
5000|$|Thread pools {{reduce the}} cost of {{spawning}} a new thread by reusing a limited <b>number</b> <b>of</b> <b>threads.</b>|$|E
40|$|High-performance, I/O-intensive {{applications}} {{often require}} complicated, split-phase, event-based implementations. Threads {{appear to be}} an attractive alternative because they allow the programmer to write a single sequence of operations and ignore the points at which the execution may be blocked. Unfortunately, the typical amount of memory required to support this technique prevents applications from scaling to large <b>numbers</b> <b>of</b> <b>threads.</b> Rather than relying on event-based programming, we use a program transformation to provide a lowcost thread implementation. This transformation retains the advantages of user-scheduled, eventbased programs, yet efficiently supports large <b>numbers</b> <b>of</b> <b>threads.</b> We replace the standard Java thread mechanism with lightweight PicoThreads and a cooperative, event-based, user-level scheduler. This is accompanied by a PicoThread-aware, asynchronous network library. To evaluate our implementation, we measure the performance of a simple web crawler running thousan [...] ...|$|R
5000|$|In parallel, Theodore Gobley {{developed}} a <b>number</b> <b>of</b> additional <b>threads</b> <b>of</b> research {{of a more}} mainstream type: ...|$|R
40|$|Abstract. Emerging {{parallel}} architectures {{provide the}} means to efficiently handle more fine-grained and larger <b>numbers</b> <b>of</b> parallel tasks. However, software for parallel programming still does not {{take full advantage of}} these new possibilities, retaining the high cost associated with managing large <b>numbers</b> <b>of</b> <b>threads.</b> A significant percentage of this overhead can be attributed to operations on queues. In this paper, we present a methodology to efficiently create and enqueue large <b>numbers</b> <b>of</b> <b>threads</b> for execution. In combination with advances in computer architecture, this reduces cost of handling parallelism and allows applications to express their inherent parallelism in a more fine-grained manner. Our methodology is based on the notion <b>of</b> Batches <b>of</b> <b>Threads,</b> which are teams <b>of</b> <b>threads</b> that are used to insert and extract more than one objects simultaneously from queues. Thus, the cost of operations on queues is amortized among all members of a batch. We define an API, present its implementation in the NthLib threading library and demonstrate how it can be used in real applications. Our experimental evaluation clearly demonstrates that handling operations on queues improves significantly. 1...|$|R
5000|$|Thread count: The <b>number</b> <b>of</b> <b>threads</b> {{per square}} inch or per 10 cm square in a woven fabric.|$|E
5000|$|... task-level {{parallelism}} (TLP), which purposes {{to increase}} the <b>number</b> <b>of</b> <b>threads</b> or processes that a CPU can execute simultaneously.|$|E
5000|$|... #Caption: An {{illustration}} of multithreading where the master thread forks off a <b>number</b> <b>of</b> <b>threads</b> which execute blocks of code in parallel.|$|E
25|$|Machine {{embroidery}} commonly uses polyester, rayon, or metallic embroidery thread, though other thread {{types are}} available. 40 wt thread {{is the most}} commonly used embroidery thread weight. Bobbin thread is usually either 60 wt or 90 wt. The quality <b>of</b> <b>thread</b> used can greatly affect the <b>number</b> <b>of</b> <b>thread</b> breaks and other embroidery problems. Polyester thread is generally more color-safe and durable. High quality embroidery thread is produced by Exquisite, Gunold, Madeira, Amann and Robison-Anton.|$|R
5000|$|Die/Screw Plate: The {{die plate}} {{was used to}} cut threads on small screws. It had a <b>number</b> <b>of</b> <b>threaded</b> die holes <b>of</b> {{different}} sizes for making different <b>threads.</b> A piece <b>of</b> wire was inserted in a hole and turned to cut a thread on the end. Then a head would be formed {{on the other end}} of the wire to make a screw.|$|R
40|$|Currently, the {{composite}} materials (CM) {{are widely used}} in the aerospace technology and mechanical engineering where the key parameters characterizing structural components and articles are related to their weight characteristics {{as well as their}} performance under high temperatures. For the experimental investigation <b>of</b> composite-based <b>threaded</b> items, the rod-based 3 Dreinforced carbon-carbon composite material (CCCM) was chosen. The subject of the research was the metric thread. The test samples were cut of the aforesaid material along one of the reinforcement direction. The following thread sizes were analyzed: М 24 × 1. 5; М 24 × 2; М 24 × 3. Dependence <b>of</b> the <b>thread</b> strength on the <b>number</b> <b>of</b> <b>thread</b> turns was determined within the range of 1 to 10 thread turns for М 24 × 2 thread size. The remaining test samples were used to obtain the relationship between the thread load bearing capacity and the thread pitch. The obtained dependence <b>of</b> the <b>thread</b> load bearing capacity on the <b>number</b> <b>of</b> <b>thread</b> turns showed the following: a) An increment in the thread load bearing capacity decreases with increasing <b>number</b> <b>of</b> <b>thread</b> turns. However, this effect is less pronounced than that observed for the metal ‘screw/nut’ pair. b) With the CCCM material under study, it proved to be impossible to test configurations having only 1 or 2 thread turns. c) The wide confidence range (CR) of the failure load {{can be explained by the}} fact that the material under study features an apparent structural heterogeneity, with a different probability of hitting a unit cell of the matrix and filler of the material. Nevertheless, the confidence range is stable, thus indicating indirectly the possibility of using this test method for further study <b>of</b> composite-based <b>threaded</b> items. There is an explicit correlation between the thread load bearing capacity and the thread pitch. Increase in the thread strength with increasing thread pitch depends on the relationship between the pitch size and the characteristic size of the unit cell of the material. The test research has shown that it is possible to make CCCM-based screw joints designed for operation under high temperatures as an alternative for metal screw joints, provided that the key parameters such as the thread profile, pitch, diameter and the <b>number</b> <b>of</b> <b>thread</b> turns are properly chosen. </p...|$|R
50|$|The {{same year}} (1828), Clement began making fluted {{screw-cutting}} tap and dies and urged {{the adoption of}} a standard system of screw threads where every machine screw of a particular length should have a set <b>number</b> <b>of</b> <b>threads</b> of a predetermined pitch and determined the <b>number</b> <b>of</b> <b>threads</b> for each length. Joseph Whitworth, at that time one of Clement's journeymen afterwards {{played a major role in}} such standardisation, the Whitworth thread becoming a standard for machine screws.|$|E
50|$|Where Wbarrier is {{the wait}} {{time for a}} thread, Tbarrier is the <b>number</b> <b>of</b> <b>threads</b> has arrived, and Rthread is the arrival rate of threads.|$|E
50|$|Cheesecloth is {{available}} in at least seven different grades, from open to extra-fine weave. Grades are distinguished by the <b>number</b> <b>of</b> <b>threads</b> per inch in each direction.|$|E
40|$|This version allows FBPIC {{to use the}} MKL {{library for}} FFTs, on CPU. In most cases, this will result in faster code {{execution}} compared to the FFTW library, especially on CPUs with a large <b>number</b> <b>of</b> cores. FFTW can still be used with FBPIC if MKL is unavailable. In addition, this version optimizes the <b>number</b> <b>of</b> <b>thread</b> per block on GPU for costly operations, which should also result faster code execution...|$|R
40|$|One of {{the most}} {{important}} requirements imposed to the modern mechanisms is economic feasibility. Therefore, considered as advanced are mechanical transducers of rotary motion to translational one, where rolling friction is mainly realized. They include planetary roller-screw mechanisms (PRSM). PRSM has a large variety of features. The design feature of PRSM is multiple starts of screw and nut thread. Rollers, as a rule, are made single-threaded. <b>Number</b> <b>of</b> screw <b>thread</b> starts which equals to a <b>number</b> <b>of</b> nut <b>thread</b> starts, has an effect on almost all performance characteristics of PRSM. This article covers comprehensively enough the influence <b>of</b> screw <b>thread</b> starts quantity on: kinematical parameters of PRSM, transfer function, mechanism radial dimensions, efficiency, power values, required characteristics of electric motor. As a result of investigations the graphs of dimensionless parameters vs. <b>number</b> <b>of</b> screw <b>thread</b> starts have been plotted, which are demonstrative and common. Being high enough the PRSM efficiency can vary within 20 … 25 % and more. It depends on a variety of mechanism part parameters; primarily on geometrical ones, as well as on a <b>number</b> <b>of</b> screw <b>thread</b> starts. Previously the methods of PRSM design calculation consisted in determination of the main geometric parameters of mechanism parts, then in determination of mechanism efficiency. At that, it was not always possible to design the economically feasible PRSM structure. Introduction of a dimensionless value – a relation <b>of</b> PRSM part <b>thread</b> pitch to average screw thread diameter – contributed to successive plotting of the assemblage of curves for relation of efficiency to the indicated ratio and a <b>number</b> <b>of</b> screw <b>thread</b> starts. By taking this assemblage of curves as a basis, the method of economically feasible PRSM structures calculation and design was proposed.   The essence of the developed method lies in that selection or definition <b>of</b> a <b>number</b> <b>of</b> screw <b>thread</b> starts helps to determine the relation <b>of</b> PRSM parts <b>thread</b> pitch to average diameter <b>of</b> screw <b>thread</b> which provides the maximum possible efficiency. Given further are check calculations confirming the operation capability of the selected PRSM design. </p...|$|R
5000|$|The {{regiment}} {{has brought}} forward a <b>number</b> <b>of</b> Golden <b>Threads</b> from its antecedents, as displays {{of its history}} and heritage: ...|$|R
