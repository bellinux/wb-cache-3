29|4|Public
50|$|Each node is {{assigned}} a unique <b>nodeID</b> uniformly distributed {{in a large}} identifier space. Tapestry uses SHA-1 to produce a 160-bit identifier space represented by a 40 digit hex key.Application specific endpoints GUIDs are similarly assigned unique identifiers. NodeIDs and GUIDs are roughly evenly distributed in the overlay network with each node storing several different IDs. From experiments it is shown that Tapestry efficiency increases with network size, so multiple applications sharing the same overlay network increases efficiency. To differentiate between applications a unique application identifier is used.Tapestry uses best-effort to publish and route objects.|$|E
50|$|The new node {{becomes the}} root for its <b>nodeID.</b> The root finds {{the length of}} the longest prefix of the ID it shares. Then it sends a {{multicast}} message that reaches all existing nodes sharing the same prefix. These nodes then add the new node to their routing tables. The new node may take over being the root for some of the root's objects. The nodes will contact the new node to provide a temporary neighborhood list. The new node then performs an iterative nearest neighbor search to fill all levels in its routing table.|$|E
5000|$|Each {{identifier}} {{is mapped}} to a live node called the root. If a node's <b>nodeID</b> is G {{then it is}} the root else use the routing table's nodeIDs and IP addresses to find the nodes neighbors. At each hop a message is progressively routed closer to G by incremental suffix routing.Each neighbor map has multiple levels where each level contains links to nodes matching {{up to a certain}} digit position in the ID. The primary ith entry in the jth level is the ID and location of the closest node that begins with prefix (N, j-1)+i. This means that level 1 has links to nodes that have nothing in common, level 2 has the first digit in common, etc. Because of this, routing takes approximately [...] hops in a network of size N and IDs of base B (hex: B=16). If an exact ID can not be found, the routing table will route to the closest matching node. For fault tolerance, nodes keep c secondary links such that the routing table has size [...]|$|E
3000|$|Nodes in a {{structured}} P 2 P overlay must be assigned unique identifiers {{to indicate their}} locations in the network: <b>nodeIds.</b> This is achieved in many systems by hashing the IP address of the node using a consistent hashing function to generate its identifier. Nodes are then ordered in the network based on their <b>nodeIds.</b> For example, in Chord, the nodes are placed orderly on an identifier circle modulo 2 [...]...|$|R
40|$|Since {{the problem}} of {{disclosing}} personal information on the Internet continues to increase, many anonymous communication systems have been studied. Such systems usually use directory servers to manage public keys of participant nodes. However, this reduces anonymity because the query messages for the directory servers can give adversaries route information of anonymous communication channels. To solve this problem, applying ID-Based Encryption has been proposed, but in the existing method, directory servers continue to exist. Our novel method, which can grasp assigned <b>NodeIDs</b> without directory servers, {{can be applied to}} existing DHT-based anonymous communication systems. Our proposal enhances scalability. This paper describes the structure of our proposed system and its application...|$|R
40|$|Abstract. Although {{peer-to-peer}} overlays {{have been}} elaborately studied, {{they still have}} redundant overheads. Pastry and Chord use leaf sets to connect those nodes contiguous in numerical space, but these pointers have no contribution to efficient routing. In this paper we argue that if the mapping between a message key and its root node is determined in a smart way, leaf sets can be removed, largely decreasing system overheads. We present a novel overlay algorithm derived from Pastry, in which <b>nodeIds</b> have different lengths and form a Huffman set, routing tables have no empty items and root node exactly prefix-matching its keys. By these means, our approach abolishes the leaf sets with no ill effect on routing performance or other properties. Experimental results show that our approach saves about 22 ~ 25 % messages cost for maintenance in comparison with Pastry in an overlay of 10, 000 peers...|$|R
40|$|Abstract — Structured P 2 P {{networks}} are growing very fast {{because of their}} scalability, efficiency and reliability. Chord {{is one of the}} popular DHTs which generate its <b>NodeId</b> by hashing the IP address of node. As there is no mechanism to verify whether the <b>NodeId</b> is generated correctly or not, malicious nodes can generate multiple NodeIds easily. So genuine node’s routing tables can be easily poisoned with fake NodeIds. In this paper we proposed the <b>NodeId</b> verification mechanism which will verify whether <b>NodeId</b> is generated correctly or not before updating the routing table entry. We will then analyse and compare the results of mitigation mechanism under attack. Index Terms — peer-to-peer, overlay network, distributed hash table, poisoning attack, Sybil attack...|$|E
30|$|The {{addressing}} scheme {{that we used}} for CoopMAC {{is based on the}} one defined in WARPMAC. Each node has a unique <b>nodeID</b> which is determined by 4 [*]dip switches. Therefore, a total of 16 unique nodeID's can be generated. Based on the <b>nodeID,</b> the MAC code generates a MAC address string and assigns it to the node. The nodes maintain a table that maps nodeID's to the corresponding MAC addresses.|$|E
3000|$|Key mapping in SHAM {{is similar}} to that in other DHT mechanisms. In SHAM, CAN, and Chord, the key will be cached at a node that has a <b>nodeId</b> that is closest to the key. Each time a new node joins with closer <b>nodeId</b> to that of they key, the key will be {{forwarded}} to it. Specifically, in SHAM, keys are distributed to nodes based on the coordinate system (X [...]...|$|E
40|$|Recently, {{flash memory}} has been {{utilized}} {{as the primary}} storage device in mobile devices. SSDs have been gaining popularity as the primary storage device in laptop and desktop computers and even in enterprise-level server machines. SSDs have an array of NAND flash memory packages and are therefore able to achieve concurrent parallel access {{to one or more}} flash memory packages. In order {{to take advantage of the}} internal parallelism of an SSD, it is beneficial for DBMSs to request input/output (I/O) operations on sequential logical block addresses (LBAs). However, the B+-Tree structure, which is a representative index scheme of current relational DBMSs, produces excessive I/O opera-tions in random order when its node structures are updated. Therefore, the conventional B+-Tree structure is unfavorable for use in SSDs. In this paper, we propose the Always Sequential (AS) B-tree which consists of the Legacy B+-Tree structure, a Sequential Writer, a Write Buffer, an Address Mapping Table, and a Node Validation Manager. All of the modified nodes in the Legacy B+-Tree are stored in the Write Buffer. If the Write Buffer is full, the Sequential Writer contiguously writes each node of the Write Buffer at the end of the file. To support this algorithm, the Address Mapping Table links <b>NodeIDs</b> of the Legacy B+-Tree to the LBA of the corresponding node. Because AS B-tree writes the modified nodes on sequential LBAs in this same manner, it is able to take advantage of the internal parallelism of SSDs. In the experiments presented as part of this paper, AS B-tree enhanced the insertion performance of the conventional B+-Tree by 21 %. We also confirmed AS B-tree demonstrates better performance than other flash-aware indexes in search-oriented workloads...|$|R
3000|$|... [...]). Throughout this paper, {{we shall}} {{use the term}} <b>nodeId</b> to refer to both the node’s {{location}} and identifier.|$|E
3000|$|... [...]. The node {{identifier}} will {{be generated}} from the node’s IP address while the identifier of the key will be generated by hashing the key itself. This arrangement makes both of the nodes and keys have the same naming space. Chord assigns keys to nodes based on the naming space as well. A key k will be stored at its successor node whose <b>nodeId</b> matches the identifier of {{the key in the}} space. If no match is found in the system, i.e., if the node whose <b>nodeId</b> matches the key has not been placed in the system or has left the system, the key will be cached at the next node whose <b>nodeId</b> follows the identifier of they key in the space in a clockwise manner. Also, Chord recognizes a predecessor to a node (or a key) as a node whose <b>nodeId</b> precedes that node in the circle in a counterclockwise manner. Each node in Chord maintains a routing table of O(log N) entries in N-node system. Lookups are resolved in O(log N) messages to other nodes, while insertion or deletion of a nodes affect O(log 2 [...]...|$|E
3000|$|... bear {{hexadecimal}} {{representation of}} {{the location of the}} node in the system. Accordingly, the <b>nodeId</b> for node u in SHAM is simply the concatenation of its coordinates from X [...]...|$|E
40|$|This paper {{presents}} {{the design and}} evaluation of Pastry, a scalable, distributed object location and routing substrate for wide-area peer-to-peer applications. Pastry performs application-level routing and object location in a potentially very large overlay network of nodes connected via the Internet. It {{can be used to}} support a variety of peer-to-peer applications, including global data storage, data sharing, group communication and naming. Each node in the Pastry network has a unique identifier (<b>nodeId).</b> When presented with a message and a key, a Pastry node efficiently routes the message to the node with a <b>nodeId</b> that is numerically closest to the key, among all currently live Pastry nodes. Each Pastry node keeps track of its immediate neighbors in the <b>nodeId</b> space, and noties applications of new node arrivals, node failures and recoveries. Pastry takes into account network locality; it seeks to minimize the distance messages travel, according to a to scalar proximity metric like the number of IP routing hops. Pastry is completely decentralized, scalable, and self-organizing; it automatically adapts to the arrival, departure and failure of nodes. Experimental results obtained with a prototype implementation on an emulated network of up to 100, 000 nodes confirm Pastry's scalability and efficiency, its ability to self-organize and adapt to node failures, and its good network locality properties...|$|E
30|$|Rule 1 Each segment in {{the network}} is uniquely {{identified}} by SegmentID, which is an integer number from 1 to N (N {{is the number of}} segments). Similarly, each node in each segment is uniquely identified by <b>NodeID</b> from 1 to n (n is the number of nodes in the segment). Thus, each node {{in the network}} can be uniquely identified by “SegmentID+NodeID”.|$|E
30|$|In Chord, after hashing the newcomer’s IP {{address and}} {{generating}} its <b>nodeId,</b> the system relies on some external mechanism {{to introduce the}} newcomer to an existing node in the overlay. Afterwards, the existing node will generate a lookup message to find the successor of the newcomer based on its generated <b>nodeId.</b> The newcomer will then connect to its successor and join the overlay. CAN {{on the other hand}} assumes the existence of a domain name server that maintains the addresses of bootstrapping nodes which hold partial lists of available nodes in the overlay. In order to join the overlay, the newcomer has first to obtain the address of one of the bootstrapping nodes. Later, the newcomer contacts this node in order to retrieve a list of randomly selected available nodes. Finally, the newcomer sends a join request to one of those nodes which accordingly splits its zone in half and assigns it to the newcomer.|$|E
30|$|Values are {{data items}} {{needed to be}} uniformly {{distributed}} over the P 2 P network [18 – 20]. In structured P 2 P networks this is usually carried out by using DHTs. Each value in the system will be paired with a key that is generated by a known hashing function. Each node identifier (usually the IP address of the node accompanied with a port number) will be hashed using the same hashing function to generate the <b>nodeId.</b> As a result of that, both of the generated <b>nodeId</b> and the key will fall within the same identifier space. Having created the namespace for nodes and values, every (key, value) pair will be stored at a node that has an identifier matches the generated key. If a match is not found, the key will be stored at a node with the closest identifier. This eventually makes every node accountable {{for a group of}} values. Our system as mentioned before does not require hashing the node’s IP address to generate its <b>nodeId,</b> yet, it is derived directly from the node’s position in the overlay. Choosing a hexadecimal representation in SHAM congregates the nodeIds and keys within the same namespace. We relax our guard when choosing the address space since no two nodes will have the same nodeIds. The criterion in choosing the address space becomes related to the load on each node in particular: The more nodes in the system, the less load on each node. On the other hand, the size of the namespace must be large enough to neglect the probability of having two values hash to the same identifier [3].|$|E
40|$|Abstract. The {{peer-to-peer}} {{systems have}} become an extremely popular platform for large-scale content sharing. A lot of research papers discussed the Distributed Hash Table (DHT) based p 2 p algorithms to promise that idle resources may be efficiently harvested. However, p 2 p systems are composed of components with extremely heterogeneous availabilities and for nodes which join/leave the system frequently, the system will generate {{a lot of information}} maintenance traffic such as routing information update traffic and data copy traffic to keep the efficiency of the DHT based p 2 p algorithms. In this paper, we suggest the mobile <b>nodeID</b> based p 2 p algorithm to reduce the overhead by exploiting the heterogeneity of participant nodes efficiently. Unlike the DHT based p 2 p algorithms, the <b>nodeID</b> of a node changes according to its characteristic to support the p 2 p system efficiency and each nodes takes the different responsibility in accordance with its <b>nodeID.</b> We classify nodes into the two types according to the characteristics of nodes: the reliable nodes and the leaf nodes. The reliable node which is the more stable and more reliable node acts as the more important role of the routing and the replication. The leaf node which joins/leaves very frequently acts as the simple role to minimize the information maintenance traffic. The reliable node has the load-balanced ID to balance the loads and the leaf node has the load-free ID to reduce the responsibility. We examine the efficiency of our p 2 p algorithm via a event driven simulation and show that the information maintenance traffic reduces and the routing process is more efficient...|$|E
40|$|The paper [pastry] {{describes}} the discovery {{and the location}} of data and resources in a dynamic, decentralized and scalable network. Each node in the Pastry network is assigned an unique <b>nodeId.</b> Messages with a key are propagated to find resources in the network. Whenever a node is presented with a message and its key, Pastry automatically routes it to the node having the numerically closest <b>nodeId</b> to the key. To support the routing procedure, each pastry node maintains its routing state consisting of three tables providing information about nearby and numerically close nodes. Pastry has the ability to take into account network locality when routing messages: a message is not only sent to the numerically closest <b>nodeId</b> to the message key, it also chooses the physically shortest way to go there. 1. 2 Viceroy [viceroy] is a constant degree routing network of logarithmic diameter. It manages the distribution of data among a dynamically changing set of servers by employing a distributed hash table. Its main purpose is to efficiently look up resources without any central control. Each node in the system is randomly assigned two identifiers: an id and an integer identifying its level. The Viceroy network is composend of an approximate butterfly network, a ring connecting nodes in the order of their id’s and level rings, where all nodes of the same level are connected in a ring. The butterfly network is a tree-like structure connecting a level ring with its upper and lower level. Therefore each node has a constant number of outgoing links. Routing consist of three phases, where the three kinds of links are followed to find the searched server. ...|$|E
3000|$|... space. The design {{eliminates}} the consistent hashing phase by directly assigning an identifier to each node joining the {{system based on}} the pre-constructed geometry of the overlay. Thus, SHAM situates the node first in the overlay based on geometric addressing, then it concludes its <b>nodeId</b> from the address of its position. To accomplish that, we devise that {{the location of a}} node in our system is a d-tuple (X [...]...|$|E
40|$|Part 1 : Full PapersInternational audienceThe {{security}} of the Peer-to-Peer (P 2 P) overlays networks has been questioned for years. Many works have been proposed to provide secure routing, anonymity, reputation systems, confidentiality, etc. However, the identity assignment has been less considered. These networks are designed so that each user has a unique identifier (<b>nodeID),</b> but the most of identity assignment systems allow malicious users to obtain a set of nodeIDs or even select certain identifiers. Thus, these users can disrupt the proper operation of a P 2 P overlay. In this paper, we propose a <b>nodeID</b> assignment protocol based {{on the issue of}} implicit certificates. Our purpose is to provide security services to struggle against the most of security threats in these networks with special attention to the identity assignment. This approach is based on the use of certificates and the joint generation of nodeIDs between a Certification Authority (CA) and the user. In addition, the use of implicit certificates presents certain advantages over the use of traditional certificates (explicit certificates) ...|$|E
3000|$|... coordinates. If no node {{has been}} placed in the system with that address yet, the key will be stored at a node that has the closest {{identifier}} {{to that of the}} key. Later on, whenever a node whose identifier is closer to the key joins the system, the key will be reallocated to that newcomer. The reallocation of the key may continue until it is stored at node whose <b>nodeId</b> matches the key 2.|$|E
3000|$|... − 1) entries of peers’ {{addresses}} which fortifies {{the system}} and reduces the average path length as we will discuss later. Also, this is important to enhance connectivity and routing in the system. In case a direct neighbor fails or leaves the system, the node will move the successor <b>nodeId</b> and IP address from the routing table to the relative remote neighbor entry. Therefore, the node in SHAM has to maintain between (3 [...]...|$|E
30|$|In the TBUT, each node {{is issued}} with a token at its inception. The token {{consists}} of three fields: <b>NodeID,</b> status, and reputation. <b>NodeID</b> {{is assumed to be}} unique and deemed to be beyond manipulation; status is a single-bit flag. Initially, the status bit is preset to zero indicating a green flag. Initially, reputation value is zero, i.e., positive. The token with a green flag and positive reputation is a permit issued to each node, which confers it the freedom to participate in all network activities. Each node in order to participate in any network activity, say Route Request RREQ, has to announce its token status bit and reputation value. If token status bit is “ 1 ” indicating a “red flag,” protocol does not allow the node to participate in any network activity. Similarly, if reputation value is “− 1 ” indicating a “negative reputation,” the protocol does not allow the node to participate in any network activity. Our study does not depend on the exact mobile node structure of the networks. For the sake of the result explanation, it will be assumed that the network consists of approximately 100 mobile nodes span in the flat space (i.e., its span size is roughly 1 km 2) and that there are roughly 20 mobile nodes per service area region [7].|$|E
40|$|Security is {{a common}} problem in {{completely}} decentralized peer-to-peer systems. Although several suggestions exist on {{how to create a}} secure key-based routing protocol, a practicable approach is still unattended. In this paper we introduce a secure key-based routing protocol based on Kademlia that has a high resilience against common attacks by using parallel lookups over multiple disjoint paths, limiting free <b>nodeId</b> generation with crypto puzzles and introducing a reliable sibling broadcast. The latter is needed to store data in a safe replicated way. We evaluate the security of our proposed extensions to the Kademlia protocol analytically and simulate the effects of multiple disjoint paths on lookup success under the influence of adversarial nodes. 1...|$|E
40|$|The {{problem of}} {{updating}} XML views {{is more complex}} than in the relational scenario due to its nested hierarchical structure. While several research projects [1, 4] began to explore this XML view updating problem, they typically provide no guarantee for avoiding view side eects. An update translatability analysis can be employed to reason about the potential view side eects before performing the update. Intuitively, such analysis could examine the ac-tual base data [2, 3]. However, as indicated by [2], this data-centric search for a translation tends to be very ex-pensive, even for relational view updates. Instead, in our HUX project, we have designed a comprehensive solution of exploring schema-knowledge to optimize this analysis. Fig. 1 (a) shows a running example of a relational database for a course registration system. A virtual XML view in Fig. 1 (c) is dened by the view query in Fig. 1 (b). The following examples illustrate cases of classifying updates as translatable or not translatable. Here we only use a delete primitive with the format (delete <b>nodeID),</b> where <b>nodeID</b> is the abbreviated identier of the element to be deleted. For example, CI 1. PS 1 represents the rst Professor-Student element of the rst ClassInfo element. Example 1. Update u 1 =fdelete CI 1. PS 1. S 2 g over the XML view (Fig. 1) deletes the student `Mike Fisher". We can delete Student. t 2 to achieve this without causing any view side eect. This can be concluded by looking at the schema of the view. From the view query (Fig. 1 (b)), each student can only appear once in the view, namely, in the ClassInfo element that represents its course-professor-student relationship. Deleting any student element in the view can Copyright is held by the author/owner(s) ...|$|E
30|$|Load {{balancing}} is {{an important}} aspect of structured P 2 P networks [18, 32 – 35]. A robust and resilient system should be able to fairly distribute the keys in the network over the participating nodes [32, 34, 35]. This will avert inundating nodes with keys and hence improving resources accessibility in the network. Consistent hashing uniformly distribute keys over the namespace as discussed earlier. However, in structured P 2 P system where both of the <b>nodeId</b> and the key are generated using the consistent hashing, there exist situations where the node identifiers do not uniformly cover the entire namespace system [3]. Thus, some nodes will be overloaded with keys while other nodes do not cache any keys. Chord maintains uniformity in this regard by requiring each node to cache its keys at an additional O(log N) virtual nodes.|$|E
40|$|Providing {{efficient}} and scalable service provisioning in Mobile Ad Hoc Network (MANET) {{is a big}} research challenge. In adaptive service provisioning mechanism an adaptive election procedure is used to select a coordinator node. The role of a service coordinator is crucial in any distributed directory based service provisioning scheme. The existing coordinator election schemes use either the <b>nodeID</b> or a hash function to choose the coordinator. In these schemes, the leader changes are more frequent due to node mobility. We propose an adaptive scheme that makes use of an eligibility factor that {{is calculated based on}} the distance to the zone center, remaining battery power and average speed to elect a core node that change according to the network dynamics. We also retain the node with the second highest priority as a backup node. Our algorithm is compared with the existing solution by simulation and the result shows that the core node selected by us is more stable and hence reduces the number of handoffs. This in turn improves the service delivery performance by increasing the packet delivery ratio and decreasing the delay, the overhead and the forwarding cost...|$|E
40|$|Serverless Peer-to-Peer (P 2 P) {{networks}} {{are becoming more}} and more influential on the Internet and in the computing world. These P 2 P systems have many advantages over their client-server counterparts, such as high availability, low maintenance cost and fault tolerance. They also make it possible to harness massive idle computing and storage resources at the edges of the Net. Two P 2 P models have emerged to achieve these benefits: the unstructured model and the structured model. The unstructured model typically forwards a query message to a selected number of nodes based on local knowledge. The structured P 2 P model is known as the Distributed Hash Table (DHT). In DHT networks, nodes and content/files are associated with a hash key as <b>nodeId</b> or contentId/fileId, respectively. The query message is routed through the overlay network to the node responsible for that key. Both the structured and the unstructured model have strengths and weaknesses. The structured model is favoured in research but not in real applications. It’s argued that the unstructured model is more suitable for the real world. It’s rather difficult to determin...|$|E
40|$|There {{are many}} works related to {{wireless}} sensor networks (WSNs) where authors present new protocols with better or enhanced features, others just compare their performance or present an application, but this work tries to provide a different perspective. Why don¿t we see the network {{as a whole and}} split it into groups to give better network performance regardless of the routing protocol? For this reason, in this thesis we demonstrate through simulations that node¿s grouping feature in WSN improves the network¿s behavior. We propose the creation of a group-based architecture, where nodes have the same functionality within the network. Each group has a head node, which defines the area in which the nodes of such group are located. Each node has a unique node identifier (<b>nodeID).</b> First group¿s node makes a group identifier (groupID). New nodes will know their groupID and <b>nodeID</b> of their neighbors. End nodes are, physically, the nodes that define a group. When there is an event on a node, this event is sent to all nodes in its group in order to take an appropriate action. End nodes have connections to other end nodes of neighboring groups and they will be used to send data to other groups or to receive information from other groups and to distribute it within their group. Links between end nodes of different groups are established mainly depending on their position, but if there are multiple possibilities, neighbor nodes could be selected based on their ability ¿, being ¿ a choice parameter taking into account several network and nodes parameters. In order to set group¿s boundaries, we can consider two options, namely: i) limiting the group¿s diameter of a maximum number of hops, and ii) establishing boundaries of covered area. In order to improve the proposed group-based architecture, we add collaboration between groups. A collaborative group-based network gives better performance to the group and to the whole system, thereby avoiding unnecessary message forwarding and additional overheads while saving energy. Grouping nodes also diminishes the average network delay while allowing scaling the network considerably. In order to offer an optimized monitoring process, and in order to offer the best reply in particular environments, group-based collaborative systems are needed. They will simplify the monitoring needs while offering direct control. Finally, we propose a marine application where a variant of this groupbased architecture could be applied and deployed. García Pineda, M. (2013). A group-based architecture and protocol for {{wireless sensor networks}} [Tesis doctoral no publicada]. Universitat Politècnica de València. doi: 10. 4995 /Thesis/ 10251 / 27599. Alfresc...|$|E
40|$|CausalTrail CausalTrail is a {{tool for}} causal {{hypotheses}} testing using causal bayesian networks (CBN) and the do-calculus. CausalTrail provides a console application and a graphical user interface. Building CausalTrail can be build using cmake. Mandatory Dependencies The Boost library {{as well as a}} C++ compiler supporting C++ 14 have to be available to build the console version of CausalTrail. Supported compilers are: >= GCC 4. 9 >= Clang 3. 5 Optional Dependencies To build CausalTrails unit test suite, gtest >= 1. 7. 0 is required. To build the gui, Qt version 5. 4 or higher has be installed. Step By Step Build Commands Enter CausalTrails directory and execute the following: mkdir build cd build cmake [...] If the path to gtest can not be found automatically, specify it via cmake. -DGTEST_SRC_DIR= If the path to Qt can not be found automatically, specify it via cmake. -DQt 5 Widgets_DIR= Build the project by typing make To use multiple cores (e. g. 4) for building use the -j option: make -j 4 The executable file for the consol version is located in the folder build/core, the gui version is located in the folder build/gui, and the tests {{can be found in the}} folder build/test. Execution To run CausalTrails tests type make test The console version of CausalTrail can be evoked with the command. /CausalTrail or alternatively. /CausalTrail We provide details on the input files in the next section. The GUI can be launched with. /CausalTrailGui Data Formats Network Files We support two kinds of network formats: the trivial graph format (tgf) and the simple interaction format (sif) along with node node atrribute (na) files. Trivial Graph Format The tgf format has the following structure: <b>NodeID</b> NodeAttribute [...] . # <b>NodeID</b> <b>NodeID</b> EdgeAtribute The upper part of a tgf file contains the mapping between node identifiers and at most one optional attribute, e. g. node names. The # marks the beginning of the actual network definition. Edges are directed from the first to the second node identifier. An edge between two nodes can be mapped to at most one optional attribute. Example 1 Apples 2 Bananas 3 Pears # 1 2 2 3 3 1 Node Attribute Format Node attribute files have the following structure: AttributeName (class = Type) <b>NodeID</b> = NodeAttribute [...] . Different node attribute classes can be referenced via the AttributeName. Type states the data type of the node attributes. The mapping of <b>NodeID</b> to NodeAttribute has to be unique within one class of attributes. Example NodeName (class=java. lang. String) 1 = Apples 2 = Bananas 3 = Pears Simple Interaction Format The simple interaction format is structured as follows: [...] . <b>NodeID</b> EdgeType <b>NodeID</b> [...] . Nodes in the network are identified via the <b>NodeID.</b> Therefore, the NodeIDs have to be unique. The left <b>NodeID</b> represents the source of an edge, the right on represents the target. It is possible to assign more than one target node to a distinct source node, so multiple edges can be stored in one line. The EdgeType encodes the type of an edge, e. g. whether an edge between two nodes is directed or not. It is also common to encode biological meaning in the EdgeType. For example, pd represents Protein-DNA interactions, whereas pp represents Protein-Protein interactions. The EdgeType can also be a longer string, allowing the encoding of more complex descriptions, e. g. activates, inactivates, or phosphorylates. If it is not necessary to encode any specific meaning for an edge xx or yy can be used as an EdgeType. Example 1 pp 2 2 pp 3 3 pp 1 For more information on the SIF format see here. Data Files The samples from which we learn the causal bayesian network parameters should be provided in a tab-delimited text file where the columns represent the samples and the rows represent the features. An example is shown below. SNV 1 Yes No Yes No SNV 2 No No No Yes Expression 1. 7 1. 2 1. 4 0. 6 Discretisation Information CausalTrail uses discretised input data for training the node parameters. As measurements often come as continous values, they have to be discretised before the actual parameter learning can take place. For this reason, we provide several discretisation methods within CausalTrail. Using a simple json file, the user can control the discretisation process. For example: { "SNV 1 ": { "method":"None", }, "SNV 2 ": { "method":"None", }, "Expression": { "method":"Threshold", "threshold": " 1. 0 " } } For every node in the network, the method field specfies the discretisation method. If necessary, additional fields can be used to provide specific information that is needed for the discretisation, e. g. a manually determined threshold as shown in the example above. A list of all keywords and discretisation methods is shown below. Floor: Round the data to the next smaller integer value. Ceil: Round the data to the next larger integer value. Round: Round the data. ArithmeticMean: Divide the data into two groups according to the arithmetic mean. HarmonicMean: Divide the data into two groups according to the harmonic mean. Median: Divide the data into two groups according to the median. Threshold: Divide the data into two groups according to a manually defined threshold. The actual threshold is specified in the field threshold. BracketMedians: Discretise the data according to the bracket medians method. The number of buckets is specified in the field buckets. PearsonTukey: Discretise the data according to the Pearson Tukey method. Z-Score: Divide the data into two groups according to the Z-Score. None: The data is already discret. GUI Usage The initial layout of CausalTrails gui is shown below. At the bottom of the window, there is a dock widget containing general information on the current session, labelled Log. As we see later, the middle area is used for network visualisation and query managment. At the top, there {{is a tool}}bar allowing direct access to the most important actions. Buttons are enabled according to the current status of a session. Thus, errors caused by wrong user input can be avoided. In addition to the toolbar, there is a menubar allowing access to all functions of CausalTrail. In the following we provide step by step guidlines on how to use our tool. For illustration purposes, we use the Student Network presented in Probabilistc Graphical Models by Koller and Friedman. Network Managment Networks can be loaded by a click on Load Network in the toolbar or by clicking on Network -> Load Network in the menu. A dialog will be shown to select networks represented in the formats introduced above. The dialog can also be opened by pressing Strg + O. Upon loading, the network layout is computed using graphviz. If graphviz is not available, the layout is generated by a force directed layouting algorithm included in CausalTrail. The network view is interactive, e. g. it is possible to move nodes or to zoom in or out the network visualisation. By clicking on Layout in the toolbar, the menubar or by pressing Strg + L, the network is layouted again. Networks are visualised in a tab window. In case that the user loads multiple networks, each network is shown in its own tab. Using CausalTrails svg export function, a network visualisation can be exported to a svg file. To do so, click Network -> Export SVG. A click on Delete Network deletes the network that is currently shown. This can also be done with Strg + D. An example of the visualisation of the Student Network is depicted below. To load the Student Network, use the files: test/data/Student. na test/data/Student. sif Loading Samples and Training the Network To load samples, click on Load Samples in the toolbar or in the menu. Once a suitable file is choosen, the data is shown in a table allowing manual inspection of the data as well as (de) selection of individual samples. This allows the exclusion of distinct samples from the analysis. An example for the student network is shown below. Upon confirming the data by a click on OK, a window for selection of discretisation methods is shown. Here, the user has two options: Either the discretisation information is loaded from a existing json file, or it is specified using the interface. A json file can be loaded by clicking on Load. In order to simplify the discretisation step, manually specified discretisation information can be stored in a json file by clicking on Save. As soon as the discretisation information is specified, the user can continue with parameter learning by clicking OK. During parameter learning the conditional probability tables (cpt) for all nodes are computed. It is possible to look at the individual cpts of each node by right clicking on a node and selecting Show CPT in the popmenu. Once the learning is completed, two new dock widgets are shown, the Query History and the Query Control Panel. The Query History lists all submitted and valid queries for individual networks. The Query Control Panel is used in formulating queries. We provide several examples for query managment in the next section. To train the Student Network use the files: test/data/StudentData. txt test/data/controlStudent. json Query Managment Overview CausalTrail offers four ways to submit a query: A query can be entered directly, as in the console version of CausalTrail. A query can be entered interactively. A query can be chosen from the Query History. Several queries can be executed using a Query Batch File. Direct Query Formulation Queries can be entered directly into the Edit field at the top of the Query Control Panel. Correctness of queries is checked while typing. The background color of the Edit field switches to green if the query is correct and to red otherwise. Queries can be submitted by a click on the green tick next to the Edit field or by pressing Enter. Entering queries directly requires the user to be familiar with our query language in detail. As this can not be expected from the general user, we offer an interactive query construction introduced in the next section. Interactive Query Formulation To facilitate the formulation of queries, CausalTrail supports interactive query construction. To build a query, the user has to move the mouse over a node of interest and perform a right click on it. A context menu allowing the following operations is shown: Probability of: Calculates the probability that this node obtains the specified value. Arg Max: Calculates the most likely value assignment for this node. Note that it is not possible to combine (1) and (2) in one query. Condition on: Calculates the conditional probability of other nodes given the specified value of the currently selected node. Set value to: Perform a do-intervention on the current node. The edges to the nodes parents are deleted and its own value is fixed to the selected value. Add Edge to: Adds an edge to another node. To add a new edge double click on the desired target node. The added edge will appear in red. If the new edge would induce a cycle, an error will be shon in the Log. Adding an edge causes retraining of the entire network. Once an item is selected, it is shown in one of the boxes in the Query Control Panel. A colour code and a natural language wrapper around the query item boxes help to understand the query. Double clicking on an item in the Query Control Panel removes it from the current query. In addition to the operations on nodes, there is an operation on edges. A right click on an edge opens a context menu allowing to remove the selected egde. Removed edges are shown in grey. As for adding an edge, removing one causes retraining of the network too. Query History The query history enables the user to reload a previously submitted query. There are two ways to do this: A query can be directly selected via a double click in the Query History. Using the Back and Forward arrows next to the query Edit field one can go stepwise forward or backward in query history. Query Batch Files To permit the user to quickly process a set of queries on networks trained on different data sets, CausalTrails offers Query Batch Files. A batch file containing all queries currently shown in the Query History can be created by clicking on Create Batchfile. It can be executed by a click on Execute Batchfile. Results are shown in the Log. Examples To illustrate the usage of CausalTrail further, we present a few example queries in the Student Network. Predictions In this example, we compute the probability that Intelligence obtains the value i 1. In the second example, we compute the probability that Intelligence obtains the value i 1 if Grade has value g 1 and SAT has value s 1. Interventions Here, we compute the probability that Intelligence obtains the value i 1, if we perform a do-intervention on Grade, setting its value to g 1 and given that SAT has value s 1. Counterfactuals In the last example, we compute the probability to get a letter, if we have not reveived a letter before. Sessions To avoid repeating the process of network and sample loading, CausalTrail supports sessions. A session in CausalTrail contains all currently trained networks and submitted queries. To save a session, click on Save Session in the toolbar or click File -> Save Session in the menu. A session can be restored by a click on Load Session in the toolbar or by clicking File -> Load Session in the menu...|$|E

