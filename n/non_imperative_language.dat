0|1833|Public
40|$|In this paper, {{we bring}} {{anonymous}} variables into <b>imperative</b> <b>languages.</b> Anonymous variables represent don't-care values and have proven useful in logic programming. To bring {{the same level}} of benefits into <b>imperative</b> <b>languages,</b> we describe an extension to C wth anonymous variables. Comment: 5 pages, We describe some usage of blind universal/existential quantifiers in <b>imperative</b> <b>language...</b>|$|R
50|$|Instead {{of logic}} programming, {{constraints}} can be mixed with functional programming, term rewriting, and <b>imperative</b> languages.Programming <b>languages</b> with built-in support for constraints include Oz (functional programming) and Kaleidoscope (imperative programming). Mostly, constraints are implemented in <b>imperative</b> <b>languages</b> via constraint solving toolkits, which are separate libraries for an existing <b>imperative</b> <b>language.</b>|$|R
40|$|Are <b>imperative</b> <b>languages</b> tied {{inseparably}} to the von Neumann {{model or}} {{can they be}} implemented in some natural way on dataflow architectures? In this paper, we show how <b>imperative</b> <b>language</b> programs can be translated into dataflow graphs and executed on a dataflow machine like Monsoon. This translation can exploit both fine-grain and coarse-grain parallelism in <b>imperative</b> <b>language</b> programs. More importantly, we establish a close connection between our work and current research in the <b>imperative</b> <b>languages</b> community on data dependences, control dependences, program dependence graphs, and static single assignment form. These results suggest that data ow graphs can serve as an executable intermediate representation in parallelizing compilers...|$|R
40|$|The {{semantics}} of <b>imperative</b> <b>languages</b> {{are often}} {{expressed in terms}} of a store-passing translation and an algebra for reasoning about stores. We axiomatize the semantics of several typical <b>imperative</b> <b>languages</b> via equational axioms by "inverting" the storepassing translation as well as the algebraic axioms for reasoning about the store. The inversion process is simple and systematic and results in theories that are similar to equational theories for <b>imperative</b> <b>languages</b> that have been derived in more complicated ways, and is likely to be applicable to languages other than those presented here. 1 A Semantic Toolkit for <b>Imperative</b> <b>Languages</b> The mathematical semantics of <b>imperative</b> <b>languages</b> conventionally regards the store as a primitive concept [16 :p. 203]. Using a "store-passing transformation", imperative operations are translated to explicit operations on a concrete representation of the store in an augmented lambda-calculus. The resulting store constructs typically have a simple sem [...] ...|$|R
5000|$|QVT-Operational is an <b>imperative</b> <b>language</b> {{designed}} for writing unidirectional transformations.|$|R
40|$|The syntax of an <b>imperative</b> <b>language</b> {{does not}} mention {{explicitly}} the state, while its denotational semantics has to mention it. In this paper we show that the equational proofs about an <b>imperative</b> <b>language</b> may hide the state, {{in the same way}} as the syntax does. Comment: In Proceedings ACCAT 2012, arXiv: 1208. 430...|$|R
5000|$|Introduced P′′, {{the first}} <b>imperative</b> <b>language</b> without GOTO to be proved Turing-complete.|$|R
50|$|Implementation {{techniques}} include <b>imperative</b> <b>languages</b> (object-oriented or procedural), functional languages, {{and logic}} languages.|$|R
40|$|The {{component}} based {{development is}} a well established methodology of software development. The industry, however does not take the advantage of component behavior modeling. Although the analyses of models guarantee notiobn of correctness in form of behavioral compatibility of component composition, the application in practice {{is limited by the}} expressiveness of the modeling languages {{as well as by the}} fact that the manual preparation of models is demanding and error prone task. To ease the application of behavioral modeling in practice, we propose Threaded Behavior Protocols (TBP) |a modeling language aiming at the gap between the modeling and <b>imperative</b> <b>languages</b> and the <b>imperative</b> <b>languages.</b> By providing the developers with the concepts known from the <b>imperative</b> <b>languages</b> at the model level, we enable easier preparation of component models. The theoretical framework of TBP provides the notion of correctness based on absence of communication errors and the re nement relation preserving the correctness in arbitrary environment. Thus, the analyses supported by the framework provide similar bene ts as the legacy modeling languages, however considering also the <b>imperative</b> <b>language</b> concepts...|$|R
40|$|The goal of {{declarative}} {{programming is}} to provide languages and implementations which let the programmer write programs by specifying what {{the properties of the}} desired solutions should be. In <b>imperative</b> <b>languages,</b> the calculation steps leading to the solutions must be programmed explicitly. The programming language Turtle combines traditional <b>imperative</b> <b>language</b> constructs and declarative constraints. This blending of paradigms is called ``constraint imperative programming'' in literature, and Turtle is one instance of this multiparadigm approach...|$|R
40|$|Program {{analysis}} and specialisation for declarative languages have been subjects of active research {{during the last}} 2 decades or so. <b>Imperative</b> <b>languages</b> could benet from the advances made in declarative languages but most research on {{analysis and}} specialisation is language-specic. Thus, it would be desirable to build connections between both worlds, enabling the transfer of results {{from one to the}} other. The semantics of an <b>imperative</b> programming <b>language</b> can be expressed as a program in a declarative constraint language. Not only does this render the semantics (as potentially) executable, but it opens up the possibility of applying to <b>imperative</b> <b>languages</b> the advances made in program analysis and transformation of declarative languages. This thesis presents results on analysis and specialisation of imperative programs through analysis and specialisation of constraint logic programs. The cornerstone of this connection is a constraint logic program capturing the structural operational semantics of the subject <b>imperative</b> <b>language</b> whose programs are to be specialise...|$|R
25|$|One {{criticism}} of <b>imperative</b> <b>languages</b> is the {{side effect of}} an assignment statement on a class of variables called non-local variables.|$|R
50|$|For <b>imperative</b> <b>language</b> the {{overhead}} is {{to define the}} function, for functional language {{the overhead}} is to define the accumulator variable x.|$|R
50|$|State-full <b>imperative</b> <b>languages</b> such as ALGOL and Pascal {{essentially}} {{implement a}} let expression, to implement restricted scope of functions, in block structures.|$|R
40|$|Relying on the formulae-as-types {{paradigm}} for classical logic, we define a program logic for an <b>imperative</b> <b>language</b> with higher-order procedural variables and non-local jumps. Then, we show how to derive a sound program logic for this programming language. As a by-product, we obtain a non-dependent type system {{which is more}} permissive than what is usually found in statically typed <b>imperative</b> <b>languages.</b> As a generic example, we encode imperative versions of delimited continuations operators shift and reset...|$|R
50|$|Most {{computer}} programming languages support recursion by allowing a function to call itself within the program text. Some functional programming languages do not define any looping constructs but {{rely solely on}} recursion to repeatedly call code. Computability theory proves that these recursive-only languages are Turing complete; they are as computationally powerful as Turing complete <b>imperative</b> <b>languages,</b> meaning they can solve {{the same kinds of}} problems as <b>imperative</b> <b>languages</b> even without iterative control structures such as “while” and “for”.|$|R
40|$|Abstract. We {{present a}} {{view on the}} problem of formal {{verification}} of imperative programs. Formal verification is usually associated to functional programming languages, but a real-world application will probably be written in <b>imperative</b> main-stream <b>languages.</b> To have the power of formal verification in an <b>imperative</b> <b>language,</b> we present, for demonstrative purposes, an instance of a technique to extend a language with support for logical annotations. We present a short description of LISS (the <b>imperative</b> <b>language</b> chosen to be extended) and Why (the verification condition generator), and after a detailed analysis of the mechanisms used to generate proof-obligations, we conclude, analyzing the global quality of the result...|$|R
50|$|<b>Imperative</b> <b>languages</b> such as Java {{provide a}} notion of {{imperative}} variables, which basically represent memory locations that can be written to and read from.|$|R
40|$|Abstract: An <b>imperative</b> {{programming}} <b>language</b> {{is defined}} by closure of a free word-algebra of de/con-structors under two new operators (simultaneous safe recurrence and constructive diagonalization). By assigning ordinals to its programs a transfinite hierarchy of <b>imperative</b> <b>languages</b> is introduced which singles-out the feasible classes DTIMEF(n k) and the superexponential classes DTIMEF (k n) ...|$|R
40|$|Most commonly-used {{programming}} {{languages are}} imperative: they {{consist of a}} sequence of actions that alter {{the state of the}} world. State includes the values of program variables and also the program’s external environment (e. g. files the program reads or writes). High-level <b>imperative</b> <b>languages</b> mimic the style of the underlying Von Neumann machine architecture, where programs are sequences of instructions that modify the contents of registers and memory locations. This makes it relatively straightforward to compile <b>imperative</b> <b>languages</b> to efficient code: • High-level variables are mapped to machine locations. • High-level operations are mapped to (multiple) machine instructions. <b>Imperative</b> <b>languages</b> are also natural for writing reactive programs that interact with the state of the “real world. ” Examples: • Reading mouse clicks and modifying the contents of a display. • Controlling a set of relays in an external device...|$|R
50|$|Like most query languages, D4 has a Data Definition Language (DDL) and a Data Manipulation Language (DML). D4 {{also has}} an <b>Imperative</b> <b>Language</b> for {{procedural}} code.|$|R
40|$|Constraint <b>imperative</b> {{programming}} <b>languages</b> combine declarative {{constraints and}} <b>imperative</b> <b>language</b> features into an integrated programming language. The language Turtle supports these programming paradigms and additionally integrates functional programming with higher-order functions and algebraic data types. This paper describes {{the implementation of}} Turtle, consisting of a compiler, a run-time system including constraint solvers and an extensive library of supporting modules...|$|R
50|$|In <b>imperative</b> {{programming}} <b>languages,</b> values can {{generally be}} accessed or changed at any time. In pure functional and logic languages, variables {{are bound to}} expressions and keep a single value during their entire lifetime due {{to the requirements of}} referential transparency. In <b>imperative</b> <b>languages,</b> the same behavior is exhibited by constants, which are typically contrasted with normal variables.|$|R
40|$|Carlsson and Hallgren [1] {{describe}} {{the implementation of}} a set of "functional widgets" (Fudgets) : components for programming graphical user interfaces under the X window system using the nonstrict functional programming language Haskell. We describe an alternative implementation based on existing widget sets (currently Openlook and Motif). Our purpose is twofold: to show that the Fudgets approach can be applied to existing widget sets; and to discuss problems experienced with Fudgets during an industrial case study. 1 Introduction <b>Imperative</b> <b>language</b> programmers enjoy relatively easy access to the graphics resources of workstations. The graphics hardware is manipulated by side-effecting procedure calls. Even if the library of graphics procedures is written in one <b>imperative</b> <b>language</b> (e. g `C'), programs written in another <b>imperative</b> <b>language</b> can usually make calls to foreign procedures. For example, Ada allows foreign procedures to be called by giving a standard pragma. Ada compilers a [...] ...|$|R
50|$|The {{scripting}} <b>language</b> is an <b>imperative</b> <b>language,</b> lacking most {{program flow}} control structures, but containing many features familiar to programmers, including variables, distinct datatypes, conditionals, and complex expressions.|$|R
40|$|Course aims Programming {{languages}} communicate {{programs to}} a computer and every computing professional must know their history, purposes, styles and means of implementation. While use of an object-oriented programming language (i. e. Java) was used in first year courses, COSC 230 looks at the history and concepts of functional and logic-based programming styles, {{as well as at}} implementation techniques for <b>imperative</b> <b>languages.</b> Students will learn basic techniques for implementing <b>imperative</b> <b>languages</b> and how to employ and choose competently among a variety of programming tools, including functional and logic-based languages...|$|R
40|$|Declarative {{programming}} languages (e. g., {{functional and}} logic programming languages) are semantically elegant and implicitly express parallelism {{at a high}} level. We show how a parallel declarative language can {{be based on a}} modern structured <b>imperative</b> <b>language</b> with single-assignment variables. Such a language combines the advantages of parallel declarative programming with the strengths and familiarity of the underlying <b>imperative</b> <b>language.</b> We introduce Declarative Ada, a parallel declarative language based on a subset of Ada. Declarative Ada integrates parallel and sequential composition, allowing sequential input and output from within parallel declarative programs. ...|$|R
40|$|Architecture The Alma Abstract Architecture (AAA) is {{the virtual}} {{architecture}} {{used during the}} intermediate code generation phase of the Alma- 0 compiler. The AAA combines {{the features of the}} abstract machines for <b>imperative</b> <b>languages</b> and for logic programming languages. The compiler compiles the Alma- 0 programs into AAA programs. In a second phase the AAA instructions are translated into C statements. As the Alma- 0 language itself, the AAA aims to combine the best of both worlds; elements were taken from virtual machines used to compile <b>imperative</b> <b>languages</b> (in particular the RISC architecture described in Wirth [1996, pp. 55 [...] 59], and from the WAM machine used to compile a logical language (see Ait-Kaci [1991]). Still, the AAA resembles most the virtual machines used in the compilation of <b>imperative</b> <b>languages.</b> The additions made to provide for the extensions of the Alma- 0 language are [...] -the failure handling instructions ONFAIL, FAIL, 40 Δ Krzysztof R. Apt et al [...] -the log [...] ...|$|R
50|$|In {{this section}} we compare how {{particular}} programming idioms are handled in a functional language with first-class functions (Haskell) {{compared to an}} <b>imperative</b> <b>language</b> where functions are second-class citizens (C).|$|R
50|$|Immutability of {{data can}} {{in many cases}} lead to {{execution}} efficiency by allowing the compiler to make assumptions that are unsafe in an <b>imperative</b> <b>language,</b> thus increasing opportunities for inline expansion.|$|R
50|$|OptimJ {{combines}} concepts from object-oriented <b>imperative</b> <b>languages</b> with concepts from algebraic modeling languages for optimization problems. Here we {{will review}} the optimization concepts added to Java, starting with a concrete example.|$|R
50|$|The <b>Imperative</b> <b>Language</b> in D4 {{is remarkably}} similar to Pascal in many respects. The largest {{distinction}} being that D4 also allows DDL and DML statements to be run in regular procedural code.|$|R
40|$|Despite {{the code}} is rarely self-explanatory, the <b>imperative</b> {{programming}} <b>languages</b> {{are the most}} commonly used in our days by the programmers {{all over the world and}} Java is definitely the lead language in popularity. This paper tries to conclude if there are any chances to use the most popular programming language of the moment in a declarative manner, even if Java itself is an intrinsic <b>imperative</b> <b>language...</b>|$|R
50|$|Specifically, {{the term}} command {{is used in}} <b>imperative</b> {{computer}} <b>languages.</b> These languages are called this, because statements in these languages are usually written {{in a manner similar}} to the imperative mood used in many natural languages. If one views a statement in an <b>imperative</b> <b>language</b> as being like a sentence in a natural language, then a command is generally like a verb in such a language.|$|R
40|$|Operational {{semantics}} {{for programming}} languages usually {{come in two}} flavours: big-step and small-step. Both are defined using deduction rules with a congruence rule allowing reduction in certain contexts. For a description based on rewrite rules, known approaches consist in deriving an abstract machine, which {{is very close to}} implementation. In this paper, we describe the operational semantics of an <b>imperative</b> <b>language</b> in a rule-based style, arguably as abstract as the other kinds of semantics. Moreover, we combine the approach with the store-based semantics, which puts the focus on memory states rather than values, which is more appropriate for <b>imperative</b> <b>languages...</b>|$|R
40|$|In {{this article}} we {{consider}} the polymorphic type checking of an <b>imperative</b> <b>language.</b> Our language contains variables, first-class references (pointers), and first-class functions. Variables, as in traditional <b>imperative</b> <b>languages,</b> are implicitly dereferenced, and their addresses (L-values) are not first-class values. Variables are easier to type check than references and, in many cases, lead to more general polymorphic types. We present a polymorphic type system for our language and prove that it is sound. Programs that use variables sometimes require weak types, as in Tofte's type system for Standard ML, but such weak types arise far less frequently with variables than with reference...|$|R
