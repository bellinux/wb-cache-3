18|65|Public
50|$|Individual {{elements}} can be inserted, updated, and deleted in a <b>nested</b> <b>table.</b> Since individual elements can {{be modified}} in a <b>nested</b> <b>table,</b> they are more flexible than an array because elements in an array can only be modified as a whole, not individually. A <b>nested</b> <b>table</b> doesn't have a maximum size, and an arbitrary number of elements {{can be stored in}} it.|$|E
50|$|A <b>nested</b> <b>table</b> is not {{in first}} normal form.|$|E
5000|$|In {{relational}} databases, a <b>nested</b> <b>table</b> is a {{table that}} is embedded within another table.|$|E
50|$|Features: Visual Basic macros, OLE Objects and {{embedded}} audio/video; {{support for}} <b>nested</b> <b>tables,</b> presentation masters and DataPilot tables for pivoting on large datasets.|$|R
50|$|In {{the late}} 1990s the first {{reasonably}} powerful WYSIWYG editors {{arrived on the}} market, which meant Web designers no longer needed a technical understanding of HTML to build web pages. Such editors indirectly encourage extensive use of <b>nested</b> <b>tables</b> to position design elements. As designers edit their documents in these editors, unnecessary code and empty elements {{can be added to}} the document. Furthermore, unskilled designers may use tables more than required when using a WYSIWYG editor. This practice can lead to many <b>tables</b> <b>nested</b> within <b>tables</b> as well as tables with unnecessary rows and columns.|$|R
50|$|<b>Nested</b> <b>tables</b> are a set {{of small}} tables of {{graduated}} size that can be stacked together, each fitting within the one immediately larger. They are for occasional use (such as a tea party), hence the stackable design.|$|R
50|$|The {{purpose of}} a PL/SQL {{function}} is generally to compute and return a single value. This returned value may be a single scalar value (such as a number, date or character string) or a single collection (such as a <b>nested</b> <b>table</b> or varray). User-defined functions supplement the built-in functions provided by Oracle Corporation.|$|E
50|$|Looking at {{the images}} to the right, the on above depicts the {{relational}} model {{and has the}} data spread over two tables, with the parent in amber and the children in blue. In the object model, both the parent and children are stored in the one data record, the information that was previously stored within the related table is now stored within the sub or <b>nested</b> <b>table</b> of Foo.|$|E
50|$|In 1970, E.F. Codd {{proposed}} the relational data model which was widely accepted {{as the standard}} data model. At that time, office automation was the major use of data storage systems, which resulted in proposal of many NF2 data models like Schek model, Jaeschke models (Non-recursive and recursive algebra) and <b>Nested</b> <b>Table</b> Data (NTD) model. IBM organized the first international workshop exclusively on this topic in 1987 which was held in Darmstadt,Germany. Moreover, {{a lot of research}} has been done and journals have been published to address the shortcomings of relational model. Since the turn of the century, NoSQL databases have become more and more popular owing to the demands of Web 2.0.|$|E
50|$|Casegoods {{are one of}} {{the three}} classifications of furniture, the others being {{upholstery}} and occasional. Upholstery refers to furniture that has fabric or leather and padding stretched over a frame. Occasional furniture includes coffee <b>tables,</b> end <b>tables,</b> <b>nesting</b> <b>tables,</b> ottomans, and accent stools.|$|R
40|$|In this paper, the <b>nested</b> <b>tables</b> {{feature in}} relational- object {{database}} is applied {{along with the}} feature of Mutation in Genetic Algorithms (GA) {{to solve the problem}} of timetabling, especially coursework timetables. The advantage of using <b>nested</b> <b>tables</b> is utilized to cancel a lot of conflicts and improve the operations of the Mutation in GA for the ideal solutions of multi-fewest number of generations and a short time has been concluded infer. Our approach conducted by this paper which is called NTMGA has been implemented and applied to timetable problem of Computer Science Department at the University of Science and Technology (UST). Results proved a satisfactory performance of NTMGA approach in terms of the absence of conflicts and a fast release of schedules has been obtained...|$|R
40|$|This paper {{proposes a}} system for {{representing}} and querying semistructured data. The proposed system provides a QBE-like interface over <b>nested</b> <b>tables,</b> which may have internal nested structural variations to accommodate semistructured data. Our motivation {{is to reduce the}} complexity found in typical query languages for semistructured data and to provide users with an alternative for quickly querying data obtained from multiple-record Web pages. We show the feasibility of our proposal by developing a prototype for a graphical query interface called QSByE (Querying Semistructured data By Example). For QSByE, we define a particular variation of <b>nested</b> <b>tables</b> and propose a set of query operations that extends typical nested-relational-algebra operations to handle semistructured data. We show examples of how users can pose interesting queries using QSByE...|$|R
40|$|Abstract: We {{introduce}} ESCHER, {{a prototype}} database {{system based on}} the extended non-first-normal-form data model. The <b>nested</b> <b>table</b> approach is the paradigm for the graphical interface which allows browsing, editing and querying the database. Interaction is achieved by fingers generalizing the well-known cursor concept. We focu...|$|E
40|$|This paper {{introduces}} a visual interface for computer-supported cooperative work (CSCW). The interface {{is an extension}} of the editor interface of ESCHER, a prototype database system based on the extended non-first-normal-form data model. In ESCHER, the <b>nested</b> <b>table</b> approach is the paradigm for presenting data, where presenting includes browsing, editing and querying the database. Interaction is achieved by fingers generalising the well-known cursor concept. When several users are involved, the concept permits synchronous collaboration with the <b>nested</b> <b>table</b> acting as "whiteboard". We discuss its use in applications which require negotiated transactions, i. e. where the isolation principle of ACID-transactions gives way to negotiations. We also give examples of how interactive query formulation in a QBE-like fashion can support the collaboration. The arguments in the paper are mainly supported with screenshots taken from two applications, one of them also with non-textual data types whi [...] ...|$|E
40|$|Abstract: This paper {{introduces}} a visual interface for computer-supported cooperative work (CSCW). The interface {{is an extension}} of the editor interface of ESCHER, a prototype database system based on the extended non-first-normal-form data model. In ESCHER, the <b>nested</b> <b>table</b> approach is the paradigm for presenting data, where presenting includes browsing, editing and querying the database. Interaction is achieved by fingers generalising the well-known cursor concept. When several users are involved, the concept permits synchronous collaboration with the <b>nested</b> <b>table</b> acting as “whiteboard“. We discuss its use in applications which require negotiated transactions, i. e. where the isolation principle of ACID-transactions gives way to negotiations. We also give examples of how interactive query formulation in a QBE-like fashion can support the collaboration. The arguments in the paper are mainly supported with screenshots taken from two applications, one of them also with non-textual data types which are seamlessly integrated into the nested tabular display paradigm. ...|$|E
50|$|With <b>nested</b> <b>tables</b> the {{programmer}} {{needs to}} understand what is nested. Here, a new type is created that may be composed of a number of components. That type can then be used to make a column in a <b>table,</b> and <b>nested</b> within that column are those components.|$|R
50|$|Programmers must specify {{an upper}} limit for varrays, but need not for index-by <b>tables</b> or for <b>nested</b> <b>tables.</b> The {{language}} includes several collection {{methods used to}} manipulate collection elements: for example FIRST, LAST, NEXT, PRIOR, EXTEND, TRIM, DELETE, etc. Index-by tables {{can be used to}} simulate associative arrays, as in this example of a memo function for Ackermann's function in PL/SQL.|$|R
40|$|Most {{real life}} data are {{relational}} by nature. Database mining integration {{is an essential}} goal to be achieved. Microsoft SQL Server (MSSQL) seems to provide an interesting and promising environment to develop aggregated multi-relational data mining algorithms by using <b>nested</b> <b>tables</b> and the plug-in algorithm approach. However, it is currently unclear how these <b>nested</b> <b>tables</b> can best be used by data mining algorithms. In this paper we {{look at how the}} Microsoft Decision Trees (MSDT) handles multi-relational data, and we compare it with the multi-relational decision tree learner TILDE. In the experiments we perform, MSDT has equally good predictive accuracy as TILDE, but the trees it gives either ignore the relational information, or use {{it in a way that}} yields noninterpretable trees. As such, one could say that its explanatory power is reduced, when compared to a multi-relational decision tree learner. We conclude that it may be worthwhile to integrate a multi-relational decision tree learner in MSSQL...|$|R
30|$|List {{screening}} {{is realized}} by modified and nested tables. The segment head of custom table {{is used as}} first-level screening title. Second-level screening catalog is achieved by <b>nested</b> <b>table</b> and custom table cells. By nesting second-level screening catalog, we obtain third-level screening catalog. The subtitle of first-level catalog is refreshed by recording the selected filter item in real time. Simultaneously, the server is synchronized to get the remaining product information.|$|E
40|$|This paper {{presents}} an end-user-oriented programming environment called Mashroom. Major contributions herein include an end-user programming model with an expressive data structure {{as well as}} a set of formally-defined mashup operators. The data structure takes advantage of <b>nested</b> <b>table,</b> and maintains the intuitiveness while allowing users to express complex data objects. The mashup operators are visualized with contextual menu and formula bar and can be directly applied on the data. Experiments and case studies reveal that end users have little difficulty in effectively and efficiently using Mashroom to build mashup applications. Categories and Subject Descriptor...|$|E
40|$|We {{introduce}} ESCHER, {{a prototype}} database {{system based on}} the extended non-first-normal-form data model. The <b>nested</b> <b>table</b> approach is the paradigm for the graphical interface which allows browsing, editing and querying the database. Interaction is achieved by fingers generalizing the well-known cursor concept. We focus on interactive query formulation for nested tables in a QBE-like fashion which is suitable for ad-hoc queries by casual users. The paper closes with examples of nontextual data types which are seamlessly integrated into the data model and the interface. 1 Introduction ESCHER is a prototype database system supporting non-standard applications in engineering, science, tourism, and the entertainment industry. ESCHER originated in 1987 {{as part of a}} joint research project with IBM Scientific Center Heidelberg and became operational in 1989 as a database editor [10, 16, 17, 18]. The underlying data model is an extension of the classical NF 2 (non first normal form) data [...] ...|$|E
25|$|A grid view, however, can be mimicked {{by using}} a {{standard}} HTML table with each cell containing a text input element. A tree view could also be mimicked through <b>nested</b> <b>tables</b> or, more semantically appropriately, nested lists. In both cases, a server-side process is responsible for processing the information, while JavaScript handles the user-interaction. Implementations of these interface elements are available through JavaScript libraries such as jQuery.|$|R
40|$|AbstractA {{generalization}} of ET 0 L systems is introduced: grammars with branching synchronization and <b>nested</b> <b>tables.</b> The main {{result is that}} branching synchronization grammars with <b>tables</b> of <b>nesting</b> depth n have the same string- and tree-generating power as n-fold compositions of top-down tree transducers. Based on this it is shown, e. g., that the family of generated string languages is a full principal AFL for each n...|$|R
5000|$|HTML {{generated}} by WD is neither semantic nor readily readable: many UI layout elements are combinations of deeply <b>nested</b> <b>tables,</b> divs, and spans. For example, rather than utilizing a fieldset (two elements including legend) for the Group UI element, WD recreates it with two spans surrounding a two row table with further spans, a div, and a wbr {{for a total}} of 13 elements.|$|R
40|$|Domain-specific {{database}} applications tend {{to contain}} a sizable number of table-, form-, and report-style views that must each be designed and maintained by a software developer. A significant part of this job is the necessary tweaking of low-level presentation details such as label placements, text field dimensions, list or table styles, and so on. In this paper, we present a horizontally constrained layout management algorithm that automates the display of structured hierarchical data using the traditional visual idioms of hand-designed database UIs: tables, multi-column forms, and outline-style indented lists. We compare our system with pure outline and <b>nested</b> <b>table</b> layouts with respect to space efficiency and readability, the latter with an online user study on 27 subjects. Our layouts are 3. 9 and 1. 6 times more compact on average than outline layouts and horizontally unconstrained table layouts, respectively, and are as readable as table layouts even for large datasets...|$|E
40|$|Abstract. The {{extraction}} of {{the relations of}} <b>nested</b> <b>table</b> headers to content cells is automated {{with a view to}} constructing narrow domain ontologies of semistructured web data. A taxonomy of tessellations for displaying tabular data is developed. X-Y tessellations that can be obtained by a divide-and-conquer method are asymptotically only an infinitesimal fraction of all partitions of a rectangle into rectangles. Admissible tessellations are the even smaller subset of all partitions that correspond to the structures of published tables and that contain only rectangles produced by successive guillotine cuts. Many of these can be processed automatically. Their structures can be conveniently represented by X-Y trees, which facilitate relating hierarchical row and column headings to content cells. A formal grammar is proposed for characterizing the X-Y trees of layout-equivalent admissible tessellations. Algorithms are presented for transforming a tessellation into an X-Y tree and hence into multidimensional, layout- independent Category Trees (Wang abstract data types) ...|$|E
40|$|Fig. 1. Interactive {{adaptation}} of {{the layout of the}} data to be displayed, based on the available horizontal width of an on-screen window. Abstract—Domain-specific database applications tend to contain a sizable number of table-, form-, and report-style views that must each be designed and maintained by a software developer. A significant part of this job is the necessary tweaking of low-level presentation details such as label placements, text field dimensions, list or table styles, and so on. In this paper, we present a horizontally constrained layout management algorithm that automates the display of structured hierarchical data using the traditional visual idioms of hand-designed database UIs: tables, multi-column forms, and outline-style indented lists. We compare our system with pure outline and <b>nested</b> <b>table</b> layouts with respect to space efficiency and readability, the latter with an online user study on 27 subjects. Our layouts are 3. 9 and 1. 6 times more compact on average than outline layouts and horizontally unconstrained table layouts, respectively, and are as readable as table layouts even for large datasets. Index Terms—Hierarchy data, tabular data, nested relations, layout management...|$|E
5000|$|TACPOL {{supports}} fixed-point binary numeric data, fixed-length character strings up to 512 bytes, and fixed-length bit strings up to 32 bits. There is {{no support}} for floating point numeric data or for pointers. Arrays may {{have up to}} three dimensions, but dynamic bounds are not permitted. Additional types are records, called groups, limited to a single level of <b>nesting,</b> <b>tables</b> (arrays of groups), and unions, called cells.|$|R
40|$|Abstract- The {{traditional}} webpage using <b>nested</b> <b>tables</b> for webpage, {{this method}} has {{the advantages of}} simple operation, but generates redundancy HTML code which is not conducive to find and manage, prolix. however, CSS webpage layout is a concise code, more functional, higher flexibility of webpage layout design method. This article presents a method of personal blog of webpage design and application based on CSS. Index Terms- table layouts, CSS, webpage design 1...|$|R
50|$|Unfortunately {{there are}} a number of {{unsupported}} objects (e.g. tables or sequences owned by SYS, tables that use table compression, tables that underlie a materialized view or Global temporary tables (GTTs)) and unsupported data types (i.e.: datatypes BFILE, ROWID, and UROWID, user-defined TYPEs, multimedia data types like Oracle Spatial, ORDDICOM, and Oracle Text Collections (e.g. <b>nested</b> <b>tables,</b> VARRAYs), SecureFile LOBs, OBJECT RELATIONAL XMLTypes and BINARY XML). Physical standby may not be appropriate in such a case.|$|R
40|$|Abstract. Recently, {{there have}} emerged more {{sophisticated}} applications, which have to represent complex objects related with complex relationships, such as aggregations and compositions. New object-relational databases are more appropriated than relational databases to support complex objects. Besides, {{the most common}} way of designing databases is using the E/R model, without taking in account the program design. However, new object-oriented design techniques, such as UML (Universal Modelling Language), permit modelling the full system, including the database schema, in a uniform way. Besides, as UML is an extensible language, it allows introducing new stereotypes for specific applications if it is needed. So, new stereotypes for database design can be also defined. The framework {{of this paper is}} an Object-Relational Database Design Methodology. The methodology specifies new UML stereotypes for Object-Relational Database Design as well as it proposes some guidelines to translate an UML schema into an object-relational one. The guidelines are based on the SQL: 1999 object-relational model and in Oracle 8 i as an example of product. In this paper we focus on the design of two UML constructors: aggregation and composition. We propose its implementation in Oracle 8 i, because unlike SQL: 1999, Oracle 8 i supports a data type, the <b>nested</b> <b>table,</b> that is specially appropriated to represent the UML aggregation and composition...|$|E
40|$|JSON (JavaScript Object Notation) is a {{lightweight}} data-interchange format for the Internet. JSON {{is built on}} two structures: (1) a collection of name/value pairs and (2) an ordered list of values ([URL] Because of this simple approach, JSON is {{easy to use and}} {{it has the potential to}} be the data interchange format of choice for the Internet. Similar to XML, JSON schemas allow nested structures to model hierarchical data. As data interchange over the Internet increases exponentially due to cloud computing or otherwise, redundancy free JSON data are an attractive form of communication because they improve the quality of data communication through eliminating update anomaly. Nested Normal Form, a normal form for hierarchical data, is a precise characterization of redundancy. A <b>nested</b> <b>table,</b> or a hierarchical schema, is in Nested Normal Form if and only if it is free of redundancy caused by multivalued and functional dependencies. Using Nested Normal Form as a guide, this paper introduces a JSON schema design methodology that begins with UML use case diagrams, communication diagrams and class diagrams that model a system under study. Based on the use cases’ execution frequencies and the data passed between involved parties in the communication diagrams, the proposed methodology selects classes from the class diagrams to be the roots of JSON scheme trees and repeatedly adds classes from the class diagram to the scheme trees as long as the schemas satisfy Nested Normal Form. This process continues until all of the classes in the class diagram have been added to some JSON scheme trees...|$|E
40|$|The longstanding {{problem of}} {{automatic}} table interpretation still eludes us. Its solution {{would not only}} be an aid to table processing applications such as large volume table conversion, but would also be an aid in solving related problems such as information extraction, semantic annotation, and semi-structured data management. In this paper, we offer a solution for the common special case in which so-called sibling pages are available. The sibling pages we consider are pages on the hidden web, commonly generated from underlying databases. Our system compares them to identify and connect nonvarying components (category labels) and varying components (data values). We tested our solution using more than 2, 000 tables in source pages from three different domains — car advertisements, molecular biology, and geopolitical information. Experimental {{results show that the}} system can successfully identify sibling tables, generate structure patterns, interpret tables using the generated patterns, and automatically adjust the structure patterns as it processes a sequence of hidden-web pages. For these activities, the system was able to achieve an overall F-measure of 94. 5 %. Further, given that we can automatically interpret tables, we next show that this leads immediately to a conceptualization of the data in these interpreted tables and thus also to a way to semantically annotate these interpreted tables with respect to the ontological conceptualization. Labels in <b>nested</b> <b>table</b> structures yield ontological concepts and interrelationships among these concepts, and associated data values become annotated information. We further show that semantically annotated data leads immediately to queriable data. Thus, the entire process, which is fully automatic, transform facts embedded within tables into facts accessible by standard query engines...|$|E
50|$|This {{causes a}} number of problems. Many web pages were {{designed}} with <b>tables</b> <b>nested</b> within <b>tables,</b> resulting in large HTML documents that use more bandwidth than documents with simpler formatting. Furthermore, when a table-based layout is linearized, for example when being parsed by a screen reader or a search engine, the resulting order of the content can be somewhat jumbled and confusing.|$|R
40|$|Abstract. This paper compares graph-oriented with tabular {{representations}} in {{the context}} of database editors and argues that displaying data in tables is to be preferred on the instance level. In particular, <b>nested</b> <b>tables</b> are advocated and design and user interaction issues for a database editor based on this complex object data model are described. This then leads to the concept of spatial cursors which serve a variety of purposes. The argu-ment is supported with illustrations taken from a running prototype named ESCHER. ...|$|R
50|$|Rapid Virtualization Indexing (RVI), {{known as}} <b>Nested</b> Page <b>Tables</b> (NPT) during its development, is an AMD second {{generation}} hardware-assisted virtualization {{technology for the}} processor memory management unit (MMU).|$|R
