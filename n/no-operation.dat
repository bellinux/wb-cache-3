20|4|Public
25|$|The use of deep packet {{inspection}} (DPI) can detect, at {{the network}} perimeter, very basic remote attempts to exploit buffer overflows by use of attack signatures and heuristics. These are able to block packets which have the signature of a known attack, or if {{a long series of}} <b>No-Operation</b> instructions (known as a NOP-sled) is detected, these were once used when the location of the exploit's payload is slightly variable.|$|E
2500|$|For example, on the IA-32 architecture, here's how two NOP (<b>no-operation)</b> {{instructions}} would look, first unencoded: ...|$|E
5000|$|The {{semicolon}} (";") is {{a statement}} terminator, and the null or <b>no-operation</b> statement is [...] A single [...] without a statement to terminate is not allowed.|$|E
25|$|This is why {{the pointer}} {{placement}} delete functions are defined as <b>no-operations</b> by the Standard C++ library. Since the pointer placement new functions do not allocate any storage, there is no storage to be deallocated {{in the event of}} the object's constructor throwing an exception.|$|R
5000|$|The central {{processor}} had 60-bit words, while the peripheral processors had 12-bit words. CDC {{used the term}} [...] "byte" [...] to refer to 12-bit entities used by peripheral processors; characters were 6-bit, and {{central processor}} instructions were either 15 bits, or 30 bits with a signed 18-bit address field, the latter allowing for a directly addressable memory space of 128K words of central memory (converted to modern terms, with 8-bit bytes, this is 0.94 MB). The signed nature of the address registers limited an individual program to 128K words. (Later CDC 6000-compatible machines could have 256K or more words of central memory, budget permitting, but individual user programs were still limited to 128K words of CM.) Central processor instructions started on a word boundary when they were {{the target of a}} jump statement or subroutine return jump instruction, so <b>no-operations</b> were sometimes required to fill out the last 15, 30 or 45 bits of a word.|$|R
40|$|Abstract. Very Long Instruction Word (VLIW) {{architectures}} exploit instruction level parallelism (ILP) {{with the}} help of the compiler to achieve higher instruction throughput with minimal hardware. However, control and data dependencies between operations limit the available ILP, which not only hinders the scalability of VLIW architectures, but also result in code size expansion. Although speculation and predicated execution mitigate ILP limitations due to control dependencies to a certain extent, they increase hardware cost and exacerbate code size expansion. Simultaneous multistreaming (SMS) can significantly improve operation throughput by allowing interleaved execution of operations from multiple instruction streams. In this paper we study SMS for VLIW architectures and quantify the benefits associated with it using a case study of the MPEG- 2 video decoder. We also propose the notion of virtual resources for VLIW architectures, which decouple architectural resources (resources exposed to the compiler) from the microarchitectural resources, to limit code size expansion. Our results for a VLIW architecture demonstrate that: (1) SMS delivers much higher throughput than that achieved by speculation and predicated execution, (2) the increase in performance due to the addition of speculation and predicated execution support over SMS averages around 12 %. The minor increase in performance might not warrant the additional hardware complexity involved, and (3) the notion of virtual resources is very effective in reducing <b>no-operations</b> (NOPs) and consequently reduce code size with little or no impact on performance. ...|$|R
5000|$|... 0003 NOOP 00 0000 0000 <b>No-operation</b> {{instruction}}, next {{instruction address}} is 0000 0000 HALT 01 0000 8000 Halt, next instruction address is the console (this Halt instruction was stored in 0000 by the STD instruction above) ...|$|E
5000|$|In {{computer}} security, a NOP slide, NOP sled or NOP ramp is {{a sequence}} of NOP (<b>no-operation)</b> instructions meant to [...] "slide" [...] the CPU's instruction execution flow to its final, desired destination whenever the program branches to a memory address anywhere on the slide.|$|E
5000|$|Operate [...] - [...] increment/decrement register, ones {{complement}} register, negate (twos-complement) register, move register to register, move console switches to register, increment register and skip on test. All the above operate instructions used {{one or more}} of registers A, B, or C. There were also wait and a <b>no-operation</b> operate instructions.|$|E
5000|$|For example, on the IA-32 architecture, here's how two [...] (<b>no-operation)</b> {{instructions}} would look, first unencoded: 90 NOP 90 NOPThen encoded into {{a string}} using percent-encoding (using the [...] function to decode): unescape("%u9090");Next encoded into a string using [...] "\uXXXX"-encoding: [...] "\u9090";And finally encoded into a string using entity encoding: [...] "&#x9090;"or [...] "&#37008;" ...|$|E
50|$|The use of deep packet {{inspection}} (DPI) can detect, at {{the network}} perimeter, very basic remote attempts to exploit buffer overflows by use of attack signatures and heuristics. These are able to block packets which have the signature of a known attack, or if {{a long series of}} <b>No-Operation</b> instructions (known as a NOP-sled) is detected, these were once used when the location of the exploit's payload is slightly variable.|$|E
50|$|With NOP-Fills, the {{reliability}} of a system {{in case of a}} disturbed instruction pointer can be improved in some cases. The entire program memory that is not used by the program code is filled with <b>No-Operation</b> (NOP) instructions. In machine code a NOP instruction is often represented by 0x00 (for example, Intel 8051, ATmega16, etc.). The system is kept in a defined state. At the end of the physical program memory, an instruction pointer error handling (IPEH IP-Error-Handler) has to be implemented. In some cases this can be a simple reset.|$|E
50|$|Other {{requests}} and {{events in the}} core protocol exist. The first kind of requests is relative to the parent relationship between windows: a client can request to change {{the parent of a}} window, or can request information about the parenthood of windows. Other requests are relative to the selection, which is however mostly governed by other protocols. Other requests are about the input focus and the shape of the pointer. A client can also request the owner of a resource (window, pixmap, etc.) to be killed, which causes the server to terminate the connection with it. Finally, a client can send a <b>no-operation</b> request to the server.|$|E
50|$|Mill uses a {{very long}} {{instruction}} word (VLIW)-style encoding to store up to 33 simple operations in wide instruction words, termed opcodes. Mill uses two program counters, and every wide instruction is split into two parts. One of the program counters counts backward. So, the code of every linear instruction block is executed from its middle to outside by two almost independent decoders. Unused operations are deleted by a small fixed-format data item {{in the center of}} each instruction. This helps maintain code density by reducing the incidence of <b>no-operation</b> codes in Mill code. It also allows each functional unit to start speculatively executing its instruction field, and then discard its result if it has no instruction.|$|E
50|$|However, {{consider}} the following instructions: LD adr -> r10 AND r10,r3 -> r11The data read from the address adr isn't present in the data cache until after the Memory Access stage of the LD instruction. By this time, the AND instruction is already through the ALU. To resolve this would require the data from memory to be passed backwards {{in time to the}} input to the ALU. This is not possible. The solution is to delay the AND instruction by one cycle. The data hazard is detected in the decode stage, and the fetch and decode stages are stalled - they are prevented from flopping their inputs and so stay in the same state for a cycle. The execute, access, and write-back stages downstream see an extra <b>no-operation</b> instruction (NOP) inserted between the LD and AND instructions.|$|E
30|$|Another approach, {{to reduce}} the spatial {{complexity}} of instruction-level power models is presented in [25]. Therein, interinstruction effects have been measured by considering only the additional energy consumption observed when a generic instruction is executed after a <b>no-operation</b> (NOP) instruction.|$|E
30|$|The first dataset was {{anomalies}} in {{network connection}} records without any real operations. We selected 600 applications from the six malware families and installed them on three {{different versions of}} Android systems, respectively. Network traffic data were recorded from each device for 2  weeks and labeled as <b>no-operation.</b>|$|E
30|$|Furthermore, 8000 network {{connection}} records were randomly chosen and divided into eight testing subsets: test 1, test 2, test 3, test 4, test 5, test 6, test 7, and test 8. Each subset contained 1000 network traffic records, of which 90 % were normal behaviors and 10 % were anomaly behaviors. Datasets test 1 –test 4 labeled as <b>no-operation</b> contained {{four types of}} attacks and datasets test 5 –test 8 labeled as having-operation contained four types of attacks.|$|E
30|$|In the Clive’s Go compiler, {{both the}} sender and the {{receiver}} may close a channel, to stop I/O once the buffered messages (if any) have been processed. Also, an error indication {{may be given}} to close, unlike in standard Go. Such error can be retrieved by calling a new cerror primitive. Furthermore, the send operation has been modified to let the sender check whether the send could proceed or not (e.g., when the channel was closed). Unlike in standard Go, closing a closed channel is a <b>no-operation.</b>|$|E
40|$|The {{object of}} {{analysis}} of the proposed benchmark exercise is a system of ion propulsion for a science mission to the outer solar system. The propulsion system consists of a single propellant tank and 5 propulsion assemblies. The mission consists of 7 phases with different durations and requirements {{for the number of}} operational assemblies. The objective of the benchmark exercise is to determine the time dependent reliability of the propulsion system over the planned mission duration using the provided reliability data. Mission success implies success of all phases. The solution approach here undertaken uses fault-tree/event-trees (ET/FTs) for each functional mode (start up, shut down, operation and <b>no-operation)</b> to generate the transition probabilities of a discrete-time, inhomogeneous embedded Markov chain consisting of 11 states. Results of the study show that assembly failure during Start Up and the Shut Down functional modes of the propulsion system significantly contribute to mission failure. 2 Copyright © ### # by ASME ISYSTEM DESCRIPTION The system under consideration is an ion propulsion engine for science exploration in the outer solar system. It consists of a single propellant tank and 5 assemblies connected to the tank by a series of lines (dashed lines) a...|$|E
40|$|The {{problem of}} {{correctly}} recovering assembly instructions from a binary has received much attention and both malware and license validation code often relies on various anti-disassembly techniques {{in order to}} complicate analysis. One well-known anti-disassembly technique is to use overlapping code such that the disassembler starts decoding from an incorrect byte, but still recovers valid code. The actual code {{which is supposed to}} be executed is instead hidden inside a decoy instruction, and is overlapped with the disassembled code. We propose and investigate a new novel anti-disassembly method that allows for exceptional flexibility in the hidden instructions, {{while at the same time}} providing a disassembled main path that is executable. This allows the approach to be very efficient against static linear sweep disassembly, but also to be more difficult to detect using dynamic analysis methods. The idea is to utilize highly redundant instructions, e. g., multibyte <b>no-operation</b> instructions, and embed the hidden code in the configurable portions of those instructions. By carefully selecting wrapping instructions, providing overlaps, the hidden execution path can be crafted with great flexibility. We also provide a detection-algorithm, together with testing results, for testing software such that the hidden execution path can be identified...|$|E
40|$|Apart from {{applications}} in classical information-processing devices, the electrical control of atomic defects in solids {{at room temperature}} will have {{a tremendous impact on}} quantum devices that are based on such defects. In this study, we demonstrate the electrical manipulation of individual prominent representatives of such atomic solid-state defects, namely, the negative charge state of single nitrogen-vacancy defect centers (NV^{−}) in diamond. We experimentally demonstrate, deterministic, purely electrical charge-state initialization of individual NV centers. The NV centers are placed in the intrinsic region of a p-i-n diode structure that facilitates the delivery of charge carriers to the defect for charge-state switching. The charge-state dynamics of a single NV center were investigated by time-resolved measurements and a nondestructive single-shot readout of the charge state. Fast charge-state switching rates (from negative to neutrally charged defects), which are greater than 0. 72 [*]±[*] 0. 10 [*][*]μs^{− 1 }, were realized. Furthermore, in <b>no-operation</b> mode, the realized charge states were stable for presumably much more than 0. 45  s. We believe that the results obtained are useful not only for ultrafast electrical control of qubits, long T_{ 2 } quantum memory, and quantum sensors associated with single NV centers but also for classical memory devices based on single atomic storage bits working under ambient conditions...|$|E
40|$|Este trabalho propõe retraçar a história de um grupo que surgiu com o intuito de defender as religiões afro-brasileiras da intolerância religiosa sofrida por este segmento religioso no estado do Rio Grande do Sul: a Congregação em Defesa das Religiões Afro-Brasileiras (CEDRAB). Formada por sacerdotes das religiões afro-brasileiras, a CEDRAB surgiu em 2002, tendo como fundadora Mãe Norinha de Oxalá. Desde o seu surgimento tem lutado contra a intolerância religiosa sofrida pelas religiões afro-brasileiras, por parte da sociedade gaúcha em geral, mas sobretudo por parte das igrejas pentecostais, destacando-se dentre elas, a Igreja Universal do Reino de Deus, e apesar de ser uma das instituições mais recentes no quadro das religiões afro-gaúchas, tem sido a que obteve maior visibilidade nos últimos anos, {{inclusive}} por parte das autoridades políticas. A partir da análise da origem e significado da CEDRAB, procurarei ressaltar a atuação deste grupo na interface do religioso com o político, ou seja, as implicações políticas da sua prática para dentro do campo afro-religioso (e mesmo afro-político), devido a uma suposta inoperância dos órgãos e instituições já existentes, e, para fora do campo afro-religioso, para conquistar um melhor espaço de reconhecimento social e religioso, sobretudo devido à intolerância religiosa que lhe é movida pelas igrejas neopentecostais e pelas instâncias oficiais, parlamentares e jurídicas. This work {{proposes to}} redraw {{the history of}} a group that appeared with the intention of defending the Afro-Brazilian religions from the intolerance suffered by this religious segment in the state of Rio Grande do Sul: the Congregation in Defense of the Afro-Brazilian Religions (CEDRAB). Formed by priests of Afro- Brazilian religions, the CEDRAB appeared in 2002, having as founder Mãe Norinha of Oxalá. Since its emergence it has struggled against the religious intolerance that Afro-Brazilian religions suffer by part of Rio Grande do Sul society in general, but, above all, by Pentecostals churches, standing out among them, the Universal Church of the God's Kingdom (Igreja Universal do Reino de Deus), and in spite of being one of the most recent institutions in the scene of Afro-gaucho religions, it is the one that has obtained wider visibility in the last years, even close to the political authorities. From the analysis of the origin and practices of the CEDRAB, I will try to emphasize the acting of this group in the interface of the religious with the political, that is, the political implications of its practice towards inside of the Afroreligious field, due to a supposed <b>no-operation</b> of the organs and already existent institutions, and, toward outside of the Afro-religious field, seeking to acquire a better space of social and religious recognition, due to the religious intolerance, which is moved by neo-Pentecostals churches and by the official, parliamentary and legal instances...|$|E

