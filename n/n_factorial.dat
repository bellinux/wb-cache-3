30|106|Public
25|$|The {{symmetric}} group S'n on a finite set of n symbols {{is the group}} whose elements are all the permutations of the n symbols, and whose group operation is the composition of such permutations, which are treated as bijective functions from the set of symbols to itself. Since there are n! (<b>n</b> <b>factorial)</b> possible permutations {{of a set of}} n symbols, it follows that the order (the number of elements) of the {{symmetric group}} S'n is n!.|$|E
25|$|In {{abstract}} algebra, the {{symmetric group}} Sn on a finite set of n symbols {{is the group}} whose elements are all the permutation operations that can be performed on n distinct symbols, and whose group operation is the composition of such permutation operations, which are defined as bijective functions from the set of symbols to itself. Since there are n! (<b>n</b> <b>factorial)</b> possible permutation operations that can be performed on a tuple composed of n symbols, {{it follows that the}} order (the number of elements) of the symmetric group Sn is n!.|$|E
2500|$|This in fact {{comes from}} an {{asymptotic}} series for the logarithm, and <b>n</b> <b>factorial</b> lies between this and the next approximation: ...|$|E
50|$|In mathematics, an {{alternating}} factorial is {{the absolute}} value of the alternating sum of the first <b>n</b> <b>factorials</b> of positive integers.|$|R
5000|$|...; Hybrid style(procedure (<b>factorial</b> <b>n)</b> (if n <= 1 then 1 else <b>n</b> * (<b>factorial</b> n-1))) ...|$|R
5000|$|The <b>n</b> th <b>factorial</b> moment measure or <b>n</b> th order <b>factorial</b> moment {{measure is}} defined as: ...|$|R
2500|$|... where |B| is {{the area}} of B and n! denotes <b>n</b> <b>factorial.</b> The above {{equation}} quickly extends to the R3 case by replacing the area term with a volume term.|$|E
2500|$|Naive {{methods of}} {{implementing}} an algorithm {{to compute the}} determinant include using the Leibniz formula or Laplace's formula. Both these approaches are extremely inefficient for large matrices, though, since the number of required operations grows very quickly: it is of order n! (<b>n</b> <b>factorial)</b> for an [...] matrix M. For example, Leibniz's formula requires calculating n! products. Therefore, more involved techniques {{have been developed for}} calculating determinants.|$|E
5000|$|...; LISP style(procedure (factorial n) (if (leqp n 1) then 1 else (times <b>n</b> (<b>factorial</b> (difference n 1))))) ...|$|E
5000|$|Or in one line: <b>factorial</b> <b>n</b> = if n > 0 then <b>n</b> * <b>factorial</b> (n-1) else 1 ...|$|R
5000|$|... let { <b>{{factorial}}</b> <b>n</b> | n > 0 = <b>n</b> * <b>factorial</b> (n-1); factorial _ = 1 } in factorial 5 ...|$|R
5000|$|... val rec <b>factorial</b> = fn <b>n</b> => case n of 0 => 1 | n => <b>n</b> * <b>factorial</b> (<b>n</b> - 1) ...|$|R
5000|$|This in fact {{comes from}} an {{asymptotic}} series for the logarithm, and <b>n</b> <b>factorial</b> lies between this and the next approximation: ...|$|E
5000|$|The {{logarithm}} of <b>n</b> <b>factorial,</b> , {{is given}} byThis {{can be used}} to obtain Stirling's formula, an approximation of [...] for large n.|$|E
5000|$|... (sstatus optimizeTailCall t)(defun {{factorial}} (n) (flet ((repeat (<b>n</b> <b>factorial)</b> (if (plusp n) (repeat (sub1 n) [...] n * factorial)) factorial))) (repeat n 1))) ...|$|E
5000|$|For any integer <b>n,</b> the <b>factorial</b> <b>n!</b> is {{the product}} of all {{positive}} integers up to and including n. Then in the sequence ...|$|R
5000|$|... {{factorial}} :: Integer -> Integerfactorial n | n == 0 = 1 | n > 0 = <b>n</b> * <b>factorial</b> (<b>n</b> - 1) ...|$|R
5000|$|...- Using {{recursion}} (with pattern matching)factorial :: (Integral a) => a -> afactorial 0 = 1factorial n = <b>n</b> * <b>factorial</b> (<b>n</b> - 1) ...|$|R
5000|$|Extent - a touch {{where all}} {{possible}} changes are rung exactly once each; {{the number of}} such different rows is <b>N</b> <b>factorial,</b> where N is the number of bells.|$|E
5000|$|... where |B| is {{the area}} of B and n denotes <b>n</b> <b>factorial.</b> The above {{equation}} quickly extends to the R3 case by replacing the area term with a volume term.|$|E
5000|$|...; {{factorial}} : number -> number;; {{to calculate}} the product of all positive;; integers {{less than or equal}} to n.(define (factorial n) (if (= n 1) 1 (* <b>n</b> (<b>factorial</b> (- n 1))))) ...|$|E
5000|$|...- Using {{recursion}} (with guards)factorial :: (Integral a) => a -> afactorial n | n < 2 = 1 | otherwise = <b>n</b> * <b>factorial</b> (<b>n</b> - 1) ...|$|R
5000|$|A simple {{example that}} {{is often used to}} {{demonstrate}} the syntax of functional languages is the factorial function for non-negative 32-bit integers, here shown in F#:/// This is a documentation comment for a function.let rec <b>factorial</b> <b>n</b> = match n with | 0 -> 1 | _ -> <b>n</b> * <b>factorial</b> (<b>n</b> - 1) ...|$|R
25|$|As <b>n</b> grows, the <b>factorial</b> <b>n!</b> {{increases}} {{faster than}} all polynomials and exponential functions (but slower than double exponential functions) in n.|$|R
5000|$|... #Caption: Number of {{possible}} permutations and derangements of n elements. n! (<b>n</b> <b>factorial)</b> {{is the number}} of n-permutations; !n (n subfactorial) {{is the number of}} derangements [...] - [...] n-permutations where all of the n elements change their initial places.|$|E
50|$|Naive {{methods of}} {{implementing}} an algorithm {{to compute the}} determinant include using the Leibniz formula or Laplace's formula. Both these approaches are extremely inefficient for large matrices, though, since the number of required operations grows very quickly: it is of order n! (<b>n</b> <b>factorial)</b> for an n × n matrix M. For example, Leibniz's formula requires calculating n! products. Therefore, more involved techniques {{have been developed for}} calculating determinants.|$|E
5000|$|Szymanski's Mutual Exclusion Algorithm is {{a mutual}} {{exclusion}} algorithm devised by computer scientist Dr. Boleslaw Szymanski, which has many favorable properties including linear wait, and which extension [...] solved the open problem posted by Leslie Lamport {{whether there is}} an algorithm with a constant number of communication bits per process that satisfies every reasonable fairness and failure-tolerance requirement that Lamport conceived of (Lamport's solution used <b>n</b> <b>factorial</b> communication variables vs. Szymanski's 5).|$|E
5000|$|... {{factorial}} :: Integer -> Integerfactorial 0 = 1factorial n = <b>n</b> * <b>factorial</b> (n-1) ...|$|R
40|$|AbstractAn attempt {{has been}} made to {{construct}} partially balanced incomplete block designs of two and more associate classes by using designs for confounded 2 <b>n</b> <b>factorials.</b> Methods of construction have been presented with examples. Parameters of such designs along with association schemes have also been given. Several designs of two associate classes which seem to be unknown to date have been reported...|$|R
50|$|The above {{triangular}} array {{is called the}} Euler triangle or Euler's triangle, and it shares some common characteristics with Pascal's triangle. The sum of row <b>n</b> is the <b>factorial</b> <b>n.</b>|$|R
50|$|The {{symmetric}} group Sn on a finite set of n symbols {{is the group}} whose elements are all the permutations of the n symbols, and whose group operation is the composition of such permutations, which are treated as bijective functions from the set of symbols to itself. Since there are n! (<b>n</b> <b>factorial)</b> possible permutations {{of a set of}} n symbols, it follows that the order (the number of elements) of the {{symmetric group}} Sn is n!.|$|E
5000|$|Given {{a list of}} {{distinct}} numbers (we can assume this {{because this is a}} worst-case analysis), there are <b>n</b> <b>factorial</b> permutations exactly one of which is the list in sorted order. The sort algorithm must gain enough information from the comparisons to identify the correct permutation. If the algorithm always completes after at most f(n) steps, it cannot distinguish more than 2f(n) cases because the keys are distinct and each comparison has only two possible outcomes. Therefore, ...|$|E
50|$|Albert Eagle was an English {{mathematician}} {{who wrote}} several books (some of them privately published) giving his forcefully expressed and somewhat eccentric views {{on science and}} mathematics. He was an assistant to J. J. Thomson, and was later a lecturer at the Victoria University of Manchester. His best-known book is on elliptic functions, where he uses his idiosyncratic mathematical notation, such as τ instead of π/2, and !n for <b>n</b> <b>factorial.</b> In his other writings he dismissed special relativity, quantum mechanics, natural selection, and English spelling as absurdities.|$|E
5000|$|The <b>n</b> th <b>factorial</b> moment {{measure of}} a point process N is {{equivalently}} defined by: ...|$|R
5000|$|... % Accepts {{a number}} and calculates its {{factorial}} [...] function factorial (n: int) : real if n = 0 then result 1 else result <b>n</b> * <b>factorial</b> (<b>n</b> - 1) end if end factorial [...] var n: int loop put [...] "Please input an integer: [...] " [...]. get n exit when n >= 0 put [...] "Input {{must be a}} non-negative integer." [...] end loop [...] put [...] "The factorial of [...] ", n, [...] " [...] is [...] ", <b>factorial</b> (<b>n)</b> ...|$|R
5000|$|Here [...] {{denotes the}} {{arithmetic}} sequence 1, 2, …, n in list form. Using the Prelude function enumFromTo, the expression [...] {{can be written}} as enumFromTo 1 <b>n,</b> allowing the <b>factorial</b> function to be expressed as <b>factorial</b> <b>n</b> = product (enumFromTo 1 n) ...|$|R
