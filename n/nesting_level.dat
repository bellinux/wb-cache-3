33|450|Public
50|$|In general, {{there is}} no unique minimal power graph for a given graph.In this example (right) a graph of four nodes and five edges admits two minimal power graphs of two power edges each.The main {{difference}} between these two minimal power graphs is the higher <b>nesting</b> <b>level</b> of the second power graph as well as a loss of symmetry with respect to the underlying graph.Loss of symmetry is only a problem in small toy examples since complex networks rarely exhibit such symmetries in the first place.Additionally, one can minimize the <b>nesting</b> <b>level</b> but even then, there is in general not a unique minimal power graph of minimal <b>nesting</b> <b>level.</b>|$|E
50|$|Templates of {{templates}} (nested templates) are {{not supported}} by all compilers, or might have a limit on the <b>nesting</b> <b>level.</b>|$|E
5000|$|Some {{languages}} such as Pascal and Ada have {{no restrictions}} on declarations {{depending on the}} <b>nesting</b> <b>level,</b> allowing precisely nested subprograms or even nested packages (Ada). Here {{is an example of}} both (simplified from a real case): ...|$|E
5000|$|The {{standard}} specifies three <b>nested</b> <b>levels</b> of interchange (paraphrased from section 10): ...|$|R
50|$|Nested CES {{functions}} are {{commonly found in}} partial equilibrium and general equilibrium models. Different <b>nests</b> (<b>levels)</b> allow for {{the introduction of the}} appropriate elasticity of substitution.|$|R
3000|$|... are: “A type {{of linear}} {{regression}} models {{in which the}} observations fall into hierarchical or completely <b>nested</b> <b>levels.</b> Hierarchical Models are a type of Multilevel Models.” [...]...|$|R
5000|$|This design choice has {{a slight}} [...] "cost" [...] in that code [...] branch is, effectively, adding an extra <b>nesting</b> <b>level,</b> complicating {{the job for}} some compilers (or its {{implement}}ors), which has to analyse and implement arbitrarily long [...] chains recursively.|$|E
50|$|Indentation-based folding {{points are}} {{generally}} {{specified by the}} position and sequence of non-printing whitespace, such as tabs and spaces, within the text. This is most often used as a simple form of syntax-based folding, as indentation almost always reflects <b>nesting</b> <b>level</b> in indent styles for structured programming languages.|$|E
5000|$|Some {{programming}} languages (e.g., Pascal and Ada) support {{declaration of}} nested subroutines, which {{are allowed to}} access {{the context of their}} enclosing routines, i.e., the parameters and local variables within the scope of the outer routines. Such static nesting can repeat - a function declared within a function declared within a function... The implementation must provide a means by which a called function at any given static <b>nesting</b> <b>level</b> can reference the enclosing frame at each enclosing <b>nesting</b> <b>level.</b> Commonly this reference is implemented by a pointer to the frame of the most recently activated instance of the enclosing function, called a [...] "downstack link" [...] or [...] "static link", to distinguish it from the [...] "dynamic link" [...] that refers to the immediate caller (which need not be the static parent function).|$|E
50|$|McCabe, B., & Feiock, R. (2005). <b>Nested</b> <b>Levels</b> of Institutions: State Rules and City Property Taxes in the Shadow of the Law. Urban Affairs Review, 40(May), 634-654.|$|R
5000|$|Sometimes {{quotations}} are <b>nested</b> in more <b>levels</b> than {{inner and}} outer quotation. <b>Nesting</b> <b>levels</b> up to five {{can be found in}} the Christian Bible. In these cases, questions arise about the form (and names) of the quotation marks to be used. The most common way is to simply alternate between the two forms, thus: ...|$|R
50|$|Deacon defines three hierarchically <b>nested</b> <b>levels</b> of {{thermodynamic}} systems: Homeodynamic systems {{combine to}} produce morphodynamic systems which combine to produce teleodynamic systems. Teleodynamic {{systems can be}} further combined to produce higher orders of self organization.|$|R
50|$|Location Caches (LC) {{build on}} VTD records to provide {{efficient}} random access. Organized as tables, with one table per nesting depth level, LCs contain entries modeling an XML document's element hierarchy. An LC entry is a 64-bit integer encoding {{a pair of}} 32-bit values. The upper 32 bits identify the VTD record for the corresponding element. The lower 32 bits identify that element's first child in the LC at the next lower <b>nesting</b> <b>level.</b>|$|E
5000|$|Programming {{languages}} {{that support}} nested subroutines {{also have a}} field in the call frame that points to the stack frame of the latest activation of the procedure that most closely encapsulates the callee, i.e. the immediate scope of the callee. This is called an access link or static link (as it keeps track of static nesting during dynamic and recursive calls) and provides the routine (as well as any other routines it may invoke) access to the local data of its encapsulating routines at every <b>nesting</b> <b>level.</b> Some architectures, compilers, or optimization cases store one link for each enclosing level (not just the immediately enclosing), so that deeply nested routines that access shallow data {{do not have to}} traverse several links; this strategy is often called a [...] "display".|$|E
5000|$|On the downside, this {{approach}} means that procedures {{with large numbers}} of local variables are problematic, and ones with fewer lead to registers—an expensive resource—being wasted. There are a finite number of register windows in the design, e.g. eight, so procedures can only be nested that many levels deep before the register windowing mechanism reaches its limit; once the last window is reached, no new window can be set up for another nested call. And if procedures are only nested a few levels deep, registers in the windows above the deepest call <b>nesting</b> <b>level</b> can never be accessed at all, so these are completely wasted.It was Stanford's work on compilers that led them to ignore the register window concept, believing that an efficient compiler could make better use of the registers than a fixed system in hardware. (The same reasoning would apply for a smart assembly-language programmer.) ...|$|E
50|$|The ICS uses an {{hierarchical}} classification, {{which consists}} of three <b>nested</b> <b>levels</b> called fields (Level 1), groups (Level 2) and sub-groups (Level 3). Each field is subdivided into groups, which are further divided into sub-groups.|$|R
30|$|According to SANDRE, {{there are}} four <b>nested</b> <b>levels</b> of hydrographic basins: the 1 st order {{considers}} 24 hydrographic regions and the 4 th order considers 6188 hydrographic areas. Each {{of them can be}} considered a flood risk basin.|$|R
50|$|Even though Photios {{praises the}} work in high tones, both for its style clarity and its plot credibility, the summary of the content that he {{presents}} creates a confusing impression, {{mainly because of the}} multiple <b>nested</b> <b>levels</b> of narration.|$|R
40|$|This article {{discusses}} the basic mechanisms {{of the test}} generator for differential equations, developed by the authors. The generator is designed to generate {{a large number of}} test questions in accordance with user-defined rules, which include: the number of tasks required for each type of differential equation, and the tasks difficulty, controlled by the <b>nesting</b> <b>level</b> of recursive functions. The generator produces a test file format GIFT, which is a plain text file...|$|E
3000|$|Calculating 19 {{software}} metrics: AMW (Average Method Weight), ATFD (Access To Foreign Data), CYCLO (McCabe’s Cyclomatic Number), FDP (Foreign Data Provider), LAA (Locality Attribute Accesses), LOC (Lines of Code), LVAR (Number of Local Variables), MAXNESTING (Maximum <b>Nesting</b> <b>Level),</b> MLOC (Method Lines of Code), NOA (Number of Attributes), NOAM (Number of Accessor Methods), NOAV (Number of Accessed Variables), NOM (Number of Methods), NOPA (Number Of Public Attributes), NProtM (Number of Protected Members), PAR (Number of Parameters), TCC (Tight Class Cohesion), WMC (Weighted Method Count), and WOC (Weight Of a Class) [...]...|$|E
40|$|Abstract. This paper {{presents}} an approach for extending the vector space model (VSM) to perform XML retrieval. The model is extended to support {{important aspects of}} XML structural and semantic information such as element <b>nesting</b> <b>level,</b> matching tag names in the query and the collection and the relation between tag names and content of an element. Potential use of the model for heterogeneous {{as well as for}} the unstructured collection is also shown. We compared our model with the standard vector space model and obtained a gain for unstructured and structured queries. For unstructured collections the vector space model effectiveness is preserved. ...|$|E
5000|$|PicaJet is {{a digital}} photo {{organizer}} software.Photos, located in various places on hard drives, can be located by date, category (which can be defined), rating or other user-defined custom criterion. PicaJet can assign images to categories without limitations to category <b>nesting</b> <b>levels.</b>|$|R
50|$|The {{theory of}} time as {{conflict}} - nested hierarchy of unresolvable conflicts.These <b>nested</b> <b>levels</b> represent qualitatively different temporalities, for both time {{and the perception of}} time have evolved. In one sense, time is physically different from what it was when the universe first came into being.|$|R
5000|$|... where [...] {{specifies}} {{the difference}} in <b>nesting</b> <b>levels</b> (remember that Pascal supports nested procedures). This instruction will mark the stack, i.e. reserve the first five cells of the above stack frame, and initialise previous EP, dynamic, and static link. The caller then computes and pushes any parameters for the procedure, and then issues ...|$|R
40|$|This paper {{develops}} a general framework for fusing any two loops. We find the existing {{test for the}} legality of loop fusion to be unduly restrictive. Here, we show how to fuse loops which do not satisfy the condition in the data dependence test. Then, we extend the scope of performing loop fusion to adjacent loops with any inter loop dependence and also any <b>nesting</b> <b>level.</b> The tradeoff between the advantages of loop fusion and the disadvantages of loop unrolling would dictate whether to perform loop fusion on adjacent loops or not. 2 The Tests For Loop Fusio...|$|E
40|$|Algebraically {{dependent}} expressions {{arise in}} a large variety of symbolic computations. People {{seem to have the}} best intuition about expressions involving radicals. Symbolic computations with simple, non-nested, radicals is relatively straightforward; however, when the radicals are nested the problem becomes more difficult, This paper presents an algorithm for determining a linearly independent basis for a set of radicals (nested or not). This allows elementary techniques to be used for arithmetic operations on expressions involving elements of this set. In addition we provide a structure theorem that provides a sufficient condition for a nested radical to be expressed in terms of radicals of lower <b>nesting</b> <b>level.</b> These two techniques are powerful tools for computations involving radicals...|$|E
40|$|In this work, {{we present}} a {{theoretical}} and practical approach for dealing with a complier related problem. Although, most of modern programming languages use explicit grouping of nested statements by means of special begin and end tokens, there are programming languages that use indentation for this purpose. The most famous example for such a language is Python. We show that languages, using this kind of syntax, cannot be generated by a context free grammar and present an extension to context free grammars that is suitable to handle the problem of determining the <b>nesting</b> <b>level.</b> Furthermore, {{we present a}} set of techniques that {{make it possible to}} construct an efficient parser out of it. ...|$|E
40|$|Most {{traditional}} {{statistical methods}} assume {{the independence of}} observations. However, in practical data observations often come in clusters on one or more <b>nested</b> <b>levels.</b> Observations may be correlated within clusters. Disregarding {{the structure of the}} data may lead to erroneous inference. A general family of weighted one-sample location test statistics for hierarchical data was introduce...|$|R
40|$|This paper proposes {{using the}} notion of chunks for {{controlling}} standard bottom-up parsers as well. As is well known, bottom-up parsers produce many constituents not contributing to the correct final analysis, {{because they do not}} consider properly the text surrounding the portion under analysis in a given moment. This paper defines the following <b>nested</b> <b>levels</b> of chunks...|$|R
40|$|This {{commentary}} raises two issues: (1) Language processing is hastened {{not only}} by internal pressures but also externally by turntaking in language use; (2) the theory requires <b>nested</b> <b>levels</b> of processing, but linguistic levels do not fully nest; further, {{it would seem to}} require multiple memory buffers, otherwise there’s no obvious treatment for discontinuous structures, or for verbatim recall...|$|R
40|$|A {{software}} system is an aggregate of communicating modules. The interfaces supporting module (procedure, etc.) communication characterize the system. Therefore, understanding these interfaces (areas of communication) gives a better {{description of system}} complexity. Understanding in an empirical sense implies measuring, and measuring interfaces involves examining both the communicational environment and the exchanged data. There are several different measures associated with the communication environment. Obviously, the structure or <b>nesting</b> <b>level</b> at the communication ping is very interesting. The need to measure the data communicated also raises some very interesting questions concerned with data type and expressional form. This paper reports on the efforts at Virginia Tech to measure, and thus capture, the complexities of software interfaces. Analyzing an Ada system of 85, 000 lines of code validated the measures proposed here. The results of this research are very encouraging...|$|E
40|$|Controlling and {{minimizing}} software complexity is {{the most}} important objective of each software development paradigm because it affects all other software quality attributes like reusability, reliability, testability, maintainability etc. For this purpose, a number of software complexity measures have been reported to quantify different aspects of complexity. As the development of object-oriented software is rising, more and more complexity metrics are being developed for the same. In this paper, we have attempted to design a weighted composite complexity measure by employing the concept of weights to quantify various aspects of complexity which may arise due to inheritance level, type and <b>nesting</b> <b>level</b> of control structures, and size of the class/program. The proposed weighted measure yields quiet interesting results and insight into various complexity aspects of software. Estimation of the new measure is also compared with four Chidamber an...|$|E
40|$|Estimating the {{execution}} time of nested loops or {{the volume of}} data transferred between processors is necessary to make appropriate processor or data allocation. To achieve this goal one need to estimate {{the execution}} time {{of the body and}} thus the number of nested loop iterations. This work could be a preprocessing step in an automatic porallelizing compilers to enhance the performance of the resulting parallel program. A bounded convex polyhedron can be associated with each loop nest. The number of its integer points corresponds to the iteration space size. In this paper, we present an algorithm that approximates this number. The algorithm is not restricted to a fixed dimension. The worst case complexity of the algorithm is infrequently reached in our context where the <b>nesting</b> <b>level</b> is rather small and the loop bound expressions are not very complex. ...|$|E
5000|$|A {{number of}} {{standard}} schemes have evolved. These are called levels. Originally, {{there were five}} RAID levels, but many variations have evolved, notably several <b>nested</b> <b>levels</b> and many non-standard levels (mostly proprietary). RAID levels and their associated data formats are standardized by the Storage Networking Industry Association (SNIA) in the Common RAID Disk Drive Format (DDF) standard: ...|$|R
5000|$|<b>Nested</b> RAID <b>levels</b> {{are usually}} {{numbered}} using {{a series of}} numbers, where {{the most commonly used}} levels use two numbers. The first number in the numeric designation denotes the lowest RAID level in the [...] "stack", while the rightmost one denotes the highest layered RAID level; for example, RAID 50 layers the data striping of RAID 0 on top of the distributed parity of RAID 5. <b>Nested</b> RAID <b>levels</b> include RAID 01, RAID 10, RAID 100, RAID 50 and RAID 60, which all combine data striping with other RAID techniques; {{as a result of the}} layering scheme, RAID 01 and RAID 10 represent significantly different <b>nested</b> RAID <b>levels.</b>|$|R
40|$|In {{an earlier}} paper we {{provided}} easily-calculated expressions for the gradient of the profiled log-likelihood and log-restricted-likelihood for single-level mixed-effects models. We also showed how this gradient {{is related to}} the update of an ECME (expectation conditional maximization either) algorithm for such single level models. In this paper we extend those results to mixed-effects models with multiple <b>nested</b> <b>levels</b> of random effects. ...|$|R
