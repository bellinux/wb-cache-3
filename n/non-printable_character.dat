0|10|Public
5000|$|... {{contains}} the [...] function. This function {{is used to}} display <b>non-printable</b> <b>characters</b> in a visual format.|$|R
5000|$|End-of-cell and end-of row markers (...) appear {{automatically}} in each box when {{display of}} <b>non-printable</b> <b>characters</b> turned on.|$|R
5000|$|Some FourCCs however, do contain <b>non-printable</b> <b>characters,</b> {{and are not}} human-readable without special {{formatting}} for display; for example, 10bit Y'CbCr 4:2:2 video {{can have}} a FourCC of ('Y', '3', 10, 10) which ffmpeg displays as [...]|$|R
50|$|Non-printing {{character}} or Formatting marks are characters for content designing in word processors, which aren't displayed at printing. It {{is also possible}} to customize their display on the monitor. The most common <b>non-printable</b> <b>characters</b> in word processors are pilcrow, space, non-breaking space, Tab character etc.|$|R
5000|$|Surrounded by {{quotation}} marks (ASCII 0x22 double quote or ASCII 0x27 single quote), used by most programming languages. To {{be able to}} include special characters such as the quotation mark itself, newline <b>characters,</b> or <b>non-printable</b> <b>characters,</b> escape sequences are often available, usually prefixed with the backslash character (ASCII 0x5C).|$|R
50|$|The etags files {{consists}} of multiple sections - one section per input source file. Sections are plain-text with several <b>non-printable</b> ascii <b>characters</b> used for special purposes. These characters are represented as bracketed hexadecimal codes below.|$|R
5000|$|Flags: [...] /B Matches pattern {{if at the}} {{beginning}} of a line. /E Matches pattern if at the end of a line. /L Uses search strings literally. /R Uses search strings as regular expressions. /S Searches for matching files in the current directory and all subdirectories. /I Specifies that the search is not to be case-sensitive. /X Prints lines that match exactly. /V Prints only lines that do not contain a match. /N Prints the line number before each line that matches. /M Prints only the filename if a file contains a match. /O Prints character offset before each matching line. /P Skip files with <b>non-printable</b> <b>characters.</b> /OFFLINE Do not skip files with offline attribute set. /A:attr Specifies color attribute with two hex digits. See [...] "color /?" [...] /F:file Reads file list from the specified file(/ stands for console). /C:string Uses specified string as a literal search string. /G:file Gets search strings from the specified file(/ stands for console). /D:dir Search a semicolon delimited list of directories ...|$|R
50|$|In most hex editor applications, {{the data}} of the {{computer}} file is represented as hexadecimal values grouped in 4 groups of 4 bytes (or two groups of 8 bytes), followed by one group of 16 printable ASCII characters which correspond to each pair of hex values (each byte). <b>Non-printable</b> ASCII <b>characters</b> (e.g., Bell) and characters that {{would take more than}} one character space (e.g., tab) are typically represented by a dot (".") in the following ASCII field.|$|R
30|$|Once {{the texts}} {{described}} above were collected, both the comments and the summaries, {{a sequence of}} operations was performed on {{them in order to}} transform the original texts into workable data. First, quotes from other comments present in the texts were removed. Keeping the quoted comments as repeated text could lead to interesting results, as that piece of text would be considered more “relevant” by some algorithms, but a new study would be needed to verify that. Then, the HTML formatting of the texts was removed, leaving only the unformatted comment texts. Doing this discards useful information in the form of text formatting, such as boldfaced words, but the methods used in this article do not take those into consideration, making them a pointless complication. Also, <b>non-printable</b> <b>characters</b> were excluded. Finally, the stop words in the texts were removed, and all letters were converted to their lower case forms. For this last step, we kept a different version of the texts with and without applying the stop word filter and lower case transformation. This was done because some of the methods used in this article require actual natural language sentences, while others work best with only a list of informative words. Unless otherwise specified, all text used as data in this article has stop words filtered out and has been completely converted to lower case.|$|R
5000|$|Followed by a slash ("/"), and in {{the case}} of the Univac VDT, the prompt character, which looked like an inverse color greater than sign (">"). The user would logon by typing the word logon {{followed}} by their identifier, e.g. their account name, a comma, and their user name. If they had a password on their account, they would type a comma followed by their password, which could be from 1 to 4 characters. If it contained one or more spaces (other than trailing spaces, which could be omitted), it had to be typed in single quotes. If it contained <b>non-printable</b> or binary <b>characters,</b> it had to by typed in by using the letter X followed by a quote and the 8-character hexadecimal value of their password. So if the account S0103 had the password (in hexadecimal) A0B0C0 and a space, then user LESLIE would logon to the system by typing ...|$|R

