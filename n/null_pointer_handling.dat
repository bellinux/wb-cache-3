0|289|Public
50|$|In {{computer}} programming, {{the pyramid}} of doom {{is a common}} problem that arises when a program uses many levels of nested indentation to control access to a function. It is commonly seen when checking for <b>null</b> <b>pointers</b> or <b>handling</b> callbacks. Two examples of the term are related to a particular programming style in JavaScript, and the nesting of if statements that occurs in object-oriented programming languages {{when one of the}} objects may be a <b>null</b> <b>pointer.</b>|$|R
40|$|We {{envision}} {{a world where}} no exceptions are raised; instead, language semantics are changed so that operations are total functions. Either an operation executes normally or tailored recovery code is applied where exceptions would have been raised. As an initial step and evaluation of this idea, we propose to transform programs so that <b>null</b> <b>pointer</b> dereferences are <b>handled</b> automatically without a large runtime overhead. We increase robustness by replacing code that raises <b>null</b> <b>pointer</b> exceptions with error-handling code, allowing the program to continue execution. Our technique first finds potential <b>null</b> <b>pointer</b> dereferences and then automatically transforms programs to insert null checks and error-handling code. These transformations are guided by composable, context-sensitive recovery policies. Errorhandling code may, for example, create default objects of the appropriate types, or restore data structure invariants. If no <b>null</b> <b>pointers</b> would be dereferenced, the transformed program behaves just as the original. We applied our transformation in experiments involving multiple benchmarks, the Java Standard Library, and externally reported <b>null</b> <b>pointer</b> exceptions. Our technique was {{able to handle the}} reported exceptions and allow the programs to continue to do useful work, with an average execution time overhead of less than 1 % and an average bytecode space overhead of 22 %. 1...|$|R
40|$|The current C++ {{standard}} {{provides the}} special rule that 0 {{is both an}} integer constant and a <b>null</b> <b>pointer</b> constant. From [C++ 03] clause 4. 10 : A <b>null</b> <b>pointer</b> constant is an integral constant expression (expr. const) rvalue of integer type that evaluates to zero. A <b>null</b> <b>pointer</b> constant {{can be converted to}} a pointer type; the result is the <b>null</b> <b>pointer</b> value of that type and is distinguishable from every other value of pointer to object or pointer to function type. Two <b>null</b> <b>pointer</b> values of the same type shall compare equal. The conversion of a <b>null</b> <b>pointer</b> constant to a pointer to cv-qualified type is a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion (conv. qual). This formulation is based on the original K&R C definition and differs from the definition in C 89 and C 99. The C standard [C 99] says (clause 6. 3. 2. 3) : An integer constant expression with the value 0, or such an expression cast to type void *, is called a <b>null</b> <b>pointer</b> constant. [55] If a <b>null</b> <b>pointer</b> constant is converted to a pointer type, the resulting <b>pointer,</b> called a <b>null</b> <b>pointer,</b> is guaranteed to compare unequal to a pointer to any object or function...|$|R
25|$|A <b>null</b> <b>pointer</b> is a pointer in a {{computer}} program that does not point to any object or function. In C, the integer constant 0 is converted into the <b>null</b> <b>pointer</b> at compile time when it appears in a pointer context, and so 0 is a standard way {{to refer to the}} <b>null</b> <b>pointer</b> in code. However, the internal representation of the <b>null</b> <b>pointer</b> may be any bit pattern (possibly different values for different data types).|$|R
5000|$|Because a {{very common}} program error is a <b>null</b> <b>pointer</b> dereference (a read or write through a <b>null</b> <b>pointer,</b> used in C to mean [...] "pointer to no object" [...] and as an error indicator), most {{operating}} systems map the <b>null</b> <b>pointer's</b> address such that accessing it causes a segmentation fault.|$|R
5000|$|A <b>null</b> <b>pointer</b> value {{explicitly}} {{points to}} no valid location. Dereferencing a <b>null</b> <b>pointer</b> value is undefined, often {{resulting in a}} segmentation fault. <b>Null</b> <b>pointer</b> values are useful for indicating special cases such as no [...] "next" [...] pointer in the final node of a linked list, or as an error indication from functions returning pointers. In appropriate contexts in source code, such as for assigning to a <b>pointer</b> variable, a <b>null</b> <b>pointer</b> constant can be written as , with or without explicit casting to a pointer type, or as the [...] macro defined by several standard headers. In conditional contexts, <b>null</b> <b>pointer</b> values evaluate to false, while all other pointer values evaluate to true.|$|R
40|$|International audienceNull pointer {{exceptions}} (NPE) are {{the number}} one cause of uncaught crashing exceptions in production. In this paper, we aim at exploring the search space of possible patches for <b>null</b> <b>pointer</b> exceptions with metaprogramming. Our idea is to transform the program under repair with automated code transformation, so as to obtain a metaprogram. This metaprogram contains automatically injected hooks, that can be activated to emulate a <b>null</b> <b>pointer</b> exception patch. This enables us to perform a fine-grain analysis of the runtime context of <b>null</b> <b>pointer</b> exceptions. We set up an experiment with 16 real <b>null</b> <b>pointer</b> exceptions that {{have happened in the}} field. We compare the effectiveness of our metaprogramming approach against simple templates for repairing <b>null</b> <b>pointer</b> exceptions...|$|R
50|$|A <b>null</b> <b>pointer</b> has a value {{reserved}} for {{indicating that the}} pointer does not refer to a valid object. <b>Null</b> <b>pointers</b> are routinely used to represent conditions such {{as the end of}} a list of unknown length or the failure to perform some action; this use of <b>null</b> <b>pointers</b> can be compared to nullable types and to the Nothing value in an option type.|$|R
50|$|A <b>null</b> <b>pointer</b> {{should not}} be {{confused}} with an uninitialized pointer: A <b>null</b> <b>pointer</b> is guaranteed to compare unequal to any pointer that points to a valid object. However, depending on the language and implementation, an uninitialized pointer may not have any such guarantee. It might compare equal to other, valid pointers; or it might compare equal to <b>null</b> <b>pointers.</b> It might do both at different times.|$|R
50|$|In computing, a <b>null</b> <b>pointer</b> has a value {{reserved}} for {{indicating that the}} pointer does not refer to a valid object. Programs routinely use <b>null</b> <b>pointers</b> to represent conditions such {{as the end of}} a list of unknown length or the failure to perform some action; this use of <b>null</b> <b>pointers</b> can be compared to nullable types and to the Nothing value in an option type.|$|R
25|$|<b>Null</b> <b>pointer</b> dereference.|$|R
50|$|Because a <b>null</b> <b>pointer</b> {{does not}} {{point to a}} {{meaningful}} object, an attempt to dereference (ie. access the data stored at that memory location) a <b>null</b> <b>pointer</b> usually (but not always) causes a run-time error or immediate program crash.|$|R
40|$|Pointers {{are one of}} {{the most}} {{powerful}} and flexible features in C/C++, but they are also one of the most dangerous ones to use. Safe proramming practice requires a pointer to be initialized to NULL once declared. However a <b>NULL</b> <b>pointer</b> does not solve the problem completely. Accessing a <b>NULL</b> <b>pointer</b> may crash the application without offering any useful clues to the real problem. In Object-Oriented design, we can view a <b>NULL</b> <b>pointer</b> as a special kind of object with special behaviors and implement a null object to replace the <b>NULL</b> <b>pointer.</b> Accessing a <b>null</b> object will not crash the application, instead it can perform meaningful operations or display more helpful error messages. In this project, we implement a binary search tree, an AVL tree, a singly linked list using both the traditional <b>NULL</b> <b>pointer</b> method and the Object-Oriented null object method. We then compared the two methods in terms of safety, coding complexity, and time/space efficiency. The implementation language is C+...|$|R
50|$|In {{languages}} with a tagged architecture, a possibly <b>null</b> <b>pointer</b> can {{be replaced}} with a tagged union which enforces explicit handling of the exceptional case; in fact, a possibly <b>null</b> <b>pointer</b> {{can be seen as}} a tagged pointer with a computed tag.|$|R
5000|$|Infer {{performs}} {{checks for}} <b>null</b> <b>pointer</b> exceptions, resource leaks, annotation reachability, missing lock guards, and concurrency race conditions in Android and Java code. It checks for <b>null</b> <b>pointer</b> problems, memory leaks, coding conventions and unavailable API’s in C, C++ and Objective C.|$|R
5000|$|In C, two <b>null</b> <b>pointers</b> of {{any type}} are {{guaranteed}} to compare equal. The macro [...] is defined as an implementation-defined <b>null</b> <b>pointer</b> constant, which in C99 can be portably expressed as the integer value [...] converted implicitly or explicitly to the type [...]|$|R
40|$|A {{name for}} the null pointer: nullptr We propose a new {{constant}} called nullptr of the distinct type decltype(nullptr). nullptr can be assigned to any pointer type (incl. pointer to member and function pointer types) but not to integral types. We further propose that the standard library macro NULL be defined to be nullptr. The result will be more readable code, better error detection, and better overload resolution. 1. The Problem, and Current Workarounds The current C++ standard provides the special rule that 0 is both an integer constant and a <b>null</b> <b>pointer</b> constant. From [C++ 03] clause 4. 10 : A <b>null</b> <b>pointer</b> constant is an integral constant expression (expr. const) rvalue of integer type that evaluates to zero. A <b>null</b> <b>pointer</b> constant {{can be converted to}} a pointer type; the result is the <b>null</b> <b>pointer</b> value of that type and is distinguishable from every other value of pointer to object or pointer to function type. Two <b>null</b> <b>pointer</b> values of the same type shall compare equal. The conversion of a <b>null</b> <b>pointer</b> constant to a pointer to cv-qualified type is a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion (conv. qual) ...|$|R
25|$|First - Is the <b>null</b> <b>pointer</b> (empty list).|$|R
50|$|It only finds basic bugs (f.ex. <b>null</b> <b>pointer</b> dereferencing).|$|R
5000|$|Invalid {{page fault}} - {{accessing}} a pointer outside the virtual memory space. A <b>null</b> <b>pointer</b> dereference will often cause an exception or program termination in most environments, but can cause corruption in operating system kernels or systems without memory protection, or when {{use of the}} <b>null</b> <b>pointer</b> involves a large or negative offset.|$|R
40|$|Adt is {{a simple}} tool {{in the spirit of}} Lex and Yacc that makes {{monomorphic}} algebraic data types, polymorphic built-in types like the list and an efficient form of pattern matching available in C programs. C programs built with ADTs typically use <b>NULL</b> <b>pointers</b> only to indicate don’t care values, and not as sentinels. This reduces the scope for errors involving <b>NULL</b> <b>pointers.</b> The Adt tool gener-ates runtime checks, which catch many of the remaining <b>NULL</b> <b>pointer</b> dereferences. The runtime checks may con-sume a significant amount of CPU time; hence they can be switched off once the program is suitably debugged. ...|$|R
5000|$|Dereferencing <b>null</b> <b>pointers</b> - this is special-cased by memory {{management}} hardware ...|$|R
5000|$|For {{backwards}} compatibility reasons, [...] remains a valid <b>null</b> <b>pointer</b> constant.|$|R
5000|$|Kernel mode <b>null</b> <b>pointer</b> dereference exploit {{affecting}} FreeBSD 7.0 to 7.2.|$|R
5000|$|In C, the {{behavior}} of dereferencing a <b>null</b> <b>pointer</b> is undefined. Many implementations cause such code to result in the program being halted with a segmentation fault, because the <b>null</b> <b>pointer</b> representation is chosen to be an address that is never allocated by the system for storing objects. However, this behavior is not universal.|$|R
5000|$|<b>Null</b> <b>pointer</b> for {{indicating}} {{the end of}} a linked list or a tree.|$|R
2500|$|Avoid {{software}} {{patterns that}} will lead to unexpected behavior (Uninitialized variable, <b>null</b> <b>pointers,</b> etc.) ...|$|R
50|$|Dereferences of <b>null</b> <b>pointers</b> lead to {{undefined}} {{values and}} usually raise an exception immediately.|$|R
5000|$|... (The <b>NULL</b> <b>pointer</b> {{shown here}} is 0x00000000.)By {{assigning}} {{the address of}} [...] to : ...|$|R
5000|$|Avoid {{software}} {{patterns that}} will lead to unexpected behavior (Uninitialized variable, <b>null</b> <b>pointers,</b> etc.) ...|$|R
5000|$|Objects {{of class}} [...] are thrown when the {{expression}} for [...] {{is the result}} of applying the unary * operator on a <b>null</b> <b>pointer.</b> Whether an exception is thrown for other null reference arguments is implementation-dependent. In other words, for the exception to be guaranteed, the expression must take the form [...] where [...] is any expression resulting in a <b>null</b> <b>pointer.</b>|$|R
5000|$|Targeted {{automatic}} bug-fixing techniques generate repairs {{for specific}} classesof errors such as <b>null</b> <b>pointer</b> exception ...|$|R
5000|$|In C++11, {{there is}} a type called [...] (<b>null</b> <b>pointer</b> type) that can only store the value [...]|$|R
5000|$|<b>Null</b> <b>pointer</b> dereference - {{dereferencing}} {{an invalid}} pointer or a pointer to memory {{that has not}} been allocated ...|$|R
50|$|Not {{checking}} for allocation failures: Memory allocation is not guaranteed to succeed, and may instead return a <b>null</b> <b>pointer.</b> Using the returned value, without checking if the allocation is successful, invokes undefined behavior. This usually leads to crash (due to the resulting segmentation fault on the <b>null</b> <b>pointer</b> dereference), {{but there is}} no guarantee that a crash will happen so relying on that can also lead to problems.|$|R
5000|$|No {{unnecessary}} checks: Trusting {{that other}} software components behave as specified, so to not paper over any unknown problem, {{is the basic}} principle. In particular, some errors may already be guaranteed to crash the program (depending on programming language or running environment), for example dereferencing a <b>null</b> <b>pointer.</b> As such, <b>null</b> <b>pointer</b> checks are unnecessary {{for the purpose of}} stopping the program (but can be used to print error messages).|$|R
