19|63|Public
2500|$|Traditionally, the Start menu {{provided}} a customizable <b>nested</b> <b>list</b> {{of programs for}} the user to launch, {{as well as a}} list of most recently opened documents, a way to find files and get help, and access to the system settings. Later enhancements via Windows Desktop Update included access to special folders like [...] "My Documents" [...] and [...] "Favorites" [...] (browser bookmarks). Windows XP's Start menu was expanded to encompass various My Documents folders (including My Music and My Pictures), and transplanted other items like My Computer and My Network Places from the Windows desktop. Until Windows Vista, the Start menu was constantly expanded across the screen as the user navigated through its cascading sub-menus.|$|E
50|$|PySynth is a {{lightweight}} {{open source software}} synthesizer written in Python. It accepts a song as a <b>nested</b> <b>list</b> and outputs a WAV file with the synthesized audio.|$|E
5000|$|In computing, Roman numerals {{may be used}} in {{identifiers}} {{which are}} limited to alphabetic characters by syntactic constraints of the programming language. In LaTeX, for instance, [...] refers to the label of an item in the third level [...] of a <b>nested</b> <b>list</b> environment.|$|E
5000|$|... adds in {{the lists}} buttons for {{inserting}} simple <b>lists</b> or <b>nested</b> <b>lists.</b>|$|R
5000|$|... == Algorithm == The program {{implements}} {{a variation}} of the genetic tree matching algorithm with respect to <b>nested</b> <b>lists.</b> That is, inside a given website, the program recursively traverses the branches of its DOM tree, aiming to detect <b>nested</b> <b>lists</b> of data items matching the format of the specified content. This approach is known to have several advantages over a simple string-matching algorithm.|$|R
50|$|Supported datatypes {{included}} <b>nested</b> <b>lists,</b> 16-bit signed integers and strings up to 127 {{characters in}} length. LOOP, WHILE and UNTIL keywords {{were available for}} program control.|$|R
5000|$|In computing, s-expressions, sexprs or sexps (for [...] "symbolic expression") are a {{notation}} for <b>nested</b> <b>list</b> (tree-structured) data, invented for and {{popularized by}} the programming language Lisp, which uses them for source code {{as well as}} data. In the usual parenthesized syntax of Lisp, an s-expression is classically defined as ...|$|E
5000|$|Traditionally, the Start menu {{provided}} a customizable <b>nested</b> <b>list</b> {{of programs for}} the user to launch, {{as well as a}} list of most recently opened documents, a way to find files and get help, and access to the system settings. Later enhancements via Windows Desktop Update included access to special folders like [...] "My Documents" [...] and [...] "Favorites" [...] (browser bookmarks). Windows XP's Start menu was expanded to encompass various My Documents folders (including My Music and My Pictures), and transplanted other items like My Computer and My Network Places from the Windows desktop. Until Windows Vista, the Start menu was constantly expanded across the screen as the user navigated through its cascading sub-menus.|$|E
50|$|A key {{challenge}} for selection-based search {{is that a}} long or <b>nested</b> <b>list</b> of categories quickly becomes unwieldy for the user. Therefore, {{it is incumbent upon}} the selection-based search system to both categorize the user-selected text and to identify those online services which most naturally apply to the selected text. For example, when the user selects an address, the system needs to identify the address as most suitable for an online mapping service such as Google Maps. When the user selects a movie title, the system needs to identify the selection as suitable for a movie database such as Internet Movie Database. When the user selects the name of a company, the system needs to identify the concordant stock symbol and an appropriate financial database such as Yahoo! Finance.|$|E
5000|$|<b>Nested</b> <b>lists</b> can {{be written}} as S-expressions: [...] is a two-element S-expression whose {{elements}} are also two-element S-expressions. The whitespace-separated notation used in Lisp (and this article) is typical. Line breaks (newline characters) usually qualify as separators.|$|R
50|$|Texy! format {{includes}} tags {{for turning}} off the formatter {{as well as for}} direct CSS styling, thus it can be said it fully supports HTML and CSS. The format itself supports images, links (anchors), <b>nested</b> <b>lists,</b> and tables, among other things.|$|R
25|$|Scheme is {{primarily}} a functional programming language. It shares many characteristics {{with other members of}} the Lisp programming language family. Scheme's very simple syntax is based on s-expressions, parenthesized lists in which a prefix operator is followed by its arguments. Scheme programs thus consist of sequences of <b>nested</b> <b>lists.</b> Lists are also the main data structure in Scheme, leading to a close equivalence between source code and data formats (homoiconicity). Scheme programs can easily create and evaluate pieces of Scheme code dynamically.|$|R
40|$|Abstract. The <b>Nested</b> <b>List</b> Normal Form is {{proposed}} as a syntactic normal form for semantically well-designed database schemata obtained from any arbitrary finite nesting of records and lists. The <b>Nested</b> <b>List</b> Normal Form {{is defined in}} terms of functional and multivalued depen-dencies, independent from any specific data model, and generalises the well-known Fourth Normal Form from relational databases in order to capture more application domains. ...|$|E
40|$|This paper {{introduces}} a scheme which implements the programmable logic controllers’ (PLCs) function based on FPGA. This scheme follows the IEC 61131 - 3 standard, selects Ladder Diagram (LD) {{to write the}} PLC programs and selects VHDL as target language. Based on VS 2005 platform, this scheme implements the construction of Ladder Diagram, compilation, simulation and other functions. This paper focuses on researching the construction method of Ladder Diagram, converting Ladder Diagram into Boolean equation and generating VHDL program by Boolean equivalence. The construction method of Ladder Diagram based on parallel-series hierarchical <b>nested</b> <b>list</b> and the implementing method of Boolean equivalence based on double-layer lists are proposed. Finally the correctness of the scheme is verified through an example.    </p...|$|E
40|$|With {{the advent}} of XML and its use as a {{database}} language, dependency and normal form theory has attracted novel research interest. Several approaches {{to build up a}} dependency and normal form theory for XML databases have been published, mainly concentrating on functional dependencies and keys. XMLlike database structures can be modelled by rational trees using constructors for lists and disjoint unions. This involves restructuring rules on subattributes. The absence of redundancy can be characterised by the <b>nested</b> <b>list</b> normal form. If ordering is ignored, constructors for sets or multisets have to be employed. For these the theory can be extended using counterfree functional dependencies. Finally, for keys an important research question is which systems of subattributes permit Armstrong instances. While this gives just a glimpse of a starting promising theory, a research agenda for further research will be set up...|$|E
50|$|HTML {{requires}} an explicit element for the list, specifying its type, {{and one for}} each list item, but most lightweight markup languages need only different line prefixes for the bullet points or enumerated items. Some languages rely on indentation for <b>nested</b> <b>lists,</b> others use repeated parent list markers.|$|R
5000|$|A new list element type, the [...] element type, {{were to be}} {{included}} to specifically designate a list as a navigation list. This would have been useful in creating nested menus, which are currently created by {{a wide variety of}} means like <b>nested</b> unordered <b>lists</b> or <b>nested</b> definition <b>lists.</b>|$|R
50|$|The Outliner of Giants is {{commercial}} Outlining Software. Like other outliners, {{it allows}} the user to create a document consisting {{of a series of}} <b>nested</b> <b>lists.</b> It is {{one of a number of}} browser-based outliners that are delivered as a web application, used through a web browser, rather than being installed as a stand-alone application.|$|R
40|$|Abstract. We give a {{polynomial}} time construction of binary codes {{with the best}} currently known trade-off between rate and error-correction radius. Specifically, we obtain linear codes over fixed alphabets that can be list decoded in {{polynomial time}} up to the so called Blokh-Zyablov bound. Our work builds upon [7] where codes list decodable up to the Zyablov bound (the standard product bound on distance of concatenated codes) were constructed. Our codes are constructed via a (known) generalization of code concatenation called multilevel code concatenation. A probabilistic argument, which is also derandomized via conditional expectations, is used to show the existence of inner codes with a certain <b>nested</b> <b>list</b> decodability property that is appropriate for use in multilevel concatenated codes. A “level-by-level ” decoding algorithm, which crucially uses the list recovery algorithm for folded Reed-Solomon codes from [7], enables list decoding up to the designed distance bound, aka the Blokh-Zyablov bound, for multilevel concatenated codes...|$|E
40|$|The high {{frequency}} of applications involving large, ordered, nested lists suggests that list is the "next most" natural data type after set. A list differs from a set through positioning and nesting {{elements within the}} list. Directly supporting such position-related operations will greatly improve the performance of database systems targeting at the above applications. Unlike other attributes, the position will be changed by insertion and deletion within a list and known methods are not appropriate for indexing the position. We present an indexing structure, called the P-tree (where P for position), to index a set of lists. The P-tree generalizes the B-tree by dealing {{with a set of}} lists rather than a set of records, while preserving all the properties of the B-tree. 1. Introduction Recently, there has {{been a great deal of}} interest in data models and access supports for "bulk" data types. Perhaps the most common such construct is the ordered, <b>nested</b> <b>list</b> (see [1, 3, 9, 11, 13] for ex [...] ...|$|E
40|$|Many {{applications}} model {{their data}} in a general-purpose storage format such as JSON. This data structure is modified by the application {{as a result of}} user input. Such modifications are well understood if performed sequentially on a single copy of the data, but if the data is replicated and modified concurrently on multiple devices, it is unclear what the semantics should be. In this paper we present an algorithm and formal semantics for a JSON data structure that automatically resolves concurrent modifications such that no updates are lost, and such that all replicas converge towards the same state (a conflict-free replicated datatype or CRDT). It supports arbitrarily <b>nested</b> <b>list</b> and map types, which can be modified by insertion, deletion and assignment. The algorithm performs all merging client-side and does not depend on ordering guarantees from the network, making it suitable for deployment on mobile devices with poor network connectivity, in peer-to-peer networks, and in messaging systems with end-to-end encryption. This research was {{supported by a grant from}} The Boeing Company...|$|E
50|$|Array storage has to {{accommodate}} arrays of different dimensions and typically large sizes. A core {{task is to}} maintain spatial proximity on disk so as {{to reduce the number}} of disk accesses during subsetting. Note that an emulation of multi-dimensional arrays as <b>nested</b> <b>lists</b> (or 1-D arrays) will not per se accomplish this and, therefore, in general will not lead to scalable architectures.|$|R
25|$|A grid view, however, can be mimicked {{by using}} a {{standard}} HTML table with each cell containing a text input element. A tree view could also be mimicked through nested tables or, more semantically appropriately, <b>nested</b> <b>lists.</b> In both cases, a server-side process is responsible for processing the information, while JavaScript handles the user-interaction. Implementations of these interface elements are available through JavaScript libraries such as jQuery.|$|R
40|$|Properties {{of a few}} {{familiar}} structures (natural numbers, <b>nested</b> <b>lists,</b> lattices) are formally {{specified in}} Tarski-Givant's map calculus, {{with the aim of}} bringing to light new translation techniques that may bridge the gap between first-order predicate calculus and the map calculus. It is also highlighted to what extent a state-of-the-art theorem-prover for first-order logic, namely Otter, can be exploited not only to emulate, but also to reason about, map calculus...|$|R
30|$|The {{position}} of the significant markers was {{compared to that of}} approximately 200 root-related genes in rice from a database established in the framework of the EURoot project ([URL] Then, the function of the candidate genes in which significant markers were detected was determined using OrygenesDB ([URL] In addition, genes located in intervals of 50  kb {{on both sides of the}} marker were explored. This window size was chosen because it was intermediate between the average marker distance (approximately 25  kb in the GBS datasets and 1.5  kb in the HDRA datasets) and the distance at which LD decayed to half its initial level (estimated at 100  kb for the indica panel and 150  kb for the japonica panel on average across all chromosomes but much more variable in short-range segments). Particular attention was paid to auxin-related genes and to kinases because the cloned genes for root angle belonged to these families. Among kinases, leucine-rich repeat receptor-like kinases (LRR-RLKs) were identified using a list of LRR-RLK genes in rice and a <b>nested</b> <b>list</b> of LRR-RLKs involved in root development established by Dievart et al. (2016) and Fischer et al. (2016).|$|E
40|$|Multi-valued depdendencies (MVDs) are an {{important}} class of relational constraints. We axiomatise MVDs in data models that support <b>nested</b> <b>list</b> types. In order to capture different data models at a time, an abstract approach based on nested attributes is taken. The set of subattributes of some fixed nested attribute carries {{the structure of a}} co-Heyting algebra. This enables us to generalise significant features of MVDs from the relational data model to the presence of lists. It is shown that an MVD is satisfied by some instance exactly when this instance can be decomposed without loss of information. The full power of the algebraic framework allows to provide a sound and complete set of inference rules for the implication of MVDs in the context of lists. The presence of the list operator calls for a new inference rule which is not required in the relational data model. Further differences become apparant when the minimality of the inference rules is investigated. The extension of the relational theory of MVDs to the presence of lists allows to specify more real-world constraints and increases therefore the number of application domains...|$|E
40|$|AbstractK is an {{executable}} semantic {{framework in}} which programming languages, calculi, as well as type systems or formal analysis tools can be defined, making use of configurations, computations and rules. Configurations organize the system/program state in units called cells, which are labeled and can be nested. Computations carry “computational meaning” as special <b>nested</b> <b>list</b> structures sequentializing computational tasks, such as fragments of program; in particular, computations extend the original language or calculus syntax. K (rewrite) rules generalize conventional rewrite rules by making explicit which parts of the term they read, write, or do not care about. This distinction makes K a suitable framework for defining truly concurrent languages or calculi, even {{in the presence of}} sharing. Since computations can be handled like any other terms in a rewriting environment, that is, they can be matched, moved {{from one place to another}} in the original term, modified, or even deleted, K is particularly suitable for defining control-intensive language features such as abrupt termination, exceptions, or call/cc. This paper gives an overview of the K framework: what it is, how it can be used, and where it has been used so far. It also proposes and discusses the K definition of Challenge, a programming language that aims to challenge and expose the limitations of existing semantic frameworks...|$|E
40|$|This {{article is}} the first in the series of the {{articles}} dedi-cated to application of functional techniques for XML data management, which may be effectively used for implementation of XML-based digital libraries. We consider SXML a representation for the XML Information Set in the form of S-expressions (<b>nested</b> <b>lists)</b> and Scheme functional programming language which naturally processes S-expressions and thus SXML. This approach avoids the impedance mismatch problem that currently affects many XML-based applications, including digital libraries. ...|$|R
5000|$|OmniOutliner is a {{commercial}} outlining software for Mac OS X produced by The Omni Group. OmniOutliner has {{most of the}} features of a conventional outliner, allowing the user to create <b>nested</b> <b>lists</b> of topics for almost any purpose, but has additional features extending its functionality beyond simple outlining. Recent versions of the software are universal binaries. OmniOutliner received a special mention in the 2005 Apple Design Awards, and Macworld gave the [...] "Professional" [...] version its highest rating.|$|R
50|$|The {{basic data}} {{structure}} of Lisp and Prolog is a linear list consed {{up from the}} beginning. Refal lists are built and scanned from both ends, and pattern matching allows to match against <b>nested</b> <b>lists</b> {{as well as the}} top-level one. (In effect, the basic data structure of Refal is a tree rather than a list). According to the authors, this gives freedom and convenience in creating data structures while using only mathematically simple control mechanisms of pattern matching and substitution.|$|R
40|$|K is an {{executable}} semantic {{framework in}} which programming languages, calculi, as well as type systems or formal analysis tools can be defined making use of configurations, computations and rules. Configurations organize the system/program state in units called cells, which are labeled and can be nested. Computations carry "computational meaning" as special <b>nested</b> <b>list</b> structures sequentializing computational tasks, such as fragments of program; in particular, computations extend the original language or calculus syntax. K (rewrite) rules generalize conventional rewrite rules by making it explicit which parts of the term they read-only, write-only, or do not care about. This distinction makes K a suitable framework for defining truly concurrent languages or calculi even {{in the presence of}} sharing. Since computations can be handled like any other terms in a rewriting environment, that is, they can be matched, moved {{from one place to another}} in the original term, modified, or even deleted, K is particularly suitable for defining control-intensive language features such as abrupt termination, exceptions or call/cc. This paper gives an overview of the K framework: what it is, how it can be used, and where it has been used so far. It also proposes and discusses the K definition of Challenge, a programming language that aims at challenging and exposing the limitations of the various existing semantic frameworks. published or submitted for publicatio...|$|E
40|$|Abstract. The n-web fractal — the attractor of the IFS of n+ 1 contrac-tions by 1 / 2 {{toward the}} {{vertices}} of an n-simplex — {{emerges from a}} mani-fold (n-simplex). The classical example is Sierpiński’s gasket (2 -web) which emerges from a 2 -simplex. It is therefore natural (inverse of moving from manifolds to fractals) to seek, for each n ≥ 2, {{an extension of the}} n-web system to an n-simplex system. For n = 2, the author recently provided such a (minimal) extension. Here, we extend the 3 -web system to one whose attractor is the 3 -simplex. For n> 3, the extension problem remains open. 1. General and Historical Background We continue the work initiated in [16]. The n + 1 points u 0, u 1, [...] ., un are vertices of an n-simplex in some Euclidian space, and Fn = {w 0, w 1, [...] ., wn} is the iterated function system (IFS) where each wi(x) = 1 / 2 (x+ui) is a scaling by 1 / 2 toward ui. The attractor ωn of Fn is called the n-web [1][31], and the code space of Fn is the topological product Π∞j= 1 Aj = N(A) = N(0, [...] ., n) where each Aj is a copy of the discrete space A = { 0, 1, [...] ., n}. In general, the attractor is the unique compact set K = ∪i∈Awi(K) [1, The-orem 1, page 82], and it follows that K ⊃ wi(K) ⊃ wi ◦ wj(K), for every i and every j. Each α = α 1 α 2 · · · ∈ N(A) thereby determines a <b>nested</b> <b>list</b> K ⊃ wα 1 (K) ⊃ wα 1 ◦ wα 2 (K) ⊃ · · · of compact sets (whose diameters go t...|$|E
40|$|Sparse matrix formats encode {{very large}} {{numerical}} matrices with relatively few nonzeros. They are typically implemented using imperative languages, {{with emphasis on}} low-level optimization. Such implementations are {{far removed from the}} conceptual organization of the sparse format, which obscures the representation invariants. They are further specialized by hand for particular applications, machines and workloads. Consequently, they are difficult to write, maintain, and verify. In this dissertation we present LL, a small functional language suitable for implementing operations on sparse matrices. LL supports <b>nested</b> <b>list</b> and pair types, which naturally represent compressed matrices. It provides a few built-in operators and has a unique compositional dataflow model. As a result, LL programs are often direct analogs of high-level dataflow diagrams. This correspondence is useful when implementing sparse format construction and algebraic kernels such as sparse matrix-vector multiplication (SpMV). Despite its limited expressiveness, LL can specify interesting operations on real-world sparse formats. Next, we present a full functional verifier for sparse codes written in LL. We use a higher-order logic theorem prover, deploying standard simplification and introduction techniques. We use novel parametric predicates for tracking relationships between mathematical objects and their concrete representation. A simple heuristic tactic is used for automating proofs of different sparse formats. A qualitative analysis shows that our rule base exhibits good reusability and that the system easily extends to hierarchical formats. Finally, we describe a compiler for LL programs that generates efficient, parallel C code. We systematically map high-level nested datatypes onto compact and efficient low-level types. This facilitates a straightforward, syntax-directed translation of code. Local optimizations improve the performance of nested loops and eliminate redundant memory accesses. A coarse-grained heuristic loop parallelization scheme produces data-parallel code for execution on shared-memory multicore machines. Empirical evaluation shows that the sequential throughput of generated SpMV code is within 0. 94 [...] 1. 09 of a handwritten implementation. Parallel execution is 1. 82 [...] 1. 98 faster on two cores and 2. 44 [...] 3. 59 faster on four cores...|$|E
30|$|The {{concrete}} similarity {{calculation method}} is introduced {{in detail in}} [17]. When the similarity of two words is greater than threshold α, they will {{be regarded as a}} pair of synonym to merge. The optimal value of α will be discussed later in the experiment. In addition, all merged synonyms are stored in a <b>list.</b> <b>Nested</b> <b>lists</b> are used to store feature words so that all synonym information remains in the feature vector. To calculate the feature vector of each document, we propose three improved methods which will be discussed in Section 3.3.|$|R
40|$|This is a bugfix {{release that}} {{includes}} a workaround for an issue in matplotlib 1. 4. 2 and fixes for two bugs in functions that were new in 0. 5. 0. Implemented a workaround for a bug in matplotlib 1. 4. 2 that prevented point markers from being drawn when the seaborn styles had been set. See this github issue for more information. Fixed a bug in heatmap where the mask was vertically reversed relative to the data. Fixed a bug in clustermap when using <b>nested</b> <b>lists</b> of side colors...|$|R
40|$|Size {{analysis}} {{can be an}} important part of heap consumption analysis. This paper is a part of ongoing work about typing support for checking output-on-input size dependencies for function definitions in a strict functional language. A significant restriction for our earlier results is that inner data structures (e. g. in a list of lists) all must have the same size. Here, we make a big step forwards by overcoming this limitation via the introduction of higher-order size annotations such that variate sizes of inner data structures can be expressed. In this way the analysis becomes applicable for general, polymorphic <b>nested</b> <b>lists...</b>|$|R
