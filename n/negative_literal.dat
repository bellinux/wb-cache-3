20|110|Public
5000|$|... {{requires}} that every variable appearing in a <b>negative</b> <b>literal</b> {{in the body}} of a clause also appears in some positive literal {{in the body of}} the clause ...|$|E
5000|$|In {{predicate}} calculus a literal is an atomic formula or its negation, where an atomic formula is a predicate symbol applied to some terms, [...] with the terms recursively defined starting from constant symbols, variable symbols, and function symbols. For example, [...] is a <b>negative</b> <b>literal</b> with the constant symbol 2, the variable symbols x, y, the function symbols f, g, and the predicate symbol Q.|$|E
5000|$|There {{are several}} special {{cases of the}} Boolean satisfiability problem in which the {{formulas}} are required to have a particular structure.A literal is either a variable, then called positive literal, or the negation of a variable, then called negative literal.A clause is a disjunction of literals (or a single literal).A clause is called a Horn clause if it contains at most one positive literal.A formula is in conjunctive normal form (CNF) {{if it is a}} conjunction of clauses (or a single clause).For example, [...] is a positive literal, [...] is a <b>negative</b> <b>literal,</b> [...] is a clause, and [...] is a formula in conjunctive normal form, its 1st and 3rd clause are Horn clauses, but its 2nd clause is not. The formula is satisfiable, choosing x1 = FALSE, x2 = FALSE, and x3 arbitrarily, since (FALSE ∨ ¬FALSE) ∧ (¬FALSE ∨ FALSE ∨ x3) ∧ ¬FALSE evaluates to (FALSE ∨ TRUE) ∧ (TRUE ∨ FALSE ∨ x3) ∧ TRUE, and in turn to TRUE ∧ TRUE ∧ TRUE (i.e. to TRUE). In contrast, the CNF formula a ∧ ¬a, consisting of two clauses of one literal, is unsatisfiable, since for a=TRUE and a=FALSE it evaluates to TRUE ∧ ¬TRUE (i.e. to FALSE) and FALSE ∧ ¬FALSE (i.e. again to FALSE), respectively.|$|E
40|$|We {{present an}} {{optimized}} recursive query evaluation for deductive databases {{with the presence}} of <b>negative</b> <b>literals,</b> based on the Deductive High-Level Petri Net (DHLPN) model. The syntax and semantics of this model are derived frown High-Level Petri Nets. Such a model benefits from the control structure inherent to Petri nets, allowing the capture of rules' stratification, in order to interpret, without ambiguities, <b>negative</b> <b>literals</b> in rules, particularly during a recursive query evaluation. Voir le lien ic...|$|R
40|$|Abstract. We {{consider}} the satisfiability phase transition in skewed random k-SAT distributions. It {{is known that}} the random k-SAT model, in which the instance {{is a set of}} m k-clauses selected uniformly from the set of all k-clauses over n variables, has a satisfiability phase transition at a certain clause density. The essential feature of the random k-SAT is that positive and <b>negative</b> <b>literals</b> occur with equal probability in a random formula. How does the phase transition behavior change as the relative probability of positive and <b>negative</b> <b>literals</b> changes? In this paper we focus on a distribution in which positive and <b>negative</b> <b>literals</b> occur with different probability. We present empirical evidence for the satisfiability phase transition for this distribution. We also prove an upper bound on the satisfiability threshold and a linear lower bound on the number of literals in satisfying partial assignments of skewed random k-SAT formulas. ...|$|R
40|$|A common {{approach}} to non [...] monotonic reasoning {{is to choose}} a set S of models (e. g. minimal, perfect or stable models) for a logic program P. Then, the meaning of P {{is defined as the}} set of all formulas which are implied logically by all models in S. For a disjunctive logic program P, we consider the set S = MMP of minimal models and get the non [...] montonic consequences NMP of ground disjunctions over positive or <b>negative</b> <b>literals.</b> The set NMP consists of three subsets: The minimal model state MSP (ground disjunctions over positive literals), the negated extended generalized closed world assumption :EGCWA P (ground disjunctions over <b>negative</b> <b>literals),</b> and the rest (mixed disjunctions over positive and <b>negative</b> <b>literals).</b> We show that the mixed disjunctions are implied logically by MSP [:EGCWA P. Thus the interesting sets are the logical consequences MSP and the non [...] monotonic consequences :EGCWA P. As described in [16], MSP consists of the positive ground disjunctions, which ar [...] ...|$|R
3000|$|... {{that contain}} {{at least one}} element of A as a <b>negative</b> <b>literal.</b> For y∈Y, let g(y) be the set of clauses in [...]...|$|E
40|$|AbstractConstructive {{negation}} derives constraint {{answers for}} non-ground negative literals. Its incorporation into query evaluation under the well-founded semantics introduces two problems. One is {{the detection of}} repeated subgoals {{and the elimination of}} redundant answers, which is required in order to guarantee termination. The other is the interaction between constraint answers of non-ground negative literals and recursion through negation. This paper presents SLGCN for effective query evaluation with constructive negation under the well-founded semantics. It has two unique features. First, it supports reduction of constraint answers and redundant answer elimination and provides the first termination result for goal-oriented query evaluation with constructive negation for function-free programs. Second, it avoids repeated computation in a subgoal. Even if a non-ground <b>negative</b> <b>literal</b> depends upon some ground negative literals whose truth values are not completely determined when they are selected, the constraints and bindings for variables in the non-ground <b>negative</b> <b>literal</b> can still be propagated once and for all...|$|E
40|$|This paper proposes an {{extension}} of the well known DavisPutnam algorithm inspired by the following observation. Given the fact that a set of clauses S does not have any model containing the variable x, the set T of clauses containing x as a <b>negative</b> <b>literal</b> can serve as a source of constraints for the remaining model search, even though the propagation of the unit suggests to completely ignore these clauses...|$|E
40|$|This paper {{provides}} {{a method for}} generating a proof tree from an instance and a general logic program viz one which includes <b>negative</b> <b>literals.</b> The method differs from previous {{work in the field}} in that <b>negative</b> <b>literals</b> are first unfolded and then transformed using De Morgan's laws so that the tree explicitly includes negative rules. The method is applied to a real-world example - a large executable specification providing rules for separation for two aircraft. Given an instance of a pair of aircraft whose flight paths potentially violate seperation rules,the tree contains both positive and negative rules which contribute to the proof...|$|R
5000|$|CCWA (careful CWA): same as GCWA, but a {{positive}} clause is only considered {{if it is}} composed of positive literals of a given set and (both positive and <b>negative)</b> <b>literals</b> from another set; ...|$|R
50|$|A Horn clause is {{a clause}} with at most one {{positive}} literal, called {{the head of}} the clause, and any number of <b>negative</b> <b>literals,</b> forming the body of the clause. A Horn formula is a propositional formula formed by conjunction of Horn clauses.|$|R
40|$|Monotone 3 -Sat- 4 is {{a variant}} of the satisfiability problem for boolean {{formulae}} in conjunctive normal form. In this variant, each clause contains exactly three literals [...] -either all or none of them are positive, i. e., no clause contains both a positive and a <b>negative</b> <b>literal</b> [...] -and every variable appears at most four times in the formula. Moreover, every clause consists of three distinct literals. We show that Monotone 3 -Sat- 4 is NP-complete...|$|E
40|$|We {{propose a}} set of {{transformation}} rules for constraint logic programs with negation. We assume that every program is locally strati- ed and, thus, it has a unique perfect model. We give sucient conditions which ensure that the proposed set of transformation rules preserves the perfect model of the programs. Our rules extend in some respects the rules for logic programs and constraint logic programs already considered in the literature and, in particular, they include a rule for unfolding a clause {{with respect to a}} <b>negative</b> <b>literal...</b>|$|E
40|$|AbstractThe SLDNF {{resolution}} (SLD resolution with negation as failure) {{is often}} restricted {{to yield a}} safe rule, that is, negation as failure rule is adopted only in {{the case that the}} selected <b>negative</b> <b>literal</b> in each goal should be in ground. In this paper we investigate extensions of goals in SLDNF resolutions with the case of selecting non-ground negative literals. Since Shepherdson's proposal is thought of as most general [16, 18] we formally show how the success and failure sets by Sherpherdson's SLDNFS resolution are related with a fixpoint semantics, which is generalized to be concerned with atom sets involving the variables...|$|E
5000|$|The STRIPS {{language}} only allows positive literals in the states, while ADL {{can support}} {{both positive and}} <b>negative</b> <b>literals.</b> For example, a valid sentence in STRIPS could be Rich ∧ Beautiful. The same sentence could be expressed in ADL as ¬Poor ∧ ¬Ugly ...|$|R
5000|$|... whose {{positive}} literal (atom) [...] unifies {{with the}} atom [...] {{of the selected}} literal , SLD resolution derives another goal clause, in which the selected literal is replaced by the <b>negative</b> <b>literals</b> of the input clause and the unifying substitution [...] is applied: ...|$|R
50|$|Contrary to STRIPS, the {{principle}} of the open world applies with ADL: everything not occurring in the conditions is unknown (Instead of being assumed false). In addition, whereas in STRIPS only positive literals and conjunctions are permitted, ADL allows <b>negative</b> <b>literals</b> and disjunctions as well.|$|R
40|$|We {{investigate}} {{the problem of}} revising a propositional knowledge base, viewed {{as a set of}} Horn clauses. We present algorithms that revise the knowledge base with a Horn clause according to the Set of Theories [Fagin and Ullman and Vardi] and the When In Doubt Throw It Out approaches [Ginsberg]. Under the first approach the problem has shown to be intractable even when further restrictions are applied. We show that the algorithms run in polynomial time in the case where the number of "relevant" negative clauses and rules (definite clauses having at least one <b>negative</b> <b>literal)</b> in the knowledge base is bounded. Intermediate results about resolution deduction of literals from a set of Horn clauses are obtained, which are of interest in their own right...|$|E
40|$|Abstract. The {{main purpose}} of this paper is to present a new {{algorithm}} (NEW-SAT) for deciding the (un) satisfiability of propositional formulae. It is based on a somehow dual (versus resolution) idea: we succesively add complementary literals to already obtained clauses instead of solving them. Hence, the unsatisfiability of a formula is detected by reaching “a complete set of maximal clauses ” instead of reaching the empty clause. Only weak (semantical) equivalence is preserved. In fact, although the strong equivalence is not preserved, we have something more than a simple weak equivalence. To be more precise, in case of satisfiability, the number of truth assignments is also preserved. Let LP be the propositional logic over the denumerable set of atomic formulae (propositional variables) V = {A 1, A 2, [...] . }. A literal is an atomic formula (positive literal) or its negation (<b>negative</b> <b>literal).</b> For any litera...|$|E
40|$|We {{consider}} {{a mode of}} an n-ary predicate symbol {{with respect to a}} logic program, which meets the aim of logic programming and captures the spirit of unification as arguments passing mechanism. We prove that the SLDNF-resolution which resolves a non-ground <b>negative</b> <b>literal</b> is complete for an interesting class of logic programs using this mode. To obviously do such a proof we do consider terms modulo variable renaming and map a logic program with a goal to an allowed logic program with an allowed goal, since it is well-known that the SLDNF-resolution is complete for the class of allowed logic programs with allowed goals [Kunen 89]. The termination of the SLDNF-resolution is studied using a sophisticated selection function which only chooses those literals and clauses that are applicable in the sense that using such literals and clauses the SLDNF-resolution would not be infinite, if a finite SLDNF-resolution does exist...|$|E
40|$|The encoded <b>negative</b> <b>literals</b> in a {{conformant}} planning task {{will result}} in increasing state spaces. Getting a compact representation of state spaces {{is one of the}} most important issues in conformant planning. In this paper, a translation algorithm for <b>negative</b> <b>literals</b> is proposed to reduce the state spaces in a conformant planning task. The relationship between encoded literals is analyzed in detail. Based on the one-of relaxation technique in domain language, the algorithm is used to express the uncertain initial states and action effects in conformant planning. It converts formula one-of into a set of mutually exclusive literals with the relationship of mutual. The experiment study shows the efficiency of the proposed algorithm in pruning the state space in conformant planning tasks...|$|R
40|$|The well-founded model {{provides}} {{a natural and}} robust semantics for logic programs with <b>negative</b> <b>literals</b> in rule bodies. Although various procedural semantics have been proposed for query evaluation under the well-founded semantics, the practical issues of implementation for effective and efficient computation of queries have been rarely discussed. This paper investigates two major implementation issues of query evaluation under the well-founded semantics, namely (a) to ensure that <b>negative</b> <b>literals</b> be resolved only after their positive counterparts have been completely evaluated, and (b) to detect and handle potential negative loops. We present efficient incremental algorithms for maintaining positive and negative dependencies among subgoals in a top-down evaluation. Both completely evaluated subgoals and potential negative loops are detected by inspecting the dependency information of a single subgoal. Our implementation {{can be viewed as}} an effective successor to SLDNF resolution, ex [...] ...|$|R
2500|$|... where H {{and all the}} Ai and Bi are atomic formulas. The {{negation}} in the <b>negative</b> <b>literals</b> [...] not Bi {{is commonly}} referred to as [...] "negation as failure", because in most implementations, a negative condition [...] not Bi is shown to hold by showing that the positive condition [...] Bi [...] fails to hold. For example: ...|$|R
40|$|An {{algorithm}} for the Satisfiability {{problem is}} presented and its probabilistic behavior is analysed {{when combined with}} two other algorithms studied earlier. The analysis {{is based on an}} instance distribution which is parameterized to simulate a variety of sample characteristics. The algorithm dynamically assigns values to literals appearing in a given instance until a satisfying assignment is found or the algorithm "gives up" without determining whether or not a solution exists. It is shown that if n clauses are constructed independently from r boolean variables where the probability that a variable appears in a clause as a positive literal is p and as a <b>negative</b> <b>literal</b> is p then almost all randomly generated instances of Satisfiability are solved in polynomial time if p ! : 4 ln(n) =r or p ? ln(n) =r or p = c ln(n) =r, : 4 ! c ! 1 and lim n;r! 1 n 1 =r 1 ! 1 for any ffl ? 0. It is also shown that if p = c ln(n) =r, : 4 ! c ! 1 and lim n;r! 1 n 1 =r = 1 then almost [...] ...|$|E
40|$|We {{consider}} pre-processing {{a random}} instance I of CNF Satisfiability {{in order to}} remove infrequent variables (those which appear once or twice in an instance) from I. The model used to generate random instances is the popular random-clause-size model with parametersn, the number of clauses, r, the number of Boolean variables from which clauses are composed, and p, {{the probability that a}} variable appears in a clause as a positive (or <b>negative)</b> <b>literal.</b> It is shown that exhaustive search over such pre-processed instances runs in polynomial average time over a significantly larger parameter space than has been shown for any other algorithm under the random-clause-size model when n = r ffl, ffl ! 1, and pr ! p fflr ln(r). Specifically, the results are that random instances of Satisfiability are "easy" in the average case if n = r ffl, 2 = 3 ? ffl ? 0, and pr ! (ln(n) = 4) 1 = 3 r 2 = 3; or n = r ffl, 1 ? ffl 2 = 3, pr ! (1 Γ ffl Γ ffi) ln(n) =ffl for any ffi ? 0 [...] ...|$|E
40|$|AbstractAn {{algorithm}} for the satisfiability problem (SAT) {{is presented}} and its probabilistic behavior is analyzed {{when combined with}} two other algorithms studied earlier. The analysis {{is based on an}} instance distribution which is parameterized to simulate a variety of sample characteristics. The algorithm dynamically assigns values to literals appearing in a given instance until a satisfying assignment is found or the algorithm “gives up” without determining whether or not a solution exists. It is shown that if n clauses are constructed independently from r Boolean variables, where the probability that a variable appears in a clause as a positive literal is p and as a <b>negative</b> <b>literal</b> is p, then almost all randomly generated instances of SAT are solved in polynomial time if p ln(n) r or p=c ln(n) r, 0. 4; 0. It is also shown that if p=c ln(n) r, 0. 4 <c< 1 and limn,r→∞n 1 −cr=∞ then almost all randomly generated instances of SAT have no solution. Thus the combined algorithm is very effective in the probabilistic sense on instances of SAT that have solutions. The combined algorithm is effective in some limited sense in verifying unsatisfiability...|$|E
40|$|AbstractThe well-founded model {{provides}} {{a natural and}} robust semantics for logic programs with <b>negative</b> <b>literals</b> in rule bodies. Although various procedural semantics have been proposed for query evaluation under the well-founded semantics, the practical issues of implementation for effective and efficient computation of queries have been rarely discussed. This paper investigates two major implementation issues of query evaluation under the well-founded semantics, namely, (a) to ensure that <b>negative</b> <b>literals</b> be resolved only after their positive counterparts have been completely evaluated, and (b) to detect and handle potential negative loops. We present efficient incremental algorithms for maintaining positive and negative dependencies among subgoals in a top-down evaluation. Both completely evaluated subgoals and potential negative loops are detected by inspecting the dependency information of a single subgoal. Our implementation {{can be viewed as}} an effective successor to SLDNF resolution, extending Prolog computation in a natural and smooth way...|$|R
40|$|AbstractFundamental {{properties}} of deterministic and nondeterministic extensions of Datalog from Abiteboul and Vianu (1988) are studied. The extensions involve {{the use of}} <b>negative</b> <b>literals</b> both in bodies and heads of rules. <b>Negative</b> <b>literals</b> in heads are interpreted as deletions. A deterministic semantics is obtained by firing in parallel all applicable rules. The nondeterministic semantics results from firing (nondeterministically) one rule at a time. In the nondeterministic case, programs do not describe functions but relations between database states. In both cases, {{the result is an}} increase in expressive power over Datalog. The price for it is that programs do not always terminate. We study when a program (i) is such that on a given input, all its successful computations reach a unique fixpoint, (ii) yields at least one output on every input and (iii) has only loop-free computations. We also show how to simulate programs containing loops by loop-free programs...|$|R
40|$|This paper {{relates the}} Defeasible Logic Programming (DeLP) {{framework}} and its semantics SEM DeLP to classical logic programming frameworks. In DeLP we distinguish between two different sorts of rules: strict and defeasible rules. <b>Negative</b> <b>literals</b> (A) {{in these rules}} are considered to represent classical negation. In contrast to this, in normal logic programming (NLP), {{there is only one}} kind of rules, but the meaning of <b>negative</b> <b>literals</b> (notA) is different: they represent a kind of negation as failure, and thereby introduce defeasibility. Various semantics have been defined for NLP, notably the well-founded semantics WFS and the stable semantics Stable. In this paper we consider the transformation properties for NLP introduced by Brass and Dix and suitably adjusted for the DeLP framework. We show which transformation properties are satisfied, thereby identifying aspects in which NLP and DeLP differ. We contend that the transformation rules presented in this paper can he [...] ...|$|R
3000|$|The {{reasoning}} system processes matrices, which {{are represented by}} Oz data structures. In particular, a matrix {{is a list of}} columns, while a column is a list of literals. We use the symbol O in the superscript to denote the Oz representation of the given expression. A <b>negative</b> <b>literal</b> has a general form of Oz record ([9]) [...] neg (L^O), whose label is a reserved symbol neg standing for the negation and the fieldL^O is an Oz counterpart of the positive literal L. In other words, L is an atom, namely a predicate possibly followed by a tuple of terms. Predicates, functors and constants are denoted by alphanumeric strings starting from a lowercase letter, whereas variable names start from an uppercase one. A tuple of terms (t_ 1, [...]..., t_n) is represented by the expression [...] ([...] t^O_ 1 t^O_ 2 [...]... t^O_n [...]) [...] with a space character as a separator. Summing up, the exemplary matrix given in Fig.  1 has the following representation in Oz: [[neg(p 1 (X Y)) p 4 (a X) neg(p 6)] [p 2 (X) neg(p 5 (b))] [neg(p 3 (Y))]].|$|E
3000|$|We briefly {{present the}} {{fundamentals}} of the connection calculus. In this description we use a standard FOL syntax and semantics {{as well as some}} elements of logic programming theory [5]. In particular, the alphabet encompasses constants a, b, c, variables x, y, z, functors f, g, h and predicates p, q, r. The symbol L denotes a literal, namely an atomic formula (i.e. a positive literal) or a negated atomic formula, i.e. a <b>negative</b> <b>literal.</b> An atomic formula is called in short an atom. All mentioned symbols can possibly be subscripted. The symbol θ stands for a substitution{x_ 1 /t_ 1, [...]..., x_n/t_n}, where x_i is a variable and t_i is a term for i= 1,n. An application of the substitutionθ to the expression E (namely, to a term or to a formula) results in the expression Eθ, which is obtained from E by replacing every occurrence of the variable x_i by the term t_i. The expression Eθ is called an instance of the expression E. Moreover, a copy of the expression E is an instance of E with all variables renamed to new, unique identifiers. If the given expression does not contain variables then it is called ground. Two expressions E and E^' are unifiable if there exists a unifier for them, that is to say, a substitution θ, such that Eθ = E^'θ.|$|E
40|$|To each of n Boolean variables, {{associate}} {{a positive}} literal x and a <b>negative</b> <b>literal</b> x. The literal x has the opposite truth value as the literal x. A k-clause {{is a set}} of k literals associated with different variables and a k-SAT formula {{is a set of}} k-clauses. An assignment of true or false to each variable is a satisfying assignment for a k-SAT formula if each clause in the formula contains at least one true literal. A k-SAT formula gives rise to a Boolean function which evaluates to 1 whenever the input forms a satisfying assignment. Let Gk(n) denote the number of Boolean functions arising from k-SAT formulae. Bollobás, Brightwell, and Leader prove that G 2 (n) = 2 (1 +o(1)) n 2 / 2 n(n+ 1) / 2. They conjecture that the number of 2 -SAT functions is actually (1 + o(1)) 2. A lower bound for G 2 (n) is given by 2 (n 2) since each monotone formula (a formula which contains only positive literals) gives rise to a unique 2 -SAT function. To obtain an upper bound, the authors translate the problem of enumerating 2 -SAT Boolean functions into one of enumerating graphs on n vertices whose edges are colored red or blue and in which every triangle has an even number of blue edges. While their technique does not extend to k-SAT functions for k> 2, Bollobás, Brightwell, and Leader do provide an upper bound for Gk(n). Upon proving that log (Gk(n)) / () n is a decreasing function, they show that for n ≥ 2 k, Gk(n) ≤ 2 Gk(n) = 2 (1 +o(1)) (n k) ...|$|E
40|$|We {{propose a}} new {{negation}} rule for logic programming which derives existentially closed <b>negative</b> <b>literals,</b> and we define {{a version of}} completion for which this rule is sound and complete. The rule is called "Negation As Instantiation" (NAI). According to it, a negated atom succeeds whenever all {{the branches of the}} SLD-tree for the atom either fail or instantiate the atom. The set of the atoms whose negation is inferred by the NAI rule is proved equivalent to the complement of TC #!, where TC is the immediate consequence operator extended to nonground atoms (Falaschi et al., 1989). The NAI rule subsumes negation as failure on ground atoms, it excludes floundering and can be efficiently implemented. We formalize this way of handling negation in terms of SLDNI-resolution (SLD-resolution with Negation as Instantiation). Finally, we amalgamate SLDNI-resolution and SLDNF-resolution, thus obtaining a new resolution procedure which is able to treat <b>negative</b> <b>literals</b> with both existentially qu [...] ...|$|R
40|$|AbstractThis paper {{presents}} a sound and complete procedure {{with respect to}} the 3 -valued stable model semantics. The procedure is regarded as an extension of Eshghi and Kowalski abductive proof procedure, involving finite or countably infinite SLD resolution, as well as finite or countably infinite negative recursion caused by negation as failure. The procedure makes use of the set of <b>negative</b> <b>literals</b> (the set of abducibles) for the negation as failure to be implemented. The set of abducibles is not only applicable to the extraction of explanations for abduction as in Kakas et al. (J. Logic Comput. 2 (1992) 719 – 770) but also specified for what stable model is now computed in the procedure, because a 3 -valued stable model is not always the least (that is, the well-founded model). The procedure also contains nondeterminism in the choices of what ground <b>negative</b> <b>literals</b> are used for negation as failure. By the assumptions of some adequate choices, the procedure is well-defined inductively...|$|R
40|$|Fundamental {{properties}} of deterministic and nondeterministic extensions of Datalog from [AV 88] are studied. The extensions involve {{the use of}} <b>negative</b> <b>literals</b> both in bodies and heads of rules. <b>Negative</b> <b>literals</b> in heads are interpreted as deletions. A deterministic semantics is obtained by firing in parallel all applicable rules. The nondeterministic semantics results from firing (nondeterministically) one rule at a time. In the nondeterministic case, programs do not describe functions but relations between database states. In both cases, {{the result is an}} increase in expressive power over Datalog. The price for it is that programs do not always terminate. We study when a program (i) is such that on a given input, all its successful computations reach a unique fixpoint, (ii) yields at least one output on every input and (iii) has only loop-free computations. We also show how to simulate programs containing loops by loop-free programs. Work supported by the Projet de Recherc [...] ...|$|R
