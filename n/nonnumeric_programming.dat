1|2|Public
40|$|The {{method of}} {{structured}} programming or program development using a top-down, stepwise refinement technique provides a systematic approach {{for the development}} of programs of considerable complexity. The aim {{of this paper is to}} present the philosophy of structured programming through a case study of a <b>nonnumeric</b> <b>programming</b> task. The problem of converting a well-formed formula in first-order logic into prenex normal form is considered. The program has been coded in the programming language PASCAL and implemented on a DEC- 10 system. The program has about 500 lines of code and comprises 11 procedures...|$|E
40|$|Speculative {{multithreading}} (SpMT) {{promises to}} be an effective mechanism for parallelizing <b>nonnumeric</b> <b>programs,</b> which tend to have irregular and pointer-intensive data structures and complex flows of control. Proper thread formation is crucial for obtaining good speedup in an SpMT system. This paper presents a compiler framework for partitioning a sequential program into multiple threads for parallel execution in an SpMT system. This framework is very general and supports speculative threads, nonspeculative threads, loop-centric threads, and out-of-order thread spawning. It is therefore useful for compiling {{for a wide variety of}} SpMT architectures. For effective partitioning of programs, the compiler uses profiling, interprocedural pointer analysis, data dependence information, and control dependence information. The compiler is implemented on the SUIF-MachSUIF platform. A simulation-based evaluation of the generated threads shows that the use of nonspeculative threads and nonloop speculative threads provides a significant increase in speedup for <b>nonnumeric</b> <b>programs...</b>|$|R
40|$|Abstract-This paper {{describes}} {{a new technique}} for estimating and understanding the speed improvement that can result from executing a program on a parallel computer. The technique requires no additional programming and minimal effort by a program’s author. The analysis begins by tracing a sequential program. A parallelism analyzer (pp) uses information from the trace to simulate parallel execution of the program. In addition to predicting parallel performance, pp measures many aspects of a program’s dynamic behavior. This paper presents measurements of six substantial programs. These {{results indicate that the}} three symbolic (<b>nonnumeric)</b> <b>programs</b> differ substantially from the numeric programs and, as a consequence, cannot be automatically parallelized with the same compilation techniques. Index Terms- Parallel compilers, parallel programming, per-formance, program tracing, simulation...|$|R

