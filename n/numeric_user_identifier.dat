0|137|Public
40|$|Microsoft Powerpoint presentation, 12 slidesThis presentation, {{given at}} the Cornell Commonspot SIG meeting on March 22, 2006, {{addresses}} issues we discovered in moving sites from a test to production server. Content is stored in a per-site Oracle schema, while <b>user</b> <b>identifiers</b> are defined in a per-server schema. When migrating, it's necessary to update <b>user</b> <b>identifiers</b> in the site database. Peter Hoyt and Paul Houle developed a Perl script that examines the database structure, identifies fields that contain <b>user</b> <b>identifiers,</b> and maps them from the old to new server...|$|R
5000|$|IMSI or Public <b>User</b> <b>Identifier</b> (PUID) {{of calling}} or called user ...|$|R
5000|$|... the <b>user</b> <b>identifier.</b> This {{field is}} the most {{important}} and it's strictly read-only.|$|R
5000|$|Sets the <b>user</b> <b>identifier,</b> uid, {{and group}} identifier, gid, for all files on the filesystem.|$|R
5000|$|... <b>user</b> <b>identifier</b> number, {{used by the}} {{operating}} system for internal purposes. It need not be unique.|$|R
40|$|This paper {{describes}} some {{attacks on}} online banks that authenticate each customer {{through the use}} of a unique <b>user</b> <b>identifier</b> and a Personal Identification Number (PIN). Many <b>user</b> <b>identifiers</b> contain structure which make them easy to generate on a computer. Given a generated set of identifiers it is possible to do a brute-force attack on the PINs. A general attack model is described and some example attacks against a Scandinavian online bank are discussed...|$|R
50|$|Process {{identification}} data always include a unique identifier {{for the process}} (almost invariably an integer number) and, in a multiuser-multitasking system, data like the identifier of the parent process, <b>user</b> <b>identifier,</b> <b>user</b> group <b>identifier,</b> etc. The process id is particularly relevant, since it {{is often used to}} cross-reference the OS tables defined above, e.g. allowing to identify which process is using which I/O devices, or memory areas.|$|R
40|$|Identity {{management}} across Ubiquitous and Telecom environments {{is suffering}} from serious privacy problems as both persistent device <b>identifiers</b> and <b>user</b> <b>identifiers</b> lead {{to high levels of}} linkability. A new approach to Privacy authentication in wireless environments is proposed turning the IETF Mobile IP proposal for wireless communication into persistent non-identified IP sessions without telecom providers knowing any persistent device or <b>user</b> <b>identifiers.</b> A new Privacy Authentication Unit holding a data component to an Identity Disclosure Process act as an IP-session authenticating agent towards the subscribing telecom provider based on a zeroknowledge authentication process with a wireless device...|$|R
30|$|Finally, we {{generated}} a table containing all follow-relationships among these 4, 016 active developers in Brazil. The generated table contained tuples with unique <b>user</b> <b>identifiers</b> {{in the form}} <user 1,user 2 > if User 1 followed User 2.|$|R
5000|$|The ORCID {{organization}} {{offers an}} open and independent registry intended to be the de facto standard for contributor identification in research and academic publishing. On 16 October 2012, ORCID launched its registry services [...] and started issuing <b>user</b> <b>identifiers.</b>|$|R
40|$|The Self-certifying File System (SFS) {{currently}} exports Unix filesystems. Consequently, file owners on SFS servers {{who want}} to give other users access to their files can do so only through the coarse-grained Unix access control mechanisms, {{which are based on}} locally de ned <b>user</b> <b>identifiers</b> and group identifiers. Therefore, despite the fact that SFS was designed to be a global filesystem, it is impossible for a file owner to grant access permissions to a remote SFS user who does not maintain a Unix account on the local machine. Moreover, creating new <b>user</b> <b>identifiers</b> or group identifiers for the purpose of access control requires the involvement of the local machine's administrator, a limitation that runs counter to the egalitarian spirit of SFS. This thesi...|$|R
50|$|Once {{the user}} has logged on, the {{operating}} system will often use an identifier such as an integer to refer to them, rather than their username, through {{a process known as}} identity correlation. In Unix systems, the username is correlated with a <b>user</b> <b>identifier</b> or <b>user</b> id.|$|R
40|$|We {{apply the}} {{two-stage}} reliable and scalable SIP server architecture proposed in [1] for presence. The first stage proxies the requests {{to one of}} second stage server groups {{based on the event}} header and destination <b>user</b> <b>identifier.</b> The destination <b>user</b> <b>identifier</b> is based on presentity’s URI. Such a system achieves uniform load sharing on the servers on an average. However, in certain cases the load may not be uniformly distributed on all the servers. We propose to use load metric based static allocation algorithm to distribute the load uniformly. The load metric determination and performance evaluation of such a strategy is identified as future work. Additionally, we explain load sharing architecture for XCAP server, which is based on HTTP request redirection which is similar to load sharing in web servers...|$|R
50|$|Network Access Identifiers were {{originally}} defined in RFC 2486, which was superseded by RFC 4282, {{which has been}} superseded by RFC 7542. The latter RFC is the current standard for the NAI. NAIs are commonly found as <b>user</b> <b>identifiers</b> in the RADIUS and Diameter network access protocols and the EAP authentication protocol.|$|R
5000|$|Data {{types are}} defined to {{represent}} the main data of the modelled system. Each type definition introduces a new type name and gives a representation {{in terms of the}} basic types or in terms of types already introduced. For example, a type modelling <b>user</b> <b>identifiers</b> for a log-in management system might be defined as follows: ...|$|R
3000|$|... [...]) keys {{according}} to some digital signature scheme. Each message in the communication phase is signed by the user using the signature key and verified by the server using the verification key. U {{sends a message to}} the CA which contains the polynomial A, the generator g (which is later explained), the <b>user</b> <b>identifier</b> I [...]...|$|R
50|$|Multiple <b>user</b> <b>identifiers</b> - Employees can be {{recorded}} in an ECRS {{so that they}} may have an unlimited number of identifiers that are used with third-party systems to associate them with transactions and/or types of transactions. Identifiers may include telephone extensions, photocopy IDs, cell phone numbers, calling card codes, service account codes, login IDs, and credit card numbers.|$|R
40|$|Source: US 2014365781 A [EN] Some {{embodiments}} {{relate to}} a computer readable medium including a program code, which is configured, when running on a programmable hardware component, to receive a delegated token from a user's device, including receiving a signal indicative of at least the delegated <b>user</b> <b>identifier</b> and a delegating security pattern from the delegated user and including providing the device of the user with a signal indicative {{of at least a}} delegated <b>user</b> <b>identifier,</b> and a delegation challenge value. It is further configured to receive, from the device of the user, a signal indicative of at least, in an encrypted form, a delegated token, a user-specific token, a delegation authentication key, a user-specific delegation challenge value, and a delegation check value. The program code is further configured to store in the device of the delegated user the delegation authentication key, the delegated token, and the user-specific token...|$|R
40|$|The {{method of}} {{biometric}} cryptosystem designed {{on the basis}} of fuzzy extractor, in which main disadvantages of biometric and cryptographic systems are absent, is considered. The main idea of this work is a control of identity recognition errors with use of fuzzy extractor which operates with Reed – Solomon correcting code. The fingerprint features vector is considered as a biometric <b>user</b> <b>identifier...</b>|$|R
5000|$|In {{the context}} of a {{financial}} transaction, usually both a private [...] "PIN code" [...] and public <b>user</b> <b>identifier</b> is required to authenticate a user to the system. In these situations, typically the user is required to provide a non-confidential <b>user</b> <b>identifier</b> or token (the user ID) and a confidential PIN {{to gain access to the}} system. Upon receiving the user ID and PIN, the system looks up the PIN based upon the user ID and compares the looked-up PIN with the received PIN. The user is granted access only when the number entered matches with the number stored in the system. Hence, despite the name, a PIN does not personally identify the user. The PIN is not printed or embedded on the card but is manually entered by the cardholder during automated teller machine (ATM) and point of sale (POS) transactions (such as those that comply with EMV), and in card not present transactions, such as over the Internet or for phone banking.|$|R
30|$|The {{algorithm}} {{takes as}} input two vectors. The first vector, i.e. the training set, {{is composed of}} tuples formed by tags, their evaluation (e.g., “useful”) and the <b>user</b> <b>identifier</b> (which consists of a URI, since we use the Semantic Web representation described above). The second vector (test set) is composed of tuples formed by tags and the <b>identifier</b> of the <b>user</b> that provided them.|$|R
30|$|Digital {{identities in}} CardSpace are {{represented}} as claims made by one digital subject (e.g., an Internet user) about itself or another digital subject. A claim is an assertion that certain identifying information (e.g., given name, SSN, credit card number, etc.) {{belongs to a}} given digital subject [5, 6]. Under this definition, <b>user</b> <b>identifiers</b> (e.g., a username) and user attributes (e.g., user gender) are both treated as claims within the identity metasystem.|$|R
50|$|Developer Don Park {{introduced}} the identicon library {{for making a}} visual icon from a hashof a data identifier. This initial public implementation has spawned a large numberof implementations for various environments. In particular, identicons arenow being used as default visual <b>user</b> <b>identifiers</b> (avatars) for several widely used systems. They are also used as a complement to Gravatars, which are pre-existing avatar images created or chosen by users, instead of automatically generated images.(see #External links).|$|R
50|$|The first {{implementation}} of identity-based signatures and an email-address based public-key infrastructure (PKI) {{was developed by}} Adi Shamir in 1984, which allowed users to verify digital signatures using only public information such as the <b>user's</b> <b>identifier.</b> Under Shamir's scheme, a trusted third party would deliver the private key to the user after verification of the user's identity, with verification {{essentially the same as}} that required for issuing a certificate in a typical PKI.|$|R
40|$|The visiting or {{business}} card has {{the size and}} thickness of a standard printed business card and has an integrated circuit embedded into it. The circuit {{is in the form}} of a read only memory that contains alpha <b>numeric</b> <b>user</b> information that can also represent a graphical image or photographic sequence. Audio information may also be stored. The surface of the card can be printed. USE - Electronic visiting card. ADVANTAGE - Is same size as standard printed visiting card...|$|R
40|$|Just as {{errors in}} {{sequential}} programs {{can lead to}} security exploits, errors in concurrent programs can lead to concurrency attacks. In this paper, we present an in-depth study of concurrency attacks and how they may affect existing defenses. Our study yields several interesting findings. For instance, we find that concurrency attacks can corrupt non-pointer data, such as <b>user</b> <b>identifiers,</b> which existing memory-safety defenses cannot handle. Inspired by our findings, we propose new defense directions and fixes to existing defenses. ...|$|R
30|$|The user Ui is {{authenticated}} {{by using}} the Password (PW’) used initially for login process. Once authenticated, the user is prompted to enter the new password. Once the new password (PW”) is entered, the yi = Ex (IDi ‖ h(PWi) ‖ SBi) value of h(PWi) is replaced with the value of h(PWi”). An intimation of the password change {{is given to the}} server and it replaces the old password for the <b>user</b> <b>identifier</b> with the new password. Thereby the user is allowed to further login {{by using the}} new password.|$|R
30|$|For our experiments, our models {{described}} in this section are implemented in a trace-driven simulator, which we now detail further. For all experiments, each simulation is driven by a workload derived from traces that describes download and upload sessions {{of a set of}} users (Sect. 4.1 details the real traces used). The workload is composed by a series of user sessions ordered by their start time. For each session, the workload contains: a <b>user</b> <b>identifier,</b> start time, end time, number of bytes requested, {{and the size of the}} file accessed.|$|R
50|$|This is {{most often}} done by using a prefix, often one or more underscores. C and C++ are notable in this respect: C99 {{reserves}} identifiers that start with two underscores or an underscore followed by an uppercase letter, and further reserves identifiers that start with a single underscore (in the ordinary and tag spaces) for use in file scope; with C++03 further reserves identifiers that contain a double underscore anywhere - this allows {{the use of a}} double underscore as a separator (to connect <b>user</b> <b>identifiers),</b> for instance.|$|R
40|$|Session-based {{recommendations}} are highly relevant in many modern on-line services (e. g. e-commerce, video streaming) and recommendation settings. Recently, Recurrent Neural Networks {{have been shown}} to perform very well in session-based settings. While in many session-based recommendation domains <b>user</b> <b>identifiers</b> are hard to come by, there are also domains in which user profiles are readily available. We propose a seamless way to personalize RNN models with cross-session information transfer and devise a Hierarchical RNN model that relays end evolves latent hidden states of the RNNs across user sessions. Results on two industry datasets show large improvements over the session-only RNNs...|$|R
50|$|The {{following}} method {{shows how}} to use the Cache object to retrieve data from the cache. In this example, a <b>user</b> <b>identifier</b> (userid) is the key for the associated user information object. The code first attempts to get this user information from the cache using the userid key. If that does not succeed, the code retrieves the information with a database query and then stores the returned user data in the cache. The next time the same code is run, the user information will be returned from the cache rather than the database. This assumes that the cached data has not been expired or evicted.|$|R
5000|$|For {{manipulating}} values {{belonging to}} data types, operators are defined on the values. Thus, natural number addition, subtraction etc. are provided, as are Boolean operators such as equality and inequality. The language does not fix a maximum or minimum representable number or a precision for real numbers. Such constraints are defined {{where they are}} required in each model by means of data type invariants—Boolean expressions denoting conditions that must be respected by all elements of the defined type. For example, a requirement that <b>user</b> <b>identifiers</b> must be no greater than 9999 would be expressed as follows (where [...] is the “less than or equal to” Boolean operator on natural numbers): ...|$|R
30|$|At the {{application}} level, to further protect the identity matching results and individual privacy, 100 Credit anonymizes their data. When receiving any data from external sources, {{the first step}} is to convert Personal Identifiable Information, such as ID, phone number, email, etc., which can be used to identify individuals in the real world, to a random string. The random string is used internally as the <b>user’s</b> <b>identifier.</b> This step is conducted automatically, so that no employees have access to the identity information. Necessary access to personal identifiable information needs internal approval from the company’s data committee. After approval, the access process is monitored by three (rotating) members of the committee with three authentication codes for accessing the data.|$|R
30|$|If {{the mobile}} host (MH) moves during an SIP session, meanwhile, the SIP user agent (UA) sends an SIP re-INVITE request message {{to each one}} of its {{corresponding}} hosts (CHs). In this message, the MH includes its original SIP <b>user</b> <b>identifier</b> and its new IP address in order to inform the corresponding host where it wants to receive future SIP messages [1, 10]. The re-INVITE message, triggered by the SIP UA at the new location, also uses the same call identifier as in the original call setup. Moreover, the c (connection) field of the SDP header contains {{a description of the}} session in order to redirect the data traffic flow towards its new location.|$|R
40|$|In {{order to}} provide inter-domain {{authentication}} services, {{it is necessary to}} have a standardized method that domains can use to identify each other’s users. This document defines the syntax for the Network Access <b>Identifier</b> (NAI), the <b>user</b> <b>identifier</b> submitted by the client prior to accessing resources. This document is a revised version of RFC 4282. It addresses issues with international character sets and makes a number of other corrections to RFC 4282. Status of This Memo This is an Internet Standards Track document. This document {{is a product of the}} Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by th...|$|R
5000|$|Unix-like {{operating}} systems identify a user within the kernel by a value called a <b>user</b> <b>identifier,</b> often abbreviated to user ID or UID. The UID, {{along with the}} group identifier (GID) and other access control criteria, is used to determine which system resources a user can access. The password file maps textual user names to UIDs, but in the kernel, only UIDs are used. UIDs are stored in the inodes of the Unix file system, running processes, tar archives, and the now-obsolete Network Information Service. In POSIX-compliant environments, the command-line command [...] gives the current user's UID, {{as well as more}} information such as the user name, primary user group and group identifier (GID).|$|R
