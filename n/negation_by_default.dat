9|10000|Public
40|$|The aim of {{this paper}} is to provide a {{semantics}} for general logic programs (with <b>negation</b> <b>by</b> <b>default)</b> extended with explicit negation, subsuming well founded semantics [22]. The Well Founded semantics for extended logic programs (WFSX) is expressible by a default theory semantics we have devised [11]. This relationship improves the cross-fertilization between logic programs and default theories, since we generalize previous results concerning their relationship [3, 4, 7, 1, 2], and there is an increasing use of logic programming with explicit negation for nonmonotonic reasoning [7, 15, 16, 13, 23]. It also clarifies the meaning of logic programs combining both explicit negation and <b>negation</b> <b>by</b> <b>default.</b> In particular, it shows that explicit negation corresponds exactly to classical negation in the default theory, and elucidates the use of rules in logic programs. Like defaults, rules are unidirectional, so their contrapositives are not implicit; the rule connective, /, is not materi [...] ...|$|E
40|$|Well Founded Semantics for logic {{programs}} extended with eXplicit negation (WFSX) {{is characterized}} by that, in any model, whenever :a (the explicit negation of a) holds, then ¸a (the <b>negation</b> <b>by</b> <b>default</b> of a) also holds. When explicit negation is used contradiction may be present (e. g. a and :a both hold for some a) and thus no semantics {{is given to the}} program. We introduce here the notion of removing some contradictions, through identifying the set of models obtained by revising closed world assumptions. One such unique model is singled out as the contradiction free semantics (CRSX). When contradiction does not arise, the contradiction removal semantics coincides with WFSX...|$|E
40|$|A complex {{reasoning}} {{system can be}} designed as an interaction between reasoning modules. A module consists of a declaration of exported/imported predicates {{and a set of}} rules containing both <b>negation</b> <b>by</b> <b>default</b> and classical negation. A prioritized modular logic program (PMP) consists of a set of modules and a partial order < on the predicate definitions (M, p), where M is a module and p is a predicate exported by M. Because of the classical negation, conflicts may arise within and among modules. The partial order < def denotes the relative reliability of the predicate definitions contributing to the conflict. We present the reliable semantics for PMPs. The goal of the reliable semantics is to draw reliable conclusions from possibly contradictory PMPs...|$|E
40|$|ABSTRACT: This paper {{shows how}} the {{critical}} questions matching an argumentation scheme can be mod-eled in the Carneades argumentation system as three kinds of premises. Ordinary premises hold {{only if they are}} supported by sufficient arguments. Assumptions hold, <b>by</b> <b>default,</b> until they have been questioned. With exceptions the <b>negation</b> holds, <b>by</b> <b>default,</b> until the exception has been supported by sufficient arguments. By “sufficient arguments”, we mean arguments sufficient to satisfy the applicable proof standard...|$|R
40|$|Negation {{is present}} in all human {{languages}} and {{it is used to}} reverse the polarity of part of statements that are otherwise affirmative <b>by</b> <b>default.</b> A negated statement often carries positive implicit meaning, but to pinpoint the positive part from the negative part is rather difficult. This paper aims at thoroughly representing the semantics of <b>negation</b> <b>by</b> revealing implicit positive meaning. The proposed representation relies on focus of negation detection. For this, new annotation over PropBank and a learning algorithm are proposed. ...|$|R
40|$|This {{paper is}} a {{contribution}} to the foundation of <b>negation</b> <b>by</b> failure. It presents a view of <b>negation</b> <b>by</b> failure as a modal provability notion. <b>Negation</b> <b>by</b> failure is a central notion in Logic Programming and is used extensively in practice. There are various attempts at its foundations each with its own difficultie...|$|R
40|$|We {{propose a}} unifying view of {{negation}} as failure, integrity constraints, and epistemic queries in nonmonotonic reasoning. Specifically, we study {{the relationship between}} satisfiability and logical implication in nonmonotonic logics, showing that, in many nonmonotonic formalisms, it is possible and easy to reduce logical implication to satisfiability. This result not only allows for establishing new complexity results for the satisfiability problem in nonmonotonic logics, but also establishes a clear relationship between the studies on epistemic queries and integrity constraints in monotonic knowledge bases with the work on <b>negation</b> <b>by</b> <b>default</b> in nonmonotonic reasoning and logic programming. From {{the perspective of the}} design of knowledge representation systems, such a reduction allows for defining both a simple method for answering epistemic queries in knowledge bases with nonmonotonic abilities, and a procedure for identifying integrity constraints in the knowledge base, which can be employed for optimizing reasoning in such systems...|$|E
40|$|AbstractThe default {{approach}} {{to the theory of}} logic programs (and deductive databases) is based on the interpretation of <b>negation</b> <b>by</b> <b>default</b> rules. Default logic is a well-suited formalism to express the Closed World Assumption and to define the declarative semantics of stratifiable logic programs. The case of disjunctive consequences in rules is treated. General logic programs may not have a meaning with respect to default semantics. The contribution of the paper is to exhibit an interesting class of programs having a default semantics, called effectively stratifiable programs. This time, disjunctive consequences are not considered. Effective stratification is a weaker constraint than stratification, local stratification and weak stratification. Besides enlarging the class of stratifiable logic programs, the paper contributes to provide a constructive definition of well-founded models of logic programs. The class of effectively stratifiable logic programs matches the class of programs having a total well-founded model and in general, the default semantics extends the well-founded semantics...|$|E
40|$|Recent {{studies in}} nonmonotonic {{reasoning}} {{have shown that}} many of the best known nonmonotonic logics are based on the same two fundamental principles, i. e. minimal knowledge and negation as failure (or <b>negation</b> <b>by</b> <b>default).</b> In this paper we prove {{that it is possible to}} express negation as failure in terms of minimal knowledge. Specifically, we present a polynomial, non-faithful, modular embedding of Lifschitz's logic of minimal knowledge and negation as failure MKNF into Halpern and Moses' logic of minimal knowledge S 5 G. From the theoretical viewpoint, this result implies that minimal knowledge has the same expressive power of negation as failure, hence it is possible to embed all the best known propositional nonmonotonic formalisms, in particular default logic, autoepistemic logic, and circumscription, into S 5 G. From the perspective of knowledge-based systems, the proposed embedding allows in principle for realizing negation as failure in systems without a negation as failure cons [...] ...|$|E
40|$|Horn clause logic {{programming}} {{can be extended}} to include abduction with integrity constraints. In the resulting extension of {{logic programming}}, <b>negation</b> <b>by</b> failure can be simulated by making negative conditions abducible and by imposing appropriate denials and disjunctions as integrity constraints. This gives an alternative semantics for <b>negation</b> <b>by</b> failure, which generalises the stable model semantics of <b>negation</b> <b>by</b> failure. The abductive extension of logic programming extends <b>negation</b> <b>by</b> failure in three ways: (1) computation can be perfonned in alternative minimal models, (2) positive as well as negative conditions can be made abducible, and (3) other integrity constraints can also be accommodated...|$|R
5000|$|... glEnable(GL_STENCIL_TEST); // <b>by</b> <b>default</b> not enabledglStencilMask(stencilMask); // allow {{writing to}} stencil buffer, <b>by</b> <b>default</b> (0xFF) no mask.glClearStencil(clearStencilValue); // clear stencil value, <b>by</b> <b>default</b> = 0glStencilFunc(func, ref, mask); // <b>by</b> <b>default</b> GL_ALWAYS, 0, 0xFF, always pass stencil testglStencilOp(fail,zfail,zpass); // <b>by</b> <b>default</b> GL_KEEP, GL_KEEP, GL_KEEP, {{do not change}} stencil bufferglClear(GL_STENCIL_BUFFER_BIT); // clear stencil buffer, fill with (clearStencilValue & stencilMask) ...|$|R
5000|$|If {{there is}} an element [...] such that , then we may define <b>negation</b> <b>by</b> [...] and [...]|$|R
40|$|Abduction {{is a form}} of {{inference}} {{that supports}} hypothetical reasoning and has been applied to a number of domains, such as diagnosis, planning, protocol verication. Abductive Logic Programming (ALP) is the integration of abduction in logic programming. Usually, the operational semantics of an ALP language is dened as a proof procedure. The rst implementations of ALP proof-procedures were based on the meta-interpretation technique, which is exible but limits the use of the built-in predicates of logic programming systems. Another, more recent, approach exploits theoretical results on the similarity between abducibles and constraints. With this approach, which bears the advantage of an easy integration with built-in predicates and constraints, Constraint Handling Rules has been the language of choice for the implementation of abductive proof procedures. The rst CHR-based implementation mapped integrity constraints directly to CHR rules, which is an ecient solution, but prevents dened predicates from being in the body of integrity constraints and does not allow a sound treatment of <b>negation</b> <b>by</b> <b>default.</b> In this paper, we describe the CHR-based implementation of the SCIFF abductive proof-procedure, which follows a dierent approach. The SCIFF implementation maps integrity constraints to CHR constraints, and the transitions of the proof-procedure to CHR rules, making it possible to treat default negation, while retaining the other advantages of CHRbased implementations of ALP proof-procedures...|$|E
40|$|The {{representation}} {{language of}} Machine Learning {{has undergone a}} substantial evolution, starting from numerical descriptions to an attribute-value representations and finally to first order logic languages. In particular, Logic Programming has recently been studied as a representation language for learning in the research area of Inductive Logic Programming. The contribution of this thesis is twofold. First, we identify two problems of existing Inductive Logic Programming techniques: their limited ability to learn from an incomplete background knowledge {{and the use of}} a two-valued logic that does not allow to consider some pieces of information as unknown. Second, we overcome these limits by prosecuting the general trend in Machine Learning of increasing the expressiveness of the representation language. Two learning systems have been developed that represent knowledge using two extensions of Logic Programming, namely abductive logic programs and extended logic programs. Abductive logic programs allow abductive reasoning to be performed on the knowledge. When dealing with an incomplete knowledge, abductive reasoning can be used to explain an observation or a goal by making some assumptions about incompletely specified predicates. The adoption of abductive logic programs as a representation language for learning allows to learn from an incomplete background knowledge: abductive reasoning is used during learning for completing the available knowledge. The system ACL (Abductive Concept Learning) for learning abductive logic programs has been implemented and tested on a number of datasets. The experiments show that the performance of the system when learning from incomplete knowledge are superior or comparable to those of ICL-Sat, mFOIL and FOIL. Extended logic programs contain a second form of negation (called explicit negation) besides <b>negation</b> <b>by</b> <b>default.</b> They allow the adoption of a three-valued model and the representation of both the target concept and its opposite. The two-valued setting that is usually adopted in Inductive Logic Programming can be a limitation in some cases, for example {{in the case of a}} robot that autonomously explores the surrounding world and that acts on the basis of the partial knowledge it posseses. For such a robot is important to distinguish what is true from what is false and what is unknown and therefore it needs to adopt a three-valued logic. The system LIVE (Learning In a three-Valued Environment) has been implemented that is able to learn extended logic programs containing a definition for both the concept and its opposite. Moreover, the definitions learned may allow exceptions. In this case, a definition for the class of exceptions is learned and for exceptions to exceptions, if present. In this way, hierarchies of exceptions can be learned...|$|E
50|$|The monoid (Z, +, 0) of {{integers}} under addition is a reduct of {{the group}} (Z, +, &minus;, 0) of integers under addition and <b>negation,</b> obtained <b>by</b> omitting <b>negation.</b> <b>By</b> contrast, the monoid (N,+,0) of natural numbers under addition is not the reduct of any group.|$|R
50|$|Creation of padding files {{has been}} enabled <b>by</b> <b>default</b> since version 0.85, {{and as of}} version 1.36 is still enabled <b>by</b> <b>default.</b>|$|R
25|$|Java Secure Socket Extension: a Java {{implementation}} {{included in}} the Java Runtime Environment supports TLS 1.1 and 1.2 from Java 7, although is disabled <b>by</b> <b>default</b> for client, and enabled <b>by</b> <b>default</b> for server. Java 8 supports TLS 1.1 and 1.2 enabled on both the client and server <b>by</b> <b>default.</b>|$|R
50|$|Ubuntu 15.04 used systemd {{instead of}} Upstart <b>by</b> <b>default.</b> This release also {{featured}} locally integrated menus <b>by</b> <b>default,</b> replacing the previous default global menus.|$|R
5000|$|CTCP {{is enabled}} <b>by</b> <b>default</b> in {{computers}} running beta versions of Windows Server 2008 and disabled <b>by</b> <b>default</b> in computers running Windows Vista and 7.|$|R
5000|$|Ad Blocker: Content filter {{that comes}} only with EasyList enabled <b>by</b> <b>default.</b> It is also subscribed <b>by</b> <b>default</b> to the Adblock Plus Acceptable Ads Program whitelist.|$|R
5000|$|SDL {{support for}} Mir and Wayland is {{available}} from SDL 2.0.2 but it was disabled <b>by</b> <b>default.</b> Wayland and Mir support is enabled <b>by</b> <b>default</b> in SDL 2.0.4.|$|R
5000|$|HTTPS URLs {{begin with}} [...] "https://" [...] and use port 443 <b>by</b> <b>default,</b> or {{alternatively}} 8443, whereas HTTP URLs begin with [...] "http://" [...] and use port 80 <b>by</b> <b>default.</b>|$|R
5000|$|Day 1: Device {{can receive}} SMS, MMS, and e-mail but {{messages}} {{will not be}} read. Wifi (if on <b>by</b> <b>default),</b> Bluetooth (if on <b>by</b> <b>default),</b> and radio stack were also in-scope.|$|R
5000|$|WR= World Record (and <b>by</b> <b>default</b> {{also new}} European, Championships and National records for those involved); ER= European Record (and <b>by</b> <b>default</b> also new Championships and National records); CR= Championships Record ...|$|R
50|$|The {{controversy}} {{gathered around}} the system of keeping score for matches won <b>by</b> <b>default</b> as one wrestler does not appear for their scheduled fight (fusensho). At the time, {{only in the last}} two days of a tournament could a win <b>by</b> <b>default</b> be accepted, and there was no formal announcement (kachi-nanori) of the winner <b>by</b> <b>default,</b> so both wrestlers would be scored as not appearing for the match. In the following tournament in March 1928, the modern system was established where the winner <b>by</b> <b>default</b> was officially scored as a win and not a no-show, {{as it was in the}} past.|$|R
5000|$|Microsoft Windows {{operating}} systems through XP use the range 1025 - 5000 as ephemeral ports <b>by</b> <b>default.</b> [...] Windows Vista, Windows 7, and Server 2008 use the IANA range <b>by</b> <b>default.</b> Windows Server 2003 uses the range 1025 - 5000 <b>by</b> <b>default,</b> until Microsoft security update MS08-037 from 2008 is installed, after which {{it uses the}} IANA range <b>by</b> <b>default.</b> Windows Server 2008 with Exchange Server 2007 installed has a default port range of 1025 - 60000. In addition to the default range, all versions of Windows since Windows 2000 {{have the option of}} specifying a custom range anywhere within 1025 - 65535.|$|R
50|$|In the C++ language, a struct is {{identical}} to a C++ class but {{a difference in the}} default visibility exists: class members are <b>by</b> <b>default</b> private, whereas struct members are <b>by</b> <b>default</b> public.|$|R
50|$|They undergo <b>negation</b> <b>by</b> the {{addition}} of not after them. For example, one can say They cannot sing, but not *They like not to sing (again do-support is required: They dont like...).|$|R
25|$|Win by default: If for any reason, {{a wrestler}} {{is unable to}} {{continue}} competing during the match (e.g. because of injury, illness, etc.), his opponent is awarded victory <b>by</b> <b>default.</b> A wrestler can concede a win <b>by</b> <b>default</b> to his opponent by informing the referee himself of his inability to continue wrestling. The decision to concede the win <b>by</b> <b>default</b> can also {{be made by the}} wrestler's coach.|$|R
50|$|In Windows Vista, {{the content}} indexer was {{replaced}} with the Windows Search indexer which was enabled <b>by</b> <b>default.</b> Indexing Service is still included with Windows Server 2008 but is not installed or running <b>by</b> <b>default.</b>|$|R
50|$|Unlocked <b>by</b> <b>default.</b>|$|R
2500|$|Hybrid Sleep {{is enabled}} <b>by</b> <b>default</b> on desktop computers, which {{typically}} {{do not include}} an uninterruptible power supply, but is disabled <b>by</b> <b>default</b> on laptops and other mobile devices which typically carry an additional power source such as a battery.|$|R
50|$|In most countries, {{computers}} <b>by</b> <b>default</b> {{show the}} time in 24-hour notation. Most operating systems, including Microsoft Windows and Unix-like systems such as Linux and macOS, activate the 12-hour notation <b>by</b> <b>default</b> for {{a limited number of}} language and region settings.|$|R
5000|$|Hybrid Sleep {{is enabled}} <b>by</b> <b>default</b> on desktop computers, which {{typically}} {{do not include}} an uninterruptible power supply, but is disabled <b>by</b> <b>default</b> on laptops and other mobile devices which typically carry an additional power source such as a battery.|$|R
25|$|<b>By</b> <b>default,</b> {{the main}} user {{interface}} includes back, forward, refresh/cancel and menu buttons. A home button is not shown <b>by</b> <b>default,</b> {{but can be}} added through the Settings page to take the user to the new tab page or a custom home page.|$|R
50|$|A {{canonical}} account (or built-in account), in {{the context}} of computer software and systems, is an account that is included <b>by</b> <b>default</b> with a program or firmware. Such accounts usually also have a default password and may have certain access rights <b>by</b> <b>default.</b>|$|R
