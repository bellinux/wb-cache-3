202|46|Public
25|$|A <b>null</b> <b>pointer</b> is a pointer in a {{computer}} program that does not point to any object or function. In C, the integer constant 0 is converted into the <b>null</b> <b>pointer</b> at compile time when it appears in a pointer context, and so 0 is a standard way {{to refer to the}} <b>null</b> <b>pointer</b> in code. However, the internal representation of the <b>null</b> <b>pointer</b> may be any bit pattern (possibly different values for different data types).|$|E
25|$|<b>Null</b> <b>pointer</b> dereference.|$|E
25|$|First - Is the <b>null</b> <b>pointer</b> (empty list).|$|E
5000|$|Dereferencing <b>null</b> <b>pointers</b> - this is special-cased by memory {{management}} hardware ...|$|R
2500|$|Avoid {{software}} {{patterns that}} will lead to unexpected behavior (Uninitialized variable, <b>null</b> <b>pointers,</b> etc.) ...|$|R
50|$|Dereferences of <b>null</b> <b>pointers</b> lead to {{undefined}} {{values and}} usually raise an exception immediately.|$|R
25|$|This sample program {{implements}} the Sieve of Eratosthenes to {{find all}} the prime numbers that are less than 100. nil is the ALGOL 68 analogue of the <b>null</b> <b>pointer</b> in other languages. The notation x of y accesses a member x of a struct y.|$|E
25|$|New {{features}} {{provided by}} ThumbEE include automatic <b>null</b> <b>pointer</b> checks on every load and store instruction, an instruction {{to perform an}} array bounds check, and special instructions that call a handler. In addition, because it utilises Thumb-2 technology, ThumbEE provides access to registers r8-r15 (where the Jazelle/DBX Java VM state is held). Handlers are small sections of frequently called code, commonly used to implement high level languages, such as allocating memory for a new object. These changes come from repurposing a handful of opcodes, and knowing the core is in the new ThumbEE state.|$|E
2500|$|The {{simplest}} representation for {{an empty}} circular list (when {{such a thing}} makes sense) is a <b>null</b> <b>pointer,</b> indicating that the list has no nodes. [...] Without this choice, many algorithms have to test for this special case, and handle it separately. [...] By contrast, the use of null to denote an empty linear list is more natural and often creates fewer special cases.|$|E
5000|$|Avoid {{software}} {{patterns that}} will lead to unexpected behavior (Uninitialized variable, <b>null</b> <b>pointers,</b> etc.) ...|$|R
5000|$|Finally, it {{increases}} type safety and can prevent problems due to <b>null</b> <b>pointers,</b> labeled by C.A.R. Hoare—the null reference inventor—as [...] "the billion dollar mistake" ...|$|R
50|$|The Rust {{programming}} language introduces a borrow checker, pointer lifetimes, and an optimisation based around optional types for <b>null</b> <b>pointers</b> to eliminate pointer bugs, {{without resorting to}} a garbage collector.|$|R
50|$|A <b>null</b> <b>pointer</b> is a pointer in a {{computer}} program that does not point to any object or function. In C, the integer constant 0 is converted into the <b>null</b> <b>pointer</b> at compile time when it appears in a pointer context, and so 0 is a standard way {{to refer to the}} <b>null</b> <b>pointer</b> in code. However, the internal representation of the <b>null</b> <b>pointer</b> may be any bit pattern (possibly different values for different data types).|$|E
5000|$|A <b>null</b> <b>pointer</b> value {{explicitly}} {{points to}} no valid location. Dereferencing a <b>null</b> <b>pointer</b> value is undefined, often {{resulting in a}} segmentation fault. <b>Null</b> <b>pointer</b> values are useful for indicating special cases such as no [...] "next" [...] pointer in the final node of a linked list, or as an error indication from functions returning pointers. In appropriate contexts in source code, such as for assigning to a pointer variable, a <b>null</b> <b>pointer</b> constant can be written as , with or without explicit casting to a pointer type, or as the [...] macro defined by several standard headers. In conditional contexts, <b>null</b> <b>pointer</b> values evaluate to false, while all other pointer values evaluate to true.|$|E
50|$|Because a <b>null</b> <b>pointer</b> {{does not}} {{point to a}} {{meaningful}} object, an attempt to dereference (ie. access the data stored at that memory location) a <b>null</b> <b>pointer</b> usually (but not always) causes a run-time error or immediate program crash.|$|E
50|$|In fact, quite {{contrary}} to the zero page's original preferential use, some modern operating systems such as FreeBSD, Linux and Microsoft Windows actually make the zero page inaccessible to trap uses of <b>NULL</b> <b>pointers.</b> This is useful, as <b>NULL</b> <b>pointers</b> are the method used to represent {{the value of a}} reference that points to nothing. Since code operating on a reference will be written assuming it that the reference actually refers to some valid structure or value, catching the case where the reference points to nothing is of use since it is a sure sign of a bug.|$|R
50|$|The null {{coalescing}} operator replaces <b>null</b> <b>pointers</b> with a default value. The haskell equivalent {{is a way}} of extracting a {{value from}} a Maybe by supplying a default value. This is the function fromMaybe.|$|R
50|$|C/C++test {{includes}} a lightweight form of runtime error detection that {{is suitable for}} use in embedded systems, including running on a target board or host. It helps find serious runtime defects such as memory leaks, <b>null</b> <b>pointers,</b> uninitialized memory, and buffer overflows.|$|R
50|$|In {{languages}} with a tagged architecture, a possibly <b>null</b> <b>pointer</b> can {{be replaced}} with a tagged union which enforces explicit handling of the exceptional case; in fact, a possibly <b>null</b> <b>pointer</b> {{can be seen as}} a tagged pointer with a computed tag.|$|E
5000|$|Infer {{performs}} {{checks for}} <b>null</b> <b>pointer</b> exceptions, resource leaks, annotation reachability, missing lock guards, and concurrency race conditions in Android and Java code. It checks for <b>null</b> <b>pointer</b> problems, memory leaks, coding conventions and unavailable API’s in C, C++ and Objective C.|$|E
50|$|It only finds basic bugs (f.ex. <b>null</b> <b>pointer</b> dereferencing).|$|E
50|$|In {{the case}} of a perfect binary tree of height h, there are 2h+1&minus;1 nodes and 2h+1 <b>Null</b> <b>pointers</b> as {{children}} (2 for each of the 2h leaves), so short-circuiting cuts the number of function calls in half in the worst case.|$|R
5000|$|Variables {{may have}} only forward {{declaration}} and lack definition. During compilation time these are initialized by language specific rules (to undefined values, 0, <b>NULL</b> <b>pointers,</b> ...). Variables that are defined in other source/object files {{must have a}} forward declaration specified with a keyword : ...|$|R
50|$|An {{alternative}} form of adjacency matrix, which however {{requires a}} larger amount of space, replaces {{the numbers in}} each element of the matrix with pointers to edge objects (when edges are present) or <b>null</b> <b>pointers</b> (when there is no edge).It is also possible to store edge weights directly in the elements of an adjacency matrix.|$|R
5000|$|Because a {{very common}} program error is a <b>null</b> <b>pointer</b> dereference (a read or write through a <b>null</b> <b>pointer,</b> used in C to mean [...] "pointer to no object" [...] and as an error indicator), most {{operating}} systems map the null pointer's address such that accessing it causes a segmentation fault.|$|E
5000|$|Invalid {{page fault}} - {{accessing}} a pointer outside the virtual memory space. A <b>null</b> <b>pointer</b> dereference will often cause an exception or program termination in most environments, but can cause corruption in operating system kernels or systems without memory protection, or when {{use of the}} <b>null</b> <b>pointer</b> involves a large or negative offset.|$|E
5000|$|For {{backwards}} compatibility reasons, [...] remains a valid <b>null</b> <b>pointer</b> constant.|$|E
40|$|Abstract Programs {{sometimes}} crash due to unusable values, for ex-ample, when Java and C # programs dereference <b>null</b> <b>pointers</b> {{and when}} C and C++ programs use undefined values toaffect program behavior. A stack trace produced {{on such a}} crash identifies {{the effect of the}} unusable value, not its cause,and is often not much help to the programmer...|$|R
5000|$|Groovy {{features}} {{not available}} in Java include both static and dynamic typing (with the keyword [...] ), operator overloading, native syntax for lists and associative arrays (maps), native support for regular expressions, polymorphic iteration, expressions embedded inside strings, added helper methods, and the safe navigation operator [...] to check automatically for <b>null</b> <b>pointers</b> (for example, , or [...] ).|$|R
50|$|In {{software}} testing, {{error guessing}} {{is a test}} method in which test cases used to find bugs in programs are established based on experience in prior testing. The scope of test cases usually rely on the software tester involved, who uses past experience and intuition to determine what situations commonly cause software failure, or may cause errors to appear. Typical errors include divide by zero, <b>null</b> <b>pointers,</b> or invalid parameters.|$|R
5000|$|Kernel mode <b>null</b> <b>pointer</b> dereference exploit {{affecting}} FreeBSD 7.0 to 7.2.|$|E
5000|$|In C, the {{behavior}} of dereferencing a <b>null</b> <b>pointer</b> is undefined. Many implementations cause such code to result in the program being halted with a segmentation fault, because the <b>null</b> <b>pointer</b> representation is chosen to be an address that is never allocated by the system for storing objects. However, this behavior is not universal.|$|E
5000|$|<b>Null</b> <b>pointer</b> for {{indicating}} {{the end of}} a linked list or a tree.|$|E
5000|$|A {{straightforward}} {{example is}} shown below:{ char *dp = NULL; /* .../ { char c; dp = &c; } [...] /* c {{falls out of}} scope */ /* dp is now a dangling pointer */}If the operating system is able to detect run-time references to <b>null</b> <b>pointers,</b> {{a solution to the}} above is to assign 0 (null) to dp immediately before the inner block is exited. Another solution would be to somehow guarantee dp is not used again without further initialization.|$|R
50|$|In such statically typed {{languages}} as C(C++) {{there is}} no specific notion of a value undefined at runtime. Arithmetically undefined expressions invoke exceptions and crash the program, if uncaught. Undefined (means, unpredictable) data in C and similar languages may appear in poorly designed programs or {{as a result of}} an unexpected fault, and represent a severe danger, particularly pointers to deallocated memory and <b>null</b> <b>pointers</b> to arrays or structures. Even an attempt to read a value, which a garbage pointer refers to, can crash a program.|$|R
2500|$|Apple {{intended}} Swift {{to support}} many core concepts associated with Objective-C, notably dynamic dispatch, widespread late binding, extensible programming and similar features, but [...] "safer" [...] (easier to catch software bugs); Swift has features addressing some common programming errors like <b>null</b> <b>pointers</b> and provides syntactic sugar to help avoid the pyramid of doom. Swift supports {{the concept of}} protocol extensibility, an extensibility system {{that can be applied}} to types, structs and classes, which Apple promotes as a real change in programming paradigms they term [...] "protocol-oriented programming" [...] (similar to traits).|$|R
