11|33|Public
2500|$|X# {{supports}} {{the definition of}} named constants which are declared outside of functions. Defining a <b>numeric</b> <b>constant</b> is similar to C++ - for instance, [...] Referencing the constant elsewhere requires a # before the name - [...] "#i", for instance.|$|E
5000|$|Each line names an {{application}} program, {{and gives a}} hexadecimal <b>numeric</b> <b>constant</b> to associate with that program. The hexadecimal <b>numeric</b> <b>constant</b> encodes the compatibility bitflags for that particular application, that Windows applies when the application is executed. Make Compatible merely provides a graphical user interface for editing these flags in an easy way, rather than editing [...] manually, with a text editor. It allows one to set and unset individual flags {{without having to know}} their numeric values.|$|E
5000|$|Each value {{can store}} {{arbitrary}} data with variable length and encoding, {{but which is}} associated with a symbolic type (defined as a <b>numeric</b> <b>constant)</b> defining how to parse this data. The standard types are: ...|$|E
5000|$|... 0x, the prefix for {{hexadecimal}} <b>numeric</b> <b>constants</b> in computing ...|$|R
40|$|Genetic {{programming}} suffers {{difficulty in}} discovering useful <b>numeric</b> <b>constants</b> for the terminal nodes of its sexpression trees. In earlier work we postulated {{a solution to}} this problem called numeric mutation. Here, we provide empirical evidence to demonstrate that this method provides a statistically significant improvement in GP system performance on a variety of problems. 1 Introduction A weakness of genetic programming (GP) is the difficulty it suffers in discovering useful <b>numeric</b> <b>constants</b> for the terminal nodes of the s-expression trees. At first glance, this weakness is somewhat surprising: Genetic Algorithms, from which GP is derived, are highly suited to the task of optimizing numeric parameters. GP's difficulty with <b>numeric</b> <b>constants</b> derives from their representation as tree nodes, while the reproduction operations (including mating and mutation) affect only the structure of the trees, not the composition of the nodes. Therefore the individual <b>numeric</b> <b>constants</b> are not af [...] ...|$|R
5000|$|... where A and B {{are certain}} <b>numeric</b> <b>constants.</b> If L is {{sufficiently}} {{far from the}} mean, i.e. , then: ...|$|R
50|$|Symbolic {{signal names}} are used because signal numbers can vary across platforms, but XSI-conformant systems allow {{the use of}} the <b>numeric</b> <b>constant</b> 1 to be used to {{indicate}} a SIGHUP, which the vast majority of systems in fact use.|$|E
5000|$|X# {{supports}} {{the definition of}} named constants which are declared outside of functions. Defining a <b>numeric</b> <b>constant</b> is similar to C++ - for instance, const i = 0. Referencing the constant elsewhere requires a [...] before the name - , for instance.|$|E
5000|$|Emitters were sets of 12 exit hubs that {{automatically}} generated a pulse at each specified {{time in the}} card cycle. The twelve exit hubs were wired to contacts on a rotary switch that turned with the card cycle. Thus wiring the 6 exit from an emitter to a punch magnet entry would cause a 6 to be punched at that position. Emitters {{might be used to}} put a <b>numeric</b> <b>constant</b> value, say a date, on every card. Alphanumeric constant data could be created by carefully combining digit and zone pulses. Later machines, such as the 407 also had a complete set of alphanumeric emitters that only required one wire to use.|$|E
50|$|The {{factorial}} example {{above is}} one example of compile-time code optimization in that all factorials used by the program are pre-compiled and injected as <b>numeric</b> <b>constants</b> at compilation, saving both run-time overhead and memory footprint. It is, however, a relatively minor optimization.|$|R
40|$|Genetic {{programming}} is relatively poor at discovering useful <b>numeric</b> <b>constants</b> for the terminal nodes of its s-expression trees. In this paper we outline an adaptation to genetic programming, called numeric mutation. ~,Ve provide empirical evidence and analysis that demon-strate that numeric mutation makes a statistically sig-nificant increase in genetic programming’s performance for symbolic regression problems...|$|R
40|$|Genetic {{programming}} suffers {{difficulty in}} discovering useful <b>numeric</b> <b>constants</b> for the terminal nodes of its sexpression trees. In earlier work we postulated {{a solution to}} this problem called numeric mutation. Here, we provide empirical evidence to demonstrate that this method provides a statistically significant improvement in GP system performance on a variety of problems...|$|R
40|$|We {{consider}} an asymmetric d-dimensional, d > 1, Ising model with the pair interaction I {{in one direction}} dierent from the pair interaction J in all other directions. We show that for any inverse temperature the system is in the gas phase as soon as jJ j 0 being a small <b>numeric</b> <b>constant...</b>|$|E
40|$|This paper {{proposes a}} Genetic Programming based {{algorithm}} {{that can be}} used to design optimal controllers. The pro posed algorithm will be named a Multiple Basis Function Genetic Programming (MBFGP). Herein, the main ideas concerning the initial population, the tree structure, genetic operations, and other proposed non-genetic operations are discussed in details. An optimization algorithm called <b>numeric</b> <b>constant</b> mutation is embedded to strengthen the search for the optimal solutions. The results of solving the optimal control for linear as well as nonlinear systems show the feasibility and effectiveness of the proposed MBFGP as compared to the optimal solutions which are based on numeri cal methods. Furthermore, this algorithm enriches the set of suboptimal state feedback controllers to include controllers that have product time-state terms. </p...|$|E
40|$|Introduction Let x = (x 1; x 2; ΔΔΔ; x n) be a vector of real or complex numbers. x is said {{to possess}} an integer {{relation}} if there exist integers a i, not all zero, such that a 1 x 1 + a 2 x 2 + ΔΔΔ + a n x n = 0 By an integer relation algorithm, we mean a practical computational scheme that can recover the vector of integers a i, if it exists, or can produce bounds within which no integer relation exists. As we shall see, integer relation algorithms {{have a variety of}} interesting applications, including the recognition of a <b>numeric</b> <b>constant</b> in terms of the mathematical formula that it satisfies. The problem of finding integer relations is not new. I...|$|E
40|$|Abstract. It is {{well known}} that modelchecking and satisfiability of Linear Temporal Logic (LTL) are Pspace-complete. Wolper showed that with grammar operators, this result can be {{extended}} to increase the expressiveness of the logic to all regular languages. Other ways of extending the expressiveness of LTL using modular and group modalities have been explored by Baziramwabo, McKenzie and Thérien, which are expressively complete for regular languages recognized by solvable monoids and for all regular languages, respectively. In all the papers mentioned, the <b>numeric</b> <b>constants</b> used in the modalities are in unary notation. We show that in some cases (such as the modular and symmetric group modalities and for threshold counting) we can use <b>numeric</b> <b>constants</b> in binary notation, and still maintain the Pspace upper bound. Adding modulo counting to LTL[F] (with just the unary future modality) already makes the logic Pspace-hard. We also consider a restricted logic which allows only the modulo counting of length {{from the beginning of the}} word. Its satisfiability is Σ P 3 -complete. ...|$|R
2500|$|... nix (Unix and related) shells, AT {{assembly}} language and likewise the C programming language, {{which was designed}} for Unix (and the syntactic descendants of C – including C++, C#, D, Java, JavaScript, Python and Windows PowerShell) use the prefix 0x for <b>numeric</b> <b>constants</b> represented in hex: 0x5A3. Character and string constants may express character codes in hexadecimal with the prefix \x followed by two hex digits: '\x1B' represents the Esc control character; [...] "\x1B ...|$|R
40|$|Abstract. neural {{networks}} solving approximation problem. It {{is based on}} two hierarchical evolu-tionary algorithms with multiobjective Pareto optimisation. The lower level algorithm searches for rules that are optimised by the upper level algorithm. The conclusion of the rule {{takes the form of}} a tree whose inner nodes contain functions and operators, and leaves—identifiers of attributes and <b>numeric</b> <b>constants.</b> The details referring to the rules encoding, genetic operators and fitness function are described. Some preliminary results of experimental studies are presented, as well. ...|$|R
40|$|In {{this paper}} we {{describe}} some novel applications of high performance computing in a discipline {{now known as}} "experimental mathematics. " The paper reviews some recent published work, and then presents some new results {{that have not yet}} appeared in the literature. A key technique inovlved in this research is the PSLQ integer relation algorithm (recently named one of ten "algorithms of the century" by Computing in Science and Engineering). This algorithm permits one to recognize a <b>numeric</b> <b>constant</b> in terms of the formula that it satisfies. We present a variant of PSLQ that is well-suited for parallel computation, and give several examples of new mathematical results that we have found using it. Two of these computations were performed on highly parallel computers, since they are not feasible on conventional systems. We also describe a new software package for performing arbitrary precision arithmetic, which is required in this research...|$|E
40|$|The Disjunctive Temporal Problem (DTP) {{involves}} {{conjunction of}} DTP constraints, each DTP constraint being a disjunction of difference {{constraints of the}} form x − y ≤ c, where x and y range over a domain of interpretation, and c is a <b>numeric</b> <b>constant.</b> The DTP is recognized to be an expressive framework for constraints modeling and processing. The addition of preferences, {{in the form of}} weights associated to difference constraints for their satisfaction, needs methods for aggregating preferences among and within DTP constraints to compute meaningful and high quality solutions, while further enhancing DTP expressivity and applicability. In this paper we consider an utilitarian aggregation of DTP constraints weights, and a prominent semantic for aggregating such weights from its difference constraints weights that considers the maximum among the weights associated to satisfied difference constraints in it. We present a novel approach that reduces the problem to Maximum Satisfiability of DTPs (Max-DTPs). In this way, we can employ off-the-shelf Max-DTP solvers with different solution methods, ranging from Satisfiability Modulo Theories (SMT), to interval-based and Boolean optimizationbased solvers. We then compare the performance of our approach with different back-end solvers on both randomly generated and real-world benchmarks, in comparison with Maxilitis, the best solver that can deal with DTPs with preferences using the aggregation methods considered. Results show that the Yices SMT solver is the best, and that Yices and the TSAT# * This paper is an extended and revised versio...|$|E
50|$|Second-generation {{languages}} {{provide one}} abstraction level {{on top of}} the machine code. In the early days of coding on computers like the TX-0 and PDP-1, the first thing MIT hackers did was write assemblers.Assembly language has little semantics or formal specification, being only a mapping of human-readable symbols, including symbolic addresses, to opcodes, addresses, <b>numeric</b> <b>constants,</b> strings and so on. Typically, one machine instruction is represented as one line of assembly code. Assemblers produce object files that can link with other object files or be loaded on their own.|$|R
5000|$|Constant/function dualism: The x1 through x5 {{parameters}} of A may be <b>numeric</b> <b>constants</b> or {{references to the}} function B — the x4+x5 expression {{must be prepared to}} handle both cases as if the formal parameters x4 and x5 had been replaced by the corresponding actual parameter (call by name). This is probably more of a problem in statically typed languages than in dynamically typed languages, but the standard work-around is to reinterpret the constants 1, 0, and −1 in the main call to A as functions without arguments that return these values.|$|R
50|$|It is {{generally}} not safe to assume the size of any datatype. For example, even though most implementations of C and C++ on 32-bit systems define type int to be four octets, this size may change when code is ported to a different system, breaking the code. The exception to this is the data type char, which always has the size 1 in any standards-compliant C implementation. In addition, it is frequently difficult to predict the sizes of compound datatypes such as a struct or union, due to padding. The use of sizeof enhances readability, since it avoids unnamed <b>numeric</b> <b>constants</b> (magic numbers).|$|R
50|$|In {{the image}} above we see three {{free-floating}} parameters that are {{hooked up to}} a subtraction component. The two yellow boxes on the left both define a set of <b>numeric</b> <b>constants.</b> The top-most panel contains four integers (6, 7, 8 and 12) while the bottom-most panel contains only a single value. These floating parameters supply the subtraction component with input data, which results in four output values (6-5=1, 7-5=2, 8-5=3 and 12-5=7). The same result can be achieved using textual expressions and an evaluator component. In this fashion Grasshopper allows users to combine both visual and textual programming within the same environment.|$|R
5000|$|Numbers (<b>numeric</b> <b>constants)</b> do {{not require}} quotation. Perl will convert numbers into strings and vice versa {{depending}} on the context in which they are used. When strings are converted into numbers, trailing non-numeric parts of the strings are discarded. If no leading part of a string is numeric, the string will be converted to the number 0. In the following example, the strings [...] and [...] are treated as numbers. This code prints the number '5'. The values of the variables remain the same. Note that in Perl, [...] is always the numeric addition operator. The string concatenation operator is the period.|$|R
50|$|Alphanumeric display also greatly eased editing programs, as {{functions}} were {{spelled out}} in full. Numeric-only calculators displayed programming steps as a list of numbers, each number generally mapped to a key on the keyboard, often via row and column coordinates. Encoding functions to the corresponding numeric codes, and vice versa, was left to the user, having to look up the function - code combinations in a reference guide. The busy programmer quickly learned most of the codes, but having to learn the codes intimidated the beginners. In addition to this, the user had to mentally keep function codes separate from <b>numeric</b> <b>constants</b> in the program listing.|$|R
5000|$|Euler {{employs a}} general type concept. In Euler, arrays, procedures, and {{switches}} are not quantities which are declared and named by identifiers: {{they are not}} (as opposed to ALGOL) quantities which {{are on the same}} level as variables, rather, these quantities are on the level of <b>numeric</b> and boolean <b>constants.</b> Thus, besides the traditional <b>numeric</b> and logical <b>constants,</b> Euler introduces the following additional types: ...|$|R
40|$|This paper {{presents}} QoS Explorer, {{an interactive}} tool {{we have developed}} which predicts quality of service (QoS) of a workflow from the QoS characteristics of its constituents, even when the relationships involved are complex. This facilitates design and instantiation of workflows to satisfy QoS constraints, as it enables the user to discover and focus effort on the aspects of a workflow which most affect their primary QoS concerns, thus improving efficiency of workflow development. Further, the underlying model we use is more sophisticated than those of similar recent work [13, 2, 18], and includes processing of entire statistical distributions and probabilistic states (instead of the simple <b>numeric</b> <b>constants</b> used elsewhere) to model such nonconstant variables as execution time. ...|$|R
40|$|We {{compared}} a turbidimetric electrophoretic method (Lipidophor) for lipoprotein quantification {{with the}} stan-dardized Lipid Research Clinics (LRC) method. In the Lip-idophor procedure, major lipoproteins {{are separated by}} electrophoresis on agarose gels, precipitated on the gels with phosphotungstate-Mg 2 reagent, and the resulting turbidity is measured densitometrically. Measurements of relative turbidity were converted into lipoprotein choles-terol values {{by the use of}} <b>numeric</b> <b>constants</b> provided by the manufacturer. Among-day CVs (n = 46) for the Lipi-dophor method were 6. 0 %, 3. 6 %, and 9. 9 % for choles-terol in the alpha-, beta-, and pre-beta lipoproteins, re-spectively. The Lipidophor alpha-cholesterol was signifi-cantly lower (n = 171 specimens) than the LRC high-density lipoprotein (HDL) cholesterol (514 vs 586 mg/L) ...|$|R
5000|$|...nix (Unix and related) shells, AT&T {{assembly}} language and likewise the C programming language, {{which was designed}} for Unix (and the syntactic descendants of C - including C++, C#, D, Java, JavaScript, Python and Windows PowerShell) use the prefix [...] for <b>numeric</b> <b>constants</b> represented in hex: [...] Character and string constants may express character codes in hexadecimal with the prefix [...] followed by two hex digits: [...] represents the Esc control character; [...] is a string containing 11 characters (plus a trailing NUL to {{mark the end of}} the string) with two embedded Esc characters. To output an integer as hexadecimal with the printf function family, the format conversion code [...] or [...] is used.|$|R
40|$|Gene Expression Programming (GEP) {{is a new}} {{evolutionary}} algorithm that incorporates both the idea of simple, linear chromosomes of fixed length used in Genetic Algorithms (GAs) {{and the structure of}} different sizes and shapes used in Genetic Programming (GP). As with other genetic programming algorithms, GEP has difficulty finding appropriate <b>numeric</b> <b>constants</b> for terminal nodes in the expression trees. In this paper, we describe a new approach of constant generation using Differential Evolution (DE), which is a simple real-valued GA that has proven to be robust and efficient on parameter optimization problems. Our experimental results on two symbolic regression problems show that the approach significantly improves the performance of the GEP algorithm. The proposed approach can be easily extended to other Genetic Programming variants...|$|R
5000|$|Control code 0x0E {{is used to}} {{indicate}} that a floating-point number follows, to accelerate text processing. In a Sinclair BASIC program <b>numeric</b> <b>constants</b> are stored as ASCII followed by a 0x0E byte and a 5-byte binary floating point representation. When listing a BASIC program only the ASCII part is used but at runtime only the binary representation is used. Some Spectrum programs exploited this to obfuscate numbers, while others did so to save memory. For example, a BASIC line displayed as [...] could contain the ASCII characters for digits 1 and 0 followed by a 0x0E byte and the floating-point representation of 100 instead of 10. Anyone listing that program would see the number 10, but when executed the program would jump to line 100.|$|R
40|$|Abstract. Gene Expression Programming (GEP) {{is a new}} {{technique}} of Genetic Programming (GP) that implements a linear genotype representation. It uses fixed-length chromosomes to represent expression trees of different shapes and sizes, which results in unconstrained search of the genome space while still ensuring validity of the program’s output. However, GEP has some difficulty in discovering suitable function structures because the genetic operators are more disruptive than traditional tree-based GP. One possible remedy is to specifically assist the algorithm in discovering useful <b>numeric</b> <b>constants.</b> In this paper, the effectiveness of several constant creation techniques for GEP has been investigated through two symbolic regression benchmark problems. Our experimental results show that constant creation methods applied to the whole population for selected generations perform better than methods that are applied only to the best individuals. The proposed tune-up process for the entire population can significantly improve the average fitness of the best solutions. ...|$|R
40|$|A {{mathematical}} model based on polyhedra (the so-called “polyhedron model”) {{serves as a}} foundation for model based loop program transformation like automatic parallelization. One of the restrictions present in the current polyhedron model is the requirement that the coefficients of variables must be <b>numeric</b> <b>constants.</b> This has been hindering some recent developments which require parametric coefficients of variables. We show how such nonlinear parameters can be introduced in the polyhedron model, using quantifier elimination in the real numbers as our main mathematical tool. We describe two approaches of obtaining algorithms for the generalized model. First, we point out how existing algorithms can be implemented for the generalized model. Quantifier elimination is employed in this approach to simplify arising case distinctions. We give Fourier-Motzkin elimination and the Simplex algorithm as examples of this approach. Second, we show how quantifier elimination can be used to solve some problems directly, e. g., by computing lexicographic maxima. We also demonstrate how to apply our methods to the frequently appearing case of tiling an index space with parametric tile size, and we present some performance results of the generalized algorithms we have implemented. ...|$|R
40|$|Initially, {{function}} using {{genetic programming}} (GP) is investigated through symbolic regression for data mining applications. Various kinds of functions are investigated including function learning tasks {{as well as}} Boolean functions learning. The objective of the initial investigation is to review how GP is applied to function learning tasks. The drawbacks of this method are identified. Hybrid GP technique based on genetic algorithm-program (GA-P) for function learning tasks with variables and constants is investigated. This hybrid GP technique is further expanded to new hybrid GA SA-p. The new hybrid GA SA-P combining genetic algorithms (GA) and simulated annealing (SA) is proposed for function learning tasks with <b>numeric</b> <b>constants.</b> The convergence bahaviour will be compared with existing GP and genetic algorithm-program (GP-P). Application of Gp is extended to discover interesting rules among data sets. Given a set of data and appropriate parameter settings, GP is used to discover set of rules that describes the relationships that exist among the data. Finally, GP is investigated as decision tree classifier for classifying binary and multiclass classification problems. The simulation results will be compared with C 4. 5 decision tree algorithm...|$|R
40|$|Abstract. The {{concept of}} ε-randomizing quantum {{channels}} {{has been introduced}} by Hayden, Leung, Shor and Winter in connection with approximately encrypting quantum states. They proved using a discretization argument that sets of roughly dlog d random unitary operators provide examples of such channels on C d. We show that a simple trick improves {{the efficiency of the}} argument and reduces the number of unitary operators to roughly d. Since our argument is a minor modification of the original proof, we systematically refer the reader to [1] for introduction, background and applications of the notion of randomizing states. Notation. On the space B(C d) of d × d complex matrices we consider the trace class norm ‖ · ‖ 1 and the operator norm ‖ · ‖∞. Let also D(C d) be the convex set of mixed states (=positive elements of B(C d) with trace 1). The extreme points of D(C d) are pure states. We denote by C and c absolute <b>numeric</b> <b>constants.</b> Definition. A quantum channel (= completely positive trace-preserving linear map) R: B(Cd) → B(Cd) is said to be ε-randomizing if for every state ϕ ∈ D(Cd) ...|$|R
