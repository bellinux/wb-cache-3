47|115|Public
50|$|TMI {{implemented}} the first InterMUD communications network, when MudOS added <b>network</b> <b>socket</b> support in 1992.|$|E
5000|$|The [...] option spawns the {{executable}} {{with its}} {{input and output}} redirected via <b>network</b> <b>socket.</b>|$|E
50|$|In {{computer}} operating systems, {{a stream}} socket {{is a type}} of interprocess communications socket or <b>network</b> <b>socket</b> which provides a connection-oriented, sequenced, and unique flow of data without record boundaries, with well-defined mechanisms for creating and destroying connections and for detecting errors.|$|E
5000|$|<b>Network</b> <b>sockets,</b> {{including}} TCP sockets in ESTABLISHED state (see below) ...|$|R
5000|$|Network - TCP and UDP <b>network</b> <b>sockets,</b> data {{encapsulation}} facilities, HTTP and FTP classes ...|$|R
50|$|The {{operating}} systems the daemons can run on without emulation; also supported I/O facilities for <b>network</b> <b>sockets</b> (see IRCd for further information).|$|R
50|$|Written in C and Lisp, it runs on {{most common}} {{operating}} systems. OpenLisp is designated an ISLISP implementation, but also contains many Common Lisp-compatible extensions (hashtable, readtable, package, defstruct, sequences, rational numbers) {{as well as}} other libraries (<b>network</b> <b>socket,</b> regular expression, XML, Posix, SQL, LDAP).|$|E
5000|$|The [...] {{class is}} a file {{descriptor}} {{that represents a}} source or sink (destination) of bytes. Typically this is a file, but {{can also be a}} console or <b>network</b> <b>socket.</b> [...] objects are used to create [...] streams. They are obtained from [...] streams and [...] sockets and datagram sockets.|$|E
5000|$|Transmission Control Protocol (TCP), where a {{reliable}} virtual circuit is established {{on top of}} the underlying unreliable and connectionless IP protocol. The virtual circuit is identified by the source and destination <b>network</b> <b>socket</b> address pair, i.e. the sender and receiver IP address and port number. Guaranteed QoS is not provided.|$|E
5000|$|FastCGI can be {{implemented}} in any language that supports <b>network</b> <b>sockets.</b> (Since [...] "FastCGI is a protocol, not an implementation," [...] it is not tightly bound to any language at all.) APIs exist for: ...|$|R
50|$|Neither the OSI Reference Model nor OSI {{protocols}} {{specify any}} programming interfaces, other than deliberately abstract service specifications. Protocol specifications precisely define the interfaces between different computers, but the software interfaces inside computers, known as <b>network</b> <b>sockets</b> are implementation-specific.|$|R
5000|$|... {{integrated}} into <b>network</b> wall <b>sockets,</b> for permanent installations.|$|R
50|$|A <b>network</b> <b>socket</b> is an {{internal}} endpoint for sending or receiving data {{at a single}} node in a computer network. Concretely, it is a representation of this endpoint in networking software (protocol stack), such as an entry in a table (listing communication protocol, destination, status, etc.), and {{is a form of}} system resource.|$|E
5000|$|OpenLisp can {{interact}} with modules written in C using FFI, ISLISP streams are extended to support <b>Network</b> <b>socket</b> ( [...] directory includes samples for Http, Json, Pop3, Smtp, Telnet, Rss), a simplified XML reader can convert XML to Lisp. A basic SQL module {{can be used}} with MySQL, Odbc, SQLite, PostgreSQL. A CSV module can read and write CSV files.|$|E
50|$|Load {{balancing}} {{differs from}} channel bonding in that load balancing divides traffic between network interfaces on a <b>network</b> <b>socket</b> (OSI model layer 4) basis, while channel bonding implies {{a division of}} traffic between physical interfaces at a lower level, either per packet (OSI model Layer 3) or on a data link (OSI model Layer 2) basis with a protocol like shortest path bridging.|$|E
40|$|This paper {{describes}} {{the design and}} implementation of Lightweight Adaptive <b>Network</b> <b>Sockets</b> (LANS) for accessing services in such a dynamically changing networked environment. A LANS socket takes a high-level description of a service and opportunistically connects to the best provider of the service in the changing environment of the applicatio...|$|R
5000|$|On Unix {{and related}} systems {{based on the}} C language, a stream is a source or sink of data, usually {{individual}} bytes or characters. Streams are an abstraction used when reading or writing files, or communicating over <b>network</b> <b>sockets.</b> The standard streams are three streams made available to all programs.|$|R
50|$|The LSP {{does not}} make any {{provisions}} about how requests, responses and notifications are transferred between client and server. For example, client and server could be components within the same process exchanging JSON strings via method calls. They could also be different processes on the same or on different machines communication via <b>network</b> <b>sockets.</b>|$|R
50|$|Interconnect {{is divided}} into two layers, namely High Interconnect (H_IN) and Low Interconnect (L_IN). The former {{provides}} means for service activation and deactivation as well as service and stream accesses. Low Interconnect provides <b>network</b> <b>socket</b> interface with uniform addressing mechanism. L_IN internally can be divided into transport network independent and dependent parts. MIPI Alliance originated solutions are expected to be key enablers for wide use of NoTA.|$|E
50|$|In {{computer}} operating systems, a datagram socket {{is a type}} of interprocess {{communications socket}} or <b>network</b> <b>socket</b> which provides a connectionless point for sending or receiving data packets. Each packet sent or received on a datagram socket is individually addressed and routed. Order and reliability are not guaranteed with datagram sockets, so multiple packets sent from one machine or process to another may arrive in any order or might not arrive at all.|$|E
5000|$|MudOS {{is a major}} {{family of}} LPMud server software, {{implementing}} its own variant of the LPC programming language. [...] It first came into being on February 18, 1992. [...] It pioneered important technical innovations in MUDs, including the <b>network</b> <b>socket</b> support that made InterMUD communications possible and LPC-to-C compilation. [...] Its name reflects its focus on separation of concerns between game driver and mudlib. FluffOS is Discworld MUDs fork of MudOS, and still being developed.|$|E
50|$|SCM {{includes}} Hobbit, the Scheme-to-C compiler originally {{written by}} Tanel Tammet.Hobbit generates C files whose binaries can be dynamically or statically linked with an SCM executable.SCM includes linkable modules for SLIB features like sequence comparison, arrays, records, and byte-number conversions. SCM also includes modules for POSIX system calls and <b>network</b> <b>sockets,</b> readline, curses, and Xlib.|$|R
5000|$|On Unix {{operating}} systems, {{two other}} vectored call interfaces are popular: the [...] ("file control") system call configures open files, {{and is used}} in situations such as enabling non-blocking I/O; and the [...] ("set socket option") system call configures open <b>network</b> <b>sockets,</b> a facility used to configure the [...] packet firewall on BSD Unix systems.|$|R
30|$|Social network {{relationships}} (friendship, group, ownership, etc.) are {{persisted in}} the Elgg back-end database. The execution history of deployments of application models and {{the description of}} those models is stored in the CAMEL information repository, which is implemented as an Eclipse CDO server. The exchange of information between the Elgg and CDO servers is implemented over <b>network</b> <b>sockets.</b>|$|R
50|$|ROM-DOS (sometimes called Datalight DOS) was {{introduced}} in 1989 as an MS-DOS compatible operating system designed for embedded systems. It includes backward compatibility build options allowing compatibility with specific versions of MS-DOS (e.g., DOS 5.01). ROM-DOS 7.1 added support for FAT32 and long file names. ROM-DOS includes a compact TCP/IP stack; and SOCKETS, a <b>network</b> <b>socket</b> API and connectivity package, is available as an optional add-on for ROM-DOS. The SDK comes with Borland C/C++ and Turbo Assembler.|$|E
5000|$|In Unix {{and related}} {{computer}} operating systems, a file descriptor (FD, less frequently fildes) is an abstract indicator (handle) used to access a file or other input/output resource, {{such as a}} pipe or <b>network</b> <b>socket.</b> File descriptors form part of the POSIX application programming interface. A file descriptor is a non-negative integer, generally represented in the C programming language as the type [...] (negative values being reserved to indicate [...] "no value" [...] or an error condition).|$|E
50|$|The {{transport}} layer {{is responsible for}} delivering data to the appropriate application process on the host computers. This involves statistical multiplexing of data from different application processes, i.e. forming data segments, and adding source and destination port numbers in the header of each {{transport layer}} data segment. Together with the source and destination IP address, the port numbers constitutes a <b>network</b> <b>socket,</b> i.e. an identification address of the process-to-process communication. In the OSI model, this function {{is supported by the}} session layer.|$|E
50|$|Open {{files in}} the system include disk files, named pipes, <b>network</b> <b>sockets</b> and devices opened by all processes. One use for this command is when a disk cannot be {{unmounted}} because (unspecified) files are in use. The listing of open files can be consulted (suitably filtered if necessary) to identify the process that is using the files.|$|R
50|$|WindowsSCOPE shows Processes, DLLs, {{and drivers}} running the {{computer}} {{at the time}} of the memory snapshot as well as open <b>network</b> <b>sockets,</b> file handles, and registry key handles. It also provides disassembly and control flow graphing for executable code. WindowsSCOPE Live is a version of the tool that allows analysis to be performed from a mobile device.|$|R
40|$|The {{objective}} of this thesis {{was to develop a}} prototype which avoids the collision in an indoor and outdoor environment and establish communication between the swarm of unmanned aerial vehicles(UAVs). This thesis introduces the collision sensing, detection, and avoidance system using an ultrasonic sensor, communication between the swarm of UAVs was established using APC 220 telemeters and <b>network</b> <b>sockets</b> embedded in Raspberry Pi 3. Several basic theories of the swarm of UAVs, collision avoidance methods and its effects have been studied and explained. We have used carrier sense multiple access to avoid the interference between the sensors and used different measurement cycles. We have also presented relation between a number of collisions avoided and energy consumption of the drone. Unique ID for drones has been created using <b>network</b> <b>sockets</b> to distribute the task, notify the addition of drones from same or different networks. All the experiments were carried out in an indoor environment...|$|R
5000|$|Trust {{boundary}} {{is a term}} {{in computer}} science and security used to describe a boundary where program data or execution changes its level of [...] "trust". The term refers to any distinct boundary within which a system trusts all sub-systems (including data). An example of an execution trust boundary would be where an application attains an increased privilege level (such as root). A data trust boundary is a point where data comes from an untrusted source. For example, user input or a <b>network</b> <b>socket</b> ...|$|E
50|$|Due to its design, kGraft {{does not}} {{introduce}} additional latency while applying hot patches. As the downside, original versions of patched kernel functions {{may be required}} to be maintained for extended periods of time in case there are processes that remain for too long within the kernel space; for example, a process may wait for I/O on a <b>network</b> <b>socket.</b> Also, as both original and patched versions of functions are allowed to be executed in parallel, troubles may arise if they use kernel's internal data structures in different ways.|$|E
50|$|Channel bonding is an {{arrangement}} of communications links in which two or more links are combined for redundancy or increased throughput. Examples include links associated with network interfaces on a host computer, or downstream and upstream channels within a DOCSIS cable modem connection. Channel bonding is differentiated from load balancing in that load balancing divides traffic between network interfaces on per <b>network</b> <b>socket</b> (OSI model layer 4) basis, while channel bonding implies a division of traffic between physical interfaces at a lower level, either per packet (OSI model Layer 3) or a data link (OSI model Layer 2) basis.|$|E
50|$|Expansion: One Eurocard-sized Podule {{support in}} common with Archimedes-series machines. One {{internal}} <b>network</b> card <b>socket.</b>|$|R
50|$|Common {{resource}} handles are file descriptors, <b>network</b> <b>sockets,</b> database connections, process identifiers (PIDs), and job IDs. Process IDs and job IDs are explicitly visible integers, while file descriptors and sockets (which {{are often}} implemented {{as a form}} of file descriptor) are represented as integers, but are typically considered opaque. In traditional implementations, file descriptors are indices into a (per-process) file descriptor table, thence a (system-wide) file table.|$|R
5000|$|In Unix-like systems, file {{descriptors}} {{can refer}} to any Unix file type named in a file system. As well as regular files, this includes directories, block and character devices (also called [...] "special files"), Unix domain sockets, and named pipes. File descriptors can also refer to other objects that do not normally exist in the file system, such as anonymous pipes and <b>network</b> <b>sockets.</b>|$|R
