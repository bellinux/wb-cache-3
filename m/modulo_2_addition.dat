12|10000|Public
50|$|Other {{names for}} this {{function}} are: Not equal (NEQ), <b>modulo</b> <b>2</b> <b>addition</b> (without 'carry') and modulo 2 subtraction (without 'borrow').|$|E
5000|$|The Vernam cipher {{implemented}} by the Lorenz SZ machines utilizes the Boolean [...] "exclusive or" [...] (XOR) function, symbolised by ⊕ and verbalised as [...] "A or B but not both". This {{is represented by the}} following truth table, where x represents [...] "true" [...] and • represents [...] "false".Other names for this function are: exclusive disjunction, not equal (NEQ), and <b>modulo</b> <b>2</b> <b>addition</b> (without [...] "carry") and subtraction (without [...] "borrow"). Note that <b>modulo</b> <b>2</b> <b>addition</b> and subtraction are identical. Some descriptions of Tunny decryption refer to addition and some to differencing, i.e. subtraction, but they mean the same thing.|$|E
5000|$|Other {{names for}} this {{function}} are: [...] "not equal" [...] (NEQ), [...] "modulo 2 addition" [...] (without carry) and [...] "modulo 2 subtraction" [...] (without 'borrow'). Note that <b>modulo</b> <b>2</b> <b>addition</b> and subtraction are identical. Some descriptions of Tunny decryption refer to addition and some to differencing, i.e. subtraction, but they {{mean the same}} thing.|$|E
50|$|With {{respect to}} the result, this example may be arithmetically viewed as <b>modulo</b> <b>2</b> binary <b>addition,</b> and as logically {{equivalent}} to the exclusive-or (exclusive disjunction) binary logic operation.|$|R
2500|$|Consider {{the group}} , the {{integers}} from 0 to 5 with addition modulo6. [...] Also consider the group , the ordered pairs where the x coordinates can be 0 or 1, and the y coordinates can be 0, 1, or <b>2,</b> where <b>addition</b> in the x-coordinate is <b>modulo</b> <b>2</b> and <b>addition</b> in the y-coordinate is modulo 3.|$|R
3000|$|... are {{represented}} by only log 2 M 2 bits. The memory usage can further be lowered in a practical implementation by storing the elements of q 1 obtained in the first slot, performing the <b>modulo</b> M <b>2</b> <b>addition</b> element-wise in the second slot as the values of [...]...|$|R
5000|$|Cryptanalysis often {{involves}} finding patterns {{of some sort}} that provide a way into eliminating a range of key possibilities. At Bletchley Park the XOR combination {{of the values of}} two adjacent letters in the key or the ciphertext was called the difference (symbolised by the Greek letter delta 'Δ') because XOR is the same as modulo 2 subtraction (without [...] "borrow")—and, incidentally, <b>modulo</b> <b>2</b> <b>addition</b> (without [...] "carry"). So, for the characters in the key(K), the difference ΔK was obtained as follows, where underline indicates the succeeding character: ...|$|E
3000|$|... c, and ⊕ {{denotes the}} <b>modulo</b> <b>2</b> <b>addition.</b> Then, the encoded bit ci can be {{recovered}} from the symbol xiusing the inverse mapping, [...]...|$|E
40|$|We {{consider}} a unit memory channel, called Binary State Symmetric Channel (BSSC), {{in which the}} channel state is the <b>modulo</b> <b>2</b> <b>addition</b> of the current channel input and the previous channel output. We derive closed form expressions for the capacity and corresponding channel input distribution, of this BSSC with and without feedback and transmission cost. We also show that {{the capacity of the}} BSSC is not increased by feedback, and it is achieved by a first order symmetric Markov process...|$|E
40|$|Efficient <b>modulo</b> <b>2</b> n± 1 adders are {{desirable}} for computer arithmetic units based on residue number systems (RNS) {{with the popular}} moduli set { 2 n– 1, 2 n, 2 n+ 1 }. Regular n-bit ripple-carry adders or their fast equivalents are suitable for <b>modulo</b> <b>2</b> n <b>addition.</b> But for the other two moduli a correcting increment/decrement step besides the primary n-bit addition is normally required. Several design efforts have tried to reduce the latency of the correcting step to a small delay not depending on the word length n, leading to one-step modular addition schemes. These {{include the use of}} alternative encoding of residues (e. g., diminished- 1 representation of <b>modulo</b> <b>2</b> n+ 1 numbers), customized (vs. generic) adders (e. g., specialized parallel prefix adders), or compound adders. In this paper we investigate alternative <b>modulo</b> <b>2</b> n+ 1 <b>addition</b> schemes, focus on generic one-step adder designs, and use the double-lsb representation of <b>modulo</b> <b>2</b> n+ 1 numbers. In a generic modular adder, the central abstract n-bit adder may be replaced by any concrete adder architecture meeting the designer’s prescribed measures in time, area and power consumption...|$|R
40|$|Zero {{treatment}} in diminished-one <b>modulo</b> <b>2</b> nþ 1 <b>addition</b> {{has traditionally been}} performed separately, leading to slow and area-consuming implementations. To overcome this, {{on the basis of}} an enhanced number representation used previously, we introduce novel carry look ahead and parallel-prefix architectures for diminished-one <b>modulo</b> <b>2</b> nþ 1 adders that can also handle operands equal to 0. Translators for the new representation are also given. 1...|$|R
5000|$|If each string in a cwatset, C, say, is {{of length}} n, then C {{will be a}} subset of Z2n. Thus, two strings in C are added by adding the bits in the strings <b>modulo</b> <b>2</b> (that is, <b>addition</b> without carry, or {{exclusive}} disjunction). The symmetric group on n letters, Sym(n), acts on Z2n by bit permutation: ...|$|R
40|$|Despite the NP {{hardness}} {{of acquiring}} minimum distance $d_m$ for linear codes theoretically, {{in this paper}} we propose one experimental method of finding minimum-weight codewords, the weight of which is equal to $d_m$ for LDPC codes. One existing syndrome decoding method, called serial belief propagation (BP) with ordered statistic decoding (OSD), is adapted to serve our purpose. We hold the conjecture that among many candidate error patterns in OSD reprocessing, <b>modulo</b> <b>2</b> <b>addition</b> of the lightest error pattern with one of the left error patterns may generate a light codeword. When the decoding syndrome changes to all-zero state, the lightest error pattern reduces to all-zero, the lightest non-zero error pattern is a valid codeword to update lightest codeword list. Given sufficient codewords sending, the survived lightest codewords are likely to be the target. Compared with existing techniques, our method demonstrates its efficiency in the simulation of several interested LDPC codes. Comment: 8 pages, 1 tabl...|$|E
40|$|Abstract—This paper {{describes}} about novel key {{expansion and}} its inversion technique for private key cryptosystems. Our design uses (8, 4) Extended Hamming Code and its error control logic to produce memory efficient key schedule generation algorithm. A mathematical relationship between 4 bit word and its corresponding 4 bit parity bits is shown. Simplicity, symmetry elimination, diffusion and non-linearity {{of the proposed}} key expansion technique are described as the key schedule generation criteria. Proposed method removes the usage of S-box to reduce the working memory of the algorithm. High nonlinearity penetration of original input message bits is achieved by applying <b>modulo</b> <b>2</b> <b>addition</b> of code based key schedules for each round transformations. Security strength among these key schedules is achieved by intentional bit inversions among them with beyond the error correcting limitations of chosen code. Comparative results between proposed design and Rijndael algorithm is illustrated {{with the aid of}} Xilinx Simulation tool. This paper concludes that novel key generation technique by Error Control Algorithm of wireless communication channel is an alternative solution to the cryptosystems without S-box substitution and any lookup tables...|$|E
40|$|Approved {{for public}} release; {{distribution}} is unlimitedThe arrival of high speed packet switched fiber optic LANs has allowed local area design architectures {{to be used}} for larger metropolitan area network (MANs) implementation. The current LAN security mechanisms used in larger and faster fiber optic LANs and MANs are often inappropriate or unacceptable for use with emerging applications. The protocol of the Fiber Distributed Data Interface (FDDI) standard provides a natural means for message integrity and availability verification. However, privacy in FDDI is facilitated at higher layers through a generic LAN standard. This thesis proposes a modification to the FDDI protocol implemented at the medium access control (MAC) sublayer, which integrates a confidentiality mechanism for data transfer. The modification provides a simple comprehensive security package to meet high performance needs of current and emerging applications. In the proposed modification, the inherent properties of the ring are exploited using a unique Central Key Translator to distribute initial session keys. Asymmetric bit stream cipher based on <b>modulo</b> <b>2</b> <b>addition</b> is used for encryption/decryption by the transmitting and receiving stations. Part of the plaintext from transmitted message frames is used as feedback to generate new session keys. [URL] United States Nav...|$|E
5000|$|The {{symmetry}} of a Lissajous knot puts severe {{constraints on the}} Alexander polynomial. In the odd case, the Alexanderpolynomial of the Lissajous knot must be a perfect square. [...] In the even case, the Alexander polynomial must be a perfect square <b>modulo</b> <b>2.</b> [...] In <b>addition,</b> the Arf invariant of a Lissajous knot must be zero. It follows that: ...|$|R
40|$|For {{each set}} X, the power set of X forms a vector space {{over the field}} Z 2 (the two-element field { 0, 1 } with {{addition}} and multiplication done <b>modulo</b> <b>2)</b> : vector <b>addition</b> is disjoint union, and scalar multiplication {{is defined by the}} two equations (1 · x: = x, 0 · x: = ∅ for subsets x of X). See [10], Exercise 2. K, for more information...|$|R
40|$|In this paper, {{we first}} {{describe}} a novel <b>modulo</b> (<b>2</b> ^n+ 1) <b>addition</b> algorithm suited to FPGA and ASIC implementations, and discuss several architectures of multioperand <b>modulo</b> (<b>2</b> ^n+ 1) adders. Then, we propose three implementations of a <b>modulo</b> (<b>2</b> ^n+ 1) multiplication algorithm {{based on a}} paper by A. Wrzyszcz and D. Milford. The first operator {{is based on an}} n× n multiplication and a subsequent <b>modulo</b> (<b>2</b> ^n+ 1) correction, and takes advantage of the arithmetic logic embedded in Spartan or Virtex FPGAs. The second operator computes a sum of modulo-reduced partial products by means of a multioperand <b>modulo</b> (<b>2</b> ^n+ 1) adder. Then, radix- 4 modified Booth recoding reduces the number of partial products, while making their generation more complex. Finally, we provide a comparison of this family of algorithms with existing solutions...|$|R
40|$|Abstract. In {{this paper}} we {{prove that the}} Fejér {{integrals}} of an integrable function f defined on R+ converges in norm to the function itself. Let denote by Z 2 the discrete cyclic group of order 2, that is Z 2 = { 0, 1 }, where the group operation is the <b>modulo</b> <b>2</b> <b>addition</b> and every subset is open. Haar measure on Z 2 is given {{in the way that}} the measure of a singleton is 12. Let G be the complete direct product of the countable infinite copies of the compact groups Z 2. The elements of G are of the form x = (x 0, x 1, [...] ., xk, [...] .) with xk ∈ { 0, 1 }. The group operation on G is the coordinate-wise addition, the measure and the topology are the product measure and the topology. G is a compact Abelian group, called Walsh group. For k ∈ N and x ∈ G denote rk the k-th Rademacher function: rk(x) : = (− 1) xk. Let n ∈ N, n can be written in the form n = ∑∞i= 0 ni 2 i, where ni ∈ { 0, 1 }, that is, n is expressed in the number system based 2. Denote by |n |: = max{j ∈ N: nj 6 = 0 }, that is, 2 |n | ≤ n 0 holds a. e. L. A. Balas̆ov [1] constructe...|$|E
40|$|I {{investigated}} the cryptographic properties of d-sequences {{many years ago}} in a series of papers [1 - 3]. The binary d-sequence is generated by means of the algorithm: a(i) = 2 i mod p mod 2 (1) where p is a prime number (for details, see [1 - 3]). The maximum length (period p- 1) sequences are generated when 2 is a primitive root of p. When the binary d-sequence is of maximum length, the bits {{in the second half of}} the period are the complements of those in the first half. It is easy to generate d-sequences, which makes them attractive for many engineering applications. It was shown in [2] that it is easy to find i given log 2 p bits of a(i). Therefore, d-sequences cannot be directly used in random number generator (RNG) applications. However, by adding together two or more different d-sequences (obtained by using primes p 1, p 2, …) mod 2, we are able to introduce non-linearity in the generation process, and the resulting sequence becomes a good candidate for use as random sequence. For convenience, we will now consider only terms in the sum. If the individual sequences are maximum length, then the period of the sum will be lcm (p 1 - 1) (p 2 - 1) (2) But for randomly chosen primes we do not know if the starting number is a primitive root, therefore, the actual period would be a divisor of lcm (p 1 - 1) (p 2 - 1). A power exponent Mathematically, let the seed by equal to S, which is relatively prime to each pi, and the order of S does not divide (pi- 1) for all i. Then the power-exponent RNG generates bits according to the algorithm: a(0) = S mod p 1 mod 2 ⊕ S mod p 2 mod 2 a(1) = S 2 mod p 1 mod 2 ⊕ S 2 mod p 2 mod 2 a(2) = S 4 mod p 1 mod 2 ⊕ S 4 mod p 2 mod 2 (3) where ⊕ means <b>modulo</b> <b>2</b> <b>addition...</b>|$|E
5000|$|In {{a finite}} field with {{characteristic}} <b>2,</b> <b>addition</b> <b>modulo</b> <b>2,</b> subtraction <b>modulo</b> <b>2,</b> and XOR are identical. Thus, ...|$|R
40|$|Abstract—This paper {{presents}} two {{new design}} methodologies for <b>modulo</b> <b>2</b> n 1 <b>addition</b> in the diminished-one number system. The first design methodology leads to carry look-ahead, whereas {{the second to}} parallel-prefix adder implementations. VLSI realizations of the proposed circuits in a standard-cell technology are utilized for quantitative comparisons against the existing solutions. Our {{results indicate that the}} proposed carry look-ahead adders are area and time efficient for small values of n, while for the rest values of n the proposed parallel-prefix adders are considerably faster than any other already known in the open literature. Index Terms—Modulo <b>2</b> n 1 <b>addition,</b> carry look-ahead addition, parallel-prefix adders, diminished-one number representation, VLSI adders. æ...|$|R
40|$|In recent years, {{reversible}} {{logic is}} of prominent factor in energy efficient computation. Reversible logic circuits play {{important role in}} nanotechnology-based systems and have applications in quantum computing, low power CMOS designs, DNA computing, bioinformatics and optical information processing. This paper proposes two efficient hardware architecture of reversible circular carry selection diminished-one modulo 24 + 1 adders which {{one of them is}} parity preserving. The proposed reversible circular carry selection diminished-one modulo 24 + 1 adder can be generalized for reversible circular carry selection diminished-one <b>modulo</b> <b>2</b> n+ 1 adder. The parity preserving reversible logic circuit of the m×r partitioned CCS modular adder is also proposed. One of the important interests for a high-performance residue number system is the diminished-one <b>modulo</b> <b>2</b> n+ 1 <b>addition.</b> It is a prominent arithmetic operation for RNS. The circuits are evaluated in terms of number of reversible gates, number of garbage outputs, number of constant inputs, quantum cost and hardware complexity. All the scales are in the nanometric area...|$|R
40|$|This paper {{presents}} {{high speed}} butterfly architecture for circular convolution based on FNT using partial product multipliers. FNT is {{ideally suited to}} digital computation requiring the order of N log N additions, subtractions and bit shifts, but no multiplications. In addition to being efficient, the FNT implementation is exact with no round off errors. Binary arithmetic permits the exact computation of FNT. This technique involves arithmetic in a binary code orresponding to the simplest one {{of a set of}} code translations from the normal binary representation of each integer in the ring of integer. In the first stage normal binary numbers are converted intotheir diminished- 1 representation using code conversion (CC). Then butterfly operation (BO) is carried out to perform FNT and IFNT where the point wise multiplication is performed using <b>modulo</b> <b>2</b> n+ 1 partial product multipliers. Thus <b>modulo</b> <b>2</b> n+ 1 <b>additions</b> are avoided {{in the final stages of}} FNT and IFNT and hence execution delay is reduced compared to circular convolution done with FFT and DFT. This architecture has better throughput and involves less hardware complexity...|$|R
40|$|In {{this paper}} we {{describe}} {{an attack on}} 3 rounds of IDEA, making use of linear as well as differential cryptanalytic techniques. The attack is independent of the key schedule. The main attack requires at most 2 29 chosen plaintext pairs and a workload of about <b>2</b> 49 <b>additions</b> <b>modulo</b> <b>2</b> 16 + 1 to find two subkeys or their additive inverses <b>modulo</b> <b>2</b> 16 + 1. Further we describe a method, which then can find two more subkeys or their additive inverses <b>modulo</b> <b>2</b> 16 + 1, which needs less than 10 of the already encrypted pairs and a total workload of at most <b>2</b> 33 multiplications <b>modulo</b> <b>2</b> 16 + 1. This attack is more powerful than all previously published general attacks on the IDEA structure...|$|R
40|$|The special moduli set,Residue Number System is {{intended}} to implement the long and repeated multiplications of cryptographic and signal processing algorithms. In this paper, area and power trade-of of <b>modulo</b> <b>2</b> n – 1 and <b>modulo</b> <b>2</b> n + 1 multipliers based on RNS are proposed. The proposed modulo multipliers {{are based on the}} radix- 8 Booth encoding technique. In the proposed <b>modulo</b> <b>2</b> n – 1 multipliers, the number of partial products is lowered to └ n/ 3 ┘ + 1 for n = 32 to 64, which is around 33 % reduction over radix- 4 Booth encoded multiplier for n = 32 to 64. For <b>modulo</b> <b>2</b> n + 1 multiplier,the aggregate bias is composed of multiplier dependent dynamic bias and multiplier independent static bias due to hard multiple and modulo-reduced partial products generation. The total number of partial products is reduced to └ n/ 3 ┘ + 6 for <b>modulo</b> <b>2</b> n + 1 multiplier. From synthesis results for <b>modulo</b> <b>2</b> n – 1 and <b>modulo</b> <b>2</b> n + 1 based RNS multipliers constructed from different <b>modulo</b> <b>2</b> n – 1 and <b>modulo</b> <b>2</b> n + 1 multipliers...|$|R
40|$|Abstract—The special moduli set,Residue Number System is {{intended}} to implement the long and repeated multiplications of cryptographic and signal processing algorithms. In this paper, area and power trade-of of <b>modulo</b> <b>2</b> n – 1 and <b>modulo</b> <b>2</b> n + 1 multipliers based on RNS are proposed. The proposed modulo multipliers {{are based on the}} radix- 8 Booth encoding technique. In the proposed <b>modulo</b> <b>2</b> n – 1 multipliers, the number of partial products is lowered to └ n/ 3 ┘ + 1 for n = 32 to 64, which is around 33 % reduction over radix- 4 Booth encoded multiplier for n = 32 to 64. For <b>modulo</b> <b>2</b> n + 1 multiplier,the aggregate bias is composed of multiplier dependent dynamic bias and multiplier independent static bias due to hard multiple and modulo-reduced partial products generation. The total number of partial products is reduced to └ n/ 3 ┘ + 6 for <b>modulo</b> <b>2</b> n + 1 multiplier. From synthesis results for <b>modulo</b> <b>2</b> n – 1 and <b>modulo</b> <b>2</b> n + 1 based RNS multipliers constructed from different <b>modulo</b> <b>2</b> n – 1 and <b>modulo</b> <b>2</b> n + 1 multipliers. Index terms-Booth algorithm, computer arithmetic, multiplic-ation, residue number system(RNS). I...|$|R
40|$|To {{implement}} {{long and}} repetitive multiplications of cryptographic and signal processing algorithmwe often adopt residue number system. In this paper {{a new low}} power and low modulo multiplier foe well established { 2 n- 1, 2 n, 2 n+ 1 } based is proposed. Radix- 8 Booth encoding technique {{is used in the}} proposed <b>modulo</b> <b>2</b> n- 1 and <b>modulo</b> <b>2</b> n+ 1 multipliers. In the proposed <b>modulo</b> <b>2</b> n- 1 multiplier, the number of partial products is lowered to [n/ 3]+ 1. For <b>modulo</b> <b>2</b> n+ 1 multiplication,the aggregate bias due to the hard multiple and the modulo reduced partial product generation is composed of multiplier dependent dynamic bias and multiplier-independent static bias. In the proposed <b>modulo</b> <b>2</b> n+ 1 multiplier, the number of partial products is lowered to n/ 3 + 6. For different <b>modulo</b> <b>2</b> n- 1 and <b>modulo</b> <b>2</b> n+ 1 multiplier our proposed modulo multiplier consumes less area and has minimum power dissipation over radix- 4 Booth encoded and non-encoded modulo multiplie...|$|R
40|$|Abstract Novel {{architectures}} {{for designing}} <b>modulo</b> <b>2</b> n + 1 subtractors and com-bined adders/subtractors are proposed in this manuscript. Both the normal and the diminished-one {{representations of the}} operands are considered. Unit gate estimates and CMOS VLSI implementations reveal that the proposed <b>modulo</b> <b>2</b> n + 1 subtrac-tors for operands in the normal representation are more efficient than those previously proposed. The proposed diminished-one <b>modulo</b> <b>2</b> n+ 1 subtractors have a complexity {{similar to that of}} the corresponding diminished-one adders. <b>Modulo</b> <b>2</b> n − 1 subtrac-tors and adders/subtractors are also considered for the sake of completeness and a comparison between alternative architectures is provided. Keywords Residue number system · <b>Modulo</b> <b>2</b> n ± 1 arithmetic circuits · Subtraction · Addition · Normal and diminished-one <b>modulo</b> <b>2</b> n + 1 number representations...|$|R
2500|$|The Galois {{group of}} [...] <b>modulo</b> <b>2</b> is cyclic of order 6, because [...] <b>modulo</b> <b>2</b> factors into polynomials of orders 2 and 3, [...]|$|R
40|$|Novel {{architectures}} {{for designing}} <b>modulo</b> <b>2</b> n+ 1 subtractors are introduced, {{for both the}} normal and the diminished-one number representation of the operands. Zero-handling is also considered in the diminished-one operand representation case. The <b>modulo</b> <b>2</b> n+ 1 subtractors for operands in the normal representation that are proposed are shown to be more efficient in area, delay and power dissipation than the currently most efficient ones. The proposed diminished-one <b>modulo</b> <b>2</b> n+ 1 subtractors offer similar characteristics {{to those of the}} corresponding diminished-one adders. Index Terms — Residue number system, <b>modulo</b> <b>2</b> n+ 1 circuits, subtraction, normal and diminished-one number representation. 1...|$|R
40|$|Abstract—In this paper, {{we present}} new design methods for <b>modulo</b> <b>2</b> n 1 adders. We {{use the same}} select-prefix {{addition}} block for both <b>modulo</b> <b>2</b> n 1 and diminished-one <b>modulo</b> <b>2</b> n þ 1 adder design. VLSI implementations of the proposed adders in static CMOS show that they achieve an attractive combination of speed and area costs. Index Terms—Modulo 2 n 1 adders, select-prefix adders, computer arithmetic, VLSI architectures...|$|R
40|$|Abstract—Two {{architectures}} for <b>modulo</b> <b>2</b> n þ 1 adders {{are introduced}} in this paper. The {{first one is}} built around a sparse carry computation unit that computes {{only some of the}} carries of the <b>modulo</b> <b>2</b> n þ 1 addition. This sparse approach is enabled by the introduction of the inverted circular idempotency property of the parallel-prefix carry operator and its regularity and area efficiency are further enhanced by the introduction of a new prefix operator. The resulting diminished- 1 adders can be implemented in smaller area and consume less power compared to all earlier proposals, while maintaining a high operation speed. The second architecture unifies the design of <b>modulo</b> <b>2</b> n 1 adders. It is shown that <b>modulo</b> <b>2</b> n þ 1 adders can be easily derived by straightforward modifications of <b>modulo</b> <b>2</b> n 1 adders with minor hardware overhead...|$|R
40|$|It {{is shown}} that a diminished- 1 adder, with minor modi¯cations, can be also used for the <b>modulo</b> <b>2</b> n þ 1 {{addition}} of two n-bit operands in the weighted representation, if {{the sum of its}} input operands is decreased by one. This modi¯ed diminished- 1 adder can perform n-bit <b>modulo</b> <b>2</b> n þ 1 addition in less area and time than solutions that are based on the use of binary adders and/or weighted <b>modulo</b> <b>2</b> n þ 1 adders. Therefore, it can be applied e®ectively to all weighted <b>modulo</b> <b>2</b> n þ 1 arithmetic components that ¯nally derive two n-bit addends. A small number of weighted arithmetic components have in the past adopted such a scheme without presenting this general theory. By applying this idea, we propose novel multi-operand <b>modulo</b> <b>2</b> n þ 1 adders (MOMAs) and residue generators (RGs). Experimental results indicate that the resulting arithmetic components o®er signi¯cant savings in delay, implementation area and average power consumption compared to the currently most e±cient solutions...|$|R
40|$|Two novel {{architectures}} {{for designing}} <b>modulo</b> <b>2</b> n- 1 squarers are given. The first {{one does not}} perform any encoding on the input operand, while the second one uses Booth-encoding. Pre-layout estimates indicate that both architectures result in area and/or delay efficient <b>modulo</b> <b>2</b> n- 1 squarers. The non-encoded modulo squarers {{are more suitable for}} small values of n while the Booth-encoded modulo squarers are more suitable for medium and large values of n. Index Terms — Squaring operation, <b>modulo</b> <b>2</b> n-...|$|R
40|$|<b>Modulo</b> <b>2</b> n + 1 adders find great {{applicability}} {{in several}} applications including RNS implementations. This paper presents a new number system called Carry Save Diminished-one for <b>modulo</b> <b>2</b> n + 1 addition and a novel addition algorithm for its operands. In this paper, we also present a novel architectures for designing <b>modulo</b> <b>2</b> n + 1 adders, based on parallel-prefix carry computation units. CMOS implementations reveal {{the superiority of}} the resulting adders against previously reported solutions in terms of implementation area and delay...|$|R
