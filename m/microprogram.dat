108|256|Public
25|$|A microassembler is {{a program}} that helps prepare a <b>microprogram,</b> called firmware, to control the low level {{operation}} of a computer.|$|E
2500|$|Less theoretically, an {{interesting}} application of computer simulation is to simulate computers using computers. In computer architecture, {{a type of}} simulator, typically called an emulator, {{is often used to}} execute a program that has to run on some inconvenient type of computer (for example, a newly designed computer that has not yet been built or an obsolete computer that is no longer available), or in a tightly controlled testing environment (see Computer architecture simulator and Platform virtualization). [...] For example, simulators have been used to debug a <b>microprogram</b> or sometimes commercial application programs, before the program is downloaded to the target machine. Since the operation of the computer is simulated, all of the information about the computer's operation is directly available to the programmer, and the speed and execution of the simulation can be varied at will.|$|E
5000|$|The most {{general-purpose}} register-transfer logic {{machine is}} a computer. This is basically an automatic binary abacus. The control unit {{of a computer}} is usually designed as a <b>microprogram</b> run by a microsequencer. A <b>microprogram</b> is much like a player-piano roll. Each table entry or [...] "word" [...] of the <b>microprogram</b> commands the state of every bit that controls the computer. The sequencer then counts, and the count addresses the memory or combinational logic machine that contains the <b>microprogram.</b> The bits from the <b>microprogram</b> control the arithmetic logic unit, memory {{and other parts of}} the computer, including the microsequencer itself. A [...] "specialized computer" [...] is usually a conventional computer with special-purpose control logic or <b>microprogram.</b>|$|E
40|$|Foundations of Microprogramming: Architecture, Software, and Applications {{discusses}} the foundations and trends in <b>microprogramming,</b> {{focusing on the}} architectural, software, and application aspects of <b>microprogramming.</b> The book reviews microprocessors, <b>microprogramming</b> concepts, and characteristics, {{as well as the}} architectural features in <b>microprogrammed</b> computers. The text explains support software and the different hierarchies or levels of languages. These include assembler languages which are mnemonic or symbolic representation of machine commands; the procedure oriented machine-dependent...|$|R
40|$|Approved {{for public}} release; {{distribution}} is unlimitedConsiderations {{in the design}} of <b>microprogrammed</b> disk controllers are presented. First, the concept of <b>microprogramming</b> and the characteristics of diskette storage drives are discussed. The use of disk storage in data base management systems is also discussed. Finally, the functions, programs and structure of a <b>microprogrammed</b> disk controller for personnel file management are presented. [URL] Indonesian Nav...|$|R
5000|$|... 1980. Firmware, <b>microprogramming,</b> and restructurable {{hardware}} : {{proceedings of}} the IFIP Working Conference on Firmware, <b>Microprogramming,</b> and Restructurable Hardware, Linz, Austria, April 28-May 1, 1980. Edited with Jörg R. Mühlbacher.|$|R
50|$|A microassembler is a {{computer}} program that helps prepare a <b>microprogram,</b> called firmware, to control the low level operation of {{a computer}} {{in much the same}} way an assembler helps prepare higher level code for a processor. The difference is that the <b>microprogram</b> is usually only developed by the processor manufacturer and works intimately with the computer hardware. On a microprogrammed computer the <b>microprogram</b> implements the operations of the instruction set in which any normal program (including both application programs and operating systems) is written. The use of a <b>microprogram</b> allows the manufacturer to fix certain mistakes, including working around hardware design errors, without modifying the hardware. Another means of employing microassembler-generated microprograms is in allowing the same hardware to run different instruction sets. After it is assembled, the <b>microprogram</b> is then loaded to a control store to become part of the logic of a CPU's control unit.|$|E
5000|$|MPG, the [...] "machine-independent {{efficient}} <b>microprogram</b> generator" ...|$|E
50|$|It {{is one of}} {{the most}} popular {{techniques}} for implementing a read-only memory. A diode matrix is used as the control store or <b>microprogram</b> in many early computers. A logically equivalent transistor matrix is still used as the control store or <b>microprogram</b> or 'decode ROM' in many modern microprocessors.|$|E
5000|$|... "Second Euromicro Symposium on Microprocessing and <b>Microprogramming,</b> October 12-14, 1976, Venice : papers / [...] " [...] Euromicro Symposium on Microprocessing and <b>Microprogramming</b> (2nd : 1976 : Venice, Italy) | 1977. | text ...|$|R
40|$|An {{overview}} of <b>microprogramming</b> {{and of the}} methods and tools available for <b>microprogramming</b> is given. A review is given of the language MPLS 130, a high level language for <b>microprogramming</b> the Data General Eclipse S/ 130. Next, a progress report on an implementation effort for this language is given. Finally a summary is made of further {{work to be done}} and some concluding remarks are made about the language...|$|R
5000|$|... "Microcomputer architectures: Third EUROMICRO Symposium on Microprocessing and <b>Microprogramming,</b> October 3-6, 1977, Amsterdam : preprints / [...] " [...] Euromicro Symposium on Microprocessing and <b>Microprogramming</b> (3rd : 1977 : Amsterdam, Netherlands) | 1977. | text ...|$|R
50|$|In some CPU designs the {{instruction}} decoder is implemented as a hardwired, unchangeable circuit. In others, a <b>microprogram</b> {{is used to}} translate instructions into sets of CPU configuration signals that are applied sequentially over multiple clock pulses. In some cases the memory that stores the <b>microprogram</b> is rewritable, {{making it possible to}} change {{the way in which the}} CPU decodes instructions.|$|E
50|$|The idea of {{microprogramming}} {{was introduced}} by Maurice Wilkes in 1951 as an intermediate level to execute computer program instructions. Microprograms were organized as a sequence of microinstructions and stored in special control memory. The algorithm for the <b>microprogram</b> control unit is usually specified by flowchart description. The main advantage of the <b>microprogram</b> control unit is the simplicity of its structure. Outputs of the controller are organized in microinstructions {{and they can be}} easily replaced.|$|E
50|$|Key CPU {{architectural}} innovations include index register, cache, virtual memory, instruction pipelining, superscalar, CISC, RISC, virtual machine, emulators, <b>microprogram,</b> and stack.|$|E
50|$|<b>Microprogrammed</b> processors, popular {{from the}} 1960s to the 1980s and beyond, took {{multiple}} cycles per instruction, and generally {{did not require}} branch prediction. However, {{in addition to the}} IBM 3090, there are several other examples of <b>microprogrammed</b> designs that incorporated branch prediction.|$|R
40|$|This paper {{describes}} the MPC (<b>Microprogrammed</b> Controller) Concept used at Sperry Univac Defense Systems Division to implement real-time computer emulations. It discusses {{the concept and}} reasons for <b>microprogrammed</b> emulation and the basic MPC approach. Enhancements developed for the MPC and their impact are also discussed...|$|R
40|$|Abstract –A {{torque and}} rotate speed {{measurement}} {{system based on}} <b>microprogrammed</b> control unit was designed. This system was composed of <b>microprogrammed</b> control unit, magnetic-electric torque sensor and signal detection circuit. Approximately sinusoidal signal from the sensor was transformed to square wave in circuit signal processing. By {{the use of the}} <b>microprogrammed</b> control unit, the torque and rotate speed of shaft was obtained from the width of high level and frequency of the phase difference signal. The system had a simple structure, stable performance and high precision...|$|R
5000|$|A microassembler is {{a program}} that helps prepare a <b>microprogram,</b> called firmware, to control the low level {{operation}} of a computer.|$|E
5000|$|In {{a typical}} {{implementation}} a horizontal <b>microprogram</b> word comprises fairly tightly defined groups of bits. For example, one simple arrangement might be: ...|$|E
50|$|The Memory Address Register is half of {{a minimal}} {{interface}} between a <b>microprogram</b> and computer storage. The other half is a memory data register.|$|E
40|$|During {{the past}} two decades, <b>microprogramming</b> has evolved to be a {{standard}} mechanism for implementing the complex standard instruction set of a computer. With {{the advent of the}} writable control store, the number of microprogrammable computers has steadily increased and subsequently, there has been a significant growth of interest in user <b>microprogramming.</b> Despite the steadily increasing rate of interest, the <b>microprogramming</b> environment remains very much the way it was {{in the early years of}} the art. This project surveys the problems associated with the current environment for user <b>microprogramming.</b> One appropriate solution to the problem would be to provide a higher level of programming through higher level language support. With this approach in mind, the main objective of this research is to propose a language that can be used efficiently for <b>microprogramming</b> on the Data General Eclipse S/ 130. Considerable effort has been expended on this area of research in the past few years and a study is made of the current state of the design and implementation of high level <b>microprogramming</b> languages. The final phase of the project involved the consideration of aspects of compiler construction for such a high level language, particularly the problems of efficient microcode generation...|$|R
40|$|Some {{possibilities}} {{offered by}} <b>microprogramming</b> in {{the realization of}} computer systems implemented according to several architectures are investigated in this paper. The serial and the classical parallel (SISD, SIMD, multiprocessors) organizations are considered together with some approaches to the realization of modern distributed systems (local networks, Logic Machines, Configurable Computers). The <b>microprogramming</b> possibilities are examined by {{taking into account the}} type of microinstruction encoding (vertical vs. horizontal), the opportunity for dynamic <b>microprogramming</b> and the Control Part-Operation Part model, and by evaluating the influence of these factors on the optimization of some design parameters...|$|R
40|$|The {{structure}} of the Processing Element (PE), which is the basic component of SMA, is presented. The PE consists of a simple serial arithmetic unit, a local high speed data memory, serial input and output ports, serial communication channels with neighbouring PE?s, and some local control logic. The PE array operates {{under the control of}} a <b>microprogrammed</b> Array Controi Unit (ACU). The peculiarities of ACU <b>microprogramming</b> are discussed, and some typical <b>microprograms</b> are reported. After presentation of the SMA principal instructions, some application programs are described implementing common radar filtering algorithms...|$|R
5000|$|... "The Use of Software Simulators in the Testing and Debugging of <b>Microprogram</b> Logic," [...] IEEE Transactions on Computers, Vol. C-30, No. 7, July 1981.|$|E
5000|$|The IBM System/360 Model 30 {{could be}} ordered with a 1401 {{compatibility}} <b>microprogram</b> feature. Several 1400 series peripherals were adapted {{for use with}} System/360.|$|E
50|$|The Memory Data Register is half of {{a minimal}} {{interface}} between a <b>microprogram</b> and computer storage, the other half is a memory address register (MAR).|$|E
5000|$|TCuARCH - Technical Committee on <b>Microprogramming</b> and Microarchitecture (TCuARCH) ...|$|R
5000|$|Core memory, <b>microprogrammed</b> CPU. An option allowed user <b>microprogramming.</b> Front panel buttons were {{illuminated}} by small incandescent lamps that burned out with use. Dark lights {{did not bother}} regular users, who knew the 1 and 0 sequences to load the paper tape [...] "loader-loader" [...] instructions without seeing the panel's lights.|$|R
25|$|The AS/400 was {{originally}} {{based on a}} custom IBM CISC CPU which used a CPU architecture known as Internal <b>MicroProgrammed</b> Interface (IMPI) with an instruction set {{similar to that of}} the IBM System/370, known as Internal <b>MicroProgrammed</b> Interface (IMPI). It was later migrated to a POWER-based RISC CPU family eventually known as RS64.|$|R
50|$|WCS offered several {{advantages}} including {{the ease of}} patching the <b>microprogram</b> and, for certain hardware generations, faster access than ROMs could provide. User-programmable WCS allowed the user to optimize the machine for specific purposes.|$|E
50|$|When {{compared}} to normal application programs, the elements composing a <b>microprogram</b> exist on a lower conceptual level. To avoid confusion, each microprogram-related element is differentiated by the micro prefix: microinstruction, microassembler, microprogrammer, microarchitecture, etc.|$|E
50|$|Chief {{architect}} in {{the development}} of the 80386 was John H. Crawford. He was responsible for extending the 80286 architecture and instruction set to 32-bit, and then led the <b>microprogram</b> development for the 80386 chip.|$|E
40|$|Programming {{wireless}} sensor networks is a major challenge, {{even for}} experienced programmers. To alleviate this problem, prior work has proposed a paradigm shift from node-level <b>microprogramming</b> to macroprogramming, where the user specifies a distributed ap-plication using a single macroprogram that is automatically trans-lated into a set of node-level <b>microprograms.</b> This paper makes the case that node-level <b>microprogramming</b> itself can be made much easier by using the right set of programming abstractions. To sup-port this claim, this paper presents µSETL, a programming abstrac-tion for sensor networks based on set theory. Sets offer a power-ful formalism and high expressiveness, yet are a natural way o...|$|R
5000|$|EDSAC_2 {{computer}}, 1965 - first {{computer to}} have a <b>microprogrammed</b> CPU ...|$|R
50|$|The Microdata 3200 was {{developed}} in 1974 and was a 16 bit <b>microprogrammed</b> system designed to implement a high level language similar to IBM's PL/I language. It was designed to a more specific purpose, but still retained {{a great deal of}} flexibility in the firmware to allow for very complex <b>microprogrammed</b> architectures to be supported.|$|R
