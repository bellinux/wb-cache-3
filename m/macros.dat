3838|10000|Public
5|$|SAS <b>macros</b> are {{pieces of}} code or {{variables}} that are coded once and referenced to perform repetitive tasks.|$|E
5|$|Early PDP-1 users wrote {{programming}} software {{including an}} assembler {{translated from the}} TX-0 over one weekend in 1961. Kotok later wrote an interpreter for the Lisp programming language in TECO <b>macros.</b>|$|E
5|$|The {{interpreter}} has an object-oriented architecture. All of {{the elements}} of the Perl language—scalars, arrays, hashes, coderefs, file handles—are represented in the interpreter by C structs. Operations on these structs are defined by a large collection of <b>macros,</b> typedefs, and functions; these constitute the Perl C API. The Perl API can be bewildering to the uninitiated, but its entry points follow a consistent naming scheme, which provides guidance to those who use it.|$|E
5000|$|<b>Macro</b> / <b>Macro</b> Free Range / <b>Macro</b> Organic - grocery {{items for}} {{specific}} dietary requirements [...] ) ...|$|R
40|$|Creating <b>macro</b> {{variables}} {{for later use}} can help to create dynamic, powerful SAS ® programs. Creating those variables in a standard, consistent manner without causing any conflicts with other <b>macro</b> variables, however, can be repetitive, time consuming, and prone to error. Here we present <b>macro</b> programs that assist with generating <b>macro</b> variables {{with the intent to}} use the variables in specific ways later in the program. Each <b>macro</b> meets a set of criteria including allowing the filtration of input data (if possible); deleting conflicting <b>macro</b> variables; creating <b>macro</b> variables in a consistent, predefined manner; and reporting the result of the <b>macro’s</b> activity...|$|R
40|$|The SAS ® <b>macro</b> facility, which {{includes}} <b>macro</b> variables and <b>macro</b> programs, {{is the most}} useful tool to develop your own applications. Beginning SAS programmers often don’t realize {{that the most important}} function in learning a <b>macro</b> program is understanding the <b>macro</b> language processing rather than just learning the syntax. The lack of understanding includes how SAS statements are transferred from the input stack to the <b>macro</b> processor and the DATA step compiler, what role the <b>macro</b> processor plays during this process, and when best to utilize the interface to interact with the <b>macro</b> facility during the DATA step execution. In this talk, these issues are addressed via creating simple <b>macro</b> applications step-by-step...|$|R
5|$|Written by Michael Feeney Callan, {{this story}} was {{commissioned}} on 5 February 1985. After {{the news of the}} hiatus, Callan was asked by the production team to continue with the story but as four 25 minute episodes. It had been planned that an adaptation of this story would appear as part of Big Finish's The Lost Stories range, but fell through due to the author's other commitments and was replaced by The <b>Macros.</b>|$|E
5|$|JMP is {{a desktop}} {{application}} with a wizard-based user interface, while SAS {{can be installed}} on servers. It runs in-memory, instead of on disk storage. According to a review in Pharmaceutical Statistics, JMP is often used as a graphical front-end for a SAS system, which performs the statistical analysis and tabulations. JMP Genomics, used for analyzing and visualizing genomics data, requires a SAS component to operate and can access SAS/Genetics and SAS/STAT procedures or invoke SAS <b>macros.</b> JMP Clinical, used for analyzing clinical trial data, can package SAS code within the JSL scripting language and convert SAS code to JMP.|$|E
25|$|Powerful <b>macros</b> used in word {{processor}} applications, such as Microsoft Word, presented a risk. Virus writers {{could use the}} <b>macros</b> to write viruses embedded within documents. This meant that computers could now also be at risk from infection by opening documents with hidden attached <b>macros.</b>|$|E
50|$|The Canon EF-M 28mm f/3.5 <b>Macro</b> IS STM lens is an {{interchangeable}} <b>Macro</b> lens {{announced by}} Canon on May 11, 2016. The maximum magnification of this <b>Macro</b> lens is 1× in Normal mode and 1.2× in Super <b>Macro</b> mode. It {{is the first}} Canon lens with integrated <b>macro</b> light and uses the Hybrid IS.|$|R
30|$|We declare {{neighbors of}} a <b>macro</b> cell its <b>macro</b> cell neighbors, defined as above, and all small cells whose base station {{is located in}} the <b>macro</b> cell in {{question}} or in one of its neighboring <b>macro</b> cells.|$|R
40|$|<b>Macro</b> {{variables}} {{are the most}} {{essential part of the}} SAS ® <b>macro</b> facility. One can create <b>macro</b> variables by using the %LET statement, the SYMPUT routine, or the INTO clause in the SELECT statement from the SQL procedure. Sometimes a SAS programmer is often unsure when best to use which method due to a lack in understanding each step of <b>macro</b> language processing. This lack in understanding includes how SAS statements are transferred from the input stack to the <b>macro</b> processor and DATA step compiler, what role the <b>macro</b> processor plays during this process, and when best to utilize the interface to interact with the <b>macro</b> facility during the DATA or SQL execution. Once one grasps the intricacies of <b>macro</b> language processing, one will best know how to accurately create a <b>macro</b> variable...|$|R
25|$|In both cases, work {{is moved}} to compile-time. The {{difference}} between C <b>macros</b> on one side, and Lisp-like <b>macros</b> and C++ template metaprogramming {{on the other}} side, is that the latter tools allow performing arbitrary computations at compile-time/parse-time, while expansion of C <b>macros</b> does not perform any computation, and relies on the optimizer ability to perform it. Additionally, C <b>macros</b> do not directly support recursion or iteration, so are not Turing complete.|$|E
25|$|Many {{assemblers}} support predefined <b>macros,</b> {{and others}} support programmer-defined (and repeatedly re-definable) <b>macros</b> involving sequences of text lines in which variables and constants are embedded. This sequence of text lines may include opcodes or directives. Once a macro {{has been defined}} its name {{may be used in}} place of a mnemonic. When the assembler processes such a statement, it replaces the statement with the text lines associated with that macro, then processes them as if they existed in the source code file (including, in some assemblers, expansion of any <b>macros</b> existing in the replacement text). <b>Macros</b> in this sense date to IBM autocoders of the 1950s.|$|E
25|$|Optimization during code {{development}} using <b>macros</b> {{takes on}} different forms in different languages.|$|E
50|$|By 31, Ennia {{married the}} Roman Vigiles Prefect Quintus Naevius Cordus Sutorius <b>Macro,</b> also known Naevius Sutorius <b>Macro</b> or simply <b>Macro.</b> After the {{downfall}} {{and death of}} the Praetorian Prefect Lucius Aelius Sejanus in Rome in 31, <b>Macro</b> was appointed by Tiberius to replace Sejanus. <b>Macro</b> now being the head Praetorian prefect of the Praetorian Guard in Rome, had become very ambitious in his role. Through his position, Ennia and <b>Macro</b> began to have considerable influence.|$|R
40|$|Under the {{direction}} of DR. PETER CALINGAERT.) ML/I is a general purpose <b>macro</b> language which provides for the user specification of the argument delimiters of a <b>macro,</b> where each <b>macro</b> may have several possible patterns of delimiters. Other language features include nested and recursive <b>macro</b> calls and definitions, macro-time assignment and conditional statements, an extensive macrotime environment, the specification of a possibly variable number of delimiters for each <b>macro,</b> and a method of defining multi-atom <b>macro</b> names and delimiters...|$|R
50|$|Canon {{currently}} produces two flash {{products for}} <b>macro</b> photography, the <b>Macro</b> Twin Lite MT-24EX flash and the <b>Macro</b> Ring Lite MR-14EX II circular-shaped flash.|$|R
25|$|Use asm <b>macros</b> {{supported}} by GCC that produce DSP instructions directly from C code.|$|E
25|$|Further, because Lisp code has {{the same}} {{structure}} as lists, <b>macros</b> can be built {{with any of the}} list-processing functions in the language. In short, anything that Lisp can do to a data structure, Lisp <b>macros</b> can do to code. In contrast, in most other languages, the parser's output is purely internal to the language implementation and cannot be manipulated by the programmer.|$|E
25|$|Files {{containing}} <b>macros</b> {{are saved}} {{with an extra}} M letter in their extension instead (.docm/xlsm/pptm/etc.).|$|E
40|$|How, why, {{when and}} where to use <b>macro</b> quoting {{functions}} are tricky questions for all users. <b>Macro</b> quoting is not, as some think, putting single and double quotation marks in or around SAS tokens. <b>Macro</b> quoting is actually masking special characters and mnemonic expressions in the SAS ® System so that these characters are not confused or ambiguous in their context during tokenization and execution of SAS or SAS <b>macro.</b> SAS <b>macro</b> quoting functions also are used to mark starting and ending delimiters. The terms compile-time and run-time should be understood as related to <b>macro</b> for mastery of <b>macro</b> quoting functions. The differences and timing of the compile-time <b>macro</b> quoting functions, %STR and %NRSTR, will be emphasized. The meaning of run-time <b>macro</b> quoting functions and the individual implications in your code will be covered and the differences between run-time and compile-time <b>macro</b> quoting functions will be illustrated. Details and history of %QUOTE and %BQUOTE may help users remember the differences in what is masked in each function. Also, the implementation of <b>macro</b> quoting functions with the NR-prefixes will be detailed. <b>Macro</b> masking of special characters is achieved by using "delta " characters, unprintable ASCII or EBCDIC characters. Just what these characters are and how to examine them and debug them will be covered. Mnemonic expressions are <b>macro</b> quoted during explicit or implicit evaluation. For debugging purposes, suggestions will be made about when <b>macro</b> quoting is stripped...|$|R
30|$|Let us take {{considerations}} of the cross-tier interferences {{with the system}} scenario of several small cell clusters located within the coverage of each <b>macro</b> cell. We assume that there are inter-cell interference coordination (ICIC) schemes implemented in the <b>macro</b> cell tier, such as fractional frequency reuse (FFR); the interferences between different <b>macro</b> cells can be sufficiently avoided [17]. Without loss of generality, we will focus only one <b>macro</b> cell with multiple small cell clusters inside of the <b>macro</b> coverage as Figure  1 showed. Because the small cell clusters will share the spectrum with the co-located <b>macro</b> cell, if we can successfully solve the cross-tier interferences inside one <b>macro</b> cell, we could mitigate the interferences in the whole network due to the ICIC used among different <b>macro</b> cells.|$|R
5000|$|Most {{assemblers}} {{provide some}} sort of <b>macro</b> ability: the advantage that HLA offers over other assemblers {{is that it can}} process <b>macro</b> arguments like [...] using HLA's extensive compile-time string functions, and HLA's <b>macro</b> facilities can infer the types of variables and use that information to direct <b>macro</b> expansion.|$|R
25|$|VerilogCSP {{is a set}} of <b>macros</b> {{added to}} Verilog HDL to support {{communicating}} sequential processes channel communications.|$|E
25|$|Unlike prior versions, Visual Studio 2012 cannot {{record and}} play <b>macros</b> and the macro editor has been removed.|$|E
25|$|The exact style {{depends on}} the author or publication. Many {{publications}} provide instructions or <b>macros</b> for typesetting in the house style.|$|E
40|$|Abstract. In this paper, the {{research}} focus on NC process information integration methods based on database and process information extraction from <b>macro</b> files of heterogeneous commercial CAM platforms. First, analyzed the <b>macro</b> file characteristics of studied CAM system to build heterogeneous systems variables mapping table and establish standard <b>macro</b> file for each studied CAM systems; Second, designed <b>macro</b> file self-learning mechanism based on {{characteristics of the}} <b>macro</b> file, extracted implicit process information in <b>macro</b> files and saved to build General process Database; Finally, used the General process Database and the standard <b>macro</b> files to generate target <b>macro</b> files to achieve automatic programming. The process Information integration method in this research improved the efficiency and processing quality of NC machining, and made excellent process experience well inheritance and reuse...|$|R
40|$|This {{application}} helps programmers {{learn and}} use SAS ® <b>macro</b> definitions {{in a more}} efficient and structured manner than reading text from the <b>macro</b> program header. From one master file, the <b>macro</b> developer customizes one application file to each SAS <b>macro,</b> by defining each <b>macro</b> parameter and its attributes (e. g. mandatory/optional, default value …etc.). Then it’s used by any programmer to view the documentation associated with each <b>macro</b> parameter, input its value and verify the validity of all entered values. A warning list of potential problems is immediately displayed (e. g. invalid numeric value where a numeric value is expected, embedded comma …etc.). Thus, this application identifies the exact source of potential errors prior to submitting the <b>macro.</b> The application writes out the complete SAS code to execute the <b>macro,</b> which can be cut and pasted into any program. It can also launch a SAS session and directly submit the <b>macro...</b>|$|R
5000|$|In some {{languages}} {{the expansion}} of a <b>macro</b> {{does not need to}} correspond to textual code; rather than expanding to an expression containing the symbol , a <b>macro</b> may produce an expansion containing the actual object referred to by [...] Similarly if the <b>macro</b> needs to use local variables or objects defined in the <b>macro's</b> package, it can expand to an invocation of a closure object whose enclosing lexical environment is that of the <b>macro</b> definition.|$|R
25|$|Semantic colorization: Improved syntax coloring, various {{user-defined}} or default {{colors for}} C++ syntax such as <b>macros,</b> enumerations, typenames and functions.|$|E
25|$|Notepad being a {{basic text}} editor, {{advanced}} features are also missing: syntax coloring, code folding, regular expressions, <b>macros,</b> support of codepages and color schemes.|$|E
25|$|The basic {{operation}} of the REPL is as follows. This is a simplistic description which omits many elements of a real Lisp, such as quoting and <b>macros.</b>|$|E
50|$|ML/1 (<b>Macro</b> Language/One) is a {{powerful}} general purpose <b>macro</b> processor.|$|R
3000|$|... 2) are {{allocated}} to the <b>macro</b> edge users and pico interior users. Nevertheless, the <b>macro</b> edge users and pico edge users, especially the offloaded <b>macro</b> users, usually suffer severe interference from the neighboring <b>macro</b> BSs. To accomplish this, a power control factor β(0 <β< 1) is introduced to the sub-channel set C [...]...|$|R
50|$|If a <b>macro</b> {{includes}} {{the press of}} a key that has another <b>macro</b> programmed to it, the second <b>macro</b> will be ignored and the original function of the key will be programmed into the new <b>macro.</b> If a <b>macro</b> includes a key that has been remapped, the <b>macro</b> will be programmed with the remapped function of the key and not its original function. If a <b>macro</b> is too long to fit in the keyboard's memory, it will be truncated at {{the point that the}} keyboard ran out of programming memory. There is no upperbound limit to the length of a <b>macro</b> except the total free memory remaining in the keyboard, which is believed to be a maximum of 16 kilobits (2048 x 8 bits) based on the controller board's inclusion of an Atmel AT28C16 EEPROM chip.|$|R
