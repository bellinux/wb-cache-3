30|3|Public
5000|$|... "Malicious logic": In {{context of}} masquerade, any hardware, firmware, or {{software}} (e.g., Trojan horse) {{that appears to}} perform a useful or desirable function, but actually gains unauthorized access to system resources or tricks a user into executing other <b>malicious</b> <b>logic.</b>|$|E
50|$|The {{size of a}} Trojan is its {{physical}} extension {{or the number of}} components it is made of. Because a Trojan can consist of many components, the designer can distribute the parts of a <b>malicious</b> <b>logic</b> on the chip. The additional logic can occupy the chip wherever it is needed to modify, add or remove a function. If the function of the Trojan demands it, on the one hand malicious components can be scattered. This is called loose distribution. On the other hand, a Trojan can consist of only few components, so the area is small where the <b>malicious</b> <b>logic</b> occupies the layout of the chip. In contrast this is called tight distribution.|$|E
50|$|Built-in {{self-test}} (BIST) and Design For Test (DFT) techniques add circuitry (logic) to {{the chip}} {{intended to help}} verify that the chip, as built, implements its functional specification. The extra logic monitors input stimulus and internal signals or memory states, generally by computing checksums or by exposing internal registers via a customized scanning technique. Where DFT usually coordinates with some external testing mechanism, BIST-enabled chips incorporate custom test-pattern generators. BIST functionality often exists to perform at-speed (high speed) verification where {{it is not possible}} to use scan chains or other low-speed DFT capabilities. Both methods were originally developed to detect manufacturing errors, but also have the double-edged potential to detect some effects of <b>malicious</b> <b>logic</b> on the chip, or to be exploited by <b>malicious</b> <b>logic</b> to covertly inspect remote state within the chip.|$|E
30|$|During {{the past}} two decades, control-hijacking attacks have drawn {{tremendous}} attention from the computer security research community. In a control-hijacking attack, the adversary manipulates the control flow objects and shifts the execution to <b>malicious</b> <b>logics.</b> The earliest attacks hijack the control flow to execute injected code. To defend against those code-injection attacks, Data Execution Prevention (DEP) (The PaX Team 2003 a; Microsoft 2008) techniques were proposed. DEP ensures that a memory page is either writable or executable, but not both.|$|R
40|$|Abstract. Security {{protocols}} must {{be designed}} to ensure the integrity of electronic communications between participants. Although the design of secure communication protocols has improved {{over the years the}} tasks of building and validating these protocols remain inherently difficult. Security protocols may fail due to unintended use, <b>malicious</b> attacks, incorrect <b>logic</b> or incorrect transition from design to code. We present our research to investigate the use of UML 2 to model, verify and validate security protocols...|$|R
40|$|Abstract Most {{existing}} malicious Android app detection approaches rely on manually selected detection heuristics, features, and models. In this paper, {{we describe}} a new, complementary system, called DroidMiner, which uses static analysis to automatically mine <b>malicious</b> program <b>logic</b> from known Android malware, abstracts this logic into {{a sequence of}} threat modalities, and then seeks out these threat modality patterns in other unknown (or newly published) An-droid apps. We formalize a two-level behavioral graph representation used to capture Android app program logic, and design new techniques to identify and label elements of the graph that capture malicious behavioral patterns (or ma-licious modalities). After the automatic learning of these malicious behavioral models, DroidMiner can scan a new Android app to (i) determine whether it con-tains malicious modalities, (ii) diagnose the malware family {{to which it is}} most closely associated, (iii) and provide further evidence as to why the app is con-sidered to be malicious by including a concise description of identified malicious behaviors. We evaluate DroidMiner using 2, 466 malicious apps, identified from a corpus of over 67, 000 third-party market Android apps, plus an additional set of over 10, 000 official market Android apps. Using this set of real-world apps, we demonstrate that DroidMiner achieves a 95. 3 % detection rate, with only a 0. 4 % false positive rate. We further evaluate DroidMiner’s ability to classify malicious apps under their proper family labels, and measure its label accuracy at 92 %...|$|R
50|$|Risks include linking to {{dangerous}} web sites with browser exploits, enabling the microphone/camera/GPS, and then streaming those feeds {{to a remote}} server, analysis of sensitive data (passwords, files, contacts, transactions), and sending email/SMS/IM messages or DDOS packets {{as part of a}} botnet, corrupting privacy settings, stealing identity, and even containing <b>malicious</b> <b>logic</b> themselves such as JavaScript or a virus. These actions could occur in the background while the user is only seeing the reader opening a seemingly harmless web page. In Russia, a malicious QR code caused phones that scanned it to send premium texts at a fee of US$6 each.|$|E
50|$|Hardware Trojans can be {{triggered}} in different ways. A Trojan can be internally activated, {{that means it}} monitors one or more signals inside the IC. The malicious circuitry could wait for a count down logic an attacker added to the chip, so that the Trojan awakes after a specific time-span. The opposite is externally activated. There can be <b>malicious</b> <b>logic</b> inside a chip, that uses an antenna or other sensors the adversary can reach from outside the chip. For example, a Trojan could be inside the control system of a cruising missile. The owner of the missile does not know, that the enemy {{will be able to}} switch off the rockets by radio.|$|E
40|$|Techniques for threat {{analysis}} From security evaluation to security management Revision Outline Programming against security Techniques for {{threat analysis}} From security evaluation to security management Revision Malware ◮ Malware or <b>malicious</b> <b>logic</b> is code that intentionally {{sets out to}} violate a site’s security policy. Malware ◮ Malware or <b>malicious</b> <b>logic</b> is code that intentionally sets out to violate a site’s security policy. ◮ A Trojan horse is a program with an overt effect and a covert (usually malicious) effect. Trojans may be self-replicating. Malware ◮ Malware or <b>malicious</b> <b>logic</b> is code that intentionall...|$|E
40|$|Abstract—Hardware {{is just as}} {{susceptible}} as {{software to}} “hacker attacks”, through inclusion of malicious logic; {{and the consequences of}} such an attack could be disastrous! The impact of software viruses has been felt, at one time or another, by the entire computerized world, through loss of productivity, loss of system resources or data, or mere inconvenience. However, the nature of <b>malicious</b> <b>logic</b> and defending against it is fundamentally different from its software counterpart. <b>Malicious</b> <b>logic</b> has the added dimension of not being removable once encapsulated in the system. This paper will identify hardware vulnerabilities and will outline an automated method, called Structural Checking, to detect and prevent <b>malicious</b> <b>logic</b> from becoming incorporated into an ASIC, which could cause catastrophic system failure, security breaches, or other dire consequences. I...|$|E
40|$|The {{threat of}} attack by {{computer}} viruses is in reality {{a very small}} {{part of a much}} more general threat, specifically attacks aimed at subverting computer security. This paper examines computer viruses as <b>malicious</b> <b>logic</b> in a research and development environment, relates them to various models of security and integrity, and examines current research techniques aimed at controlling the threats viruses in particular, and <b>malicious</b> <b>logic</b> in general, pose to computer systems. Finally, a brief examination of the vulnerabilities of research and development systems that <b>malicious</b> <b>logic</b> and computer viruses may exploit is undertaken. 1. Introduction A computer virus is a sequence of instructions that copies itself into other programs {{in such a way that}} executing the program also executes that sequence of instructions. Rarely has something seemingly so esoteric captured the imagination of so many people; magazines from Business Week to the New England Journal of Medicine [39][48][60][72][135] [...] ...|$|E
40|$|Abstract—Kernel {{drivers are}} usually {{provided}} {{in the form of}} loadable kernel extensions, which can be loaded/unloaded dynamically at runtime and execute with the same privilege as the core operating system kernel. The unrestricted security access from the drivers to the kernel is nevertheless a double-edged sword that makes them susceptible targets of trojan attacks. Given a benign driver, it is now easy to implant <b>malicious</b> <b>logic</b> with existing hacking tools. Once implanted, such <b>malicious</b> <b>logic</b> is difficult to detect. In this paper we propose DRIP, a framework for detecting and eliminating <b>malicious</b> <b>logic</b> embedded in a kernel driver through iteratively eliminating unnecessary kernel API invocations from the driver. When provided with the binary of a trojaned driver, DRIP generates a purified driver with benign functionalities preserved and malicious ones eliminated. Our evaluation shows that DRIP successfully eliminates malicious effects of trojaned drivers in the system, with the purified drivers maintaining or even improving their performance over the trojaned drivers. Keywords—System Security; Kernel Drivers; Trojan Detection; I...|$|E
40|$|Techniques for threat {{analysis}} From security evaluation to security management Revision Outline Programming against security Techniques for {{threat analysis}} From security evaluation to security management Revision Malware ◮ Malware or <b>malicious</b> <b>logic</b> is code that intentionally {{sets out to}} violate a site’s security policy. Malware ◮ Malware or <b>malicious</b> <b>logic</b> is code that intentionally sets out to violate a site’s security policy. ◮ A Trojan horse is a program with an overt effect and a covert (usually malicious) effect. Trojans may be self-replicating. Malware ◮ Malware or <b>malicious</b> <b>logic</b> is code that intentionally sets out to violate a site’s security policy. ◮ A Trojan horse is a program with an overt effect and a covert (usually malicious) effect. Trojans may be self-replicating. ◮ A virus is a program that inserts itself into other files and then (usually) performs some action. Two phases: insertion and execution. Identified by Fred Cohen when {{a graduate student in}} 1983, named by his teacher Adleman. Malware ◮ Malware or <b>malicious</b> <b>logic</b> is code that intentionally sets out to violate a site’s security policy. ◮ A Trojan horse is a program with an overt effect and a covert (usually malicious) effect. Trojans may be self-replicating. ◮ A virus is a program that inserts itself into other files and then (usually) performs some action. Two phases: insertion and execution. Identified by Fred Cohen when a graduate student in 1983, named by his teacher Adleman. ◮ Many types of viruses (antivirus companies enjoy categorizations) : boot sector, application, TSR, multipartite, encrypted, polymorphic (designed to resist detection), macro. Malware ◮ Malware or <b>malicious</b> <b>logic</b> is code that intentionally sets out to violate a site’s security policy. ◮ A Trojan horse is a program with an overt effect and a covert (usually malicious) effect. Trojans may be self-replicating. ◮ A virus is a program that inserts itself into other files and then (usually) performs some action. Two phases: insertion and execution. Identified by Fred Cohen when a graduate student in 1983, named by his teacher Adleman. ◮ Many types of viruses (antivirus companies enjoy categorizations) : boot sector, application, TSR, multipartite, encrypted, polymorphic (designed t...|$|E
40|$|Virtualization is the {{predominant}} enabling technology of current cloud infrastructures and brings unique security benefits. Traditionally, researchers strive to include security components, such as intrusion detection, malware analysis, and integrity check, into underlying hypervisors. These hypervisor-based security approaches conduct only passive monitoring on the guest systems, but lack active protection mechanisms, i. e., patching the system vulnerabilities, eliminating the <b>malicious</b> <b>logic,</b> and shrinking the kernel attack surface, etc. ^ In {{order to achieve}} the security goals that are missing in existing hypervisor-based research efforts, we aim to expand {{the reach of the}} hypervisor to support active protection mechanisms. In this dissertation, we present a hypervisor-based security framework that consists of three key components, PROCESS-IMPLANTING, DRIP, and FACE-CHANGE to provide active protection at the level of user processes, kernel drivers, and OS kernels respectively, within guest virtual machines (VM). In particular, PROCESS-IMPLANTING enables on-demand implantation of general-purpose security tools directly from a hypervisor into a guest VM. The dynamic and stealthy nature of such security tools makes them harder to be predicted and detected by malicious adversaries. DRIP targets in-VM trojaned kernel drivers, which carry both benign and <b>malicious</b> <b>logic.</b> We conduct purification on such trojaned drivers to systematically deactivate the <b>malicious</b> <b>logic</b> and keep the benign logic intact. FACE-CHANGE minimizes the kernel attack surface within guest VMs at fine time-granularity. We achieve such kernel minimalism through dynamic switching of multiple application-specific minimized kernels at runtime. ^ From our evaluation results on both security and performance metrics, we demonstrate that PROCESS-IMPLANTING, DRIP, and FACE-CHANGE, can effectively provide active protection for the guest VM with minimum negative impact on the guest system execution. Furthermore, it is practical to deploy our security framework in the real-world cloud infrastructures considering its reasonable performance overhead. ...|$|E
40|$|Smartphones {{face the}} same threats as {{traditional}} computers. As long as a device has the capabilities to perform logic processing, the threat of running <b>malicious</b> <b>logic</b> exists. The only difference between security threats on traditional computers versus security threats on smartphones is the challenge to understand {{the inner workings of}} the operating system on different hardware processor architectures. To improve upon the security of smartphones, anomaly detection capabilities can be implemented at different functional layers of a smartphone in a coherent manner; instead of just looking at individual functional layers. This paper will focus on identifying conceptual points for measuring normalcy in different functional layers of a smartphone based on OKL 4 and LiMo Foundation’s platform architecture...|$|E
40|$|Similar to {{the effects}} of {{software}} viruses, hardware can also be compromised by introduction of <b>malicious</b> <b>logic</b> into circuits to cause unwanted system behaviors. This can be done by changing or adding internal logic, {{in such a way that}} it is undetectable using traditional testing and verification tools and techniques. Therefore, the user of the circuit needs to decide whether it can be trusted, i. e., it only performs functions defined in the original circuit specification (no more and no less), before employing it in the system. In this paper, a preliminary methodology is proposed to model potential hardware threats in order to determine a circuit’s trustability and provide guidance to malicious-logic checking tools. 1...|$|E
40|$|Within the {{hierarchy}} of the Software Defined Network (SDN) net-work stack, the control layer operates as the critical middleware fa-cilitator of interactions between the data plane and the network ap-plications, which govern flow routing decisions. In the OpenFlow implementation of the SDN model, the control layer, commonly re-ferred to as a network operating system (NOS), has been realized by a range of competing implementations that offer various per-formance and functionality advantages: Floodlight [11], POX [30], NOX [14], and ONIX [18]. In this paper we focus on the ques-tion of control layer resilience, when rapidly developed prototype network applications go awry, or third-party network applications incorporate unexpected vulnerabilities, fatal instabilities, or even <b>malicious</b> <b>logic.</b> We demonstrate how simple and common failures in a network application may lead to loss of the control layer, an...|$|E
30|$|In our attack scenario, {{either the}} {{attacker}} has a physical {{access to the}} victim machine and uses a malicious peripheral or a device of the victim machine is corrupted remotely. In the first case, the attack can be designed to be stealthy by construction (e.g., by hiding the <b>malicious</b> <b>logic</b> {{in addition to the}} implementation of the legitimate behavior). In the second case, two situations can be distinguished. If the corrupted device is configured by the kernel with identity mapping option, the attack will not be perceived by the victim. On the other hand, if it is not identity mapped, the corrupted driver will probably fail and the victim machine will have to be rebooted, though it would have been already permanently compromized. Nevertheless, the attacker can enforce the usage of identity mapping for the corrupted device using ACPI Reserved Memory Region Reporting Structures.|$|E
40|$|AbstractCode {{obfuscation}} {{was introduced}} {{as a viable}} technique to prevent reverse engineering of software applications. Obfuscation protects an application's key algorithms and data structures from theft by hackers. However, malware authors use the same techniques to create a malware or insert <b>malicious</b> <b>logic</b> into a legitimate application. This paper proposes an analysis system to detect lexical and string obfuscation in Java malware. We identify a set of eleven features that characterizes obfuscated code, {{and use it to}} train a machine learning classifier to distinguish between obfuscated and non-obfuscated malware. The features are extracted using a static analyzer that examines bytecode. Our experimental results based on a dataset of 375 malware samples containing 182927 strings and 12721 Java classes provide an accuracy of 99 %. The proposed features are effective even when a dictionary is employed for lexical obfuscation. We evaluated the robustness of our features by calculating chi-squared statistic for each feature...|$|E
40|$|AbstractAs the maliciousness and {{frequency}} of cyber-attacks continues to grow, the safety and security of cyber-physical critical infrastructures, such as manufacturing, is quickly becoming a significant concern across the globe. Outside of traditional intellectual property theft, attacks against manufacturing systems {{pose a threat to}} maintaining a product's design intent. More specifically, such attacks can alter a manufacturing system to produce a part incorrectly; resulting in impaired functionalities or reduced performance. Manufacturing systems rely heavily upon the use of quality control systems to detect quality losses and to ensure the continued production of high-quality parts. However, quality control systems are not designed to detect the effects of malicious attacks and are ill-suited to act as a cyber-security measure for many manufacturing systems. Therefore, this paper presents a novel product/process design approach to enable real-time attack detections to supplement the shortcomings of quality control systems. The proposed approach, inspired by side-channel schemes used to detect Trojans (foreign <b>malicious</b> <b>logic)</b> in integrated circuits, aims at detecting changes to a manufactured part's intrinsic behavior through the use of structural health monitoring techniques...|$|E
40|$|During a cyber-attack, {{an adversary}} executes {{offensive}} maneuvers to target computer systems. Particularly, an attacker often exploits a vulnerability within a program, hijacks control-flow, and executes malicious code. Data Execution Prevention (DEP), a hardware-enforced security feature, prevents an attacker from directly executing the injected malicious code. Therefore, attackers {{have resorted to}} code-reuse attacks, wherein carefully chosen fragments of code within existing code sections of a program are sequentially executed to accomplish <b>malicious</b> <b>logic.</b> Code-reuse attacks are ubiquitous and account for majority of the attacks in the wild. On one hand, due to the wide use of closed-source software, binary-level solutions are essential. On the other hand, without access to source-code and debug-information, defending raw binaries is hard. A majority of defenses against code-reuse attacks enforce ”control-flow integrity”, a program property that requires the runtime execution of a program to adhere to a statically determined control-flow graph (CFG) – a graph that captures the intended flow of control within the program. While defenses against code-reuse attacks have focused o...|$|E
40|$|<b>Malicious</b> <b>logic,</b> {{specifically}} worms cost network users {{an enormous}} amount of time and money. Worms, like Slammer and Code Red, infect thousands of systems and denied whole networks access to the Internet. This research examines the ability of the original Slammer worm, a Slammer based routing worm, and a new Single Slash Eight (SSE) routing worm to infect vulnerable systems within a given address space. The ability of Slammer to generate a uniform random IP addresses in a given address space is established. Finally, a comparison of the speed increase from a worm on a computing system in 2003 to those available today is performed. Both the Slammer based routing worm and the SSE routing worm spread faster than the original Slammer. The random number generator of the original Slammer worm generates a statistically uniform distribution of addresses within the range under test. Furthermore, despite the previous research into the speed of worm propagation, there is still a need to test worms on the current systems. The speed of the computing systems that the worms operated on in the past were more than three times slower than today’...|$|E
40|$|Success of {{the mission}} should {{be the focus of}} {{software}} and supply chain assurance activities regardless of what activity produces the risk. It does not matter if a malicious saboteur is the cause. It does not matter if it is <b>malicious</b> <b>logic</b> inserted at the factory or inserted through an update after fielding. It does not matter if it comes from an error in judgment or from a failure to understand how an attacker could exploit a software feature. Issues from bad software hygiene, like inadvertent coding flaws or weak architectural constructs are as dangerous to the mission as malicious acts. Enormous energies are put into hygiene and quality in the medical and food industries to address any source of taint. Similar energies need to be applied to software and hardware. Until both malicious and non-malicious aspects of taint can be dealt with in ways that are visible and verifiable there will be a continued lack of confidence and assurance in the delivered capabilities throughout their life-cycle. BACKGROUND Every piece of information and communications technology (ICT) hardware—this includes computers as well as any device that stores, processes, or transmits data—has an initiall...|$|E
40|$|Abstract—Hardware {{components}} {{can contain}} hidden backdoors, {{which can be}} enabled with catastrophic effects or for ill-gotten profit. These backdoors can be inserted by a malicious insider on the design team or a third-party IP provider. In this paper, we propose techniques {{that allow us to}} build trustworthy hardware systems from components designed by untrusted designers or procured from untrusted third-party IP providers. We present the first solution for disabling digital, designlevel hardware backdoors. The principle is that rather than try to discover the <b>malicious</b> <b>logic</b> in the design – an extremely hard problem – we make the backdoor design problem itself intractable to the attacker. The key idea is to scramble inputs that are supplied to the hardware units at runtime, making it infeasible for malicious components to acquire the information they need to perform malicious actions. We show that the proposed techniques cover the attack space of deterministic, digital HDL backdoors, provide probabilistic security guarantees, and can be applied {{to a wide variety of}} hardware components. Our evaluation with the SPEC 2006 benchmarks shows negligible performance loss (less than 1 % on average) and that our techniques can be integrated into contemporary microprocessor designs. Index Terms—hardware, security, performance, backdoors, trigger...|$|E
40|$|It is a {{well-known}} fact that design productivity is failing {{to keep pace with}} the big increase in the demands of applications and advanced silicon technology, especially in the domain of portable electronics. Moreover owing to the massive complexity of modern systems-on-chip (SoC), complete in-house development is impossible, and thus globalization of the design process has established itself as an inevitable solution for faster and efficient design. In this global design supply chain, the design of mobile computing devices relies heavily on reusable Intellectual Property (IP) cores as a practical solution. However, such IP cores are becoming increasingly vulnerable to malicious activities, attacks and threats. Any form of third party intervention in the design process can raise grave security concerns about the system. Security issues in IP’s can be in the form of IP piracy/IP counterfeit or embedded <b>malicious</b> <b>logic</b> or information leakage. The first form of security countermeasure requires anti-piracy methodologies that can nullify false claims of ownership or detect unauthorized pirated designs. The second form of threat, which is often called a ‘hardware Trojan’, is the deliberate insertion of illicit hardware into the IP design by a rogue designer or vendor, also requires detection/correction strategies as a security countermeasure...|$|E
40|$|Smartphones {{and mobile}} devices are rapidly {{becoming}} indispensable devices for many users. Unfortunately, they also become fertile grounds for hackers to deploy malware and to spread virus. There is {{an urgent need}} to have a "security analytic & forensic system" which can facilitate analysts to examine, dissect, associate and correlate large number of mobile applications. An effective analytic system needs to address the following questions: How to automatically collect and manage a high volume of mobile malware? How to analyze a zero-day suspicious application, and compare or associate it with existing malware families in the database? How to perform information retrieval so to reveal similar <b>malicious</b> <b>logic</b> with existing malware, and to quickly identify the new malicious code segment? In this paper, we present the design and implementation of DroidAnalytics, a signature based analytic system to automatically collect, manage, analyze and extract android malware. The system facilitates analysts to retrieve, associate and reveal malicious logics at the "opcode level". We demonstrate the efficacy of DroidAnalytics using 150, 368 Android applications, and successfully determine 2, 494 Android malware from 102 different families, with 342 of them being zero-day malware samples from six different families. To the best of our knowledge, this is the first reported case in showing such a large Android malware analysis/detection. The evaluation shows the DroidAnalytics is a valuable tool and is effective in analyzing malware repackaging and mutations...|$|E
40|$|Abstract—Most {{security}} mechanisms {{proposed to}} date unquestioningly place trust in microprocessor hardware. This trust, however, is misplaced and dangerous because microprocessors {{are vulnerable to}} insider attacks that can catastrophically compromise security, integrity and privacy of computer systems. In this paper, we describe several methods to strengthen the fundamental assumption about trust in microprocessors. By employing practical, lightweight attack detectors within a microprocessor, we show {{that it is possible}} to protect against <b>malicious</b> <b>logic</b> embedded in microprocessor hardware. We propose and evaluate two area-efficient hardware methods — TRUSTNET and DATAWATCH — that detect attacks on microprocessor hardware by knowledgeable, malicious insiders. Our mechanisms leverage the fact that multiple components within a microprocessor (e. g., fetch, decode pipeline stage etc.) must necessarily coordinate and communicate to execute even simple instructions, and that any attack on a microprocessor must cause erroneous communications between microarchitectural subcomponents used to build a processor. A key aspect of our solution is that TRUSTNET and DATAWATCH are themselves highly resilient to corruption. We demonstrate that under realistic assumptions, our solutions can protect pipelines and on-chip cache hierarchies at negligible area cost and with no performance impact. Combining TRUSTNET and DATAWATCH with prior work on fault detection has the potential to provide complete coverage against a large class of microprocessor attacks. 1 Index Terms—hardware security, backdoors, microprocessors, security based on causal structure and division of work...|$|E
40|$|Abstract—Smartphones {{and mobile}} devices are rapidly {{becoming}} indispensable devices for many users. Unfortunately, they also become fertile grounds for hackers to deploy malware. There is {{an urgent need}} to have a “security analytic & forensic system ” which can facilitate analysts to examine, dissect, associate and correlate large number of mobile applications. An effective analytic system needs to address the following questions: How to automatically collect and manage a high volume of mobile malware? How to analyze a zeroday suspicious application, and compare or associate it with existing malware families in the database? How to reveal similar <b>malicious</b> <b>logic</b> in various malware, and to quickly identify the new malicious code segment? In this paper, we present the design and implementation of DroidAnalytics, a signature based analytic system to automatically collect, manage, analyze and extract android malware. The system facilitates analysts to retrieve, associate and reveal malicious logics at the “opcode level”. We demonstrate the efficacy of DroidAnalytics using 150, 368 Android applications, and successfully determine 2, 494 Android malware from 102 different families, with 342 of them being zero-day malware samples from six different families. To the best of our knowledge, this is the first reported case in showing such a large Android malware analysis/detection. The evaluation shows the DroidAnalytics is a valuable tool and is effective in analyzing malware repackaging and mutations. I...|$|E
40|$|Traditional remote-server-exploiting malware {{is quickly}} {{evolving}} and {{adapting to the}} new web-centric computing paradigm. By leveraging the large population of (insecure) web sites and exploiting the vulnerabilities at client-side modern (complex) browsers (and their extensions), web-based malware becomes {{one of the most}} severe and common infection vectors nowadays. While traditional malware collection and analysis are mainly focusing on binaries, it is important to develop new techniques and tools for collecting and analyzing web-based malware, which should include a complete web-based <b>malicious</b> <b>logic</b> to reflect the dynamic, distributed, multi-step, and multi-path web infection trails, instead of just the binaries executed at end hosts. This paper is a first attempt in this direction to automatically collect web-based malware scenarios (including complete web infection trails) to enable fine-grained analysis. Based on the collections, we provide the capability for offline “live ” replay, i. e., an end user (e. g., an analyst) can faithfully experience the original infection trail based on her current client environment, even when the original malicious web pages are not available or already cleaned. Our evaluation shows that WebPatrol can collect/cover much more complete infection trails than state-of-the-art honeypot systems such as PHoneyC [11] and Capture-HPC [1]. We also provide several case studies on the analysis of web-based malware scenarios we have collected from a large national education and research network, which contains around 35, 000 web sites. Corresponding author...|$|E
40|$|The {{persistent}} {{evolution of}} malware intrusion brings great challenges to current anti-malware industry. First, the traditional signature-based detection and prevention schemes produce outgrown signature databases for each end-host user and user has {{to install the}} AV tool and tolerate consuming huge amount of resources for pairwise matching. At {{the other side of}} malware analysis, the emerging malware can detect its running environment and determine whether it should infect the host or not. Hence, traditional dynamic malware analysis can no longer find the desired <b>malicious</b> <b>logic</b> if the targeted environment cannot be extracted in advance. Both these two problems uncover that current malware defense schemes are too passive and reactive to fulfill the task. The goal of this research is to develop new analysis and protection schemes for the emerging malware threats. Firstly, this dissertation performs a detailed study on recent targeted malware attacks. Based on the study, we develop a new technique to perform effectively and efficiently targeted malware analysis. Second, this dissertation studies a new trend of massive malware intrusion and proposes a new protection scheme to proactively defend malware attack. Lastly, our focus is new P 2 P malware. We propose a new scheme, which is named as informed active probing, for large-scale P 2 P malware analysis and detection. In further, our internet-wide evaluation shows our active probing scheme can successfully detect malicious P 2 P malware and its corresponding malicious servers...|$|E
40|$|As a freely {{downloadable}} reference document, “Security in the Software Life Cycle: Making Application Development Processes – and Software Produced by Them – More Secure ” presents {{key issues}} in the security of software and its development processes. It introduces a number of process improvement models, risk management and development methodologies, and sound practices and supporting tools that {{have been reported to}} help reduce the vulnerabilities and exploitable defects in software and diminish the possibility that <b>malicious</b> <b>logic</b> and trap doors may be surreptitiously introduced during its development. No single practice, process, or methodology offers the universal silver bullet for software security. “Security in the Software Life Cycle ” has been compiled as a reference document with practical guidance intended to tie it together and inform software practitioners of a number of practices and methodologies from which they can evaluate and selectively adopt to reshape their development processes to increase not only the security but also the quality and reliability of their software applications, services, and systems, both in development and in deployment. In an era riddled with asymmetric cyber attacks, claims about system reliability, integrity and safety must also include provisions for built-in security of the enabling software. The Department of Homeland Security (DHS) Software Assurance Program has undertaken to partner with software practitioners in industry, government, and academia to increase the availability and use of tools, knowledge, and guidance that will help improve the security and quality of the software they produce. In addition to its BuildSecurityIn Web portal [1] an...|$|E
40|$|In DoD, DHS, the {{intelligence}} community, and other security-focused organizations, a frequently discussed supply chain threat to {{software is the}} rogue developer or distributor who embeds <b>malicious</b> <b>logic,</b> backdoors, or intentional vulnerabilities in source code or binary executables prior to releasing them to customers. (From here on “malicious code ” should be under-stood to refer collectively to all three types of inclusions.) The threat of counterfeiting is another concern, especially coun-terfeit integrated circuits and network devices, and increasingly software. Three factors drive this concern: (1) counterfeits are often found to be less dependable than the original products {{they are intended to}} copy; (2) counterfeiting occurs outside the legitimate supply chain, thus obscuring supply chain transparency and trace-ability of product, product pedigree, and product provenance; and (3) counterfeiting violates the IPR of the copied product’s legitimate vendor/developer and threatens their business viability. For software, the terms “counterfeiting ” and “piracy ” are often used interchangeably, so the distinction between them has become obscure. For purposes of this article, piracy means the act of illicitly distributing copies of software without a legitimate license. Counterfeiting means the substitution at any point in the supply chain of legitimate license-bearing software with an illicit replica. Counterfeit replicas are often modified or augmented, e. g., through removal of anti-tamper protections or insertion of malicious code, thus tying the first concern about malicious code with the second about illicit copies. Pirated software is sometimes, but not always, counterfeit. Sometimes it is directly copied without alteration...|$|E
40|$|Abstract. Success of {{the mission}} should {{be the focus of}} {{software}} and supply chain assurance activities regardless of what activity produces the risk. It does not matter if a malicious saboteur is the cause. It does not matter if it is <b>malicious</b> <b>logic</b> inserted at the factory or inserted through an update after fielding. It does not matter if it comes from an error in judgment or from a failure to understand how an attacker could exploit a software feature. Issues from bad software hygiene, like inadvertent coding flaws or weak architectural constructs are as dangerous to the mission as malicious acts. Enormous energies are put into hygiene and quality in the medical and food industries to address any source of taint. Similar energies need to be applied to software and hardware. Until both malicious and non-malicious aspects of taint can be dealt with in ways that are visible and verifiable, there will be a continued lack of confidence and assurance in delivered capabilities throughout their lifecycle. Bad Hygiene is as Dangerous to the Mission as Malicious Intent During the past several decades, software-based ICT capa-bilities have become the basis of almost every aspect of today’s cyber commerce, governance, national security, and recreation. Software-based devices are in our homes, vehicles, commu-nications, and toys. Unfortunately software, the basis of these cyber capabilities, can be unpredictable since there are now underlying rules software has to follow as opposed to the rest of our material world which is constrained by the laws of gravity, chemistry, and physics with core factors like Plank’s Constant. This is even more true given the variety and level of skills and training of those who create and evolve cyber capabilities. The result is that for the foreseeable future there will remain a need to address the types of quality and integrity problems that leave software unreliable, attackable, and brittle directly. This includes addressing the problems that allow malware and exploitable vulnerabilities to be accidentally inserted into products dur-ing development, packaging, or updates due to poor software hygiene practices. Computer language specifications are historically vague an...|$|E

