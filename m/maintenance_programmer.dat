19|54|Public
5000|$|The {{problem and}} {{modification}} analysis process, which is executed once the application {{has become the}} responsibility of the maintenance group. The <b>maintenance</b> <b>programmer</b> must analyze each request, confirm it (by reproducing the situation) and check its validity, investigate it and propose a solution, document the request and the solution proposal, and finally, obtain all the required authorizations to apply the modifications.|$|E
5000|$|When lexical scoping is used {{to infer}} , the use of [...] in code, while not illegal, may raise warning bells to a <b>maintenance</b> <b>programmer,</b> {{although}} there are still legitimate uses of [...] in this case, such as referring to instance variables hidden by local variables of the same name, or if the method wants to return {{a reference to the}} current object, i.e. , itself.|$|E
40|$|The {{research}} {{described in}} this thesis addresses itself {{to the problem of}} maintaining large, undocumented systems written in languages that contain a module construct. Emphasis is placed on developing techniques for analysing the code of these systems, thereby helping a <b>maintenance</b> <b>programmer</b> to understand a system. Techniques for improving the structure of a system are presented. These techniques help make the code of a system easier to understand. All the code analysis techniques {{described in this}} thesis involve reasoning with, and manipulating, graphical representations of a system. To help with these graph manipulations, a set of graph operations are developed that allow a <b>maintenance</b> <b>programmer</b> to combine graphs to create a bigger graph, and to extract subgraphs from a given graph that satisfy specified constraints. A relational database schema is developed to represent the information needed for inter-module code analysis. Pointers are given as to how this database can be used for inter-module code analysis...|$|E
5000|$|... 1992. Measuring and {{motivating}} <b>maintenance</b> <b>programmers.</b> With Jerome B. Landsbaum.|$|R
50|$|The best {{software}} developers {{understand the importance}} of communicating with people over communicating with the computer, according to Code Complete by Steve McConnell. On average, 85 percent of a programmer's time is spent communicating with people, while only 15 percent is spent communicating with the computer. <b>Maintenance</b> <b>programmers</b> spend 50 to 60 percent of their time trying to understand the code they have to maintain and a software program will have, on average, 10 generations of <b>maintenance</b> <b>programmers</b> in its lifetime.|$|R
40|$|GCC is {{considered}} {{more difficult to}} modify or debug than other programs of similar size. This paper will investigate {{the reasons for this}} difficulty, {{from the point of view}} of a maintenance programmer: someone producing a small patch to fix a bug or implement a feature, without causing new problems for unrelated use. Because the development tree’s head is expected to be functional at all times, such incremental changes are normal—even regular contributors are in the <b>maintenance</b> <b>programmer’s</b> shoes. ...|$|R
40|$|The Maintainer's Assistant is a code {{analysis}} tool {{aimed at}} helping the <b>maintenance</b> <b>programmer</b> to understand and modify a given program. Program transformation techniques are employed by the Maintainer's Assistant both to derive a specification from a section of code and to transform a section of code into a logically equivalent form. The general structure of the tool is described and two examples of the application of program transformations are given...|$|E
40|$|Abstract—Software {{systems that}} undergo {{repeated}} addi-tion of functionality commonly suffer {{a loss of}} quality in their underlying designs, termed design erosion. This leads {{to the maintenance of}} a system becoming increasingly difficult and time-consuming during its lifetime. Refactoring can reduce the effects of design erosion, but this process requires significant {{effort on the part of}} the <b>maintenance</b> <b>programmer.</b> Research into automated refactoring has had some success in reducing the effort involved, however source code refactoring uses refactoring steps that are too small to effect major design changes. Design-level refactoring is also possible, but these approaches operate on design models and do little to help in the subsequent refactoring of the source code. In this paper, we present a novel refactoring approach that refactors a program based both on its desired design and on its source code. The <b>maintenance</b> <b>programmer</b> first creates a desired design (a UML class model) for the software based on the current software design and their understanding of how it may be required to evolve. Then, the source code is refactored using the desired design as a target. This resulting source code has the same behavior as the original, but its design more closely correlates to the desired design. We conducted an investigation using several open source Java applications to determine how precisely it is possible to refactor program source code to a desired design. Our findings were that the original program could be refactored to the desired design with an accuracy of over 90 %, hence demonstrating the viability of automated refactoring using design differencing. Keywords-Search-based refactoring; automated design im-provement; design differencing; refactoring tool I...|$|E
40|$|The Environment for Application Software Integration and Execution (EASIE) {{provides}} both {{a methodology}} {{and a set}} of software utility programs to ease the task of coordinating engineering design and analysis codes. This document provides necessary information for installing the EASIE software on a host computer system. The target host is a DEX VAX running VMS version 4; host dependencies are noted when appropriate. Relevant directories and individual files are identified, and compile/load/execute sequences are specified. In the case of the data management utilities, database management system (DBMS) specific features are described in an effort to assist the <b>maintenance</b> <b>programmer</b> in converting to a new DBMS. The document also describes a sample EASIE program directory structure to guide the program implementer in establishing his/her application dependent environment...|$|E
40|$|This thesis {{presents}} a hypertext browser tool mainly for maintenance phase of software development. As the maintenance phase {{is the most}} costly and time-consuming phase in {{the whole process of}} software development and system evolution, our tool is aimed at providing support to <b>maintenance</b> <b>programmers</b> for better understanding of existing code and maintaining of large applications. With this tool, programmers can setup link between identifiers and their definitions, browse through source code, have easy access to definitions of any user defined identifiers and routines through hypertext, and inspect each occurrences of an identifier, which can be highlighted in browser window, of any file. But our tool {{is not limited to the}} maintenance phase activities. It can be used in any phases with text documentation, such as the important phases like the design and implementation phases. Our tool can also provide assistance to designers and developers by supporting documentation inspection. In this thesis, we surveyed software development environments and supporting tools. From our survey, we understand the development history and future directions in this area. This helps the design and implementation decisions of our tool. Some future applications of this tool are also discussed. Our tool will be more completed and helpful to <b>maintenance</b> <b>programmers</b> with these future enhancement. We believe this will brighten the future of our tool...|$|R
40|$|Look {{before you}} leap"; "a stitch in time saves nine"; "more haste, less speed". Many proverbs declare {{the wisdom of}} {{planning}} before doing. We suggest how to apply this to Excel, by explaining and specifying spreadsheets before coding them, so {{there will always be}} documentation for auditors and <b>maintenance</b> <b>programmers.</b> The specification method uses "pseudo-code": code that, for precision and conciseness, resembles a programming language, but is not executable. It is, however, based on the notation used by our Excelsior spreadsheet generator, which is executable. This paper is structured as a tutorial, in which we develop a simple cash-flow and loans spreadsheet. Comment: 12 Page...|$|R
40|$|Small {{changes can}} have major and nonlocal eects in objectoriented languages, {{due to the}} use of subtyping and dynamic dispatch. This complicates life for <b>maintenance</b> <b>programmers,</b> who need to x bugs or add {{enhancements}} to systems originally written by others. Change impact analysis provides feedback on the semantic impact of a set of program changes. This analysis can be used to determine the regression test drivers that are aected by a set of changes. Moreover, if a test fails, a subset of changes responsible for the failure can be identi ed, as well as a subset of changes that can be incorporated safely without aecting any test driver...|$|R
40|$|INTRODUCTION In {{a series}} of papers, Belady and Lehman [Belady & Lehman, 1976] pioneered {{the study of the}} {{evolution}} of software. They observed that over time, programs exhibit increasing entropy. As a program evolves, its structure degrades and its size increases, resulting in increased complexity. The increase in program entropy as it evolves makes program maintenance increasingly more difficult, and will ultimately result in the program dying and being replaced by another program, or the program undergoing a major and expensive overhaul. When making a modification to a piece of production software, a <b>maintenance</b> <b>programmer</b> must give some thought to the impact their changes will have on the entropy of the module. AD HOC PATCHES AND PLANNED, STRUCTURE PRESERVING MODIFICATIONS When changing a piece of code, a programmer may apply a "patch" that effects the desired change in program behavior, or alternatively restructure (perhaps even rewrite) t...|$|E
40|$|Legacy {{software}} {{represents a}} large investment for many {{organizations in the}} scientific community. The maintenance programmers, which keep these software systems operational are continually developing, modifying and updating code. In order to assist the <b>maintenance</b> <b>programmer</b> in understanding legacy software, it is desirable to have a software tool that can automate repetitive and computable tasks. Past research has often used the term “intelligent editor ” to describe this function This research project takes this direction further, it attempts to build an expert system that is able to understand segments of legacy software. The field of Program Understanding attempts to determine the function of a code segment with or without programmer intervention. This research analyses FORTRAN numerical analysis programs for common algorithm usage and other software characteristics. This paper discusses the problems identified by a cursory analysis of FORTRAN programs from the Collected Algorithms of the ACM...|$|E
40|$|In {{this paper}} a {{detailed}} methodology for automated reengineering of computer-based systems is presented. The methodology has evolved through application to {{portions of the}} AEGIS Weapons System. The methodology contains many enhancements over # 6 #, incorporating experience gained through the reengineering of the weapons selection module and the surface operations module of the Aegis Weapons System. Thus, as proof of concept, results of applying the methodology to the two components of the AEGIS Weapons System are also summarized. 1 Introduction Software maintenance consumes seventy to {{eighty percent of the}} budget in most large software organizations and the problem is escalating. One of the most wasteful practices that often accompanies large systems is the introduction of redundant code. Large systems that are in particular need of reverse engineering seldom have good traceability,thus a <b>maintenance</b> <b>programmer</b> does not know where to #nd modules that perform related functions. When ask [...] ...|$|E
40|$|Abstract—Program {{comprehension}} is {{the most}} time consuming activity during software <b>maintenance.</b> <b>Programmers</b> need support to help them in understanding large software systems. This paper presents an approach to extract useful knowledge from Java byte code, and apply hierarchical clustering to discover groups of closely related classes. The groups of classes can assist programmers to know the high level structure of large software systems without prior knowledge, and programmers can learn the classes in the same group together. The distance among classes is determined by considering their organizational structure and various kinds of couplings. A prototype system has been developed and evaluated using a medium and a large sized Java application. Keywords- Program comprehension, hieararchical clustering, Java, data minin...|$|R
40|$|The {{classical}} comprehension theories study {{relations between}} extensions, intensions, and names. Originally developed in linguistics and mathematics, these theories are applicable to program comprehension as well. While extensions {{are present in}} the program, the intensions are usually missing, and evolution and <b>maintenance</b> <b>programmers</b> have to recover them as the program cannot be successfully comprehended and changed without them. There are six fundamental processes of comprehension and they have several attributes that generate a large set of comprehension processes. One of these processes is concept location, which is a practical and theoretically interesting problem of program comprehension. Despite the current divergence among program comprehension processes, there is still a possibility that a universal program comprehension process will emerge sometime in the future. 1...|$|R
40|$|The {{importance}} of software documentation in maintenance work is widely acknowledged by {{those involved in}} the work. However, many new software projects axe still being produced with documentation that is inadequate for efficient support of the product following development. When a product enters the maintenance phase of its life-cycle, the need for quality documentation increases dramatically as it is common for the maintenance team to be composed of personnel who were not involved in the products development. This thesis surveys the tools available for supporting the production of software documentation and then proposes a tool, based on hypertext technology, that will enable <b>maintenance</b> <b>programmers</b> to efficiently create documentation about systems they are working on, where the existing documentation is unsatisfactory...|$|R
40|$|Object-oriented {{programming}} {{has brought}} many advantages to the software engineering community. Especially, the reuse of existing software components and application frameworks has improved the productivity in software development considerably. Now, the object-oriented programming paradigm has advanced {{in years and}} increasingly object-oriented software systems have to be maintained. Program comprehension {{plays a major role}} in software maintenance. Additionally, the increased reuse of software components, which is propagated and supported by object-oriented programming, necessitates the understanding of existing software during development and, thus, program comprehension becomes even more important. Very often the only information a <b>maintenance</b> <b>programmer</b> can trust is the source code. It is the only accurate, complete and up-to-date representation of a program. However, source code listings are hardly suited to representing design decisions, the global system structure, or the interactions among different system components. System documentation is necessary to enable reuse and maintenance of software components. It should remain valid as long as the software is being used. Nevertheless, system documentation i...|$|E
40|$|Abstract. The {{high cost}} of {{software}} maintenance could potentially be reduced by automatically improving the design of object-oriented programs without altering their behaviour. We have constructed a software tool capable of refactoring object-oriented programs to conform more closely to design quality models based {{on a set of}} metrics, by formulating the task as a search problem in the space of alternative designs. However, no consensus exists on a single quality model for object-oriented design, since the definition of ‘quality ’ can depend on the purpose, pedigree and perception of the <b>maintenance</b> <b>programmer.</b> We therefore demonstrate here the flex-ibility of our approach by automatically refactoring several Java programs to con-form with quality models based on the metric values of example programs. Results show that an object-oriented program can be automatically refactored to reduce its dissimilarity in terms of a set of design metrics to another program having some desirable trait, such as ease of maintenance...|$|E
40|$|To my father, {{mother and}} sister for their endless love and support I {{have yet to see}} any problem, however complicated, which, when you looked at it in the right way, did not become still more complicated. Poul Anderson (1926 - 2001) Science Fiction Writer It is well known that {{maintenance}} is the most expensive stage of the software life cycle. Most large real world software systems consist of {{a very large number of}} source code files. Important knowledge about different aspects of a software system is embedded in a rich set of implicit relationships among these files. Those relationships are partly reflected in system documentation at its different levels, but more often than not are never made explicit and become part of the expertise of system maintainers. Finding existing relations between source code components is a difficult task, especially in the case of legacy systems. When a <b>maintenance</b> <b>programmer</b> is looking at a piece of code in a source file, one of th...|$|E
40|$|Abstract. A {{management}} model for explaining software errors is developed and estimated. The model {{is used to}} analyze two years of error log data at a commercial site. The focus is on identifying managerially controllable factors which affect software reliability. At the research site, application systems which (1) underwent frequent modification; (2) were maintained by programmers {{with low levels of}} application experience; (3) had high reliability requirements, and (4) had high levels of static complexity all showed particularly high error rates, other things being equal. It is suggested that that managers can make quantified judgements about {{the degree to which they}} wish to reduce error rates by implementing a number of procedures, including enforcing release control, assigning more experienced <b>maintenance</b> <b>programmers,</b> and establishing and enforcing complexity metric standards...|$|R
40|$|This paper {{describes}} {{a case study}} that was carried out to characterize the behaviour of professional programmers, working on in-vivo software maintenance tasks, {{in terms of the}} cognitive levels of Bloom’s taxonomy. Specifically, it evaluates if their behaviour on specific maintenance sub-tasks can be associated with specific cognitive levels of the taxonomy. The findings suggest that some such relationships do exist. Indeed, several of the identified relationships are at the most cognitively-demanding levels of Bloom’s taxonomy. Allied with reports from other research in the domain of software maintenance, these relationships suggest that difficult sub-tasks within software maintenance are difficult, in part, because of the cognitive levels that programmers must work at when undertaking them. Thus, they suggest the nature of the support that should be offered to <b>maintenance</b> <b>programmers</b> involved in these tasks. 1...|$|R
40|$|As {{the size}} of {{software}} systems continues to grow, understanding the structure of these systems gets harder. This coupled with associated problems such as of lack of current documentation, and the limited or nonexistent availability of the original designers of the system, adds further di#culty to the job of software professionals {{trying to understand the}} structure of large and complex systems. The application of clustering techniques and tools to software systems helps software designers, developers, and <b>maintenance</b> <b>programmers</b> by recovering high-level views of system designs. In this paper we survey clustering approaches that have been developed by software engineering researchers. We also examine classical clustering techniques that have been applied in mathematics, science, and engineering, and investigate how these techniques have been adapted to work in the software domain. We conclude with a discussion of open research challenges related to software clustering...|$|R
40|$|This thesis {{surveys the}} {{activities}} performed in software maintenance and identifies {{some of the}} software tools which can be utilised by the <b>maintenance</b> <b>programmer.</b> The most expensive phase of software maintenance is surveyed in more detail and tools to support this activity are identified. A new class of cross referencer tool was designed and investigated. The novel aspect of the cross referencer {{is that it can}} be used on more than one language, by utihzing grammar driven generators to customize and make maximum re-use of the language independent components, allowing language specific implementations to be generated with minimal effort. The cross referencer also extends an idea of having different levels of detail in cross reference listings by allowing the tool implementor to specify the contents of each level of detail. A proposed experimental toolkit for the automatic construction of these cross referencer front end tools, from non procedural specifications, is designed and investigated...|$|E
40|$|The {{mechanisms}} {{described in}} this paper support a software engineering {{environment in which the}} transition from initial design through implementation and into maintenance is a smooth and continuous process. Two new datatypes, Nodule and Octopus, are presented. Nodules are templates containing compiled code and labelled typed locations, and are intended to support the interactive construction and evolution of applications. The major benefit of the Nodules over other systems is that they permit application systems to be generated that are complete, internally consistent and strongly type checked. The Octopus mechanism permits executable application systems to be evolved in situ. Using this mechanism, the information that was available to the application developer is accessible to the <b>maintenance</b> <b>programmer.</b> It also enables components of the application to be evolved or replaced, and reconnected to live data in a type safe manner. When combined into a single system, the Nodule and Octopus datatypes enable a rich collection of information about the structure and state of applications to be maintained and made available to programmers not only during the construction phase, but during the entire lifetime of applications. ...|$|E
40|$|The Geoscience Laser Altimeter System (GLAS) is {{the primary}} {{instrument}} for the ICESat (Ice, Cloud and Land Elevation Satellite) laser altimetry mission. ICESat was the benchmark Earth Observing System (EOS) mission for measuring ice sheet mass balance, cloud and aerosol heights, as well as land topography and vegetation characteristics. From 2003 to 2009, the ICESat mission provided multi-year elevation data needed to determine ice sheet mass balance as well as cloud property information, especially for stratospheric clouds common over polar areas. It also provided topography and vegetation data around the globe, {{in addition to the}} polar-specific coverage over the Greenland and Antarctic ice sheets. This document describes the detailed design of GLAS Science Algorithm Software (GSAS). The GSAS is used to create the ICESat GLAS standard data products. The National Snow and Ice Data Center (NSDIC) distribute these products. The document contains descriptions, flow charts, data flow diagrams, and structure charts for each major component of the GSAS. The purpose of this document is to present the detailed design of the GSAS. It is intended as a reference source to assist the <b>maintenance</b> <b>programmer</b> in making changes that fix or enhance the documented software...|$|E
40|$|During {{software}} <b>maintenance,</b> <b>programmers</b> {{spend a lot}} of time on code comprehension. Reading comments is {{an effective}} way for programmers to reduce the reading and navigating time when comprehending source code. Therefore, as a critical task in software engineering, code summarization aims to generate brief natural language descriptions for source code. In this paper, we propose a new code summarization model named CodeSum. CodeSum exploits the attention-based sequence-to-sequence (Seq 2 Seq) neural network with Structure-based Traversal (SBT) of Abstract Syntax Trees (AST). The AST sequences generated by SBT can better present the structure of ASTs and keep unambiguous. We conduct experiments on three large-scale corpora in different program languages, i. e., Java, C#, and SQL, in which Java corpus is our new proposed industry code extracted from Github. Experimental results show that our method CodeSum outperforms the state-of-the-art significantly...|$|R
40|$|This paper {{presents}} {{an approach to}} program comprehension in multi-language systems. Such systems are characterized by a high amount of source codes in various languages for programming, database definition and job control. Coping with those systems requires the references crossing the language boundaries to be analysed. Using the EER/GRAL approach to graph-based conceptual modeling, models representing relevant aspects of single language are built and integrated into a common conceptual model. Since conceptual modeling focusses on specific problems, the integrated model presented here is especially tailored to multi-language aspects. Software systems are parsed and represented according to this conceptual model and queried by using a powerful graph query mechanism. This allows multi-language cross references to be easily retrieved. The multi-language conceptual model and the query facilities have been developed {{in cooperation with the}} <b>maintenance</b> <b>programmers</b> at an insurance company w [...] ...|$|R
40|$|The {{ability to}} {{comprehend}} a program written by other individuals {{is becoming increasingly}} important in software development and maintenance. In an attempt to encourage undergraduate Computer Science students to write informative and usable documentation, the literate programming paradigm was incorporated into the teaching of one undergraduate Computer Science course at Augustana College. This paper describes the concept of literate programming, the experience of using literate programming to teach good programming practices, and {{the results from the}} experiment that showed that literate programming encourages more documentation. Introduction The ability to comprehend a program written by other individuals is becoming increasingly important in software development and maintenance. Studies have shown that 30 - 90 % of software expenditure is spent on maintaining existing software [15, 12]. Studies have also shown that <b>maintenance</b> <b>programmers</b> spend about half of their time studying the code [...] ...|$|R
40|$|The {{research}} in this thesis addresses the subject of regression testing. Emphasis is placed on developing a technique for selective revalidation {{which can be used}} during software maintenance to analyse and retest only those parts of the program affected by changes. In response to proposed program modifications, the technique assists the <b>maintenance</b> <b>programmer</b> in assessing the extent of the program alterations, in selecting a representative set of test cases to rerun, and in identifying any test cases in the test suite which are no longer required because of the program changes. The proposed technique involves the application of code analysis techniques and operations research. Code analysis techniques are described which derive information about the structure of a program and are used to determine the impact of any modifications on the existing program code. Methods adopted from operations research are then used to select an optimal set of regression tests and to identify any redundant test cases. These methods enable software, which has been validated using a variety of structural testing techniques, to be retested. The development of a prototype tool suite, which can be used to realise the technique for selective revalidation, is described. In particular, the interface between the prototype and existing regression testing tools is discussed. Moreover, the effectiveness of the technique is demonstrated by means of a case study and the results are compared with traditional regression testing strategies and other selective revalidation techniques described in this thesis...|$|E
40|$|Abstract—As energy {{efficiency}} {{has become a}} key consideration in the engineering of mobile applications, {{an increasing number of}} perfective maintenance tasks are concerned with optimizing energy consumption. However, optimizing a mobile application to reduce its energy consumption is non-trivial due to the highly volatile nature of mobile execution environments. Mobile applications commonly run on a variety of mobile devices over mobile networks with divergent characteristics. Therefore, no single, static energy consumption optimization is likely to yield across-the-board benefits, and may even turn to be detrimental in some scenarios. In this paper, we present a novel approach to perfective maintenance of mobile applications to reduce their energy consumption. The <b>maintenance</b> <b>programmer</b> declaratively specifies the suspected energy consumption hotspots in a mobile application. Based on this input, our approach then automatically transforms the application to enable it to offload parts of its functionality to the cloud. The offloading is highly adaptive, being driven by a runtime system that dynamically determines both the state-to-offload and its transfer mechanism based on the execution environment in place. In addition, the runtime system continuously improves its effectiveness due to a feedback-loop mechanism. Thus, our approach flexibly reduces the energy con-sumption of mobile applications behind the scenes. Applying our approach to third-party Android applications has shown that it can effectively reduce the overall amount of energy consumed by these applications, with the actual numbers ranging between 25 % and 50 %. These results indicate that our approach represents a promising direction in developing pragmatic and systematic tools for the perfective maintenance of mobile applications. I...|$|E
40|$|An {{accurate}} flowchart is {{an important}} part of the documentation for any computer program. The flowchart offers the user an easy to follow overview of program operation and the <b>maintenance</b> <b>programmer</b> an effective debugging tool. The TAMU FLOWCHART System was developed to flowchart any program written in the FORTRAN language. It generates a line printer flowchart which is representative of the program logic. This flowchart provides the user with a detailed representation of the program action taken as each program statement is executed. The TAMU FLOWCHART System should prove to be a valuable aid to groups working with complex FORTRAN programs. Each statement in the program is displayed within a symbol which represents the program action during processing of the enclosed statement. Symbols available include: subroutine, function, and entry statements; arithmetic statements; input and output statements; arithmetical and logical IF statements; subroutine calls with or without argument list returns; computed and assigned GO TO statements; DO statements; STOP and RETURN statements; and CONTINUE and ASSIGN statements. Comment cards within the source program may be suppressed or displayed and associated with a succeeding source statement. Each symbol is annotated with a label (if present in the source code), a block number, and the statement sequence number. Program flow and options within the program are represented by line segments and direction indicators connecting symbols. The TAMU FLOWCHART System should be able to accurately flowchart any working FORTRAN program. This program is written in COBOL for batch execution and has been implemented on an IBM 370 series computer with an OS operating system and with a central memory requirement of approximately 380 K of 8 bit bytes. The TAMU FLOWCHART System was developed in 1977...|$|E
40|$|The first {{activity}} {{performed by}} <b>maintenance</b> <b>programmers</b> when approaching {{the task of}} understanding a system is often trying to discover its high level structure, that is identifying its subsystems and their relations: in few words, the software architecture of the system. In this paper, an approach for the architectural analysis of software systems, together with an environment implementing the approach, are described. The approach {{is based on a}} hierarchical architectural model that drives the application of a set of architectural recognizers. Each recognizer builds an abstract view describing some architectural aspects of the system, or of some of its parts. The implementation of the environment supporting the architectural analysis process described is currently in progress. Keywords:program understanding, software architectures, reverse engineering, software visualization, user interface. 1 Introduction Understanding a software system may carry different meanings according to the [...] ...|$|R
5000|$|The Elements of Programming Style, by Brian W. Kernighan and P. J. Plauger, is a {{study of}} {{programming}} style, advocating the notion that computer programs should be written not only to satisfy the compiler or personal programming [...] "style", but also for [...] "readability" [...] by humans, specifically software <b>maintenance</b> engineers, <b>programmers</b> and technical writers.|$|R
40|$|Abstract: Program {{comprehension}} plays {{a crucial}} role during the software-development life cycle: <b>Maintenance</b> <b>programmers</b> {{spend most of their time}} with comprehending source code, and maintenance is the main cost factor in software development. Thus, if we can improve program comprehension, we can save considerable amount of time and cost. To improve program comprehension, we have to measure it first. However, program comprehension is a complex, internal cognitive process that we cannot observe directly. Typically, we need to conduct controlled experiments to soundly measure program comprehension. However, empirical research is applied only reluctantly in software engineering. To close this gap, we set out to support researchers in planning and conducting experiments regarding program comprehension. We report our experience with experiments that we conducted and present the resulting framework to support researchers in planning and conducting experiments. Additionally, we discuss the role of teaching for the empirical researchers of tomorrow. ...|$|R
