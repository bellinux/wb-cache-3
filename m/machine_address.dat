13|421|Public
5000|$|... each {{of which}} took a <b>machine</b> <b>address</b> as an argument, loaded the {{corresponding}} word from memory, and extracted the appropriate bits.|$|E
5000|$|An earlier form of base 32 {{notation}} {{was used}} by programmers working on the Electrologica X1 to represent machine addresses. The [...] "digits" [...] were represented as decimal numbers from 0 to 31. For example, 12-16 would represent the <b>machine</b> <b>address</b> 400 (= 12*32 + 16).|$|E
50|$|RealVNC {{uses the}} RFB protocol. It {{defaults}} to TCP port 5900. When making a connection over the Internet, the user must open this port {{in the local}} firewall as well as configure port forwarding to forward TCP Port 5900 (or the customized port respectively) to the local <b>machine</b> <b>address</b> if behind a NAT Router.|$|E
40|$|Authentication {{for access}} control {{procedures}} is usually based on the identity of participating entities. In some communications systems, identities are partially or wholly resolved using hostnames or <b>machine</b> <b>addresses</b> in the underlying protocol suite. Access control lists and revocation lists are often defined {{on the basis of}} hostnames, whereby the communication subsystem at runtime utilizes <b>machine</b> <b>addresses.</b> afte...|$|R
5000|$|Low-level {{access to}} {{computer}} memory is possible by converting <b>machine</b> <b>addresses</b> to typed pointers.|$|R
50|$|Sterling Elliott {{had invented}} the <b>addressing</b> <b>machine</b> to <b>address</b> his {{magazine}} wrappers in 1898. In 1909 Sterling Elliott asked {{his only son}} Harmon Elliott to become his partner at the Elliott <b>Addressing</b> <b>Machine</b> Company. Harmon accepted the position and took over management after Sterling's death on February 13, 1922 (Elliott 52).|$|R
5000|$|Identifiers (variables and constants) must be {{declared}} before use, typically using the [...] keyword. Declaring a variable normally causes the compiler to allocate space for it; when necessary, a variable may be assigned a fixed <b>machine</b> <b>address</b> via the [...] declaration. This feature is primarily used for accessing either machine registers or certain special addresses.|$|E
50|$|In {{local area}} {{networks}} where bus topology is used, each node {{is connected to}} a single cable, by the help of interface connectors. This central cable is {{the backbone of the}} network and is known as the bus (thus the name.) A signal from the source travels in both directions to all machines connected on the bus cable until it finds the intended recipient. If the <b>machine</b> <b>address</b> does not match the intended address for the data, the machine ignores the data. Alternatively, if the data matches the <b>machine</b> <b>address,</b> the data is accepted. Because the bus topology consists of only one wire, it is rather inexpensive to implement when compared to other topologies. However, the low cost of implementing the technology is offset by the high cost of managing the network. Additionally, because only one cable is utilized, it can be the single point of failure. In this topology data being transferred may be accessed by any workstation.|$|E
5000|$|If {{instead the}} {{parameters}} are passed by reference, then action on them within Silly does indeed affect the originals. This is usually done by passing the <b>machine</b> <b>address</b> of the parameters to the procedure {{so that the}} procedure's adjustments are to the original storage area.Thus {{in the case of}} call by reference, procedure Silly has an effect. Suppose that its invocations are expanded in place, with parameters identified by address: the code amounts to x:=7; b:=5; if x < 0 then a:=x + b else a:=-6; write(x); {a is changed.} if a < 0 then x:=a + b else x:=-6; write(x); {Because the parameters are swapped.} if b < 0 then b:=b + b else b:=-6; write(b); {Two versions of variable b in Silly, plus the global usage.}The compiler could then in this rather small example follow the constants along the logic (such as it is) and find that the predicates of the if-statements are constant and so... x:=7; b:=5; a:=-6; write(7); {b is not referenced, so this usage remains [...] "pure".} x:=-1; write(-1); {b is referenced...} b:=-6; write(-6); {b is modified via its parameter manifestation.}And since the assignments to a, b and x deliver nothing to the outside world - they do not appear in output statements, nor as input to subsequent calculations (whose results in turn do lead to output, else they also are needless) - {{there is no point in}} this code either, and so the result is write(7); write(-1); write(-6);A variant method for passing parameters that appear to be [...] "by reference" [...] is copy-in, copy-out whereby the procedure works on a local copy of the parameters whose values are copied back to the originals on exit from the procedure. If the procedure has access to the same parameter but in different ways as in invocations such as Silly(a,a) or Silly(a,b), discrepancies can arise. So, if the parameters were passed by copy-in, copy-out in left-to-right order then Silly(b,b) would expand into p1:=b; p2:=b; {Copy in. Local variables p1 and p2 are equal.} if p2 < 0 then p1:=p2 + b else p1:=-6; {Thus p1 may no longer equal p2.} b:=p1; b:=p2; {Copy out. In left-to-right order, the value from p1 is overwritten.}And in this case, copying the value of p1 (which has been changed) to b is pointless, because it is immediately overwritten by the value of p2, which value has not been modified within the procedure from its original value of b, and so the third statement becomes write(5); {Not -6}Such differences in behavior are likely to cause puzzlement, exacerbated by questions as to the order in which the parameters are copied: will it be left to right on exit as well as entry? These details are probably not carefully explained in the compiler manual, and if they are, they will likely be passed over as being not relevant to the immediate task and long forgotten by the time a problem arises. If (as is likely) temporary values are provided via a stack storage scheme, then it is likely that the copy-back process will be in the reverse order to the copy-in, which in this example would mean that p1 would be the last value returned to b instead.|$|E
50|$|Since the PDP-11 was an octal-oriented (3-bit sub-byte) <b>machine</b> (<b>addressing</b> modes 0-7, {{registers}} R0-R7), {{there were}} (electronically) 8 addressing modes. Through {{the use of}} the Stack Pointer (R6) and Program Counter (R7) as referenceable registers, there were 10 conceptual addressing modes available.|$|R
5000|$|IP Address Grabber Extender - Gets the <b>machine's</b> IP <b>Addresses.</b>|$|R
50|$|Addresses in {{the thread}} are the <b>addresses</b> of <b>machine</b> language. This form is simple, but may have {{overheads}} because the thread consists only of <b>machine</b> <b>addresses,</b> so all further parameters must be loaded indirectly from memory. Some Forth systems produce direct-threaded code. On many machines direct-threading is faster than subroutine threading (see reference below).|$|R
30|$|Because of the {{existence}} of hypervisor, there is an additional address translation during the process of guest virtual address to physical <b>machine</b> <b>address.</b> So we need to translate the virtual address of hypercall page into <b>machine</b> <b>address</b> to set traps and monitor all the hypercalls. This can be done with LibVMI, an open source virtual machine introspection library. LibVMI translates the L 1 address of hypercall entries into L 0 addresses. The basic idea of the approach is utilizing the xc_map_foreign_range function, provided by XenControl Library (libxl).|$|E
30|$|The {{hypervisor}} uses {{shadow page}} tables to convert a guest VM physical address to an actual <b>machine</b> <b>address.</b> Shadow page tables are accessible from the hypervisor {{and can be}} manipulated easily. The introspection code can be secured from guest VM-based applications using shadow tables and Intel VT technology features. Intel's VT support and virtual memory protection {{can be used to}} secure the monitoring code.|$|E
30|$|Running PV guests as an L 2 {{has been}} {{supported}} in Xen since the introduction of HVM guests in Xen 3.0 (He 2009). However, support for HVM guests as L 2 guests is heavily dependent on architecture-specific support. It is not until 2012 when Intel upgrades nested virtualization support with virtual EPT and virtual VT-d that nested HVM guests are fully supported (Zhang and Dong 2012). With virtual EPT support, guest memory address can be directly translated to <b>machine</b> <b>address</b> using shadow EPT in L 0 hypervisor, instead of two times of translation from virtual address to address in L 1 then to address in L 0. This greatly improved the performance and universality of nested virtualization.|$|E
40|$|We describeaprototype system {{capable of}} extracting <b>machine</b> print <b>addresses</b> from fax images of English {{language}} business letters and fax cover sheets. The system automatically orients incoming page images, locates and parses <b>machine</b> printed <b>addresses,</b> and classifies each address {{as one of}} fsender, recipient, otherg. Wepresent results of preliminary performance tests, and discuss potential improvements. ...|$|R
40|$|Authentication {{for access}} control {{procedures}} is usually based on the identity of participating entities. In some communications systems, identities are partially or wholly resolved using hostnames or <b>machine</b> <b>addresses</b> in the underlying protocol suite. Access control lists and revocation lists are often de ned {{on the basis of}} hostnames, whereby the communication subsystem at runtime utilizes <b>machine</b> <b>addresses.</b> After communications between two machines are established, hosts identify each other by their protocol addresses. To map this address to a high-level name, which can then be compared with access control or revocation lists to grant ordenyaccess, a resolution process is initiated. The abstraction from protocol addresses to high{level hostnames is necessary to hide details of heterogeneous communication subsystems, and of dynamic network con gurations from the application layer where a uniform, high-level naming scheme is desired. If cryptographic capabilities are used that identify subject-object interactions...|$|R
40|$|Authentication {{for access}} control {{procedures}} is usually based on the identity of participating entities. In some communications systems, identities are partially or wholly resolved using hostnames or <b>machine</b> <b>addresses</b> in the underlying protocol suite. Access control lists and revocation lists are often defined {{on the basis of}} hostnames, whereby the communication subsystem at runtime utilizes <b>machine</b> <b>addresses.</b> After communications between two machines are established, hosts identify each other by their protocol addresses. To map this address to a high [...] level name, which can then be compared with access control or revocation lists to grant or deny access, a resolution process is initiated. The abstraction from protocol addresses to high [...] level hostnames is necessary to hide details of heterogeneous communication subsystems, and of dynamic network configurations from the application layer where a uniform, high [...] level naming scheme is desired. If cryptographic capabilities are used that [...] ...|$|R
3000|$|A guest VM can be introspected from {{a privileged}} domain (Dom 0) {{associated}} with a Xen hypervisor [7]. Dom 0 is a control domain of Xen, and it provides access to every data structure, driver and library implemented by Xen. libxc is a control library for Xen. The memory of the guest VM can be monitored using the function xc_map_foreign_range (...), which belongs to the same library. A special high-performance disk driver named blktap made for Xen's paravirtualised guest VMs monitors disk access and data transfer. In {{the case of a}} guest VM, memory access needs to address translation from the virtual to the physical address and then again from the physical to the <b>machine</b> <b>address.</b> Xen has implemented shadow page tables for the same purpose. The introspection of a paravirtualised guest VM is possible using libxc, a blktap driver and the xen store library.|$|E
40|$|Many {{researchers}} have developed applications using transactional memory (TM) {{with the purpose}} of benchmarking different implementations, and studying whether or not TM is easy to use. However, comparatively little has been done to provide general-purpose tools for profiling and tuning programs which use transactions. In this paper we introduce a series of profiling techniques for TM applications that provide in-depth and comprehensive information about the wasted work caused by aborting transactions. We explore three directions: (i) techniques to identify multiple potential conflicts from a single program run, (ii) techniques to identify the data structures involved in conflicts by using a symbolic path through the heap, rather than a <b>machine</b> <b>address,</b> and (iii) visualization techniques to summarize how threads spend their time and which of their transactions conflict most frequently. To examine the effectiveness of the profiling techniques, we provide a series of illustrations from the STAMP TM benchmark suite and from the synthetic WormBench workload. We show how to use our profiling techniques to optimize the performance of the Bayes, Labyrinth and Intruder applications. We discuss the design and implementation of our techniques in the Bartok-STM system. We process data offline or during garbage collection, where possible, in order to minimize the probe effect introduced by profiling...|$|E
40|$|Many {{researchers}} have developed applications using transactional memory (TM) {{with the purpose}} of benchmarking different implementations, and studying whether or not TM is easy to use. However, comparatively little has been done to provide general-purpose tools for profiling and optimizing programs which use transactions. In this paper we introduce a series of profiling and optimization techniques for TM applications. The profiling techniques are of three types: (i) techniques to identify multiple potential conflicts from a single program run, (ii) techniques to identify the data structures involved in conflicts by using a symbolic path through the heap, rather than a <b>machine</b> <b>address,</b> and (iii) visualization techniques to summarize how threads spend their time and which of their transactions conflict most frequently. Altogether they provide in-depth and comprehensive information about the wasted work caused by aborting transactions. To reduce the contention between transactions we suggest several TM specific optimizations which leverage nested transactions, transaction checkpoints, early release and etc. To examine the effectiveness of the profiling and optimization techniques, we provide a series of illustrations from the STAMP TM benchmark suite and from the synthetic WormBench workload. First we analyze the performance of TM applications using our profiling techniques and then we apply various optimizations to improve the performance of the Bayes, Labyrinth and Intruder applications. We discuss the design and implementation of the profiling techniques in the Bartok-STM system. We process data offline or during garbage collection, where possible, in order to minimize the probe effect introduced by profiling. 1...|$|E
5000|$|According to Hypermedia Seduction for Terrorist Recruiting (2007), {{exploiting}} ICMP ping {{responses from}} broadcast addresses at multiple hosts sharing an Internet address, and forging the ping packet's return address to match a target <b>machine's</b> <b>address,</b> a single malformed packet {{sent to the}} [...] "smurf amplifier" [...] will be echoed to the target machine. This {{has been used to}} take over IRC servers.|$|R
50|$|Many Super-80 owners {{chose to}} modify their <b>machines</b> to <b>address</b> the {{limitations}} of the original machine.|$|R
50|$|UML state <b>machines</b> <b>address</b> {{exactly this}} {{shortcoming}} {{of the conventional}} FSMs. They provide a number of features for eliminating the repetitions so that the complexity of a UML state machine no longer explodes but tends to faithfully represent {{the complexity of the}} reactive system it describes. Obviously, these features are very interesting to software developers, because only they make the whole state machine approach truly applicable to real-life problems.|$|R
40|$|Transactional memory (TM) {{is a new}} optimistic {{synchronization}} technique {{which has}} the potential of making shared memory parallel programming easier compared to locks without giving up from the performance. This thesis explores four aspects in the research of transactional memory. First, it studies how programming with TM compares to locks. During the course of work, it develops the first real transactional application ¿ AtomicQuake. AtomicQuake is adapted from the parallel version of the Quake game server by replacing all lock-based synchronization with atomic blocks. Findings suggest that programming with TM is indeed easier than locks. However the performance of current software TM systems falls behind the efficiently implemented lock-based versions of the same program. Also, the same findings report that the proposed language level extensions are not sufficient for developing robust production level software and that the existing development tools such as compilers, debuggers, and profilers lack support for developing transactional application. Second, this thesis introduces new set of debugging principles and abstractions. These new debugging principles and abstractions enable debugging synchronization errors which manifest at coarse atomic block level, wrong code inside atomic blocks, and also performance errors related to the implementation of the atomic block. The new debugging principles distinguish between debugging at the language level constructs such as atomic blocks and debugging the atomic blocks based on how they are implemented whether TM or lock inference. These ideas are demonstrated by implementing a debugger extension for WinDbg and the ahead-of-time C# to X 86 Bartok-STM compiler. Third, this thesis investigates the type of performance bottlenecks in TM applications and introduces new profiling techniques to find and understand these bottlenecks. The new profiling techniques provide in-depth and comprehensive information about the wasted work caused by aborting transactions. The individual profiling abstractions can be grouped in three groups: (i) techniques to identify multiple conflicts from a single program run, (ii) techniques to describe the data structures involved in conflicts by using a symbolic path through the heap, rather than a <b>machine</b> <b>address,</b> and (iii) visualization techniques to summarize which transactions conflict most. The ideas were demonstrated by building a lightweight profiling framework for Bartok-STM and an offline tool which process and display the profiling data. Forth, this thesis explores and introduces new TM specific optimizations which target the wasted work due to aborting transactions. Using the results obtained with the profiling tool it analyzes and optimizes several applications from the STAMP benchmark suite. The profiling techniques effectively revealed TM-specific bottlenecks such as false conflicts and contentions accesses to data structures. The discovered bottlenecks were subsequently eliminated with using the new optimization techniques. Among the optimization highlights are the transaction checkpoints which reduced the wasted work in Intruder with 40 %, decomposing objects to eliminate false conflicts in Bayes, early release in Labyrinth which decreased wasted work from 98 % to 1 %, using less contentions data structures such as chained hashtable in Intruder and Genome which have higher degree of parallelism...|$|E
40|$|This work {{presents}} a robust technique, based on Krylov subspace method, for {{the reduction of}} large-scale state-space models arising in many electromagnetic applications in fusion machines. The proposed approach, built on the Arnoldi algorithm, aims at {{reducing the number of}} states of the system and lowering the computational effort, with a negligible loss of accuracy in the numerical solution. A detailed performance study is presented on an ITER-like <b>machine,</b> <b>addressing</b> both 2 D and 3 D problems...|$|R
40|$|An {{examination}} of Girard's execution formula suggests implementations of the Geometry of Interaction at the syntactic level. In this paper we limit our scope to groundtype terms {{and study the}} parallel aspects of such implementations, by introducing a family of abstract machines which can be directly implemented. These <b>machines</b> <b>address</b> all the important implementation {{issues such as the}} choice of an inter-thread communication model, and allow to incorporate specic strategies for dividing the computation of the execution path into smaller tasks. ...|$|R
5000|$|The product {{performs}} the migration over a network {{and creates a}} virtual machine (VM)-based environment on the target PC that presents an [...] "old computer" [...] view to the user - with applications, settings and data from the old computer. The user can switch between {{the old and new}} desktops, copying files and text. As with Windows XP Mode, migrated applications run inside a virtual <b>machine,</b> <b>addressing</b> compatibility issues - which are one of the top barriers to deploying Windows 7.|$|R
5000|$|Björn Guterstam critiques {{conventional}} {{wastewater treatment}} for five different inadequacies that living <b>machine</b> systems <b>address.</b> This evaluation explains {{the basis of}} his five points of contention: ...|$|R
40|$|Abstract. This paper {{proposes a}} method to perform class-specific feature {{selection}} in multiclass support vector <b>machines</b> <b>addressed</b> with the one-against-all strategy. The main issue arises at the final step of the classification process, where binary classifier outputs must be compared one against another to elect the winning class. This comparison may be biased towards one specific class when the binary classifiers are built on distinct feature subsets. This paper proposes a normalization of the binary classifiers outputs that allows fair comparisons in such cases. ...|$|R
50|$|Each Mighty Machines episode {{focuses on}} a {{specific}} type of heavy equipment or work environment. Documentary footage of actual machines in action doing their day-to-day work is presented with voiceovers of the <b>machines</b> <b>addressing</b> the viewers. The children in the audience are invited to follow the machines during a typical day. They explain their abilities and their duties in detail {{over the course of the}} episode. Each machine is given its own personality and they often hold conversations with one another as they work. Unlike most documentary-style shows, there is no external narrator.|$|R
5000|$|... /etc/dsniff/dnsspoof.hosts --> Sample hosts file.If no hostfile is specified, replies will {{be forged}} for all address queries on the LAN {{with an answer}} of the local <b>machine’s</b> IP <b>address.</b>|$|R
40|$|Jorge Sousa Pinto ? Departamento de Informatica Universidade do Minho Campus de Gualtar, 4710 - 057 Braga, Portugal jsp@di. uminho. pt Abstract. An {{examination}} of Girard's execution formula suggests implementations of the Geometry of Interaction at the syntactic level. In this paper we limit our scope to ground-type terms {{and study the}} parallel aspects of such implementations, by introducing a family of abstract machines which can be directly implemented. These <b>machines</b> <b>address</b> all the important implementation {{issues such as the}} choice of an interthread communication model, and allow to incorporate specic strategies for dividing the computation of the execution path into smaller tasks...|$|R
5000|$|In a prologue {{included}} with the released version, and in the film's trailer, porn director Gail Palmer sat by an editing <b>machine</b> <b>addressing</b> the audience and presented the film as X-rated. The release campaign implied that the original film was hardcore pornography, but that the material had now been edited into a milder version. However, {{the truth of this}} version has been repeatedly challenged, notably by trade journal AVN, which examined an original print, finding no trace of hardcore scenes. The [...] "Sylvester Stallone porno movie" [...] evolved over the years into a minor urban legend.|$|R
5000|$|... iFax machine → {{email message}} (over Internet) → iFax <b>machine</b> (using email <b>address)</b> ...|$|R
50|$|Contrast {{this with}} A {{records in the}} DNS, where a name {{translates}} to a <b>machine's</b> <b>address,</b> not including the port number that might be providing a service. Thus, if people are accustomed to using a particular machine name to access a particular service, their access will break when the service is moved to a different machine. This can be mitigated somewhat by insistence on using CNAME records indicating service rather than actual machine names {{to refer to the}} service, but {{there is no way of}} guaranteeing that users will follow such a convention. Some newer protocols, such as Kerberos and Active Directory use DNS SRV records to identify services by name, which is much closer to the AppleTalk model.|$|R
