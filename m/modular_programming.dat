256|589|Public
25|$|The OO {{principle}} {{is that all}} of the functions (and only the functions) that access the internal representation of a type should be encapsulated within the type definition. C++ supports this (via member functions and friend functions), but does not enforce it: the programmer can declare parts or all of the representation of a type to be public, and is allowed to make public entities that {{are not part of the}} representation of the type. Therefore, C++ supports not just OO programming, but other decomposition paradigms, like <b>modular</b> <b>programming.</b>|$|E
25|$|Procedural {{programming}} {{is a type}} of imperative programming in which the program is built from one or more procedures (also termed subroutines or functions). The terms are often used as synonyms, but the use of procedures has a dramatic effect on how imperative programs appear and how they are constructed. Heavily-procedural programming, in which state changes are localized to procedures or restricted to explicit arguments and returns from procedures, is a form of structured programming. From the 1960s onwards, structured programming and <b>modular</b> <b>programming</b> in general have been promoted as techniques to improve the maintainability and overall quality of imperative programs. The concepts behind object-oriented programming attempt to extend this approach.|$|E
500|$|One {{cause of}} {{spaghetti}} code was the [...] statement. Attempts to remove s from COBOL code, however, resulted in convoluted programs and reduced code quality. s were largely {{replaced by the}} [...] statement and procedures, which promoted <b>modular</b> <b>programming</b> and gave easy access to powerful looping facilities. However, [...] could only be used with procedures so loop bodies were not located where they were used, making programs harder to understand.|$|E
5000|$|Business programs: Full-Time Master's of Business Administration (MBA); Part-Time Executive MBA (22-month weekend program); IMM Global Executive MBA (20-month <b>modular</b> <b>program)</b> ...|$|R
50|$|Each {{individual}} university reserves {{the right}} to decide whether its <b>programs</b> are <b>modular</b> in nature, or compatible with other <b>modular</b> <b>programs</b> or program components.|$|R
40|$|The Nord Modular music synthesiser system {{comprises}} {{a stand-alone}} array of digital signal processors programmed by a dataflow visual langauage {{and supported by}} a visual programming environment that runs on commodity hardware. We have investigated applying program visualisation techniques to over 400 Nord <b>Modular</b> <b>programs.</b> Our visualisations make explicit module types and signal flows that are only implicit in the metaphorical graphical syntax adopted by the Nord <b>Modular</b> visual <b>programming</b> language. We have also analysed the programming style used in Nord <b>Modular</b> <b>programs,</b> in particular, the direction of program layouts. While we found that programs tended to arrange signal flow top down and left to right, we found much more variation than we expected, both within individual programs and across the Nord factory program corpus...|$|R
2500|$|Programming {{languages}} include {{features to}} help prevent bugs, such as static type systems, restricted namespaces and <b>modular</b> <b>programming.</b> For example, when a programmer writes (pseudocode) LET REAL_VALUE PI = [...] "THREE AND A BIT", although this may be syntactically correct, the code fails a type check. Compiled languages catch this without having to run the program. Interpreted languages catch such errors at runtime. Some languages deliberate exclude features that easily lead to bugs, {{at the expense of}} slower performance: the general principle being that, it is almost always better to write simpler, slower code than inscrutable code that runs slightly faster, especially considering that maintenance cost is substantial. For example, the Java programming language does not support pointer arithmetic; implementations of some languages such as Pascal and scripting languages often have runtime bounds checking of arrays, at least in a debugging build.|$|E
5000|$|<b>Modular</b> <b>programming,</b> in {{the form}} of {{subsystems}} (particularly for I/O) and software libraries, dates to early software systems, where it was used for code reuse. <b>Modular</b> <b>programming</b> per se, with a goal of modularity, developed in the late 1960s and 1970s, as a larger-scale analog of the concept of structured programming (1960s). The term [...] "modular programming" [...] dates at least to the National Symposium on <b>Modular</b> <b>Programming,</b> organized at the Information and Systems Institute in July 1968 by Larry Constantine; other key concepts were information hiding (1972) and separation of concerns (SoC, 1974).|$|E
5000|$|David Parnas (born 1941) {{developed}} {{the concept of}} information hiding in <b>modular</b> <b>programming.</b>|$|E
40|$|Context-sensitive {{analysis}} {{provides information}} which is potentially {{more accurate than}} that provided by context-free analysis. Such information can then be applied in order to validate/debug the program and/or to specialize the program obtaining important improvements. Unfortunately, context-sensitive analysis of <b>modular</b> <b>programs</b> poses important theoretical and practical problems. One solution, used in several proposals, is to resort to context-free analysis. Other proposals do address context-sensitive analysis, but are only applicable when the description domain used satisfies rather restrictive properties. In this paper, we argüe that a general framework for context-sensitive analysis of <b>modular</b> <b>programs,</b> Le., one that allows using all the domains which have proved useful in practice in the non-modular setting, is indeed feasible and very useful. Driven by our experience {{in the design and}} implementation of analysis and specialization techniques in the context of CiaoPP, the Ciao system preprocessor, in this paper we discuss a number of design goals for context-sensitive analysis of <b>modular</b> <b>programs</b> as well as the problems which arise in trying to meet these goals. We also provide a high-level description of a framework for analysis of <b>modular</b> <b>programs</b> which does substantially meet these objectives. This framework is generic in that it can be instantiated in different ways in order to adapt to different contexts. Finally, the behavior of the different instantiations w. r. t. the design goals that motivate our work is also discussed...|$|R
40|$|The Advanced Photon Source (APS) {{has taken}} a unique {{approach}} to creating high-level software applications for accelerator operation and analysis. The approach is based on self-describing data, <b>modular</b> <b>program</b> toolkits, and scripts. Self-describing data provide a communication standard that aids the creation of <b>modular</b> <b>program</b> toolkits by allowing compliant programs {{to be used in}} essentially arbitrary combinations. These <b>modular</b> <b>programs</b> can be used as part of an arbitrary number of high-level applications. At APS, a group of about 70 data analysis, manipulation, and display tools is used in concert with about 20 control-system-specific tools to implement applications for commissioning and operations. High-level applications are created using scripts, which are relatively simple interpreted programs. The Tcl/Tk script language is used, allowing creating of graphical user interfaces (GUIs) and a library of algorithms that are separate from the interface. This last factor allows greater automation of control by making it easy to take the human out of the loop. Applications of this methodology to operational tasks such as orbit correction, configuration management, and data review will be discussed. ...|$|R
40|$|<b>Modular</b> logic <b>{{programs}}</b> {{provide a}} way of viewing logic programs as consisting of many independent, meaningful modules. This paper introduces first-order <b>modular</b> logic <b>programs,</b> which can capture the meaning of many answer set programs. We also introduce conservative extensions of such programs. This concept helps to identify strong relationships between <b>modular</b> <b>programs</b> {{as well as between}} traditional programs. We show how the notion of a conservative extension can be used to justify the common projection rewriting. This note is under consideration for publication in Theory and Practice of Logic Programming. Comment: Paper presented at the 32 nd International Conference on Logic Programming (ICLP 2016), New York City, USA, 16 - 21 October 2016, 15 pages, LaTeX, 3 PDF figure...|$|R
5000|$|F {{places a}} heavy {{emphasis}} on <b>modular</b> <b>programming.</b> Modules in F are called [...] "programs": ...|$|E
5000|$|Linda Sue Rising: Information hiding metrics for <b>modular</b> <b>programming</b> languages, Doctoral Dissertation, Arizona State University, 1992 ...|$|E
50|$|In <b>modular</b> <b>programming,</b> {{modularity}} {{refers to}} the compartmentalization and inter-relation of the parts of a software package.|$|E
50|$|The ESMT Berlin Executive MBA {{started in}} autumn 2007. The part-time, <b>modular</b> <b>program</b> runs for 18 months, and {{graduates}} are awarded {{the degree of}} Master of Business Administration. The program is held in English. It focuses on international management and technology & innovation.|$|R
40|$|Several {{models for}} {{context-sensitive}} analysis of <b>modular</b> <b>programs</b> have been proposed, each with different characteristics and representing different trade-offs. The {{advantage of these}} context-sensitive analyses is that they provide information which is potentially more accurate than that provided by context-free analyses. Such information can then be applied to validating/debugging the program and/or to specializing the program {{in order to obtain}} important performance improvements. Some very preliminary experimental results have also been reported for some of these models which provided initial evidence on their potential. However, further experimentation, which is needed {{in order to understand the}} many issues left open and to show that the proposed modes scale and are usable in the context of large, real-life <b>modular</b> <b>programs,</b> was left as future work. The aim of this paper is two-fold. On one hand we provide an empirical comparison of the different models proposed in previous work, as well as experimental data on the different choices left open in those designs. On the other hand we explore the scalability of these models by using larger <b>modular</b> <b>programs</b> as benchmarks. The results have been obtained from a realistic implementation of the models, integrated in a production-quality compiler (CiaoPP/Ciao). Our experimental results shed light on the practical implications of the different design choices and of the models themselves. We also show that contextsensitive analysis of <b>modular</b> <b>programs</b> is indeed feasible in practice, and that in certain critical cases it provides better performance results than those achievable by analyzing the whole program at once, specially in terms of memory consumption and when reanalyzing after making changes to a program, as is often the case during program development...|$|R
40|$|<b>Modular</b> <b>program</b> {{with a small}} {{main program}} and several {{specialized}} subroutines provides a general purpose computer program to simulate the design, test and analysis phases of sensitivity experiments. This program allows {{a wide range of}} design-response function combinations and the addition, deletion, or modification of subroutines...|$|R
5000|$|... torchnet - Torch {{framework}} {{providing a}} set of abstractions aiming at encouraging code re-use as well as encouraging <b>modular</b> <b>programming</b> ...|$|E
50|$|MLton aims {{to produce}} fast executables, and to {{encourage}} rapid prototyping and <b>modular</b> <b>programming</b> by eliminating performance penalties often {{associated with the use}} of high-level language features.|$|E
50|$|The module {{software}} design pattern provides the features and syntactic structure {{defined by the}} <b>modular</b> <b>programming</b> paradigm to programming languages that have incomplete support for the concept.|$|E
40|$|Limitations of the monad stacks {{get in the}} way of {{developing}} highly <b>modular</b> <b>programs</b> with effects. This pearl demonstrates that Functional Programming’s abstractions are up to the challenge. Of course, abstraction must be followed by clever instantiation: Huet’s zipper for the monad stack makes components jump through unanticipated hoops...|$|R
50|$|The {{print manager}} program TurboPrint, by German firm IrseeSoft, is {{the de facto}} {{standard}} for advanced printing on the Amiga. It is a <b>modular</b> <b>program</b> with many drivers which support many modern printers. PrintStudio Professional I and II are another well known printer driver system for the Amiga.|$|R
40|$|Abstract. Limitations of monad stacks {{get in the}} way of {{developing}} highly <b>modular</b> <b>programs</b> with effects. This paper demonstrates that Functional Programming’s abstraction tools are up to the challenge. Of course, abstraction must be followed by clever instantiation: Huet’s zipper for the monad stack makes components jump through unanticipated hoops. ...|$|R
50|$|SiMPLE (a {{recursive}} acronym for SiMPLE <b>Modular</b> <b>Programming</b> Language & Environment) is a programming development {{system that was}} created to provide easy programming capabilities for everybody, especially non-professionals.|$|E
50|$|Various {{software}} package metrics {{are used in}} <b>modular</b> <b>programming.</b> They have been mentioned by Robert Cecil Martin in his 2002 book Agile software development: principles, patterns, and practices.|$|E
50|$|Supporting <b>modular</b> <b>programming,</b> Falcon {{ships with}} Feathers, the {{standard}} module suite, which integrates the built-in core module, containing the basic I/O and language-integrated base functions, classes and objects.|$|E
40|$|The {{interface}} {{and support}} performance, design and confirmation requirements are defined for the modular {{space station and}} space shuttle programs. The requirements are treated as separate obligations against each <b>modular</b> <b>program</b> and are presented for the following: shuttle orbiter, shuttle booster, launch operations, mission operations, and the research applications module...|$|R
40|$|We use on-line partial-evaluation {{technology}} to generate partial derivations from natural (big-step) semantics definitions. First, we reformat the big-step rules into a small-step form, and we extend big-step semantics to be higher-order, that is, we allow data structures like closures to contain partial derivations. Next, we apply a supercompilation algorithm to the transformed semantics, thereby producing partial derivations for programs and exposing the programs' control structures. The resulting system can perform static analysis on incomplete or "modular" programs {{and can do}} double duty as a link-time static analyzer; these are significant steps towards <b>modular</b> <b>program</b> analysis. Keywords: on-line partial evaluation, natural semantics, supercompilation, static analysis, <b>modular</b> <b>program</b> analysis. 1 Introduction Perhaps the most general form of declarative language is a deductive operational semantics framework, since the semantics of other languages can be encoded within deduct [...] ...|$|R
40|$|AbstractWe {{present a}} module {{language}} for PROLOG {{based on the}} theory of modularity underlying the Standard ML module system. The language supports the construction of hierarchically structured programs from parametrized components and provides a form of structural data abstraction. A formal semantics is given for the system which translates <b>modular</b> <b>programs</b> into conventional program...|$|R
50|$|Although the {{procedural}} and <b>modular</b> <b>programming</b> paradigms {{are often used}} together, there are cases where a procedural programming language may not fully support modules, hence requiring a design pattern implementation.|$|E
50|$|In {{software}} development, {{source code}} can be organized into components that accomplish a particular function or contain everything necessary {{to accomplish a}} particular task. <b>Modular</b> <b>programming</b> {{is one of those}} approaches.|$|E
50|$|In {{software}} engineering, {{the module}} pattern is a design pattern used {{to implement the}} concept of software modules, defined by <b>modular</b> <b>programming,</b> in a programming language with incomplete direct support for the concept.|$|E
40|$|Improperly {{designed}} interfaces {{can make}} <b>modular</b> <b>programs</b> almost indistinguishable from monoliths. An interface encapsulates design decisions {{only if it}} need not be changed when those design decisions are changed. This talk presents a principle for interface design and a procedure for applying that principle. The principle and procedure are illustrated {{with a variety of}} examples...|$|R
40|$|D We {{present a}} module {{language}} for PROLOG {{based on the}} theory of modularity underlying the Standard ML module system. The language supports the construction of hierarchically structured programs from parametrized components and provides a form of structural data abstraction. A formal semantics is given for the system which translates <b>modular</b> <b>programs</b> into conventional programs. a 1...|$|R
40|$|Limitations of monad stacks {{get in the}} way of {{developing}} highly <b>modular</b> <b>programs</b> with effects. This pearl demonstrates that Functional Programming’s abstraction tools are up to the challenge. Of course, abstraction must be followed by clever instantiation: Huet’s zipper for the monad stack makes components jump through unanticipated hoops. Categories and Subject Descriptors D. 1. 1 [Programming Techniques]...|$|R
