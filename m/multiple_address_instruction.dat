0|2151|Public
40|$|Reducing <b>address</b> {{arithmetic}} <b>instructions</b> by optimization {{of address}} offset assignment greatly improves {{the performance of}} DSP applications. However, minimizing address operations alone may not directly reduce code size and schedule length for multiple functional units DSPs. In this paper, we exploit address assignment and scheduling for application with loops on multiple functional units DSPs. Array transformation is used in our approach to leverage the indirect addressing modes provided {{by most of the}} DSP architectures. An algorithm, <b>Address</b> <b>Instruction</b> Reduction Loop Scheduling (AIRLS), is proposed. The algorithm utilizes the techniques of rotation scheduling, address assignment and array transformation to minimize both <b>address</b> <b>instructions</b> and schedule length. Compared to the list scheduling, AIRLS shows an average reduction of 35. 4 % in schedule length and an average reduction of 38. 3 % in <b>address</b> <b>instructions.</b> Compared to the rotation scheduling, AIRLS shows an average reduction of 19. 2 % in schedule length and 39. 5 % in the number of <b>address</b> <b>instructions...</b>|$|R
50|$|Also, a Harvard {{architecture}} {{machine has}} distinct code and data <b>address</b> spaces: <b>instruction</b> <b>address</b> zero {{is not the}} same as data <b>address</b> zero. <b>Instruction</b> <b>address</b> zero might identify a twenty-four bit value, while data address zero might indicate an eight-bit byte that is not part of that twenty-four bit value.|$|R
40|$|One of the {{important}} issues in embedded system design is to optimize program code for the microprocessor to be stored in ROM. In this paper, we propose an integrated approach to the DSP address code generation problem for minimizing the number of <b>addressing</b> <b>instructions.</b> Unlike previous works in which code scheduling and offset assignment are performed sequentially without any interaction between them, our work tightly couples offset assignment problem with code scheduling to exploit scheduling on minimizing <b>addressing</b> <b>instructions</b> more effectively. We accomplish this by developing a fast but accurate two-phase procedure which, for a sequence of code schedules, finds a sequence of memory layouts with minimum <b>addressing</b> <b>instructions.</b> Experimental results with benchmark DSP programs show improvements of 13 %- 33 % in the address code size over Solve-SOA/GOA [7]...|$|R
50|$|In this approach, {{the network}} is {{connected}} to multiple providers, and assigned <b>multiple</b> <b>address</b> ranges, one for each provider. Hosts are assigned <b>multiple</b> <b>addresses,</b> one for each provider.|$|R
40|$|A {{microprocessor}} system {{is provided with}} added memories to expand its address spaces beyond its address word length capacity by using indirect <b>addressing</b> <b>instructions</b> of a type having a detectable operations code and dedicating designated address spaces of memory {{to each of the}} added memories, one space to a memory. By decoding each operations code of instructions read from main memory into a decoder to identify indirect <b>addressing</b> <b>instructions</b> of the specified type, and then decoding the address that follows in a decoder to determine which added memory is associated therewith, the associated added memory is selectively enabled through a unit while the main memory is disabled to permit the instruction to be executed on the location to which the effective address of the indirect <b>address</b> <b>instruction</b> points, either before the indirect address is read from main memory or afterwards, depending on how the system is arranged by a switch...|$|R
5000|$|While {{multihoming}} with <b>multiple</b> <b>addresses</b> {{has been}} implemented for IPv4, {{it is not}} generally used, as host implementations do not deal well with <b>multiple</b> <b>addresses</b> per interface which {{requires the use of}} [...] "virtual interfaces".|$|R
25|$|Counter machine â€“ {{the most}} {{primitive}} and reduced theoretical {{model of a}} computer hardware. Lacks indirect <b>addressing.</b> <b>Instructions</b> are in the finite state machine {{in the manner of}} the Harvard architecture.|$|R
5000|$|<b>Multiple</b> <b>address</b> spaces. By {{implementing}} <b>multiple</b> virtual <b>address</b> spaces, {{each for}} a different user, each user could potentially have a private virtual machine.|$|R
5000|$|One of {{the reasons}} for the 8051s {{popularity}} is its range of operations on single bits. Bits are always specified by absolute addresses; there is no register-indirect or indexed <b>addressing.</b> <b>Instructions</b> that operate on single bits are: ...|$|R
40|$|This paper {{introduces}} the MoM- 3 as a reconfigurable accelerator for high performance computing {{at a moderate}} price. By using a new machine paradigm to trigger the operations in the MoM- 3, this accelerator is especially suited to scientific algorithms, where the hardware structure can be configured to match {{the structure of the}} algorithm. The MoM- 3 efficiently uses reconfigurable logic devices to provide a fine-grain parallelism, and <b>multiple</b> <b>address</b> generators to have the complete memory bandwidth free for data transfers (instead of fetching <b>address</b> computing <b>instructions).</b> Speed-up factors up to 82, compared to state-of-the-art workstations, are demonstrated by means of an Ising spin system simulation example. Adding the MoM- 3 as an accelerator allows to achieve supercomputer performance from a low-cost workstation. 1...|$|R
50|$|A Change <b>Address</b> Mode (CAM) <b>instruction</b> {{switched}} between 2-, 3- and 4-character {{address mode}}s.The address mode specified {{the number of}} characters needed for each operand <b>address</b> in <b>instructions.</b>|$|R
50|$|The {{instruction}} set implicitly subdivides the data format {{into the same}} fields as type A instructions: prefix, decrement, tag and <b>address.</b> <b>Instructions</b> exist to modify each of these fields in a data word without changing {{the remainder of the}} word.|$|R
40|$|PC {{instruction}} memory, {{fetch instruction}} Register numbers register file, read registers Depending on instruction class Use ALU to calculate Arithmetic result Memory address for load/store Branch target address Access data memory for load/store PC target address or PC + 4 3 Abstract / Simplified View Two types of functional units: elements that operate on data values (combinational) elements that contain state (sequential) 4 PC <b>address</b> <b>instruction</b> instruction memory data memory address data registers data register # register # register # ALU Abstract / Simplified View Cannot just join wires together Use multiplexers 5 PC <b>address</b> <b>instruction</b> instruction memory data memory address data registers data register # register # register # ALU Recall...|$|R
5000|$|... +------+ | nop | {{execute the}} {{following}} instruction +------+ [...] (Effective PC <b>address</b> = next <b>instruction</b> <b>address)</b> ...|$|R
5000|$|RFC 6824 - TCP Extensions for Multipath Operation with <b>Multiple</b> <b>Addresses</b> ...|$|R
50|$|Both {{classical}} multihoming and multihoming with <b>multiple</b> <b>addresses</b> {{may be used}} in IPv6.|$|R
5000|$|RFC 6181 - Threat Analysis for TCP Extensions for Multipath Operation with <b>Multiple</b> <b>Addresses</b> ...|$|R
50|$|The machine {{instructions}} can {{be grouped}} into six categories: accumulator instructions, branch instructions, memory reference <b>instructions,</b> <b>address</b> register <b>instructions,</b> scratchpad register instruction, miscellaneous instructions (interrupt, input, output, indirect scratchpad register, load, and store).|$|R
5000|$|Addressing modes include Immediate (operand in instruction), Direct or [...] "Symbolic" [...] (operand <b>address</b> in <b>instruction),</b> Register (operand in {{workspace}} register), Register Indirect (operand {{address in}} workspace register) {{with or without}} auto-increment, Indexed (operand <b>address</b> in <b>instruction</b> indexed with workspace register content), and Program Counter Relative.|$|R
50|$|With no byte <b>addressing</b> <b>instructions</b> at all, code had to {{be written}} to pack and shift {{characters}} into words. The very large words, and comparatively small amount of memory, meant that programmers would frequently economize on memory by packing data into words at the bit level.|$|R
5000|$|Multi-point driving {{directions:}} <b>Multiple</b> <b>addresses</b> can {{be entered}} and manually reordered for complex driving directions.|$|R
5000|$|Installations {{are divided}} into <b>multiple</b> <b>address</b> spaces {{for a wide variety}} of reasons, such as: ...|$|R
5000|$|... +----+------------------------------+ |jump| offset | jump {{relative}} +----+------------------------------+ [...] (Effective PC <b>address</b> = next <b>instruction</b> <b>address</b> + offset, offset may be negative) ...|$|R
5000|$|... +------+-----+-----+ |skipEQ| reg1| reg2| {{skip the}} {{following}} instruction if reg1=reg2 +------+-----+-----+ [...] (Effective PC <b>address</b> = next <b>instruction</b> <b>address</b> + 1) ...|$|R
50|$|In {{both the}} {{original}} version and 1A, clocks for Program Store and Call Store were operated out of phase, so one would be delivering data while the other was still accepting an <b>address.</b> <b>Instruction</b> decoding and execution were pipelined, to allow overlapping processing of consecutive instructions in a program.|$|R
50|$|Service Objects {{provides}} <b>multiple</b> <b>address</b> verification products, and email validation services via batch or real-time API.|$|R
5000|$|... {{then at the}} {{operating}} system level (to let system software access <b>multiple</b> <b>address</b> spaces and utilize larger address spaces) ...|$|R
5000|$|The {{instruction}} set implicitly subdivides the data format {{into the same}} fields as type A instructions: prefix, decrement, tag and <b>address.</b> <b>Instructions</b> exist to modify each of these fields in a data word without changing {{the remainder of the}} word though the Store Tag instruction was not implemented on the IBM 704.|$|R
2500|$|A {{centralised}} {{mail delivery}} station consisting of individual mailboxes for multiple recipients at <b>multiple</b> <b>addresses</b> {{in a particular}} neighborhood or community ...|$|R
5000|$|Mail notification: Enables {{the server}} to send emails to <b>{{multiple}}</b> <b>addresses.</b> It handles plain text and html message content format. It also can enclose multiple files.|$|R
5000|$|The ESA/370 {{architecture}} (later named ESA/390) made further extensions, {{including the}} addition of sixteen 32-bit access registers, more addressing modes, and various facilities for working with <b>multiple</b> <b>address</b> spaces simultaneously.|$|R
5000|$|An {{incrementing}} {{counter that}} {{keeps track of}} the memory <b>address</b> of the <b>instruction</b> {{that is to be}} executed next or in other words, holds the <b>address</b> of the <b>instruction</b> to be executed next.|$|R
50|$|The {{assignment}} procedure for global addresses {{is similar to}} local address construction. The prefix is supplied from router advertisements on the network. Multiple prefix announcements cause <b>multiple</b> <b>addresses</b> to be configured.|$|R
5000|$|Association setup: An {{association}} {{is a connection}} that is set up between two endpoints for data transfer, much like a TCP connection. A SCTP association can have <b>multiple</b> <b>addresses</b> at each end.|$|R
5000|$|Multihoming with <b>multiple</b> <b>addresses</b> {{has been}} {{implemented}} for IPv6. [...] For outgoing traffic, this requires {{support on the}} host, either protocol agnostic (Multipath TCP, SCTP, etc.) or specific to IPv6 (e.g. SHIM6).|$|R
40|$|This paper dev elops a new {{approach}} to compiling C programs for <b>multiple</b> <b>address</b> space, multi-processor DSPs. It integrates a nov el data transformation technique that exposes the processor location of partitioned data into a parallelization strategy. When this is combined with a new address resolution mechanism, it generates e#cient programs that run on <b>multiple</b> <b>address</b> spaces without using message passing. This approach is applied to the UTDSP benchmark suite and ev aluated on a four processor TigerSHARC board, where it is shown to outperform existing approaches and giv es an av erage speedup of 3. 25 on the parallel benchmarks...|$|R
