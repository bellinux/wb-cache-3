115|310|Public
5|$|In {{the uniform}} cost model (suitable for {{analyzing}} {{the complexity of}} gcd calculation on numbers that fit into a single <b>machine</b> <b>word),</b> {{each step of the}} algorithm takes constant time, and Lamé's analysis implies that the total running time is also O(h). However, in a model of computation suitable for computation with larger numbers, the computational expense of a single remainder computation in the algorithm can be as large as O(h2). In this case the total time for all of the steps of the algorithm can be analyzed using a telescoping series, showing that it is also O(h2). Modern algorithmic techniques based on the Schönhage–Strassen algorithm for fast integer multiplication can be used to speed this up, leading to quasilinear algorithms for the GCD.|$|E
25|$|While EPROMs {{had to be}} {{completely}} erased before being rewritten, NAND-type flash memory may be written and read in blocks (or pages) which are generally {{much smaller than the}} entire device. NOR-type flash allows a single <b>machine</b> <b>word</b> (byte) to be written to an erased location or read independently.|$|E
25|$|In computers, {{the main}} numeral systems {{are based on}} the {{positional}} system in base2 (binary numeral system), with two binary digits, 0 and 1. Positional systems obtained by grouping binary digits by three (octal numeral system) or four (hexadecimal numeral system) are commonly used. For very large integers, bases232 or 264 (grouping binary digits by 32 or 64, the length of the <b>machine</b> <b>word)</b> are used, as, for example, in GMP.|$|E
50|$|Since any {{computer}} {{data can}} be represented as one or more <b>machine</b> <b>words,</b> one generally needs hash functions for three types of domains: <b>machine</b> <b>words</b> ("integers"); fixed-length vectors of machine words; and variable-length vectors ("strings").|$|R
5000|$|Other office {{products}} such as dictation <b>machines,</b> <b>word</b> processors.|$|R
5000|$|The NAR 2 {{processor}} uses 32-bit <b>machine</b> <b>words.</b> Each <b>Machine</b> instruction contains: ...|$|R
500|$|... {{combinations}} of the parameters defining {{the number of}} items to be sorted, range of keys, and <b>machine</b> <b>word</b> size.|$|E
500|$|Time bounds for integer sorting {{algorithms}} typically {{depend on}} three parameters: the number [...] of data values to be sorted, the magnitude [...] {{of the largest}} possible key to be sorted, and the number [...] of bits that can be represented in a single <b>machine</b> <b>word</b> of the computer on which the algorithm is to be performed. Typically, {{it is assumed that}} that is, that machine words are large enough to represent an index into the sequence of input data, and also large enough to represent a single key.|$|E
500|$|The non-conservative packed sorting {{algorithm}} of [...] uses a subroutine, {{based on}} Ken Batcher's bitonic sorting network, for merging two sorted sequences of keys that are each short {{enough to be}} packed into a single <b>machine</b> <b>word.</b> The input to the packed sorting algorithm, a sequence of items stored one per word, {{is transformed into a}} packed form, a sequence of words each holding multiple items in sorted order, by using this subroutine repeatedly to double the number of items packed into each word. Once the sequence is in packed form, Albers and Hagerup use a form of merge sort to sort it; when two sequences are being merged to form a single longer sequence, the same bitonic sorting subroutine can be used to repeatedly extract packed words consisting of the smallest remaining elements of the two sequences. This algorithm gains enough of a speedup from its packed representation to sort its input in linear time whenever it is possible for a single word to contain [...] keys; that is, when [...] for some constant [...]|$|E
5000|$|... {{is number}} of <b>machine</b> <b>words</b> in a packet sent over the network.|$|R
5000|$|This {{section is}} {{concerned}} with hashing a fixed-length vector of <b>machine</b> <b>words.</b> Interpret the input as a vector [...] of [...] <b>machine</b> <b>words</b> (integers of [...] bits each). If [...] is a universal family with the uniform difference property, the following family (dating back to Carter and Wegman) also has the uniform difference property (and hence is universal): ...|$|R
5000|$|Word: Bitwise {{operations}} on unsigned integers (or <b>machine</b> <b>words).</b> Normally implemented {{directly by the}} compiler ...|$|R
2500|$|Because {{of their}} simplicity, text files are {{commonly}} used for storage of information. [...] They avoid {{some of the problems}} encountered with other file formats, such as endianness, padding bytes, or differences in the number of bytes in a <b>machine</b> <b>word.</b> Further, when data corruption occurs in a text file, it is often easier to recover and continue processing the remaining contents. [...] A disadvantage of text files is that they usually have a low entropy, meaning that the information occupies more storage than is strictly necessary.|$|E
50|$|ALGOL68 already {{included}} {{fixed length}} structures for efficient handling of characters and bit-data on word based machines, the bytes and bits modes. A bytes variable held one <b>machine</b> <b>word</b> of characters, a bits variable held {{the bits of}} one <b>machine</b> <b>word.</b>|$|E
50|$|A <b>machine</b> <b>word</b> {{could be}} {{reassembled}} by cons, which took four arguments (a,d,p,t).|$|E
50|$|Barrett {{initially}} {{considered an}} integer {{version of the}} above algorithm when the values fit into <b>machine</b> <b>words.</b>|$|R
5000|$|The <b>machine's</b> <b>word</b> size remains 16 bits, but its {{memory is}} now byte-addressable {{with the same}} address space.|$|R
5000|$|Multiply the key by the {{predetermined}} constant m. This operation actually requires two <b>machine</b> <b>words,</b> {{but this}} can still by done in constant time.|$|R
5000|$|... is the bandwidth, or time per <b>machine</b> <b>word</b> {{at which}} a {{processor}} can inject or receive [...] machine words from the network.|$|E
50|$|Endianness only {{applies to}} {{processors}} that allow individual addressing of units of data (such as bytes) that {{are smaller than}} the basic addressable <b>machine</b> <b>word.</b>|$|E
5000|$|Applying above exp-by-squaring algorithm, with [...] "*" [...] {{interpreted}} as x*y = xy mod 2345 (that is a multiplication {{followed by a}} division with remainder) leads to only 27 multiplications and divisions of integers which may all be stored in a single <b>machine</b> <b>word.</b>|$|E
3000|$|For the {{ordinary}} sizes of <b>machine</b> <b>words,</b> the coefficients of u and v are not relative primes. Below we list their common factors as k ranges through 0 to w: [...]...|$|R
30|$|One {{could think}} that 64 -bits need more {{iterations}} to get full distribution of bits, {{but the process}} above proved to have enough reserve that it still works adapted for long <b>machine</b> <b>words.</b>|$|R
50|$|Comparison is {{also very}} simple. Compare the high order digits (or <b>machine</b> <b>words)</b> until a {{difference}} is found. Comparing {{the rest of the}} digits/words is not necessary. The worst case is , but usually it will go much faster.|$|R
50|$|Where EPROMs {{had to be}} {{completely}} erased before being rewritten, NAND-type flash memory may be written and read in blocks (or pages) which are generally {{much smaller than the}} entire device. NOR-type flash allows a single <b>machine</b> <b>word</b> (byte) to be writtento an erased locationor read independently.|$|E
50|$|Leading zeros {{also present}} {{whenever}} {{the number of}} digits is technically fixed (such as in a memory register), but the stored value is not large enough {{to result in a}} non-zero most significant digit. The count leading zeros operation efficiently determines the number of leading zero bits in a <b>machine</b> <b>word.</b>|$|E
50|$|Therefore, {{the basic}} numbers used in {{computer}} algebra are the integers of the mathematicians, commonly represented by an unbounded signed {{sequence of digits}} in some base of numeration, usually the largest base allowed by the <b>machine</b> <b>word.</b> These integers allow to define the rational numbers, which are irreducible fractions of two integers.|$|E
25|$|The Attitude and Articulation Control System (AACS) is two 18-bit <b>word</b> <b>machines</b> with 4096 <b>words</b> each.|$|R
3000|$|... [...]. There {{are deep}} and age old open {{problems}} concerning Fermat numbers. Computational evidence supports the following conjecture, which is important, because {{the length of}} <b>machine</b> <b>words</b> in all practical cases is a power of 2 (8, 16, 32, 64...).|$|R
3000|$|The {{problems}} are easily seen by computing x + ROL(x, k) for all values of x, and sorting the results. For example, for w = 16 -bit <b>machine</b> <b>words,</b> and rotation by k = 3, {{the sequence of}} the sorted y values starts as: [...]...|$|R
50|$|Barrett's primary {{motivation}} for considering reduction was {{the implementation of}} RSA, where the values in question will almost certainly exceed {{the size of a}} <b>machine</b> <b>word.</b> In this situation, Barrett provided an algorithm that approximates the single-word version above but for multi-word values. For details see section 14.3.3 of the Handbook of Applied Cryptography.|$|E
5000|$|Note that [...] machine {{words is}} not the same thing as one <b>machine</b> <b>word.</b> A 32-bit vector would only suffice for sizes less than L(32) = 7049155. A 64-bit vector will do for sizes less than L(64) = 34335360355129 ≈ 245. In general, it takes 1/log2(φ) ≈ 1.44 bits of vector per bit of size.|$|E
50|$|During {{expression}} evaluation, {{and in both}} languages, a {{boolean value}} may be internally stored as a single bit, a single byte, a full <b>machine</b> <b>word,</b> {{a position in the}} generated code, or as a condition code in a status register, depending on machine, compiler, and situation; these factors are usually more important than the language compiled.|$|E
3000|$|... - 32)) mod 232 for x (assuming 32 -bit <b>machine</b> <b>words).</b> For many y values, {{there is}} no solution, or {{there are more than}} one {{possible}} x values. Therefore, we should better avoid these functions in counter mode, in hybrid counter mode of random number generators, or in ciphers.|$|R
30|$|Note {{that the}} {{function}} f could compute the modified counter k from a regular one i, as k = i·c mod 232 (in case of 32 -bit <b>machine</b> <b>words),</b> but we excluded multiplication from the admissible operations (because they need large hardware cores and multiple clock cycles at high clock frequencies).|$|R
30|$|We assume 32 -bit <b>machine</b> <b>words.</b> The {{smallest}} case is of stage- 2 : These {{random number}} generators have two parameters (which {{can be treated}} as two internal state variables), one is recursively updated by a mixing function, while the other one (an offset counter) is incremented by a large, odd constant before each call.|$|R
