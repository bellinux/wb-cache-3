2|1484|Public
50|$|A full {{featured}} development package {{would include}} a linker and a run-time support library. Usually a <b>machine</b> <b>oriented</b> <b>language</b> is required for writing the support library. C or C++ {{could be used as}} a <b>machine</b> <b>oriented</b> <b>language.</b> A library consisting of support functions required for the compilation process usually rounds out the full metacompiler package.|$|E
40|$|This {{report is}} {{one part of}} a series of {{documents}} describing the fully verified specification, construction and implementation of a ComLisp [...] compiler. ComLisp is a subset of ANSI-CommonLisp. Programs are systems of first order mutually recursive function and procedure definitions on dynamic Lisp data. ComLisp is both compiler source and implementation language. The work is part of the DFG research project Verifix on Correct Compilers. The major goal in Verifix is to develop methods for correct realistic compiler construction for practically relevant source languages and concrete target machines, and to completely verify them down to their binary machine code implementations. We specify a four-phase compilation transforming ComLisp [...] programs to binary machine code executables on transputer T 400 processors. The compilation is modularized to four steps using three intermediate languages, a stack language, a C-like abstract <b>machine</b> <b>oriented</b> <b>language,</b> and an assembly language. Compiling spe [...] ...|$|E
50|$|Mohol {{refers to}} <b>Machine</b> <b>Oriented</b> High Order <b>Languages</b> in Dijkstra's terminology.|$|R
5000|$|... "Application of the Machine-Oriented Language Epsilon to Software Development", I.V. Pottosin et al., in <b>Machine</b> <b>Oriented</b> Higher Level <b>Languages,</b> W. van der Poel, N-H 1974, pp. 417-434 ...|$|R
40|$|Pronoun {{resolution}} is an uncertain process in <b>machine</b> <b>oriented</b> natural <b>language</b> processing. There are many techniques {{to determine the}} referent of the pronoun. This paper addresses the resolution of two pronouns, &quot;they &quot; and &quot;them&quot;, and looks at simplistic rules to improve the process of determining the referent, beyond simply deciding {{on the basis of}} most recent plural noun...|$|R
50|$|ESPOL (short for Executive Systems Problem <b>Oriented</b> <b>Language)</b> was a superset of ALGOL 60 that {{provided}} capabilities {{of what would}} later be known as Mohols, <b>machine</b> <b>oriented</b> high order <b>languages,</b> such as interrupting a processor on a multiprocessor system (the Burroughs large systems were multiprocessor processor systems). It was used to write the MCP (Master Control Program) on Burroughs computer systems from the B5000 to the B6700. The single-pass compiler for ESPOL could compile over 250 lines per second.|$|R
40|$|Pronoun {{resolution}} is an uncertain process in <b>machine</b> <b>oriented</b> natural <b>language</b> processing. There are many techniques {{to determine the}} referent of the pronoun. This paper addresses the resolution of two pronouns, "they" and "them", and looks at simplistic rules to improve the process of determining the referent, beyond simply deciding {{on the basis of}} most recent plural noun. Introduction The majority of text being generated today is available in electronic form. The current advances in speech recognition provide potential access to a vast amount of additional text in electronic form. Automated processing of this text, to obtain information contained within the text and to allow content queries associated with the text, is desirable. The ability to extract information will require resolution of co-references over the entire discourse. Many of the current techniques identifying co-referents involve identification of phrases within sentences and applying template processes to the [...] ...|$|R
5000|$|APL A vector <b>oriented</b> <b>language</b> {{using an}} unusual {{character}} set ...|$|R
50|$|This {{design pattern}} applies to any class in any object <b>oriented</b> <b>language.</b>|$|R
5000|$|COmmon Business <b>Oriented</b> <b>Language</b> (COBOL) uses {{terms like}} file, move and copy.|$|R
40|$|Create a {{real-time}} language focusing on concurrency and parallelization, which can utilize {{the potential of}} a multiprocessor system:- Research what <b>language</b> features concurrency <b>oriented</b> <b>language</b> offer, and present them. - Investigate how the design of their run-time architecture support the concurrency <b>oriented</b> <b>language.</b> - Define {{a subset of the}} grammar to a concurrency <b>oriented</b> <b>language.</b> Limit the language to only include those mechanism necessary for demonstrating communication and concurrency mechanisms. - Create a compiler based on the defined grammar, and a scalable run-time system. - Investigate if dependency analysis can be utilized by a multiprocessor real-time scheduler. If possible implement a scheduler utilizing these principles...|$|R
40|$|This paper {{provides}} a general discussion of object-oriented computer languages. Deals with design {{and development of}} object <b>oriented</b> programming <b>languages,</b> and examines technical infrastructure for object oriented systems. Reviews the origins of object <b>oriented</b> <b>languages</b> from 1967 to 1988 in COBOL. Defines object <b>oriented</b> computer <b>languages,</b> such as "Smalltalk", class-less prototype-based <b>languages,</b> object <b>oriented</b> <b>language</b> derivatives, extensions of the JAVA language, and refers to the "beta" language. Refers to object-oriented methods {{which are based on}} experience, and defines a technical infrastructure, with reference to scheduling and synchronisation. Problems of object identity, referencing, aliasing and encapsulation, inheritance and modularisation. are listed. The increased use of inheritance and reusability is noted...|$|R
5000|$|COBOL (COmmon Business <b>Oriented</b> <b>Language),</b> a {{compiler}} for {{the well}} known business programming language.|$|R
5000|$|TOL (Time <b>Oriented</b> <b>Language)</b> is {{designed}} to model ARIMA models (including SARIMA, ARIMAX and DSARIMAX variants) https://www.tol-project.org/.|$|R
50|$|Data {{serialization}} <b>oriented</b> <b>languages</b> include Curl (homoiconic, {{but also}} reads JSON; every object serializes), JSON, OGDL, and YAML.|$|R
40|$|The {{theory of}} {{classification}} in object <b>oriented</b> <b>languages</b> are discussed. The differences between classes and types in object <b>oriented</b> <b>languages</b> are described by developing the alternative formal model of classification and inheritance. Extensibility and polymorphism {{are the two}} characteristics that hold classes apart from the traditional variable types. Classes are {{used to refer to}} a polymorphic family and types are used to refer one member of this family...|$|R
50|$|Some line <b>oriented</b> <b>languages</b> may {{support the}} use of a line {{continuation}} character, such as a backslash or tilde symbol.|$|R
50|$|Concurrent {{programming}} {{languages are}} programming languages that use language constructs for concurrency. These constructs may involve multi-threading, support for distributed computing, message passing, shared resources (including shared memory) or futures and promises. Such languages are sometimes described as Concurrency <b>Oriented</b> <b>Languages</b> or Concurrency <b>Oriented</b> Programming <b>Languages</b> (COPL).|$|R
40|$|This paper {{argues that}} object {{oriented}} distributed programming {{should not be}} about wrapping existing technologies with object oriented like interfaces nor should it be about hiding distribution behind classical abstractions of traditional (centralized) object <b>oriented</b> <b>languages.</b> Roughly speaking, object oriented distributed programming has {{very little to do}} with building a distributed object <b>oriented</b> <b>language</b> or system. The metaphor of a community of independent objects communicating through message passing should not hide the fact that distributed interaction is not local interactio...|$|R
40|$|The {{automation}} {{of first}} order logic has received comparatively little attention from researcher intent upon synthesizing the theorem proving mechanism used by humans. The dominant point of view [15], [18] has been that theorem proving on the computer should be oriented to {{the capabilities of the}} computer rather than to the human mind and therefore one should not be afraid to provide the computer with a logic that humans might find strange and uncomfortable. The preeminence of this point of view is not hard to explain since until now the most successful theorem proving programs have been <b>machine</b> <b>oriented.</b> Nevertheless, {{there are at least two}} reasons for being dissatisfied with the <b>machine</b> <b>oriented</b> approach. First, a mathematician often is interested more in understanding the proof of a proposition than in being told that the propositions true, for the insight gained from an understanding of the proof can lead to the proof of additional propositions and the development of new mathematical concepts. However, <b>machine</b> <b>oriented</b> proofs can appear very unnatural to a human mathematician thereby providing him with little if any insight. Second, the <b>machine</b> <b>oriented</b> approach has failed to produce a computer program which even comes close to equaling a good human mathematician in theorem proving ability; this leads one to suspect that perhaps the logic being supplied to the machine is not as efficient as the logic used by humans. The approach taken in this paper has been to develop a theorem proving program as a vehicle for gaining a better understanding of how humans actually prove theorems. The computer program which has emerged from this study is based upon a logic which appears more "natural" to a human (i. e., more human oriented). While the program is not yet the equal of a top flight human mathematician, it already has given indication (evidence of which is presented in section 9) that it can outperform the best <b>machine</b> <b>oriented</b> theorem provers...|$|R
50|$|In object <b>oriented</b> <b>languages</b> type {{safety is}} usually {{intrinsic}} {{in the fact}} a type system is in place. This is {{expressed in terms of}} class definitions.|$|R
40|$|Suppose one COTS (Commercial Off the Shelf) {{software}} supplier {{provides an}} interpreter for a problem <b>oriented</b> <b>language,</b> another provides an application generator for producing numerical solvers {{for a class}} of partial differential equations, and a third produces a visualization package. A team of domain specialists writes scripts in the problem <b>oriented</b> <b>language</b> to define cases to be solved, uses the application generator to produce an appropriate solver, solves the generated PDE, and uses the visualization package to analyze the results and adjust the description of cases...|$|R
50|$|HPE Unified Functional Testing runs {{primarily}} in Windows environments. It relies on largely obsolete Windows-only {{technologies such as}} ActiveX and VBScript which is not an object <b>oriented</b> <b>language.</b>|$|R
50|$|Presentation <b>oriented</b> <b>languages</b> include AsciiDoc, atx, BBCode, Creole, Crossmark, Epytext, Haml, JsonML, MakeDoc, Markdown, Org-mode, POD, reST, RD, Setext, SiSU, SPIP, Xupl, Texy!, Textile, txt2tags, UDO and Wikitext.|$|R
50|$|Although Scala had {{extensive}} support for functional programming from its inception, Java remained a mostly object <b>oriented</b> <b>language</b> until {{the inclusion of}} lambda expressions with Java 8 in 2014.|$|R
50|$|Mathematically <b>oriented</b> <b>languages</b> (such as on {{scientific}} calculators) sometimes allow implicit multiplication with higher priority than prefix operators (such as sin), so that sin 2x+1 = (sin(2x))+1, for instance.|$|R
40|$|We {{specify the}} dynamic {{semantics}} {{of an object}} <b>oriented</b> programming <b>language</b> in an incremental way. We begin with a simple language of arithmetic and boolean expressions. Then, we add functional abstractions, local declarations, references and assignments obtaining a functional language with imperative features. We finally add objects, classes and subclasses to obtain a prototypical object <b>oriented</b> <b>language</b> with dynamic binding...|$|R
5000|$|Silk Test Classic {{uses the}} domain {{specific}} 4Test language for automation scripting. It is an object <b>oriented</b> <b>language</b> similar to C++. It uses {{the concepts of}} classes, objects, and inheritance.|$|R
5000|$|Gellish, an {{industry}} standard natural <b>language</b> <b>oriented</b> modeling <b>language</b> for storage and {{exchange of data}} and knowledge, published in 2005 ...|$|R
5000|$|Some object <b>oriented</b> <b>languages</b> {{can do this}} {{thanks to}} the hosting virtual machine (e.g[...]NET CLI {{compliant}} languages in the Common Language Runtime and JVM compliant languages in the Java Virtual Machine).|$|R
5000|$|Ferguson, Charles. 1975 [...] "On sociolinguistically <b>oriented</b> <b>language</b> surveys." [...] From S. Ohannessian, C. Ferguson and E. Polome (eds.), Language {{surveys in}} {{developing}} nations, p. 1-5. Washington, D.C.: Center for Applied Linguistics.|$|R
50|$|TACPOL (Tactical Procedure <b>Oriented</b> <b>Language)</b> is a block {{structured}} programming language {{developed by the}} United States Army for the TACFIRE Tactical Fire Direction command and control application. TACPOL is similar to PL/I.|$|R
40|$|The paper {{shows the}} {{outlines}} of the SLAM system, that allows for an effective use of Formal Methods (FM) in Rapid Application Development (RAD) and other prototyping processes. The SLAM system, includes an expressive object <b>oriented</b> specification <b>language</b> and a development environment that, among other features, is able to generate efficient and readable code in a high level object <b>oriented</b> <b>language</b> (Java, C++, [...] .) ...|$|R
40|$|We {{introduce}} Jeeg, a dialect of Java {{based on}} a declarative replacement of the synchronization mechanisms of Java that results in a complete decoupling of the `business' and the `synchronization' code of classes. Synchronization constraints in Jeeg are expressed in a linear temporal logic which allows to eectively limit the occurrence of the inheritance anomaly that commonly affects concurrent object <b>oriented</b> <b>languages.</b> Jeeg is inspired by the current trend in aspect <b>oriented</b> <b>languages.</b> In a Jeeg program the sequential and concurrent aspects of object behaviors are decoupled: specified separately by the programmer these are then weaved together by the Jeeg compiler...|$|R
40|$|Recently, several {{descriptions}} of object <b>oriented</b> programming <b>languages</b> with denotational semantics have been given. Cook presented a denotational semantics of class inheritance. This semantics abstracts from the internal state of objects, {{which is one}} of their salient characteristics. In this paper we show that Cooks denotational semantics of class inheritance is applicable to object <b>oriented</b> programming <b>languages,</b> where objects have a state. For this purpose we define a direct denotational semantics of a small object <b>oriented</b> programming <b>language.</b> We claim that the resulting denotational semantics is clear and can serve the derivation of efficient implementations of object <b>oriented</b> programming <b>languages...</b>|$|R
5000|$|It is {{a central}} tenet of {{object-oriented}} analysis and design that subtype polymorphism, which is implemented in most object <b>oriented</b> <b>languages</b> via inheritance, {{should be used to}} model object types that are subsets of each other; this is commonly referred to as the is-a relationship. In the present example, the set of circles is a subset of the set of ellipses; circles can be defined as ellipses whose major and minor axes are the same length. Thus, code written in an object <b>oriented</b> <b>language</b> that models shapes will frequently choose to make [...] a subclass of , i.e. inheriting from it.|$|R
