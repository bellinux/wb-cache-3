4|1|Public
5000|$|Ezhil as a {{language}} - {{it is not a}} <b>macro-processor,</b> and it is a complete compiler-front-end ...|$|E
40|$|The dynamic {{prediction}} model {{along with its}} <b>macro-processor</b> capability and data flow system from the Drexel Limited-Area and Mesoscale Prediction System (LAMPS) were converted and recorded for the Perkin-Elmer 3220. The previous version of this model was written for Control Data Corporation 7600 and CRAY- 1 a computer environment which existed until recently at the National Center for Atmospheric Research. The purpose of this conversion was to prepare LAMPS for porting to computer environments other than that encountered at NCAR. The emphasis was shifted from programming tasks to model simulation and evaluation tests...|$|E
40|$|In {{this paper}} we present VoiceBuilder, a {{framework}} for automating {{the process of developing}} speech applications. Our framework allows speech User Interface (UI) specialists to introduce UI's in two ways: a stand-alone GUI application, and a web-based interface; in which speech UI's are stored in a markup language previously proposed called SUIML [1], supporting either system initiative or mixed initiative dialogue strategies. For automatic coding, we propose an algorithm based on a <b>macro-processor</b> that generates VoiceXML code by parsing SUIML documents. This algorithm was designed to generate various kinds of code with a minimal initial effort. We performed experiments considering both system initiative and mixed initiative dialogue strategies with three different speech applications: auto-attendant, e-mail reader, and flight reservations. VoiceBuilder is very useful for building speech applications in new domains, requires no programming effort and could be incorporated into several voice toolkits...|$|E
50|$|In computing, {{tombstone}} diagrams (or T-diagrams) {{consist of}} a set of “puzzle pieces” representing compilers and other related language processing programs. They are used to illustrate and reason about transformations from a source language (left of T) to a target language (right of T) realised in an implementation language (bottom of T). They are most commonly found describing complicated processes for bootstrapping, porting, and self-compiling of compilers, interpreters, and <b>macro-processors.</b>|$|R
40|$|The Maple {{system has}} been under {{development}} a the University of Waterloo since December 1980. The kernel {{of the system is}} written in a BCPL-like language. A <b>macro-processor</b> is used to generate code for severM implementation languages in the BCPL family (in particular, C). Maple provides interactive usage through: an interpreter for the user-oriented, higher-level, Maple programming language. This paper discusses Maple's current solution to several design issues. Maple attempts to provide a natural syntax nd semantics for symbolic mathematical computation i a cal-culator mode. The syntax of the Maple programming language borrows heavily from the Algol family. Full "recursive valuation " is uniformly applied to all expressions and to all parameters in function calls (with exceptions for only four basic system functions). Internally, Maple supports many types of objects: integers, li ts, sets, procedures, equa-tions, and power series, among others. Each internal type has its own tagged data struc-ture. "Dynamic vectors " are used as the fundamental memory allocation scheme. Maple maintains a unique copy of every expression and subexpression computed, employing hash-ing for efficient access. Another feature relying upon hashing is the "remembering " facility...|$|E

