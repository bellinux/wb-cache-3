15|167|Public
50|$|Contemporary {{processors}} {{incorporate a}} <b>mode</b> <b>bit</b> {{to define the}} execution capability of a program in the processor. This bit can be set to kernel mode or user mode. Kernel mode is also {{commonly referred to as}} supervisor mode, monitor mode or ring 0. In kernel mode, the processor can execute every instruction in its hardware repertoire, whereas in user mode, it can only execute a subset of the instructions. Instructions that can be executed only in kernel mode are called kernel, privileged or protected instructions to distinguish them from the user mode instructions. For example, I/O instructions are privileged. So, if an application program executes in user mode, it cannot perform its own I/O. Instead, it must request the OS to perform I/O on its behalf. The system may logically extend the <b>mode</b> <b>bit</b> to define areas of memory to be used when the processor is in kernel mode versus user mode. If the <b>mode</b> <b>bit</b> is set to kernel mode, the process executing in the processor can access either the kernel or user partition of the memory. However, if user mode is set, the process can reference only the user memory space. We frequently refer to two classes of memory user space and system space (or kernel, supervisor or protected space). In general, the <b>mode</b> <b>bit</b> extends the operating system's protection rights. The <b>mode</b> <b>bit</b> is set by the user mode trap instruction, also called a supervisor call instruction. This instruction sets the <b>mode</b> <b>bit,</b> and branches to a fixed location in the system space. Since only system code is loaded in the system space, only system code can be invoked via a trap. When the OS has completed the supervisor call, it resets the <b>mode</b> <b>bit</b> to user mode prior to the return.|$|E
50|$|A disk can {{be locked}} in two modes: High {{security}} mode or Maximum security <b>mode.</b> <b>Bit</b> 8 in word 128 of the IDENTIFY response shows which mode the disk is in: 0 = High, 1 = Maximum.|$|E
50|$|In {{the early}} {{instances}} {{of the architecture}} (System/360 and early System/370), the instruction address was 24 bits; in later instances (XA/370), the instruction address was 31 bits plus a <b>mode</b> <b>bit</b> (24 bit addressing mode if zero; 31 bit addressing mode if one) {{for a total of}} 32 bits.|$|E
25|$|M (bits 0–4) is the {{processor}} <b>mode</b> <b>bits.</b>|$|R
5000|$|Register {{settings}} {{that can not}} be altered during simulation such as <b>mode</b> <b>bits</b> or if part of the environment reg ...|$|R
5000|$|System mode (ARMv4 and above): The only {{privileged mode}} {{that is not}} entered by an exception. It can only be entered by {{executing}} an instruction that explicitly writes to the <b>mode</b> <b>bits</b> of the CPSR.|$|R
5000|$|First the FS-Zone1 data is {{recorded}} {{on the next}} writable address. To write the image following the FS-Zone1, the <b>mode</b> <b>bit</b> {{is set in the}} LabelTag mode page. The drive is now in LabelTag mode. The data in TAGWRITE commands contains the Label pixel data. The label starts on the Next Writable Address of the inserted disc. The application sends a SYNCHRONIZE CACHE to the drive to let the drive start the image burning. The application unsets the <b>mode</b> <b>bit</b> in the LabelTag mode page to let the drive go back in data write mode. Before the drive can add the FS-Zone2, the application has to inquire the Next Writable Address from the drive to know where the end address is of the Image Window. The application finishes the LabelTag writing by closing the Image Session.|$|E
5000|$|The {{multidrop}} bus used by {{vending machine}} controllers {{to communicate with}} the vending machine's components, such as a currency detector, is also called MDB (for MultiDropBus). In use since the 1980s, it is now an open standard of the National Automatic Merchandising Association, or NAMA. The devices communicate in a single-master, multiple-slave configuration using the MDB protocol, which is based on a Motorola 9-bit UART implemented as an 8-bit data value with an additional <b>mode</b> <b>bit.</b> The <b>mode</b> <b>bit</b> differentiates between ADDRESS and DATA bytes. The master sends messages containing one address byte and a variable number of data bytes. The bus [...] "slave devices" [...] listen for an address, and if it matches their address that slave device will process the message and respond to the master. [...] Though 9-bit compliant UARTs are not popular in PCs, they can be found in many microcontrollers.|$|E
50|$|On many computers, {{instructions}} that flip the user/system <b>mode</b> <b>bit,</b> the interrupt-enable bit, etc. implicitly specify the special register that holds those bits. This simplifies the hardware necessary to trap those instructions {{in order to}} meet the Popek and Goldberg virtualization requirements—on such a system, the trap logic does not need to look at any operand (or at the final effective address), but only at the opcode.|$|E
50|$|There {{are three}} screen <b>mode</b> <b>bits</b> (for {{a total of}} eight {{combinations}} / modes). However, TI only documented the four modes listed above, leaving the possibility of four other modes. Two of these modes produce nothing of value, however, two produce useful results.|$|R
50|$|The status {{register}} contains various <b>mode</b> <b>bits,</b> but the processor {{does not have}} the standard ALU result flags like carry, zero, negative or overflow. Add and subtract with carry instructions exist, but specify five operand registers: two inputs and input carry, and one output and output carry.|$|R
25|$|The {{designers}} {{attempted to}} make the assembly language orthogonal. That is, instructions are divided into operations and address modes, and almost all address modes are available for almost all instructions. There are 56 instructions and a minimum instruction size of 16 bits. Many instructions and addressing modes are longer to include additional address or <b>mode</b> <b>bits.</b>|$|R
50|$|The Set Path Group ID command, {{with the}} dynamic path {{selection}} (DPS)function, provides greater flexibility in operations on reserved devices.Once a path group for a device has been established, {{it may be}} accessedover any path which {{is a member of}} the group to which it is reserved. Inaddition, on 370-XA systems which set the multipath <b>mode</b> <b>bit</b> in thefunction control byte (byte 0) to a 1, block multiplex reconnections willoccur on the first available path which {{is a member of the}} group over whichthe channel program was initiated (regardless of the reservation state of thedevice).|$|E
50|$|Such {{an example}} is that the S/370 {{architecture}} specifies that the 64-bit PSW register bit number 32 has to be set to 0 and that doing otherwise leads to an exception. Subsequently, when the S/370-XA architecture was defined, it was stated that this bit would indicate whether the program was a program expecting a 24-bit address architecture or 31-bit address architecture. Thus, most programs that ran on the 24-bit architecture can still run on 31-bit systems; the 64-bit z/Architecture has an additional <b>mode</b> <b>bit</b> for 64-bit addresses, so that those programs, and programs that ran on the 31-bit architecture, can still run on 64-bit systems.|$|E
50|$|Certain machine {{instructions}} in this 31-bit addressing mode alter the addressing <b>mode</b> <b>bit</b> as a possibly intentional side effect. For example, the original subroutine call instructions BAL, Branch and Link, and its register-register equivalent, BALR, Branch and Link Register, store certain status information, the instruction length code, the condition code {{and the program}} mask, in the top byte of the return address. A BAS, Branch and Store, instruction was added to allow 31-bit return addresses. BAS, and its register-register equivalent, BASR, Branch and Store Register, {{was part of the}} instruction set of the System/360 Model 67, which was the only System/360 model to allow addresses longer than 24 bits. These instructions were maintained, but were modified and extended for 31-bit addressing.|$|E
50|$|<b>Mode</b> {{selection}} <b>bits,</b> D2, D5, D6 are all 0 for mode 0 operation.|$|R
5000|$|When <b>Mode</b> <b>bits</b> are all zero ANTIC {{performs}} no playfield DMA {{and displays}} {{one or more}} blank scan line(s) of the background color. For normal color interpretation modes the [...] "background" [...] is color register COLBK ($D01Ahex/53274dec) OS Shadow COLOR4 ($02C8hex/712dec), though this differs for the GTIA color interpretation modes. See discussion of COLBK on the GTIA page for more information.|$|R
50|$|In fact, {{because the}} program counter is always word-aligned the lowest two bits are always zero which allowed the {{designers}} to reuse these two bits {{to hold the}} processor's <b>mode</b> <b>bits</b> too. The four modes allowed were USR26, SVC26, IRQ26, FIQ26; contrast this with the 32 possible modes available when the program status was separated from the program counter in more recent ARM architectures.|$|R
40|$|Testing {{was carried}} out in the Engineering Testing Laboratory, 305 Building- 300 Area, during June, July and August of 1996. This testing was to develop and proof test a new sampler insert which would prevent purge gas from flowing through a push-mode core {{drilling}} bit - and subsequently prevent rotation of the Rotary Mode Core Sampling System (RMCSS) when the push bit was used. The testing involved push-mode sampling with both a new push mode insert and a rotary insert in a push <b>mode</b> <b>bit</b> into two simulants. A total of sixty final test runs showed that the inserts are sucessful in preventing purge flow and hence in preventing rotation with a push-mode bit installed...|$|E
40|$|The {{design and}} {{performance}} of a rain fade simulation/counteraction system on a laboratory simulated 30 / 20 GHz, time division multiple access (TDMA) satellite communications testbed is evaluated. Severe rain attenuation of electromagnetic radiation at 30 / 20 GHz occurs due to the carrier wavelength approaching the water droplet size. Rain in the downlink path lowers the signal power present at the receiver, resulting in a higher number of bit errors induced in the digital ground terminal. The laboratory simulation performed at NASA Lewis Research Center uses a programmable PIN diode attenuator to simulate 20 GHz satellite downlink geographic rain fade profiles. A computer based network control system monitors the downlink power and informs the network of any power threshold violations, which then prompts the network to issue commands that temporarily increase the gain of the satellite based traveling wave tube (TWT) amplifier. After the rain subsides, the network returns the TWT to the normal energy conserving power <b>mode.</b> <b>Bit</b> error rate (BER) data taken at the receiving ground terminal serves {{as a measure of}} the severity of rain degradation, and also evaluates {{the extent to which the}} network can improve the faded channel...|$|E
40|$|Abstract—We {{consider}} optimal encoding {{of video}} sequences for ATM networks. Two cases are investigated. In one, the video units are coded independently (e. g., motion JPEG), {{while in the}} other, the coding quality of a later picture may depend on that of an earlier picture (e. g., H. 26 x and MPEGx). The aggregate distortion–rate relationship for the latter case exhibits a tree structure, and its solution commands {{a higher degree of}} complexity than the former. For independent coding, we develop an algorithm which employs multiple Lagrange multipliers to find the constrained bit allocation. This algorithm is optimal up to a convex-hull approximation of the distortion–rate relations in the case of CBR (constant bit-rate) transmission. It is suboptimal in the case of VBR (variable bit-rate) transmission by the use of a suboptimal transmission rate control mechanism for sim-plicity. For dependent coding, the Lagrange-multiplier approach becomes rather unwieldy, and a constrained tree search method is used. The solution is optimal for both CBR and VBR transmission if the full constrained tree is searched. Simulation results are presented which confirm the superiority in coding quality of the encoding algorithms. We also compare the coded video quality and other characteristics of VBR and CBR transmission. Index Terms—Asynchronous transfer <b>mode,</b> <b>bit</b> allocation, im-age coding, optimization methods, quantization, rate distortion theory. I...|$|E
50|$|Clearly, in {{lossless}} <b>mode</b> all <b>bit</b> planes {{have to be}} encoded by the EBCOT, and no bit planes can be dropped.|$|R
50|$|The Pep/7's {{instruction}} set is simplistic, with only 32 possible opcodes. The instruction specifier {{consists of the}} opcode of 5 bits, a register selector (A or X) of 1 bit, and a memory access <b>mode</b> of 2 <b>bits,</b> with the opcode occupying the top 5 bits of a byte, the register selector in bit 2 and the address <b>mode</b> in <b>bits</b> 1 and 0.|$|R
5000|$|The term [...] "addressing mode" [...] {{is itself}} subject to {{different}} interpretations: either [...] "memory address calculation mode" [...] or [...] "operand accessing mode". Under the first interpretation, instructions {{that do not}} read from memory or write to memory (such as [...] "add literal to register") are considered not to have an [...] "addressing mode". The second interpretation allows for machines such as VAX which use operand <b>mode</b> <b>bits</b> {{to allow for a}} register or for a literal operand. Only the first interpretation applies to instructions such as [...] "load effective address".|$|R
40|$|Security {{has become}} a very {{critical}} issue {{in the provision of}} mobile services. The Open Mobile Alliance (OMA) has specified a powerful security layer, the WTLS. In this paper, a VLSI architecture for the implementation of the WTLS integrity unit is proposed. The proposed architecture is reconfigurable in the sense that operates in three different modes: as Keyed-Hash Authentication Code (HMAC), as SHA- 1 and MD 5 hash functions, according to WTLS specifications. This multi-mode operation is achieved due to the reconfigurable applied design technique in the proposed architecture, which keeps the allocated area resources at a minimized level. The proposed architecture achieves high speed performance, due to the pipeline designed architecture. Especially, SHA- 1 operation achieved throughput is equal to 1, 7 Gbps, while MD 5 operation <b>mode</b> <b>bit</b> rate is equal to 2, 1 Gbps. The proposed architecture has been integrated by using VHDL and has been synthesized placed and routed in an FPGA device. Comparisons with related hash functions implementations have been done in terms of throughput, operating frequency, allocated area and Area-Delay product. The achieved performance of the SHA- 1 operation mode is better at about 14 - 42 times compared with the other conventional works. In addition, MD 5 performance is superior to the other works at about 6 - 18 times, in all of the cases. The proposed Integrity Unit is a very trustful and powerful solution fo...|$|E
40|$|Library-based {{record and}} replay tools aim to {{reproduce}} an application’s execution by recording {{the results of}} selected functions in a log and during replay returning {{the results from the}} log rather than executing the functions. These tools must ensure that a replay run is identical to the record run. The challenge in doing so is that only invocations of a function by the application should be recorded, recording the side effects of a function call can be difficult, and not executing function calls during replay, multithreading, and the presence of the tool may change the application’s behavior from recording to replay. These problems have limited the use of such tools. R 2 allows developers to choose functions that can be recorded and replayed correctly. Developers annotate the chosen functions with simple keywords so that R 2 can handle calls with side effects and multithreading. R 2 generates code for record and replay from templates, allowing developers to avoid implementing stubs for hundreds of functions manually. To track whether an invocation is on behalf of the application or the implementation of a selected function, R 2 maintains a <b>mode</b> <b>bit,</b> which stubs save and restore. We have implemented R 2 on Windows and annotated large parts (1, 300 functions) of the Win 32 API, and two higher-level interfaces (MPI and SQLite). R 2 can replay multithreaded web and database servers that previous library-based tools cannot replay. By allowing developers to choose high-level interfaces, R 2 can also keep recording overhead small; experiments show that its recording overhead for Apache is approximately 10 %, that recording and replaying at the SQLite interface can reduce the log size up to 99 % (compared to doing so at the Win 32 API), and that using optimization annotations for BitTorrent and MPI applications achieves log size reduction ranging from 13. 7 % to 99. 4 %. ...|$|E
40|$|H. 264 /AVC video {{compression}} standard achieved {{significant improvements in}} coding efficiency, but the computational complexity of the H. 264 /AVC encoder is drastically high. The main complexity of encoder comes from variable block size motion estimation (ME) and rate-distortion optimized (RDO) mode decision methods. This dissertation proposes three different methods to reduce computation of motion estimation. Firstly, the computation of each distortion measure is reduced by proposing a novel two step edge based partial distortion search (TS-EPDS) algorithm. In this algorithm, the entire macroblock is divided into different sub-blocks and the calculation order of partial distortion is determined based on the edge strength of the sub-blocks. Secondly, we have developed an early termination algorithm that features an adaptive threshold based on the statistical characteristics of rate-distortion (RD) cost regarding current block and previously processed blocks and modes. Thirdly, this dissertation presents a novel adaptive search area selection method by utilizing the information of the previously computed motion vector differences (MVDs). In H. 264 /AVC intra coding, DC mode is used to predict regions with no unified direction and the predicted pixel values are same and thus smooth varying regions are not well de-correlated. This dissertation proposes an improved DC prediction (IDCP) mode based on {{the distance between the}} predicted and reference pixels. On the other hand, using the nine prediction modes in intra 4 x 4 and 8 x 8 block units needs a lot of overhead bits. In order {{to reduce the number of}} overhead bits, an intra <b>mode</b> <b>bit</b> rate reduction method is suggested. This dissertation also proposes an enhanced algorithm to estimate the most probable mode (MPM) of each block. The MPM is derived from the prediction mode direction of neighboring blocks which have different weights according to their positions. This dissertation also suggests a fast enhanced cost function for mode decision of intra encoder. The enhanced cost function uses sum of absolute Hadamard-transformed differences (SATD) and mean absolute deviation of the residual block to estimate distortion part of the cost function. A threshold based large coefficients count is also used for estimating the bit-rate part...|$|E
40|$|ABSTRACT: We {{present a}} new motion vector coding {{technique}} based on minimum bitrate prediction. In the proposed scheme, the current block motion vector is predicted among three causal neighboring motion vectors {{so that it}} can produce minimum bitrate in motion vector coding. And then prediction error and mode information for determining the true motion vector at the decoder are coded and transmitted. Since MVD (motion vector difference) code bits are ahead of <b>MODE</b> <b>bits</b> in syntax, the <b>bit</b> amount for <b>MODE</b> information can be minimized by using the fact that the minimum bitrate predictor is used for the motion vector prediction. 1...|$|R
5000|$|... in 1024x768 32 <b>bits</b> <b>mode</b> with 253 clients memory usage is ~2,5M ...|$|R
5000|$|... 64 bit memory {{interface}} (single-channel <b>mode)</b> / 128 <b>bit</b> memory interface (dual-channel mode).|$|R
5000|$|Y-Luminance = 10 <b>Bits</b> 24/25 fr/sec <b>modes</b> and 8 <b>Bits</b> 30 fr/sec <b>modes</b> ...|$|R
5000|$|With four address <b>mode</b> {{selection}} <b>bits</b> (P, R, I and N - indexed, relative, indirect and immediate), NAR 2 instructions can specify 16 different {{addressing modes}} {{but not all}} make sense in all instructions. In the following table: ...|$|R
5000|$|RISC OS 5 from RISC OS Open {{with the}} CPU running in 32 <b>bit</b> <b>mode</b> ...|$|R
50|$|Q Mode 2: In this <b>mode,</b> {{the data}} <b>bits</b> contain the Media Catalog Number (MCN) of the disc.|$|R
5000|$|Force Win31 printer dev <b>mode</b> size:This is <b>bit</b> #23 of the {{compatibility}} bits word, with {{hexadecimal value}} [...]|$|R
5000|$|... bit 2 : if set and bit 5 reset, bank 3 is RAM <b>mode</b> {{irrespective}} of <b>bit</b> 4 ...|$|R
