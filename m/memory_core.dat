62|1024|Public
5|$|The {{second issue}} of the comic Homeworlds was {{revealed}} to focus around Tali's past. Released on May 30, 2012, the issue tells {{of the beginning of}} her Pilgrimage, and the events leading up to her appearance in the first game. Originally intending to take the quarian ship Honorata to the planet Illium, along with Keenah'Breizh, in search of valuable items, they discover geth activity on an unidentified ice planet. Tali extracts the <b>memory</b> <b>core</b> from one of the geth, and discovers a recording of a conversation between Saren and Matriarch Benezia discussing the attack on Eden Prime.|$|E
25|$|Another {{important}} aspect of the Spacecraft Bus is the central computing, memory storage, and communications equipment. The processor and software direct data to and from the instruments, to the solid-state <b>memory</b> <b>core,</b> and to the radio system which can send data back to Earth and receive commands. The computer also controls the pointing and moment of the spacecraft, taking in sensor data from the gyroscopes and star tracker, and sending the necessary commands to the reaction wheels or thrusters depending.|$|E
25|$|Erasmus {{continues}} his experiment with his ward Gilbertus Albans, whom he names his Mentat. After seventy years {{it becomes clear}} that the independent robot loves his “son” even though he has no problem brutalizing other humans. When Gilbertus sneaks onto one of the cargo haulers of the Bridge of Hrethgir containing a Serena Butler clone that he is infatuated with, Erasmus disables the explosive trip mechanism in order to save him. In doing so, Erasmus dooms the entire machine empire. Realizing that hrethgir will rule the universe, he suggests to Gilbertus that he teach the other humans to “think efficiently.” Erasmus apparently survives the battle when Gilbertus smuggles away his <b>memory</b> <b>core.</b>|$|E
40|$|On-chip {{multiport}} <b>memory</b> <b>cores</b> {{are crucial}} primitives for many modern high-performance reconfigurable architectures and multicore systems. Previous approaches for scaling <b>memory</b> <b>cores</b> {{come at the}} cost of operating frequency, communication overhead, and logic resources without increasing the storage capacity of the memory. In this paper, we present two approaches for designing multiport <b>memory</b> <b>cores</b> that are suitable for reconfigurable accelerators with substantial on-chip memory or complex communication. Our design approaches tackle these challenges by banking RAM blocks and utilizing interconnect networks which allows scaling without sacrificing logic resources. With banking, memory congestion is unavoidable and we evaluate our multiport <b>memory</b> <b>cores</b> under different <b>memory</b> access patterns to gain insights about different design trade-offs. We demonstrate our implementation with up to 256 memory ports using a Xilinx Virtex- 7 FPGA. Our experimental results report high throughput memories with resource usage that scales with the number of ports...|$|R
5000|$|The [...] "second generation" [...] of {{computers}} (transistor computers) featured boards filled with discrete transistors and magnetic <b>memory</b> <b>cores.</b>|$|R
40|$|A memory test {{algorithm}} {{for detecting}} neighborhood pattern sensitive faults (NPSFs), including static NPSF (SNPSF), passive NPSF (PNPSF) and active NPSF (ANPSF), is proposed in this paper. The patterns can also detect all the traditional faults {{present in the}} memory array such as stuck-at faults (SAFs), transition faults (TFs), coupling faults (CFs) and address decoder faults. Next, a programmable BIST architecture is designed. The BIST circuit allows the users to select a vast variety of test algorithms based on their choice. The single BIST circuit is capable of testing different types of <b>memory</b> <b>cores</b> embedded in SOC. The proposed BIST circuit is shared among the different <b>memory</b> <b>cores</b> in an SOC. For this purpose, test wrappers for the shared BIST circuits and the <b>memory</b> <b>cores</b> are designed. Finally, a test scheduling algorithm is developed to reduce the overall test time...|$|R
2500|$|The {{prefetch}} buffer depth {{can also}} {{be thought of as}} the ratio between the core memory frequency and the IO frequency. [...] In an 8n prefetch architecture (such as DDR3), the IOs will operate 8 times faster than the <b>memory</b> <b>core</b> (each memory access results in a burst of 8 datawords on the IOs). [...] Thus a 200MHz <b>memory</b> <b>core</b> is combined with IOs that each operate eight times faster (1600 megabits per second). [...] If the memory has 16 IOs, the total read bandwidth would be 200MHz x 8 datawords/access x 16 IOs = 25.6 gigabits per second (Gbit/s), or 3.2 gigabytes per second (GB/s). [...] Modules with multiple DRAM chips can provide correspondingly higher bandwidth.|$|E
50|$|Primary {{storage in}} a form of {{magnetic}} memory, or core <b>memory,</b> <b>core</b> rope memory, thin-film memory and/or twistor memory.|$|E
50|$|It {{turns out}} that Jared was fatally wounded in her escape from LA, {{requiring}} her <b>memory</b> <b>core</b> to be salvaged from her body. After removing a surveillance device implanted in Alex's eye, Julian injects him with a digital scrambler that prevents the bomb from being remotely detonated. She gives him Jared's <b>memory</b> <b>core,</b> enabling him to talk to her. The strike team storms the hotel and Julian sacrifices herself to let Alex escape.|$|E
40|$|We present {{cost and}} benefit models {{and analyze the}} {{economics}} effects of built-in self-test (BIST) for logic and <b>memory</b> <b>cores.</b> In our cost and benefit models for BIST, we {{take into consideration the}} design verification time and test development time associated with testability. Experimental results for logic BIST and memory BIST examples show that a threshold volume exists when BIST is profitable for the logic core under consideration [...] -it is not recommended for a higher volume. However, BIST is a good choice for <b>memory</b> <b>cores</b> in general...|$|R
40|$|Abstract—We {{present a}} {{framework}} for formal verification of flash <b>cores.</b> Flash <b>memories</b> cannot be verified by traditional switch-level abstractions, due to capacitive coupling induced {{by the presence of}} floating gates. We discuss a new approach to abstracting transistor networks that is agnostic to the type of transistor used in the implementation. We show how to use this abstraction to model flash memory designs. The abstractions are used for functional verification of <b>memory</b> <b>cores,</b> and can be validated through analog simulation. We have used the approach in the verification of representative NOR and a NAND flash <b>memory</b> <b>cores.</b> I...|$|R
40|$|<b>Memory</b> <b>cores</b> (especially SRAM cores) used on {{a system}} chip usually come from a memory compiler. Commercial memory compilers have their limitation— a large memory {{may need to be}} {{implemented}} with multiple small memories, if generated by memory compilers. In this paper we introduce a testability-driven memory optimizer and wrapper generator that generates BISTed embedded memories by using a commercial memory compiler. We describe one of its key components called MORE (for Memory Optimization and REconfiguration). The approach is cost effective for designing embedded memories. By configuring small <b>memory</b> <b>cores</b> into the large one specified by the user and providing the BIST circuits, MORE allows the user to combine the commercial memory compiler and our memory BIST compiler into a cost-effective testability-driven memory generator. The resulting memory has a shorter test time, since the small <b>memory</b> <b>cores</b> can be tested in parallel, so far as the power and geometry constraints are considered. As an example, the test time of a typical 256 K¢ 32 memory generated by MORE is reduced by about 75 %. 1...|$|R
50|$|PAL devices {{consisted}} of a small PROM (programmable read-only <b>memory)</b> <b>core</b> and additional output logic used to implement particular desired logic functions with few components.|$|E
50|$|Later, Main Computer is {{restored}} using Brian's <b>memory</b> <b>core.</b> The first operation performed is {{to verify the}} Moon's present trajectory; the data confirms their course remains unchanged. Hoping to cause confusion with this red herring, Brian the Brain was apparently manipulating Computer from the very beginning. Regarding the robot, the Alphans elect {{to give it a}} second chance. The <b>memory</b> <b>core</b> will be returned to Brian—once programmed with a proper sense of morality. Afterward, Koenig and Helena make a date to discuss the results of the love test...|$|E
50|$|Under most UNIX based {{operating}} systems control-\ {{is used to}} terminate a running process from a command shell and have it produce a <b>memory</b> <b>core</b> dump by sending it a SIGQUIT signal.|$|E
40|$|Self-Test (BIST) for {{a generic}} SoC {{consisting}} of a Field Programmable Gate Array (FPGA) core for application specific logic along with a processor and several <b>memory</b> <b>cores.</b> Our target device was the Atmel AT 94 K series System-on-Chip (SoC), {{also known as a}} Field Programmable System Level Integrated Circuit (FPSLIC). The original goal for this project was to develop BIST configurations to completely test the programmable logic and routing resources of the FPGA core and then to use the FPGA core to test the other cores. We found that the FPGA can provide only limited testing of the some <b>memory</b> <b>cores</b> and even less testing of the processor. The processor, on the other hand, provides more effective testing of some <b>memory</b> <b>cores</b> than the FPGA core. In addition, the ability of the processor to write the FPGA configuration memory provides an improved and more efficient method of testing the FPGA core. As a result, the processor core was the primary testing resource instead of the FPGA. 1 1...|$|R
5000|$|... #Caption: Drum <b>memory</b> (bottom) and <b>core</b> <b>memory</b> (upper right) for the BESK computer.|$|R
5000|$|MM11-L 8K word <b>core</b> <b>memory</b> (MM11-K 4K word <b>core</b> <b>memory</b> on GT40-Bx models) ...|$|R
5000|$|... #Caption: Diagram of the {{hysteresis}} curve for {{a magnetic}} <b>memory</b> <b>core</b> during a read operation. Sense line current pulse is high ("1") or low ("0") depending on original magnetization {{state of the}} core.|$|E
50|$|The {{prefetch}} buffer depth {{can also}} {{be thought of as}} the ratio between the core memory frequency and the IO frequency. In an 8n prefetch architecture (such as DDR3), the IOs will operate 8 times faster than the <b>memory</b> <b>core</b> (each memory access results in a burst of 8 datawords on the IOs). Thus a 200 MHz <b>memory</b> <b>core</b> is combined with IOs that each operate eight times faster (1600 megabits per second). If the memory has 16 IOs, the total read bandwidth would be 200 MHz x 8 datawords/access x 16 IOs = 25.6 gigabits per second (Gbit/s), or 3.2 gigabytes per second (GB/s). Modules with multiple DRAM chips can provide correspondingly higher bandwidth.|$|E
50|$|In old computers, {{magnetic}} storage {{was also used}} for primary storage in a form of magnetic drum, or core <b>memory,</b> <b>core</b> rope memory, thin film memory, twistor memory or bubble memory. Unlike modern computers, magnetic tape was also often used for secondary storage.|$|E
50|$|The 7600 has {{two main}} <b>core</b> <b>memories.</b> Small <b>core</b> <b>memory</b> holds the {{instructions}} currently being executed {{and the data}} currently being processed. It has an access time of ten of the 27.5-ns. minor cycle times and a 60-bit word length. Large <b>core</b> <b>memory</b> holds data ready to transfer to small <b>core</b> <b>memory.</b> It has an access time of 60 of the 27.5-ns. minor-cycle times and a word length of 480 bits (488 bits with parity). Accesses are fully pipelined and buffered, so the two have the same sequential transfer rate of 60 bits every 27.5 ns. The two work in parallel, so the sequential transfer rate {{from one to the}} other is 60 bits per 27.5 ns. minor-cycle time. On an operating system call, the contents of the small <b>core</b> <b>memory</b> are swapped out and replaced from the large <b>core</b> <b>memory</b> by the operating system, and restored afterward.|$|R
40|$|With {{the advent}} of deep-submicron VLSI technology, core-based {{system-on-chip}} (SOC) design is attracting an increasing attention. On an SOC, popular reusable <b>cores</b> include <b>memories</b> (such as ROM, SRAM, DRAM and flash memory), processors (such as CPU, DSP and microcontroller), input/output circuits, etc. <b>Memory</b> <b>cores</b> are obviously among the most universal ones-almost all system chips contain some type of embedded memory [5]. However, to provide a low cost-cost test solution for the on-chip <b>memory</b> <b>cores</b> is not a trivial task. This paper presents a study on memory BIST, algorithms of different test patterns, survey of memory BIST implementations, and discussion of some novel design issues. This paper shall serve as a knowledge base for future design in memory BIST. 1...|$|R
40|$|Embedded {{memories}} contain several {{hundreds of}} <b>memory</b> <b>cores</b> which constitute {{a significant portion}} of the chip area for typical system-on-chip (SOC) designs. With the shrinking transistor size and aggressive design rules, <b>memory</b> <b>cores</b> are easily prone to manufacturing defects and reliability problems. As these circuits have higher complexity and more sharing signals than logic blocks, they have higher failure possibilities In order to solve this problem; designers usually add redundancy to embedded memories. Most of faults are single cell transient fault; the area of spare is effectively utilized by replacing defected cell with spare cell. Continuing advancements in semiconductor technology have made sure that the integrated circuit industry keeps following the Moore’s law, which predicts doubli...|$|R
50|$|Historically, early {{computers}} used delay lines, Williams tubes, or rotating magnetic drums {{as primary}} storage. By 1954, those unreliable methods were mostly replaced by magnetic core <b>memory.</b> <b>Core</b> memory remained dominant until the 1970s, when advances in integrated circuit technology allowed semiconductor memory to become economically competitive.|$|E
50|$|On Moonbase, all main {{systems are}} non-responsive. It seems the entire {{computer}} network has been disabled. Maya recalls Brian's chat with Computer; she speculates that it either blocked every link to Computer or downloaded {{the operating system}} to its own <b>memory</b> <b>core</b> on the Swift before erasing theirs. Either way, Moonbase Alpha is effectively blind. Upon learning the Eagles' on-board computers are operating normally, Tony Verdeschi takes up a squadron to rescue the abductees.|$|E
50|$|Another {{important}} aspect of the Spacecraft Bus is the central computing, memory storage, and communications equipment. The processor and software direct data to and from the instruments, to the solid-state <b>memory</b> <b>core,</b> and to the radio system which can send data back to Earth and receive commands. The computer also controls the pointing and moment of the spacecraft, taking in sensor data from the gyroscopes and star tracker, and sending the necessary commands to the reaction wheels or thrusters.|$|E
40|$|<b>Memory</b> <b>cores</b> {{are usually}} the densest portion with the {{smallest}} feature size in system-on-chip (SOC) designs. The reliability of <b>memory</b> <b>cores</b> thus has heavy impact on the reliability of SOCs. Transparent test is one of useful technique for improving the reliability of memories during life time. This paper presents a systematic algorithm used for transforming a bit-oriented march test into a transparent word-oriented march test. The transformed transparent march test has shorter test complexity compared with that proposed in the previous works [12, 13]. For example, if a memory with 32 -bit words is tested with March C, time complexity of the transparent word-oriented test transformed by the proposed scheme is only about 56 % or 19 % time complexity of the transparent word-oriented test converted by the scheme reported in [12] or [13], respectively...|$|R
5000|$|KDF8 was a {{transistor}} based {{machine with}} magnetic <b>core</b> <b>memory.</b> The <b>core</b> <b>memory</b> {{of the machine}} installed at the Kidsgrove computer bureau was upgraded from 64k to the then maximum of 96k of <b>core</b> <b>memory.</b> KDF8 used an octal (base eight) addressing system. A machine-code instruction was fixed length, ten octal characters long. The instruction set was specifically designed for commercial use. It had machine-code level instructions for {{all four of the}} decimal arithmetic functions operating on variable length numbers, and also had instructions for efficient manipulation of variable-length data-strings. Not all instructions required all ten characters. Given the minimal <b>core</b> <b>memory</b> available, programmers frequently used [...] "spare" [...] characters in instructions for storage of constants and similar storage-saving tricks.|$|R
40|$|Abstract — Programmable memory BIST {{architecture}} {{is becoming a}} necessity for embedded <b>memory</b> <b>cores.</b> Classical <b>memory</b> BIST architectures use fixed algorithmic tests during the whole live of digital device. To improve the flexibility of memory BIST the programmable solution, based on finite state machine with microcode control, was invented. The requirement to use such flexibility is dictated by reason to use newest test for <b>memory</b> <b>cores.</b> In this paper a new Programmable Memory BIST architecture with small microcode memory is proposed. The analysis of existing March tests allows to code them into the optimal binary format, which cause not only small hardware overhead but also may speed-up the transferring of new test over the serial interfaces like IEEE 1149. 1 and P 1500. Index Terms — built-in testing, finite state machines, memory testing, microprogramming, random access memories...|$|R
5000|$|Chaselon (voiced by Tom Kenny) - The {{crystalline}} Green Lantern {{is first}} {{seen in the}} episode [...] "Reboot", where he is assigned to watch over the lab where Aya is being dissected. He is distracted by Hal Jordan while Ch'p recovers Aya's <b>memory</b> <b>core.</b> Later, Chaselon serves in Guy Gardner's squadron at the Battle of Ranx, alongside Larvox, and later fights against the Manhunters in the series finale. Chaselon is characterized as naive and somewhat lonely, admitting to Hal that he has few friends on Oa.|$|E
50|$|The GDDR3 Interface {{transfers}} two 32 bit wide data {{words per}} clock cycle from the I/O pins. Corresponding to the 4n-pre fetch a single write or read access {{consists of a}} 128 bit wide, one-clock-cycle data transfer at the internal <b>memory</b> <b>core</b> and four corresponding 32 bit wide, one-half-clock-cycle data transfers at the I/O Pins. Single-ended unidirectional Read and Write Data strobes are transmitted simultaneously with Read and Write data respectively in order to capture data properly at the receivers of both the Graphics SDRAM and the controller. Data strobes are organized per byte of the 32 bit wide interface.|$|E
50|$|Koenig {{and company}} {{continue}} to verbally batter the hysterical robot with repeated accusations. Like a guilty child, Brian tries to hide, {{ending up in}} an airlock. Koenig ejects the machine into space, but its antenna is trapped when the outer door cycles shut. Brian threatens to erase his <b>memory</b> <b>core</b> unless he is brought back aboard. The Alphans must proceed cautiously as Brian {{is linked to the}} only available working computer. Despite the threat, Koenig orders the antenna cut and the robot set adrift. Begging for mercy, Brian breaks down, sobbing as it offers to give the Alphans anything they want.|$|E
40|$|System on Chip devices {{include an}} {{increasing}} number of embedded <b>memory</b> <b>cores,</b> whose test during the operational phase is often a strict requirement, especially for safety-critical applications. This paper proposes a new memory test method combining the characteristics of hardware and software solutions: the test is performed by the microcontroller/processor, while the code of the test instructions to be executed is generated on-the-fly by an ad hoc module, also in charge of checking the memory behavior. The solution is modular and does not require any modification either in the <b>memory</b> <b>cores</b> or in the processor. Moreover, it is well suited to be used for test during the operational phase. Experimental results, gathered by implementing some representative March elements and algorithms, show that the method guarantees higher defect coverage than software BIST and a test time comparable with that of traditional hardware BIST solutions with a reduced hardware cos...|$|R
5000|$|The term [...] "core" [...] {{comes from}} {{conventional}} transformers whose windings surround a magnetic <b>core.</b> In <b>core</b> <b>memory,</b> the wires pass once through any given core - they are single-turn devices. The {{properties of materials}} used for <b>memory</b> <b>cores</b> are dramatically different from those used in power transformers. The magnetic material for a <b>core</b> <b>memory</b> requires {{a high degree of}} magnetic remanence, the ability to stay highly magnetized, and a low coercitivity so that less energy is required to change the magnetization direction. The core can take two states, encoding one bit, which can be read when [...] "selected" [...] by a [...] "sense wire". The <b>core</b> <b>memory</b> contents are retained even when the memory system is powered down (non-volatile memory). However, when the core is read, it is reset to a [...] "zero" [...] value. Circuits in the computer memory system then restore the information in an immediate re-write cycle.|$|R
50|$|Magnetic-core {{memory was}} the {{predominant}} form of random-access computer memory for 20 years between about 1955 and 1975. Such memory is often just called <b>core</b> <b>memory,</b> or, informally, <b>core.</b>|$|R
