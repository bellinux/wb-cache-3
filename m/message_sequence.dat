589|237|Public
50|$|For the {{inductive}} hypothesis, {{we assume}} that for some j+1 ≤ p and any <b>message</b> <b>sequence</b> Mj+1, NMj = Praccepts w and then prove the hypothesis for j and any <b>message</b> <b>sequence</b> Mj.|$|E
5000|$|MSC <b>Message</b> <b>Sequence</b> Chart. Another ITU-T related {{notation}} {{to describe}} the dynamic behavior of a system.|$|E
5000|$|PragmaDev Studio can {{generate}} TTCN-3 test cases out of <b>Message</b> <b>Sequence</b> Charts {{resulting from a}} simulation.|$|E
40|$|Two {{important}} issues {{that need to}} be addressed when designing medium access control (MAC) protocols for Wavelength Division Multiplexing networks are <b>message</b> <b>sequencing</b> and channel assignment. Channel assignment addresses the problem of choosing an appropriate data channel via which a message is transmitted. This problem has been addressed extensively in the literature. On the other hand, <b>message</b> <b>sequencing,</b> which addresses the order in which messages are sent, has rarely been addressed. In this paper, we propose a new reservation-based message scheduling algorithm called RO-EATS that addresses both the channel assignment and <b>message</b> <b>sequencing</b> during its scheduling process. We formulate an analytical model and conduct extensive simulations to evaluate the performance of this algorithm. We compare the performance results of a well-known algorithm which only addresses the channel assignment issue with those of our new algorithm. The comparison shows that our new algorithm gives significant improvement over scheduling algorithms that do not consider <b>message</b> <b>sequencing.</b> As a result, we anticipate that these research results will lead to new approaches to message scheduling on WDM networks. (C) 1999 published by Elsevier Science B. V. All rights reserved...|$|R
40|$|<b>Message</b> <b>sequencing</b> {{and channel}} {{assignment}} are two important issues {{that need to}} be addressed when scheduling variable-length messages in a wavelength division multiplexing (WDM) network. Channel assignment addresses the problem of choosing an appropriate data channel via which a message is transmitted to a node. This problem has been addressed extensively in the literature. On the other hand, <b>message</b> <b>sequencing</b> which addresses the order in which messages are sent, has rarely been addressed. In this paper, we propose a set of scheduling techniques for single-hop WDM passive star networks, which address both the sequencing aspect and the assignment aspect of the problem, In particular, we develop two priority schemes for <b>sequencing</b> <b>messages</b> in a WDM network in order to increase the overall performance of the network. We evaluate the proposed algorithms, using analytical modeling and extensive discrete-event simulations, by comparing their performance with state-of-the-art scheduling algorithms that only address the assignment problem [9], We find that significant improvement in performance can be achieved using our scheduling algorithms where <b>message</b> <b>sequencing</b> and channel assignment are simultaneously taken into consideration. This suggests that, when scheduling messages in WDM networks, one has to consider <b>message</b> <b>sequencing,</b> as well as channel assignment. As a result, we anticipate that this research mill open new directions into the problem of on-line scheduling in WDM networks...|$|R
50|$|The Web Service Conversation Language (WSCL) {{proposal}} {{defines the}} overall {{input and output}} <b>message</b> <b>sequences</b> for one web service using a finite state automaton FSA over the alphabet of message types.|$|R
50|$|A <b>message</b> <b>sequence</b> chart (or MSC) is an {{interaction}} diagram from the SDL family standardized by the International Telecommunication Union.|$|E
5000|$|<b>Message</b> <b>Sequence</b> Charts is {{an internationally}} {{accepted}} standard for capturing requirements.MSC [...] Provides a graphical 2-D language often required for collecting requirements through some interaction scenarios.|$|E
50|$|The 1996 version added references, {{ordering}} and inlining expressions concepts, {{and introduced}} HMSC (High-level <b>Message</b> <b>Sequence</b> Charts), {{which are the}} way of expressing a sequence of MSCs.|$|E
50|$|Critics of SVOT {{as applied}} to <b>message</b> <b>sequencing</b> argue that this concept is not scalable. As the world moves towards systems spread over many {{processing}} nodes, the effort involved in negotiating a single agreed-upon sequence becomes prohibitive.|$|R
5000|$|ITU-T Recommendation H.460.16, Multiple <b>message</b> release <b>sequence</b> capability.|$|R
40|$|In {{scheduling}} {{the transmission}} of messages in a WDM network, we are facing not only the channel assignment problem but also <b>message</b> <b>sequencing</b> problem. In this paper, we propose and evaluate a new reservation-based message scheduling algorithm for single-hop, WDM passive star lightwave network which addresses both the assignment aspect and the sequencing aspect of the problem. We compare {{the performance of the}} algorithm which only addresses the channel assignment issue with the performance of our new algorithm theoretically and experimentally and demonstrate that our new algorithm has significant improvement over the performance of a WDM network with a scheduling algorithm that does not consider the <b>message</b> <b>sequencing</b> problem. As a result, we anticipate that this research can open new directions into the problem of message scheduling on WDM networks...|$|R
50|$|A {{sequence}} diagram is {{an interaction}} diagram {{that shows how}} objects operate {{with one another and}} in what order. It is a construct of a <b>message</b> <b>sequence</b> chart.|$|E
5000|$|Users {{can view}} how the {{response}} time is varied {{with the time}} and <b>message</b> <b>sequence</b> are differed from the defined sequence, giving lots of insights to network in {{the perspective of the}} customer ...|$|E
50|$|PragmaDev Specifier embeds an SDL {{simulator}} that behaves like a model debugger. It {{is possible}} to set breakpoints graphically, to view variables, and pending timers. During execution a live trace is generated based on the <b>Message</b> <b>Sequence</b> Chart ITU-T standard.|$|E
40|$|This paper {{presents}} a state-based approach to testing aspect-oriented programs. Aspectual state models, {{as an extension}} to the testable FREE state model of classes, are exploited to capture the impact of aspects on the state models of classes. To generate test suites for adequately testing object behavior and interaction between classes and aspects in terms of <b>message</b> <b>sequences,</b> we transform an aspectual state model to a transition tree, where each path from the root to some leaf node indicates a template of test cases, i. e. <b>message</b> <b>sequences.</b> Since the statebased approach is directly built upon the test design patterns for object-oriented programs, {{it is not only}} applicable to the simultaneous development of classes and aspects, but also to the incremental development of aspects based on the existing classes. Keywords: Aspect-oriented programming, software testing, state model, transition tre...|$|R
3000|$|Alice and Bob obtain <b>message</b> <b>sequences</b> view_ 1 ^π (x,y)=(x,r^ 1,m_ 1 ^ 1, [...]..., m_t^ 1) and view_ 2 ^π (x,y)=(x,r^ 2,m_ 1 ^ 2,..., m_t^ 2), respectively, where r^ 1 or r^ 2 is {{the result}} of her or his {{internal}} coin toss, and m_i^ 1 or m_i^ 2 is her or his received message; [...]...|$|R
40|$|Distributed {{enterprise}} systems, {{which are}} comprised of multiple software systems, typically communicate using application-layer protocols. Being able to independently test each system’s conformance to the protocol specification {{is important to}} ensure the overall robustness and reliability of the distributed system. While there exists many modelling languages for network layer protocols, very few tools exist for modelling valid <b>message</b> <b>sequences</b> specifically for the application layer. In order to address this issue, we propose a concise formal modelling syntax for application-layer protocols, with clearly defined semantics. A key feature of our protocol model is dynamic extension, which {{is necessary for the}} concise modelling of subsidiary concurrent operations. We demonstrate the power of our modelling language by compactly specifying the valid <b>message</b> <b>sequences</b> of two common application-layer protocols. Trace conformance is defined for the model along with a prototype implementation demonstrating the practical utility of our modelling framework...|$|R
5000|$|When any cue {{is called}} by a user (typically a stage manager) and/or preprogrammed {{timeline}} {{in a show}} control software application, the show controller transmits one or more MSC messages from its 'MIDI Out' port. A typical MSC <b>message</b> <b>sequence</b> is: ...|$|E
50|$|Because of the {{computational}} {{complexity of}} asymmetric encryption, {{it is usually}} used only for small blocks of data, typically the transfer of a symmetric encryption key (e.g. a session key). This symmetric key is then used to encrypt {{the rest of the}} potentially long <b>message</b> <b>sequence.</b> The symmetric encryption/decryption is based on simpler algorithms and is much faster.|$|E
50|$|The <b>message</b> <b>sequence</b> {{of command}} (or request) and its {{response}} {{is known as}} a transaction, which is identified by the numerical Transaction Identifier exchanged in each transaction. The protocol specification defines nine standard commands that are distinguished by a four-letter command verb: AUEP, AUCX, CRCX, DLCX, EPCF, MDCX, NTFY, RQNT, and RSIP. Responses begin with a three-digit numerical response code that identifies the outcome or result of the transaction.|$|E
40|$|Abstract. A multi-party {{contract}} signing (MPCS) protocol is {{used for}} a group of signers to sign a digital contract over a network. We analyse the protocols of Mukhamedov and Ryan (MR), and of Mauw, Radomirović and Torabi Dashti (MRT), using the finite-state model checker Mocha. Mocha allows for the specification of properties in alternating-time tem-poral logic (ATL) with game semantics, and the model checking problem for ATL requires the computation of winning strategies. This gives us an intuitive interpretation of the verification problem of crucial properties of MPCS protocols. We analyse the MR protocol with up to 5 signers and our analysis does not reveal any flaws. MRT protocols can be generated from minimal <b>message</b> <b>sequences,</b> depending on the number of signers. We discover an attack in a published MRT protocol with 3 signers, and present a solution for it. We also design a number of MRT protocols using minimal <b>message</b> <b>sequences</b> for 3 and 4 signers, all of which have been model checked in Mocha. ...|$|R
3000|$|It is very {{powerful}} in list manipulation. Lists {{are used in}} CMQ to provide lightweight data structure that holds <b>messages</b> in <b>sequence.</b> List manipulation is useful to implement selective receives of messages with defined characteristics (rather than accepting <b>messages</b> in FIFO <b>sequence)</b> in an Erlang-like fashion.|$|R
40|$|AbstractThis paper {{contributes}} to the interoperability of web services by proposing the flexible specification technique SXQT {{in conjunction with the}} automatic validation, a straightforward approach for detecting non-conformance. SXQT allows different levels of abstraction by specifying individual requirements on a web service's protocol, i. e. its SOAP messages and behaviour including SOAP modules. The automatic validation detects non-conformance by comparing occurring <b>message</b> <b>sequences</b> with the protocol's specification...|$|R
50|$|Library {{provides}} UDP session management (connect, disconnect, keep-alives, {{sliding window}} for messages and <b>message</b> <b>sequence</b> numbers) and supports {{any number of}} concurrent sessions. Library contains standard Intelligent Platform Management Interface encryption algorithms for authentication (RAKP-HMAC-SHA1), integrity (HMAC-SHA1-96) and confidentiality (AES-CBC-128), however additional algorithms can be provided. Library contains encoders and decoders for event log, sensor values and hardware information (FRU - Field Replaceable Unit). Library can be extended with additional, user-defined encoders.|$|E
50|$|Mscgen (short for MSC generator) is a {{software}} tool for drawing <b>message</b> <b>sequence</b> charts {{from a simple}} to manage text-based source file. Rendered charts can be output in PNG, SVG and PostScript, with hyperlink information in ismap format. There is an extension for MediaWiki, Sphinx (documentation generator) and integration with Doxygen that allows embedding of charts into source code comments with generated automatically inserted into the generated documentation page. Mscgen is free software licensed under the GNU General Public License (GPL).|$|E
50|$|The {{purpose of}} recommending MSC (<b>Message</b> <b>Sequence</b> Chart) {{is to provide}} a trace {{language}} for the specification and description of the communication behaviour of system components and their environment by means of message interchange. Since in MSCs the communication behaviour is presented in a very intuitive and transparent manner, particularly in the graphical representation, the MSC language is easy tolearn, use and interpret. In connection with other languages {{it can be used to}} support methodologies for system specification, design, simulation, testing, and documentation.|$|E
40|$|Service-Oriented Computing (SOC) is an {{emerging}} computing paradigm that supports loosely-coupled inter-enterprise interactions. SOC interactions are predominantly specified in a procedural manner that defines <b>message</b> <b>sequences</b> intermixing implementation with business requirements. In this paper {{we present a}} set of patterns concerning requirements of information exchange between participants engaging in service-oriented interactions. The patterns aim at explicating and elaborating the business requirements driving the interaction and separating them from implementation concerns. 1...|$|R
40|$|A multi-party {{contract}} signing (MPCS) protocol is {{used for}} a group of signers to sign a digital contract over a network. We analyse the protocols of Mauw, Radomirović and Torabi Dashti (MRT), using the finite-state model checker Mocha. Mocha allows for the specification of properties in alternating-time temporal logic (ATL) with game semantics, and the model checking problem for ATL requires the computation of winning strategies. This gives us an intuitive interpretation of the verification problem of crucial properties of MPCS protocols. MRT protocols can be generated from minimal <b>message</b> <b>sequences,</b> depending on the number of signers. We discover an attack on fairness in a published MRT protocol with three signers and a general attack on abuse-freeness for all MRT protocols. For both attacks, we present solutions. The abuse-freeness attack leads us to a revision of the methodology to construct an MRT protocol. Following this revised methodology, we design a number of MRT protocols using minimal <b>message</b> <b>sequences</b> for three and four signers, all of whom have been successfully model checked in Mocha...|$|R
40|$|Testing the {{components}} of a distributed system is challenging as it requires consideration of not just the state of a component, but also the <b>sequence</b> of <b>messages</b> it may receive {{from the rest of}} the system or the environment. Such messages may vary in type and content, and more particularly, in the frequency at which they are generated. All of these factors, in the right combination, may lead to faulty be-havior. In this paper we present an approach to address these chal-lenges by systematically analyzing a component in a distributed system to identify specific <b>message</b> <b>sequences</b> and frequencies at which a failure can occur. At the core of the analysis is the genera-tion of a test driver that defines the space of <b>message</b> <b>sequences</b> to be generated, the exploration of that space through the use of dy-namic symbolic execution, and the timing and analysis of the gen-erated tests to identify problematic frequencies. We implemented our approach in the context of the popular Robotic Operating Sys-tem and investigated its application to three systems of increasing complexity...|$|R
5000|$|MM {{was unusual}} for its {{time in its}} support of [...] "message sequences," [...] which allowed the user to select a subset of {{messages}} in a mailbox for batch operations. The <b>message</b> <b>sequence</b> feature proved so popular with MM users that TOPS-20 MM author Mark Crispin went on to implement similar filtering capabilities in Pine. Columbia MM also offered context-sensitive help, command completion, and command history, carried over from the TOPS-20 version, before such features were commonplace in Unix software.|$|E
50|$|Take M0 to be {{the empty}} <b>message</b> <b>sequence,</b> here we will show that NM0 can be {{computed}} in polynomial space, and that NM0 = Praccepts w. First, to compute NM0, an algorithm can recursively calculate the values NMj for every j and Mj. Since {{the depth of the}} recursion is p, only polynomial space is necessary. The second requirement is that we need NM0 = Praccepts w, the value needed to determine whether w is in A. We use induction to prove this as follows.|$|E
5000|$|An EE can utilize CMP {{to obtain}} {{certificates}} from the CA. This {{can be done}} through an [...] "initial registration/certification", a [...] "key pair update" [...] or a [...] "certificate update" [...] <b>message</b> <b>sequence.</b> By means of a revocation request it can also get {{one of its own}} certificates revoked. Using a [...] "cross-certification request" [...] a CA can get a certificate signed by another CA. In case an EE has lost its private key and it is stored by the CA, it might be recovered by requesting a [...] "key pair recovery".|$|E
40|$|Varshamov-Tenengolts (VT) {{codes are}} {{a class of}} codes which can correct a single {{deletion}} or insertion with a linear-time decoder. This paper addresses the problem of efficient encoding of non-binary VT codes, defined over an alphabet of size $q > 2 $. We propose a simple linear-time encoding method to systematically map binary <b>message</b> <b>sequences</b> onto VT codewords. The method provides a new lower bound {{on the size of}} $q$-ary VT codes of length $n$...|$|R
40|$|<b>Sequencing</b> <b>messages</b> {{and channel}} {{assignment}} are two important issues {{that need to}} be addressed in scheduling messages in a WDM network. Channel assignment addresses the problem of choosing an appropriate data channel via which a message is transmitted to a node. This problem has been addressed extensively in the literature. Among reservation-based techniques, <b>message</b> <b>sequencing</b> which addresses the order in which messages are sent, has rarely been addressed. In this paper, we propose a set of reservation-based scheduling techniques for single-hop, WDM passive star networks which address both the sequencing aspect and the assignment aspect of the problem. Two priority schemes for <b>sequencing</b> <b>messages,</b> and their performance tradeoffs are also discussed in the paper. We evaluate the proposed algorithms by comparing their performance with an algorithm that only addresses the assignment problem, through a number of experiments. The results of the experiments show significant improvements in pe [...] ...|$|R
40|$|Monitoring {{communication}} {{is central to}} the development and ttming of parallel and distributed applications. Available tools for network monitoring typically capture the network traffic at TCP or IP layers, but a software developer is most interested in the <b>message</b> exchange <b>sequence</b> between pairs of nodes executing the application. However, capturing application level traffic requires instrumenting the application code, which is cumbersome and not even an option in most cases. We present a procedure that reconstructs the application layer <b>message</b> <b>sequences</b> by analyzing TCP layer traffic. The basic idea is that, since TCP traffic is constructed with a well defined procedure from application traffic, {{it should be possible to}} reconstruct application message exchanges from TCP segments. We demonstrate that the procedure is effective, although not perfect, by extensive experimentation with NASA's NAS parallel benchmarks...|$|R
