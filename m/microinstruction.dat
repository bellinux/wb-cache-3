54|35|Public
50|$|Usually the {{addresses}} {{are generated}} by {{some combination of}} a counter, a field from a <b>microinstruction,</b> and some subset of the instruction register. A counter {{is used for the}} typical case, that the next <b>microinstruction</b> is the one to execute. A field from the <b>microinstruction</b> is used for jumps, or other logic.|$|E
50|$|Microcode can be {{characterized}} as horizontal or vertical, referring primarily to whether each <b>microinstruction</b> controls CPU elements with little or no decoding (horizontal microcode) or requires extensive decoding by combinatorial logic before doing so (vertical microcode). Consequently, each horizontal <b>microinstruction</b> is wider (contains more bits) and occupies more storage space than a vertical <b>microinstruction.</b>|$|E
5000|$|III: 4 Top of stack registers, 175 ns <b>microinstruction</b> {{cycle time}} → 5.7 MHz ...|$|E
5000|$|... {{allows the}} {{creation}} of a CPU (a virtual one), including the registers, RAM, <b>microinstructions,</b> and machine instructions; ...|$|R
50|$|The ESP was a VLSI device {{designed}} in a 1.0 micrometre double-metal CMOS process. The multiplicity and {{flexibility of the}} data paths in the ESP allowed many DSP operations to be accomplished in a minimum number of <b>microinstructions</b> steps. Its nominal instruction cycle was 250 ns, yielding program lengths from about 64 to 160 <b>microinstructions</b> at typical sample rates. Because the ESP chip was fully programmable, the range of effects was unlimited.|$|R
50|$|The idea of {{microprogramming}} {{was introduced}} by Maurice Wilkes in 1951 as an intermediate level to execute computer program instructions. Microprograms were organized as a sequence of <b>microinstructions</b> and stored in special control memory. The algorithm for the microprogram control unit is usually specified by flowchart description. The main advantage of the microprogram control unit is the simplicity of its structure. Outputs of the controller are organized in <b>microinstructions</b> {{and they can be}} easily replaced.|$|R
5000|$|<b>Microinstruction</b> - {{from the}} Greek [...] (mikros) meaning [...] "small" [...] and the Latin ...|$|E
5000|$|... 40, 42, 44, 48: Schottky TTL, 4 Top of stack registers, 105 ns <b>microinstruction</b> {{cycle time}} → 9.5 MHz ...|$|E
5000|$|... 30, 33: Silicon on sapphire, 2 Top of stack registers, 90 ns <b>microinstruction</b> {{cycle time}} → 11 MHz, {{instructions}} take 3-7 cycles ...|$|E
50|$|In {{a single}} processor, MLP may be {{considered}} a form of instruction-level parallelism (ILP). However, ILP is often conflated with superscalar, the ability to execute more than one instruction at the same time. E.g., a processor such as the Intel Pentium Pro is five-way superscalar, {{with the ability to}} start executing five different <b>microinstructions</b> in a given cycle, but it can handle four different cache misses for up to 20 different load <b>microinstructions</b> at any time.|$|R
50|$|Since CPUs {{implement}} {{an instruction}} set, it's very useful {{to be able}} to decode the instruction's bits directly into the sequencer, to select a set of <b>microinstructions</b> to perform a CPU's instructions.|$|R
5000|$|The Model 50 has two {{internal}} datapaths which {{operated in}} parallel: a 32-bit datapath used for arithmetic operations, and an 8-bit data path {{used in some}} logical operations. The control store uses 90-bit <b>microinstructions.</b>|$|R
5000|$|... 64, 68: ECL, 8 Top of Stack registers, 75 ns <b>microinstruction</b> {{cycle time}} → 13 MHz, 8KB cache, 60KB WCS, 2 16-bit ALUs ...|$|E
50|$|The control store {{usually has}} a {{register}} on its outputs. The outputs that {{go back into}} the sequencer to determine the next address have to go through some sort of register to prevent the creation of a race condition. In most designs all of the other bits also go through a register. This is because the machine will work faster if the execution of the next <b>microinstruction</b> is delayed by one cycle. This register is known as a pipeline register. Very often the execution of the next <b>microinstruction</b> is dependent on the result of the current <b>microinstruction,</b> which will not be stable {{until the end of the}} current microcycle. It can be seen that either way, all of the outputs of the control store go into one big register. Historically it used to be possible to buy EPROMs with these register bits on the same chip.|$|E
5000|$|Microprograms {{consist of}} series of microinstructions, which control the CPU {{at a very}} {{fundamental}} level of hardware circuitry. For example, a single typical horizontal <b>microinstruction</b> might specify the following operations: ...|$|E
40|$|Microcode {{compaction}} is {{an essential}} tool for the compilation of high-level language microprograms into <b>microinstructions</b> with parallel microoperations. Although guaranteeing minimum execution time is an exponentially complex problem, recent research indicates {{that it is not}} difficult to obtain practical results. This paper, whic...|$|R
25|$|The AGC {{also had}} 20 {{involuntary}} counters. These were memory locations which functioned as up/down counters, or shift registers. The counters would increment, decrement, or shift {{in response to}} internal inputs. The increment (Pinc), decrement (Minc), or shift (Shinc) was handled by one subsequence of <b>microinstructions</b> inserted between any two regular instructions.|$|R
40|$|Approved {{for public}} release; {{distribution}} is unlimitedThe {{design of a}} COBOL editor and interpreter is explored which uses simple, straightforward algorithms similar to the approach found in programmable calculators. The algorithms {{are designed to be}} implemented using the <b>microinstructions</b> of a high-performance bit-slice microprocessor. A possible machine design using a family of microprogrammable four-bit-slice bipolar circuits is outlined. [URL] United States Nav...|$|R
50|$|Each Cyberplus (aka Advanced Flexible Processor, AFP) is a 16-bit {{processor}} with optional 64-bit floating point capabilities and has 256 K or 512 K words of 64-bit memory. The AFP was {{the successor to}} the Flexible Processor (FP), whose design development started in 1972 under black-project circumstances targeted at processing radar and photo image data. The FP control unit had a hardware network for conditional <b>microinstruction</b> execution, with four mask registers and a condition-hold register; three bits in the <b>microinstruction</b> format select among nearly 50 conditions for determining execution, including result sign and overflow, I/O conditions, and loop control.|$|E
50|$|When {{compared}} to normal application programs, the elements composing a microprogram exist on a lower conceptual level. To avoid confusion, each microprogram-related element is differentiated by the micro prefix: <b>microinstruction,</b> microassembler, microprogrammer, microarchitecture, etc.|$|E
50|$|The Rigel {{architecture}} {{was based}} on the VAX 8800 processor. It has a six-stage <b>microinstruction</b> pipeline and 64-entry fully associative translation look-aside buffer. The Rigel chip set supported an optional vector processor and the REX520 decoded any vector instructions and passed on to the vector interface (VC) chip by the REX520.|$|E
40|$|GA 103 is a 16 bit microprogrammable processor, which emulates the PDP 11 {{instruction}} set. It {{is based}} on the Am 2900 slices. It allows user- implemented <b>microinstructions</b> and addition of hardwired processors. It will perform online filtering tasks in the NA 14 experiment at CERN, based on the reconstruction of transverse momentum of photons detected in a lead glass calorimeter. (3 refs) ...|$|R
5000|$|The System Control Unit (SCU) was a [...] "microprogrammable data processor" [...] {{which can}} {{interface}} to a Sigma CPU, and [...] "to peripheral and analog devices, {{and to many}} kinds of line protocol." [...] The SCU executes horizontal <b>microinstructions</b> with a 32-bit word length. A cross-assembler running on a Sigma system {{can be used to}} create microprograms for the SCU.|$|R
5000|$|The B700 [...] "microprocessor" [...] execute {{application-level}} opcodes using {{sequences of}} 16-bit <b>microinstructions</b> stored in main memory; {{each of these}} is either a register-load operation or mapped to a single 56-bit [...] "nanocode" [...] instruction stored in read-only memory. This allows comparatively simple hardware to act either as a mainframe peripheral controller or to be packaged as a standalone computer.|$|R
50|$|The PERQ CPU was a microcoded {{discrete}} logic design, {{rather than}} a microprocessor. It was based around 74S181 bit-slice ALUs and an Am2910 microcode sequencer. The PERQ CPU was unusual in having 20-bit wide registers and a writable control store (WCS), allowing the microcode to be redefined. The CPU had a <b>microinstruction</b> cycle period of 170 ns (5.88 MHz).|$|E
5000|$|Predicated {{instructions}} were popular in European computer designs of the 1950s, including the Mailüfterl (1955), the Zuse Z22 (1955), the ZEBRA (1958), and the Electrologica X1 (1958). The IBM ACS-1 design of 1967 allocated a [...] "skip" [...] bit in its instruction formats, and the CDC Flexible Processor in 1976 allocated three conditional execution bits in its <b>microinstruction</b> formats.|$|E
50|$|To {{simultaneously}} {{control all}} processor's features in one cycle, the <b>microinstruction</b> is often wider than 50 bits; e.g., 128 bits on a 360/85 with an emulator feature. Microprograms are carefully designed and optimized for the fastest possible execution, as a slow microprogram {{would result in}} a slow machine instruction and degraded performance for related application programs that use such instructions.|$|E
5000|$|The Model 25 {{is unique}} among System/360 models {{in using the}} top 16 K bytes of core storage to hold the control storage for the microprogram. The 2025 uses a 16-bit {{microarchitecture}} with seven control words (or <b>microinstructions).</b> At power up, or full system reset, the microcode is loaded from the card reader. The IBM 1410 emulation for this model is loaded this way.|$|R
40|$|Abstract — The {{introduction}} of computer architecture {{in computer science}} studies has created a demand for a highly simplified architecture and graphical tools to illustrate its operation. This paper presents the approach followed at the University of Oviedo. The main concepts introduced to the students are relative to RISC instruction sets, data-path architecture, control steps within instructions and <b>microinstructions.</b> Keywords—Computer architecture education, data-path control signals, CPU operation simulation I...|$|R
40|$|This paper {{provides}} {{the first comprehensive}} description of the Z 1, the mechanical computer built by the German inventor Konrad Zuse in Berlin from 1936 to 1938. The paper describes the main structural elements of the machine, the high-level architecture, and the dataflow between components. The computer could perform the four basic arithmetic operations using floating-point numbers. Instructions were read from punched tape. A program consisted of a sequence of arithmetical operations, intermixed with memory store and load instructions, interrupted possibly by input and output operations. Numbers were stored in a mechanical memory. The machine did not include conditional branching in the instruction set. While {{the architecture of the}} Z 1 is similar to the relay computer Zuse finished in 1941 (the Z 3) there are some significant differences. The Z 1 implements operations as sequences of <b>microinstructions,</b> as in the Z 3, but does not use rotary switches as micro-steppers. The Z 1 uses a digital incrementer and a set of conditions which are translated into <b>microinstructions</b> for the exponent and mantissa units, {{as well as for the}} memory blocks. <b>Microinstructions</b> select one out of 12 layers in a machine with a 3 D mechanical structure of binary mechanical elements. The exception circuits for mantissa zero, necessary for normalized floating-point, were lacking; they were first implemented in the Z 3. The information for this article was extracted from careful study of the blueprints drawn by Zuse for the reconstruction of the Z 1 for the German Technology Museum in Berlin, from some letters, and from sketches in notebooks. Although the machine has been in exhibition since 1989 (non-operational), no detailed high-level description of the machine's architecture had been available. This paper fills that gap. Comment: 24 pages, 20 figure...|$|R
5000|$|... "Horizontal {{microcode}} {{has several}} discrete micro-operations that are combined {{in a single}} <b>microinstruction</b> for simultaneous operation." [...] Horizontal microcode is typically contained in a fairly wide control store; {{it is not uncommon}} for each word to be 108 bits or more. On each tick of a sequencer clock a microcode word is read, decoded, and used to control the functional elements that make up the CPU.|$|E
5000|$|Each <b>microinstruction</b> in a {{microprogram}} {{provides the}} bits {{that control the}} functional elements that internally compose a CPU. The advantage over a hard-wired CPU is that internal CPU control becomes a specialized form of a computer program. Microcode thus transforms a complex electronic design challenge (the control of a CPU) into a less complex programming challenge. To take advantage of this, a CPU is divided into several parts: ...|$|E
50|$|Many RISC and VLIW {{processors}} {{are designed}} to execute every instruction (as {{long as it is}} in the cache) in a single cycle. This is very similar to the way CPUs with microcode execute one <b>microinstruction</b> per cycle. VLIW processors have instructions that behave similarly to very wide horizontal microcode, although typically without such fine-grained control over the hardware as provided by microcode. RISC instructions are sometimes similar to the narrow vertical microcode.|$|E
40|$|A {{programmable}} {{cellular array}} is investigated in this thesis. Each {{cell in the}} array is a multi-state network containing combinational logic and a data storage element. The function performed by a cell {{is determined by the}} state of the cell and by inputs from neighboring cells. This method of choosing the cell's function allows any combination of cell states in a row or a column. Also, utilization of signals from neighboring cells allows internally generated (as well as external) signals to control a cell. The array is utilized by first programming it to perform several operations and then applying <b>microinstructions</b> which cause the operations to be executed. (A program is a specification {{of the state of the}} cells in the array.) The <b>microinstructions</b> contain both data and control information so that all inputs are to the top of the array. This feature reduces the number of external pins to the array. The array can be programmed to operate as an arithmetic processor capable of performing several arithmetic operations. This ability is demonstrated by the implementation of algorithms to perform binary addition, subtraction, multiplication, and division. The array can be programmed to perform other useful operations including conversion between BCD and binary representations, double-precision addition, decimal addition and subtraction, and permutation of variables...|$|R
5000|$|There was an onboard {{stack of}} 1024 16-bit words, so that both scalars and sets could be {{operated}} on there. The top ofthe stack was actually kept {{in one of}} the AMD 2901's registers, so that simple operations like integer addition took a single cycle.before we stole the technique of keeping the top word of the stack {{in one of the}} AMD 2901 registers. These often resulted in one fewer <b>microinstructions.</b> (The stack doesn't quite operate this way...it decrements before data is written to it, and incrementsafter data is read.) ...|$|R
40|$|The aim of {{the work}} is to develop the methods for {{functional}} diagnostics and control-able synthesis of the microprogram control devices. The methods and algorithms of algorithm graph-circuit transformation for providing control-ability of the synthesized control devices have been proposed. The methods for control-able synthesis of the logic control devices have been improved. The algorithms for coding of the <b>microinstructions</b> and for diagnostics of the microprogram control devices have been developed. Application field: Research Institute of Computers, Scientific and Production Association "Integral", Minsk Production Association of Computer EngineeringAvailable from VNTIC / VNTIC - Scientific & Technical Information Centre of RussiaSIGLERURussian Federatio...|$|R
