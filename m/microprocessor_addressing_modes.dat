0|828|Public
50|$|The {{system was}} based on a Z80 <b>Microprocessor</b> <b>addressing</b> a mixture of 8 KB of system RAM and EPROM, plus 2 KB of Video RAM.|$|R
5000|$|<b>Address</b> <b>mode</b> {{operations}} - Use <b>address</b> <b>modes</b> {{to simplify}} code.|$|R
50|$|When {{there are}} only a few <b>addressing</b> <b>modes,</b> the {{particular}} <b>addressing</b> <b>mode</b> required is usually encoded within the instruction code(e.g. IBM System/360 and successors, most RISC). But when there are lots of <b>addressing</b> <b>modes,</b> a specific field is often set aside in the instruction to specify the <b>addressing</b> <b>mode.</b> The DEC VAX allowed multiple memory operands for almost all instructions, and so reserved the first few bits of each operand specifier to indicate the <b>addressing</b> <b>mode</b> for that particular operand.Keeping the <b>addressing</b> <b>mode</b> specifier bits separate from the opcode operation bits produces an orthogonal instruction set.|$|R
5000|$|Unlike the octal-oriented PDP-11, the VAX-11 was a hexadecimal-oriented machine (4-bit sub-byte). This {{resulted}} in 16 logical <b>addressing</b> <b>modes</b> (0-15), however, <b>addressing</b> <b>modes</b> 0-3 were [...] "short immediate" [...] for immediate data of 6 bits or less (the 2 low-order {{bits of the}} <b>addressing</b> <b>mode</b> being the 2 high-order bits of the immediate data, when prepended to the remaining 4 bits in that data-addressing byte). Since <b>addressing</b> <b>modes</b> 0-3 were identical, this made 13 (electronic) <b>addressing</b> <b>modes,</b> but as in the PDP-11, {{the use of the}} Stack Pointer (R14) and Program Counter (R15) created a total of over 15 conceptual <b>addressing</b> <b>modes</b> (with the assembler program translating the source code into the actual stack-pointer or program-counter based <b>addressing</b> <b>mode</b> needed).|$|R
50|$|This <b>addressing</b> <b>mode</b> {{is closely}} related to the indexed {{absolute}} <b>addressing</b> <b>mode.</b>|$|R
5000|$|Different {{computer}} architectures vary greatly {{as to the}} number of <b>addressing</b> <b>modes</b> they provide in hardware. There are some benefits to eliminating complex <b>addressing</b> <b>modes</b> and using only one or a few simpler <b>addressing</b> <b>modes,</b> even though it requires a few extra instructions, and perhaps an extra register. [...] It has proven much easier to design pipelined CPUs if the only <b>addressing</b> <b>modes</b> available are simple ones.|$|R
40|$|Many {{processor}} architectures {{provide a}} set of <b>addressing</b> <b>modes</b> in their <b>address</b> generation units. For example DSPs (digital signal processors) have powerful <b>addressing</b> <b>modes</b> for efficiently implementing numerical algorithms. Typical <b>addressing</b> <b>modes</b> of DSPs are auto post-modification and indexing for address registers. The selection of the optimal <b>addressing</b> <b>modes</b> in the means of minimal code size and minimal execution time depends on many parameters and is NP complete in general. In this work we present a new approach for solving the <b>addressing</b> <b>mode</b> selection (AMS) problem. We provide a method for modeling the target architecture’s <b>addressing</b> <b>modes</b> as cost functions for a partitioned boolean quadratic optimization problem (PBQP). For solving the PBQP we present an efficient and effect way to implement large matrices for modeling the cost model. We have integrated the <b>addressing</b> <b>mode</b> selection with the Atair C-Compiler for the uPD 7705 x DSP from NEC. In our experiments we show that the <b>addressing</b> <b>mode</b> selection can be optimally solved for almost all benchmark programs and the compile-time overhead of the <b>address</b> <b>mode</b> selection is within acceptable bounds for a production DSP compiler. ...|$|R
50|$|Since the PDP-11 was an octal-oriented (3-bit sub-byte) machine (<b>addressing</b> <b>modes</b> 0-7, {{registers}} R0-R7), {{there were}} (electronically) 8 <b>addressing</b> <b>modes.</b> Through {{the use of}} the Stack Pointer (R6) and Program Counter (R7) as referenceable registers, there were 10 conceptual <b>addressing</b> <b>modes</b> available.|$|R
25|$|The {{designers}} {{attempted to}} make the assembly language orthogonal. That is, instructions are divided into operations and <b>address</b> <b>modes,</b> and almost all <b>address</b> <b>modes</b> are available for almost all instructions. There are 56 instructions and a minimum instruction size of 16 bits. Many instructions and <b>addressing</b> <b>modes</b> are longer to include additional <b>address</b> or <b>mode</b> bits.|$|R
5000|$|Note {{that there}} is no {{generally}} accepted way of naming the various <b>addressing</b> <b>modes.</b> In particular, different authors and computer manufacturers may give different names to the same <b>addressing</b> <b>mode,</b> or the same names to different <b>addressing</b> <b>modes.</b> Furthermore, an <b>addressing</b> <b>mode</b> which, in one given architecture, is treated as a single <b>addressing</b> <b>mode</b> may represent functionality that, in another architecture, is covered by two or more <b>addressing</b> <b>modes.</b> For example, some complex instruction set computer (CISC) architectures, such as the Digital Equipment Corporation (DEC) VAX, treat registers and literal or immediate constants as just another <b>addressing</b> <b>mode.</b> Others, such as the IBM System/360 and its successors, and most reduced instruction set computer (RISC) designs, encode this information within the instruction. Thus, the latter machines have three distinct instruction codes for copying one register to another, copying a literal constant into a register, and copying the contents of a memory location into a register, while the VAX has only a single [...] "MOV" [...] instruction.|$|R
50|$|Even on a {{computer}} with many <b>addressing</b> <b>modes,</b> measurements of actual programs indicate that the simple <b>addressing</b> <b>modes</b> listed below account for some 90% or more of all <b>addressing</b> <b>modes</b> used. Since most such measurements are based on code generated from high-level languages by compilers, this reflects to some extent {{the limitations of the}} compilers being used.|$|R
50|$|A Change <b>Address</b> <b>Mode</b> (CAM) {{instruction}} switched between 2-, 3- and 4-character <b>address</b> modes.The <b>address</b> <b>mode</b> specified {{the number}} of characters needed for each operand address in instructions.|$|R
5000|$|Support {{of several}} <b>addressing</b> <b>modes.</b> In {{addition}} to the 6-byte MAC address (including multicast and unicast), it supports a MAC address-less mode, and an optional 3-byte <b>address</b> <b>mode.</b>|$|R
40|$|GCC has {{no formal}} <b>addressing</b> <b>mode</b> {{selection}} mechanism. It uses target hooks to generate valid <b>addressing</b> <b>modes</b> for a target. However, {{a significant amount}} of high level information is destroyed while doing this, especially for targets lacking a rich set of <b>addressing</b> <b>modes.</b> This leads to poor aliasing, and subsequently poorer CSE, GCSE, and scheduling. Hence, an unoptimal object code. This paper proposes an abstraction over RTL to generate machine independent <b>addressing</b> <b>modes</b> to achieve better aliasing. The actual <b>addressing</b> <b>modes</b> of the target are exposed after the first scheduling pass, where they are selected based on current execution scenario. Inter block address inheritance is also done at this point. The idea can be extended to specify a general “mid-level ” RTL for GCC...|$|R
40|$|In this paper, two new <b>addressing</b> <b>modes</b> are {{introduced}} to the 16 -bit Thumb instruction set architecture to improve performance of the ARM/Thumb processors. Contrary to previous approaches, the proposed approach focuses on the <b>addressing</b> <b>mode</b> of the instruction set architecture. It adopts scaled register offset <b>addressing</b> <b>mode</b> and post-indexed <b>addressing</b> <b>mode</b> from the 32 -bit ARM architecture, which is the superset of the 16 -bit Thumb architecture. To provide the encoding space for the new <b>addressing</b> <b>modes,</b> the register fields in the LDM and STM instructions are reduced, which are not frequently executed. Experiments show the proposed extension achieves an average of 7. 0 % performance improvement for the seven benchmark programs {{when compared to the}} 16 -bit Thumb instruction set architecture...|$|R
50|$|As a result, {{a greater}} number of {{programs}} were able to utilize the enhanced direct page <b>addressing</b> <b>mode</b> versus legacy processors that only included the zero page <b>addressing</b> <b>mode.</b>|$|R
50|$|Additionally, a third index {{register}} (Z) was included, the stack pointer was widened to 16 bits, and the zero page <b>addressing</b> <b>mode</b> was superseded {{by the more}} flexible direct page <b>addressing</b> <b>mode.</b>|$|R
50|$|A {{cylinder}} is {{a division}} of data in a disk drive, as used in the CHS <b>addressing</b> <b>mode</b> of a Fixed Block Architecture disk or the cylinder-head-record (CCHHR) <b>addressing</b> <b>mode</b> of a CKD disk.|$|R
50|$|<b>Addressing</b> <b>modes</b> are {{an aspect}} of the {{instruction}} set architecture in most central processing unit (CPU) designs. The various <b>addressing</b> <b>modes</b> that are defined in a given instruction set architecture define how machine language instructions in that architecture identify the operand(s) of each instruction. An <b>addressing</b> <b>mode</b> specifies how to calculate the effective memory address of an operand by using information held in registers and/or constants contained within a machine instruction or elsewhere.|$|R
50|$|Besides instructions, the ISA defines {{items in}} the {{computer}} {{that are available to}} a program - e.g. data types, registers, <b>addressing</b> <b>modes,</b> and memory. Instructions locate these available items with register indexes (or names) and memory <b>addressing</b> <b>modes.</b>|$|R
50|$|Within a loop, this <b>addressing</b> <b>mode</b> {{can be used}} to step {{backwards}} {{through all}} the elements of an array or vector. A stack can be implemented by using this mode in conjunction with the previous <b>addressing</b> <b>mode</b> (autoincrement).|$|R
5000|$|With four <b>address</b> <b>mode</b> {{selection}} bits (P, R, I and N - indexed, relative, indirect and immediate), NAR 2 instructions can specify 16 different <b>addressing</b> <b>modes</b> but not {{all make}} sense in all instructions. In the following table: ...|$|R
50|$|The <b>{{addressing}}</b> <b>modes</b> {{listed below}} {{are divided into}} code addressing and data addressing. Most computer architectures maintain this distinction, but there are, or have been, some architectures which allow (almost) all <b>addressing</b> <b>modes</b> {{to be used in}} any context.|$|R
5000|$|The x86-64 {{architecture}} and the 64-bit ARMv8-A architecture have PC-relative <b>addressing</b> <b>modes,</b> called [...] "RIP-relative" [...] in x86-64 and [...] "literal" [...] in ARMv8-A. The Motorola 6809, a very advanced 8-bits CPU designed in 1978, also supports a PC-relative <b>addressing</b> <b>mode.</b>|$|R
25|$|Has {{powerful}} indexed <b>addressing</b> <b>modes.</b>|$|R
5000|$|... +-----------------+ | clear {{carry bit}} | +-----------------+ [...] +-------------------+ | clear Accumulator | +-------------------+The implied <b>addressing</b> <b>mode,</b> {{also called the}} {{implicit}} <b>addressing</b> <b>mode</b> (X86 assembly language), does not explicitly specify an effective address for either the source or the destination (or sometimes both).|$|R
2500|$|An {{instruction}} set {{is said to}} be orthogonal if it lacks redundancy (i.e., there is only a single instruction {{that can be used to}} accomplish a given task) and is designed such that instructions can use any register in any <b>addressing</b> <b>mode.</b> This terminology results from considering an instruction as a vector whose components are the instruction fields. [...] One field identifies the registers to be operated upon and another specifies the <b>addressing</b> <b>mode.</b> An orthogonal {{instruction set}} uniquely encodes all combinations of registers and <b>addressing</b> <b>modes.</b>|$|R
50|$|The two <b>addressing</b> <b>modes</b> Indirect {{register}}, and Indirect {{register with}} auto-increment are then fairly efficient, to perform 8-bit operations {{on the data}} in the accumulator. There are no other <b>addressing</b> <b>modes,</b> though. Thus, the direct <b>addressing</b> <b>mode</b> needs to be emulated using the four instructions mentioned earlier to load the address into a spare register; followed by an instruction to select that register as the index register; followed, finally, by the intended operation on the data variable that is pointed to by that address.|$|R
5000|$|The {{first four}} {{general-purpose}} RAM locations are {{also known as}} the X, Y, V and W registers, and some instructions can access them using special short <b>addressing</b> <b>modes.</b> The X and Y registers serve as index registers, and can use indirect <b>addressing</b> <b>modes</b> [...] and [...]|$|R
50|$|The <b>addressing</b> <b>modes</b> {{listed here}} {{were used in}} the 1950-1980 period, but are no longer {{available}} on most current computers.This list is by no means complete; there have been many other interesting and peculiar <b>addressing</b> <b>modes</b> used from time to time, e.g. absolute-minus-logical-OR of two or three index registers.|$|R
50|$|In {{the early}} {{instances}} {{of the architecture}} (System/360 and early System/370), the instruction address was 24 bits; in later instances (XA/370), the instruction address was 31 bits plus a mode bit (24 bit <b>addressing</b> <b>mode</b> if zero; 31 bit <b>addressing</b> <b>mode</b> if one) {{for a total of}} 32 bits.|$|R
50|$|Most RISC {{architectures}} {{have only}} about five simple <b>addressing</b> <b>modes,</b> while CISC architectures {{such as the}} DEC VAX have over a dozen <b>addressing</b> <b>modes,</b> {{some of which are}} quite complicated. The IBM System/360 architecture had only three addressing modes; a few more have been added for the System/390.|$|R
40|$|This manual {{describes}} the architecture, registers, {{and operation of}} the fixedpoint TMS 320 C 55 x ™ digital signal processor (DSP) CPU. About This Maual Release This release is updated with the 3. x Revision of the TMS 320 C 55 x DSP. Information not affected by the revision remains identical to the previous manual. The main new features of this revision are: The 23 -bit linear data addressing feature, which affects only the indirect <b>addressing</b> <b>mode</b> and the circular <b>addressing</b> <b>mode.</b> All other <b>addressing</b> <b>modes</b> or I/O space <b>addressing</b> <b>mode</b> remain {{the same as in}} the previous manual. All information on this feature is in Chapter 6. Data read bus extension to 32 -bit (BB bus). It introduces the new double coefficient indirect <b>addressing</b> <b>mode.</b> All information on this feature is in Chapter 1. Program bus extension to 32 -bit (PB bus) and IBQ size enlarged to 128 bytes. Instruction decoder can now accept 8 bytes of program code from the instruction buffer queue. All information on this feature is i...|$|R
2500|$|Simple <b>addressing</b> <b>modes</b> {{with complex}} <b>addressing</b> {{performed}} by instruction sequences ...|$|R
50|$|See the {{discussion}} of side-effects under the autoincrement <b>addressing</b> <b>mode.</b>|$|R
5000|$|<b>Addressing</b> <b>modes</b> added scaled {{indexing}} {{and another}} level of indirection ...|$|R
