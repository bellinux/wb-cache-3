127|238|Public
25|$|In 1951, British {{scientist}} Maurice Wilkes {{developed the}} concept of <b>microprogramming</b> from the realisation that the central processing unit of a computer could be controlled by a miniature, highly specialised computer program in high-speed ROM. <b>Microprogramming</b> allows the base instruction set to be defined or extended by built-in programs (now called firmware or microcode). This concept greatly simplified CPU development. He first described this at the University of Manchester Computer Inaugural Conference in 1951, then published in expanded form in IEEE Spectrum in 1955.|$|E
25|$|WepSIM is a {{browser-based}} simulator where {{a subset}} of MIPS instructions are micro-programmed. This simulator is very useful {{in order to learn}} how a CPU works (<b>microprogramming,</b> MIPS rutines, traps, interruptions, system calls, etc.).|$|E
25|$|From {{the late}} 1960s {{through the late}} 1970s, several {{hardware}} capabilities evolved that allowed similar or ported software to run {{on more than one}} system. Early systems had utilized <b>microprogramming</b> to implement features on their systems in order to permit different underlying computer architectures to appear to be the same as others in a series. In fact, most 360s after the 360/40 (except the 360/165 and 360/168) were microprogrammed implementations.|$|E
5000|$|The most {{general-purpose}} register-transfer logic {{machine is}} a computer. This is basically an automatic binary abacus. The control unit {{of a computer}} is usually designed as a <b>microprogram</b> run by a microsequencer. A <b>microprogram</b> is much like a player-piano roll. Each table entry or [...] "word" [...] of the <b>microprogram</b> commands the state of every bit that controls the computer. The sequencer then counts, and the count addresses the memory or combinational logic machine that contains the <b>microprogram.</b> The bits from the <b>microprogram</b> control the arithmetic logic unit, memory {{and other parts of}} the computer, including the microsequencer itself. A [...] "specialized computer" [...] is usually a conventional computer with special-purpose control logic or <b>microprogram.</b>|$|R
50|$|A microassembler is a {{computer}} program that helps prepare a <b>microprogram,</b> called firmware, to control the low level operation of {{a computer}} {{in much the same}} way an assembler helps prepare higher level code for a processor. The difference is that the <b>microprogram</b> is usually only developed by the processor manufacturer and works intimately with the computer hardware. On a <b>microprogrammed</b> computer the <b>microprogram</b> implements the operations of the instruction set in which any normal program (including both application programs and operating systems) is written. The use of a <b>microprogram</b> allows the manufacturer to fix certain mistakes, including working around hardware design errors, without modifying the hardware. Another means of employing microassembler-generated <b>microprograms</b> is in allowing the same hardware to run different instruction sets. After it is assembled, the <b>microprogram</b> is then loaded to a control store to become part of the logic of a CPU's control unit.|$|R
40|$|Modern {{large scale}} {{integration}} (LSI) microcircuits {{are meant to}} be programmed in order to control the function that they perform. The author explores the methods of developing software for microcircuits. This generally requires a package of support software in order to assemble the <b>microprogram,</b> and also some amount of support software to test the <b>microprograms</b> and to test the <b>microprogrammed</b> circuit itself. (7 refs) ...|$|R
5000|$|... 1980. Firmware, <b>microprogramming,</b> and restructurable {{hardware}} : {{proceedings of}} the IFIP Working Conference on Firmware, <b>Microprogramming,</b> and Restructurable Hardware, Linz, Austria, April 28-May 1, 1980. Edited with Jörg R. Mühlbacher.|$|E
5000|$|... "Second Euromicro Symposium on Microprocessing and <b>Microprogramming,</b> October 12-14, 1976, Venice : papers / [...] " [...] Euromicro Symposium on Microprocessing and <b>Microprogramming</b> (2nd : 1976 : Venice, Italy) | 1977. | text ...|$|E
5000|$|... "Microcomputer architectures: Third EUROMICRO Symposium on Microprocessing and <b>Microprogramming,</b> October 3-6, 1977, Amsterdam : preprints / [...] " [...] Euromicro Symposium on Microprocessing and <b>Microprogramming</b> (3rd : 1977 : Amsterdam, Netherlands) | 1977. | text ...|$|E
40|$|I Overview of the Université de Montréal, p. 3; II Overview of the Faculty of Education, p. 4; III Overview of the First Nations Education Council, p. 5; IV What Is a <b>Microprogram</b> at the Université de Montréal? p. 6; V Objectives of <b>Microprogram</b> on Pedagogical Integration of ICT, p. 7; VI Assumptions of <b>Microprogram</b> on Pedagogical Integration of ICT, p. 8; VII Admission and Registration, p. 9; VIII Opportunities for <b>Microprogram</b> Participants, p. 10; IX Professorial Team, p. 10; X Pedagogical Formula, p. 11; XI Pedagogical Support, p. 12; XII Continuous Assessment of Training, p. 13; XIII Structure and Length of Program, p. 15; XIV Structure of the Proposed <b>Microprogram,</b> p. 17; XV Program Courses, p. 18; Appendix I Admission Form; Appendix II Effectiveness Conditions for (ODT; Appendix III Details of the Internet videoconferenc...|$|R
50|$|<b>Microprogrammed</b> processors, popular {{from the}} 1960s to the 1980s and beyond, took {{multiple}} cycles per instruction, and generally {{did not require}} branch prediction. However, {{in addition to the}} IBM 3090, there are several other examples of <b>microprogrammed</b> designs that incorporated branch prediction.|$|R
40|$|This paper {{describes}} the MPC (<b>Microprogrammed</b> Controller) Concept used at Sperry Univac Defense Systems Division to implement real-time computer emulations. It discusses {{the concept and}} reasons for <b>microprogrammed</b> emulation and the basic MPC approach. Enhancements developed for the MPC and their impact are also discussed...|$|R
5000|$|TCuARCH - Technical Committee on <b>Microprogramming</b> and Microarchitecture (TCuARCH) ...|$|E
5000|$|So-called [...] "canonical" [...] finite state {{machines}} do the symbol tests [...] "in parallel"; see more at <b>microprogramming.</b>|$|E
5000|$|A700 - {{based on}} AMD AM2903 {{bit-slice}} processor, optional hardware floating point processor, 1MIPS, 204kFLOPS, <b>microprogramming,</b> optional ECC memory. Codename: PHOENIX ...|$|E
40|$|Abstract –A {{torque and}} rotate speed {{measurement}} {{system based on}} <b>microprogrammed</b> control unit was designed. This system was composed of <b>microprogrammed</b> control unit, magnetic-electric torque sensor and signal detection circuit. Approximately sinusoidal signal from the sensor was transformed to square wave in circuit signal processing. By {{the use of the}} <b>microprogrammed</b> control unit, the torque and rotate speed of shaft was obtained from the width of high level and frequency of the phase difference signal. The system had a simple structure, stable performance and high precision...|$|R
5000|$|MPG, the [...] "machine-independent {{efficient}} <b>microprogram</b> generator" ...|$|R
50|$|It {{is one of}} {{the most}} popular {{techniques}} for implementing a read-only memory. A diode matrix is used as the control store or <b>microprogram</b> in many early computers. A logically equivalent transistor matrix is still used as the control store or <b>microprogram</b> or 'decode ROM' in many modern microprocessors.|$|R
5000|$|In the 1970s Chroust {{continued}} to study parallelism and simulation from 1969 until 1972, <b>microprogramming</b> from 1975 until 1990 and compiler building from 1976 until 1982.|$|E
50|$|In 1951, British {{scientist}} Maurice Wilkes {{developed the}} concept of <b>microprogramming</b> from the realisation that the central processing unit of a computer could be controlled by a miniature, highly specialised computer program in high-speed ROM. <b>Microprogramming</b> allows the base instruction set to be defined or extended by built-in programs (now called firmware or microcode). This concept greatly simplified CPU development. He first described this at the University of Manchester Computer Inaugural Conference in 1951, then published in expanded form in IEEE Spectrum in 1955.|$|E
5000|$|Leslie Treloar, rheologist {{and expert}} on rubber, and Maurice Wilkes, {{creator of the}} EDSAC {{computer}} and inventor of <b>microprogramming,</b> worked at TRE briefly during World War II.|$|E
25|$|The AS/400 was {{originally}} {{based on a}} custom IBM CISC CPU which used a CPU architecture known as Internal <b>MicroProgrammed</b> Interface (IMPI) with an instruction set {{similar to that of}} the IBM System/370, known as Internal <b>MicroProgrammed</b> Interface (IMPI). It was later migrated to a POWER-based RISC CPU family eventually known as RS64.|$|R
40|$|<b>Microprogram</b> scheme enables {{computer}} {{to recover from}} failure {{in one of its}} two central processing units during time duration of instruction in which failure occurs. <b>Microprogram</b> advantages include - / 1 / built-in interpretive capability, / 2 / selection of processing interrupts by priority, and / 3 / economical use of bootstrap sequence...|$|R
40|$|Zero-defect {{designs are}} {{the goal of}} current {{research}} activities in CAD. An increasingly popular avenue of attack is formal verification of hardware correctness. Formal verification techniques have been applied widely in the past, {{but most of the}} examples were either simple or verification-oriented. This paper presents the application of such techniques to a real <b>microprogrammed</b> microprocessor, the MTI. Some abstract views of the device are identified, and the upper levels, namely, the machine instruction and <b>microprogram</b> levels, are described and verified within a functional framework. A methodology that is general and applicable to state-of-the-art <b>microprogrammed</b> architectures is a by-product of this work...|$|R
50|$|The use of <b>microprogramming</b> in {{electronic}} transistor computers {{dates back to}} 1961, with the KT-Pilot, an early microprogram-controlled electronic computer developed by Kyoto University and Toshiba in Japan.|$|E
5000|$|In 1951, he {{developed}} the concept of <b>microprogramming</b> from the realisation that the Central Processing Unit of a computer could be controlled by a miniature, highly specialised computer program in high-speed ROM. This concept greatly simplified CPU development. <b>Microprogramming</b> was first described at the University of Manchester Computer Inaugural Conference in 1951, then published in expanded form in IEEE Spectrum in 1955. This concept was implemented {{for the first time}} in EDSAC 2, which also used multiple identical [...] "bit slices" [...] to simplify design. Interchangeable, replaceable tube assemblies were used for each bit of the processor. The next computer for his laboratory was the Titan, a joint venture with Ferranti Ltd begun in 1963. It eventually supported the UK's first time-sharing system and provided wider access to computing resources in the university, including time-shared graphics systems for mechanical CAD[...] Control Memory (CM) which is extremely used in today's computer was developed by using the concept of this <b>Microprogramming.</b>|$|E
50|$|Moreover, {{taxonomies}} {{in computer}} science are typically characterized by such abstractions. What is of interest {{at the level of}} information processing are such things as registers and <b>microprogramming</b> operations, not the causal powers of the material structure of semiconductors.|$|E
40|$|ABSTRACT: This paper {{discusses}} {{a software}} package named SYMCAD, a marketable microcode synthesizer which forms {{part of a}} <b>microprogrammed</b> control synthesis in the VLSI CAD system IDEAS (Integrated Design Automation System) [1 J. The objective is to synthesize a <b>microprogrammed</b> control for a specified data part and microsequencer to realize the behavior expressed in a hardware description language. A distinctive feature {{of this approach is}} the synthesis of a customized control unit suitable for VLSI realization. Retargetable microcode generation comprises symbolic <b>microprogram</b> synthesis, microinstruction format generation and binary microcode generation, to map the required behavior on the specified micro-architecture...|$|R
5000|$|EDSAC_2 {{computer}}, 1965 - first {{computer to}} have a <b>microprogrammed</b> CPU ...|$|R
50|$|The Microdata 3200 was {{developed}} in 1974 and was a 16 bit <b>microprogrammed</b> system designed to implement a high level language similar to IBM's PL/I language. It was designed to a more specific purpose, but still retained {{a great deal of}} flexibility in the firmware to allow for very complex <b>microprogrammed</b> architectures to be supported.|$|R
50|$|<b>Microprogramming</b> also {{reduces the}} cost of field changes to correct defects (bugs) in the processor; a bug can often be fixed by {{replacing}} {{a portion of the}} microprogram rather than by changes being made to hardware logic and wiring.|$|E
50|$|<b>Microprogramming</b> {{is still}} used in modern CPU designs. In some cases, after the {{microcode}} is debugged in simulation, logic functions are substituted {{for the control}} store. Logic functions are often faster and less expensive than the equivalent microprogram memory.|$|E
5000|$|Core memory, microprogrammed CPU. An option allowed user <b>microprogramming.</b> Front panel buttons were {{illuminated}} by small incandescent lamps that burned out with use. Dark lights {{did not bother}} regular users, who knew the 1 and 0 sequences to load the paper tape [...] "loader-loader" [...] instructions without seeing the panel's lights.|$|E
5000|$|C V Ramamoorthy. A {{survey of}} current <b>microprogrammed</b> computers. DAC, pages 272- 274, 1972.|$|R
5000|$|The Digital Equipment Corporation PDP-11 processors, {{with the}} {{exception}} of the PDP-11/20, are <b>microprogrammed.</b>|$|R
40|$|Approved {{for public}} release; {{distribution}} is unlimitedThis thesis presents a basic hardware model suitable for most sequential <b>microprogrammed</b> devices. A software system is described {{which allows the}} use of an assembly-level programming language instead of the binary representation of microcodes. The implementation of a <b>microprogrammed</b> input/output interface is presented as an example of use of both the hardware and software. [URL] Brazilian Nav...|$|R
