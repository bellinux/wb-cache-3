229|734|Public
5|$|Super Mario RPG: Legend of the Seven Stars {{is one of}} {{only seven}} SNES games {{released}} outside Japan to use the Nintendo SA-1 chip. Compared with standard SNES games, the additional microprocessor allows higher clock speeds; faster access to the random-access memory (RAM); greater <b>memory</b> <b>mapping</b> capabilities, data storage, and compression; new direct memory access (DMA) modes, such as bitmap to bit plane transfer; and built-in CIC lockout for piracy protection and regional marketing control.|$|E
25|$|The PCI {{standard}} is discouraging {{the use of}} I/O space in new devices, preferring {{that as much as}} possible be done through main <b>memory</b> <b>mapping.</b>|$|E
25|$|This {{approach}} {{eliminates the}} need for node pointers, substantially reducing the memory requirements. This in turn permits <b>memory</b> <b>mapping</b> and the use of virtual memory to efficiently load the data from disk.|$|E
50|$|The 940 accesses memory {{through a}} <b>memory</b> <b>map</b> to provide virtual <b>memory.</b> The <b>map</b> formats differ {{slightly}} between a user <b>memory</b> <b>map</b> and a monitor <b>memory</b> <b>map.</b>|$|R
5000|$|... jmap Oracle jmap - <b>Memory</b> <b>Map</b> - [...] This utility outputs the <b>memory</b> <b>map</b> for Java and {{can print}} shared object <b>memory</b> <b>maps</b> or heap <b>memory</b> {{details of a}} given process or core dump. (experimental) ...|$|R
50|$|A set of <b>memory</b> <b>map</b> {{registers}} {{is used to}} map virtual addresses to physical. There {{are eight}} <b>memory</b> <b>map</b> registers, each mapping 2K words, to provide an address space of 16K.|$|R
5000|$|TI-990/10 [...] - [...] TTL {{processor}} with <b>memory</b> <b>mapping</b> support to 2M {{bytes of memory}} ...|$|E
5000|$|TI-990/10A [...] - [...] TMS-99000 {{microprocessor}} with <b>memory</b> <b>mapping</b> {{support to}} 1M {{bytes of memory}} ...|$|E
5000|$|A file {{interface}} {{that supports}} locks and <b>memory</b> <b>mapping</b> of files up to [...] bytes (2 GiB) ...|$|E
50|$|In native {{debugger}} programs, a <b>memory</b> <b>map</b> {{refers to}} the mapping between loaded executable/library files and memory regions. These <b>memory</b> <b>maps</b> are used to resolve memory addresses (such as function pointers) to actual symbols.|$|R
50|$|The monitor can {{use either}} the monitor <b>memory</b> <b>map</b> or the user <b>memory</b> <b>map,</b> {{determined}} by the value of bit 0 of the instruction. This allows the monitor access to the user's address space.|$|R
50|$|The {{hardware}} of {{the system}} is arranged so that devices on the address bus will only respond to particular addresses which are intended for them, while all other addresses are ignored. This is the job of the address decoding circuitry, and that establishes the <b>memory</b> <b>map</b> {{of the system}}. As a result, system's <b>memory</b> <b>map</b> may look like in the table on the right. This <b>memory</b> <b>map</b> contains gaps, which is also quite common in actual system architectures.|$|R
50|$|For Perl {{there are}} a several modules {{available}} for <b>memory</b> <b>mapping</b> files on the CPAN, such as Sys::Mmap and File::Map.|$|E
5000|$|The PCI {{standard}} is discouraging {{the use of}} I/O space in new devices, preferring {{that as much as}} possible be done through main <b>memory</b> <b>mapping.</b>|$|E
5000|$|TI-990/12 [...] - [...] Schottky TTL {{processor}} with <b>memory</b> <b>mapping</b> to 2M bytes, workspace caching, hardware floating point, extended mode instructions and writeable control store ...|$|E
50|$|The J {{programming}} language has supported <b>memory</b> <b>mapped</b> files {{since at least}} 2005. It includes support for boxed array data, and single datatype files. Support can be loaded from 'data/jmf' J's Jdb and JD database engines use <b>memory</b> <b>mapped</b> files for column stores.|$|R
5000|$|Buffered, synchronous, asynchronous, direct, and <b>memory</b> <b>mapped</b> I/O ...|$|R
5000|$|XMLMemMappedBuffer {{performs}} <b>memory</b> <b>mapped</b> {{loading of}} XML documents.|$|R
5000|$|Daniel L. Weinreb and Sam J. Haradhvala, [...] "Method and {{apparatus}} for virtual <b>memory</b> <b>mapping</b> and transaction {{management in}} an object-oriented database system", U.S. Patent #5649139 ...|$|E
5000|$|Memory-mapped {{files are}} {{becoming}} more difficult to implement in 32-bit architectures as files of over 4 GiB become more common; such large files cannot be memory-mapped easily to 32-bit architectures, as {{only part of the}} file can be mapped into the address space at a time, and to access such a file by <b>memory</b> <b>mapping,</b> the parts mapped must be swapped {{into and out of the}} address space as needed. This is a problem, as <b>memory</b> <b>mapping,</b> if properly implemented by the OS, is one of the most efficient disk-to-memory methods.|$|E
50|$|Different CPU-to-device {{communication}} methods, such as <b>memory</b> <b>mapping,</b> do {{not affect}} the direct memory access (DMA) for a device, because, by definition, DMA is a memory-to-device communication method that bypasses the CPU.|$|E
50|$|The Linux framebuffer {{device was}} {{developed}} to abstract the physical method for accessing the underlying framebuffer into a guaranteed <b>memory</b> <b>map</b> that is easy for programs to access. This increases portability, as programs {{are not required to}} deal with systems that have disjointed <b>memory</b> <b>maps</b> or require bank switching.|$|R
5000|$|In the Microsoft [...]NET runtime, P/Invoke {{can be used}} to use <b>memory</b> <b>mapped</b> files {{directly}} through the Windows API. Managed access (P/Invoke not necessary) to <b>memory</b> <b>mapped</b> files was introduced in version 4 of the runtime (see Memory-Mapped Files). For previous versions, there are third-party libraries which provide managed API's.|$|R
40|$|The {{design and}} {{implementation}} of some persistent object stores rely {{on the availability of}} <b>memory</b> <b>mapped</b> files. A significant difficulty faced by this approach is that the programmer has very little control over when I/O occurs. In this paper, a mechanism for exposing the I/O activity of a <b>memory</b> <b>mapped</b> file is presented. This involves implementing a special purpose NFS server that provides a shadow paged file which can be <b>memory</b> <b>mapped</b> by a persistent object store. Some initial performance figures are presented to indicate the relative performance of this approach compared to more traditional approaches. Fred Brow...|$|R
50|$|For example, {{getting the}} system time {{involves}} an IPC {{call to the}} user-space server maintaining system clock. The caller first traps into the kernel, causing a context switch and <b>memory</b> <b>mapping.</b> The kernel then checks that the caller has required access rights and that the message is valid. If it does, there is another context switch and <b>memory</b> <b>mapping</b> to complete the call into the user-space server. The process must then be repeated to return the results, adding up {{to a total of}} four context switches and memory mappings, plus two message verifications. This overhead rapidly compounds with more complex services, where there are often code paths passing through many servers.|$|E
5000|$|PDP-11/20 and PDP-11/15 — The original, non-microprogrammed processor; {{designed}} by Jim O'Loughlin. Floating point {{is supported by}} peripheral options using various data formats. The 11/20 lacks any kind of memory protection hardware unless retrofitted with a KS-11 <b>memory</b> <b>mapping</b> add-on.|$|E
5000|$|... stmmap An {{implementation}} of STM in C, based on shared <b>memory</b> <b>mapping.</b> It is for sharing memory between threads and/or processes (not just between threads within a process) with transactional semantics. The multi-threaded {{version of its}} memory allocator is in C++.|$|E
50|$|Another pseudo-type—associated with name, {{rather than}} value—is the <b>memory</b> <b>mapped</b> file.|$|R
5000|$|BIOS Function: INT 0x15, AX=0xE820 - GET SYSTEM <b>MEMORY</b> <b>MAP</b> '''''': ...|$|R
5000|$|... 4 fast {{switchable}} register {{banks with}} 8 registers each (<b>memory</b> <b>mapped)</b> ...|$|R
5000|$|... (These {{should not}} be {{confused}} with hybrid computers that combine both digital and analogue features, e.g. an otherwise digital computer that accesses analogue multiplication or differential equation solving by <b>memory</b> <b>mapping</b> and conversion to and from an analogue device's inputs and outputs.) ...|$|E
5000|$|While framebuffers are {{commonly}} accessed via a <b>memory</b> <b>mapping</b> {{directly to the}} CPU memory space, {{this is not the}} only method by which they may be accessed. Framebuffers have varied widely in the methods used to access memory. Some of the most common are: ...|$|E
50|$|In 1983, OS-9/6809 was ported to Motorola 68000 {{assembly}} language and extended (called OS-9/68K); and a still later (1989) version was rewritten mostly in C for further portability. The portable version was initially called OS-9000 {{and was released}} for 80386 PC systems around 1989, then ported to PowerPC around 1995. These later versions lack the <b>memory</b> <b>mapping</b> facilities of OS-9/6809 Level Two simply {{because they do not}} need them. They used a single flat address space that all processes share; <b>memory</b> <b>mapping</b> hardware, if present, is mostly used to ensure that processes access only that memory {{they have the right to}} access. The 680x0 and 80386 (and later) MPUs all directly support far more than 1 MB of memory in any case.|$|E
2500|$|RAM: {{commonly}} 64kB (on Japanese computers), normally <b>memory</b> <b>mapped</b> (4MB per slot maximum) ...|$|R
5000|$|The Microtan 65 <b>memory</b> <b>map</b> {{is shown}} below ($ {{representing}} a hexadecimal memory address): ...|$|R
5000|$|Missiles {{share the}} same bytes of the <b>memory</b> <b>maps</b> above, two bits per Missile: ...|$|R
