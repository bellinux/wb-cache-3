187|1871|Public
5|$|AMD chose a {{different}} direction, designing the less radical x86-64, a 64-bit extension {{to the existing}} x86 architecture, which Microsoft then supported, forcing Intel to introduce the same extensions in its own x86-based processors. These designs can run existing 32-bit applications at native hardware speed, while offering support for 64-bit <b>memory</b> <b>addressing</b> and other enhancements to new applications. This architecture has now become the predominant 64-bit architecture in the desktop and portable market. Although some Itanium-based workstations were initially introduced by companies such as SGI, {{they are no longer}} available.|$|E
25|$|The use {{of virtual}} <b>memory</b> <b>addressing</b> (such as paging or segmentation) {{means that the}} kernel can choose what memory each program may use at any given time, {{allowing}} the operating system {{to use the same}} memory locations for multiple tasks.|$|E
25|$|MIPS III is a backwards-compatible {{extension}} of MIPS II that added support for 64-bit <b>memory</b> <b>addressing</b> and integer operations. The 64-bit data type {{is called a}} doubleword, and MIPS III extended the general-purpose registers, HI/LO registers, and program counter to 64 bits to support it. New instructions were added to load and store doublewords, to perform integer addition, subtraction, multiplication, division, and shift operations on them, and to move doubleword between the GPRs and HI/LO registers. Existing instructions originally defined to operate of 32-bit words were redefined, where necessary, to sign-extend the 32-bit results to permit words and doublewords to be treated identically by most instructions. Among those instructions redefined was Load Word. In MIPS III it sign-extends words to 64 bits. To complement Load Word, a version that zero-extends was added.|$|E
50|$|In {{the context}} of these definitions, a byte is the {{smallest}} primitive; each <b>memory</b> <b>address</b> specifies a different byte. The <b>memory</b> <b>address</b> of the initial byte of a datum is considered the <b>memory</b> <b>address</b> (or base <b>memory</b> <b>address)</b> of the entire datum.|$|R
5000|$|INP OUT // Initialize output [...] LOOP BRZ QUIT // If the {{accumulator}} {{value is}} 0, {{jump to the}} <b>memory</b> <b>address</b> labeled QUIT SUB ONE // Label this <b>memory</b> <b>address</b> as LOOP, The instruction will then subtract the value stored at address ONE from the accumulator OUT BRA LOOP // Jump (unconditionally) to the <b>memory</b> <b>address</b> labeled LOOP QUIT HLT // Label this <b>memory</b> <b>address</b> as QUIT ONE DAT 1 // Store the value 1 in this <b>memory</b> <b>address,</b> and label it ONE (variable declaration) ...|$|R
5000|$|Likewise, knowing D's <b>memory</b> <b>address,</b> {{it is easy}} {{to compute}} the <b>memory</b> <b>address</b> of B: ...|$|R
2500|$|... 64-bit <b>memory</b> <b>addressing</b> is also added, but is only {{permitted}} {{when there}} is no equivalent 32-bit address.|$|E
2500|$|As for Mac OS, System 7 was a 32-bit rewrite from Pascal to C++ that {{introduced}} {{virtual memory}} and improved {{the handling of}} color graphics, as well as <b>memory</b> <b>addressing,</b> networking, and co-operative multitasking. Also during this time, the Macintosh began to shed the [...] "Snow White" [...] design language, along with the expensive consulting fees they were paying to Frogdesign. Apple instead brought the design work in-house by establishing the Apple Industrial Design Group, becoming responsible for crafting a new look for all Apple products.|$|E
2500|$|The {{hardware}} severely {{restricts the}} ways in which control can be passed from one ring to another, and also enforces restrictions on the types of memory access that can be performed across rings. Using x86 as an example, there is a special gate structure which is referenced by the call instruction that transfers control in a secure way towards predefined entry points in lower-level (more trusted) rings; this functions as a supervisor call in many operating systems that use the ring architecture. The hardware restrictions are designed to limit opportunities for accidental or malicious breaches of security. [...] In addition, the most privileged ring may be given special capabilities, (such as real <b>memory</b> <b>addressing</b> that bypasses the virtual memory hardware).|$|E
5000|$|... {{knowing the}} <b>memory</b> <b>address</b> where the array starts, {{it is easy}} to compute the <b>memory</b> <b>address</b> of D: ...|$|R
50|$|The source operand can {{be either}} an XMM {{register}} (xmm) or a <b>memory</b> <b>address</b> (m64). When the source operand is an XMM register, the destination operand must be a <b>memory</b> <b>address.</b> When the source operand is a <b>memory</b> <b>address,</b> the destination operand must be an XMM register.|$|R
5000|$|... <b>memory</b> <b>address</b> executes {{the machine}} {{language}} program at <b>memory</b> <b>address.</b> If none specified, the execute {{address of the}} program loaded off tape is used ...|$|R
2500|$|One of {{the most}} {{significant}} features of System 7 is virtual memory support, which previously had only been available as a third-party add-on. Accompanying this was a move to 32-bit <b>memory</b> <b>addressing,</b> necessary for the ever-increasing amounts of RAM available to the Motorola 68030 CPU, and 68020 CPUs with a 68551 PMMU. [...] This process involves making all of the routines in OS code use the full 32-bits of a pointer as an address—prior systems used the upper 8bits as flags. This change is known as being [...] "32-bit clean". While System 7 itself is 32-bit clean, many existing machines and thousands of applications were not, so it was some time before the process was completed. To ease the transition, the [...] "Memory" [...] control panel contains a switch to disable this feature, allowing for compatibility with older applications.|$|E
2500|$|Hitachi {{produced}} its own 6809-based machines, the MB6890 {{and later}} the S1. These were primarily for the Japanese market, but some were exported to and sold in Australia. There the MB6890 was dubbed the [...] "Peach", probably in ironic reference to {{the popularity of the}} Apple II. The S1 was notable in that it contained paging hardware extending the 6809's native 64 kilobyte (64×210 byte) addressing range to a full 1 megabyte (1×220 byte) in 4 KB pages. It was similar in this to machines produced by SWTPC, Gimix, and several other suppliers. TSC produced a Unix-like operating system uniFlex which ran only on such machines. OS-9 Level II, also took advantage of such memory management facilities. Most other computers of the time with more than 64 KB of <b>memory</b> <b>addressing</b> were limited to bank switching where much if not all the 64 KB was simply swapped for another section of memory.|$|E
50|$|This {{evolutionary}} implementation (repeated in z/Architecture) had {{the characteristic}} {{of solving the}} most urgent problems first: relief for real <b>memory</b> <b>addressing</b> being needed sooner than virtual <b>memory</b> <b>addressing.</b>|$|E
50|$|The {{destination}} operand can {{be either}} an XMM register (xmm1) or a <b>memory</b> <b>address</b> (m128). Note, however, that the source and destination operands cannot both be <b>memory</b> <b>addresses.</b>|$|R
50|$|Common {{exploits}} of insecure low-level code lets an attacker perform unauthorized reads or writes to <b>memory</b> <b>addresses.</b> The <b>memory</b> <b>addresses</b> {{can be either}} random or chosen by the attacker.|$|R
5000|$|In paging the <b>memory</b> <b>address</b> {{space is}} divided into equal-sized blocks called pages. Using virtual memory hardware, each page can reside in any {{location}} of the computer's physical memory, or be flagged as being protected. Virtual memory {{makes it possible to}} have a linear virtual <b>memory</b> <b>address</b> space and to use it to access blocks fragmented over physical <b>memory</b> <b>address</b> space.|$|R
5000|$|... 24-bit <b>memory</b> <b>addressing</b> {{provides}} {{access to}} 16MB of memory space.|$|E
5000|$|... 48-bit <b>memory</b> <b>addressing</b> {{to allow}} for 256 TB memory {{subsystems}} ...|$|E
5000|$|... 64-bit <b>memory</b> <b>addressing</b> is also added, but is only {{permitted}} {{when there}} is no equivalent 32-bit address.|$|E
5000|$|The [...] {{instruction}} on line 3 has a RAW {{dependence on the}} [...] {{instruction on}} line 2, and the [...] instruction on line 5 has a RAW dependence on the [...] instruction on line 4. Both load instructions read the <b>memory</b> <b>address</b> that the preceding stores wrote. The stores were the most recent producers to that <b>memory</b> <b>address,</b> and the loads are reading that <b>memory</b> <b>address's</b> value.|$|R
5000|$|An IOMMU {{also allows}} {{operating}} systems to eliminate bounce buffers needed to {{allow themselves to}} communicate with peripheral devices whose <b>memory</b> <b>address</b> spaces are smaller than the operating system's <b>memory</b> <b>address</b> space, by using <b>memory</b> <b>address</b> translation. At the same time, an IOMMU also allows operating systems and hypervisors to prevent buggy or malicious hardware from compromising memory security. Both AMD and Intel have released their IOMMU specifications: ...|$|R
5000|$|Game {{trainers}} are programs made {{to modify}} {{memory of a}} computer game thereby modifying its behavior using addresses and values, {{in order to allow}} cheating. It can [...] "freeze" [...] a <b>memory</b> <b>address</b> disallowing the game from lowering or changing the information stored at that <b>memory</b> <b>address</b> (e.g. health meter, ammo counter, etc.) or manipulate the data at the <b>memory</b> <b>addresses</b> specified to suit the needs of the person cheating at the game.|$|R
50|$|By the 2000s it {{had become}} obvious that 32-bit x86 processors' {{limitations}} in <b>memory</b> <b>addressing</b> were an obstacle to their utilization in high-performance computing clusters and powerful desktop workstations. The aged 32-bit x86 was competing with much more advanced 64-bit RISC architectures which could address much more memory. Intel and the whole x86 ecosystem needed 64-bit <b>memory</b> <b>addressing</b> if x86 was to survive the 64-bit computing era, as workstation and desktop software applications were soon to start hitting the limitations present in 32-bit <b>memory</b> <b>addressing.</b> However, Intel {{felt that it was}} the right time to make a bold step and use the transition to 64-bit desktop computers for a transition away from the x86 architecture in general, an experiment which ultimately failed.|$|E
5000|$|... 2. Indexed: OPR @MEM(R); R {{contains}} index value, R0 is {{not used}} in indexing and allows direct <b>memory</b> <b>addressing</b> ...|$|E
50|$|Memory-mapped I/O is {{the cause}} of memory {{barriers}} in older generations of computers, which are unrelated to memory barrier instructions. The 640 KB barrier is due to the IBM PC placing the Upper Memory Area in the 640-1024 KB range within its 20-bit <b>memory</b> <b>addressing.</b> The 3 GB barrier and PCI hole are manifestations of this with 32-bit memory addressing; with 64-bit <b>memory</b> <b>addressing</b> these are usually no longer problems on newer architectures.|$|E
50|$|In a computer, the <b>Memory</b> <b>Address</b> Register (MAR) is the CPU {{register}} {{that either}} stores the <b>memory</b> <b>address</b> from which {{data will be}} fetched to the CPU or the address to which data will be sent and stored.|$|R
5000|$|During {{the course}} of a {{programs}} life, the heap, also called the data segment or [...]bss, will grow up; the heap expands towards the highest <b>memory</b> <b>address</b> available. Conversely, the stack grows down, towards the lowest <b>memory</b> <b>address,</b> 0.|$|R
50|$|This {{value is}} also the largest <b>memory</b> <b>address</b> for CPUs using a 32-bit address bus. Being an odd value, its {{appearance}} may reflect an erroneous (misaligned) <b>memory</b> <b>address.</b> Such a value may {{also be used as}} a sentinel value to initialize newly allocated memory for debugging purposes.|$|R
5000|$|PSE-36 an {{alternative}} to PAE on x86 processors to extend the physical <b>memory</b> <b>addressing</b> capabilities from 32 bits to 36 bits ...|$|E
5000|$|... 64-bit {{external}} data bus with 32-bit <b>memory</b> <b>addressing,</b> allowing {{a maximum of}} 4 GB addressable memory with a transfer rate of 800 MB/sec ...|$|E
50|$|Communications between {{processors}} and between one processor and other components are essential. Besides direct <b>memory</b> <b>addressing,</b> common protocols include I²C, SPI, serial ports, and USB.|$|E
5000|$|Protected task {{environment}} (independent <b>memory</b> <b>address</b> per process).|$|R
2500|$|... 32- or 64-bit <b>memory</b> <b>address</b> space (4gigabytes or 16exabytes) ...|$|R
50|$|For {{implementations}} {{of programming}} languages that {{are using a}} compiler, identifiers are often only compile time entities. That is, at runtime the compiled program contains references to <b>memory</b> <b>addresses</b> and offsets rather than the textual identifier tokens (these <b>memory</b> <b>addresses,</b> or offsets, having been assigned by the compiler to each identifier).|$|R
