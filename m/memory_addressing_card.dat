0|2209|Public
50|$|In {{the context}} of these definitions, a byte is the {{smallest}} primitive; each <b>memory</b> <b>address</b> specifies a different byte. The <b>memory</b> <b>address</b> of the initial byte of a datum is considered the <b>memory</b> <b>address</b> (or base <b>memory</b> <b>address)</b> of the entire datum.|$|R
5000|$|INP OUT // Initialize output [...] LOOP BRZ QUIT // If the {{accumulator}} {{value is}} 0, {{jump to the}} <b>memory</b> <b>address</b> labeled QUIT SUB ONE // Label this <b>memory</b> <b>address</b> as LOOP, The instruction will then subtract the value stored at address ONE from the accumulator OUT BRA LOOP // Jump (unconditionally) to the <b>memory</b> <b>address</b> labeled LOOP QUIT HLT // Label this <b>memory</b> <b>address</b> as QUIT ONE DAT 1 // Store the value 1 in this <b>memory</b> <b>address,</b> and label it ONE (variable declaration) ...|$|R
5000|$|Likewise, knowing D's <b>memory</b> <b>address,</b> {{it is easy}} {{to compute}} the <b>memory</b> <b>address</b> of B: ...|$|R
5000|$|... {{knowing the}} <b>memory</b> <b>address</b> where the array starts, {{it is easy}} to compute the <b>memory</b> <b>address</b> of D: ...|$|R
50|$|The source operand can {{be either}} an XMM {{register}} (xmm) or a <b>memory</b> <b>address</b> (m64). When the source operand is an XMM register, the destination operand must be a <b>memory</b> <b>address.</b> When the source operand is a <b>memory</b> <b>address,</b> the destination operand must be an XMM register.|$|R
5000|$|... <b>memory</b> <b>address</b> executes {{the machine}} {{language}} program at <b>memory</b> <b>address.</b> If none specified, the execute {{address of the}} program loaded off tape is used ...|$|R
50|$|The {{destination}} operand can {{be either}} an XMM register (xmm1) or a <b>memory</b> <b>address</b> (m128). Note, however, that the source and destination operands cannot both be <b>memory</b> <b>addresses.</b>|$|R
50|$|This {{evolutionary}} implementation (repeated in z/Architecture) had {{the characteristic}} {{of solving the}} most urgent problems first: relief for real <b>memory</b> <b>addressing</b> being needed sooner than virtual <b>memory</b> <b>addressing.</b>|$|R
50|$|Common {{exploits}} of insecure low-level code lets an attacker perform unauthorized reads or writes to <b>memory</b> <b>addresses.</b> The <b>memory</b> <b>addresses</b> {{can be either}} random or chosen by the attacker.|$|R
5000|$|In paging the <b>memory</b> <b>address</b> {{space is}} divided into equal-sized blocks called pages. Using virtual memory hardware, each page can reside in any {{location}} of the computer's physical memory, or be flagged as being protected. Virtual memory {{makes it possible to}} have a linear virtual <b>memory</b> <b>address</b> space and to use it to access blocks fragmented over physical <b>memory</b> <b>address</b> space.|$|R
5000|$|The [...] {{instruction}} on line 3 has a RAW {{dependence on the}} [...] {{instruction on}} line 2, and the [...] instruction on line 5 has a RAW dependence on the [...] instruction on line 4. Both load instructions read the <b>memory</b> <b>address</b> that the preceding stores wrote. The stores were the most recent producers to that <b>memory</b> <b>address,</b> and the loads are reading that <b>memory</b> <b>address's</b> value.|$|R
5000|$|An IOMMU {{also allows}} {{operating}} systems to eliminate bounce buffers needed to {{allow themselves to}} communicate with peripheral devices whose <b>memory</b> <b>address</b> spaces are smaller than the operating system's <b>memory</b> <b>address</b> space, by using <b>memory</b> <b>address</b> translation. At the same time, an IOMMU also allows operating systems and hypervisors to prevent buggy or malicious hardware from compromising memory security. Both AMD and Intel have released their IOMMU specifications: ...|$|R
5000|$|Game {{trainers}} are programs made {{to modify}} {{memory of a}} computer game thereby modifying its behavior using addresses and values, {{in order to allow}} cheating. It can [...] "freeze" [...] a <b>memory</b> <b>address</b> disallowing the game from lowering or changing the information stored at that <b>memory</b> <b>address</b> (e.g. health meter, ammo counter, etc.) or manipulate the data at the <b>memory</b> <b>addresses</b> specified to suit the needs of the person cheating at the game.|$|R
50|$|In a computer, the <b>Memory</b> <b>Address</b> Register (MAR) is the CPU {{register}} {{that either}} stores the <b>memory</b> <b>address</b> from which {{data will be}} fetched to the CPU or the address to which data will be sent and stored.|$|R
5000|$|During {{the course}} of a {{programs}} life, the heap, also called the data segment or [...]bss, will grow up; the heap expands towards the highest <b>memory</b> <b>address</b> available. Conversely, the stack grows down, towards the lowest <b>memory</b> <b>address,</b> 0.|$|R
50|$|This {{value is}} also the largest <b>memory</b> <b>address</b> for CPUs using a 32-bit address bus. Being an odd value, its {{appearance}} may reflect an erroneous (misaligned) <b>memory</b> <b>address.</b> Such a value may {{also be used as}} a sentinel value to initialize newly allocated memory for debugging purposes.|$|R
5000|$|Protected task {{environment}} (independent <b>memory</b> <b>address</b> per process).|$|R
2500|$|... 32- or 64-bit <b>memory</b> <b>address</b> space (4gigabytes or 16exabytes) ...|$|R
50|$|For {{implementations}} {{of programming}} languages that {{are using a}} compiler, identifiers are often only compile time entities. That is, at runtime the compiled program contains references to <b>memory</b> <b>addresses</b> and offsets rather than the textual identifier tokens (these <b>memory</b> <b>addresses,</b> or offsets, having been assigned by the compiler to each identifier).|$|R
5000|$|<b>Memory</b> <b>Address</b> Register Display Selector - Rotary switch, 12 {{positions}} ...|$|R
5000|$|... q = Extend program <b>memory</b> <b>address</b> with RAMPZ (0=0:Z, 1=RAMPZ:Z) ...|$|R
5000|$|... 24-bit <b>memory</b> <b>addressing</b> {{provides}} {{access to}} 16MB of memory space.|$|R
5000|$|... 24-bit {{physical}} address space, 16 Mbyte physical <b>memory</b> <b>address</b> space ...|$|R
5000|$|... 32-bit {{physical}} address space, 4 Gbyte physical <b>memory</b> <b>address</b> space ...|$|R
5000|$|... 48-bit <b>memory</b> <b>addressing</b> {{to allow}} for 256 TB memory {{subsystems}} ...|$|R
5000|$|The {{most basic}} way of {{achieving}} {{this is by}} means of memory editor software, which allows the player to directly edit the numeric values in a certain <b>memory</b> <b>address.</b> This kind of software usually includes a feature that allows the player to perform memory searches to aid the user to locate the memory areas where known values (such {{as the amount of}} lives, score or health level) are located. Provided a <b>memory</b> <b>address,</b> a <b>memory</b> editor may also be able to [...] "freeze" [...] it, preventing the game from altering the information stored at that <b>memory</b> <b>address.</b>|$|R
5000|$|Attempting {{to access}} a nonexistent <b>memory</b> <b>address</b> (outside process's address space) ...|$|R
5000|$|I : 16bit {{register}} (For <b>memory</b> <b>address)</b> (Similar to void pointer) ...|$|R
5000|$|... {{takes that}} <b>memory</b> <b>address</b> and dereferences it {{to access the}} value.|$|R
5000|$|... 32- or 64-bit <b>memory</b> <b>address</b> space (4 {{gigabytes}} or 16 exabytes) ...|$|R
50|$|A memory pointer (or just pointer) is a primitive, {{the value}} of which is {{intended}} {{to be used as a}} memory address; it is said that a pointer points to a <b>memory</b> <b>address.</b> It is also said that a pointer points to a datum memory when the pointer's value is the datum's <b>memory</b> <b>address.</b>|$|R
50|$|An error occurs if {{reference}} to a non-existent <b>memory</b> <b>address</b> is attempted.|$|R
5000|$|Address Register (12 bit): {{holds the}} <b>memory</b> <b>address</b> {{requested}} by central computer ...|$|R
5000|$|Most CPUs are byte-addressable, {{where each}} unique <b>memory</b> <b>address</b> {{refers to an}} 8-bit byte. Most CPUs can access {{individual}} bytes from each <b>memory</b> <b>address,</b> but they generally cannot access larger units (16 bits, 32 bits, 64 bits and so on) without these units being [...] "aligned" [...] to a specific boundary (the x86 platform being a notable exception).|$|R
2500|$|... {{decreasing}} numeric significance {{with increasing}} <b>memory</b> <b>addresses</b> (or increasing time), known as big-endian ...|$|R
5000|$|<b>Memory</b> <b>addresses</b> for main <b>memory,</b> memory-mapped I/O, {{as well as}} for virtual memory; ...|$|R
