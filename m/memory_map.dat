169|797|Public
5|$|Planning for Dragon Quest II {{began in}} April 1986, {{a month before}} the release of the {{original}} Dragon Quest. With the system and <b>memory</b> <b>map</b> decided, they started development in early July. At the beginning of development, producer Yukinobu Chida asked director and programmer Koichi Nakamura for a definite release date, and he offhandedly set one. Then the development team was divided into two groups, with one designing the story, as well as the monsters, and one doing the programming. The initial deadline was set for early November, but the game ultimately suffered a small delay. The development team had finished programming almost everything {{by the time of the}} initial release and believed the game could be released by the end of that year. In the Japanese magazine Weekly Shōnen Jump, published on November 11, 1986, it was announced that the game would be released in late December. However, the developers found that the game was too difficult, so it was delayed for month to adjust the balance. They had to finish the final version in mid-December, which they did, and then rushed to deliver to Nintendo to make the physical game cartridges. The game was released on January 26, 1987.|$|E
25|$|In Linux, kernel may destroy <b>memory</b> <b>map</b> {{of the old}} {{process and}} start {{constructing}} (loading) new executable, and only then discover that the new executable can't be loaded (for example, some fields in executable's internal tables contain invalid values). In this case, process gets killed by a fatal signal (such as SIGSEGV). Ideally, kernel should fail evecve and return error indication in old executable, but this would require significantly more complex (and slower) code in the kernel.|$|E
25|$|The 6809 {{design team}} {{believed}} that future system integrators would look to off-the-shelf code in ROMs to handle common tasks. Motorola's official programming manual contains the full listing of assist09, a so-called monitor, a miniature operating system {{intended to be}} burned in ROM. Another example of ROM code might be binary floating point arithmetic, which is a common requirement in many systems. In order to speed time to market, common code modules would be purchased, rather than developed in-house, and integrated into systems with code from other manufacturers. Since a CPU designer could hardly guarantee where this code would be located in a future system, the 6809 design focused heavily on support of position-independent, reentrant code that could be freely located anywhere in the <b>memory</b> <b>map.</b> This expectation was, in reality, never quite met: Motorola's only released example of a ROM'd software module was the MC6839 floating-point ROM. However, the decisions made by the design team made for a very powerful processor and made possible advanced operating systems like OS-9 and UniFlex, which {{took advantage of the}} position-independent, re-entrant nature of the 6809 to create multi-user multitasking operating systems.|$|E
50|$|The J {{programming}} language has supported <b>memory</b> <b>mapped</b> files {{since at least}} 2005. It includes support for boxed array data, and single datatype files. Support can be loaded from 'data/jmf' J's Jdb and JD database engines use <b>memory</b> <b>mapped</b> files for column stores.|$|R
5000|$|Buffered, synchronous, asynchronous, direct, and <b>memory</b> <b>mapped</b> I/O ...|$|R
5000|$|XMLMemMappedBuffer {{performs}} <b>memory</b> <b>mapped</b> {{loading of}} XML documents.|$|R
25|$|The {{protected}} mode of the 80286 was not utilized until {{many years after}} its release, {{in part because of}} the high cost of adding extended memory to a PC, but also because of the need for software to support the large user base of 8086 PCs. For example, in 1986 the only program that made use of it was VDISK, a RAM disk driver included with PC DOS 3.0 and 3.1. A DOS could utilize the additional RAM available in {{protected mode}} (extended memory) either via a BIOS call (INT 15h, AH=87h), as a RAM disk, or as emulation of expanded memory. The difficulty lay in the incompatibility of older real-mode DOS programs with protected mode. They simply could not natively run in this new mode without significant modification. In protected mode, memory management and interrupt handling were done differently than in real mode. In addition, DOS programs typically would directly access data and code segments that did not belong to them, as real mode allowed them to do without restriction; in contrast, the design intent of protected mode was to prevent programs from accessing any segments other than their own unless special access was explicitly allowed. While it was possible to set up a protected-mode environment that allowed all programs access to all segments (by putting all segment descriptors into the GDT and assigning them all the same privilege level), this undermined nearly all of the advantages of protected mode except the extended (24-bit) address space. The choice that OS developers faced was either to start from scratch and create an OS that would not run the vast majority of the old programs, or to come up with a version of DOS that was slow and ugly (i.e., ugly from an internal technical viewpoint) but would still run a majority of the old programs. Protected mode also did not provide a significant enough performance advantage over the 8086-compatible real mode to justify supporting its capabilities; actually, except for task switches when multitasking, it actually yielded only a performance disadvantage, by slowing down many instructions through a litany of added privilege checks. In protected mode, registers were still 16-bit, and the programmer was still forced to use a <b>memory</b> <b>map</b> composed of 64kB segments, just like in real mode.|$|E
500|$|The {{original}} , a {{video game}} based on a trilogy of novels by writer Aya Nishitani, was developed by Atlus and published by Namco in 1987. The game met with critical and commercial success, and according to director Kouji Okada gave the Atlus team [...] "breathing room" [...] for developing a second game. While the original game used a first-person viewpoint for the entire game outside some cutscenes, Megami Tensei II used an overhead view for navigation and first-person for combat. This was done {{at the suggestion of}} staff due to issues of getting lost that plagued the original. As with the first game, priority was given to programming and game design over other aspects such as narrative. The music was composed by Tsukasa Masuko, who had worked on the previous game and incorporated his earlier work. The music quality could be greatly increased due to the incorporation of a dedicated <b>memory</b> <b>map.</b>|$|E
2500|$|The {{design of}} the {{original}} IBM PC placed the Color Graphics Adapter (CGA) <b>memory</b> <b>map</b> and other hardware in the 384 KB upper memory area (UMA). The need for more RAM grew faster than the needs of hardware to utilize the reserved addresses, which resulted in RAM eventually being mapped into these unused upper areas to utilize all available addressable space. This introduced a reserved [...] "hole" [...] (or several holes) into the set of addresses occupied by hardware {{that could be used}} for arbitrary data. Avoiding such a hole was difficult and ugly and not supported by DOS or most programs that could run on it. Later, space between the holes would be used as upper memory blocks (UMBs).|$|E
5000|$|In the Microsoft [...]NET runtime, P/Invoke {{can be used}} to use <b>memory</b> <b>mapped</b> files {{directly}} through the Windows API. Managed access (P/Invoke not necessary) to <b>memory</b> <b>mapped</b> files was introduced in version 4 of the runtime (see Memory-Mapped Files). For previous versions, there are third-party libraries which provide managed API's.|$|R
40|$|The {{design and}} {{implementation}} of some persistent object stores rely {{on the availability of}} <b>memory</b> <b>mapped</b> files. A significant difficulty faced by this approach is that the programmer has very little control over when I/O occurs. In this paper, a mechanism for exposing the I/O activity of a <b>memory</b> <b>mapped</b> file is presented. This involves implementing a special purpose NFS server that provides a shadow paged file which can be <b>memory</b> <b>mapped</b> by a persistent object store. Some initial performance figures are presented to indicate the relative performance of this approach compared to more traditional approaches. Fred Brow...|$|R
50|$|Another pseudo-type—associated with name, {{rather than}} value—is the <b>memory</b> <b>mapped</b> file.|$|R
50|$|The 940 accesses memory {{through a}} <b>memory</b> <b>map</b> to provide virtual memory. The map formats differ {{slightly}} between a user <b>memory</b> <b>map</b> and a monitor <b>memory</b> <b>map.</b>|$|E
50|$|A set of <b>memory</b> <b>map</b> {{registers}} {{is used to}} map virtual addresses to physical. There {{are eight}} <b>memory</b> <b>map</b> registers, each mapping 2K words, to provide an address space of 16K.|$|E
50|$|The monitor can {{use either}} the monitor <b>memory</b> <b>map</b> or the user <b>memory</b> <b>map,</b> {{determined}} by the value of bit 0 of the instruction. This allows the monitor access to the user's address space.|$|E
5000|$|... 4 fast {{switchable}} register {{banks with}} 8 registers each (<b>memory</b> <b>mapped)</b> ...|$|R
50|$|The primary {{benefit of}} <b>memory</b> <b>mapping</b> a file is {{increasing}} I/O performance, especially when used on large files. For small files, memory-mapped files {{can result in}} a waste of slack space as <b>memory</b> <b>maps</b> are always aligned to the page size, which is mostly 4 KiB. Therefore, a 5 KiB file will allocate 8 KiB and thus 3 KiB are wasted. Accessing <b>memory</b> <b>mapped</b> files is faster than using direct read and write operations for two reasons. Firstly, a system call is orders of magnitude slower than a simple change to a program's local memory. Secondly, in most operating systems the <b>memory</b> region <b>mapped</b> actually is the kernel's page cache (file cache), meaning that no copies need to be created in user space.|$|R
40|$|Increased {{availability}} of Multi-Core processors is forcing us to redesign algorithms and applications {{so as to}} exploit the available computational power from multiple cores. It is not un-common to employ <b>memory</b> <b>mapping</b> of files in applications involving huge I/O bandwidth to improve the response/service times. This paper mainly focuses on performance of <b>memory</b> <b>mapped</b> files on Multi-Core processors. Experiments are carried out with k-means algorithm, a popular Data mining (DM) clustering algorithm, to explore the potential of Multi-Core hardware under OpenMP API and POSIX threads. Observations are made both with static and dynamic threads of OpenMP. Experiments are also conducted with both simulated and real data sets. Experiments indicate that <b>memory</b> <b>mapping</b> of files gives considerable benefit on Multi-Core processors also. In addition, the benefit increased with increased physical memory size. Also, the benefit of <b>memory</b> <b>mapping</b> with the selected algorithm is increasing with number of cores...|$|R
5000|$|... jmap Oracle jmap - <b>Memory</b> <b>Map</b> - [...] This utility outputs the <b>memory</b> <b>map</b> for Java and {{can print}} shared object memory maps or heap memory {{details of a}} given process or core dump. (experimental) ...|$|E
50|$|The {{hardware}} of {{the system}} is arranged so that devices on the address bus will only respond to particular addresses which are intended for them, while all other addresses are ignored. This is the job of the address decoding circuitry, and that establishes the <b>memory</b> <b>map</b> {{of the system}}. As a result, system's <b>memory</b> <b>map</b> may look like in the table on the right. This <b>memory</b> <b>map</b> contains gaps, which is also quite common in actual system architectures.|$|E
5000|$|BIOS Function: INT 0x15, AX=0xE820 - GET SYSTEM <b>MEMORY</b> <b>MAP</b> '''''': ...|$|E
2500|$|RAM: {{commonly}} 64kB (on Japanese computers), normally <b>memory</b> <b>mapped</b> (4MB per slot maximum) ...|$|R
40|$|We {{introduce}} {{a new approach to}} take into account the memory architecture and the <b>memory</b> <b>mapping</b> in High- Level Synthesis for data intensive applications. We formalize the <b>memory</b> <b>mapping</b> as a set of constraints for the synthesis, and defined a Memory Constraint Graph and an accessibility criterion to be used in the scheduling step. We use a <b>memory</b> <b>mapping</b> file to include those memory constraints in our HLS tool GAUT. It is possible, with the help of GAUT, to explore a wide range of solutions, and to reach a good tradeoff between time, power-consumption, and area. Comment: ISBN 0 - 7695 - 2097 -...|$|R
5000|$|Missiles {{share the}} same bytes of the <b>memory</b> <b>maps</b> above, two bits per Missile: ...|$|R
5000|$|The Microtan 65 <b>memory</b> <b>map</b> {{is shown}} below ($ {{representing}} a hexadecimal memory address): ...|$|E
50|$|The {{following}} is the <b>memory</b> <b>map</b> for the Atom. Shaded areas indicate those {{present on the}} minimal system.|$|E
5000|$|Provide {{useful and}} {{detailed}} debug information {{in case of}} a crash: Process details, registers dump and <b>memory</b> <b>map.</b>|$|E
50|$|The D {{programming}} language supports <b>memory</b> <b>mapped</b> files in its standard library (std.mmfile module).|$|R
40|$|Abstract: In this paper, a data {{acquisition}} subsystem for aluminum reduction cells under reconstruction is designed on <b>memory</b> <b>mapped</b> file and MODBUS, has realized the sampling procedure {{and the main}} control program of real-time data transmission through the <b>memory</b> <b>mapped</b> file, has realized the MODBUS communication between the sampling procedure and the prestage using MSComm control, the system can work stably at present...|$|R
5000|$|RAM: {{commonly}} 64 kB (on Japanese computers), normally <b>memory</b> <b>mapped</b> (4 MB per slot maximum) ...|$|R
50|$|The <b>memory</b> <b>map</b> for {{monitor mode}} is similar. There are no P bits; the R0-R5 equivalents, called M0-M5, contain the {{read-only}} values 0-5, providing {{direct access to}} physical addresses 0-8K-1 (00000-177778). For addresses in the range 8K-12K-1 (20000-277778) memory extension register EM2 is used to form the physical address {{as it is in}} normal mode. For addresses 12K-16K-1 (30000-377778) the contents of <b>memory</b> <b>map</b> registers M6 and M7 are used to form the address.|$|E
5000|$|Can manage {{more than}} 32 GB RAM, as the <b>memory</b> <b>map</b> would consume a disproportionately large {{area of the}} 32-bit kernel space.|$|E
50|$|Late in the system's lifetime, {{hardware}} modifications {{were introduced}} to solve the <b>memory</b> <b>map</b> issues, and a version of CP/M was released for the 8813.|$|E
5000|$|TI-990/10 [...] - [...] TTL {{processor}} with <b>memory</b> <b>mapping</b> support to 2M {{bytes of memory}} ...|$|R
5000|$|TI-990/10A [...] - [...] TMS-99000 {{microprocessor}} with <b>memory</b> <b>mapping</b> {{support to}} 1M {{bytes of memory}} ...|$|R
5000|$|The Java {{programming}} language provides classes and methods to access <b>memory</b> <b>mapped</b> files, such as [...]|$|R
