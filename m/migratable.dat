80|0|Public
5000|$|<b>Migratable</b> sockets {{for direct}} {{communication}} between migrated processes.|$|E
50|$|Adaptive MPI (AMPI) is an {{implementation}} of the Message Passing Interface standard {{on top of the}} Charm++ runtime system and provides the capabilities of Charm++ in a more traditional MPI programming model. AMPI encapsulates each MPI process within a user-level <b>migratable</b> thread that is bound within a Charm++ object. By embedding each thread with a chare, AMPI programs can automatically take advantage of the features of the Charm++ runtime system with little or no changes to the underlying MPI program.|$|E
40|$|The {{migration}} of a user interface (UI) is {{the action of}} transferring a UI from a device to another one, for example from a desktop computer to a handheld device. A UI is said <b>migratable</b> if it has the migration ability. This paper describes how the QTk toolkit was extended to provide <b>migratable</b> UI and what API is provided to the developers. Basically an indirection layer has been introduced between the application and the actual representation of the UI. The {{migration of}} a UI is achieved by firstly creating a clone {{of the state of}} the site displaying the UI, secondly by changing the indirection to point to this clone. The API provides a way to specify if (the entirety of) a window can be migrated or not at construction time. A <b>migratable</b> window returns a universal reference that can be given to any site with whom a network connection is possible. This reference can be used by a receiver widget to migrate the window there. Interestingly, a <b>migratable</b> window can itself contain a receiver widget configured to display the content of another <b>migratable</b> window: all windows are transparently migrated along. Also a window (stationary or <b>migratable)</b> may contain one or more receiver widgets: it is possible to dynamically compose a UI from several different UIs...|$|E
40|$|TPM密钥迁移机制使密钥按照迁移特性分为了可迁移密钥和不可迁移密钥两类,本文深入分析可迁移密钥的安全性,指出可迁移密钥存在的安全问题. 首先,利用密钥迁移机制,TPM所有者能将TPM内部可迁移密钥以迁移块的形式导出,解密迁移块能获得可迁移密钥私钥. 其次,TPM用户能通过密钥迁移机制将非TPM产生的用户可控密钥构造成迁移块,作为迁移密钥导入到TPM内部. 此外,用户使用TPM密钥加载命令能将非TPM产生的用户可控密钥作为TPM产生的可迁移密钥加载到TPM中. 在对TPM规范理论分析的基础上,本文从技术角度给出了攻击可迁移密钥安全性的实现方法,并对部分安全问题提出了解决方案. 通过分析,本文指出TPM提供密钥迁移机制的同时,也降低了可迁移密钥的安全保护强度. 因此,用户在使用可迁移密钥时,应增强安全意识,在安全要求高的操作中尽量不要使用TPM可迁移密钥. 国家自然科学基金项目(91118006) 资助TPM key {{migration}} mechanism put keys {{into two}} categories {{in accordance with the}} migration characteristics. This paper gives a deep security analysis of TPM <b>migratable</b> keys,and points out some security flaws about TPM key migration. First,by key migration mechanism,the TPM owner can export a <b>migratable</b> key in the form of migration blob,decrypt the blob,and get the plaintext of the TPM private key. Second,a TPM user can use TPM key migration mechanism to import a non-TPM generated key blob into TPM. Third,a TPM user can construct a loadable blob of a non-TPM generated key,and then load it into TPM by the TPM key loading command. On the basis of analyzing the TPM specification theoretically,we give an attack in technical view,and propose a solution to one of the security problems. The analysis indicates that the TPM key migration mechanism,in spite of improving key interoperability between TPMs,reduces the security strength of the <b>migratable</b> key. Therefore,TPM users must think over the security weaknesses when using <b>migratable</b> keys,and do not use <b>migratable</b> keys in security critical operation as far as possible...|$|E
40|$|This paper {{concerns}} {{the problem of}} scheduling sets of preemptable, periodic tasks on multiple resources. We consider a task model that allows arbitrary mixes of fixed and <b>migratable</b> tasks, and prove {{the existence of an}} optimal pfair scheduler in this model. Fixed tasks must always be scheduled on a given resource, while <b>migratable</b> tasks can be scheduled on different resources at different times. A pfair scheduler produces a periodic schedule in which the times each task is allocated a processor are approximately evenly spread throughout its period. This work extends work of Baruah et al, who proved a similar result for systems in which all tasks are <b>migratable...</b>|$|E
40|$|Desktop {{workstations}} {{represent a}} largely untapped source of computational power for parallel computing. Two {{of the main}} problems in utilizing these workstations are developing strategies for migrating load so that partially loaded workstations can contribute CPU cycles to the computation, and making dynamically <b>migratable</b> application programs easy to write. This paper describes object arrays, a construct which makes dynamically <b>migratable</b> applications easier to write, and a simple strategy for migrating load on a workstation cluster...|$|E
40|$|Abstract. This paper {{defines the}} problem space of distributed, <b>migratable</b> and plastic user interfaces, and {{presents}} CAMELEON-RT 1, a technical {{answer to the}} problem. CAMELEON-RT 1 is an architecture reference model {{that can be used}} for comparing and reasoning about existing tools as well as for developing future run time infrastructures for distributed, <b>migratable,</b> and plastic user interfaces. We have developed an early implementation of a run time infrastructure based on the precepts of CAMELEON-RT 1. ...|$|E
40|$|This paper {{presents}} an EDF-based algorithm, called Earliest Deadline Deferrable Portion (EDDP), for efficient schedul-ing of recurrent real-time tasks on multiprocessor systems. The design of EDDP {{is based on}} the portioned scheduling technique which classifies each task into a fixed task or a <b>migratable</b> task. A fixed task is scheduled on the dedi-cated processor without migrations. A <b>migratable</b> task is meanwhile permitted to migrate between the particular two processors. In order to curb the cost of task migrations, EDDP makes at most M − 1 <b>migratable</b> tasks on M pro-cessors. The scheduling analysis derives the condition for a given task set to be schedulable. It is also proven that no tasks ever miss deadlines, if the system utilization does not exceed 65 %. Beyond the theoretical analysis, the effec-tiveness of EDDP is evaluated through simulation studies. Simulation results show that EDDP achieves high system utilization with a small number of preemptions, compared with the traditional EDF-based algorithms...|$|E
40|$|Supercomputers {{have seen}} an {{exponential}} increase in their size {{in the last two}} decades. Such a high growth rate is expected to take us to exascale in the timeframe 2018 - 2022. But, to bring a productive exascale environment about, it is necessary to focus on several key challenges. One of those challenges is fault tolerance. Machines at extreme scale will experience frequent failures and will require the system to avoid or overcome those failures. Various techniques have recently been developed to tolerate failures. The impact of these techniques and their scalability can be substantially enhanced by a parallel programming model called <b>migratable</b> objects. In this paper, we demonstrate how the migratable-objects model facilitates and improves several fault tolerance approaches. Our experimental results on thousands of cores suggest fault tolerance schemes based on <b>migratable</b> objects have low performance overhead and high scalability. Additionally, we present a performance model that predicts a significant benefit of using <b>migratable</b> objects to provide fault tolerance at extreme scale...|$|E
40|$|Abstract—Supercomputers {{have seen}} an {{exponential}} increase in their size {{in the last two}} decades. Such a high growth rate is expected to take us to exascale in the timeframe 2018 - 2022. But, to bring a productive exascale environment about, it is necessary to focus on several key challenges. One of those challenges is fault tolerance. Machines at extreme scale will experience frequent failures and will require the system to avoid or overcome those failures. Various techniques have recently been developed to tolerate failures. The impact of these techniques and their scalability can be substantially enhanced by a parallel programming model called <b>migratable</b> objects. In this paper, we demonstrate how the migratable-objects model facilitates and improves several fault tolerance approaches. Our experimental results on thousands of cores suggest fault tolerance schemes based on <b>migratable</b> objects have low performance overhead and high scalability. Additionally, we present a performance model that predicts a significant benefit of using <b>migratable</b> objects to provide fault tolerance at extreme scale. Index Terms—migratable objects, fault tolerance, resilience, checkpoint/restart, message logging. ...|$|E
40|$|Abstract—This paper {{proposes a}} {{technique}} for letting end users build pervasive applications by combining services on networked devices. The approach avoids relying on standardized service interfaces which are deemed too limiting, and instead {{makes use of}} <b>migratable</b> user interfaces and scripted combina-tions of services. I...|$|E
40|$|Based {{on our own}} {{experience}} in developing software environments for plastic UIs, we argue for a new middleware software infrastructure that extends the functional capabilities of our current windowing systems and toolkits. Keywords Distributed user interface, <b>migratable</b> user interface, plastic user interface, software infrastructure, ubiquitous computing...|$|E
3000|$|... {{could be}} made <b>migratable.</b> This would allow to {{transfer}} the binding keys to the updated control station hardware. Key migration can only be performed if the migration password specified upon key creation is supplied. Clearly, {{it is critical that}} appropriate policies for management of these migration secrets are applied. These policies must also ensure that the old [...]...|$|E
40|$|We {{present a}} container-based {{architecture}} for supporting autonomic data stream processing application on Fog computing infrastructures. Our architecture runs applications as Docker containers, and it exploits Docker’s native features to dynamically scale up/down {{the resources of}} a Fog node assigned to the applications running on it. Preliminary results demonstrate that Docker containers are appropriate for building <b>migratable</b> autonomic solutions in the Fog...|$|E
3000|$|RSA keys can be {{generated}} for different purposes such as data encryption or signing. Upon creation, keys can be declared <b>migratable</b> or not. While <b>migratable</b> keys can be transferred to a different TPM, non-migratable keys cannot. A password called usage secret can be specified upon key creation. If specified, this password has to be provided every time the key is used. Likewise, a migration secret can be specified that must be supplied if {{the key is to}} be migrated to another TPM. Regardless of key type and migratability, a private TPM key can never be extracted from the chip as plain text but only in encrypted form. By definition, every key is required to have a parent key that is used to encrypt the private key when it has to be swapped out of the TPM due to limited internal memory. At the root of this key hierarchy is the Storage Root Key ([...] [...]...|$|E
40|$|Processor {{virtualization}} via <b>migratable</b> objects is {{a powerful}} technique that enables the runtime system to carry out intelligent adaptive optimizations like dynamic resource management. CHARM++ is an early language/system that supports <b>migratable</b> objects. This paper describes Adaptive MPI (or AMPI), an MPI implementation and extension, that supports processor virtualization. AMPI implements virtual MPI processes (VPs), several {{of which may be}} mapped to a single physical processor. AMPI includes a powerful runtime support system that takes advantage of the degree of freedom afforded by allowing it to assign VPs onto processors. With this runtime system, AMPI supports such features as automatic adaptive overlapping of communication and computation, automatic load balancing, flexibility of running on arbitrary number of processors, and checkpoint/restart support. It also inherits communication optimization from CHARM++ framework. This paper describes AMPI, illustrates its performance benefits through a series of benchmarks, and shows that AMPI is a portable and mature MPI implementation that offers various performance benefits to dynamic applications...|$|E
40|$|Abstract. The {{capability}} to dynamically evolve process models {{over time and}} to migrate process instances to a modified model version are fundamental requirements for any process-aware information system. This has been recognized {{for a long time}} and different approaches for process schema evolution have emerged. Basically, the challenge is to correctly and efficiently migrate running instances to a modified process model. In addition, no process instance should be needlessly excluded from being migrated. While there has been significant research on cor-rectness notions, existing approaches are still too restrictive regarding the set of <b>migratable</b> instances. This paper discusses fundamental re-quirements emerging in this context. We revisit the well-established com-pliance criterion for reasoning about the correct applicability of dynamic process changes, relax this criterion in different respects, and discuss the impact these relaxations have in practice. Furthermore, we investigate how to cope with non-compliant process instances to further increase the number of <b>migratable</b> ones. Respective considerations are fundamental for further maturation of adaptive process management technology. ...|$|E
40|$|This paper {{proposes a}} {{reference}} model for reasoning about {{different types of}} distributed User Interfaces (UI) : mouldable, distributable, and <b>migratable</b> UIs. The reference model explicitly captures concepts subject to distribution {{at different levels of}} abstraction (tasks, concepts, abstract UI, concrete UI, and deployed UI) so as to provide designers with some guidance on deciding how to distribute the UI. Some significant types of distributed UI are uniformly expressed according to the reference model...|$|E
40|$|Parallel {{machines}} with an extremely {{large number of}} processors (at least tens of thousands processors) are now in operation. For example, the IBM BlueGene/L machine with 128 K processors is currently being deployed. It {{is going to be}} a significant challenge for application developers to write parallel programs in order to exploit the enormous compute power available and manually scale their applications on such machines. Solving these problems involves finding suitable parallel programming models for such machines and addressing issues like load imbalance. In this thesis, we explore Charm++ programming model and its <b>migratable</b> objects for programming such machines and dynamic load balancing techniques to help parallel applications to easily scale on a large number of processors. We also present a parallel simulator that is capable of predicting parallel performance to help analysis and tuning of the parallel performance and facilitate the development of new load balancing techniques, even before such machines are built. We evaluate the idea of virtualization and its usefulness in helping a programmer to write applications with high degree of parallelism. We demonstrate it by developing several mini-applications with millionway parallelism. We show that Charm++ and AMPI (an extension to MPI) with <b>migratable</b> objects an...|$|E
40|$|This paper {{proposes a}} {{reference}} model for classifying about {{different types of}} Distributed User Interfaces (DUIs) so that one could reason about their types: mouldable, distributable, and <b>migratable</b> UIs. The reference model explicitly captures concepts subject to distribution {{at different levels of}} abstraction (tasks, concepts, abstract UI, concrete UI, and deployed UI) so as to provide designers with a specification mechanism that enables them to express distribution. Some representative types of distributed UI are expressed according to the reference model to exemplify its usage...|$|E
30|$|To {{process the}} TPM {{commands}} efficiently, {{we made the}} following two-design decisions. First, we adopted a template-based TPM command construction. The TPM library prepares a command template for each TPM command in the runtime stack. When issuing a TPM command, it replaces the template with the corresponding parameters without allocating new memory in the heap. Second, we only implemented a subset of TPM commands that are suitable for a portable trusted platform. For example, our TPM library does not create <b>migratable</b> keys when using the command TPM.CreateWrapKey since the device is already a portable device.|$|E
40|$|ABSTRACT: Parallel Virtual Machine (PVM) is a widely-used {{software}} {{system that allows}} a heterogeneous set of parallel and serial UNIX-based computers to be programmed as a single message-passing parallel machine. In this paper, an extension to PVM to support dynamic process migration is presented. Support for migration is important in general-purpose workstation environments since it allows parallel computations to co-exist with other applications, using idle-cycles as they become available and off-loading from workstations when {{they are no longer}} free. A description and evaluation of the design and implementation of the prototype <b>Migratable</b> PVM system is presented together with some performance results...|$|E
40|$|Many {{important}} parallel applications require multiple {{flows of}} control {{to run on}} a single processor. In this paper, we present a study of four flow-of-control mechanisms: processes, kernel threads, user-level threads and event-driven objects. Through experiments, we demonstrate the practical performance and limitations of these techniques {{on a variety of}} platforms. We also examine migration of these flows-of-control with focus on thread migration, which is critical for application-independent dynamic load balancing in parallel computing applications. Thread migration, however, is challenging due to the complexity of both user and system state involved. In this paper, we present several techniques to support <b>migratable</b> threads and compare the performance of these techniques. ...|$|E
40|$|Abstract. Grid {{applications}} {{need to be}} fault tolerant, malleable, and <b>migratable.</b> In previous work, we {{have presented}} orphan saving, an efficient mechanism addressing these issues for divide-and-conquer applications. In this paper, we present a mechanism for writing partial results to checkpoint files, adding the capability to also tolerate the total loss of all processors, and to allow suspending and later resuming an application. Both mechanisms have only negligible overheads {{in the absence of}} faults. In the case of faults, the new checkpointing mechanism outperforms orphan saving by 10 % to 15 %. Also, suspending/resuming an application has only little overhead, making our approach very attractive for writing grid applications. ...|$|E
40|$|In the past, {{pervasive}} {{systems have}} concentrated largely on integrating contextawareness for supporting application adaptations to suit user activities. However, {{with the increase}} complexity of pervasive computing applications and their requirements, {{there is also a}} need for more autonomic functionalities in the communication infrastructure to support this complexity. In this paper, we propose a hierarchical architecture based on active nodes, which maximizes the computational capabilities of various nodes within the pervasive computing environment, to support both pervasive user applications as well as autonomic functionalities within the communication infrastructures. The <b>migratable</b> active node architecture employs various decision-making processes for evaluating a rich set of context information...|$|E
40|$|Abstract. The {{knowledge}} of spatial arrangements of objects {{is an important}} component for the design of <b>migratable</b> user interfaces that target pervasive environments. Objects in these environments are often moving around individually, which leads to a highly dynamic and unpredictable environment. Due to its nature, spatial information cannot be described exhaustively, and uncertainty and imprecision need {{to be taken into account}} during both the design phase and at runtime. We present an approach to model dynamic spatial information, providing it with the ability to interpret to some extent uncertain and imprecise knowledge. We then integrate this type of spatial-awareness into ReWiRe, a framework for designing interactive pervasive environments, in order to improve its user-interface distribution techniques. ...|$|E
40|$|Contact: Jeremy Casas (503 - 690 - 1125) or Jonathan Walpole (503 - 690 - 1161) Parallel Virtual Machine (PVM) is a widely-used {{software}} {{system that allows}} a heterogeneous set of parallel and serial UNIX-based computers to be programmed as a single message-passing parallel machine. In this paper, an extension to PVM to support dynamic process migration is presented. Support for migration is important in general-purpose workstation environments since it allows parallel computations to co-exist with other applications, using idle-cycles as they become available and o-loading from workstations when {{they are no longer}} free. A description and evaluation of the design and implementation of the prototype <b>Migratable</b> PVM system is presented together with some performance results...|$|E
40|$|Abstract — Automatic, {{adaptive}} {{load balancing}} {{is essential for}} handling load imbalance that may occur during parallel finite element simulations involving mesh adaptivity, nonlinear material behavior and other localized effects. This paper demonstrates the successful application of a measurement-based dynamic load balancing concept to the finite element analysis of elasto-plastic wave propagation and dynamic fracture events. The simulations are performed {{with the aid of}} a parallel framework for unstructured meshes called ParFUM, which is based on Charm++ and Adaptive MPI (AMPI) and involves <b>migratable</b> user-level threads. The performance was analyzed using Projections, a performance analysis and post factum visualization tool. The bottlenecks to scalability are identified and eliminated using a variety of strategies resulting in performance gains ranging from moderate to highly significant. I...|$|E
40|$|ALMA is {{a revolutionary}} radio {{telescope}} at present and its full operation will start from 2012. It {{is expected that}} ALMA will resolve several cosmic questions and will show a new cosmic view to us. Our passion for astronomy naturally goes beyond ALMA because {{we believe that the}} 21 st-century Astronomy should pursue the new scientific frontier. In this conference, we propose a project of the future radio telescope to search for Habitable planets and finally detect 2 nd Earth as a <b>Migratable</b> planet. The detection of 2 nd Earth is one of ultimate dreams for not only astronomers but also people. Comment: 2 pages, 1 figure 2010 Asia-Pacific Radio Science Conference Commission J: Radio Astronomy J 2 Millimeter- and Sub-millimeter-wave Telescope and Arra...|$|E
40|$|This study {{reports the}} reading of 11 Arabic-speaking {{individuals}} with letter position dyslexia (LPD), {{and the effect of}} letter form on their reading errors. LPD is a peripheral dyslexia caused by a selective deficit to letter position encoding in the orthographic-visual analyzer, which results in migration of letters within words, primarily of middle letters. The Arabic orthography is especially interesting for the study of LPD because Arabic letters have different forms in different positions in the word. As a result, some letter position errors require letter form change. We compared the rate of letter migrations that change letter form with migrations that do not change letter form in 10 Arabic-speaking individuals with developmental LPD, and one bilingual Arabic and Hebrew-speaking individual with acquired LPD. The results indicated that the participants made 40 % letter position errors in <b>migratable</b> words when the resulting word included the letters in the same form, whereas migrations that changed letter form almost never occurred. The error rate of the Arabic-Hebrew bilingual reader was smaller in Arabic than in Hebrew. However, when only words in which migrations do not change letter form were counted, the rate was similar in Arabic and Hebrew. Hence, whereas orthographies with multiple letter forms for each letter might seem more difficult in some respects, these orthographies are in fact easier to read in some forms of dyslexia. Thus, the diagnosis of LPD in Arabic should consider the effect of letter forms on migration errors, and use only <b>migratable</b> words that do not require letter-form change. The theoretical implications for the reading model are that letter form (of the position-dependent type found in Arabic) is part of the information encoded in the abstract letter identity, and thus affects further word recognition processes, and {{that there might be a}} pre-lexical graphemic buffer in which the checking of orthographic well-formedness takes place...|$|E
40|$|Object {{abstraction}} {{is indispensable}} to construction of distributed applications to encapsulate {{the details of}} execution entities. By applying an RPC technology integrated with virtual memory management, this paper presents a novel approach to implementing <b>migratable</b> distributed objects. The novelties of the approach are transparency achieved at the instruction code level, distributed dynamic methods, and applicability to heterogeneous environments. The instruction code level transparency naturally accomplishes object migration and enables efficient manipulation of migrated objects. The distributed dynamic methods provide the programmers with flexible control of activities. 1 Introduction Construction of distributed application, which consists of autonomous execution entities running on loosely coupled machines, is hindered {{by the lack of}} knowledge on remote execution entities. Thus, it is essential to abstract these entities as the interacting modules with well-defined interfaces an [...] ...|$|E
40|$|Charm++ is an elegant, {{general-purpose}} {{parallel programming}} model backed by an adaptive runtime system [1]. This combination yields portable performance and {{a spectrum of}} real-world productivity benefits that have been demonstrated in production applications. Our submission to this year’s HPC Challenge (Class II) comprises six benchmarks that demonstrate these practical benefits available to application developers today. These include: (1) interoperability with MPI (2) automatic, dynamic load balancing (3) effortless checkpointing and restart on a different number of processors, and (4) application progress {{in the presence of}} failing processes. The submission also explains how overdecomposed, message-driven, <b>migratable</b> objects enhance the clarity of expression of parallel programs and also enable the runtime system to deliver portable performance. Our codesize (line counts) and a summary of the performance results can be seen in Table 1...|$|E
40|$|We {{report the}} first three cases of {{selective}} developmental letter position dyslexia in English. Although the parents and teachers {{of the children were}} concerned about these children's reading, standard tests did not reveal their deficit. Itwasonlywhenthe appropriate target words were presented, in this case, <b>migratable</b> words, thattheirletter positiondyslexiawasdetected. Whereaspreviousresearchhasdescribed cases with acquiredanddevelopmentalformsofletterpositiondyslexiainHebrew and Arabic readers, thisisthefirstreportofthistypeofreadingdisorder in English. The cardinal symptom of letter position dyslexia is the migration of letters withintheword (reading slime as ‘smile’; pirates as ‘parties’). These migration errors occur in reading aloud as well as in tasks of silent reading. This study provides further evidence that migration errors emerge at the level of early visual‐orthographic analysis, in the letter position encoding function. Alternative explanations for the occurrence of migration errors such as poor phonological processing or a deficit in the orthographic input lexicon are ruled out. 1...|$|E
40|$|We present our {{implementation}} of the HPC Challenge Class II (productivity) benchmarks in the Charm++ [1] programming paradigm 1. Our submission focuses on explaining how over-decomposed, message-driven, <b>migratable</b> objects enhance the clarity of expression of parallel programs and also enable the runtime system to deliver portable performance. Our submission includes implementations of three required benchmarks: Dense LU Factorization, FFT, and Random Access. We also include two additional benchmarks that represent relevant scientific computing algorithms of some complexity: Molecular Dynamics and Barnes-Hut. We believe our implementations demonstrate that a high-level productivity oriented model can also deliver portable performance via an intelligent runtime. Our code-size results {{can be seen in}} Table 1 and a summary of the performance metrics can be seen in Table 2. 1. PROGRAMMING MODEL We describe relevant aspects of the Charm++ programming model in order to set the context for explaining the benchmark implementations. 1. 1 Salient Feature...|$|E
40|$|Introduction Traditional UNIX-like {{systems such}} as Sprite [7] and MOSIX [2] support dynamic load {{balancing}} in a cluster by implementing process migration at the kernel level. Because the kernel has the best knowledge of all the activities and resources that are distributed within the cluster, it can perform resource management effectively. However, as UNIX was not designed {{with the notion of}} process migration from ground up, extending it to support migration usually requires a substantial amount of software effort and the portability of the system could be compromised as a result [3]. Delta Execution aims at providing a high-level and portable implementation of <b>migratable</b> Java threads that is not entangled with any low-level and system-dependent issues. The implementation is carried out at the middle-ware level by extending the Java Virtual Machine. Because of this high-level approach, the Delta Execution mechanism is also applicable to other language environments that are based on...|$|E
40|$|Parallel Virtual Machine (PVM) is a widely-used {{software}} {{system that allows}} a heterogeneous set of parallel and serial UNIX-based computers to be programmed as a single distributed-memory parallel machine. In this paper, an extension to PVM to support dynamic process migration is presented. Support for migration is important in general-purpose workstation environments since it allows parallel computations to co-exist with other applications, using idle-cycles as they become available and off-loading from workstations when {{they are no longer}} free. A description and evaluation of the design and implementation of the prototype <b>Migratable</b> PVM system is presented together with some performance results. 1 Introduction PVM [1, 2, 3] is a {{software system}} that allows a heterogeneous network of parallel and serial computers to be programmed as a single computational resource. This resource appears to the application programmer as a potentially large distributed-memory virtual computer. Such a s [...] ...|$|E
