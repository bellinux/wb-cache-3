158|806|Public
25|$|The first {{commands}} for classical MML {{appeared in}} the internal architecture of the SP-1002 MONITOR IOCS and SP-5001 BASIC Operating Systems on the MZ-80K 8-bit computer. Made by SHARP Corporation at 1978 in Japan. It incorporated Intel 8253 hardware and <b>memory</b> <b>mapped</b> I/O. The sound-related BASIC Statements were MUSIC, TEMPO, and BEEP.|$|E
2500|$|RAM: {{commonly}} 64kB (on Japanese computers), normally <b>memory</b> <b>mapped</b> (4MB per slot maximum) ...|$|E
2500|$|RAM: 64kB minimum, {{commonly}} 128kB in Europe, 64kB on Japanese computers, {{machines with}} up to 512kB were made. Normally <b>memory</b> <b>mapped</b> (4MB per slot maximum) ...|$|E
50|$|The 940 accesses memory {{through a}} <b>memory</b> <b>map</b> to provide virtual <b>memory.</b> The <b>map</b> formats differ {{slightly}} between a user <b>memory</b> <b>map</b> and a monitor <b>memory</b> <b>map.</b>|$|R
5000|$|... jmap Oracle jmap - <b>Memory</b> <b>Map</b> - [...] This utility outputs the <b>memory</b> <b>map</b> for Java and {{can print}} shared object <b>memory</b> <b>maps</b> or heap <b>memory</b> {{details of a}} given process or core dump. (experimental) ...|$|R
50|$|A set of <b>memory</b> <b>map</b> {{registers}} {{is used to}} map virtual addresses to physical. There {{are eight}} <b>memory</b> <b>map</b> registers, each mapping 2K words, to provide an address space of 16K.|$|R
50|$|The J {{programming}} language has supported <b>memory</b> <b>mapped</b> files {{since at least}} 2005. It includes support for boxed array data, and single datatype files. Support can be loaded from 'data/jmf' J's Jdb and JD database engines use <b>memory</b> <b>mapped</b> files for column stores.|$|E
5000|$|Buffered, synchronous, asynchronous, direct, and <b>memory</b> <b>mapped</b> I/O ...|$|E
5000|$|XMLMemMappedBuffer {{performs}} <b>memory</b> <b>mapped</b> {{loading of}} XML documents.|$|E
50|$|In native {{debugger}} programs, a <b>memory</b> <b>map</b> {{refers to}} the mapping between loaded executable/library files and memory regions. These <b>memory</b> <b>maps</b> are used to resolve memory addresses (such as function pointers) to actual symbols.|$|R
50|$|The monitor can {{use either}} the monitor <b>memory</b> <b>map</b> or the user <b>memory</b> <b>map,</b> {{determined}} by the value of bit 0 of the instruction. This allows the monitor access to the user's address space.|$|R
50|$|The {{hardware}} of {{the system}} is arranged so that devices on the address bus will only respond to particular addresses which are intended for them, while all other addresses are ignored. This is the job of the address decoding circuitry, and that establishes the <b>memory</b> <b>map</b> {{of the system}}. As a result, system's <b>memory</b> <b>map</b> may look like in the table on the right. This <b>memory</b> <b>map</b> contains gaps, which is also quite common in actual system architectures.|$|R
5000|$|In the Microsoft [...]NET runtime, P/Invoke {{can be used}} to use <b>memory</b> <b>mapped</b> files {{directly}} through the Windows API. Managed access (P/Invoke not necessary) to <b>memory</b> <b>mapped</b> files was introduced in version 4 of the runtime (see Memory-Mapped Files). For previous versions, there are third-party libraries which provide managed API's.|$|E
50|$|Another pseudo-type—associated with name, {{rather than}} value—is the <b>memory</b> <b>mapped</b> file.|$|E
5000|$|... 4 fast {{switchable}} register {{banks with}} 8 registers each (<b>memory</b> <b>mapped)</b> ...|$|E
50|$|The Linux framebuffer {{device was}} {{developed}} to abstract the physical method for accessing the underlying framebuffer into a guaranteed <b>memory</b> <b>map</b> that is easy for programs to access. This increases portability, as programs {{are not required to}} deal with systems that have disjointed <b>memory</b> <b>maps</b> or require bank switching.|$|R
5000|$|BIOS Function: INT 0x15, AX=0xE820 - GET SYSTEM <b>MEMORY</b> <b>MAP</b> '''''': ...|$|R
40|$|We {{introduce}} {{a new approach to}} take into account the memory architecture and the <b>memory</b> <b>mapping</b> in High- Level Synthesis for data intensive applications. We formalize the <b>memory</b> <b>mapping</b> as a set of constraints for the synthesis, and defined a Memory Constraint Graph and an accessibility criterion to be used in the scheduling step. We use a <b>memory</b> <b>mapping</b> file to include those memory constraints in our HLS tool GAUT. It is possible, with the help of GAUT, to explore a wide range of solutions, and to reach a good tradeoff between time, power-consumption, and area. Comment: ISBN 0 - 7695 - 2097 -...|$|R
50|$|The D {{programming}} language supports <b>memory</b> <b>mapped</b> files in its standard library (std.mmfile module).|$|E
5000|$|RAM: {{commonly}} 64 kB (on Japanese computers), normally <b>memory</b> <b>mapped</b> (4 MB per slot maximum) ...|$|E
5000|$|The Java {{programming}} language provides classes and methods to access <b>memory</b> <b>mapped</b> files, such as [...]|$|E
5000|$|The Microtan 65 <b>memory</b> <b>map</b> {{is shown}} below ($ {{representing}} a hexadecimal memory address): ...|$|R
5000|$|Missiles {{share the}} same bytes of the <b>memory</b> <b>maps</b> above, two bits per Missile: ...|$|R
5000|$|TI-990/10 [...] - [...] TTL {{processor}} with <b>memory</b> <b>mapping</b> support to 2M {{bytes of memory}} ...|$|R
50|$|Examining the ROM chip at the Reset vector shows a JMP {{instruction}} {{outside the}} <b>memory</b> <b>mapped</b> {{location of the}} chip.|$|E
50|$|The {{major reason}} to choose <b>memory</b> <b>mapped</b> file I/O is performance. Nevertheless, {{there can be}} tradeoffs. The {{standard}} I/O approach is costly due to system call overhead and memory copying. The memory-mapped approach has its cost in minor page faults—when a block of data is loaded in page cache, but is not yet mapped into the process's virtual memory space. In some circumstances, <b>memory</b> <b>mapped</b> file I/O can be substantially slower than standard file I/O.|$|E
5000|$|RAM: 64 kB minimum, {{commonly}} 128 kB in Europe, 64 kB on Japanese computers, {{machines with}} up to 512 kB were made. Normally <b>memory</b> <b>mapped</b> (4 MB per slot maximum) ...|$|E
5000|$|TI-990/10A [...] - [...] TMS-99000 {{microprocessor}} with <b>memory</b> <b>mapping</b> {{support to}} 1M {{bytes of memory}} ...|$|R
40|$|Abstract: The DS 1865 {{burst-mode}} PON controller with {{integrated monitoring}} provides programming options required to configure the alarms, warnings, lookup tables, and other functions detailed in Application Note 4052, Quick Reference Guide to the DS 1863 <b>Memory</b> <b>Map.</b> This programmability necessitates a large register <b>memory</b> <b>map.</b> This application note provides an alternate {{outline of the}} register map, which is convenient when programming the device...|$|R
50|$|In {{computer}} science, a <b>memory</b> <b>map</b> is {{a structure}} of data (which usually resides in memory itself) that indicates how memory is laid out. <b>Memory</b> <b>maps</b> can have a different meaning {{in different parts of}} the operating system. It is the fastest and most flexible cache organization which uses an associative memory. The associative memory stores both the address and content of the memory word.|$|R
50|$|<b>Memory</b> <b>mapped</b> I/O devices {{can also}} be {{accessed}} by using the LDA (load accumulator from a 16-bit address) and STA (store accumulator at a 16-bit address specified) instructions, or any other instructions that have memory operands.|$|E
50|$|SunOS 4 {{includes}} what is {{most likely}} the earliest implementation of tmpfs; it first appeared in SunOS 4.0 in late 1987, together with new orthogonal address space management that allowed any object to be <b>memory</b> <b>mapped.</b>|$|E
50|$|MonetDB {{internal}} data representation also {{relies on the}} memory addressing ranges of contemporary CPUs using demand paging of <b>memory</b> <b>mapped</b> files, and thus departing from traditional DBMS designs involving complex management of large data stores in limited memory.|$|E
50|$|This exhibit was {{followed}} by a solo show at the Milwaukee Art Museum which featured the Kitty Ewens <b>Memory</b> <b>Map.</b> The work was created from the childhood recollections of Kitty Ewens, a 101-year-old resident of the Milwaukee area. The <b>Memory</b> <b>Maps</b> attracted the attention of social psychologists such as Stanley Milgram with whom Welch collaborated in a 1975 exhibition at the Piltzer Gallery in Paris.|$|R
5000|$|A file {{interface}} {{that supports}} locks and <b>memory</b> <b>mapping</b> of files up to [...] bytes (2 GiB) ...|$|R
50|$|The {{following}} is the <b>memory</b> <b>map</b> for the Atom. Shaded areas indicate those {{present on the}} minimal system.|$|R
