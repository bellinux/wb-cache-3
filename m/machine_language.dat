672|737|Public
25|$|PackML (Packaging <b>Machine</b> <b>Language)</b> is an {{industry}} technical standard for the control of packaging machines, as an aspect of industrial automation.|$|E
25|$|On his own again, Cuccurullo began {{recording}} {{some music}} {{in his bedroom}} that was eventually released on his solo album <b>Machine</b> <b>Language.</b>|$|E
25|$|Applesoft BASIC {{used the}} {{ampersand}} as an internal command, {{not intended to}} be used for general programming, that invoked a <b>machine</b> <b>language</b> program in the computer's ROM.|$|E
5000|$|Algebraic Theory of <b>Machines,</b> <b>Languages</b> and Semigroups (January, 1968) ...|$|R
5000|$|... 1978, with Jack Dennis and Joe Qualitz. <b>Machines,</b> <b>Languages,</b> and Computation. Prentice-Hall.|$|R
40|$|This paper {{argues that}} through affording {{communications}} between machines and humans, <b>machine</b> <b>languages</b> become structures of media. To examine the argument, the paper selects a virtual city {{model of the}} Alphatown {{as a case study}} and draws on Roman Jakobson’s linguistic theory, at first analyses how the metalanguage functions via the mediums of listing and navigation in the Alphatown, then looks at how the affects of boredom, being lost and strangeness arise from the media infrastructures based upon metalanguage, and analyses where the poetic function lies in the transmission of affects and how the sensual and the material aspects of <b>machine</b> <b>languages</b> emerge thus functioning as poetic. With analysing the metalingual and poetic functions in a diagrammatic thought of <b>machine</b> <b>languages,</b> different levels of <b>machine</b> <b>languages</b> can be considered as media structures, while media structures manifest themselves as material and processual in the meantime...|$|R
25|$|The gcj Java {{compiler}} can target {{either a}} native <b>machine</b> <b>language</b> architecture or the Java virtual machine's Java bytecode. When retargeting GCC {{to a new}} platform, bootstrapping is often used.|$|E
25|$|At {{the level}} of <b>machine</b> <b>language</b> or {{assembly}} language, control flow instructions usually work by altering the program counter. For some central processing units (CPUs), the only control flow instructions available are conditional or unconditional branch instructions, also termed jumps.|$|E
25|$|Since that time, Cuccurullo has {{recorded}} solo albums including Road Rage, <b>Machine</b> <b>Language,</b> and recently, Playing in Tongues. He has collaborated with musicians including Frank Sinatra, Blondie, Dweezil Zappa, Shenkar, Milton Nascimento, Wes Wehmiller, and Patrick O'Hearn, {{as well as}} Terry Bozzio.|$|E
50|$|A {{programming}} language such as C, FORTRAN, or Pascal enables a programmer to write {{programs that are}} more or less independent from a particular type of computer. Such languages are considered high-level because they are closer to human languages and further from <b>machine</b> <b>languages.</b> In contrast, assembly languages are considered as low-level because they are very close to <b>machine</b> <b>languages.</b>|$|R
50|$|Methods {{have been}} {{proposed}} to use the operational semantics of <b>machine</b> <b>languages</b> to automatically generate verification condition generators.|$|R
50|$|Belevitch {{wrote a book}} {{on human}} and <b>machine</b> <b>languages</b> in which he {{explored}} the idea of applying the mathematics of information theory to obtain results regarding human languages. The book highlighted the difficulties for <b>machine</b> understanding of <b>language</b> for which there was some naive enthusiasm amongst cybernetics researchers in the 1950s.|$|R
25|$|SpeedScript {{was later}} ported to the Atari and the Apple II family in Compute! in May and June 1985 respectively. SpeedScript was written entirely in {{assembly}} language, and Compute! Publications later released book/disk combinations that contained the complete commented source code (as {{well as the}} <b>machine</b> <b>language</b> in MLX format) for each platform.|$|E
25|$|A program {{written in}} {{assembly}} language {{consists of a}} series of mnemonic processor instructions and meta-statements (known variously as directives, pseudo-instructions and pseudo-ops), comments and data. Assembly language instructions usually consist of an opcode mnemonic followed by a list of data, arguments or parameters. These are translated by an assembler into <b>machine</b> <b>language</b> instructions that can be loaded into memory and executed.|$|E
25|$|In 1961, Burroughs Corporation {{introduced}} the B5000 with the MCP, (Master Control Program) operating system. The B5000 was a stack machine designed to exclusively support high-level languages with no <b>machine</b> <b>language</b> or assembler, {{and indeed the}} MCP was the first OS to be written exclusively in a high-level language ESPOL, a dialect of ALGOL. MCP also introduced many other ground-breaking innovations, such as being the first commercial implementation of virtual memory. During development of the AS/400, IBM made an approach to Burroughs to license MCP to run on the AS/400 hardware. This proposal was declined by Burroughs management to protect its existing hardware production. MCP is still in use today in the Unisys ClearPath/MCP line of computers.|$|E
40|$|Abstract — Realistic formal {{specifications}} of <b>machine</b> <b>languages</b> {{for commercial}} processors consist {{of thousands of}} lines of definitions. Current methods support trustworthy proofs of the correctness of programs for one such specification. However, these methods provide little or no support for reusing proofs of the same algorithm implemented in different <b>machine</b> <b>languages.</b> We describe an approach, based on proof-producing decompilation, which both makes machine-code verification tractable and supports proof reuse between different languages. We briefly present examples based on detailed models of machine code for ARM, PowerPC and x 86. The theories and tools have been implemented in the HOL 4 system. I...|$|R
500|$|Belevitch {{wrote a book}} {{on human}} and <b>machine</b> <b>languages</b> in which he {{explored}} the idea of applying the mathematics of information theory to obtain results regarding human languages. [...] The book highlighted the difficulties for <b>machine</b> understanding of <b>language</b> for which there was some naive enthusiasm amongst cybernetics researchers in the 1950s.Vandewalle, pp.429-430Walker, p.81 ...|$|R
50|$|The {{term was}} coined {{to provide a}} {{distinction}} from higher level third-generation programming languages (3GL) such as COBOL and earlier first-generation programming <b>language</b> (<b>machine</b> code <b>languages).</b>|$|R
25|$|The {{hardware}} {{implementation of}} almost all computers is imperative. Nearly all computer hardware is designed to execute machine code, which is native to the computer, written in the imperative style. From this low-level perspective, the program state {{is defined by the}} contents of memory, and the statements are instructions in the native <b>machine</b> <b>language</b> of the computer. Higher-level imperative languages use variables and more complex statements, but still follow the same paradigm. Recipes and process checklists, while not computer programs, are also familiar concepts that are similar in style to imperative programming; each step is an instruction, and the physical world holds the state. Since the basic ideas of imperative programming are both conceptually familiar and directly embodied in the hardware, most computer languages are in the imperative style.|$|E
500|$|At {{the end of}} the ban, {{the four}} {{students}} offered to find bugs in CCC's software in exchange for extra computer time. Rather than use the system via Teletype. Subsequently, Gates went to CCC's offices and studied source code for various programs that ran on the system, including programs in Fortran, Lisp, and <b>machine</b> <b>language.</b> The arrangement with CCC continued until 1970, when the company went out of business. The following year, Information Sciences, Inc. hired the four Lakeside students to write a payroll program in COBOL, providing them computer time and royalties. After his administrators became aware of his programming abilities, Gates wrote the school's computer program to schedule students in classes. He modified the code so that he was placed in classes with [...] "a disproportionate number of interesting girls." [...] He later stated that [...] "it was hard to tear myself away from a machine at which I could so unambiguously demonstrate success." [...] At age 17, Gates formed a venture with Allen, called Traf-O-Data, to make traffic counters based on the Intel 8008 processor. [...] In early 1973, Bill Gates served as a congressional page in the U.S. House of Representatives.|$|E
2500|$|Daniel Jurafsky, an {{associate}} professor of linguistics at Stanford University who specializes in statistical models of human and <b>machine</b> <b>language</b> processing ...|$|E
5000|$|Like all virtual <b>machine</b> <b>languages,</b> PowerHouse is CPU intensive. [...] This {{sometimes}} {{produced a}} visibly {{negative impact on}} overall transaction performance necessitating hardware upgrades. [...] Cognos practice of tying license fees to hardware performance metrics resulted in high licensing costs for PowerHouse users.|$|R
40|$|Jody R. Threet (Ph. D. in Computer Science) A Formal Process Calculus and Execution Model for Distributed Agent Computing (55 pp. - V Chapters) Directed by Professor Sujeet Shenoi (237 words) Most {{low level}} <b>machine</b> <b>languages</b> reflect the {{hardware}} {{on which they}} execute. Current hardware promotes the development of sequential <b>machine</b> <b>languages.</b> Such languages do not provide atomic forms of communication which is a fundamental operation in distributed computing and severely restricts the expression of fine-grained concurrency. Furthermore, most high and low level programming languages lack formal semantics. This makes the analysis, i. e. the specification and proof of abstract properties, practically impossible. This work involves {{the design of a}} formal concurrent language which is a robust extension of an exiting flawed concurrent language. The fundamental event in the formal concurrent language is communication, so that computation consists of distributed agents communicating values. A co [...] ...|$|R
50|$|Belevitch had an {{interest}} in languages and found a mathematical derivation of Zipf's law. He also published on <b>machine</b> <b>languages.</b> Another field of interest was transmission lines, where he published on line coupling. He worked on telephone conferencing and introduced the mathematical construct of the conference matrix.|$|R
2500|$|Transforming {{assembly}} language into machine code {{is the job}} of an assembler, and the reverse can at least partially be achieved by a disassembler. Unlike high-level languages, there is a one-to-one correspondence between many simple assembly statements and <b>machine</b> <b>language</b> instructions. However, in some cases, an assembler may provide pseudoinstructions (essentially macros) which expand into several <b>machine</b> <b>language</b> instructions to provide commonly needed functionality. For example, for a machine that lacks a [...] "branch if greater or equal" [...] instruction, an assembler may provide a pseudoinstruction that expands to the machine's [...] "set if less than" [...] and [...] "branch if zero (on the result of the set instruction)". Most full-featured assemblers also provide a rich macro language (discussed below) which is used by vendors and programmers to generate more complex code and data sequences.|$|E
2500|$|Microsoft {{released}} Visual Studio [...]NET (VS.NET), codenamed Rainier (for Washington's Mount Rainier), in February 2002 (the {{beta version}} was released via Microsoft Developer Network in 2001). The biggest change was {{the introduction of}} a managed code development environment using the [...]NET Framework. Programs developed using [...]NET are not compiled to <b>machine</b> <b>language</b> (like C++ is, for example) but instead to a format called Microsoft Intermediate Language (MSIL) or Common Intermediate Language (CIL). When a CIL application executes, it is compiled while being executed into the appropriate <b>machine</b> <b>language</b> for the platform it is being executed on, thereby making code portable across several platforms. Programs compiled into CIL can be executed only on platforms which have an implementation of Common Language Infrastructure. It is possible to run CIL programs in Linux or Mac OS X using non-Microsoft [...]NET implementations like Mono and DotGNU.|$|E
2500|$|In 1997 Cuccurullo {{completed}} <b>Machine</b> <b>Language,</b> an ambient instrumental guitar album, also {{released on}} Imago. [...] He {{followed up with}} a live album, Roadrage in 1998 (on Bandai Records). [...] The Blue (recorded with Shenkar in 1992) was self-released in 2000. [...] Another ambient album, Trance Formed, was released on One Way Records in 2003.|$|E
50|$|CoreASM is an {{open source}} project (licensed under Academic Free License version 3.0) {{that focuses on the}} design of a lean {{executable}} ASM (Abstract State <b>Machines)</b> <b>language,</b> in combination with a supporting tool environment for high-level design, experimental validation, and formal verification (where appropriate) of abstract system models.|$|R
40|$|Timing {{diagrams}} {{are popular}} in hardware design. They have been formalized {{for use in}} reasoning tasks, such as computer-aided verification. These efforts have largely treated timing diagrams as interfaces to established notations for which verification is decidable; this has restricted timing diagrams to expressing only regular language properties. This paper presents a timing diagram logic capable of expressing certain context-free and context-sensitive properties. It shows that verification is decidable for properties expressible in this logic. More specifically, it shows that containment of !-regular languages generated by Buchi automata in timing diagram languages is decidable. The result relies on a correlation between timing diagram and reversal bounded counter <b>machine</b> <b>languages.</b> Keywords: computer-aided verification, counter <b>machines,</b> <b>language</b> containment, model checking, timing diagrams. 1. Introduction Hardware designers use diagrammatic representations extensively and perv [...] ...|$|R
5000|$|... virtual {{machines}} as in Java virtual <b>machine,</b> Common <b>Language</b> Runtime, etc.|$|R
2500|$|Each {{computer}} architecture {{has its own}} <b>machine</b> <b>language.</b> [...] Computers differ in the number and type of operations they support, in the different sizes and numbers of registers, and in the representations of data in storage. While most general-purpose computers are {{able to carry out}} essentially the same functionality, the ways they do so differ; the corresponding assembly languages reflect these differences.|$|E
2500|$|Instructions (statements) in {{assembly}} language are generally very simple, unlike those in high-level languages. Generally, a mnemonic is a symbolic {{name for a}} single executable <b>machine</b> <b>language</b> instruction (an opcode), and {{there is at least}} one opcode mnemonic defined for each <b>machine</b> <b>language</b> instruction. Each instruction typically consists of an operation or opcode plus zero or more operands. Most instructions refer to a single value, or a pair of values. [...] Operands can be immediate (value coded in the instruction itself), registers specified in the instruction or implied, or the addresses of data located elsewhere in storage. This is determined by the underlying processor architecture: the assembler merely reflects how this architecture works. Extended mnemonics are often used to specify a combination of an opcode with a specific operand, e.g., the System/360 assemblers use [...] as an extended mnemonic for [...] with a mask of 15 and [...] ("NO OPeration" [...] – do nothing for one step) for [...] with a mask of 0.|$|E
2500|$|SpeedScript {{is a word}} {{processor}} originally printed as a type-in <b>machine</b> <b>language</b> listing in 1984-85 issues of Compute! and Compute!'s Gazette magazines. [...] Approximately 5KB in length, it provided {{many of the same}} features as commercial word processing packages of the early 8-bit era, such as PaperClip and Bank Street Writer. Versions were published for the Apple II, Commodore 64 and 128, Atari 8-bit family, VIC-20, and for MS-DOS.|$|E
50|$|A full {{featured}} development package {{would include}} a linker and a run-time support library. Usually a <b>machine</b> oriented <b>language</b> is required for writing the support library. C or C++ {{could be used as}} a <b>machine</b> oriented <b>language.</b> A library consisting of support functions required for the compilation process usually rounds out the full metacompiler package.|$|R
40|$|ABSTgACr The {{problem of}} {{determining}} the minimum representation of programs for executmn by a computer is considered The methods of measuring space requirements suggest practical methods for encoding programs and for designing <b>machine</b> <b>languages</b> An analysis of the operation portion of instructions finds that the 47 operation codes used by a well-known compiler require, on average, fewer than two bits eac...|$|R
40|$|The MTS Manual is {{a series}} of volumes that {{describe}} in detail the facilities provided by the Michigan Terminal System. The May 1983 revision reflects the changes that have been made to MTS since August 1978. This edition contains information for using those translators which translate languages that are essentially 360 or 370 <b>machine</b> <b>languages.</b> The translators described are Assembler H and ASSIST...|$|R
