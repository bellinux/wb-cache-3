12|1637|Public
5000|$|Turing {{adds another}} definition, Rosser equates all three: Within {{just a short}} time, Turings 1936-37 paper [...] "On Computable Numbers, with an Application to the Entscheidungsproblem" [...] appeared. In it he stated another notion of [...] "effective computability" [...] with the {{introduction}} of his a-machines (now known as the Turing <b>machine</b> <b>abstract</b> computational model). And in a proof-sketch added as an [...] "Appendix" [...] to his 1936-37 paper, Turing showed that the classes of functions defined by λ-calculus and Turing machines coincided. Church was quick to recognise how compelling Turings analysis was. In his review of Turings paper he made clear that Turings notion made [...] "the identification with effectiveness in the ordinary (not explicitly defined) sense evident immediately".|$|E
40|$|Key words：optical flow algorithm; people counting; object tracking; support vector <b>machine</b> <b>Abstract.</b> In {{order to}} improve the {{accuracy}} of people counting in video surveillance, the method for people counting based on {{the analysis of the}} mass is proposed. The novel algorithm of objects tracking is designed to aim at people counting, and the people counting model is obtained by training a support vector machine (SVM) classifier with the input of the feature of mass. The experimental results show that the accuracy of counting is over 93 %...|$|E
40|$|Key words: smile {{expression}} classification; gabor filters bank; pyramid histogram of oriented gradient; pyramid local binary pattern; support vector <b>machine</b> <b>Abstract.</b> This paper {{proposed to}} build a smile expression classification system on data sets of GENKI that can represent real-world environments, and tested its implementation, in which we got the optimal recognition rate up to 86. 197 %. To deal with the features extraction problems, hybrid features (i. e., Gabor, PHOG, PLBP) are used, using hybrid recognition algorithms (i. e., GentleBoost, SVM) to classify, in this paper. Experiments showed the effectiveness of our methods. I...|$|E
30|$|SETS: Declaration of the {{definitions}} of <b>machine’s</b> <b>abstract</b> or listed sets.|$|R
50|$|The ALF {{system was}} {{designed}} to be an efficient implementation of the combination of resolution, narrowing, rewriting, and rejection. ALF programs are compiled into instructions of an <b>abstract</b> <b>machine.</b> The <b>abstract</b> <b>machine</b> is based on the Warren <b>Abstract</b> <b>Machine</b> (WAM) with several extensions to implement narrowing and rewriting. In the current ALF implementation programs of this <b>abstract</b> <b>machine</b> are executed by an emulator written in C.|$|R
2500|$|Krivine <b>machine</b> - A <b>abstract</b> <b>machine</b> to {{interpret}} call-by-name in lambda-calculus ...|$|R
40|$|Civil {{society is}} one of the most {{relevant}} concepts defined by Hegel’s philosophy of law. Analysing the material and symbolic layers that create the “system of needs”, Hegel enters a dialogue with political economics and foregrounds the constitutive features of the modern bourgeois society embodied as a distinct existential sphere by the representative political state. The concepts of market, contract, <b>machine,</b> <b>abstract</b> labour, the circulation of goods, ownership, land and possession are investigated as essential elements of the social experience of modernity. They consolidate the original tension between the public and the private, the general and the particular, the abstract and the concrete, the form and the content...|$|E
40|$|Discrete hidden markov model, Support vector <b>machine</b> <b>Abstract.</b> Because of the {{problems}} of fault diagnosis in the power electric circuit and the merit of FCM is efficient in clustering and the merit of hidden Markov model (HMM) that have the ability to deal with continuous dynamic signals and the merit of support vector machine (SVM) with perfect classifying ability, With the features extracted from the circuit, based on the trained FCM algorithm, HMM was used to calculate the matching degree among the unknown signal and the circuit’s states, which formed the features for SVM to diagnosis. Double-bridge 12 -pulse rectifier is used as a example to verifiy the effectiveness of the method. The experimental results show that the proposed method has a good correct rate...|$|E
40|$|Keywords- {{forecast}} of grain production; grey relationnal analysis; statistical learning theory;support vector <b>machine</b> <b>Abstract.</b> This paper proposes a new method: GRA-SVM model which {{is composed of}} GRA and SVM to predict grain production through annual production data. In {{view of the fact}} that the complexity and incomplete information of grain production system, the primary factors influencing the grain production is decided on the basis of the grey ralational analysis of the grain producing system, then, the grey ralational analysis and support vector machine model is established by the principle of the support vection machine regression. The application case proved that the proposed method can improve the feasibility of the program in grain production, and it is suitable for on-line grain production control for food system...|$|E
30|$|The B {{method is}} based on the notion of <b>abstract</b> <b>machines.</b> These <b>abstract</b> <b>machines</b> can be {{associated}} to imperative programing, which describes the operations in terms of sequences of elementary instructions executed to change the program state. Each machine declares its own variables and operations and variables can only be changed by the machine’s operations.|$|R
40|$|We {{bridge the}} gap between {{functional}} evaluators and <b>abstract</b> <b>machines</b> for the λ-calculus, using closure conversion, transformation into continuation-passing style, and defunctionalization. We illustrate this approach by deriving Krivine’s <b>abstract</b> <b>machine</b> from an ordinary call-by-name evaluator and by deriving an ordinary call-by-value evaluator from Felleisen et al. ’s CEK machine. The first derivation is strikingly simpler than what {{can be found in the}} literature. The second one is new. Together, they show that Krivine’s <b>abstract</b> <b>machine</b> and the CEK machine correspond to the call-by-name and call-by-value facets of an ordinary evaluator for the λ-calculus. We then reveal the denotational content of Hannan and Miller’s CLS machine and of Landin’s SECD machine. We formally compare the corresponding evaluators and we illustrate some degrees of freedom in the design spaces of evaluators and of <b>abstract</b> <b>machines</b> for the λ-calculus with computational effects. Finally, we consider the Categorical <b>Abstract</b> <b>Machine</b> and the extent to which it is more of a virtual <b>machine</b> than an <b>abstract</b> <b>machine...</b>|$|R
40|$|AbstractIn {{this paper}} we {{demonstrate}} {{how to use}} a semantics-directed generator to systematically design <b>abstract</b> <b>machines.</b> The main novelty of the generator is that it generates compilers and <b>abstract</b> <b>machines.</b> The generator is fully automated and its core transformations are proved correct. In this paper we propose a design methodology based on our generator and as an example we design a functional <b>abstract</b> <b>machine</b> which turns out to be very similar to the categorial <b>abstract</b> <b>machine...</b>|$|R
40|$|Because of the {{increasing}} gap between modern high-level programming languages and existing hardware, it has often become necessary to introduce intermediate languages and to build abstract machines {{on top of the}} primitive hardware. This paper describes the ABSTRACT-MACHINE, a structural pattern that captures the essential features addressing the definition of machines as separate components, as well as it considers the instruction set and the semantics for these instructions as other first-order components of the pattern. Define a common template for the design of Abstract Machines. The pattern captures the essential features underlying abstract machines (i. e., data area, program, instruction set, etc [...] .), encapsulating them in separated loose-coupled components into a structural pattern. Furthermore, the proposal provides the collaboration structures how components of an abstract machine interact. Also known as Virtual <b>Machine,</b> <b>Abstract</b> State Machine...|$|E
40|$|Abstract: The Krivine {{machine is}} a simple and natural {{implementation}} of the normal weak-head reduction strategy for pure λ-terms. While its original description has remained unpublished, this machine {{has served as a}} basis for many variants, extensions and theoretical studies. In this paper, we present the Krivine machine and some well-known variants in a common framework. Our framework consists of a hierarchy of intermediate languages that are subsets of the λ-calculus. The whole implementation process (compiler + abstract machine) is described via a sequence of transformations all of which express an implementation choice. We characterize the essence of the Krivine machine and locate it in the design space of functional language implementations. We show that, even within the particular class of Krivine machines, hundreds of variants can be designed. Key-words: Krivine <b>machine,</b> <b>abstract</b> machines, program transformation, compilation, functional language implementations...|$|E
40|$|Part 3 : Smart Cards and Embedded DevicesInternational audienceAttacks {{based on}} type {{confusion}} against Java Card platforms {{have been widely}} studied in the literature {{over the past few}} years. Until now, no generic countermeasure has ever been proposed to cover simultaneously and efficiently direct and indirect type confusions. In this article we bridge this gap by introducing two different schemes which cover both type confusions. First, we show that an adequate random transformation of all the manipulated data on the platform according to their type can bring a very good resistance against type confusion exploits. Secondly, we describe how a so-called Java Card Virtual <b>Machine</b> <b>Abstract</b> Companion can allow one to detect all type confusions between integers and Objects all across the platform. While the second solution stands as a strong but resource-demanding mechanism, we show that the first one is a particularly efficient memory/security trade-off solution to secure the whole platform...|$|E
40|$|We study <b>abstract</b> <b>machines</b> as a {{perspective}} {{from which to}} better approach the development of complex systems. We believe that <b>abstract</b> <b>machines</b> provide a form of modularity that has been largely under-appreciated, and {{that has the potential}} to yield varied and substantial benets. An important notion in exploring the interaction of <b>abstract</b> <b>machines</b> is one of renement of one machine by another, which provides the ability for processes, threads, programs, or even single instructions from several <b>abstract</b> <b>machines</b> to share processors and data. ...|$|R
40|$|AbstractWe derive an <b>abstract</b> <b>machine</b> {{from the}} Curry-Howard {{correspondence}} with a sequent calculus presentation of Intuitionistic Propositional Linear Logic. The {{states of the}} register based <b>abstract</b> <b>machine</b> comprise a low-level code block, a register bank and a dump holding suspended procedure activations. Transformation of natural deduction proofs into our sequent calculus yields a type-preserving compilation function from the Linear Lambda Calculus to the <b>abstract</b> <b>machine.</b> We prove correctness of the <b>abstract</b> <b>machine</b> {{with respect to the}} standard call-by-value evaluation semantics of the Linear Lambda Calculus...|$|R
40|$|We {{present an}} extensive, {{annotated}} bibliography of the <b>abstract</b> <b>machines</b> designed {{for each of}} the main programming paradigms (imperative, object oriented, functional, logic and concurrent). We conclude that whilst a large number of efficient <b>abstract</b> <b>machines</b> have been designed for particular language implementations, relatively little work has been done to design <b>abstract</b> <b>machines</b> in a systematic fashion...|$|R
40|$|The inverse {{problem of}} life cycle assessment, used in {{designing}} for environment, is about determining the optimal values of environmental inputs {{that provide the}} required environmental impacts. The notion of the inverse problem of life cycle assessment is explained here using {{a case study of}} a coffee <b>machine</b> (<b>abstract</b> model SimaPro, based on models Sima and Pro described in SimaPro 8. 1 software). The dependencies between input and output signals were defined by nonlinear functions of several variables. Next, linearization was used and coefficient aki was calculated. On the basis of 3 hypothetical experiments, recommendations have been made on the reduction {{of the value of the}} factors that are the most detrimental for the environment: the consumption of aluminium, electricity, and paper for coffee filters, for the analysed product. The results prove the high applicability and usefulness of the proposed approach during environmental evaluation and enhancement of products over the full product life cycle...|$|E
40|$|Keywords:mobile robots; terrain classification; vibrations; Support Vector <b>Machine</b> <b>Abstract.</b> Human {{ability to}} explore planets (e. g. the moon, Mars) {{depends on the}} {{autonomous}} mobile performance of planetary exploration robots, so studying on terrain classification is important for it. Vibration-based terrain classification unlike vision classification affected by lighting variations, easily cheated by covering of surface, it analyses the vibration signals from wheel-terrain interaction to classify. Three accelerometers in x,y, zdirection and a microphone in z direction were mounted to arm of the left-front wheel. The robot drove on the sand, gravel, grass, clay and asphalt at six speeds, three groups of acceleration signal and one group of sound pressure signal were received. The original signals were dealt using Time Amplitude Domain Analysis. Original data were divided into segments, each segment was a three centimeters distance of driving; eleven features from every segment were normalized. The data from four sensors weremerged into aforty-four dimensions feature vector. Ten one against one classifiers of Support Vector Machine(SVM) wereused to classify; one against one SVM program from LibSVM was applied to multi-class classification usingvoting strategy in MATLAB. Facing to {{the same number of}} votes, we propose a new algorithm. Experimental results demonstrate the effectiveness of the feature extraction method and the multi-class SVM algorithm...|$|E
40|$|The Evolvable Virtual <b>Machine</b> <b>abstract</b> {{architecture}} (EVMA) is a computational archi-tecture for dynamic hierarchically organised virtual machines. The concrete EVM in-stantiation (EVMI) {{builds on}} traditional stack-based models of computation and extends them by notions of hierarchy and {{reflection on the}} virtual machine level. The EVM Uni-verse is composed {{of a number of}} autonomous and asynchronously communicating EVM machines. The main contribution of this work lies in the new model of computation and in the architecture itself: a novel, compact, flexible and expressive representation of distributed concurrent computation. The EVMA provides a way of expressing and modelling auto-catalytic networks composed of a hierarchical hypercycle of autopoietic subsystems characterised by self-adaptable structural tendencies and self-organised crit-icality. EVMA provides capabilities for: a) self-learning of dynamical patterns through continuous observation of computable environments, b) self-compacting and generalisa-tion of existing program structures, c) emergence of efficient and robust communication code through appropriate machine assembly on both ends of communication channel. EVMA is in one sense a multi-dimensional generalisation of stack machine with the pur-pose of modelling concurrent asynchronous processing. EVMA approach can be also seen as a meta-evolutionary theory of evolution. The EVMA is designed to model sys-tems that mimic living autonomous and adaptable computational processes. The EVMI prototype has been designed and developed to conduct experimental studies on complex evolving systems. The generality of our approach not only provides the means to experi-ment with complex hierarchical, computational and evolutionary systems, but it provides a useful model to evaluate, share and discuss the complex hierarchical systems in gen-eral. The EVMA provides a novel methodology and language to pursue research, to understand and to talk about evolution of complexity in living systems. In this thesis, we present the simple single-cell EVMI framework, discuss the multi-cell EVM Universe architecture, present experimental results, and propose further extensions, experimental studies, and possible hardware implementations of the EVMI. ii...|$|E
5000|$|The SECD {{machine is}} a highly {{influential}} virtual <b>machine</b> and <b>abstract</b> <b>machine</b> intended as a target for functional programming language compilers. The letters stand for Stack, Environment, Control, Dump, the internal registers of the machine. These registers point to linked lists in memory.|$|R
40|$|Typically, <b>abstract</b> <b>machines</b> may be nested, {{providing}} different {{services and}} levels of abstraction to different sets of users. Thus, the expectations of object-oriented programmers may differ markedly from those of C programmers, even though both may be targetting real-time applications. At a lower level, however, the <b>abstract</b> <b>machines</b> to support objects and C may be implemented in turn by a common <b>abstract</b> <b>machine.</b> The {{price to be paid}} for this kind of support is run-time performance. This paper describes CTDNet 2, an <b>abstract</b> <b>machine,</b> for parallel computer architectures aimed at the requirements of real-time...|$|R
40|$|We {{introduce}} {{our natural}} semantics-directed generator 2 BIG for compilers and <b>abstract</b> <b>machines.</b> It applies {{a sequence of}} transformations {{to a set of}} natural semantics rules including a pass separation transformation. Then we discuss how {{it can be used to}} generate a compiler and <b>abstract</b> <b>machine</b> for action notation. With the help of these components we can then generate compilers for other source languages whose semantics has been specified in Action Notation. We also briefly discuss the concept of an <b>abstract</b> <b>machine</b> language language based on the <b>abstract</b> <b>machine</b> generated for action notation. ...|$|R
40|$|ISBN: 3540603859 This paper gives {{operational}} semantics for {{a subset of}} VHDL in terms of <b>abstract</b> <b>machines.</b> Restrictions to the VHDL source code are the finiteness of data types, {{and the absence of}} quantitative timing informations. The <b>abstract</b> <b>machine</b> of a design unit is built by composition of the <b>abstract</b> <b>machines</b> for its embedded processes and blocks. The kernel process in our model is distributed among the composed machines. One transition of the final <b>abstract</b> <b>machine</b> models a VHDL delta cycle. This model can be used for symbolic model checking and equivalence verification...|$|R
40|$|In {{this paper}} we {{demonstrate}} {{how to use}} a semantics-directed generator to systematically design <b>abstract</b> <b>machines.</b> The main novelty of the generator is that it generates compilers and <b>abstract</b> <b>machines.</b> The generator is fully automated and its core transformations are proved correct. In this paper we propose a design methodology based on our generator and as an example we design a functional <b>abstract</b> <b>machine</b> which turns out to be very similar to the categorial <b>abstract</b> <b>machine.</b> c # 2000 Elsevier Science B. V. All rights reserved. Keywords: Abstract machines; Natural semantics; Compiler generation 1...|$|R
40|$|One {{method for}} {{producing}} verified implementations of programming languages is to formally derive them from <b>abstract</b> <b>machines.</b> Tail-recursive <b>abstract</b> <b>machines</b> provide e#cient support for iterative processes via the ordinary procedure call mechanism. This document {{argues that the}} use of tail-recursive <b>abstract</b> <b>machines</b> incurs only a small increase in theorem-proving burden when compared with what is required when using ordinary <b>abstract</b> <b>machines.</b> The position is supported by comparing correctness proofs performed using the BoyerMoore theorem prover. A by-product of this e#ort is a syntactic criterion based on tail contexts for identifying which procedure calls must be implemented as tail calls. The concept of tail contexts was used in the latest Scheme Report, the only language specification known to the author that defines the requirement that its implementations must be tail recursive. Keywords: tail recursion, tail call, SECD machine, CEK machine, verified implementati [...] ...|$|R
40|$|This paper {{presents}} an <b>abstract</b> <b>machine</b> for the stochastic bioambient calculus. The <b>abstract</b> <b>machine</b> is proved sound and complete {{with respect to}} a novel stochastic semantics, and is also shown to preserve the reduction probabilities of the calculus. The machine is implemented as an extension to an existing simulator for stochastic pi-calculus. Keywords: <b>abstract</b> <b>machine,</b> stochastic, bioambient calculus, correctness, implementation...|$|R
50|$|Abstract {{data types}} can be {{specified}} {{in terms of their}} operational semantics on an <b>abstract</b> <b>machine.</b> For example, a stack {{can be specified}} in terms of operations on an <b>abstract</b> <b>machine</b> with an array of memory. Through the use of <b>abstract</b> <b>machines</b> it is possible to compute the amount of resources (time, memory, etc.) necessary to perform a particular operation without having to construct a physical system.|$|R
40|$|This paper {{reports on}} the use of the Haskell QuickCheck library for testing the {{correctness}} of a simple functional compiler and <b>abstract</b> <b>machine.</b> We use QuickCheck to express the correctness of the <b>abstract</b> <b>machine</b> against a denotational semantics, to generate well-formed test programs This paper {{reports on the}} use the Haskell QuickCheck testing library [2] for verifying the implementation correctness of a simple functional language. The implementation consists of a syntaxdirected compiler and an interpreter for (a variant of) the well-known SECD <b>abstract</b> <b>machine</b> [5]. The denotational semantics, compiler and <b>abstract</b> <b>machine</b> are written in Haskell and correctnes...|$|R
40|$|AbstractA {{number of}} {{constituents}} of a methodology for the systematic design of <b>abstract</b> <b>machines</b> for logic programming languages are described. By means of partial deduction and other program transformation techniques, an interpreter {{and a source}} program are “compiled” into a new residual program consisting of: 1) “machine code” for the source program, and 2) an <b>abstract</b> <b>machine</b> for the machine code. Based upon the appearance of these, the user may choose to refine the original interpreter and repeat the process until the resulting “machine code” and the <b>abstract</b> <b>machine</b> satisfy the user's expectations of an <b>abstract</b> <b>machine.</b> We illustrate these principles by reconstructing several of the control instructions of Warren's <b>Abstract</b> <b>Machine.</b> The paper complements previous work of Kursawe, who reconstructed several of the unification instructions using similar techniques...|$|R
40|$|AbstractThe Pict {{programming}} language is an {{implementation of the}} π-calculus in which executions of π-calculus terms are specified via an <b>abstract</b> <b>machine.</b> An important property of any concurrent {{programming language}} implementation is the fair execution of threads. After defining fairness for the π-calculus, we show that Pict <b>abstract</b> <b>machine</b> executions implement fair π-calculus executions. We also give new proofs of soundness and liveness for the Pict <b>abstract</b> <b>machine...</b>|$|R
40|$|Living {{cells are}} {{extremely}} well-organized autonomous systems, consisting of discrete interacting components. Key to understanding and modelling their behavior is modelling their system organization, {{which can be}} described as a collection of distinct but interconnected <b>abstract</b> <b>machines.</b> Biologists have invented a number of notations attempting to describe, abstractly, these <b>abstract</b> <b>machines</b> and the processes that they implement. Systems biology aims to understand how these <b>abstract</b> <b>machines</b> work, separately and together...|$|R
40|$|Traditional {{native code}} {{generating}} Prolog compilers with global analysis compile programs {{as a whole}} and do not support the data base builtin-predicates assert and retract. In this paper we present a scheme to both enable global analysis and incremental compilation. This incremental compiler is based on the Vienna <b>Abstract</b> <b>Machine</b> (VAM). A version of the VAM, the VAM AI, is used as an <b>abstract</b> <b>machine</b> for <b>abstract</b> interpretation. The VAM AI does the data flow analysis by a factor of two hundred faster than the previous used meta interpreter written in Prolog. This fast execution together with a compact representation of the intermediate code makes incremental global compilation feasible. Preliminary results of intermediate code size, size of generated machine code, compile time and run time are presented. 1 Introduction The development of the Vienna <b>Abstract</b> <b>Machine</b> (VAM) started in 1985. The VAM has been developed {{as an alternative to the}} Warren <b>Abstract</b> <b>Machine</b> (WAM). The aim was [...] ...|$|R
40|$|A {{brief summary}} of the Hierarchical Development Methodology (HDM) is provided. The design of a system is {{decomposed}} into a hierarchy of <b>abstract</b> <b>machines,</b> linearly ordered with a different <b>abstract</b> <b>machine</b> at each level in the hierarchy. Each <b>abstract</b> <b>machine</b> in the hierarchy is dependent only on the functionality of lower level machines. The facilities of the highest level <b>abstract</b> <b>machine,</b> and only those of that machine, are visible to a user of the system. A machine is itself decomposed into modules, each module having operations and data structures which typically define a single abstract data concept. As in the Parnas module concept, the module is the programming unit of HDM; each of the modules may be independently implemented. The programs implementing a module can access the data structures of their own <b>abstract</b> <b>machine,</b> but not those of lower level machines...|$|R
40|$|In {{traditional}} compiler {{design the}} work of a compiler is divided into several phases: lexical, syntactical and semantical analysis, optimizations and code generation. For several of these phases generators exist [...] most prominently LEX and YACC for generating lexical and syntactical analyzers. A common feature of all generators is that the phase in the compiler is described using a meta-language (e. g. regular expressions or context-free grammars) and that the generator produces the related compiler module. There exist several good textbooks on compiler design. However, all of these books present ready made mappings from source language constructs to target language constructs, the so called translation schemes, instead of deriving them. Hence, the reader is expected to learn how to design code generators by analysing translation schemes as opposed to from first principles. The same is true for <b>abstract</b> <b>machines.</b> <b>Abstract</b> <b>machines</b> are virtual target architectures which support the concepts of the source language. Typically <b>abstract</b> <b>machines</b> are presented together with translation schemes from the source language to the <b>abstract</b> <b>machine</b> language. There is only little work on how translation schemes and <b>abstract</b> <b>machines</b> are designed. The aim of our work is to detect underlying principles that relate <b>abstract</b> <b>machines</b> to programming language semantics, and to automate part of the design process for <b>abstract</b> <b>machines.</b> Thus, we need to ensure that the behaviour of a source program will be maintained by translating it into the <b>abstract</b> <b>machine</b> language, and then applying the <b>abstract</b> <b>machine.</b> The behaviour of a program will depend on it 2 ̆ 7 s semantics. Often this aspect of a programming language is only described in natural language which is both ambiguous and vague. We shall use formal techniques to describe the meaning of programs in a particular language and to prove that our transformations are correct. In this thesis we concentrate on natural semantics, but we also address action semantics...|$|R
