55|0|Public
25|$|Some {{observers}} use {{the term}} <b>memory-safe</b> language (or just safe language) to describe languages that do not allow programs to access memory {{that has not been}} assigned for their use. For example, a <b>memory-safe</b> language will check array bounds, or else statically guarantee (i.e., at compile time before execution) that array accesses out of the array boundaries will cause compile-time and perhaps runtime errors.|$|E
25|$|In general, type-safety and memory-safety {{go hand in}} hand. For example, a {{language}} that supports pointer arithmetic and number-to-pointer conversions (like C) is neither <b>memory-safe</b> nor type-safe, because it allows arbitrary memory to be accessed {{as if it were}} valid memory of any type.|$|E
25|$|On 29 October 2015, the Tor Project {{released}} Tor Messenger Beta, {{an instant}} messaging program based on Instantbird with Tor and OTR built in {{and used by}} default. Like Pidgin and Adium, Tor Messenger supports multiple different instant messaging protocols; however, it accomplishes this without relying on libpurple, implementing all chat protocols in the <b>memory-safe</b> language JavaScript instead.|$|E
2500|$|In {{this example}} [...] will {{point to a}} memory address five {{characters}} beyond , equivalent to three characters after the terminating zero character of the string pointed to by [...] This is memory that the program {{is not expected to}} access. It may contain garbage data, and it certainly doesn't contain anything useful. As this example shows, C is neither a <b>memory-safe</b> nor a type-safe language.|$|E
2500|$|In this example, the {{variable}} [...] {{will have the}} value 42. Although {{this may not be}} what the programmer anticipated, it is a well-defined result. If [...] were a different string, one that could not be converted to a number (e.g. [...] "Hello World"), the result would be well-defined as well. Note that a program can be type-safe or <b>memory-safe</b> and still crash on an invalid operation; in fact, if a program encounters an operation that is not type-safe, terminating the program is often the only option.|$|E
50|$|Some {{observers}} use {{the term}} <b>memory-safe</b> language (or just safe language) to describe languages that do not allow programs to access memory {{that has not been}} assigned for their use. For example, a <b>memory-safe</b> language will check array bounds, or else statically guarantee (i.e., at compile time before execution) that array accesses out of the array boundaries will cause compile-time and perhaps runtime errors.|$|E
50|$|Fail-Safe C is an {{open-source}} <b>memory-safe</b> ANSI C compiler that performs {{bounds checking}} based on fat pointers and object-oriented memory access.|$|E
50|$|D's design goals {{attempt to}} combine the {{performance}} and safety of compiled languages with the expressive power of modern dynamic languages. Idiomatic D code is commonly as fast as equivalent C++ code, while being shorter and <b>memory-safe.</b>|$|E
50|$|In general, type-safety and memory-safety {{go hand in}} hand. For example, a {{language}} that supports pointer arithmetic and number-to-pointer conversions (like C) is neither <b>memory-safe</b> nor type-safe, because it allows arbitrary memory to be accessed {{as if it were}} valid memory of any type.|$|E
50|$|In October 2015 the Tor {{anonymity}} project presented Tor Messenger as its {{open source}} instant messenger client. It {{is based on}} Instandbird but removes the dependency on libpurple, re-implementing all supported chat protocols in the <b>memory-safe</b> language JavaScript. Tor Messenger encrypts one-to-one chats by default using OTR and provides anonymity by routing its traffic through the Tor network.|$|E
50|$|On 29 October 2015, the Tor Project {{released}} Tor Messenger Beta, {{an instant}} messaging program based on Instantbird with Tor and OTR built in {{and used by}} default. Like Pidgin and Adium, Tor Messenger supports multiple different instant messaging protocols; however, it accomplishes this without relying on libpurple, implementing all chat protocols in the <b>memory-safe</b> language JavaScript instead.|$|E
50|$|Memory {{safety is}} the state of being {{protected}} from various software bugs and security vulnerabilities when dealing with memory access, such as buffer overflows and dangling pointers. For example, Java is said to be <b>memory-safe</b> because its runtime error detection checks array bounds and pointer dereferences. In contrast, C and C++ support arbitrary pointer arithmetic, with no provision for bounds checking, and thus are termed memory-unsafe.|$|E
5000|$|In {{this example}} [...] will {{point to a}} memory address five {{characters}} beyond , equivalent to three characters after the terminating zero character of the string pointed to by [...] This is memory that the program {{is not expected to}} access. It may contain garbage data, and it certainly doesn't contain anything useful. As this example shows, C is neither a <b>memory-safe</b> nor a type-safe language.|$|E
5000|$|In this example, the {{variable}} [...] {{will have the}} value 42. Although {{this may not be}} what the programmer anticipated, it is a well-defined result. If [...] were a different string, one that could not be converted to a number (e.g. [...] "Hello World"), the result would be well-defined as well. Note that a program can be type-safe or <b>memory-safe</b> and still crash on an invalid operation; in fact, if a program encounters an operation that is not type-safe, terminating the program is often the only option.|$|E
50|$|Type {{safety is}} {{closely linked to}} memory safety, a {{restriction}} {{on the ability to}} copy arbitrary bit patterns from one memory location to another. For instance, in an implementation of a language that has some type , such that some sequence of bits (of the appropriate length) does not represent a legitimate member of , if that language allows data to be copied into a variable of type , then it is not type-safe because such an operation might assign a non- value to that variable. Conversely, if the language is type-unsafe to the extent of allowing an arbitrary integer {{to be used as a}} pointer, then it is not <b>memory-safe.</b>|$|E
5000|$|River Trail was {{announced}} at the Intel Developer Forum in September 2011, and demonstrated using a Firefox extension developed by Intel. Brendan Eich, the original author of JavaScript, promised that he would promote River Trail within Ecma International, saying [...] "The demo shows a 15x speedup over serial JavaScript. It lights up the ridiculously parallel hardware in modern CPUs and GPUs, for audio, video, image processing, automated voice response, computer vision, 3D gaming, etc. - all written in <b>memory-safe,</b> clean, functional JavaScript, without threads and their data races and deadlocks." [...] Because River Trail leverages Intel's OpenCL SDK [...] it can exploit multiple CPU cores as well as data parallel instructions (ex. AVX, SSE) and the speedup can be greater than the CPU core count would imply.|$|E
50|$|Because {{of their}} complexity, a holy grail of {{software}} verification {{has been to}} verify properties of operating systems. Operating systems are usually written in low-level languages, such as C, that provide very few guarantees. The Singularity project took the approach of writing an operating system in C#, a type-safe, <b>memory-safe</b> language. A weakness {{of this approach is}} that operating systems necessarily need to call lower-level code to, for instance, move the stack pointer. Verve addresses this problem by partitioning the operating system into verified assembly that is required to be low-level and a trusted interface to rest of the operating system, written in C#. There is a trusted specification that guarantees the low-level assembly code does not mess with the heap and that the high-level C# code does not mess with the stacks.|$|E
5000|$|This {{extended}} {{lambda calculus}} {{was intended to}} serve as a provably <b>memory-safe</b> intermediate representation for compiling Standard ML programs into machine code, but building a translator that would produce good results on large programs faced a number of practical limitations which had to be resolved with new analyses, including dealing with recursive calls, tail recursive calls, and eliminating regions which contained only a single value. This work was completed in 1995 and integrated into the ML Kit, a version of ML based on region allocation in place of garbage collection. This permitted a direct comparison between the two on medium-sized test programs, yielding widely varying results ("between 10 times faster and four times slower") depending on how [...] "region-friendly" [...] the program was; compile times, however, were on the order of minutes. The ML Kit was eventually scaled to large applications with two additions: a scheme for separate compilation of modules, and a hybrid technique combining region inference with tracing garbage collection.|$|E
40|$|We {{describe}} an {{implementation of a}} media streaming network service written in O’Caml, a <b>memory-safe,</b> typed functional programming lan-guage. First, we introduce Internet streaming paradigms and then attempt to document some of the popular non-proprietary streaming proto-cols. We also present a server design and specu-late other design possibilities...|$|E
40|$|We {{propose a}} new <b>memory-safe</b> {{interpretation}} of the C ab-stract machine that provides stronger protection to benefit security and debugging. Despite ambiguities in the specifi-cation intended to provide implementation flexibility, con-temporary implementations of C have converged on a mem-ory model similar to the PDP- 11, the original target for C. This model lacks support for memory safety despite well-documented impacts on security and reliability. Attempts to change this model are often hampered by as-sumptions embedded in {{a large body of}} existing C code, dat-ing back to the memory model exposed by the original C compiler for the PDP- 11. Our experience with attempting to implement a <b>memory-safe</b> variant of C on the CHERI ex-perimental microprocessor led us to identify a number of problematic idioms. We describe these as well as their in-teraction with existing memory safety schemes and the as-sumptions that they make beyond the requirements of the C model for C, by combining elements of the CHERI capabil-ity model and fat pointers, and present a softcore CPU that implements a C abstract machine that can run legacy C code with strong memory protection guarantees. 1...|$|E
40|$|The C {{language}} definition {{leaves the}} sizes and layouts of types partially unspecified. When a C program makes assumptions about type layout, its semantics is defined only on platforms (C compilers {{and the underlying}} hardware) on which those assumptions hold. Previous work on formalizing C-like languages has ignored this issue, either by assuming that programs do not make such assumptions or by assuming that all valid programs target only one platform. In the latter case, the platform’s choices are hard-wired in the language semantics. In this paper, we present a practically-motivated model for a C-like language in which the memory layouts of types are left largely unspecified. The dynamic semantics is parameterized by a platform’s layout policy and makes manifest the consequence of platform-dependent (i. e., unspecified) steps. A type-and-effect system produces a layout constraint: a logic formula encoding layout conditions under which the program is <b>memory-safe.</b> We prove that if a program type-checks, it is <b>memory-safe</b> on all platforms satisfying its constraint. Based on our theory, we have implemented a tool that discovers unportable layout assumptions in C programs. Our approach should generalize to other kinds of platform-dependent assumptions...|$|E
40|$|The {{need for}} direct memory {{manipulation}} through pointers {{is essential in}} many applications. However, it is also commonly understood that the use (or probably misuse) of pointers is a rich source for program errors. In this paper, we design and then formalize a type system that can effectively prevent dangling pointers from being ever accessed during the evaluation of a well-type program. In particular, we present an approach that makes novel use of linear types {{in support of the}} construction of <b>memory-safe</b> programs while allowing explicit pointer manipulation such as pointer arithmetic...|$|E
40|$|We {{present a}} theory {{describing}} implementation-dependent assumptions that a C program might make, {{such as the}} size and alignment of data. We define a static analysis to encode such assumptions in a constraint that describes language implementations (i. e., compilers and architectures) on which a program is <b>memory-safe.</b> The constraint produced by the analysis is a formula in a theory of first-order logic for which implementations are models. By defining an abstract machine that is parameterized by an implementation, we can prove the analysis sound. This foundation explains some common coding practices and the poorly understood assumptions they are implicitly making...|$|E
40|$|It is {{well known}} that the use of points-to {{information}} can substantially improve the accuracy of a static program analysis. Commonly used algorithms for computing points-to information are known to be sound only for <b>memory-safe</b> programs. Thus, it appears problematic to utilize points-to information to verify the memory safety property without giving up soundness. We show that a sound combination is possible, even if the points-to information is computed separately and only conditionally sound. This result is based on a refined statement of the soundness conditions of points-to analyses and a general mechanism for composing conditionally sound analyses...|$|E
40|$|Given the {{widespread}} use of <b>memory-safe</b> languages, students must understand garbage collection well. Following a constructivist philosophy, an effective approach would be to have them implement garbage collectors. Unfortunately, a full implementation depends on substantial knowledge of compilers and runtime systems, which many courses do not cover or cannot assume. This paper presents an instructive approach to teaching gc, where students implement it atop a simplified stack and heap. Our approach eliminates enormous curricular dependencies while preserving the essence of gc algorithms. We take pains to enable testability, comprehensibility, and facilitates debugging. Our approach has been successfully classroom-tested for several years at several institutions...|$|E
40|$|Abstract. This paper {{presents}} a new synthesis-based approach for writ-ing low-level <b>memory-safe</b> code. Given a partial program with missing guards, our algorithm synthesizes concrete predicates {{to plug in}} for the missing guards such that all buffer accesses in the program are memory safe. Furthermore, guards synthesized by our technique are the simplest and weakest among guards that guarantee memory safety, relative to the inferred loop invariants. Our approach is fully automatic and does not require any hints from the user. We have implemented our algorithm in a prototype synthesis tool for C programs, and we show that the proposed approach is able to successfully synthesize guards that closely match hand-written programmer code {{in a set of}} real-world C programs. ...|$|E
40|$|This {{paper is}} {{centered}} around {{the design of a}} thread- and <b>memory-safe</b> language, primarily for the compilation of application-specific services for extensible operating systems. We describe various issues that have influenced the design of our language, called Cuckoo, that guarantees safety of programs with potentially asynchronous flows of control. Comparisons are drawn between Cuckoo and related software safety techniques, including Cyclone and software-based fault isolation (SFI), and performance results suggest our prototype compiler is capable of generating safe code that executes with low runtime overheads, even without potential code optimizations. Compared to Cyclone, Cuckoo is able to safely guard accesses to memory when programs are multithreaded. Similarly, Cuckoo is capable of enforcing memory safety in situations that are potentially troublesome for techniques such as SFI...|$|E
40|$|The lack {{of memory}} safety in many popular {{programming}} languages, including C and C++, has been a cause for great concern {{in the realm of}} software reliability, verification, and more recently, system security. Despite their limitations, the flexibility, performance, and ease of use of these languages have made them the choice of most embedded software developers. Researchers have proposed various techniques to enhance programs for memory safety; however, they are all subject to severe performance penalties, making their use impractical in most scenarios. In this paper, we present architectural enhancements to enable efficient, <b>memory-safe</b> execution of software on embedded processors. The key insight behind our approach is to extend embedded processors with hardware that significantly accelerates the execution of th...|$|E
40|$|We {{propose a}} new <b>memory-safe</b> {{interpretation}} of the C abstract machine that provides stronger protection to benefit security and debugging. Despite ambiguities in the specification intended to provide implementation flexibility, contemporary implementations of C have converged on a memory model similar to the PDP- 11, the original target for C. This model lacks support for memory safety despite well documented impacts on security and reliability. Attempts to change this model are often hampered by assumptions embedded in {{a large body of}} existing C code, dating back to the memory model exposed by the original C compiler for the PDP- 11. Our experience with attempting to implement a <b>memory-safe</b> variant of C on the CHERI experimental microprocessor led us to identify a number of problematic idioms. We describe these as well as their interaction with existing memory safety schemes and the assumptions that they make beyond the requirements of the C specification. Finally, we refine the CHERI ISA and abstract model for C, by combining elements of the CHERI capability model and fat pointers, and present a softcore CPU that implements a C abstract machine that can run legacy C code with strong memory protection guarantees. This work is part of the CTSRD and MRC 2 projects that are sponsored by the Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL), under contracts FA 8750 - 10 -C- 0237 and FA 8750 - 11 -C- 0249. The views, opinions, and/or findings contained in this paper {{are those of the authors}} and should not be interpreted as representing the official views or policies, either expressed or implied, of the Department of Defense or the U. S. Government. We gratefully acknowledge Google, Inc. for its sponsorship...|$|E
40|$|Many popular {{systems for}} {{processing}} “big data ” are im-plemented in high-level programming languages with automatic memory management via garbage collection (GC). However, high object churn and large heap sizes put severe {{strain on the}} garbage collector. As a result, ap-plications underperform significantly: GC increases the runtime of typical data processing tasks by up to 40 %. We propose to use region-based memory management instead of GC in distributed data processing systems. In these systems, many objects have clearly defined life-times. Hence, it is natural to allocate these objects in fate-sharing regions, obviating the need to scan a large heap. Regions can be <b>memory-safe</b> and could be in-ferred automatically. Our initial results show that region-based memory management reduces emulated Naiad ver-tex runtime by 34 % for typical data analytics jobs. ...|$|E
40|$|Real-time {{embedded}} systems {{come in all}} shapes and sizes with vastly different capabilities. They often operate under stringent resource constraints, ranging from space and time to power. Programming them is usually done in low-level system’s programming languages close to the hardware. The resulting software is costly and not particularly portable. The Java programming language has been successful in providing a virtualized, high-level, development environment for desktop and server applications. Programming in Java leads to <b>memory-safe</b> code that can be ported straightforwardly across architecture and operating system. This paper surveys the state of the art in Java virtualization for real-time and {{embedded systems}}. Technological advances in virtual machines as well as new real-time extensions to the language have brought Java closer to being widely usable for a wide range of embedded problems. 1...|$|E
40|$|Abstract. Writing {{code that}} manipulates bit streams is a painful and {{error-prone}} programming task, often performed via bit twiddling {{techniques such as}} explicit bit shifts and bit masks in programmer-allocated buffers. Still, this kind of programming is necessary in many application areas ranging from decoding streaming media files to implementing network protocols. In this paper we employ highlevel constructs from declarative programming, such as pattern matching at the bit level and bit stream comprehensions, and show how a variety of bit stream programming applications can be written in a succinct, less error-prone, and totally <b>memory-safe</b> manner. We also describe how these constructs can be implemented efficiently. The resulting performance is superior {{to that of other}} (purely) functional languages and competitive to that of low-level languages such as C. ...|$|E
40|$|Writing {{code that}} manipulates bit streams is a painful and errorprone {{programming}} task, currently often performed via bit twiddling {{techniques such as}} explicit bit shifts and bit masks in programmer-allocated buffers. Still, this kind of programming is necessary in many application areas ranging from decoding streaming media files to implementing network protocols. In this paper we show how high-level constructs from functional programming, such as binary pattern matching at the bit level and binary comprehensions, can make bit stream manipulation more succinct, less error-prone, and totally <b>memory-safe.</b> We formally define these language constructs, show a variety of example uses from several different application areas, and describe their implementation in detail. We hold that a binary data structure {{with the ability to}} perform pattern matching at the bit level allows (purely) functional languages to significantly expand the range of their practical uses. 1...|$|E
40|$|Abstract. Network latency is {{a problem}} for all cloud services. It can be mitigated by moving {{computation}} out of remote datacenters by rapidly instantiating local ser-vices near the user. This requires an embedded cloud platform on which to deploy multiple applications se-curely and quickly. We present Jitsu, a new Xen tool-stack that satisfies the demands of secure multi-tenant isolation on resource-constrained embedded ARM de-vices. It does this by using unikernels: lightweight, compact, single address space, <b>memory-safe</b> virtual ma-chines (VMs) written in a high-level language. Using fast shared memory channels, Jitsu provides a directory service that launches unikernels in response to network traffic and masks boot latency. Our evaluation shows Jitsu to be a power-efficient and responsive platform for hosting cloud services in the edge network while preserv-ing the strong isolation guarantees of a type- 1 hypervisor. ...|$|E
40|$|Purely {{functional}} languages [...] with static type {{systems and}} dynamic memory management using garbage collection [...] are a known tool for helping programmers {{to reduce the}} number of memory errors in programs. By using such languages, we can establish correctness properties relating to memory-safety through our choice of implementation language alone. Unfortunately, the language characteristics that make purely functional languages safe also make them more difficult to apply in a low-level domain like operating systems construction. The low-level features that support the kinds of hardware manipulations required by operating systems are not typically available in <b>memory-safe</b> languages with garbage collection. Those that are provided may have the ability to violate memory- and type-safety, destroying the guarantees that motivate using such languages in the first place. This work demonstrates that it is possible to bridge the gap between the requirements of operating system implementations and the features of purely functional languages without sacrificing type- and memory-safety. In particular, we show that this can be achieved by isolating the potentially unsafe memory operations required by operating systems in an abstraction layer that is well integrated with a purely functional language. The salient features of this abstraction layer are that the operations it exposes are <b>memory-safe</b> and yet sufficiently expressive to support the implementation of realistic operating systems. The abstraction layer enables systems programmers to perform all of the low-level tasks necessary in an OS implementation, such as manipulating an MMU and executing user-level programs, without compromising the static memory-safety guarantees of programming in a purely functional language. A specific contribution of this work is an analysis of memory-safety for the abstraction layer by formalizing a meaning for memory-safety in the presence of virtual-memory using a novel application of noninterference security policies. In addition, we evaluate the expressiveness of the abstraction layer by implementing the L 4 microkernel API, which has a flexible set of virtual memory management operations...|$|E
40|$|We {{consider}} {{the design of}} C++ classes for abstract data types that are useful in scientific computing, such as vectors and matrices that appear and disappear dynamically, have varying sizes, may be sparse, and that respond to the natural arithmetic operators. These classes should be <b>memory-safe,</b> {{in the sense that}} all dynamically allocated memory is automatically released when no longer needed, and copy-efficient in the sense that no data should be unnecessarily copied when objects are passed to or from functions and operators. A framework for designing such classes is developed. We introduce as a simple example the case of a dynamic array of numbers. We then expand this framework to more general container classes, exemplified by a dynamic array with elements of any type by use of a template. The design of C++ and possible extensions to the language are discussed informally along the way. ...|$|E
