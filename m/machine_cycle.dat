107|316|Public
25|$|The basic <b>machine</b> <b>cycle</b> was 200 microseconds (20 {{cycles of}} the 100kHz {{clock in the}} cycling unit), or 5,000 cycles per second for {{operations}} on the 10-digit numbers. In one of these cycles, ENIAC could write a number to a register, read a number from a register, or add/subtract two numbers.|$|E
2500|$|Undergarments {{are known}} {{by a number}} of terms. , underclothing [...] and [...] are formal terms, while {{undergarments}} may be more casually called, in Australia, [...] (rhyming slang for undies) and Reginalds, and, in the United Kingdom, [...] (from the earlier smallclothes) and (historically) unmentionables. In the United States, women's underwear may be known as delicates due to the recommended washing <b>machine</b> <b>cycle</b> or because they are, simply put, delicate.|$|E
50|$|Program steps execute in one <b>machine</b> <b>cycle,</b> {{except for}} steps {{performing}} multiplication or division which take as many machine cycles as {{needed for the}} operation. Punching rate is roughly four columns per <b>machine</b> <b>cycle.</b> The total number of machine cycles required per card varies depending on the data and programming.|$|E
50|$|Mandatory Breath is {{a breath}} type during {{mechanical}} ventilation for which inspiration is machine triggered and/or <b>machine</b> <b>cycled.</b>|$|R
40|$|AbstractAmong several {{strategies}} for high performance cutting, trochoidal milling is an efficient one for roughing process {{and reduces the}} cycle times significantly. For maximization of the efficiency and reducing the <b>machining</b> <b>cycle</b> time in the trochoidal milling, a novel tool path strategy, so- called, epicycloidal milling is developed. In this paper, mathematical model of the epicycloidal milling is presented. For the two mentioned strategies, comparison between cutting forces, tool tip vibrations, and <b>machining</b> <b>cycle</b> times are performed by four levels of machining experiments. To calculate the tool tip vibration, modal parameters of machine tool are achieved by system identification and then dynamic models of the machine spindle has been developed. It is observed that epicycloidal milling can improve <b>machining</b> <b>cycle</b> time, while the measured forces and calculated vibrations increased slightly...|$|R
40|$|Language-supported {{synchronization}} is {{a source}} of serious performance problems in Java programs. Even for single threaded programs the overhead of synchronization in com-piled Java can be as high as 45 %. I address this problem with a new language-level locking algorithm suitable for both uniprocessor and multiprocessor environments. On a Pen-tium uniprocessor, in the most common case the lock-and-unlock overhead for a Java synchronized method is a mere 6 <b>machine</b> <b>cycles</b> when a synchronous thread scheduler is used, or 15 <b>machine</b> <b>cycles</b> when an asynchronous thread scheduler is used. ...|$|R
5000|$|Real-world example: FI 30-min = a 30-minute washing <b>machine</b> <b>cycle.</b>|$|E
5000|$|A <b>machine</b> <b>cycle</b> time of 26 nanoseconds (38 MHz {{equivalent}} CPU) ...|$|E
50|$|Many {{applications}} using {{unit record}} tabulators were migrated to computers {{such as the}} IBM 1401. Two programming languages, FARGO and RPG, were created to aid this migration. Since tabulator control panels {{were based on the}} <b>machine</b> <b>cycle,</b> both FARGO and RPG emulated the notion of the <b>machine</b> <b>cycle</b> and training material showed the control panel vs. programming language coding sheet relationships.|$|E
50|$|Developers should value {{developer}} {{time over}} machine time, because <b>machine</b> <b>cycles</b> today are relatively inexpensive compared to {{prices in the}} 1970s. This rule aims to reduce development costs of projects.|$|R
2500|$|Every {{breath is}} volume cycled, {{which is a}} form of machine cycling. Any breath for which {{inspiration}} is <b>machine</b> <b>cycled</b> is classified as a mandatory breath. Hence, the breath sequence is continuous mandatory ventilation.|$|R
40|$|AbstractThis paper {{presents}} an increasing demand of Top-Spinning (T-S) {{has resulted in}} the production of high quantity of T-S. Currently, the production of T-S is very low and not up to the required demand. This is due to the old machine used as well as an old method in the manufacturing of T-S, which lead to the longer time taken compared to the new technology found in this project. The cardinal purpose of this project is to identify the machining sequence with the selection of a suitable tool and reducing <b>machining</b> <b>cycle</b> time with the use of CNC Lathe for manufacturing T-S. In ensuring a successful and optimum result of the project, manufacturing T-S with CNC Lathe will be assisted by Mathematisch Technishe software Entwicklung (MTS) and Master CAM simulation to determine machining sequence, cutting tools, technology parameters and <b>machining</b> <b>cycle</b> time. The data extracted from MTS, and CAD/CAM simulation process will then be used for manufacturing T-S on CNC Lathe technology. This project emphasizes on the importance of determining machining sequence, cutting tools to manufacture T-S in any shape available and also resolving <b>machining</b> <b>cycle</b> time. The result from MTS and CAD/CAM with three analyses of machining sequence, cutting tool and technology parameters will be used to proceed on CNC Lathe. Finally, with the utilization of the data extracted from MTS software, and CAD/CAM simulation has successfully impacted the reduction on overall <b>machining</b> <b>cycle</b> time while producing T-S...|$|R
5000|$|The KDP10 in {{the service}} bureau was updated in situ, as the system was built with RCA {{germanium}} transistors. Part of the update was to convert the main logic with to silicon transitors. There was also a three character address adder added, and the <b>machine</b> <b>cycle</b> was 15 microseconds, with six timing pulese, where sixth pulse was for settling time, thus the <b>machine</b> <b>cycle</b> was reduced to 12.5 microseconds.|$|E
50|$|It has a <b>machine</b> <b>cycle</b> {{of up to}} 2M cycles per second, {{but most}} {{versions}} seem to be overclockable to up to 2.8M cycles per second (28 MHz clock).|$|E
50|$|When {{used in the}} {{saturated}} mode {{in digital}} logic, they latch in the on-state, making it necessary to remove power {{for a short time}} in each <b>machine</b> <b>cycle</b> to return them to the off-state.|$|E
50|$|The Z80 <b>machine</b> <b>cycles</b> are sequenced by an {{internal}} state machine which builds each M-cycle out of 3, 4, 5 or 6 T-cycles depending on context. This avoids cumbersome asynchronous logic {{and makes the}} control signals behave consistently at {{a wide range of}} clock frequencies. It also means that a higher frequency crystal must be used than without this subdivision of <b>machine</b> <b>cycles</b> (approximately 2-3 times higher). It does not imply tighter requirements on memory access times, since a high resolution clock allows more precise control of memory timings and so memory can be active in parallel with the CPU to a greater extent, allowing more efficient use of available memory bandwidth.|$|R
40|$|This paper {{presents}} {{a novel approach}} to a problem of the design feature library elaboration. As a tool of the design feature library development CNC <b>machining</b> <b>cycles</b> were proposed. Because of the great number of commercially available CNC machine controllers, with different CNC <b>machining</b> <b>cycles</b> definitions, {{it was necessary to}} make a decision about a research methodological framework, it is the selected CNC machine controller. Taking into account the criterion of popularity as the research framework the selected group of Sinumerik CNC machine controllers was chosen. Presented in the paper idea of the feature library development is based on an assumption saying that it is possible to find a relationship between a particular CNC <b>machining</b> <b>cycle</b> and the simple design feature or even compound design features. Identified, thanks to this assumption, set of the design features could be the base for elaboration of the design feature library. This solution, it is the feature library next gave opportunity for elaboration of the feature based design modelling module (FBDMM) working in the SIEMENS NX system environment. Hence, the FBDMM module can support both a designer and CNC machine programmer which is possible due to received in the module modelling paradigm. In FBDMM module the removal feature based modelling technique is received...|$|R
30|$|In this section, we {{describe}} {{the implementation of the}} operations S, Cb, and Ci to obtain the respective number of <b>machine</b> <b>cycles</b> based on simulations of the TMS 320 C 55 xx DSP from Texas Instruments. This device belongs to a family of well-known 16 -bit fixed-point low-power consumption DSPs suited for telecommunication applications that require low power, low system cost, and high performance [17]. More details about this processor can be found in [18, 19]. We work with the integrated development environment (IDE) Code Composer Studio (CCStudio) version 4.1. 1.00014 [19]. The simulations are conducted with the C 55 xx Rev 2.x CPU Accurate Simulator. Once the number of <b>machine</b> <b>cycles</b> of each operation is obtained, we utilize (12) to have the computational complexity measure for a trellis module for this particular architecture.|$|R
50|$|Modern 8051 cores are {{faster than}} earlier {{packaged}} versions. Design improvements have increased 8051 performance while retaining compatibility {{with the original}} MCS 51 instruction set. The original Intel 8051 ran at 12 clock cycles per <b>machine</b> <b>cycle,</b> and most instructions executed {{in one or two}} machine cycles. A typical maximum clock frequency of 12 MHz meant these old 8051s could execute one million single-cycle instructions, or 500,000 two-cycle instructions, per second. In contrast, enhanced 8051 silicon IP cores now run at one clock cycle per <b>machine</b> <b>cycle,</b> and have clock frequencies of up to 450 MHz. That means an 8051-compatible processor can now execute 450 million instructions per second.|$|E
50|$|A superscalar {{processor}} usually sustains {{an execution}} rate {{in excess of}} one instruction per <b>machine</b> <b>cycle.</b> But merely processing multiple instructions concurrently does not make an architecture superscalar, since pipelined, multiprocessor or multi-core architectures also achieve that, but with different methods.|$|E
50|$|The basic <b>machine</b> <b>cycle</b> was 200 microseconds (20 {{cycles of}} the 100 kHz {{clock in the}} cycling unit), or 5,000 cycles per second for {{operations}} on the 10-digit numbers. In one of these cycles, ENIAC could write a number to a register, read a number from a register, or add/subtract two numbers.|$|E
50|$|The VIS ran on 5.626 MHz for a PAL and 5.67 MHz for an NTSC machine. This {{frequency}} {{was divided}} by 2 and output via CPUCLK (pin 38) to the CDP 1802 for {{timing of the}} CPU (2.813 and 2.835 MHz). The VIS was also responsible for {{the timing of the}} interrupt (50/60 Hz)S and timing of the non display period via PREDISPLAY (pin 1). Video memory could only be accessed during the non display period which allowed for execution of 2160 <b>machine</b> <b>cycles</b> on a PAL and 1574 on an NTSC machine. Provided that not more instructions were executed than the indicated maximum number of <b>machine</b> <b>cycles</b> video memory could be accessed during the interrupt routine. Alternatively the program could be paused by waiting for a non display period by checking EF1.|$|R
30|$|The bit {{comparison}} operation Cb is implemented with a bitwise logical XOR instruction, assuming that each {{bit of the}} received word has been previously stored in an integer type variable. Table 6 shows {{the details of the}} implementation of this operation. Similarly, three <b>machine</b> <b>cycles</b> are necessary to implement the operation Cb.|$|R
50|$|Each {{instruction}} is executed in steps {{that are usually}} termed <b>machine</b> <b>cycles</b> (M-cycles), each of which can take between three and six clock periods (T-cycles). Each M-cycle corresponds roughly to one memory access and/or internal operation. Many instructions actually end during the M1 of the next instruction which {{is known as a}} fetch/execute overlap.|$|R
50|$|The IBM 7700 was an 18-bit system, with {{instructions}} occupying two 18-bit words. Arithmetic instructions generally executed {{in two or}} three machine cycles, except for multiply, about 8 cycles, and divide, 12 cycles. A <b>machine</b> <b>cycle</b> was two microseconds. Address space was 262,144 words, but the two machines known to have been built had 16,384, 32,768 or 49,152 words.|$|E
50|$|In the F8 {{the control}} bus regulates {{the use of}} the data bus through the use of timing signals and state controls. The phi clock divides the <b>machine</b> <b>cycle</b> into {{discrete}} phases depending on the instruction being executed. The five state control lines are a function of the instruction being executed. The control bus states regulate the control of information in the computer.|$|E
50|$|Clock cycle {{efficiency}} is poor {{in comparison to}} most 8-bit microprocessors. Eight clock cycles makes up one <b>machine</b> <b>cycle.</b> Most instructions take two machine cycles (16 clock cycles) to execute; the remaining instructions take three machine cycles (24 clock cycles). By comparison, the MOS Technology 6502 takes two to seven clock cycles to execute an instruction, and the Intel 8080 takes four to 18 clock cycles.|$|E
40|$|Language-supported {{synchronization}} is {{a source}} of serious performance problems in Java programs. Even for single threaded programs the overhead of synchronization in compiled Java can be as high as 45 %. I address this problem with a new language-level locking algorithm suitable for both uniprocessor and multiprocessor environments. On a Pentium uniprocessor, in the most common case the lock-andunlock overhead for a Java synchronized method is a mere 6 <b>machine</b> <b>cycles</b> when a synchronous thread scheduler is used, or 15 <b>machine</b> <b>cycles</b> when an asynchronous thread scheduler is used. 1 Introduction Monitors [6] are a language-level construct for providing mutually exclusive access to shared data structures in a multi-threaded environment. However, the overhead required by the necessary locking has generally restricted their use to relatively "heavy-weight" objects. Recently, their incorporation in Java [4] has led to renewed interest in monitors, because of both their prevalence and their [...] ...|$|R
30|$|The {{operation}} Ci {{is implemented}} with an if-else statement, {{which includes the}} storage of the lowest accumulated edge metric. Table 7 shows how this operation is implemented. The if statement is used to compare two accumulated edge metrics, and the lowest one is stored at the integer type variable minor. In the third column, AR 1 and AR 2 are accumulator registers loaded with the accumulated metrics values, represented here by the variables B and A, respectively. Next, the metrics are compared; if B<A, then status bit TC 1 is set, and the program flow is deviated to the label specified by @L 1, where the value of B is stored at minor. Following this path, the code consumes 10 (= 1 + 1 + 1 + 6 + 1) <b>machine</b> <b>cycles.</b> Otherwise, if A≤B, then the value of A is stored in minor, and the program flow is deviated to the label specified by @L 2, where the next instruction to be executed is located. The architecture of this processor cannot transfer the value stored at AR 2 directly to memory. Instead, it copies the AR 2 value to AR 1 {{and then to the}} memory. Following this path, the code consumes 16 (= 1 + 1 + 1 + 5 + 1 + 1 + 6) <b>machine</b> <b>cycles.</b> We consider the average value consumed by the operation, i.e., 13 <b>machine</b> <b>cycles.</b>|$|R
50|$|The MAC-16 (or LEC-16) was a 16-bit {{minicomputer}} {{introduced in}} 1966 by Lockheed Electronics. One main selling {{point of the}} MAC-16 was a dedicated context switching system that completed operations in two <b>machine</b> <b>cycles.</b> Several improved versions were introduced, including the MAC Jr., Sue, and System III, but the company dropped support {{for all of these}} in the late 1970s.|$|R
50|$|Tab machine {{technicians}} {{were accustomed}} to plugging wires into control panels to implement input, output, control and counter operations (add, subtract, multiply, divide). Tab machines programs were executed by impulses emitted in a machine cycle; hence, FARGO and RPG emulated {{the notion of the}} <b>machine</b> <b>cycle</b> with the program cycle. RPG was superior to and rapidly replaced FARGO as the report generator program of choice.|$|E
5000|$|Undergarments {{are known}} {{by a number}} of terms. , underclothing and [...] are formal terms, while {{undergarments}} may be more casually called, in Australia, [...] (rhyming slang for undies) and Reginalds, and, in the United Kingdom, [...] (from the earlier smallclothes) and (historically) unmentionables. In the United States, women's underwear may be known as delicates due to the recommended washing <b>machine</b> <b>cycle</b> or because they are, simply put, delicate.|$|E
50|$|MCS-51 based {{microcontrollers}} typically {{include one}} or two UARTs, two or three timers, 128 or 256 bytes of internal data RAM (16 bytes of which are bit-addressable), up to 128 bytes of I/O, 512 bytes to 64 KB of internal program memory, and sometimes a quantity of extended data RAM (ERAM) located in the external data space. External RAM and ROM share the data and address buses. The original 8051 core ran at 12 clock cycles per <b>machine</b> <b>cycle,</b> with most instructions executing in {{one or two}} machine cycles. With a 12 MHz clock frequency, the 8051 could thus execute 1 million one-cycle instructions per second or 500,000 two-cycle instructions per second. Enhanced 8051 cores are now commonly used which run at six, four, two, or even one clock per <b>machine</b> <b>cycle,</b> and have clock frequencies of up to 100 MHz, and are thus capable of an even greater number of instructions per second. All Silicon Labs, some Dallas and a few Atmel devices have single cycle cores.|$|E
40|$|Abstract — In this paper, {{we design}} and {{implement}} an improved hardware-based evolutionary digital filter (EDF) version 2. The EDF is an adaptive digital filter which {{is controlled by}} adaptive algorithm based on evolutionary computation. The hardware-based EDF version 1 consists of two submodules, that is, a filter-ing and fitness calculation (FFC) module and a reproduction and selection (RS) module. The FFC module has high computational ability to calculate the output and the fitness value since its submodules run in parallel. However, hardware size of the FFC module is large, and many <b>machine</b> <b>cycles</b> are needed. Thus, in the hardware-based EDF version 2, we combine the two modules to reduce its hardware size and <b>machine</b> <b>cycles.</b> A synthesis result on the FPGA shows the clock frequency is 65. 5 MHz and the maximum sampling rate of the hardware-based EDF version 2 is 4, 948. 1 Hz. Moreover, the hardware-based EDF version 2 is 15. 7 {{times faster than the}} hardware-based EDF version 1. I...|$|R
40|$|Because {{computation}} {{speed and}} memory size are both increasing, the latency of memory, in basic <b>machine</b> <b>cycles,</b> is also increasing. As a result, recent compiler {{research has focused}} on reducing the effective latency by restructuring programs to take more advantage of high-speed intermediate memory (or cache, as it is usually called). The problem is that many real-world programs are non-trivial to restructure, and current methods will often fail. In this paper, we present some encouraging preliminary results of a project to determine how much restructuring is possible with automatic techniques. 1. Introduction. Over the past decade we have seen dramatic reductions in the cycle times of microprocessors, while memories for the same processors have been growing in size. These two trends have yielded computer systems in which memory latency is quite large in terms of basic <b>machine</b> <b>cycles</b> [...] -latencies of 10 to 20 cycles are not unusual. To address this problem, system designers have incorpor [...] ...|$|R
50|$|Anticiparallelism (Anticipatory Parallelism) {{is a term}} {{coined by}} Bob Metcalfe in 1998. It is a {{technique}} of using idle <b>machine</b> <b>cycles</b> to perform useful computing tasks in the background. Such tasks must be readily interrupted for intervals when the computer needs to return to its primary task. An exampleof such a task is transmitting e-mail. Anticiparalleism {{is also known as}} speculative execution, continual computation or optimistic execution.|$|R
