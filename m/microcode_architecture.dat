2|10|Public
5000|$|UISA (Microcode Instruction Set Architecture)—a {{group of}} {{machines}} with different hardware level microarchitectures may {{share a common}} <b>microcode</b> <b>architecture,</b> and hence a UISA.|$|E
5000|$|In June 1971, on the S/370-145 (one {{of which}} had to be [...] "smuggled" [...] into Cambridge Scientific Center to prevent anybody noticing the arrival of an S/370 at that hotbed of virtual memory {{development}} [...] - [...] since this would have signaled that the S/370 was about to receive address relocation technology). (Varian 1997:p29) The S/370-145 had an associative memory used by the microcode for the DOS compatibility feature from its first shipments in June 1971; the same hardware was used by the microcode for DAT. Although IBM famously chose to exclude virtual memory from the S/370 announcement, that decision was being reconsidered during the completion of the 145 engineering, partly because of virtual memory experience at CSC and elsewhere. The 145 <b>microcode</b> <b>architecture</b> simplified the addition of virtual memory, allowing this capability to be present in early 145s without the extensive hardware modifications needed in other models. However, IBM did not document the 145's virtual memory capability, nor annotate the relevant bits in the control registers and PSW that were displayed on the operator control panel when selected using the roller switches. The Reference and Change bits of the Storage-protection Keys, however, were labeled on the rollers, a dead giveaway to anyone who had worked with the earlier 360/67. Existing S/370-145 customers were happy to learn {{that they did not have}} to purchase a hardware upgrade in order to run DOS/VS or OS/VS1 (or OS/VS2 Release 1 [...] - [...] which was possible, but not common because of the limited amount of main storage available on the S/370-145).|$|E
50|$|Unlike many {{processors}} of the {{day that}} used a <b>microcoded</b> <b>architecture,</b> the 6809 more resembled the simplified RISC machines that would later appear in the 1980s. The 6809 was implemented as a register-transfer level (RTL) machine, using a large PLA to implement the combinational logic and a two-phase clock to gate the latches.|$|R
50|$|On {{traditional}} architectures, {{an instruction}} includes an opcode that specifies the operation to perform, such as add contents of memory to register—and zero or more operand specifiers, which may specify registers, memory locations, or literal data. The operand specifiers may have addressing modes determining their meaning {{or may be}} in fixed fields. In very long instruction word (VLIW) architectures, which include many <b>microcode</b> <b>architectures,</b> multiple simultaneous opcodes and operands are specified in a single instruction.|$|R
40|$|We {{design and}} {{implement}} a cryptographic biometric authentication system using a <b>microcoded</b> <b>architecture.</b> The secure properties of the biometric matching process are obtained {{by means of a}} fuzzy vault scheme. The algorithm is implemented in a reprogrammable, microcoded coprocessor called FV 16. We present the micro-architecture of FV 16 as well as a dedicated assembler for this architecture. Our coprocessor can be attached to an ARM processor, and offers a 83 -fold cycle count improvement when the fuzzy vault algorithm is migrated from embedded ARM software (13. 8 million cycles) to the FV 16 coprocessor (166 thousand cycles) ...|$|R
50|$|Nick {{graduated}} magna {{cum laude}} from Marist College. He holds more than 80 U.S. patents in computer systems technology.From 1980 until September 2004 {{he worked at}} IBM, where he was an IBM Fellow.He worked on software development, <b>microcode,</b> systems <b>architecture,</b> clustered and distributed systems, database sharing algorithms, and transaction processing.|$|R
40|$|Multimedia {{components}} for the visualization of dynamic behavior in computer architectures Understanding modern processors requires a good {{knowledge of the}} dynamic behavior of processors. Traditional media like books use text for describing the dynamic behavior of processors. Visualization of this behavior, however, is impossible, due to the static nature of books. In this paper, we describe multimedia {{components for}} visualizing the dynamic behavior of hardware structures, called RaVi (abbreviation for the German equivalent of “computer architecture visualization”). Available RaVi components 1 include models of a <b>microcoded</b> MIPS <b>architecture,</b> of a MIPS pipeline, of scoreboarding, Tomasulo’s algorithm and the MESI multiprocessor cache protocol. ...|$|R
40|$|Shrinking {{time-to-market}} {{and high}} demand for productivity has driven traditional hardware designers to use design methodologies that start from high-level languages. However, meeting timing constraints of automatically generated IPs {{is often a}} challenging and time-consuming task that must be repeated every time the specification is modified. To address this issue, {{a new generation of}} IP-design technologies that is capable of generating custom datapaths as well as programming an existing one is developed. These technologies are often based on Horizontal <b>Microcoded</b> <b>Architectures.</b> Large code size is a well-know problem in HMAs, and is referred to as “code bloating ” problem. In this paper, we study the code size of one of the new HMAbased technologies called NISC. We show that NISC code size can be several times larger than a typical RISC processor, and we propose several low-overhead dictionary-based code compression techniques to reduce the code size. Our compression algorithm leverages the knowledge of “don’t care ” values in the control words to better compress the content of dictionary memories. Our experiments show that by selecting proper memory architectures the code size of NISC can be reduced by 70 % (i. e. 3. 3 times) at cost of only 9 % performance degradation. We also show that some code compression techniques may increase number of utilized block RAMs in FPGA-based implementations. To address this issue, we propose combining dictionaries and implementing them using embedded dual-port memories...|$|R
40|$|As {{embedded}} memory area on-chip is increasing and memory density is growing, newer test algorithms like March SS are defined to detect newly developing faults. These new March algorithms contain multiple operations per March element. This paper presents a <b>microcoded</b> BIST <b>architecture</b> which can implement these new March tests having {{number of operations}} per element according to the growing needs of {{embedded memory}} testing. This is shown by implementing March SS Test and testing for new faults including Write Disturb Fault (WDF), Transition Coupling Fault (Cft), Deceptive Read Disturb Coupling Fault (Cfdrd), which established tests like March C- are not capable of detecting. Verilog HDL code of this architecture is written and synthesized using Xilinx ISE 8. 2 i. Verification of the architecture is done by testing Mentor’s ModelSim...|$|R
40|$|Survey of ITRS in 2001,the System-on-Chips (SoCs) {{are moving}} from logic {{dominant}} chips to memory dominant chips {{in order to}} deal with today’s and future application requirements. The dominating logic (about 64 % in 1999) is changing to dominating memory (approaching 90 % by 2011). These shrinking technologies give rise to new defects and new fault models have to be defined to detect and eliminate these new defects. These new fault models are used to develop new high coverage test and diagnostic algorithms. The greater the fault detection and localization coverage, the higher the repair efficiency, hence higher the obtained yield. Memory repair is the necessary, since just detecting the faults is no longer sufficient for SoCs, hence both diagnosis and repair algorithms are required. March SS algorithm is a newly developed test algorithm that deal with detecting some recently developed static and dynamic fault models. A new <b>microcoded</b> BIST <b>architecture</b> is presented here which is capable of employing these new test algorithms. A word-oriented BISR array is used to detect the faulty memory locations and repair those faulty memory locations. As indicated by the BIST controller. The MBISR logic used here can function in two modes. Mod...|$|R
40|$|Functional {{validation}} of microprocessors {{is growing in}} complexity in current and future microprocessors. Traditionally, the different components (or validation collaterals) used in simulation based validation, like simulators and test generators, to validate the system, <b>architecture,</b> <b>microcode,</b> and RTL abstractions of the processor, were manually derived from the specification document. The incomplete informal specification document along with manual translation introduces inconsistency and bugs in the validation collaterals, resulting in increased cost and time to validate the processor. We envision a novel metamodeling based microprocessor modeling and validation environment (MMV) to address this problem. MMV provides a language independent modeling environment to describe the processor at various abstraction levels, a refinement flow to consistently move from one abstraction to the next lower abstraction and code generators to automatically generate the validation collaterals from the models. As a first step towards our vision, in this paper, we describe architectural modeling in MMV and automatic generation of random and coverage directed test suites from the models. We demonstrate the practicality of our approach for validating real world Instruction Set Architectures (ISA) by modeling and generating test cases for eight comple...|$|R

