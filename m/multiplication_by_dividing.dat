0|10000|Public
40|$|Efficient {{computation}} of the modular exponentiations is {{very important}} and useful for public-key cryptosystems. In this paper, an efficient parallel binary exponentiation algorithm is proposed which based on the Montgomery multiplication algorithm, the signed-digit-folding (SDF) and common-multiplicand-multiplicand (CMM) techniques. By using the CMM technique of computing the common part from two modular multiplications, the same common part in two modular multiplications can be computed once rather twice, we can thus improve {{the efficiency of the}} binary exponentiation algorithm by decreasing the number of modular <b>multiplications.</b> <b>By</b> <b>dividing</b> the bit pattern of the minimal-signed-digit recoding exponent into three equal length parts and using the technique of recording the common parts in the folded substrings, the proposed SDF-CMM algorithm can improve the efficiency of the binary algorithm, thus can further decrease the computational complexity of modular exponentiation. Furthermore, by using the proposed parallel SDF-CMM Montgomery binary exponentiation algorithm, on average the total number of singleprecision multiplications can be reduced by about 61. 3 % and 74. 1 % as compared with Chang-Kuo-Lin’s CMM modular exponentiation algorithm and Ha-Moon’s CMM Montgomery modular exponentiation algorithm, respectively...|$|R
50|$|This {{is true for}} all {{values of}} x, so the {{solution}} set is all real numbers. But clearly not all real numbers are solutions to the original equation. The problem is that <b>multiplication</b> <b>by</b> zero is not invertible: if we multiply by any nonzero value, we can reverse the step <b>by</b> <b>dividing</b> <b>by</b> the same value, but division by zero is not defined, so <b>multiplication</b> <b>by</b> zero cannot be reversed.|$|R
5000|$|When {{computing}} [...] in {{a language}} with fixed-length integers, the <b>multiplication</b> <b>by</b> [...] may overflow even when the result would fit. The overflow can be avoided <b>by</b> <b>dividing</b> first and fixing the result using the remainder: ...|$|R
5000|$|The content [...] of a {{polynomial}} [...] with coefficients in [...] is {{the greatest}} common divisor of its coefficients, and, as such, is defined up to the <b>multiplication</b> <b>by</b> a unit. The primitive part [...] of [...] is the quotient [...] of [...] by its content; it is a polynomial with coefficients in , which is unique up to the <b>multiplication</b> <b>by</b> a unit. If the content is changed <b>by</b> <b>multiplication</b> <b>by</b> a unit , then the primitive part must be changed <b>by</b> <b>dividing</b> it <b>by</b> the same unit, {{in order to keep}} the equalitywhich is called the primitive-part-content factorization of [...]|$|R
25|$|Indeed, the {{operator}} D is given on Fourier transforms as <b>multiplication</b> <b>by</b> iz/2 and C as <b>multiplication</b> <b>by</b> its inverse.|$|R
2500|$|... The set [...] is {{invariant}} under inversion, contains operators [...] and J, so it {{is enough}} to show it is invariant under <b>multiplication.</b> <b>By</b> construction it is invariant under <b>multiplication</b> <b>by</b> B. It is invariant under <b>multiplication</b> <b>by</b> J because of the defining equation for [...]|$|R
3000|$|The case m= 2 we {{saw before}} {{is a very}} special case, since then A= Z⊕Zx, with [...] x^ 2 = 1, hence on the trivial module Z= Hom_Z[G] ([...] Z[G], Z)(1 -x) acts as <b>multiplication</b> <b>by</b> 0, 1 + x acts as <b>multiplication</b> <b>by</b> 2. But the same pattern happens for all m: (1 -x) acts as <b>multiplication</b> <b>by</b> 0, 1 + x [...]... + x^m- 1 acts as <b>multiplication</b> <b>by</b> m.|$|R
50|$|Canada Post uses a 13 {{character}} barcode {{for their}} pre-printed labels. Bar codes consist of two letters, followed by eight sequence digits, and a ninth digit {{which is the}} check digit. The last two characters are the letters CA. The check digit seems to ignore the letters and only concern itself with the first 8 numeric digits. The scheme is to multiply each of those 8 digits by a different weighting factor, (8 6 4 2 3 5 9 7). Add up the total {{of all of these}} <b>multiplications</b> and <b>divide</b> <b>by</b> 11. The remainder after <b>dividing</b> <b>by</b> 11 gives a number from 0 to 10. Subtracting this from 11 gives a number from 1 to 11. That result is the check digit, except in the two cases where it is 10 or 11. If 10 it is then changed to a 0, and if 11 then it is changed to a 5. The check digit may be used to verify if a barcode scan is correct, or if a manual entry of the barcode is correct.|$|R
25|$|The inverse {{operation}} of multiplication is division. For example, since 4 multiplied by 3 equals 12, then 12 <b>divided</b> <b>by</b> 3 equals 4. <b>Multiplication</b> <b>by</b> 3, followed by division by 3, yields the original number (since {{the division of}} a number other than 0 by itself equals 1).|$|R
50|$|Some Z-related chords are {{connected}} by M or IM (<b>multiplication</b> <b>by</b> 5 or <b>multiplication</b> <b>by</b> 7), due to identical entries for 1 and 5 on the interval vector.|$|R
50|$|The {{number of}} multiplications {{required}} to add two points is 13 plus 3 <b>multiplications</b> <b>by</b> constants: in particular {{there are two}} <b>multiplications</b> <b>by</b> the constant e and one by the constant d.|$|R
5000|$|By {{continuity}} {{it follows}} that H acts as <b>multiplication</b> <b>by</b> i on H2− and as <b>multiplication</b> <b>by</b> −i on H2+. Since these spaces are closed and their sum dense, {{it follows that}} ...|$|R
5000|$|Multiplying ab = d on {{the left}} by a, we have b = ad. Right <b>multiplication</b> <b>by</b> f gives bf = a, and left <b>multiplication</b> <b>by</b> b gives f = ba. Multiplying on the right by a we then have fa = b, and left <b>multiplication</b> <b>by</b> d then yields a = db. Filling in the Cayley table, we now have (new {{additions}} in red): ...|$|R
5000|$|The {{respective}} {{proper time}} interval is {{obtained from the}} above relationship according to [...] <b>by</b> <b>multiplication</b> <b>by</b> , and the distance dl between the two points - <b>by</b> additional <b>multiplication</b> <b>by</b> c/2. As a result: ...|$|R
50|$|Strength reduction: Replace complex or {{difficult}} or expensive operations with simpler ones. For example, replacing division by a constant with <b>multiplication</b> <b>by</b> its reciprocal, or using induction variable analysis to replace <b>multiplication</b> <b>by</b> a loop index with addition.|$|R
40|$|The <b>multiplication</b> <b>by</b> a {{constant}} problem consists in generating code {{to perform a}} <b>multiplication</b> <b>by</b> an integer constant, using elementary operations, such as left shifts (<b>multiplications</b> <b>by</b> powers of two), additions and subtractions. This {{can also be seen}} as a method to compress (or more generally encode) integers. We will not discuss about the quality of this compression method, but this idea will be used to find lower bounds on the code length (number of elementary operations) ...|$|R
3000|$|Multiplying by a {{power of}} two. The <b>multiplication</b> <b>by</b> two, in binary, can be {{performed}} as a simple left shift, adding a 0 bit as the least significant output digit. We write the left shift of i bits (<b>multiplication</b> <b>by</b> 2 [...]...|$|R
5000|$|Given the {{representation}} of T as the operator of <b>multiplication</b> <b>by</b> —as guaranteed by the spectral theorem—it is easy to characterize the functional calculus: If h is a bounded real-valued Borel function on R, then h(T) is the operator of <b>multiplication</b> <b>by</b> the composition [...]|$|R
5000|$|On Hp,q [...] the Weil complex {{structure}} IW is <b>multiplication</b> <b>by</b> ip&minus;q, {{while the}} Griffiths complex structure IG is <b>multiplication</b> <b>by</b> i if p > q and &minus;i if p < q. Both these complex structures map Hn(M,R) into itself and so defined complex structures on it.|$|R
25|$|Pseudodifferential {{operators}} can {{be explained}} easily {{in the case of}} constant coefficient operators on Euclidean space. In this case, constant coefficient differential operators are just the Fourier transforms of <b>multiplication</b> <b>by</b> polynomials, and constant coefficient pseudodifferential operators are just the Fourier transforms of <b>multiplication</b> <b>by</b> more general functions.|$|R
30|$|At {{the input}} and output stages, there are <b>multiplications</b> <b>by</b> one, so those multiplications are avoided at all in our approach. Also, the <b>multiplications</b> <b>by</b> one at the input stage are also avoided {{depending}} on whether DFTDIF−DIT−Pr or DFTDIT−DIF−Pr was executed in the particular employed pruned decomposed transform modality.|$|R
50|$|Pseudodifferential {{operators}} can {{be explained}} easily {{in the case of}} constant coefficient operators on Euclidean space. In this case, constant coefficient differential operators are just the Fourier transforms of <b>multiplication</b> <b>by</b> polynomials, and constant coefficient pseudodifferential operators are just the Fourier transforms of <b>multiplication</b> <b>by</b> more general functions.|$|R
5000|$|... and the {{diagonal}} elements [...] satisfy [...] This is the Smith normal {{form of the}} matrix A. The elements [...] are unique up to <b>multiplication</b> <b>by</b> a unit and are called the elementary divisors, invariants, or invariant factors. They can be computed (up to <b>multiplication</b> <b>by</b> a unit) as ...|$|R
50|$|Another {{method is}} <b>multiplication</b> <b>by</b> 3. A {{number of the}} form 10x + y has the same {{remainder}} when <b>divided</b> <b>by</b> 7 as 3x + y. One must multiply the leftmost digit of the original number by 3, add the next digit, take the remainder when <b>divided</b> <b>by</b> 7, and continue from the beginning: multiply by 3, add the next digit, etc. For example, the number 371: 3×3 + 7 = 16 remainder 2, and 2×3 + 1 = 7. This method {{can be used to}} find the remainder of division by 7.|$|R
5000|$|The prefix exbi (symbol Ei) {{represents}} <b>multiplication</b> <b>by</b> 260, therefore: ...|$|R
5000|$|The prefix pebi (symbol Pi) {{represents}} <b>multiplication</b> <b>by</b> 10245, therefore: ...|$|R
5000|$|The prefix tebi (symbol Ti) {{represents}} <b>multiplication</b> <b>by</b> 10244, therefore: ...|$|R
5000|$|The prefix yobi (symbol Yi) {{represents}} <b>multiplication</b> <b>by</b> 10248, therefore: ...|$|R
5000|$|The prefix zebi (symbol Zi) {{represents}} <b>multiplication</b> <b>by</b> 10247, therefore: ...|$|R
2500|$|If {{the group}} [...] is {{represented}} as an open submanifold of [...] then a left Haar measure on [...] {{is given by}} , where [...] is the Jacobian of left <b>multiplication</b> <b>by</b> [...] A right Haar measure is given in the same way, except with [...] the Jacobian of right <b>multiplication</b> <b>by</b> [...]|$|R
50|$|We {{can also}} define the {{functional}} calculus for not necessarily bounded Borel functions h; {{the result is}} an operator which in general fails to be bounded. Using the <b>multiplication</b> <b>by</b> a function f model of a self-adjoint operator given by the spectral theorem, this is <b>multiplication</b> <b>by</b> the composition of h with f.|$|R
5000|$|If {{the group}} [...] is {{represented}} as an open submanifold of [...] then a left Haar measure on [...] {{is given by}} , where [...] is the Jacobian of left <b>multiplication</b> <b>by</b> [...] A right Haar measure is given in the same way, except with [...] the Jacobian of right <b>multiplication</b> <b>by</b> [...]|$|R
2500|$|... "A {{mathematical}} phenomenon {{exists in}} our suburbs - <b>multiplication</b> <b>by</b> sub-division" ...|$|R
5000|$|In {{terms of}} complex numbers: <b>multiplication</b> <b>by</b> [...] and complex conjugation.|$|R
5000|$|Moreover, {{a closed}} string is {{replaced}} <b>by</b> a <b>multiplication</b> <b>by</b> [...]|$|R
5000|$|... {{then the}} {{decomposition}} is unique up to <b>multiplication</b> <b>by</b> a scalar.|$|R
