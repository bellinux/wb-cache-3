145|6|Public
25|$|The XOR metric allows Kademlia {{to extend}} routing tables beyond single bits. Groups of bits {{can be placed}} in k-buckets. The group of bits are termed a prefix. For an <b>m-bit</b> prefix, there will be 2m-1 k-buckets. The missing k-bucket is a further {{extension}} of the routing tree that contains the node ID. An <b>m-bit</b> prefix reduces {{the maximum number of}} lookups from log2 n to log2m n. These are maximum values and the average value will be far less, increasing the chance of finding a node in a k-bucket that shares more bits than just the prefix with the target key.|$|E
2500|$|The {{meaning of}} the side {{condition}} on A1 is that ioĵ is that 2n-bit number whose v-th bit is the ĵ'v-th bit of i, where the ranges of each quantity are u: m, v: 2n, j'u: 22n, and ĵ'v: 2m. (So j is an m-tuple of 2n-bit numbers while ĵ as the transpose of j is a 2n-tuple of <b>m-bit</b> numbers. Both j and ĵ therefore contain m2n bits.) ...|$|E
5000|$|An <b>M-bit</b> vector that is {{the object}} of the writing and reading operations. Like the address pattern, it is a coded {{description}} of an environmental state. (e.g. M = 256.) ...|$|E
40|$|A digital {{volume control}} device {{comprises}} a logic unit for volume control of digital input signals. Successively supplied <b>m-bits</b> words with maximally k bits active, {{derived from the}} output signals of or supplied by a volume control (4) with a quantizer (5) element the filtered <b>m-bits</b> workds are passed, however, with only the j most significant active bits of these filtered signals. The noise shaper operates with a frequency that is a k/j-fold of the frequency by which the <b>m-bits</b> words are supplied. An up-sampler (3) is provided for operation frequency adjustment of the filtered <b>m-bits</b> words to the noise shaper. This operation frequency {{is at least a}} factor k/j greater than the sample rate of the digital input signals. The control signals for the logic unit are formed by the <b>m-bits</b> words passed by the quantizer...|$|R
50|$|The {{use of the}} 8F byte {{requires}} that the <b>m-bits</b> (see VEX coding scheme) have a value larger {{than or equal to}} 8 in order to avoid overlap with existing instructions. The C4 byte used in the VEX scheme has no such restriction. This may prevent the use of the <b>m-bits</b> for other purposes in the future in the XOP scheme, but not in the VEX scheme. Another possible problem is that the pp bits have the value 00 in the XOP scheme, while they have the value 01 in the VEX scheme for instructions that have no legacy equivalent. This may complicate the use of the pp bits for other purposes in the future.|$|R
40|$|This work {{presents}} {{the design of}} RSFQ parallel multiplier suitable for implementation of the superconducting digital signal processor for interference cancellation in 3 G cellular systems. We have designed the parallel multiplier which consists of N <b>M-bits</b> serial adders based on the T 1 cells for M ×N sign multiplication. This multiplier consumes 74 ×M×N Josephson junctions. The 2 -bit and 4 -bit parallel multipliers have been designed for TRWs 8 kA/cm 2 process. The maximum VHDL simulated clock speed and one bit effective area are 39 GHz and 300 × 300 &# 956;m 2 correspondingly...|$|R
50|$|The XOR metric allows Kademlia {{to extend}} routing tables beyond single bits. Groups of bits {{can be placed}} in k-buckets. The group of bits are termed a prefix. For an <b>m-bit</b> prefix, there will be 2m-1 k-buckets. The missing k-bucket is a further {{extension}} of the routing tree that contains the node ID. An <b>m-bit</b> prefix reduces {{the maximum number of}} lookups from log2 n to log2m n. These are maximum values and the average value will be far less, increasing the chance of finding a node in a k-bucket that shares more bits than just the prefix with the target key.|$|E
5000|$|... a {{contents}} portion that is M-bits {{wide and}} that can accumulate multiple <b>M-bit</b> data patterns written into the location. The contents' portion is not fixed; it is modified by data patterns written into the memory.|$|E
50|$|It {{has been}} called bit slice {{processing}} because <b>m-bit</b> slice is processes at a time. Word parallel signifies selection of all words. It {{can be considered as}} one bit from all words are processed at a time.|$|E
40|$|Abstract — Steganography {{involves}} hiding {{information in}} another media. PVD based steganography techniques uses {{the difference between}} the pixel values of a pair directly to hide the information. The proposed steganography system modifies the difference value before being used for hiding the information. This makes extraction of hidden data harder in case the steganography system fails. The algorithm divides the cover image in the block of 2 x 3 pixels and calculates average (N) of the bits that can be hidden in five pairs of that block. Thus if the difference value allows <b>M-bits</b> to be hidden in the pair, then only N-bits are hidden in that pair when M>N otherwise M (if M≤N) bits are hidden in that pair. Second level of security is added by converting the secret information into gray code before embedding it in the cover image. The algorithm provides good hiding capacity and improved quality of stego image with two levels of security for the secret information...|$|R
40|$|Multi-stage analog-to-digital {{converters}} are {{the dominant}} choice in applications that require both high speed and high accuracy, such as video and wideband radio [1]. Non-idealities such as static device mismatch and dynamic timing mismatch, in different architectures of multi-steps {{analog to digital converter}} affect the redundancy and {{performance at the}} output of an instrument. Redundant sign digit (RSD) is an approach of calibration have been proposed to detect and automation no anymore only for cyclic converter but also for multistage A/D with <b>M-bits</b> per cycle for correction of errors in order to improve the resolution and the redundancy of A/D converters and to adapt the high performance of digital signal processing system. In this paper we will presented a behavioral model in order to investigate the impact of different sources of error at different levels of simulation based at the comparison of RSD to conventional converter with Z extra decision level (CRZ). As result, the RSD converter show a performance equivalent to CRZ with Z= 2 M- 1 where M is the number of bits per cycle...|$|R
40|$|When we are {{required}} to design a DAC with a specific performance, {{it may well be}} that no single architecture is ideal. In such cases, two or more DACs may be combined in a single higher resolution DAC to give the required performance. These DACs may be of the same type or of different types and need not each have the same resolution. In principle, one DAC handles the MSBs, another handles the LSBs, and their outputs are added in some way. The process is known as "segmentation, " and these more complex structures are called "segmented DACs". There are many different types of segmented DACs and some, but by no means all, of them will be illustrated in this tutorial. Figure 1 shows two varieties of segmented voltage-output DAC. The architecture in Figure 1 A is sometimes called a Kelvin-Varley Divider and is composed of two or more "string DACs. " Since there are buffers between the first and second stages, the second string DAC does not load the first, and the resistors in this string do not need to have the same value as the resistors in the other one. All the resistors in each string, however, do need to be equal to each other or the DAC will not be linear. The examples shown have 3 -bit first and second stages but for the sake of generality, let us refer to the first (MSB) stage resolution as <b>M-bits</b> and the second (LSB) as K-bits for a total of N = M + K bits. The MSB DAC has a string of 2 M equal resistors, and a string of 2 K equal resistors in the LSB DAC. KELVIN-VARLEY DIVIDER(TWO "STRING DACs"...|$|R
5000|$|Let be a {{function}} that takes as input a sample from an [...] distribution [...] and a d-bit seed from , and outputs an <b>m-bit</b> string. is a (k, ε)-extractor, if for all [...] distributions , the output distribution of [...] is ε-close to [...]|$|E
5000|$|If {{a bit on}} the nth bit {{plane on}} an <b>m-bit</b> dataset is set to 1, it {{contributes}} a value of 2(m-n), otherwise it contributes nothing. Therefore, bit planes can contribute half {{of the value of the}} previous bit plane. For example, in the 8-bit value 10110101 (181 in decimal) the bit planes work as follows: ...|$|E
5000|$|The {{encryption}} scheme employs two key types:ACE public key: [...]ACE private key: [...]For a given size parameter m , {{such that}} , key components are defined as: — a 256-bit prime number. — a <b>m-bit</b> prime number, such that [...] — elements [...] (whose multiplicative order modulo [...] divides [...] ). — elements [...] — elements [...] with [...] and , where [...] and [...]|$|E
5000|$|Intuitively, an {{extractor}} takes a weakly random n-bit {{input and}} a short, uniformly random seed and produces an <b>m-bit</b> output that looks uniformly random. The {{aim is to}} have a low [...] (i.e. to use as little uniform randomness as possible) and as high an [...] as possible (i.e. to get out as many close-to-random bits of output as we can).|$|E
50|$|Reading is the {{operation}} of retrieving a data pattern from the memory using a particular address pattern. During a read, an address pattern is used to select {{a certain number of}} hard memory locations (just like during a write). The contents of the selected locations are bitwise summed and thresholded to derive an <b>M-bit</b> data pattern. This serves as the output read from the memory.|$|E
50|$|To {{explain this}} {{assembly}} process, suppose {{we have a}} reversible n-bit gate f and a reversible <b>m-bit</b> gate g. Putting them together means producing a new circuit by connecting some set of k outputs of f to some set of k inputs of g as in the figure below. In that figure n=5, k =3 and m = 7. The resulting circuit is also reversible and operates on n+m&minus;k bits.|$|E
5000|$|The {{meaning of}} the side {{condition}} on A1 is that ioĵ is that 2n-bit number whose v-th bit is the ĵv-th bit of i, where the ranges of each quantity are u: m, v: 2n, ju: 22n, and ĵv: 2m. (So j is an m-tuple of 2n-bit numbers while ĵ as the transpose of j is a 2n-tuple of <b>m-bit</b> numbers. Both j and ĵ therefore contain m2n bits.) ...|$|E
5000|$|A {{message that}} is m bits long {{can be viewed}} as a corner of the m-dimensional hypercube. The effect of a {{checksum}} algorithm that yields an n-bit checksum is to map each <b>m-bit</b> message to a corner of a larger hypercube, with dimension [...] The 2m+n corners of this hypercube represent all possible received messages. The valid received messages (those that have the correct checksum) comprise a smaller set, with only 2m corners.|$|E
50|$|Now {{imagine that}} the inputs are driven not by an <b>m-bit</b> address, but by m {{independent}} logic signals. Theoretically, there are 22m possible Boolean functions of these m input signals. By Boolean function {{in this context is}} meant a single function that maps each of the 2m possible combinations of the m Boolean inputs to a single Boolean output. There are 22m possible distinct ways to map each of 2m inputs to a Boolean value, which explains why there are 22m such Boolean functions of m inputs.|$|E
50|$|This encoder {{implementation}} sends three sub-blocks of bits. The first sub-block is the <b>m-bit</b> {{block of}} payload data. The second sub-block is n/2 parity bits for the payload data, computed using a recursive systematic convolutional code (RSC code). The third sub-block is n/2 parity bits for a known permutation of the payload data, again computed using an RSC code. Thus, two redundant but different sub-blocks of parity bits are sent with the payload. The complete block has m + n bits of data with a code rate of m/(m + n). The permutation of the payload data {{is carried out}} by a device called an interleaver.|$|E
50|$|The key {{innovation}} of turbo codes is {{how they}} use the likelihood data to reconcile {{differences between the two}} decoders. Each of the two convolutional decoders generates a hypothesis (with derived likelihoods) for the pattern of m bits in the payload sub-block. The hypothesis bit-patterns are compared, and if they differ, the decoders exchange the derived likelihoods they have for each bit in the hypotheses. Each decoder incorporates the derived likelihood estimates from the other decoder to generate a new hypothesis for the bits in the payload. Then they compare these new hypotheses. This iterative process continues until the two decoders come up with the same hypothesis for the <b>m-bit</b> pattern of the payload, typically in 15 to 18 cycles.|$|E
5000|$|... where m is {{the number}} of bits that are {{required}} to label the nodes in the network. So, if there are 4 nodes in the network, 2 bits are needed to represent all the nodes in the network. The network is constructed by connecting the nodes that just differ by one bit in their binary representation. This is commonly referred to as Binary labelling. A 3D hypercube internetwork would look be a cube with 8 nodes and 12 edges. A 4D hypercube network can be created by duplicating two 3D networks, and adding a most significant bit. The new added bit should be ‘0’ for one 3D hypercube and ‘1’ for the other 3D hypercube. The corners of the respective one-bit changed MSBs are connected to create the higher hypercube network. This method can be used to construct any <b>m-bit</b> represented hypercube with (m-1)-bit represented hypercube.|$|E
50|$|In the three-party set disjointness {{problem in}} {{communication}} complexity, three subsets of the integers in some range 1,m are specified, and three communicating parties each know {{two of the}} three subsets. The goal is for the parties to transmit as few bits to each other on a shared communications channel in order for one of the parties to be able to determine whether the intersection of the three sets is empty or nonempty. A trivial <b>m-bit</b> communications protocol would be for one of the three parties to transmit a bitvector describing the intersection of the two sets known to that party, after which either of the two remaining parties can determine the emptiness of the intersection. However, if there exists a protocol that solves the problem with o(m) communication and 2o(m) computation, it could be transformed into an algorithm for solving k-SAT in time O(1.74n) for any fixed constant k, violating the strong exponential time hypothesis. Therefore, the strong exponential time hypothesis implies either that the trivial protocol for three-party set disjointness is optimal, or that any better protocol requires an exponential amount of computation.|$|E
40|$|Iterated hash {{functions}} {{based on}} block ciphers are treated. Five attacks on an iterated hash function {{and on its}} round function are formulated. The wisdom of strengthening such hash functions by constraining the last block of the message to be hashed is stressed. Schemes for constructing <b>m-bit</b> and 2 <b>m-bit</b> hash round functions from <b>m-bit</b> block ciphers are studied. A principle is formalized for evaluating the strength of hash round functions, viz., that applying computationally simple #in both directions# invertible transformations to the input and output of a hash round function yields a new hash round function with the same security. By applying this principle, four attacks on three previously proposed 2 <b>m-bit</b> hash round functions are formulated. Finally, three new hash round functions based on an <b>m-bit</b> block cipher with a 2 <b>m-bit</b> key are proposed. 1 Introduction This paper is intended to provide a rather rounded treatment of hash functions that are obtained by iterati [...] ...|$|E
40|$|This paper {{analyzes}} {{the security of}} a hash mode recently proposed by Yi and Lam. Given a block cipher with <b>m-bit</b> block size and 2 <b>m-bit</b> key, they build a hash function with 2 <b>m-bit</b> outputs that can hash messages as fast as the underlying block cipher can encrypt. This construction was conjectured to have ideal security, i. e., to resist all collision attacks faster than brute force. We disprove this conjecture by presenting a collision attack that is substantially faster than brute force and which could even be considered practical for typical security parameters...|$|E
40|$|A {{block cipher}} based hash-function of Yi and Lam [5] is {{analysed}} and {{shown to be}} significantly weaker than originally intended. 1 Introduction Yi and Lam [5] give a method for deriving a 2 <b>m-bit</b> hash-function from a block cipher with an <b>m-bit</b> block length and a 2 <b>m-bit</b> key length. We show that the hash-function is somewhat less secure than claimed in [5]; indeed, it appears to offer no significant gains over the `single length' block cipher based hash-function in ISO/IEC 10118 - 2 [1]. 2 The Yi-Lam hash-function The hash-function {{is based on the}} iterated use of a round-function, which is, in turn, block cipher based. Data to be hashed is split into <b>m-bit</b> blocks, with padding added, as necessary, to the final block. An extra final block is added, containing an encoding of the data's bit-length prior to padding. We denote the resulting string of blocks by: M 1; M 2; : : :; M n, where M n contains the encoded length value. Denote block cipher encryption by EK (M), where M is an <b>m-bit</b> [...] ...|$|E
40|$|Abstract. This paper {{analyzes}} {{the security of}} a hash mode recently proposed by Yi and Lam. Given a block cipher with <b>m-bit</b> block size and 2 <b>m-bit</b> key, they build a hash function with 2 <b>m-bit</b> outputs that can hash messages as fast as the underlying block cipher can encrypt. This construction was conjectured to have ideal security, i. e., to resist all collision attacks faster than brute force. We disprove this conjecture by presenting a collision attack that is substantially faster than brute force and which could even be considered practical for typical security parameters. ...|$|E
30|$|The RS code {{belongs to}} the system linear block code, {{including}} the information bit and the supervised bit. The block code divides the continuous data bit stream into fixed-length groups, each group being further divided into <b>m-bit</b> symbols, usually taking 3 or 8  bits of data to form a symbol. The K symbols together form a source word, which is linearly encoded after being encoded as a code word called an <b>m-bit</b> symbol block code.|$|E
40|$|Abstract: In our project, {{we propose}} a novel {{architecture}} which generates the test patterns with reduced switching activities. LP-TPG (Test pattern Generator) structure consists of modified low power linear feedback shift register (LP-LFSR), <b>m-bit</b> counter; gray counter, NOR-gate structure and XOR-array. The <b>m-bit</b> counter is initialized with Zeros and which generates 2 m test patterns in sequence. The <b>m-bit</b> counter and gray code generator {{are controlled by}} common clock signal [CLK]. The output of <b>m-bit</b> counter is applied as input to gray code generator and NOR-gate structure. When all the bits of counter output are Zero, the NOR-gate output is one. Only when the NOR-gate output is one, the clock signal is applied to activate the LP-LFSR which generates the next seed. The seed generated from LP-LFSR is Exclusive–OR ed with the data generated from gray code generator. The patterns generated from the Exclusive–OR array are the final output patterns. The proposed architecture is simulated using Modelsim and synthesized using Xilinx ISE 13. 2 {{and it will be}} implemented on XC 3 S 500 e Spartan 3 E FPGA board for hardware implementation and testing. The Xilinx Chip scope tool will be used to test the FPGA inside results while the logic running on FPGA...|$|E
3000|$|In image applications, {{embedding}} {{capacity is}} usually {{expressed as a}} ratio, bit-per-pixel (bpp). According to Definition 4.7, if the watermarking embedding capacity is n-bit, {{and the size of}} watermark is <b>m-bit</b> (i.e., w={ 1, 0 } [...]...|$|E
40|$|Abstract. This paper {{analyzes}} {{the security of}} a hash mode recently proposed by Yi and Lam. Given a block cipher with <b>m-bit</b> block size and 2 <b>m-bit</b> key, they build a hash function with 2 <b>m-bit</b> outputs that can hash messages as fast as the underlying block cipher can encrypt. This construction was conjectured to have ideal security, i. e., to resist all collision attacks faster than brute force. We disprove this conjecture by presenting a collision attack that is substantially faster than brute force and which could even be considered practical for typical security parameters. 1 Introduction The public cryptographic community has over 20 years of experience in building secure block ciphers. In contrast, the design of cryptographic hash functions has received only about half as many years of research. Yet hash functions are still a very important primitive to practitioners. Therefore, there is much interest in the problem of building a secure, fast hash function out of a secure block cipher. This research program has been troubled by two major challenges. First, most existing block ciphers have a 64 bit block size, but a hash function with a 64 bit output cannot possibly resist collision search. Therefore, one must somehow securely double the width of the internal state, and this appears to be a non-trivial endeavor. Second, it is hard to maintain efficiency without sacrificing security. The critical figure of merit is the rate of the hash function, which is defined as the number of <b>m-bit</b> message blocks hashed per encryption, where m is the block size of the underlying cipher. Many early proposals for building fast hash functions have been broken; in particular, Knudsen, Lai, and Preneel cryptanalyzed a large class of double-length hash functions of rate 1 [1 - 4, 8]...|$|E
40|$|This paper {{considers}} hash functions {{based on}} block ciphers. It presents a new {{attack on the}} compression function of the 128 -bit hash function MDC- 4 using DES with a complexity far less that one would expect, and proposes new constructions of fast and secure compression functions based on error-correcting codes and <b>m-bit</b> block ciphers with an <b>m-bit</b> key. This leads to simple and practical hash function constructions based on block ciphers such as DES, where the key size is slightly smaller than the block size, IDEA, where the key size is twice the block size and to MD 4 -like hash functions. Under reasonable assumptions about the underlying block cipher, we obtain collision resistant compression functions. Finally we provide examples of hashing constructions based on both DES and IDEA more efficient than previous proposals and discuss applications of our approach for MD 4 -like hash functions. status: publishe...|$|E
40|$|We {{consider}} constructions for {{cryptographic hash}} functions based on <b>m-bit</b> block ciphers. First {{we present a}} new attack on the LOKIDBH mode: the attack finds collisions in 2 3 m= 4 encryptions, which should be compared to 2 m encryptions for a brute force attack. This attack breaks the last remaining subclass in a wide class of efficient hash functions which have been proposed in the literature. We then analyze hash functions based on a collision resistant compression function for which finding a collision requires at least 2 m encryptions, providing a lower bound {{of the complexity of}} collisions of the hash function. A new class of constructions is proposed, based on error correcting codes over GF(2 2) and a proof of security is given, which relates their security to that of single block hash functions. For example, a compression function is presented which requires about 4 encryptions to hash an <b>m-bit</b> block, and for which finding a collision requires at least 2 m encryptions [...] ...|$|E
3000|$|... [...]. Bit {{interleaved}} coded modulation (BICM) [18, 19] is used {{to disperse}} the obtained coded binary data sequence to assure that no single coded symbol is fully destroyed while passing through a fading channel. Punctured and interleaved bit stream v is passed to the mapper. Each <b>m-bit</b> combination is mapped to channel symbol x according to the chosen constellation (BPSK till 256 -QAM) formed of 2 [...]...|$|E
