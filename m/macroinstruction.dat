9|16|Public
25|$|A macro {{assembler}} includes a <b>macroinstruction</b> facility so that (parameterized) assembly language text {{can be represented}} by a name, and that name {{can be used to}} insert the expanded text into other code.|$|E
5000|$|<b>Macroinstruction</b> - {{from the}} Greek [...] (makros) meaning [...] "long" [...] and the Latin ...|$|E
5000|$|A macro {{assembler}} includes a <b>macroinstruction</b> facility so that (parameterized) assembly language text {{can be represented}} by a name, and that name {{can be used to}} insert the expanded text into other code.|$|E
50|$|The NVAX is {{partitioned}} {{into the}} five semi-autonomous units, the I-box, E-box, F-box, M-box and C-box. The NVAX is macropipelined. Multiple VAX <b>macroinstructions</b> are processed in parallel by autonomous units, which {{have their own}} micropipelines.|$|R
50|$|The {{microprocessor}} is microprogrammed {{and partially}} pipelined {{and consists of}} six major functional units, the I-Box, E-Box, M-box, bus interface unit (BIU), cache, and control store and microsequencer. The I-Box fetches VAX instructions from the cache and decodes them (parses) into <b>macroinstructions.</b> The I-Box has an IROM (Instruction decode ROM) that holds the information required to do so.|$|R
40|$|This paper {{outlines}} {{the synthesis of}} <b>macroinstructions</b> for dynamically reprogrammable FPGAs {{so that they may}} be easily generated, placed, and garbage collected at run-time. An overview of a dynamic logic caching computer that uses these <b>macroinstructions</b> is given and their use within this environment discussed. The synthesis of macro-instructions is illustrated with a basic example. Finally, the current state of development of a logic cache based computing platform and compiler/simulator workframe is presented. 1 Introduction Dynamically reconfigurable gate arrays can be used to implement time-sliced coprocessors. By changing the configuration in the gate array's static RAM during run time, the coprocessor changes function during the execution of the program to provide hardware support on an as-needed basis. Thinking of the co-processor as a hardware cache, operating {{in much the same way}} as a memory cache, can provide several important benefits for fast prototyping. The logic cache c [...] ...|$|R
50|$|Another {{way to try}} {{to improve}} {{performance}} is to cache the decoded micro-operations, so that if the same <b>macroinstruction</b> is executed again, the processor can directly access the decoded micro-operations from a special cache, instead of decoding them again. The Execution Trace Cache found in Intel NetBurst microarchitecture (Pentium 4) is a widespread example of this technique. The size of this cache may be stated in terms of how many thousands of micro-operations it can store: kμops.|$|E
50|$|While macro {{instructions}} can {{be defined}} by a programmer for any set of native assembler program instructions, typically macros are associated with macro libraries delivered with the operating system allowing access to operating system functions such as peripheral access by access methods (including macros such as OPEN, CLOSE, READ and WRITE) and other operating system functions such as ATTACH, WAIT and POST for subtask creation and synchronization. Typically such macros expand into executable code, e.g., for the EXIT <b>macroinstruction,</b> a list of define constant instructions, e.g., for the DCB macro, {{or a combination of}} code and constants, with the details of the expansion depending on the parameters of the macro instruction (such as a reference to a file and a data area for a READ instruction); he executable code often terminated in either a branch and link register instruction to call a routine, or a supervisor call instruction to call an operating system function directly.|$|E
40|$|Fecundity, {{bloodmeal}} size, {{and survival}} {{are among the}} most important parameters in the overall fitness of mosquitoes. Impact of an intervention that affects fecundity can be assessed by directly counting the eggs laid by exposed mosquitoes, which is usually done manually. We have developed a <b>macroinstruction,</b> which can be used to count thousands of Anopheles stephensi Liston eggs in a few minutes, to provide an alternative and adaptable method to egg counting as a measure of fecundity. The macro was developed using a scanner and a computer running AxioVision Rel. 4. 8 software, a freely accessible software compatible with Windows XP/ 7 /Vista. Using this semiautomated method, it is possible to reduce time, avoid human error and bias, and obtain improved consistency in studies measuring mosquito fecundity. No Full Tex...|$|E
40|$|The {{architecture}} {{and implementation of}} a Computational RAM (CRAM) controller is presented. The design interfaces the CRAM to the PCI bus. CRAM <b>macroinstructions</b> are issued by the host processor through the PCI bus onto the CRAM controller instruction FIFO. These <b>macroinstructions</b> act as address pointers to the CRAM control store, which contains the lowest-level CRAM microinstruction routines. A read/write buffer and an instruction FIFO increase performance by reducing bus transaction delays and avoiding the need to synchronize PCI bus transactions to CRAM operations. The controller programming model is also described. A prototype CRAM controller has been implemented in a Xilinx XC 4013 E- 2 FPGA, and is currently being used in building a prototype CRAM system in a PC environment. 1. Introduction Computational RAM [1 - 2] is a SIMD-memory hybrid architecture, with 1 -bit processing elements (PE) integrated at the sense amplifiers of a standard DRAM/ SRAM (Fig. 1 a). This architecture improve [...] ...|$|R
40|$|Structured {{programming}} with complementary {{conditions and}} multi-level exits in assembly language is {{applicable to the}} small computer systems which have no <b>macroinstructions.</b> SPA consists of B-structure (BS), C-structures (CS), L-structures (LS) and F-structures (FS). BS is the main frame CS comprises conditional statements and conditional variables, and LS also comprises loops. FS consists of arithmetic statements. Various combinations of BS, CS, LS and FS decrease the number of blocks in structured programming. Moreover, both complementary conditions and multi-level exits facilitate programming in SPA...|$|R
50|$|A Microsoft Excel {{application}} {{has been}} authored that uses least squares fits of wind tunnel acquired tabular drag coefficients. Alternatively, manufacturer supplied ballistic trajectory data, or Doppler acquired velocity {{data can be}} fitted as well to calibrate the model. The Excel application then employs custom <b>macroinstructions</b> to calculate the trajectory variables of interest. A modified 4th order Runge-Kutta integration algorithm is used. Like Pejsa, Colonel Manges claims center-fired rifle accuracies to the nearest one tenth of an inch for bullet position, and nearest foot per second for the projectile velocity.|$|R
40|$|Baccalaureate work {{deal with}} {{problems}} education in patients indicated to invasive achievement cardiac catheterization. It consists of theoretic and experiential parts. In theoretic parts are translateds basic piece of knowledge incidental educational activity in medical environment. Further list-form of <b>macroinstruction</b> with character achievement cardiac catheterization, inclusive nurse care before and after step. Pivotal is experiential volume of work, for which was elect philosophy uniphase mixed mock - up, i. e. use qualitative also quantitative engineer in just one experimental enquiry. Collection was realized by the help of semi - structured talk in patients hospitalized on internal clinic ÚVN and 1. LF. at the close are present record enquiry, which are bent on quality and effect education of the process. Part of experimental news is also proposal interventions that the have contribute by to increasing effectiveness education activities medical personnel detachment cardiology - sick - bed part and intermediate care internal clinic ÚVN and 1. LF...|$|E
40|$|This paper {{describes}} the design goals, micro-architecture, {{and implementation of}} the microprogrammed processor for a compact high performance personal com-puter. This computer supports a range of high level lang-uage environments and high bandwidth I/O devices. Besides the processor, it has a cache, a memory map, main storage, and an instruction fetch unit; these are described in other papers. The processor can be shared among 16 microcoded tasks, performing microcode context switches on demand with essentially no overhead. Conditional branches are done without any Iookahead or delay. Micro-instructions are fairly tightly encoded, and use an interes-ting variant on control field sharing. The processor imple-ments a large number of internal registers, hardware stacks, a cyclic shifter/masker, and an arithmetic/logic unit, together with external data paths for instruction fetching, memory interface, and t/O, in a compact, pipe-lined organization. The machine has a 50 ns microcycle, and can execute a simple <b>macroinstruction</b> in one cycle; the available 1 /O bandwidth is 640 Mhits/sec. The entire machine, including disk, display and network interfaces, is implemented with approximately 3000 MSI components, mostly ECL 10 K; the processor is about 35 % of this. In addition there are up to 4 storage modules, each with about 300 16 K or 64 K RAMS and 200 MS! components, for a total of 8 Mbytes. Several prototypes are currently running. 1...|$|E
40|$|Summary: Microprogramming is a {{technique}} to implement the control logic necessary to execute instructions within a processor. It relies on fetching low-level microinstructions from a control store and deriving the appropriate control signals as well as microprogram sequencing information from each microinstruction. Definitions and Example Although loose usage has sometimes equated the term "microprogramming " {{with the idea of}} "programming a microcomputer", this is not the standard definition. Rather, microprogramming is a systematic technique for implementing the control logic of a computer's central processing unit. It is a form of stored-program logic that substitutes for hardwired control circuitry. The central processing unit in a computer system is composed of a data path and a control unit. The data path includes registers, function units such as shifters and ALUs (arithmetic and logic units), internal processor busses and paths, and interface units for main memory and I/O busses. The control unit governs the series of steps taken by the data path during the execution of a uservisible instruction, or <b>macroinstruction</b> (e. g., load, add, store). Each action of the datapath is called a register transfer and involves the transfer of information within the data path, possibly including the transformation of data, address, or instruction bits by the function units. A register transfer is accomplished by gating out (sending) register contents onto internal processor busses, selecting the operation of ALUs, shifters, etc., through which that information might pass, and gating in (receiving) new values for one or more registers...|$|E
25|$|In the mid 1970s, the 8-bit {{microprocessor}} manufacturers {{raced to}} introduce the 16-bit generation. National Semiconductor had been first with its IMP-16 and PACE processors in 1973–1975, but these had issues with speed. Intel had worked on their advanced 16/32-bit Intel iAPX 432 (alias 8800) since 1975 and their Intel 8086 since 1976 (it was introduced in 1978 but became really widespread {{in the form of}} the almost identical 8088 in the IBM PC a few years later). Arriving late to the 16-bit arena afforded the new processor more transistors (roughly 40,000 active versus 20,000 active in the 8086), 32-bit <b>macroinstructions,</b> and acclaimed general ease of use.|$|R
40|$|Abstract: The paper {{presents}} a software product developed in University comparable with other industrial products. The digital motion control development shell solves the hard real-time constraints {{imposed by the}} AC drive control applications. It was developed {{because of lack of}} integrated software tools for TMS 320 C 3 Cx family. The main advantages of the shell proposed are: high level programming, integration in a natural way of the software tools delivered by Texas Instruments Inc., user-friendly programming environment, powerful library functions for peripherals, portability and readability of application programs. The software product can be used in research and in educational process as well. Key-Words: DSP, digital motion control, shell, programming environment, communication, <b>macroinstructions.</b> ...|$|R
40|$|Transferable Output ASCII Data (TOAD) {{computer}} program (LAR- 13755), implements format designed to facilitate transfer of data across communication networks and dissimilar host computer systems. Any data file conforming to TOAD format standard called TOAD file. TOAD Editor is interactive software tool for manipulating contents of TOAD files. Commonly used to extract filtered subsets of data for visualization of results of computation. Also offers such user-oriented features as on-line help, clear English error messages, startup file, <b>macroinstructions</b> defined by user, command history, user variables, UNDO features, and {{full complement of}} mathematical statistical, and conversion functions. Companion program, TOAD Gateway (LAR- 14484), converts data files from variety of other file formats to that of TOAD. TOAD Editor written in FORTRAN 77...|$|R
40|$|Contemporary {{software}} forces {{users to}} choose between general purpose operating systems with primitive data management facilities, and special-purpose data management systems with little support of programing languages and interactive computation. This is because integrated systems combining these two features have not been available. This report presents the design of an integrated system known as the Extended Data Management Facility (EDMF) which combines the facilities of the RCA Time Sharing Operating System (TSOS) with novel data-handling and access-control capabilities. The novelties of the EDMF include a generalized file structure, a generalized record organization, an efficient record retrieval algorithm, and access control to files, records within files, and fields within records. A comprehensive set of on-line commands and system <b>macroinstructions</b> are provided for defining and processing files, records, and fields, and for access control. Special programming aids are also provided for defining blocks of commands, called procedures, for later execution...|$|R
40|$|A small microprocessor, {{suitable}} for use in applications in which high reliability is required, {{was designed to be}} implemented in either an application-specific integrated circuit (ASIC) or a field-programmable gate array (FPGA). The design is based on commercial microprocessor architecture, making it possible to use available software development tools and thereby to implement the microprocessor at relatively low cost. The design features enhancements, including trapping during execution of illegal instructions. The internal structure of the design yields relatively high performance, with a significant decrease, relative to other microprocessors that perform the same functions, in the number of microcycles needed to execute <b>macroinstructions.</b> The problem meant to be solved in designing this microprocessor was to provide a modest level of computational capability in a general-purpose processor while adding as little as possible to the power demand, size, and weight of a system into which the microprocessor would be incorporated. As designed, this microprocessor consumes very little power and occupies {{only a small portion of}} a typical modern ASIC or FPGA. The microprocessor operates at a rate of about 4 million instructions per second with clock frequency of 20 MHz...|$|R
40|$|PVM Wrapper is a {{software}} library {{that makes it}} possible for code that utilizes the Parallel Virtual Machine (PVM) software library to run using the message-passing interface (MPI) software library, without needing to rewrite the entire code. PVM and MPI are the two most common software libraries used for applications that involve passing of messages among parallel computers. Since about 1996, MPI has been the de facto standard. Codes written when PVM was popular often feature patterns of {"initsend," "pack," "send"} and {"receive," "unpack"} calls. In many cases, these calls are not contiguous and one set of calls may even exist over multiple subroutines. These characteristics make it difficult to obtain equivalent functionality via a single MPI "send" call. Because PVM Wrapper is written to run with MPI- 1. 2, some PVM functions are not permitted and must be replaced - a task that requires some programming expertise. The "pvm_spawn" and "pvm_parent" function calls are not replaced, but a programmer can use "mpirun" and knowledge of the ranks of parent and child tasks with supplied <b>macroinstructions</b> to enable execution of codes that use "pvm_spawn" and "pvm_parent. ...|$|R
40|$|The {{computations}} {{related to}} geodetic works require an application guarantee-ing execution of computations. Therefore, a program performing the required computations can be purchased, or an own application for execution of computa-tions can be created, including specifying details of realization of a task in a com-plete way {{as well as}} the method and the range of presentation of the results. An own program can realize problems from the simplest computations to complicated analyses. We decide which functions are executed by our application. The commercial programs that are nowadays available at the market offer fi-nal results and often do not provide any view into indirect results (that are repeat-edly required for making an analysis, particularly if any computation troubles oc-cur). If an own program is created, it is possible to make a view into indirect re-sults at any computation stage. An application performing computations that are interesting for us, can be created in many ways: – write a program from the ground up taking advantage of the existing mar-ket programming tools (e. g. C++, Delphi, Java, Visual Basic or another); – take advantage of the popular Excel spreadsheet; in addition to broad cal-culation capabilities (including the matrix algebra), the Excel spreadsheet features embedded elements for programming the <b>macroinstructions</b> by means of the Visual Basic language; thereby, a complete application for a given group of computation problems can be created...|$|R
40|$|International {{recommendations}} for determination of referenceintervals have been recently updated, especially for small reference sample groups, {{and use of}} the robust method and Box–Cox transformation is now recommended. Unfortunately, these methods are not included in most software programs used for data analysis by clinical laboratories. We have created a set of <b>macroinstructions,</b> named Reference Value Advisor, for use in Microsoft Excel to calculate reference limits applying different methods. For any series of data, Reference Value Advisor calculates reference limits (with 90 % confidence intervals [CI]) using a nonparametric method when nZ 40 and by parametric and robust methods from native and Box–Cox transformed values; tests normality of distributions using the Anderson–Darling test and outliers using Tukey and Dixon–Reed tests; displays the distribution of values in dot plots and histograms and constructs Q–Q plots for visual inspection of normality; and provides minimal guidelines in the form of comments based on international recommendations. The critical steps in determination of reference intervals are correct selection of as many reference individuals as possible and analysis of specimens in controlled preanalytical and analytical conditions. Computing tools cannot compensate for flaws in selection and size of the reference sample group and handling and analysis of samples. However, if those steps are performed properly, Reference Value Advisor, available as freeware at [URL] www. biostat. envt. fr/spip /spip. php?article 63, permits rapid assessment and comparison of results calculated using different methods, including currently unavailable methods. This allows for selection of the most appropriate method, especially as the program provides the CI of limits. It should be useful in veterinary clinical pathology when only small reference sample groups are available...|$|R
40|$|The Thermal Radiation Analyzer System, TRASYS, is a {{computer}} software system with generalized capability to solve the radiation related aspects of thermal analysis problems. TRASYS computes the total thermal radiation environment for a spacecraft in orbit. The software calculates internode radiation interchange data as well as incident and absorbed heat rate data originating from environmental radiant heat sources. TRASYS provides data of both types in a format directly usable by such thermal analyzer programs as SINDA/FLUINT (available from COSMIC, program number MSC- 21528). One primary feature of TRASYS {{is that it allows}} users to write their own driver programs to organize and direct the preprocessor and processor library routines in solving specific thermal radiation problems. The preprocessor first reads and converts the user's geometry input data into the form used by the processor library routines. Then, the preprocessor accepts the user's driving logic, written in the TRASYS modified FORTRAN language. In many cases, the user has a choice of routines to solve a given problem. Users may also provide their own routines where desirable. In particular, the user may write output routines to provide for an interface between TRASYS and any thermal analyzer program using the R-C network concept. Input to the TRASYS program consists of Options and Edit data, Model data, and Logic Flow and Operations data. Options and Edit data provide for basic program control and user edit capability. The Model data describe the problem in terms of geometry and other properties. This information includes surface geometry data, documentation data, nodal data, block coordinate system data, form factor data, and flux data. Logic Flow and Operations data house the user's driver logic, including the sequence of subroutine calls and the subroutine library. Output from TRASYS consists of two basic types of data: internode radiation interchange data, and incident and absorbed heat rate data. The flexible structure of TRASYS allows considerable freedom in the definition and choice of solution method for a thermal radiation problem. The program's flexible structure has also allowed TRASYS to retain the same basic input structure as the authors update it in order to keep up with changing requirements. Among its other important features are the following: 1) up to 3200 node problem size capability with shadowing by intervening opaque or semi-transparent surfaces; 2) choice of diffuse, specular, or diffuse/specular radiant interchange solutions; 3) a restart capability that minimizes recomputing; 4) <b>macroinstructions</b> that automatically provide the executive logic for orbit generation that optimizes the use of previously completed computations; 5) a time variable geometry package that provides automatic pointing of the various parts of an articulated spacecraft and an automatic look-back feature that eliminates redundant form factor calculations; 6) capability to specify submodel names to identify sets of surfaces or components as an entity; and 7) subroutines to perform functions which save and recall the internodal and/or space form factors in subsequent steps for nodes with fixed geometry during a variable geometry run. There are two machine versions of TRASYS v 27 : a DEC VAX version and a Cray UNICOS version. Both versions require installation of the NASADIG library (MSC- 21801 for DEC VAX or COS- 10049 for CRAY), which is available from COSMIC either separately or bundled with TRASYS. The NASADIG (NASA Device Independent Graphics Library) plot package provides a pictorial representation of input geometry, orbital/orientation parameters, and heating rate output as a function of time. NASADIG supports Tektronix terminals. The CRAY version of TRASYS v 27 is written in FORTRAN 77 for batch or interactive execution and has been implemented on CRAY X-MP and CRAY Y-MP series computers running UNICOS. The standard distribution medium for MSC- 21959 (CRAY version without NASADIG) is a 1600 BPI 9 -track magnetic tape in UNIX tar format. The standard distribution medium for COS- 10040 (CRAY version with NASADIG) is a set of two 6250 BPI 9 -track magnetic tapes in UNIX tar format. Alternate distribution media and formats are available upon request. The DEC VAX version of TRASYS v 27 is written in FORTRAN 77 for batch execution (only the plotting driver program is interactive) and has been implemented on a DEC VAX 8650 computer under VMS. Since the source codes for MSC- 21030 and COS- 10026 are in VAX/VMS text library files and DEC Command Language files, COSMIC will only provide these programs in the following formats: MSC- 21030, TRASYS (DEC VAX version without NASADIG) is available on a 1600 BPI 9 -track magnetic tape in VAX BACKUP format (standard distribution medium) or in VAX BACKUP format on a TK 50 tape cartridge; COS- 10026, TRASYS (DEC VAX version with NASADIG), is available in VAX BACKUP format on a set of three 6250 BPI 9 -track magnetic tapes (standard distribution medium) or a set of three TK 50 tape cartridges in VAX BACKUP format. TRASYS was last updated in 1993...|$|R

