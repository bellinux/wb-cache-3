1113|69|Public
5|$|COBOL's syntax {{is usually}} {{described}} {{with a unique}} <b>metalanguage</b> using braces, brackets, bars and underlining. The <b>metalanguage</b> was developed for the original COBOL specifications. Although Backus–Naur form did exist at the time, the committee had not heard of it.|$|E
25|$|The undefinability theorem {{shows that}} this {{encoding}} cannot be done for semantic concepts such as truth. It shows that no sufficiently rich interpreted language can represent its own semantics. A corollary is that any <b>metalanguage</b> capable of expressing the semantics of some object language must have expressive power exceeding that of the object language. The <b>metalanguage</b> includes primitive notions, axioms, and rules absent from the object language, {{so that there are}} theorems provable in the <b>metalanguage</b> not provable in the object language.|$|E
25|$|This {{defines a}} <b>metalanguage</b> stack of {{increasing}} capability to resolve undecidability in the autonomous lower levels. If someone near process level needs to innovate to achieve potential, or restore capability, help can {{be secured from}} management of higher variety.|$|E
50|$|The {{front end}} accepts the grammar <b>metalanguages</b> as an input.|$|R
50|$|There are {{a variety}} of {{recognized}} <b>metalanguages,</b> including embedded, ordered, and nested (or, hierarchical).|$|R
50|$|The {{characteristics}} of the metaprogramming <b>metalanguages</b> above are common to all Schorre metacompilers and those derived from them.|$|R
25|$|Davidson's work is {{well noted}} for its unity, as he has brought a similar {{approach}} {{to a wide variety}} of philosophical problems. Radical interpretation is a hypothetical standpoint which Davidson regards as basic to the investigation of language, mind, action, and knowledge. Radical interpretation involves imagining that you are placed into a community which speaks a language you do not understand at all. How could you come to understand the language? One suggestion is that you know a theory that generates a theorem of the form 's means that p' for every sentence of the object language (i.e. the language of the community), where s is the name of a sentence in the object language, and p is that sentence, or a translation of it, in the <b>metalanguage</b> in which the theory is expressed. However, Davidson rejects that suggestion on the grounds that the sentential operator 'means that' is sensitive not only to the extensions of the terms that follow it, but also to their intensions. Hence, Davidson replaces 'means that' with a connective sensitive only to the extensions of sentences; since the extension of a sentence is its truth value, this is a truth functional connective. Davidson elects the biconditional (if and only if) as the connective needed in a theory of meaning. He concludes that a theory of meaning must be such that for each sentence of the object language it generates a theorem of the form 's is true if and only if p'. A theory of truth for a language can serve as a theory of meaning.|$|E
500|$|The COBOL {{community}} {{has always been}} isolated from the computer science community. No academic computer scientists participated {{in the design of}} COBOL: all of those on the committee came from commerce or government. [...] Computer scientists at the time were more interested in fields like numerical analysis, physics and system programming than the commercial file-processing problems which COBOL development tackled. Jean Sammet attributed COBOL's unpopularity to an initial [...] "snob reaction" [...] due to its inelegance, the lack of influential computer scientists participating in the design process and a disdain for business data processing. The COBOL specification used a unique [...] "notation", or <b>metalanguage,</b> to define its syntax rather than the new Backus–Naur form because few committee members had heard of it. This resulted in [...] "severe" [...] criticism.|$|E
500|$|Central to Whorf's {{inquiries}} was {{the approach}} later described as metalinguistics by G. L. Trager, who in 1950 published four of Whorf's essays as [...] "Four articles on Metalinguistics". Whorf was crucially {{interested in the}} ways in which speakers come {{to be aware of the}} language that they use, and become able to describe and analyze language using language itself to do so. Whorf saw that the ability to arrive at progressively more accurate descriptions of the world hinged partly on the ability to construct a <b>metalanguage</b> to describe how language affects experience, and thus to have the ability to calibrate different conceptual schemes. Whorf's endeavors have since been taken up in the development of the study of metalinguistics and metalinguistic awareness, first by Michael Silverstein who published a radical and influential rereading of Whorf in 1979 and subsequently in the field of linguistic anthropology.|$|E
50|$|These <b>metalanguages</b> {{have their}} own metasyntax each {{composed}} of terminal symbols, nonterminal symbols, and metasymbols. A terminal symbol, such as a word or a token, is a stand-alone structure in a language being defined. A nonterminal symbol represents a syntactic category, which defines one or more valid phrasal or sentence structure consisted of an n-element subset. Metasymbols provide syntactic information for denotational purposes in a given metasyntax. Terminals, nonterminals, and metasymbols do not apply across all <b>metalanguages.</b>|$|R
50|$|Metacompiler <b>metalanguages</b> are {{powerful}} string and symbol processing languages {{that are also}} useful for generating {{a wide range of}} other software engineering and analysis tools.|$|R
50|$|<b>Metalanguages</b> {{of formal}} systems all resolve {{ultimately}} to natural language, the 'common parlance' in which mathematicians and logicians converse {{to define their}} terms and operations and 'read out' their formulae.|$|R
2500|$|Romaneczko, Marta E. The Role of <b>Metalanguage</b> in [...] Radical Interpretation. Journal of Consciousness Studies. 2007.|$|E
2500|$|Ancient {{examples}} of acronymy (regardless {{of whether there}} was <b>metalanguage</b> {{at the time to}} describe it) include the following: ...|$|E
2500|$|Because {{mathematical}} logic {{has a long}} tradition of distinguishing between object language and <b>metalanguage,</b> logic programming also allows metalevel programming. [...] The simplest metalogic program is the so-called [...] "vanilla" [...] meta-interpreter: ...|$|E
40|$|Abstract. Agent {{communication}} languages such as KQML and the FIPA ACL {{serve as}} <b>metalanguages</b> to define software agent message-passing protocols. These <b>metalanguages</b> are incompatible with each other, preventing intercommunication between agents employing different agent communication languages. The primary hindrance to agent intercommunication is the different underlying semantics {{of the message}} passing protocols. Conceptual graphs provide a mechanism to bridge this agent communication barrier by representing the semantics of message-passing protocols in the formal representation of conceptual graphs. Semantic content of the KQML tell performative is contrasted {{with that of the}} FIPA ACL inform performative and represented in conceptual graphs. The intent is that software agents conversant in CGIF may intelligently translate messages between agents employing different agent communication languages. ...|$|R
40|$|Software is a {{communication}} system. The usual topic of communication is program behavior, as encoded by programs. Domainspecific libraries are codebooks, domain-specific languages are coding schemes, and so forth. To turn metaphor into method, we adapt tools from information theory—the study of efficient communication—to probe the efficiency with which languages and libraries let us communicate programs. In previous work we developed an information-theoretic analysis of software reuse in problem domains. This new paper uses information theory to analyze tradeoffs {{in the design}} of components, generators, and <b>metalanguages.</b> We seek answers to two questions: (1) How can we judge whether a component is over- or under-generalized? Drawing on minimum description length principles, we propose that the best component yields the most succinct representation of the use cases. (2) If we view a programming language as an assemblage of <b>metalanguages,</b> each providing a complementary style of abstraction, how can these <b>metalanguages</b> aid or hinder us in efficiently describing software? We describe a complex triangle of interactions between the power of an abstraction mechanism, the amount of reuse it enables, and the cognitive difficulty of its use. Categories and Subject Descriptors D. 2. 13 [Software Engineering]...|$|R
25|$|In sum, {{the primary}} tasks of sociological {{analysis}} are the following: (1) The hermeneutic explication and mediation of divergent {{forms of life}} within descriptive <b>metalanguages</b> of social science; (2) Explication of the production and reproduction of society as the accomplished outcome of human agency.|$|R
2500|$|<b>Metalanguage</b> {{and folk}} {{linguistics}} – It involves {{looking at the}} way these linguistic forms and changes on the Internet are labelled and discussed (e.g. impact of Internet lingo resulted in the 'death' of the apostrophe and loss of capitalization.) ...|$|E
2500|$|Informally, the theorem {{says that}} given some formal {{arithmetic}}, {{the concept of}} truth in that arithmetic is not definable using the expressive means that that arithmetic affords. This implies a major limitation on the scope of [...] "self-representation." [...] It is possible to define a formula True(n) whose extension is T*, but only by drawing on a <b>metalanguage</b> whose expressive power goes beyond that of L. For example, a truth predicate for first-order arithmetic can be defined in second-order arithmetic. However, this formula would {{only be able to}} define a truth predicate for sentences in the original language L. To define a truth predicate for the <b>metalanguage</b> would require a still higher [...] "metametalanguage", and so on.|$|E
2500|$|In 1968 Zellig Harris {{wrote that}} [...] "the <b>metalanguage</b> {{is in the}} language," [...] {{suggesting}} that self-replication is part of language. In 1977 Niklaus Wirth formalized this proposition by publishing a self-replicating deterministic context-free grammar. Adding to it probabilities, Bertrand du Castel published in 2015 a self-replicating stochastic grammar and presented a mapping of that grammar to neural networks, thereby presenting {{a model for a}} self-replicating neural circuit.|$|E
50|$|Metacompilers {{differ from}} parser generators. They take {{a program in}} a metaprogramming language, and have grammar {{analyzing}} rules and code production transforms that output executable code. They can be programmed in their own <b>metalanguages</b> enabling them to compile themselves, making them self-hosting extensible language compilers.|$|R
5000|$|In sum, {{the primary}} tasks of sociological {{analysis}} are the following: (1) The hermeneutic explication and mediation of divergent {{forms of life}} within descriptive <b>metalanguages</b> of social science; (2) Explication of the production and reproduction of society as the accomplished outcome of human agency.|$|R
40|$|A {{theory of}} truth is {{introduced}} {{for a first}} [...] order language L of set theory. Fully interpreted <b>metalanguages</b> which contain their truth predicates are constructed for L. The presented theory is free from infinite regress, whence it provides a proper framework to study the regress problem. Only ZF set theory, concepts definable in L and classical two-valued logic are used...|$|R
2500|$|In linguistics, the conduit {{metaphor is}} a {{dominant}} class of figurative expressions used when discussing communication itself (<b>metalanguage).</b> It operates whenever people speak or write {{as if they}} [...] "insert" [...] their mental contents (feelings, meanings, thoughts, concepts, etc.) into [...] "containers" [...] (words, phrases, sentences, etc.) whose contents are then [...] "extracted" [...] by listeners and readers. Thus, language {{is viewed as a}} [...] "conduit" [...] conveying mental content between people.|$|E
2500|$|The {{difference}} between implication [...] and inequality or entailment [...] or [...] {{is that the}} former is internal to the logic while the latter is external. Internal implication between two terms is another term of the same kind. Entailment as external implication between two terms expresses a metatruth outside {{the language of the}} logic, and is considered part of the <b>metalanguage.</b> Even when the logic under study is intuitionistic, entailment is ordinarily understood classically as two-valued: either the left side entails, or is less-or-equal to, the right side, or it is not.|$|E
2500|$|In {{describing}} the transformation rules, we may introduce a <b>metalanguage</b> symbol [...] It {{is basically a}} convenient shorthand for saying [...] "infer that". The format is , in which [...] is a (possibly empty) set of formulas called premises, and [...] is a formula called conclusion. The transformation rule [...] means that if every proposition in [...] is a theorem (or has the same truth value as the axioms), then [...] is also a theorem. Note that considering the following rule Conjunction introduction, we will know whenever [...] {{has more than one}} formula, we can always safely reduce it into one formula using conjunction. So for short, from that time on we may represent [...] as one formula instead of a set. Another omission for convenience is when [...] is an empty set, in which case [...] may not appear.|$|E
40|$|AbstractIn recent years, logical {{frameworks}} and tile logic {{have been}} separately proposed by our research groups, respectively in Udine and in Pisa, as suitable <b>metalanguages</b> with higher-order features for encoding and studying nominal calculi. This paper discusses {{the main features}} of the two approaches, tracing differences and analogies {{on the basis of}} two case studies: late π-calculus and lazy simply typed Λ-calculus...|$|R
50|$|PyX is a Python {{package for}} the {{creation}} of PostScript, PDF, and static SVG files. It combines an abstraction of the PostScript drawing model with a TeX/LaTeX interface. Complex tasks like 2d and 3d plots in publication-ready quality are built out of these primitives. Its goals {{are similar to those of}} other <b>metalanguages</b> for PDF drawing, such as TikZ or Asymptote.|$|R
40|$|AbstractWe {{introduce}} H-systems as language generators {{using the}} concept of homomorphic replacement of variables by words from <b>metalanguages.</b> This is a generalization of the hypernotion construct in van Wijngaarden grammars {{with a number of}} hard open problems. Here we concentrate on the generative power of the language families which result from varying the sets of axioms, resp. the sets of replacements, from ONE through the metalinear languages to CF...|$|R
2500|$|Alfred Tarski, a pupil of Łukasiewicz, is {{best known}} for his {{definition}} of truth and logical consequence, and the semantic concept of logical satisfaction. [...] In 1933, he published (in Polish) The concept of truth in formalized languages, in which he proposed his semantic theory of truth: a sentence such as [...] "snow is white" [...] is true if and only if snow is white. [...] Tarski's theory separated the <b>metalanguage,</b> which makes the statement about truth, from the object language, which contains the sentence whose truth is being asserted, and gave a correspondence (the T-schema) between phrases in the object language and elements of an interpretation. [...] Tarski's approach to the difficult idea of explaining truth has been enduringly influential in logic and philosophy, especially in the development of model theory. [...] Tarski also produced important work on the methodology of deductive systems, and on fundamental principles such as completeness, decidability, consistency and definability. According to Anita Feferman, Tarski [...] "changed the face of logic in the twentieth century".|$|E
50|$|An ordered <b>metalanguage</b> is {{analogous}} to ordered logic. An example of an ordered <b>metalanguage</b> is the construction of one <b>metalanguage</b> to discuss an object language, followed by the creation of another <b>metalanguage</b> to discuss the first, etc.|$|E
50|$|There {{are several}} {{entities}} commonly {{expressed in a}} <b>metalanguage.</b> In logic usually the object language that the <b>metalanguage</b> is discussing is a formal language, and very often the <b>metalanguage</b> as well.|$|E
40|$|A {{standard}} monad of continuations, when {{constructed with}} domains {{in the world}} of FM-sets [1], is shown to provide a model of dynamic allocation of fresh names that is both simple and useful. In particular, it is used to prove that the powerful facilities for manipulating fresh names and binding operations provided by the "FreshML" series of <b>metalanguages</b> [2 [...] 4] respect #-equivalence of object-level languages up to meta-level contextual equivalence...|$|R
40|$|ABSTRACT: This paper {{takes up}} the sea-faring metaphor at the centre of this special edition and asks what kinds of navigational tools (<b>metalanguages)</b> are {{necessary}} to steer English through the digital seas of contemporary communication. Much of this territory {{is yet to be}} mapped and the disciplinary “boat ” is buffeted by contrary winds such as pressures for improved outcomes on the basics and development of 21 st-century digital skills. The role of grammar as a navigational aid is complicated by these competing pressures. Alongside developing <b>metalanguages</b> to explore digital literacy practices in Web 2, in multimodal texts like picture books, websites and social networking sites, teachers are being asked simultaneously to prepare students for national testing regimes which assess children’s abilities to identify the correct verb, to underline the pronouns and to punctuate sentences in language convention tests. What kinds of grammar will enable us to manage such seemingly incongruous purposes? How do we make use of tools to improve students’ writing without succumbing to reductionist models of language? What kinds o...|$|R
40|$|Language Engineering aims at {{providing}} advanced {{techniques to}} design, implement and maintain languages or <b>metalanguages.</b> The Meta-Modeling Framework provides a method applying Object-Oriented modeling {{to the definition}} of languages, as well as a powerful meta-circular Meta-Modeling Language based on OCL, allowing language engineers to define high-quality languages at low cost. In order to per-form a better reusability, Language Engineering also provides language composition mechanisms, as composition of model elements, inspired by Software Engineering. ...|$|R
