0|98|Public
50|$|Due to the {{conditions}} in which the facts unraveled, and due to a <b>mutually</b> <b>suspicious</b> attitude of some of the involved parties, widely different accounts of the incident have been proposed.|$|R
5000|$|In September 1942, {{the group}} signed an {{agreement}} with the large left-wing Front de l'Indépendance group in order to co-ordinate their operations, however the groups were <b>mutually</b> <b>suspicious</b> and shared very different political ideologies which reduced their scope for greater collaboration.|$|R
40|$|ABSTRACT: We present {{security}} extensions to the RTI prototype {{developed at}} ONERA (Office National d'Etudes et de Recherches Aérospatiales). These extensions {{are aimed at}} guaranteeing secure interoperation of simulations belonging to various <b>mutually</b> <b>suspicious</b> organizations. The paper describes {{the design of a}} security architecture for HLA/RTI and its implementation. ...|$|R
40|$|This paper {{describes}} a capability-based {{access control mechanism}} implemented on a Java environment. In this scheme, access to objects is controlled by means of software capabilities that can be exchanged between <b>mutually</b> <b>suspicious</b> interacting applications. Each application defines the access control rules that must be enforced when interacting with other applications...|$|R
40|$|Every novel {{cooperative}} {{arrangement of}} <b>mutually</b> <b>suspicious</b> parties interacting electronically [...] - every smart contract [...] - effectively requires a new cryptographic protocol. However, if every new contract requires new cryptographic protocol design, our dreams of cryptographically enabled electronic commerce would be unreachable. Cryptographic protocol design is {{too hard and}} expensive, given our unlimited need for new contracts...|$|R
40|$|A fair {{exchange}} protocol is {{a protocol}} {{in which two}} (or more) <b>mutually</b> <b>suspicious</b> parties exchange their digital items {{in a way that}} neither party can gain an advantage over the other. Many fair exchange protocols have been proposed in the academic literature, but they provide rather different types of fairness. The formal comparison of these protocols has remained difficult, mainly {{because of the lack of}} a formal framework in which each can be modeled and formal definitions of fairness can be given. In this paper, weintroduce game theory as a formal tool to model exchange protocols. We give formal definitions of various types of fairness using standard notions of game theory, and showhow the defined fairness types are related to each other. Our results can serveas the foundations of the formal comparison of existing and future fair exchange protocols with respect to fairness. 1 Introduction Protocols that allowtwo (or more) <b>mutually</b> <b>suspicious</b> parties to exchange their dig [...] ...|$|R
40|$|Simultaneous {{contract}} signing is a two-party cryptographic protocol: two <b>mutually</b> <b>suspicious</b> parties wish {{to exchange}} signatures on a contract. We propose novel and efficient protocol for contract signing {{based on a}} construction by Even, Goldreich, and Lempel. We focus on the reduction of on-line computational complexity of the protocol. A {{significant part of the}} most time-consuming operations can be pre-computed. An important component used in our protocol is an efficient oblivious transfer, which can be of interest per se...|$|R
40|$|The Monash Multiprocessor Architecture {{incorporates}} a monetary {{system at the}} lowest kernel level, integrated with a password capability scheme. Although the capability scheme is quite flexible, providing support for non-hierarchic security and access policies, abstract type management and information confinement, we show {{that it is possible}} for service providers to command use-based fees for service. The fee charging protocols must be designed with some care to avoid breaching required information confinement constraints when user and provider are <b>mutually</b> <b>suspicious,</b> but need not be very complicated. 1...|$|R
40|$|This paper {{describes}} JCCap, {{a protection}} facility for cooperating {{applications in the}} context of Java Card. It enables the control of access rights between <b>mutually</b> <b>suspicious</b> applications, either between one terminal application and one Java Card applet or between two applets hosted inside the same Java Card. Using JCCap, access to objects is controlled by means of software capabilities that can be exchanged between <b>mutually</b> <b>suspicious</b> applications. An important advantage of JCCap is that the definition of the protection policy of an application (i. e., how access rights are granted to other applications) is completely separated from the application code. The protection policy is described in an extended Interface Definition Language (IDL) at the interface level, thus enhancing modularity, separation of concerns, and ease of expression {{in the design of the}} overall security architecture. Each application can define its own protection policy independently from the other applications, thus enabling the expression of mutual suspicion without any prior knowledge about the policies of other applications. Every protection policy is then applied when applications interact with each other. This paper describes the implementation of a prototype of JCCap and experiments with simple Java Card-based applications. Reported results show the feasibility and applicability of this technique in today's Java Card and outline its advantages. ...|$|R
50|$|EAM-ELAS, EDES and EKKA were <b>mutually</b> <b>suspicious</b> and {{tensions}} were exacerbated {{as the end}} of the war became nearer and the question of the country's political future arose. The role of the British military mission in these events proved decisive. EAM was by far the largest and most active group but was determined to achieve its own political goal to dominate postwar Greece, and its actions were not always directed against the Axis powers. Consequently, British material support was directed mostly to the more reliable Zervas, who by 1943 had reversed his earlier anti-monarchist stance.|$|R
40|$|This {{research}} {{investigate the}} concept of secret sharing scheme based on Shamir's secret sharing. The goal {{of this research is}} to implement secret sharing scheme for collaborative access system which are ideally suited to application in which a group of <b>mutually</b> <b>suspicious</b> individuals with conflicting interest must cooperate. In (q,n) secret sharing, a quorum, q of a group of n users are allowed to access the system by having the quorum reconstruct a secret(key), less than quorum can gain no information. Lost or stolen share still ensure the security of resources...|$|R
40|$|A {{computer}} protection {{mechanism is}} a set of tools for controlling the actions of computations and safeguarding stored information. This paper describes a new mechanism, COPS, which is a kernel of data structures, primitive operations, and a monitor and is used to specify and enforce the capabilities of actors (processes and procedures). COPS can be used to implement a variety of security policies and systems and to enhance software reliability. Its tools are sufficient to solve problems in the areas of isolation, controlled sharing, restricted access, <b>mutually</b> <b>suspicious</b> interaction, and confinement. Key Words and phrases: protection, kernel, operating system, security, access control...|$|R
40|$|Abstract. Contracts enable <b>mutually</b> <b>suspicious</b> {{parties to}} {{cooperate}} safely through {{the exchange of}} rights. Smart contracts are programs whose behavior enforces {{the terms of the}} contract. This paper shows how such contracts can be specified elegantly and executed safely, given an appropriate distributed, secure, persistent, and ubiquitous computational fabric. JavaScript provides the ubiquity but must be significantly extended to deal with the other aspects. The first part of this paper is a progress report on our efforts to turn JavaScript into this fabric. To demonstrate the suitability of this design, we describe an escrow exchange contract implemented in 42 lines of JavaScript code...|$|R
40|$|This paper {{introduces}} traits. js, a small, portable trait composition {{library for}} Javascript. Traits are a more robust alternative to multiple inheritance and enable object composition and reuse. traits. js {{is motivated by}} two goals: first, it is an experiment in using and extending Javascript’s recently added meta-level object description format. By reusing this standard description format, traits. js can be made more interoperable with similar libraries, and even with built-in primitives. Second, traits. js makes it convenient to create “high-integrity ” objects whose integrity cannot be violated by clients, an important property {{in the context of}} interaction between <b>mutually</b> <b>suspicious</b> scripts...|$|R
40|$|Intellectuals in the post-Medieval West, {{striving for}} {{scholarly}} emancipation, developed methodologies to target {{so as to}} free themselves from the dominant Christian, largely Roman Catholic, intellectual tradition. Machiavelli was one such critic, calling for the repristination of pre-Christian classics. Such methodologies are never without an inherent quest for power. Machiavelli developed a Classicist, ‘heroic exemplar’ hermeneutic in order to extol the republicanist, manly, ferocious, imperialist virtues of Rome, vis-à-vis the divisive, meek, caring, justice-seeking, unpatriotic, Christian leaders of his day. He therefore initiated Modern ideological militaristic competitiveness with its <b>mutually</b> <b>suspicious</b> balance of powers practices. This article forms {{part of a series}} of articles on methodologies of targeting groups...|$|R
5000|$|Fay's {{conclusion}} {{was that all}} the European powers shared in the blame, {{but most of all}} the system of secret alliances that divided Europe after the Franco-Prussian War into two <b>mutually</b> <b>suspicious</b> camps of group solidarity, Triple Alliance against Triple Entente (Fay's student Allan B. Calhamer, would later develop and publish the game Diplomacy, based on this thesis) but that Austro-Hungary, Serbia and Russia were primarily responsible for the immediate cause of war's outbreak. Other forces besides militarism and nationalism were at work: the economics of imperialism and the newspaper press played roles. [...] Fay also wrote The Rise of Brandenburg-Prussia to 1786 (1937).|$|R
40|$|This {{dissertation}} {{considers the}} single sender, multiple receiver model of secure multicast communication. The {{goal is to}} develop schemes that have reduced computational overhead {{at the time of}} key generation, minimize the amount of message units required at the time of key updates, andminimize the number of keys to be stored by the sender as well as receivers. In order to achieve this goal, a key generation and distribution architecture based on rooted trees and control panels is proposed. A control panel is assumed to consist of <b>mutually</b> <b>suspicious</b> members who jointly generate the keys that are distributed {{to the rest of the}} members. Based on the assumption about the control panel, we provide a distributed key generation mechanism which allows a set of <b>mutually</b> <b>suspicious</b> members to contribute to the generation of a joint secret without revealing their individual contributions. The key distribution scheme presented considers the member revocation event and relates it to the key assignment of individual users. We define and show that the entropy of the member revocation event plays an important role in determining the number of keys assigned to a member. We claim that the number of keys allocated to a member based on the elementary concepts from information theory will also correspond to the minimum number of keys that need to be assigned to a member unless additional functional relationship among keys exists, since it "completely captures" the uncertainty of the member revocation event. We also identify some weaknesses in the recent schemes, and solvean open problem posed at Eurocrypt' 99...|$|R
40|$|Abstract — The goal of {{this paper}} is to give an {{overview}} of security relevant aspects of existing data warehouse solutions. Data warehousing has increasingly become an important and rather essential phenomenon in the world of enter- prise data storage. It contains confidential and sensitive data. In order to use its data, you must have proper authorization. So that Access per-missions in data warehouse are currently managed in separate world from the source policies. The protection of data privacy and confidentiality in underlying warehouse is guaranteed through reliable security mea-sures in different area. In current ware house systems, the warehouse administrator is given complete authority to grant user permissions. We also propose different security policies to secure data from <b>mutually</b> <b>suspicious</b> parties...|$|R
40|$|We {{show that}} any {{function}} F can be securely evaluated by a protocolwith ballots and a ballot box. That is, N <b>mutually</b> <b>suspicious</b> players,each player possessing a secret input, can use ballots and a ballotbox to jointly evaluate F on their secret inputs so that (no matterhow many players may collude and deviate from their prescribed instructions, {{and no matter}} how long they compute!) each player learnsexactly the output of the function with the same privacy and correctnessas if all players privately handed their secret inputs to a trustedparty, who privately evaluates F and privately returns the outputs toeach player. Our protocol is (1) efficient, (2) enjoys perfect privacy, (3) guarantees perfect correctness, (4) is universally composable, and (5) is collusion-free even for games with secret actions...|$|R
40|$|We {{introduce}} {{and construct}} timed commitment schemes, an extension {{to the standard}} notion of commitments in which a potential forced opening phase permits the receiver to recover (with effort) the committed value {{without the help of}} the committer. An important application of our timed-commitment scheme is contract signing: two <b>mutually</b> <b>suspicious</b> parties wish to exchange signatures on a contract. We show a two-party protocol that allows them to exchange RSA or Rabin signatures. The protocol is strongly fair: if one party quits the protocol early, then the two parties must invest comparable amounts of time to retrieve the signatures. This statement holds even if one party has many more machines than the other. Other applications, including honesty preserving auctions and collective coin-flipping, are discussed...|$|R
40|$|We {{introduce}} traits. js, a small, portable trait composition {{library for}} Javascript. Traits are a more robust alternative to multiple inheritance and enable object composition and reuse. traits. js {{is motivated by}} two goals: first, it is an experiment in using and extending Javascript’s recently added meta-level object description format. By reusing this standard description format, traits. js can be made more interoperable with similar libraries, and even with built-in primitives. Second, traits. js makes it convenient to create “high-integrity” objects whose integrity cannot be violated by clients, an important property when web content is composed from <b>mutually</b> <b>suspicious</b> scripts. We describe the design of traits. js and provide an operational semantics for traits-js, a minimal calculus that models the core functionality of the library...|$|R
40|$|CACL is a {{protection}} scheme for objects {{that offers a}} simple and flexible model of protection and has an efficient, software-only implementation. The model, based on Access Control Lists (ACLs) integrated with the type system, allows owners to control who may invoke which methods on which objects, per-mits cooperation between <b>mutually</b> <b>suspicious</b> princi-pals, allows ownership of objects to be transferred safely, prevents unwanted propagation of authority between principals, and allows changes to the autho-rization information to take effect on the next method invocation. The implementation, based on the inte-gration of Capabilities with method dispatch, avoids the overhead of access checking {{in the majority of}} invocations, at the cost of space for extra dispatch vectors. CACL offers a viable mechanism for fine-grained protection in an object-oriented database sys-tem. ...|$|R
50|$|Japanese {{attitudes towards}} {{government}} {{have historically been}} shaped by Confucianism. Japan often {{has been defined as}} a Confucian country, but one in which loyalty is more important than benevolence. Leadership stemmed from the government and authority in general, and business looked to government for guidance. These attitudes, coupled with the view of the nation as a family, allowed government to influence business, and businesses worked hard not only for their own profits but also for national well-being. There was a national consensus that Japan must be an economic power and that the duty of all Japanese was to sacrifice themselves for this national goal. Thus, the relationship between government and business was as collaborators rather than as <b>mutually</b> <b>suspicious</b> adversaries.|$|R
40|$|When IPv 6 Neighbor and Router Discovery {{functions}} were defined, it {{was assumed}} that the local link would consist of mutually trusting nodes. However, the recent developments in public wireless networks, such as WLANs, have radically changed the situation. The nodes on a local link cannot necessarily trust each other any more, but they must become <b>mutually</b> <b>suspicious</b> even when the nodes have completed an authentication exchange with the network. This creates a number of operational difficulties and new security threats. In this paper we provide a taxonomy for the IPv 6 Neighbor and Router Discovery threats, describe two new cryptographic methods, Cryptographically Generated Addresses (CGA) and Address Based Keys (ABK), and discuss how these new methods can be used to secure the Neighbor and Router discovery mechanisms...|$|R
50|$|SentinelOne's core {{technology}} is behavior-based threat detection. Its Dynamic Behavior Tracking (DBT) Engine (a {{key component of}} SentinelOne's Endpoint and Critical Server Protection Platforms) utilizes sophisticated algorithms to map <b>suspicious</b> <b>processes</b> into malicious patterns. These patterns are then compared against a full context view of normal system and application behavior {{in order to determine}} if a threat exists.|$|R
40|$|A fair {{exchange}} protocol is a protocol, {{in which}} two (or more) <b>mutually</b> <b>suspicious</b> parties exchange their digital items {{in a way that}} neither party can gain an advantage over the other by misbehaving. Many fair exchange protocols have been proposed in the academic literature, but they provide rather different types of fairness. The formal comparison of these proposals remained diffcult, mainly, {{because of the lack of}} a common formal framework, in which each can be modelled and formal fairness defnitions can be given. In this paper, we propose to use game theory for this purpose. We show how to represent fair exchange protocols with game trees and give three defnitions of fairness using standard game theoretic notions. We are not aware of any other work that uses the apparatus of game theory for modelling fair exchange protocols...|$|R
40|$|A secure {{programming}} environment must offer protection mechanisms for regulating {{the interaction between}} <b>mutually</b> <b>suspicious</b> code units. Discretionary Capability Confinement (DCC) is a static type system recently proposed for expressing and enforcing access control policies in Java programs. This paper considers the computational complexity of the type reconstruction problem for DCC, that is, the automatic inference of DCC annotations for legacy Java code base. We model a representative subproblem of the type reconstruction problem as a graph-theoretic optimization problem. We demonstrate that this problem is NP-Complete. To strengthen the result, we further eliminate the asymmetry in the problem statement to obtain an elegant reformulation. We show that the reformulated problem is still NP-Complete. These results help identify the complexity core of the type reconstruction problem, and suggest that practical type reconstruction tool must adopt a heuristic and/or approximation approach. 1...|$|R
50|$|As an example, one {{technique}} for anonymous trade between <b>mutually</b> <b>suspicious</b> parties {{was for the}} offerers to lay the goods (such as gold) in a clearing (the potential common ground), and then {{to hide in the}} forest with the gold in their plain sight, while armed with weapons, in the event of treachery. Thus, the offers could be made to traders. The traders, who bore goods (and who were also armed with weapons), would lay the trade goods in the clearing, and take the gold back with them. This was a mechanism for trading between the Moors and the gold miners of Africa over a millennium ago, and also for trade with Sumatra (the isle of gold) and other islands of Southeast Asia. This has some structural similarity to the policy of mutually assured destruction during the Cold War era.|$|R
40|$|Mobile {{devices such}} as laptops, PDAs and cell phones are {{increasingly}} relied on but are used in contexts that put them at risk of physical damage, loss or theft. However, few mechanisms are available {{to reduce the risk}} of losing the data stored on these devices. In this dissertation, we try to address this concern by designing a cooperative backup service for mobile devices. The service leverages encounters and spontaneous interactions among participating devices, such that each device stores data on behalf of other devices. We first provide an analytical evaluation of the dependability gains of the proposed service. Distributed storage mechanisms are explored and evaluated. Security concerns arising from thecooperation among <b>mutually</b> <b>suspicious</b> principals are identified, and core mechanisms are proposed to allow them to be addressed. Finally, we present our prototype implementation of the cooperative backup servic...|$|R
40|$|Software {{capabilities}} {{are a very}} convenient means to protect cooperating applications. They allow access rights to be dynamically exchanged between <b>mutually</b> <b>suspicious</b> interacting applications. However, in all the proposed approaches, {{capabilities are}} made available at the programming language level, requiring application developers to wire protection definition in the application code, which is detrimental to both flexibility and reusability. We believe instead that capabilities should be hidden from the application programmer, allowing protection definition and application code to be clearly separated. In this paper, we propose a new protection model based on hidden software capabilities, in which protection definition is completely disjoined from the application code and described in an extended Interface Definition Language (IDL). This allows to specify protection for existing modules and to easily change the protection policy of an application. This protection model can be integ [...] ...|$|R
40|$|Coordination {{languages}} {{based on}} shared data spaces are {{well suited to}} programming parallel applications composed of cooperating software components. Secure Object Spaces (SOS) extend this model to support composition of independently developed, <b>mutually</b> <b>suspicious,</b> software components. SOS provides flexible and efficient security facilities based on a cryptographic re-interpretation of object types. We discuss the implementation of secure object spaces {{in the context of}} a Java-based mobile agent system. 1 Introduction Coordination languages based on shared data spaces have been around for over fifteen years. Oftentimes, researchers have advocated their use for structuring distributed and concurrent systems. This because the mode of communication provided by these languages, sometimes called generative communication, is anonymous [...] - processes interact by reading and writing entries in a shared space without having to know their interlocutor(s); and is uncoupled [...] - processes are not [...] ...|$|R
40|$|In this paper, we {{introduce}} {{the problem of}} private matchmaking. Private matchmaking is interesting because it has conflicting requirements for anonymity and authentication. A private matchmaking protocol allows two or more <b>mutually</b> <b>suspicious</b> parties with matching credentials to locate and authenticate each other without revealing their credentials or identities to anyone including the matchmaker. Private matchmaking is more than mutual authentication of suspicious parties in that it has further requirements on privacy and efficient locating. We present a simple and efficient solution to the private matchmaking problem without using public-key cryptography or a trusted matchmaker. Extensions and open problems are also discussed. 1 Introduction With the Internet growing at ever-increasing speeds and people using the Internet for both business and personal activities, privacy issues have become a major concern [9]. In this paper, we consider the problem of Private Matchmaking. Private [...] ...|$|R
50|$|The Treaty of Amiens in 1802 {{provided}} {{for a temporary}} truce in hostilities, only to be broken in 1804 when the British captured a Spanish treasure fleet off Cadiz. The French planned an invasion of England in the coming year; the Spanish fleet was to {{be an integral part}} in assisting this invasion. At the Battle of Trafalgar in 1805, the Spanish navy and the French Mediterranean fleet, attempting to join forces with the French fleets in the north for the invasion, were attacked by Admiral Lord Nelson {{at the head of a}} British fleet in one of history's greatest naval engagements. The disastrous defeat that the Spanish and French suffered assured British dominance at sea and seriously shook the resolve of the Spanish who began to doubt the usefulness of their always <b>mutually</b> <b>suspicious</b> alliance with Napoleon's regime.|$|R
40|$|Confined types {{enforce a}} form of {{encapsulation}} stronger than what the standard Java type system offers. It is known that confined types effectively prevent accidental reference leaks {{that could lead to}} security breaches in object-oriented programs. Because existing formulations of confined types target the Java source language, they can only be enforced by the code producer at compile time. As such these formulations fail to qualify as practical languagebased protection mechanisms for the Java platform. This paper presents a capability-based formulation of confined types for JVM bytecode, and reports the first implementation to enforce confined types at link time, on the code consumer side. This novel formulation of confined types is backward compatible, modular, and interoperable with lazy dynamic linking. The paper also demonstrates how this bytecode-level formulation of confined types can be applied to facilitate {{a form of}} secure cooperation between <b>mutually</b> <b>suspicious</b> code units. ...|$|R
40|$|This paper {{introduces}} {{the notion of}} a secret set [...] a basic construct for communication with groups of <b>mutually</b> <b>suspicious</b> entities. A set is secret if any entity can test its membership in the set but can determine neither the other set members nor the cardinality of the set. A number of possible secret set constructions are presented, analyzed and contrasted according to criteria such as: security (strength) as well as bandwidth and processing overheads. Example applications of secret sets are discussed. Keywords: secret sets, secret multicast, location secrecy, mobile networks. 1 Introduction Under certain conditions, electronic communication must be conducted in a manner that preserves the secrecy of either (or both) senders or receivers. While this is particularly applicable to military environments, similar requirements can also arise in civilian communications. For example, since mobile (especially, cellular) networks are often vulnerable to hostile eavesdropping, there is a n [...] ...|$|R
40|$|We {{report on}} the {{industrial}} application of VDM in an application for banknote processing. The SIC 2000 project at the GAO involved {{the development of a}} complex collection of <b>mutually</b> <b>suspicious</b> cooperating software components in a banknote processing system. The role of the formal specication in the project was twofold. It provided a framework in which explicit software invariants are used to reduce the potential of errors arising from the interplay of the cooperating components. It also enabled the construction of an executable system model during the process of designing an adaptive sensor integration subsystem. We present the lessons learned from this project and outline the expected perspectives for the future use of this kind of technology. 1 Introduction This paper reports on the use of VDM in the SIC 2000 (Sensor Integration Controller) project, which was undertaken at the GAO (Gesellschaft f 7 ̆fur Organisation und Automation) with the goal of expediting the integratio [...] ...|$|R
