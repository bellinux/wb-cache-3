113|122|Public
500|$|Python allows programmers {{to define}} their own types using classes, which are most often used for {{object-oriented}} programming. New instances of classes are constructed by calling the class (for example, SpamClass (...) or EggsClass (...) [...] ), and the classes are instances of the <b>metaclass</b> type (itself an instance of itself), allowing metaprogramming and reflection.|$|E
5000|$|As an example, a car object [...] is an {{instance}} of the class [...] In turn, the class [...] is again an object and as such {{an instance}} of the <b>metaclass</b> of [...] called [...] Note the blank {{in the name of}} the <b>metaclass.</b> The name of the <b>metaclass</b> is the Smalltalk expression that, when evaluated, results in the <b>metaclass</b> object. Thus evaluating [...] results in the <b>metaclass</b> object for [...] whose name is [...] (one can confirm this by evaluating [...] which returns the name of the <b>metaclass</b> of [...]) ...|$|E
50|$|Since <b>metaclass</b> objects do not behave {{differently}} (you cannot add class {{methods for}} a <b>metaclass,</b> so <b>metaclass</b> objects {{all have the}} same methods), they are all instances of the same class—the <b>metaclass</b> of the root class (unlike Smalltalk). Thus, the <b>metaclass</b> of the root class is an instance of itself. The {{reason for this is that}} all metaclasses inherit from root class; hence, they must inherit the class methods of the root class.|$|E
5000|$|Metamodeling with {{arbitrarily}} many abstraction levels (<b>metaclasses,</b> meta <b>metaclasses)</b> ...|$|R
5000|$|The {{superclass}} hierarchy for <b>metaclasses</b> parallels {{that for}} classes, except for class [...] ALL <b>metaclasses</b> are subclasses of , therefore: ...|$|R
2500|$|Thoroughly {{object-oriented}} with inheritance, mixins and <b>metaclasses</b> ...|$|R
50|$|ObjVlisp {{provided}} {{a far more}} flexible <b>metaclass</b> model than that provided by earlier object-oriented languages, especially Smalltalk. In Smalltalk-80, whenever a new class is created, a corresponding <b>metaclass</b> is created automatically; {{it does not have}} a name independent of that of the <b>metaclass</b> for which it was created-metaclasses are implicit rather than explicit. By contrast, in ObjVlisp, it is possible to define named metaclasses, and when defining a class one must specify which named <b>metaclass</b> it will instantiate.|$|E
50|$|Groovy's {{changes in}} code through {{prototyping}} are not visible in Java, since each attribute/method invocation in Groovy {{goes through the}} <b>metaclass</b> registry. The changed code can only be accessed from Java {{by going to the}} <b>metaclass</b> registry.|$|E
5000|$|The above example {{contains}} some redundant code {{to do with}} the four attributes , , , and [...] It is possible to eliminate some of this redundancy using a <b>metaclass.</b> In Python, a <b>metaclass</b> is most easily defined as a subclass of [...]|$|E
5000|$|<b>Metaclasses</b> are {{provided}} by the following programming languages: ...|$|R
5000|$|ObjVlisp is a 1984 {{object-oriented}} {{extension of}} Vlisp-Vincennes LISP, a LISP dialect developed since 1971 at the University of Paris VIII - Vincennes. It is noteworthy {{as one of}} the earliest implementations of the concept of <b>metaclasses,</b> and in particular explicit (as opposed to implicit) <b>metaclasses.</b> In the ObjVlisp model, [...] "each entity is an instance of a single class. Classes are instances of other classes, called <b>metaclasses.</b> This model allows for extension of the static part of OOL, i.e. the structural aspects of objects considered as implementation of abstract data types" ...|$|R
50|$|Logtalk, an {{object-oriented}} {{extension of}} Prolog, also supports <b>metaclasses.</b>|$|R
5000|$|In early Smalltalks, {{there was}} only one <b>metaclass</b> called [...] This implied that the methods all classes have were the same, in {{particular}} the method to create new objects, i.e., [...] To allow classes to have their own methods and their own instance variables (called class instance variables and {{should not be confused with}} class variables), Smalltalk-80 introduced for each class [...] their own <b>metaclass</b> [...] This means that each <b>metaclass</b> is effectively a singleton class.|$|E
50|$|Since all {{values are}} objects, classes {{themselves}} are also objects. Each class is {{an instance of}} the <b>metaclass</b> of that class. Metaclasses in turn are also objects, and are all {{instances of a class}} called <b>Metaclass.</b> Code blocks—Smalltalk's way of expressing anonymous functions—are also objects.|$|E
5000|$|<b>Metaclass</b> - {{initializing}} class variables, instance creation messages ...|$|E
50|$|<b>Metaclasses</b> are {{sometime}} {{organized by}} levels, {{in a similar}} way to the simple Theory of types where classes that are not <b>metaclasses</b> are assigned the first level, classes of classes in the first level are in the second level, classes of classes in the second level on the next and so on.|$|R
50|$|Resource Description Framework (RDF) and Unified Modeling Language (UML) both support <b>metaclasses.</b>|$|R
30|$|The Interaction Flow Modeling Language (IFML) is {{designed}} for expressing the content, user interaction and control behavior of the front-end of software applications. Its metamodel uses the basic data types from the UML metamodel, specializes a number of UML <b>metaclasses</b> {{as the basis for}} IFML <b>metaclasses,</b> and presumes that the IFML Domain Model is represented in UML.|$|R
5000|$|... #Caption: The Smalltalk-80 <b>metaclass</b> {{hierarchy}} as a UML diagram ...|$|E
50|$|In {{object-oriented}} programming, a <b>metaclass</b> is a class whose instances are classes. Just as {{an ordinary}} class defines {{the behavior of}} certain objects, a <b>metaclass</b> defines the behavior of certain classes and their instances. Not all object-oriented programming languages support metaclasses. Among those that do, {{the extent to which}} metaclasses can override any given aspect of class behavior varies. Metaclasses can be implemented by having classes be first-class citizen, in which case a <b>metaclass</b> is simply an object that constructs classes. Each language has its own metaobject protocol, a set of rules that govern how objects, classes, and metaclasses interact.|$|E
5000|$|<b>Metaclass</b> (Semantic Web), a {{featured}} {{allowed by}} OWL to represent knowledge ...|$|E
30|$|After that, many {{queries are}} {{performed}} over the KDM model {{to recover the}} application structure, which is represented by some instances of the KDM <b>metaclasses.</b> In our case, we recover all instances of StorableUnits (variables) and MethodUnits (methods) <b>metaclasses.</b> We have chosen these two source code elements because they are most suitable to find crosscutting concerns [32].|$|R
50|$|The {{following}} {{are some of the}} most prominent programming languages that support <b>metaclasses.</b>|$|R
5000|$|... #Caption: Diagram of the {{inheritance}} and instance relationships between classes and <b>metaclasses</b> in Smalltalk ...|$|R
5000|$|When {{a message}} {{is sent to}} [...] {{the search for the}} method starts in [...] and {{proceeds}} up the superclass chain to [...] Note that, so far, the <b>metaclass</b> inheritance chain exactly follows that of the class inheritance chain. But the <b>metaclass</b> chain extends further because [...] is the subclass of [...] All metaclasses are subclasses of Class.|$|E
5000|$|In Python, the builtin class [...] is a <b>metaclass.</b> Consider {{this simple}} Python class: ...|$|E
5000|$|... #Caption: {{an example}} of {{ontology}} with a first <b>metaclass</b> order: the classification of some chemical atoms ...|$|E
50|$|In the {{ontology}} editor Protégé, <b>metaclasses</b> are templates {{for other}} classes who are their instances.|$|R
50|$|Classes are {{first-class}} objects, and {{are themselves}} instances of classes called metaobject classes (<b>metaclasses</b> for short).|$|R
50|$|The Common Lisp Object System (CLOS) {{provides}} metaobject protocols (MOPs) {{to implement}} those classes and <b>metaclasses.</b>|$|R
5000|$|Like Smalltalk, in Objective-C, class {{methods are}} simply methods {{called on the}} class object, hence a class's class methods must be defined as {{instance}} methods in its <b>metaclass.</b> Because different classes can have different sets of class methods, each class must have its own separate <b>metaclass.</b> Classes and metaclasses are always created as a pair: the runtime has functions [...] and [...] to create and register class-metaclass pairs, respectively.|$|E
50|$|The {{explicit}} <b>metaclass</b> {{support in}} ObjVlisp influenced {{the provision of}} the same capability in the Common Lisp Object System.|$|E
5000|$|This <b>metaclass</b> only {{overrides}} object creation. All {{other aspects}} of class and object behavior are still handled by [...]|$|E
5000|$|Ruby purifies the Smalltalk-80 {{concept of}} <b>metaclasses</b> by {{introducing}} eigenclasses,removing the [...] class,and (un)redefining the class-of map.|$|R
50|$|<b>Metaclasses</b> are {{classes of}} classes. They are allowed in OWL full {{or with a}} feature called class/instance punning.|$|R
40|$|We {{describe}} a computationally reflective object-oriented architecture suitable for incorporating open-ended innovation and emergent entities into simulations. This allows emergent properties to be reified into objects. This requires modifying the model, and the metamodel, by incorporating novel classes and <b>metaclasses</b> dynamically. The classes and <b>metaclasses</b> are modified by including {{them in the}} model through reflection. We argue that such computationally reflective introduction of novelty is necessary for true open-ended simulations...|$|R
