841|100|Public
5|$|While all Debian {{releases}} {{are derived}} from the GNU Operating System and use the GNU userland and the GNU C library (glibc), other kernels aside from the Linux kernel are also available, such as those based on BSD kernels and the GNU Hurd <b>microkernel.</b>|$|E
5|$|Besides these distributions, {{there are}} some {{independent}} operating systems based on FreeBSD. DragonFly BSD is a fork from FreeBSD 4.8 aiming for a different multiprocessor synchronization strategy than the one chosen for FreeBSD 5 and development of some <b>microkernel</b> features. It does not aim to stay compatible with FreeBSD and has huge differences in the kernel and basic userland. MidnightBSD is a fork of FreeBSD 6.1 borrowing heavily from NeXTSTEP, particularly in the user interface department.|$|E
25|$|Additionally, QNX is a <b>microkernel</b> {{which is}} principally used in {{embedded}} systems, and the open-source software MINIX, while originally created for educational purposes, is now focussed {{on being a}} highly reliable and self-healing <b>microkernel</b> OS.|$|E
50|$|IPC is very {{important}} to the design process for <b>microkernels</b> and nanokernels. <b>Microkernels</b> reduce the number of functionalities provided by the kernel. Those functionalities are then obtained by communicating with servers via IPC, increasing drastically the number of IPC compared to a regular monolithic kernel.|$|R
5000|$|The {{traditional}} kernel {{categories are}} monolithic kernels and <b>microkernels</b> (with nanokernels and exokernels {{seen as more}} extreme versions of <b>microkernels).</b> The [...] "hybrid" [...] category is controversial, due to the similarity of hybrid kernels and ordinary monolithic kernels; the term has been dismissed by Linus Torvalds as simple marketing.|$|R
5|$|DragonFly's kernel is a hybrid, {{containing}} {{features of}} both monolithic and <b>microkernels,</b> {{such as the}} message passing capability of <b>microkernels</b> enabling larger portions of the OS to benefit from protected memory, as well as retaining the speed of monolithic kernels for certain critical tasks. The messaging subsystem being developed is {{similar to those found}} in <b>microkernels</b> such as Mach, though it is less complex by design. DragonFly's messaging subsystem has the ability to act in either a synchronous or asynchronous fashion, and attempts to use this capability to achieve the best performance possible in any given situation.|$|R
25|$|Although Mach, {{developed}} at Carnegie Mellon University from 1985 to 1994, is the best-known general-purpose <b>microkernel,</b> other microkernels {{have been developed}} with more specific aims. The L4 <b>microkernel</b> family (mainly the L3 and the L4 kernel) was created to demonstrate that microkernels are not necessarily slow. Newer implementations such as Fiasco and Pistachio are able to run Linux next to other L4 processes in separate address spaces.|$|E
25|$|In fact, as guessed in 1995, {{the reasons}} for the poor {{performance}} of microkernels might as well have been: (1) an actual inefficiency of the whole <b>microkernel</b> approach, (2) the particular concepts implemented in those microkernels, and (3) the particular implementation of those concepts. Therefore it remained to be studied if the solution to build an efficient <b>microkernel</b> was, unlike previous attempts, to apply the correct construction techniques.|$|E
25|$|From early on, the Hurd was {{developed}} to use GNU Mach as the <b>microkernel.</b> This was a technical decision made by Richard Stallman, who thought it would speed up the work by saving {{a large part of}} it. He has admitted that he was wrong about that. Other Unix-like systems working on the Mach <b>microkernel</b> include OSF/1, Lites, and MkLinux. macOS and NeXTSTEP use hybrid kernels based on Mach.|$|E
50|$|XNU is {{a hybrid}} kernel, {{containing}} features of both monolithic kernels and <b>microkernels,</b> {{attempting to make}} the best use of both technologies, such as the message passing ability of <b>microkernels</b> enabling greater modularity and larger portions of the OS to benefit from memory protection, and retaining the speed of monolithic kernels for some critical tasks.|$|R
5000|$|Jochen Liedtke (1953-2001), German {{computer}} scientist, {{noted for}} his work on <b>microkernels</b> ...|$|R
40|$|A {{paper by}} Hand et al. {{at the recent}} HotOS {{workshop}} re-examined <b>microkernels</b> and contrasted them to virtual-machine monitors (VMMs). It found that the two kinds of systems share architectural commonalities but also {{have a number of}} technical differences which the paper examined. It concluded that VMMs are a special case of <b>microkernels,</b> “microkernels done right”. A closer examination of that paper shows that it contains a number of statements which are poorly justified or even refuted by the literature. While we believe that it is indeed timely to reexamine the merits and issues of <b>microkernels,</b> such an examination needs to be based on facts. ...|$|R
25|$|The ext2 {{filesystem}} translator. It receives disk {{blocks from}} the <b>microkernel</b> and gives files and directories to the applications.|$|E
25|$|Memory organisation: this {{category}} contained settings {{related to the}} size of buffers the <b>Microkernel</b> needed to allocate for various purposes.|$|E
25|$|GNU Hurd {{consists}} {{of a set of}} protocols and server processes (or daemons, in Unix terminology) that run on the GNU Mach <b>microkernel.</b> The Hurd aims to surpass the Unix kernel in functionality, security, and stability, while remaining largely compatible with it. The GNU Project chose the multiserver <b>microkernel</b> for the operating system, due to perceived advantages over the traditional Unix monolithic kernel architecture, a view that had been advocated by some developers in the 1980s.|$|E
50|$|Like {{some other}} modern kernels, XNU is a hybrid, {{containing}} features of both monolithic and <b>microkernels,</b> {{attempting to make}} the best use of both technologies, such as the message passing capability of <b>microkernels</b> enabling greater modularity and larger portions of the OS to benefit from protected memory, as well as retaining the speed of monolithic kernels for certain critical tasks.|$|R
5000|$|Redox kernel: The Redox kernel largely {{derives from}} the concept of <b>microkernels,</b> with {{particular}} inspiration from MINIX.|$|R
50|$|In general, <b>microkernels</b> succeed {{when the}} task {{switching}} and intertask communication is fast and fail {{when they are}} slow.|$|R
25|$|The Darbat {{project is}} an {{experimental}} port of Darwin to the L4 <b>microkernel</b> family. It aims to be binary compatible with existing Darwin binaries.|$|E
25|$|<b>Microkernel</b> {{operating}} systems attempt {{to minimize the}} amount of code running in privileged mode, for purposes of security and elegance, but ultimately sacrificing performance.|$|E
25|$|Most micro kernels use {{a message}} passing system {{of some sort}} to handle {{requests}} from one server to another. The message passing system generally operates on a port basis with the <b>microkernel.</b> As an example, if a request for more memory is sent, a port is opened with the <b>microkernel</b> and the request sent through. Once within the <b>microkernel,</b> the steps are similar to system calls. The rationale {{was that it would}} bring modularity in the system architecture, which would entail a cleaner system, easier to debug or dynamically modify, customizable to users' needs, and more performing. They are part of the operating systems like AIX, BeOS, Hurd, Mach, macOS, MINIX, QNX. Etc. Although micro kernels are very small by themselves, in combination with all their required auxiliary code they are, in fact, often larger than monolithic kernels. Advocates of monolithic kernels also point out that the two-tiered structure of <b>microkernel</b> systems, in which most of the operating system does not interact directly with the hardware, creates a not-insignificant cost in terms of system efficiency. These types of kernels normally provide only the minimal services such as defining memory address spaces, Inter-process communication (IPC) and the process management. The other functions such as running the hardware processes are not handled directly by micro kernels. Proponents of micro kernels point out those monolithic kernels have the disadvantage that an error in the kernel can cause the entire system to crash. However, with a <b>microkernel,</b> if a kernel process crashes, it is still possible to prevent a crash of the system as a whole by merely restarting the service that caused the error.|$|E
50|$|Heiser's {{research}} {{focuses on}} <b>microkernels</b> and microkernel-based systemsas well as virtual machines, with a specific emphasis on performanceand reliability.|$|R
50|$|For efficiency, most <b>microkernels</b> contain schedulers {{and manage}} timers, in {{violation}} of the minimality principle and the principle of policy-mechanism separation.|$|R
2500|$|The {{performance}} of <b>microkernels</b> was poor {{in both the}} 1980s and early 1990s. However, studies that empirically measured the {{performance of}} these <b>microkernels</b> did not analyze the reasons of such inefficiency. The explanations of this data were left to [...] "folklore", {{with the assumption that}} they were due to the increased frequency of switches from [...] "kernel-mode" [...] to [...] "user-mode", to the increased frequency of inter-process communication and to the increased frequency of context switches.|$|R
25|$|A nanokernel delegates {{virtually}} all services including {{even the most}} basic ones like interrupt controllers or the timer to device drivers to make the kernel memory requirement even smaller than a traditional <b>microkernel.</b>|$|E
25|$|In a {{monolithic}} kernel, {{the operating system}} runs in supervisor mode and the applications run in user mode. Other types of operating systems, like those with an exokernel or <b>microkernel,</b> do not necessarily share this behavior.|$|E
25|$|The Amiga {{multitasking}} kernel {{was also}} one of the first to implement a <b>microkernel</b> OS methodology based on a real-time message passing (inter-process communication) core known as Exec (for executive) with dynamically loaded libraries and devices as optional modules around the core.|$|E
50|$|L4 is {{a family}} of second-generation <b>microkernels,</b> {{generally}} used to implement Unix-like operating systems, but also used {{in a variety of}} other systems.|$|R
50|$|These newer <b>microkernels</b> have revitalized the {{industry}} as a whole, and projects such as the GNU Hurd have received new attention as a result.|$|R
40|$|The {{future of}} {{supercomputing}} lies in massively parallel computers. The nodes of these machines {{will need a}} different kind of operating system than current computers have. Many researchers in the field believe that <b>microkernels</b> provide the kind of functionality and performance required. In this paper we discuss three popular <b>microkernels,</b> Amoeba, Mach, and Chorus, to show what they can do. They are compared and contrasted in the areas of process management, memory management, and communication. © 1995 Kluwer Academic Publishers...|$|R
25|$|In this configuration, the {{application}} makes {{calls to the}} Btrieve API, or <b>Microkernel</b> Interface (WBTRV32.DLL). The call is then processed by the interface and passed to the MKDE (W32MKDE.EXE) which uses the underlying operating system file system (whether it be network or local) to directly access the database files.|$|E
25|$|The {{alternative}} is formal software verification, which uses mathematical proof techniques {{to show the}} absence of bugs. Researchers at NICTA and its spinout Open Kernel Labs have recently performed such a formal verification of , {{a member of the}} L4 <b>microkernel</b> family, proving functional correctness of the C implementation of the kernel.|$|E
25|$|The first {{formally}} verified <b>microkernel,</b> seL4, used Haskell as a prototyping {{language for}} the OS developer. At the same time, the Haskell code defined an executable specification {{with which to}} reason, for automatic translation by the theorem-proving tool. The Haskell code thus served as an intermediate prototype before final C refinement.|$|E
50|$|While {{these results}} {{demonstrate}} that the poor performance of systems based on first-generation <b>microkernels</b> is not representative for second-generation kernels such as L4, this constitutes no proof that microkernel-based systems can be built with good performance. It {{has been shown that}} a monolithic Linux server ported to L4 exhibits only a few percent overhead over native Linux.However, such a single-server system exhibits few, if any, of the advantages <b>microkernels</b> are supposed to provide by structuring operating system functionality into separate servers.|$|R
50|$|Although major work on <b>microkernels</b> {{had largely}} ended, experimenters {{continued}} development. It {{has since been}} shown {{that many of the}} performance problems of earlier designs were not a fundamental limitation of the concept, but instead due to the designer's desire to use single-purpose systems to implement as many of these services as possible. Using a more pragmatic approach to the problem, including assembly code and relying on the processor to enforce concepts normally supported in software led to a new series of <b>microkernels</b> with dramatically improved performance.|$|R
40|$|Abstract—This work {{analyzes}} the performance increases gained from enabling Swift applications {{to utilize the}} GPU through the GeMTC Framework. By identifying computationally intensive portions of Swift applications, we can easily turn these code blocks into GeMTC <b>microkernels.</b> Users can then call these <b>microkernels</b> throughout the lifetime of their Swift application. The GeMTC API handles task overlap and data movement, providing transparent GPU acceleration for the user. This work highlights preliminary performance results from the scientific application MDProxy. This application determines the energy of particles in a modeled universe as they move around in space...|$|R
