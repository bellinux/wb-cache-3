0|10000|Public
50|$|UsiXML (<b>USer</b> <b>Interface</b> eXtensible Markup Language) is an XML-based {{specification}} language for <b>user</b> <b>interface</b> design. It supports {{the description of}} UI for multiple contexts of use such as Character <b>User</b> <b>Interfaces</b> (CUIs), Graphical <b>User</b> <b>Interfaces</b> (GUIs), Auditory <b>User</b> <b>Interfaces,</b> and Multimodal <b>User</b> <b>Interfaces.</b>|$|R
40|$|We address current {{research}} concerning patterns dedicated to enable higher reusability during the automated development of GUI systems. <b>User</b> <b>interface</b> patterns are promising artifacts for improvements in this regard. Both general models for abstractions of graphical <b>user</b> <b>interfaces</b> and <b>user</b> <b>interface</b> pattern based {{concepts such as}} potential notations and model-based processes are considered. On that basis, the present limitations and potentials surrounding <b>user</b> <b>interface</b> patterns are to be investigated. We elaborate what theoretical implications emerge from <b>user</b> <b>interface</b> patterns applied for reuse and automation within <b>user</b> <b>interface</b> transformation steps. For this purpose, formal descriptions of <b>user</b> <b>interface</b> patterns are necessary. We analyze {{the capabilities of the}} mature XML-based <b>user</b> <b>interface</b> description languages UIML and UsiXML to express <b>user</b> <b>interface</b> patterns. Additionally, we experimentally investigate and analyze strengths and weaknesses of two general transformation approaches to derive practical implications of <b>user</b> <b>interface</b> patterns. As a result, we develop suggestions on how to apply positive effects of <b>user</b> <b>interface</b> patterns for the development of pattern-based graphical <b>user</b> <b>interfaces...</b>|$|R
40|$|This paper {{discusses}} supportive <b>user</b> <b>interfaces</b> as {{a special}} kind of distributed <b>user</b> <b>interfaces.</b> It introduces tangible objects as elements of a supportive <b>user</b> <b>interface</b> and discusses the role of metaphors. Furthermore, the role of supportive <b>user</b> <b>interfaces</b> for implementing the usability criteria of task migratability in smart environments is discussed. Some challenges are identified and the combination of tangible <b>user</b> <b>interfaces</b> and graphical <b>user</b> <b>interfaces</b> is suggested...|$|R
40|$|Abstract — We address current {{research}} concerning patterns dedicated to enable higher reusability during the automated development of GUI systems. <b>User</b> <b>interface</b> patterns are promising artifacts for improvements in this regard. Both general models for abstractions of graphical <b>user</b> <b>interfaces</b> and <b>user</b> <b>interface</b> pattern based {{concepts such as}} potential notations and model-based processes are considered. On that basis, the present limitations and potentials surrounding <b>user</b> <b>interface</b> patterns are to be investigated. We elaborate what theoretical implications emerge from <b>user</b> <b>interface</b> patterns applied for reuse and automation within <b>user</b> <b>interface</b> transformation steps. For this purpose, formal descriptions of <b>user</b> <b>interface</b> patterns are necessary. We analyze {{the capabilities of the}} mature XML-based <b>user</b> <b>interface</b> description languages UIML and UsiXML to express <b>user</b> <b>interface</b> patterns. Additionally, we experimentally investigate and analyze strengths and weaknesses of two general transformation approaches to derive practical implications of <b>user</b> <b>interface</b> patterns. As a result, we develop suggestions on how to apply positive effects of <b>user</b> <b>interface</b> patterns for the development of pattern-based graphical <b>user</b> <b>interfaces...</b>|$|R
40|$|In {{this paper}} we {{investigate}} {{what is needed}} to make <b>user</b> <b>interface</b> builders incrementally refinable. The need for dedicated <b>user</b> <b>interface</b> builders is motivated by drawing a parallel with programming language design and object-oriented application frameworks. We show that reflection techniques borrowed from the programming language community can be successfully applied to make <b>user</b> <b>interface</b> builders incrementally refinable. KEY WORDS: <b>User</b> <b>Interfaces,</b> <b>User</b> <b>Interface</b> Builder, Object-oriented Framework, Reflection. 1. Introduction Graphical <b>user</b> <b>interfaces</b> for workstation applications are inherently difficult to build. To help programmers create such interfaces, tools are being developed. Those tools range from tool kits (libraries providing primitive building blocks for managing simple widgets, sometimes machine dependent) to <b>user</b> <b>interface</b> management systems (application frameworks and <b>user</b> <b>interface</b> builders supporting higher level <b>user</b> <b>interface</b> concepts). The major goal of tho [...] ...|$|R
40|$|We {{have applied}} {{interaction}} acts, an abstract user-service interaction specification, to speech <b>user</b> <b>interfaces</b> to investigate {{how well it}} lends itself to {{a new type of}} <b>user</b> <b>interface.</b> We used interaction acts to generate VoiceXML-based speech <b>user</b> <b>interface,</b> and identified two main issues connected to the differences between graphical <b>user</b> <b>interfaces</b> and speech <b>user</b> <b>interfaces.</b> The first issue concerns the structure of the <b>user</b> <b>interface.</b> Generating speech <b>user</b> <b>interfaces</b> and GUIs from the same underlying structure easily results in a too hierarchical and difficult to use speech <b>user</b> <b>interface.</b> The second issue is user input. Interpreting spoken user input is fundamentally different from user input in GUIs. We have shown {{that it is possible to}} generate speech <b>user</b> <b>interfaces</b> based on. A small user study supports the results. ...|$|R
40|$|This {{bachelor}} {{thesis is}} focused on design and execution of <b>user</b> <b>interface</b> of mobile applications for the Windows Phone operating system. The main objective is to extend the MMSP methodology by the support of mobile applications' <b>user</b> <b>interface</b> design. Another objective is to compare <b>user</b> <b>interface</b> of the major mobile operating systems (Anroid and iOS) with Windows Phone, and thus to identify advantages of Windows Phone <b>user</b> <b>interface</b> for ordinary <b>users.</b> The thesis is divided as follows: the first part describes <b>user</b> <b>interface</b> of the major mobile operating systems and identifies advantages of the Windows Phone operating system for ordinary users by comparing it {{with the rest of}} the major operating systems. The thesis further deals with execution of the MMSP methodology. Firstly, the methodology is extended by the task of mobile application <b>user</b> <b>interface</b> design. This describes the principles of <b>user</b> <b>interface</b> design. Furthermore, the role of the mobile application <b>user</b> <b>interface</b> designer, who is responsible for the design of <b>user</b> <b>interface</b> is defined. The thesis describes the possibilities of Windows Phone <b>user</b> <b>interface</b> applications, so that they are comprehensible to the <b>user</b> <b>interface</b> designers. Moreover, the thesis evaluates the application support of <b>user</b> <b>interface</b> application creation for Windows Phone, in the last chapter. The thesis extends the MMSP methodology, in a way that it supports <b>user</b> <b>interface</b> design. The thesis also creates a comprehensive summary of Windows Phone <b>user</b> <b>interface</b> and its operating elements, which has not been available in Czech until now...|$|R
40|$|M. Com. (Informatics) In {{this study}} {{the issue on}} <b>User</b> <b>Interface</b> Management Systems (UIMSs) is addressed. Specific {{attention}} {{is given to the}} design principles regarding development of <b>user</b> <b>interface</b> management systems that allow the creation of graphical <b>user</b> <b>interfaces</b> for existing text-oriented command-line applications. As an introduction the concept of <b>user</b> <b>interface</b> management systems is discussed and a working and formal definition is derived. Thereafter a survey is discussed concerning <b>user</b> <b>interface</b> tools. A <b>user</b> <b>interface</b> management system architecture is proposed; planning, design and development aspects of <b>user</b> <b>interface</b> management systems are addressed, and the effect of human factors in the design of a <b>user</b> <b>interface</b> management system is discussed. Attention is also given to various interaction and dialogue models [...] ...|$|R
5000|$|UIML (<b>User</b> <b>Interface</b> Markup Language) is an XML-based <b>user</b> <b>interface</b> markup {{language}} for defining <b>user</b> <b>interfaces</b> on computers.Basically UIML tries {{to reduce the}} work needed to develop <b>user</b> <b>interfaces.</b> It allows you to describe the <b>user</b> <b>interface</b> in declarative terms (i.e. as text) and abstract it. Abstracting means that you don't exactly specify how the <b>user</b> <b>interface</b> is going to look, but rather what elements are to be shown, and how should they behave. For example, to describe a message window, you could write: ...|$|R
40|$|<b>User</b> <b>interfaces</b> often {{account for}} a {{majority}} of application code and defects. High quality <b>user</b> <b>interfaces</b> come with equally high development costs ? lower than the cost of multitudes of users coping with low quality <b>user</b> <b>interfaces,</b> but higher than the mild frustration experienced by any individual user. Thus, the economics of software lead to a situation where barely passable <b>user</b> <b>interfaces</b> abound. That most <b>user</b> <b>interface</b> code comes from bespoke attempts to implement vague human interface guidelines is a leading cause of high cost and low quality. This thesis introduces a novel formalism for <b>user</b> <b>interfaces</b> based on ordered constraint systems. Using explicit models for the values and relationships in a <b>user</b> <b>interface,</b> several reusable algorithms are defined for rich <b>user</b> <b>interface</b> behaviors, including value propagation, dataflow visualization, pinning, scripting, command activation, widget enablement, and context-sensitive help. Developers can leverage provably correct implementations of such desirable features for free, raising the quality of <b>user</b> <b>interfaces</b> while lowering their production cost. Some of these behaviors have been implemented in a JavaScript framework, Hot-Drink, for web <b>user</b> <b>interfaces,</b> and a C++ framework, Adam, for desktop <b>user</b> <b>interfaces.</b> Experiments have demonstrated higher developer productivity, fewer lines of code, fewer defects, and fewer components when compared to conventional <b>user</b> <b>interface</b> frameworks...|$|R
40|$|Most present HCI design {{patterns}} and pattern languages {{are based on}} the traditional <b>user</b> <b>interfaces,</b> i. e., the graphical <b>user</b> <b>interfaces.</b> However, with growing popularity of computers, <b>user</b> <b>interfaces</b> for HCI are being integrated in more and more application domains. Today, large amount of <b>user</b> <b>interfaces</b> go beyond the desktop metaphor, which results in complexity and diversity in <b>user</b> <b>interface</b> design. To aid designing these <b>user</b> <b>interfaces,</b> I am involved in using and developing the related HCI {{design patterns}} and pattern languages. In this paper, through the practice of developing <b>user</b> <b>interfaces</b> for control a model robot, I conclude that application domain patterns are also critical to an HCI pattern language...|$|R
40|$|Part 2 : Late Breaking ResultsInternational audienceCurrent <b>user</b> <b>interface</b> {{modeling}} languages usually {{focus on}} modeling a single <b>user</b> <b>interface</b> {{and have a}} fixed set of <b>user</b> <b>interface</b> components; adding another <b>user</b> <b>interface</b> component requires {{an extension of the}} language. In this paper we present CASSIS, a concise language that supports creation of <b>user</b> <b>interface</b> components using models instead of language extensions. It also allows the specification of design-time and runtime <b>user</b> <b>interface</b> variations. The support for variations has been used to generate constraints for custom <b>user</b> <b>interface</b> components, to specify design patterns and design decisions. CASSIS has been used in several projects including a multi-disciplinary applied research project...|$|R
40|$|GUI builder {{tools are}} widely used in {{practice}} to develop the <b>user</b> <b>interface</b> of software systems. Typically they are visual programming tools that support direct-manipulative assembling of the <b>user</b> <b>interface</b> components. We have developed the tool GuiBuilder to facilitate model-driven development of graphical and multimedia <b>user</b> <b>interfaces.</b> <b>User</b> <b>interface</b> developers can model {{the structure of the}} <b>user</b> <b>interface</b> with compositional presentation diagrams and its behaviour with hierarchical statechart diagrams. GuiBuilder then supports the transformation of the model to Java, i. e., the generation of a working <b>user</b> <b>interface</b> and the simulation of the modelled behaviour. Interactive sessions with the <b>user</b> <b>interface</b> can be recorded and replayed...|$|R
5000|$|Text-based <b>user</b> <b>interface</b> (TUI), {{also called}} textual <b>user</b> <b>interface</b> or {{terminal}} <b>user</b> <b>interface,</b> is a retronym coined sometime after {{the invention of}} graphical <b>user</b> <b>interfaces.</b> TUIs display computer graphics in text mode. An advanced TUI may, like GUIs, use the entire screen area and accept mouse and other inputs.|$|R
40|$|Abstract. Currently, it is {{difficult}} for a designer to create <b>user</b> <b>interfaces</b> that are of high aesthetic quality for a continuously growing range of devices with varied screen sizes. Most existing approaches use abstractions that only support form based <b>user</b> <b>interfaces.</b> These <b>user</b> <b>interfaces</b> may be usable but are of low aesthetic quality. In this paper, we present a technique to design adaptive graphical <b>user</b> <b>interfaces</b> by example (i. e. <b>user</b> <b>interfaces</b> that can adapt to the target platform, the user, etc.), which can produce <b>user</b> <b>interfaces</b> of high aesthetic quality while reducing the development cost inherent to manual approaches. Designing adaptive <b>user</b> <b>interfaces</b> by example could lead to a new generation of design tools that put adaptive <b>user</b> <b>interface</b> development within reach of designers as well as developers...|$|R
40|$|Abstract: An energy {{simulation}} tool {{is a tool}} {{to predict}} the energy consumption of a building. Today there are many energy simulation tools in the market. However, architects find that the existing energy simulation tools do not meet their needs. One thing that does not meet their need is the <b>user</b> <b>interface.</b> In relation to that, we carried out a <b>user</b> <b>interface</b> survey to know which <b>user</b> <b>interface</b> is preferred by architects. We found that architects prefer visual <b>user</b> <b>interface</b> (<b>user</b> <b>interface</b> that uses image) than textual <b>user</b> <b>interface</b> (<b>user</b> <b>interface</b> that merely uses text). In inputting value, they prefer to input it using drag-and-drop style rather than typing using keyboard. We also find that architects {{do not like to}} input too many values in the <b>user</b> <b>interface...</b>|$|R
40|$|Abstract. Constructing {{multi-device}} interfaces still presents major challenges, {{despite all}} {{efforts of the}} industry and several academic initiatives to develop usable solutions. One approach which is finding its way into general use, is XML-based <b>User</b> <b>Interface</b> descriptions to generate suitable <b>User</b> <b>Interfaces</b> for embedded systems and mobile computing devices. Another important solution is Model-based <b>User</b> <b>Interface</b> design, which evolved into a very suitable but academic approach for designing multi-device interfaces. We introduce a framework, Dygimes, which uses XML-based <b>User</b> <b>Interface</b> descriptions in combination with selected models, to generate <b>User</b> <b>Interfaces</b> for different kinds of devices at runtime. With this framework task specifications are combined with XMLbased <b>User</b> <b>Interface</b> building blocks to generate <b>User</b> <b>Interfaces</b> that can adapt to the context of use. The design of the <b>User</b> <b>Interface</b> and {{the implementation of the}} application code can be separated, while smooth integration of the functionality and the <b>User</b> <b>Interface</b> is supported. The resulting interface is location independent: it can migrate over devices while invoking functionality using standard protocols. ...|$|R
40|$|Declarative {{models can}} provide {{abstract}} descriptions of <b>user</b> <b>interfaces.</b> Therefore, {{it is desirable}} to use declarative models for designing <b>user</b> <b>interfaces</b> since complex details of the <b>user</b> <b>interfaces</b> can be avoided at the design time. However, declarative models are usually not able to describe all aspects required to generate <b>user</b> <b>interfaces...</b>|$|R
40|$|This report gives {{a survey}} of <b>user</b> <b>interface</b> {{languages}} and formal representations of <b>user</b> <b>interfaces.</b> The following aspects of <b>User</b> <b>Interface</b> Languages are considered: expressiveness; readability; evaluation (is it possible to evaluate the ergonomic and functional quality of the <b>user</b> <b>interface</b> from the representation); manipulation; compilation/interpretation; possibility to include knowledge representation...|$|R
40|$|This {{bachelor}} thesis {{deals with}} the problem of <b>user</b> <b>interface</b> design. The goal of this thesis is to introduce the concept of the <b>user</b> <b>interface,</b> its types and terms of <b>user</b> <b>interface</b> including defining basic needs of the user related to this interface. Furthermore, this thesis introduce to reader concept of Human Computer Interaction and presents the basic rules and procedures of creating the <b>user</b> <b>interface.</b> These rules and procedures are in practical part applied to the specific <b>user</b> <b>interface</b> design of web application for benchmarking comparison of particular regions tourism strategies. Final result of this bachelor thesis is specific tested <b>user</b> <b>interface</b> on which bases are submitted final recommendations for creating ideal <b>user</b> <b>interface</b> for this application...|$|R
40|$|<b>User</b> <b>interface</b> {{modeling}} {{is a well}} accepted {{approach to}} handle increasing <b>user</b> <b>interface</b> complexity. The approach {{presented in this paper}} utilizes <b>user</b> <b>interface</b> models at runtime to provide a basis for <b>user</b> <b>interface</b> distribution and synchronization. Task and domain model synchronize workflow and dynamic content across devices and modalities. A cooking assistant serves as example application to demonstrate multimodality and distribution. Additionally a debugger allows the inspection of the underlying <b>user</b> <b>interface</b> models at runtime...|$|R
50|$|UsiXML (which {{stands for}} <b>User</b> <b>Interface</b> Extensible Markup Language) is a XML-compliant markup {{language}} {{that describes the}} UI for multiple contexts of use such as Character <b>User</b> <b>Interfaces</b> (CUIs), Graphical <b>User</b> <b>Interfaces</b> (GUIs), Auditory <b>User</b> <b>Interfaces,</b> and Multimodal <b>User</b> <b>Interfaces.</b> In other words, interactive applications with different types of interaction techniques, modalities of use, and computing platforms {{can be described in}} a way that preserves the design independently from peculiar characteristics of physical computing platform.|$|R
40|$|This paper {{describes}} a model-driven engineering approach for specifying, designing, and generating consistent behaviors in graphical <b>user</b> <b>interfaces</b> in multiple contexts of use, i. e. different users using different computing platforms in different physical environments. This methodological approach is structured {{according to the}} levels of abstraction of the Cameleon Reference Framework: task and domain, abstract <b>user</b> <b>interface,</b> concrete <b>user</b> <b>interface,</b> and final <b>user</b> <b>interface.</b> A behavior model captures the abstractions of the behavior in terms of abstract events and abstract behavior primitives {{in the same way}} a traditional presentation model may capture the abstraction of the visual components of a <b>user</b> <b>interface.</b> The behavior modeled at the abstract level is reified into a concrete <b>user</b> <b>interface</b> by model-to-model transformation. The concrete <b>user</b> <b>interface</b> leads to the final <b>user</b> <b>interface</b> running thanks to code by model-to-code generation...|$|R
40|$|This paper {{introduces}} a knowledge-based method for developing <b>user</b> <b>interfaces</b> based on generative patterns instead of descriptive patterns. The knowledge base contains generative patterns from which portions of previously designed <b>user</b> <b>interfaces</b> {{could be identified}} and re-applied to a new design case study by generating code from its functional pecifications. The method introduced in this paper is relying on models that are typically involved in <b>user</b> <b>interface</b> development such as task, domain, abstract <b>user</b> <b>interface,</b> concrete <b>user</b> <b>interface,</b> final <b>user</b> <b>interface,</b> context model, and mappings between them. In this way, any type of model can virtually {{be the source of}} a pattern and can be described, searched, matched, retrieved, and assembled together so as to create a new <b>user</b> <b>interface.</b> The method is supported by IDEALXML, a software {{that can be used for}} pattern-based design of <b>user</b> <b>interface</b> based on the USIXML <b>user</b> <b>interface</b> description language. In order to support pattern-based design, the USIXML language has been expanded with concepts addressing problems raised by pattern description and matching related to models pertaining to <b>user</b> <b>interface</b> development. This extension could also be considered as an extension of PLML (Pattern Language Markup Language) that has been introduced to uniformly represent <b>user</b> <b>interface</b> patterns...|$|R
40|$|The {{process of}} {{creating}} a <b>user</b> <b>interface</b> for any platform involves creating a visual design first and then implementing it using the desired <b>user</b> <b>interface</b> framework. This process can be complicated and lengthy – the code has to written individually when targeting multiple platforms, developer’s time is not efficiently used on writing repetitive boilerplate code and debugging common mistakes and pitfalls when using various <b>user</b> <b>interface</b> frameworks. This thesis attempts to solve the abovementioned problems by introducing an intermediate markup language and a tool prototype that automates the process of converting mock-up layered images of the <b>user</b> <b>interface</b> to actual <b>user</b> <b>interface</b> code for a target platform. This approach helps to improve the time of creating a working <b>user</b> <b>interface</b> by automating markup generation, thus {{reducing the amount of}} hand-written code and common bugs made by developers. In addition, one <b>user</b> <b>interface</b> mock-up can be converted to real <b>user</b> <b>interfaces</b> on multiple platforms by using the extensible architecture of the prototype thus eliminating the need to write individual code for every targeted platform. This thesis focuses heavily on Adobe Photoshop as the image editing tool and HTML and WPF/XAML as the target <b>user</b> <b>interface</b> frameworks. Asiasanat:user <b>interface,</b> layered image, <b>user</b> <b>interface</b> implementation, multi-platform <b>user</b> <b>interfaces,</b> automatisatio...|$|R
40|$|Abstract: Modern {{graphical}} <b>user</b> <b>interfaces</b> {{are based}} on the WIMP (Window, Icon, Menu, Pointing device) paradigm which has been introduced around 1980 and used without any dramatic change until today. In 2007, Microsoft introduced the Ribbon: a radically redesigned <b>user</b> <b>interface</b> for the Office suite as a reaction to increas-ing complexity of the Office suite <b>user</b> <b>interface</b> with each new version release. We carried out a qualitative user study on the Microsoft Word 2007 in order to analyse how the Ribbon <b>user</b> <b>interface</b> is accepted by <b>users.</b> Key–Words: <b>User</b> <b>interfaces,</b> WIMP paradigm, Ribbon <b>user</b> <b>interface,</b> <b>user</b> study, evaluation, qualitative approach. ...|$|R
40|$|Abstract: Task {{modeling}} {{has become}} one of the cornerstones of model-based <b>user</b> <b>interface</b> design. Although different task modeling approaches to <b>user</b> <b>interfaces</b> design have been pushed, ConcurTaskTrees notation is becoming a de facto standard in the design of <b>user</b> <b>interfaces</b> including task-based modeling techniques. In this paper, a task-based approach to <b>user</b> <b>interfaces</b> design is introduced inspired by ConcurTaskTrees (Paternò, 1999). This approach is supported by a tool, namely IDEALXML, that allows for the animation of the specified <b>user</b> <b>interfaces</b> to generate a hi-fi prototype of the future <b>user</b> <b>interface</b> while still in the first development stages...|$|R
40|$|I am {{exploring}} {{an approach}} to developing services with multiple <b>user</b> <b>interfaces</b> based on a high level description of the service. The description is made using interaction acts, which are primitives for describing user-service interaction in a device independent way. Device adapted <b>user</b> <b>interfaces</b> are generated based on interaction acts in combination with device and service specific presentation information. As a proof of concept, the approach is implemented in a working prototype that handles graphical <b>user</b> <b>interfaces,</b> web <b>user</b> <b>interfaces,</b> and speech <b>user</b> <b>interfaces</b> for our sample services. Future work will mainly concentrate on evaluation of the generated <b>user</b> <b>interfaces.</b> 1...|$|R
40|$|This thesis {{describes}} {{challenges in}} designing, developing and testing web <b>user</b> <b>interfaces.</b> It discusses human-computer interaction, communication channels and <b>user</b> <b>interface</b> analogy {{to the real}} world. <b>User</b> <b>interfaces</b> can be designed     to be optimal for a specific action or to suite the user. A design of <b>interfaces</b> focused on <b>users</b> utilize methods, such as gamification and improving user experience, which can improve <b>interface</b> usability. <b>User</b> <b>interface</b> development is demonstrated on     web page development. Further, the thesis describes 3 web <b>user</b> <b>interface</b> testing methods. The methods are demonstrated by designing, developing, and testing <b>user</b> <b>interface</b> of a web strategy game...|$|R
40|$|The {{notion of}} {{interactive}} multi-media systems is introduced. A {{brief review of}} <b>user</b> <b>interface</b> management systems is given and the ISA Dialog Manager with its main features is presented. Possible architectures for the extension of <b>user</b> <b>interface</b> management systems towards multimedia <b>user</b> <b>interface</b> management systems are discussed. The current implementation status of the Multimedia Builder, {{an extension of the}} ISA Dialog Manager and its future directions are outlined. The Multex system — a multimedia <b>user</b> <b>interface</b> management system based on the DIAMANT <b>user</b> <b>interface</b> management system is discusses as example of a multi-modal <b>user</b> <b>interface</b> management system...|$|R
5000|$|AES70 {{does not}} define {{controller}} <b>user</b> <b>interfaces</b> or <b>user</b> <b>interface</b> elements.|$|R
5000|$|... #Subtitle level 3: 1985: SAA <b>User</b> <b>Interface</b> or Text-Based <b>User</b> <b>Interface</b> ...|$|R
40|$|<b>User</b> <b>interfaces</b> {{determine}} the process support {{that is really}} delivered to the user. In order to support a process effectively, individually tailored <b>user</b> <b>interfaces</b> have to be provided. Most process centered software engineering environments (PSEEs) provide predefined <b>user</b> <b>interfaces,</b> but only low-level languages {{which can be used}} by customers to build process-specific <b>user</b> <b>interfaces...</b>|$|R
40|$|Creating novel <b>user</b> <b>interfaces</b> {{that are}} “natural ” and {{distributed}} is challenging for designers and developers. “Natural ” interaction techniques are barely standardized and {{in combination with}} distributed UIs additional technical difficulties arise. In this paper we present the lessons we have learned in developing several natural and distributed <b>user</b> <b>interfaces</b> and propose design patterns to support development of such applications. Author Keywords Post-WIMP, natural <b>user</b> <b>interfaces,</b> distributed <b>user</b> <b>interfaces,</b> zoomable <b>user</b> <b>interfaces,</b> design patterns. ACM Classification Keyword...|$|R
40|$|The Rational Unified Process (RUP) is a {{use case}} driven {{iterative}} software engineering process <b>User</b> <b>Interface</b> design within the RUP involves <b>user</b> <b>interface</b> modelling and <b>user</b> <b>interface</b> prototyping. This paper describes two support artefacts- extended tabular use cases and UI element clusters- which provide {{a bridge between}} these two activities. They provide support for 'flow of events' storyboarding, the clustering of <b>user</b> <b>interface</b> elements and identification of UML boundary classes, and the initial sketching of <b>user</b> <b>interface</b> prototypes...|$|R
40|$|GENIUS (GENerator for <b>user</b> <b>Interfaces</b> Using Software-ergonomic rules) {{comprises}} {{a method}} and the supporting tool {{environment for the}} generation of <b>user</b> <b>interfaces</b> from extended data models by means of software-ergonomic rules. The representation of the <b>user</b> <b>interface</b> is based on views defined for the data model. The basic dialogue structure {{is derived from the}} data model structure. This ensures the development of task-appropriate <b>user</b> <b>interfaces</b> by transferring the characteristics of the application domain and the user's tasks reflected in the data model to the dialogue structure. The automatic generation of the <b>user</b> <b>interface</b> from the defined views is carried out by a rule-based system with explicit design rules derived from existing guidelines. Output is generated for an existing <b>user</b> <b>interface</b> management system. The software-ergonomic rules in the generation process guarantee the consistent use of interaction objects and a uniformed dialogue structure. The use of the data model as t he starting point for the generation of the <b>user</b> <b>interface</b> ensures the integration of software engineering and <b>user</b> <b>interface</b> design by the consistent use of data for application and <b>user</b> <b>interface</b> development. The generation with GENIUS reduces the development effort and improves the quality of the <b>user</b> <b>interface...</b>|$|R
