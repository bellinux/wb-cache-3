1191|0|Public
5|$|As {{support for}} {{multiple}} instruction set architectures complicates symmetric <b>multiprocessing</b> (SMP) support, DragonFly BSD now limits its {{support to the}} x86-64 platform. DragonFly originally ran on the x86 architecture, however as of version 4.0 {{it is no longer}} supported. Since version 1.10, DragonFly supports 1:1 userland threading (one kernel thread per userland thread), which is regarded as a relatively simple solution that is also easy to maintain. Inherited from FreeBSD, DragonFly also supports multi-threading.|$|E
5|$|Describing {{the system}} in November 1988, Cray stated that the 12 times {{performance}} increase would {{be made up of}} a three times increase due to GaAs circuits, and four times due to the use of more processors. One of the problems with the Cray-2 had been poor <b>multiprocessing</b> performance due to limited bandwidth between the processors, and to address this the Cray-3 would adopt the much faster architecture used in the Cray Y-MP. This would provide a design performance of 8000 MIPS, or 16 GFLOPS.|$|E
5|$|Dillon started DragonFly in {{the belief}} that the methods and {{techniques}} being adopted for threading and symmetric <b>multiprocessing</b> in FreeBSD 5 would lead to poor system performance and cause maintenance difficulties. He sought to correct these suspected problems within the FreeBSD project. Due to ongoing conflicts with other FreeBSD developers over the implementation of his ideas, his ability to directly change the FreeBSD codebase was eventually revoked. Despite this, the DragonFly BSD and FreeBSD projects still work together contributing bug fixes, driver updates, and other system improvements to each other.|$|E
5|$|In November 2006, first-generation {{symmetric}} <b>multiprocessing</b> (SMP) {{clients were}} publicly released for open beta testing, {{referred to as}} SMP1. These clients used Message Passing Interface (MPI) communication protocols for parallel processing, as {{at that time the}} GROMACS cores were not designed to be used with multiple threads. This was the first time a distributed computing project had used MPI. Although the clients performed well in Unix-based operating systems such as Linux and macOS, they were troublesome under Windows. On January24, 2010, SMP2, the second generation of the SMP clients and the successor to SMP1, was released as an open beta and replaced the complex MPI with a more reliable thread-based implementation.|$|E
25|$|In 2006, native {{symmetric}} <b>multiprocessing</b> {{support was}} added to the runtime system and virtual machine.|$|E
25|$|Heap layout {{has been}} {{modified}} to provide higher performance on 64-bit and Symmetric <b>multiprocessing</b> (SMP) systems. The new heap structure {{is also more}} scalable and has low management overhead, especially for large heaps.|$|E
25|$|With {{the return}} of Jobs, this {{rebranding}} to version 8 also allowed Apple to exploit a legal loophole to terminate third-party manufacturers' licenses to System 7 and effectively shut down the Macintosh clone market. Later, Mac OS 8.1 finally added the new filesystem and Mac OS 8.6 updated the nanokernel to handle limited support for preemptive tasks. Its interface is <b>Multiprocessing</b> Services 2.x and later, {{but there is no}} process separation and the system still uses cooperative multitasking between processes. Even a process that is <b>Multiprocessing</b> Services-aware still has a portion that runs in the Blue Box—a task that also runs all single-threaded programs and the only task that can run 68k code.|$|E
25|$|An {{early and}} {{important}} application of CSP was its use for specification and verification of {{elements of the}} INMOS T9000 Transputer, a complex superscalar pipelined processor designed to support large-scale <b>multiprocessing.</b> CSP was employed in verifying the correctness of both the processor pipeline, and the Virtual Channel Processor which managed off-chip communications for the processor.|$|E
25|$|SCO {{has claimed}} {{a number of}} {{instances}} of IBM Linux code as breaches of contract. These examples include code related to Symmetric <b>multiprocessing</b> (SMP), Journaled File System (JFS), Read-copy-update (RCU) and Non-Uniform Memory Access (NUMA). This code is questionably in the Linux kernel, and may have been added by IBM through the normal kernel submission process. This code was developed and copyrighted by IBM. IBM added features to AIX and Dynix.|$|E
25|$|MIPS II {{removed the}} load delay slot and added several sets of {{instructions}}. For shared-memory <b>multiprocessing,</b> the Synchronize Shared Memory, Load Linked Word, and Store Conditional Word instructions were added. A set of Trap-on-Condition instructions were added. These instructions caused an exception if the evaluated condition is true. All existing branch instructions were given branch-likely versions that executed the {{instruction in the}} branch delay slot only if the branch is taken. These instructions improve performance in certain cases by allowing useful instructions to fill the branch delay slot. Doubleword load and store instructions for COP1ndash&3 were added. Consistent with other memory access instructions, these loads and stores required the doubleword to be naturally aligned.|$|E
25|$|The P5 was {{followed}} by the P54C (80502), also known as Pentium-S; there were versions specified to operate at 75, 90, or 100MHz using a 3.3 volt power supply. This was the first Pentium processor to operate at 3.3 volts, reducing energy consumption. It employed an internal clock multiplier to let the internal circuitry work at a higher frequency than the external address and data buses, as it is more complicated and cumbersome to increase the external frequency, due to physical constraints. It also allowed two-way <b>multiprocessing</b> and had an integrated local APIC as well as new power management features. It contained 3.3 million transistors and measured 163mm2. It was fabricated in a BiCMOS process which has been described as both 0.5µm and 0.6 µm due to differing definitions.|$|E
500|$|A {{graduate}} of Sidney Sussex College, Cambridge, Kilburn worked on radar at the Telecommunications Research Establishment (TRE) in Malvern under Frederic Calland Williams during the Second World War. [...] After the war ended, he was recruited by Williams {{to work on}} the development of computers at the University of Manchester. He led the development of a succession of innovative Manchester computers that incorporated a host of ground-breaking innovations and developments, including the Ferranti Mark 1, the world's first commercial computer, and the Atlas, one of the first time-sharing <b>multiprocessing</b> computers that incorporated job scheduling, spooling, interrupts, pipelining and paging.|$|E
500|$|According to Kalinske, Sega of America [...] "fought {{against the}} {{architecture}} of Saturn for quite some time". Seeking an alternative graphics chip for the Saturn, Kalinske attempted to broker a deal with Silicon Graphics, but Sega of Japan rejected the proposal. Silicon Graphics subsequently collaborated with Nintendo on the Nintendo 64. Kalinske, Sony Electronic Publishing's Olaf Olafsson, and Sony America's Micky Schulhof had previously discussed development of a joint [...] "Sega/Sony hardware system", which never came to fruition due to Sega's desire to create hardware that could accommodate both 2D and 3D visuals and Sony's competing notion of focusing entirely on 3D technology. Publicly, Kalinske defended the Saturn's design: [...] "Our people feel that they need the <b>multiprocessing</b> {{to be able to}} bring to the home what we're doing next year in the arcades." ...|$|E
2500|$|Windows 9x has no native {{support for}} [...] hyper-threading, Data Execution Prevention, {{symmetric}} <b>multiprocessing</b> or multi-core processors.|$|E
2500|$|<b>Multiprocessing</b> control: TAS, test-and-set, {{performed}} an indivisible bus operation, permitting semaphores {{to be used}} to synchronize several processors sharing a single memory ...|$|E
2500|$|The Alpha {{architecture}} {{was intended}} to be a high-performance design. Digital intended the architecture to support a one-thousandfold increase in performance over twenty-five years. To ensure this, any architectural feature that impeded multiple instruction issue, clock rate or <b>multiprocessing</b> was removed. As a result, the Alpha does not have: ...|$|E
2500|$|In the Linux kernel, {{hibernation}} {{is implemented}} by swsusp which {{is built into}} the 2.6 series. An alternative implementation is TuxOnIce which is available as patches for the kernel version 3.4. TuxOnIce provides advantages such as support for symmetric <b>multiprocessing</b> and preemption. Another alternative implementation is uswsusp. All three refer to it as [...] "suspend-to-disk".|$|E
2500|$|Erlang's main {{strength}} is support for concurrency. It {{has a small}} but powerful set of primitives to create processes and communicate among them. Erlang is conceptually similar to the occam programming language, though it recasts the ideas of communicating sequential processes (CSP) in a functional framework and uses asynchronous message passing. Processes are the primary means to structure an Erlang application. [...] They are neither operating system processes nor operating system threads, but lightweight processes that are scheduled by Erlang's BEAM VM. Like operating system processes (but unlike operating system threads), they share no state with each other. The estimated minimal overhead for each is 300 words. Thus, many processes can be created without degrading performance. A benchmark with 20 million processes has been successfully performed. Erlang has supported symmetric <b>multiprocessing</b> since release R11B of May 2006.|$|E
2500|$|The {{reason for}} Rosetta’s reduced {{compatibility}} compared to Apple’s earlier 68k emulator for PPCs lies within its implementation: Rosetta is a user-level program {{and can only}} intercept and emulate user-level code, while the older emulator was integrated with the system {{at a much lower}} level. The 68k emulator was given access to the very lowest levels of the OS by being at the same level as, and tightly connected to, the Mac OS nanokernel on PPC Macs (later used for <b>multiprocessing</b> under Mac OS 8.6 and later), which means that the nanokernel was able to intercept PowerPC interrupts, translate them to 68k interrupts (then doing a mixed mode switch, if necessary), and then executing 68k code to handle the interrupts. This allowed lines of 68k and PPC code to be interspersed within the same binary of a fat application. While a similar effect could likely have been achieved for Mac OS X by running Rosetta within XNU, Apple instead chose to implement Rosetta as a user-level process to avoid excessive debugging and the potential for security issues.|$|E
2500|$|Mac OS {{continued}} to evolve up to version 9.2.2, including retrofits {{such as the}} addition of a nanokernel and support for <b>Multiprocessing</b> Services 2.0 in Mac OS 8.6, though its dated architecture made replacement necessary. Initially developed in the Pascal programming language, it was substantially rewritten in C++ for System 7. From its beginnings on an 8MHz machine with 128KB of RAM, it had grown to support Apple's latest 1GHz G4-equipped Macs. Since its architecture was laid down, features that were already common on Apple's competition, like preemptive multitasking and protected memory, had become feasible on the kind of hardware Apple manufactured. As such, Apple introduced Mac OS X, a fully overhauled Unix-based successor to Mac OS 9. OS X uses Darwin, XNU, and Mach as foundations, and is based on NeXTSTEP. It was released to the public in September 2000, as the Mac OS X Public Beta, featuring a revamped user interface called [...] "Aqua". At US$29.99, it allowed adventurous Mac users to sample Apple's new operating system and provide feedback for the actual release. The initial version of Mac OS X, 10.0 [...] "Cheetah", was released on March 24, 2001. Older Mac OS applications could still run under early Mac OS X versions, using an environment called [...] "Classic". Subsequent releases of Mac OS X included 10.1 [...] "Puma" [...] (2001), 10.2 [...] "Jaguar" [...] (2002), 10.3 [...] "Panther" [...] (2003) and 10.4 [...] "Tiger" [...] (2005).|$|E
50|$|Systems that {{treat all}} CPUs equally are called {{symmetric}} <b>multiprocessing</b> (SMP) systems. In systems where all CPUs are not equal, system resources may be divided {{in a number}} of ways, including asymmetric <b>multiprocessing</b> (ASMP), non-uniform memory access (NUMA) <b>multiprocessing,</b> and clustered <b>multiprocessing.</b>|$|E
5000|$|Both the 370/168 and the 370/158 had MP (<b>multiprocessing)</b> {{models that}} offered [...] "tightly coupled <b>multiprocessing.</b>|$|E
50|$|Cellular <b>multiprocessing</b> is a <b>multiprocessing</b> {{computing}} architecture designed initially for Intel {{central processing}} units from Unisys, a worldwide information technology consulting services and solutions company.|$|E
50|$|At the {{operating}} system level, <b>multiprocessing</b> is sometimes {{used to refer to}} the execution of multiple concurrent processes in a system, with each process running on a separate CPU or core, as opposed to a single process at any one instant. When used with this definition, <b>multiprocessing</b> is sometimes contrasted with multitasking, which may use just a single processor but switch it in time slices between tasks (i.e. a time-sharing system). <b>Multiprocessing</b> however means true parallel execution of multiple processes using more than one processor. <b>Multiprocessing</b> doesn't necessarily mean that a single process or task uses more than one processor simultaneously; the term parallel processing is generally used to denote that scenario. Other authors prefer to refer to {{the operating}} system techniques as multiprogramming and reserve the term <b>multiprocessing</b> for the hardware aspect of having more than one processor. The remainder of this article discusses <b>multiprocessing</b> only in this hardware sense.|$|E
50|$|Mac OS 8.6's nanokernel {{was rewritten}} by René A. Vega to add <b>Multiprocessing</b> Services 2.0 support. PowerMacInfo, {{distributed}} in the <b>Multiprocessing</b> SDK, is an application that displays statistics about the nanokernel's operation.|$|E
50|$|Enea OSE Multicore Edition was {{released}} in 2009 {{and is based on}} the same microkernel architecture. The kernel design that combines the advantages of both traditional asymmetric <b>multiprocessing</b> (AMP) and symmetric <b>multiprocessing</b> (SMP).|$|E
50|$|Neutrino {{supports}} symmetric <b>multiprocessing</b> and processor affinity, called bound <b>multiprocessing</b> (BMP) in QNX terminology. BMP is used {{to improve}} cache hitting and to ease the migration of non-SMP safe applications to multi-processor computers.|$|E
50|$|The UltraSPARC III is an in-order superscalar microprocessor. The UltraSPARC III was {{designed}} for shared memory <b>multiprocessing</b> performance, and it has several features that aid in achieving that goal: an integrated memory controller and a dedicated <b>multiprocessing</b> bus.|$|E
50|$|Solbourne Computer Inc. was {{originally}} a vendor of computer systems based in Longmont, Colorado, United States, at first 52% owned by Matsushita. In the late 1980s and early '90s, the company produced {{a range of}} computer workstations and servers based on the SPARC microprocessor architecture, largely compatible with Sun Microsystems' Sun-4 systems. Some of these are notable for supporting symmetric <b>multiprocessing</b> some time before Sun themselves produced multiprocessor systems. Even when Sun produced multiprocessor systems, SunOS uses an asymmetric <b>multiprocessing</b> model rather than OS/MP's symmetric <b>multiprocessing</b> model; Sun would not adopt symmetric <b>multiprocessing</b> until the release of Solaris 2.0 in 1992. Due {{to the cost of}} engineering and producing new systems to compete with Sun's increasingly competitive hardware offerings and the loss of symmetric <b>multiprocessing</b> as a distinguishing feature, in 1994, Solbourne left the computer hardware business, with Grumman Systems Support Corporation taking over support for Solbourne customers until 2000.|$|E
50|$|Sequent Computer Systems was a {{computer}} company that designed and manufactured <b>multiprocessing</b> computer systems. They {{were among the}} pioneers in high-performance symmetric <b>multiprocessing</b> (SMP) open systems, innovating in both hardware (e.g., cache management and interrupt handling) and software (e.g., read-copy-update).|$|E
50|$|Although the POWER1 was a {{high-end}} design, {{it was not}} capable of <b>multiprocessing,</b> and as such was disadvantaged, {{as the only way}} performance could be improved was by clocking the CPU higher, which was difficult to do with such a large multi-chip design. IBM used clustering to overcome this disadvantage in POWER1 systems, allowing them to effectively function as if they were <b>multiprocessing</b> systems, a concept proven by the popularity of SP1 supercomputers based on the POWER1. As the POWER1 was the basis of the POWER2 and P2SC microprocessors, the lack of <b>multiprocessing</b> was passed on to these later POWER processors. <b>Multiprocessing</b> was not supported until the introduction of the POWER3 in 1998.|$|E
50|$|Supports Event Timers {{allowing}} <b>multiprocessing.</b>|$|E
50|$|The system {{interface}} {{was similar to}} that of the Alpha 21364. There were integrated memory controllers that provided ten RDRAM channels. <b>Multiprocessing</b> was facilitated by a router that provided links to other 21464s, and it architecturally supported 512-way <b>multiprocessing</b> without glue logic.|$|E
50|$|In <b>multiprocessing</b> systems, each {{microprocessor}} is a node {{with its}} own memory. Accessing the memory of other nodes is possible, but with a latency. The latency increases with distance, thus the Alpha 21364 implements non-uniform memory access (NUMA) <b>multiprocessing.</b> I/O is also distributed in an identical fashion. An Alpha 21364 microprocessor in a <b>multiprocessing</b> system {{did not have to}} have its RIMM slots populated with memory or its I/O port populated with devices. It could use another microprocessor's memory and I/O.|$|E
5000|$|Unlike UNIX, {{which was}} {{developed}} {{without regard for}} <b>multiprocessing,</b> Mach incorporates <b>multiprocessing</b> support throughout. Its <b>multiprocessing</b> support is also exceedingly flexible, ranging from shared memory systems to systems with no memory shared between processors. Mach is designed to run on computer systems ranging from one to thousands of processors. In addition, Mach is easily ported to many varied computer architectures. A key goal of Mach {{is to be a}} distributed system capable of functioning on heterogeneous hardware. (Appendix B, Operating System Concepts) ...|$|E
50|$|Helios: {{heterogeneous}} <b>multiprocessing</b> with satellite kernels.|$|E
