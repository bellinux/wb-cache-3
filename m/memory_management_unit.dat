301|6675|Public
5|$|In PowerPC-based Macintoshes, {{the boot}} process {{starts with the}} {{activation}} of BootROM, the basic Macintosh ROM, which performs a Power On Self Test to test hardware essential to startup. On the passing of this test, the startup chime is played {{and control of the}} computer is passed to OpenFirmware. OpenFirmware initializes the Random Access Memory, <b>Memory</b> <b>Management</b> <b>Unit</b> and hardware necessary for the ROM's operation. The OpenFirmware then checks settings, stored in NVRAM, and builds a list of all devices on a device tree by gathering their stored FCode information.|$|E
25|$|In September 2016, Dolphin's {{developers}} {{announced the}} emulator was {{now able to}} boot all official GameCube titles. The last title to be supported for boot-up, , had been particularly difficult to emulate due to the game's use of the <b>memory</b> <b>management</b> <b>unit.</b> Also they announced that they removed Triforce emulation, because of no maintenance in the Triforce emulation's code.|$|E
25|$|The AllCard, an add-on <b>memory</b> <b>management</b> <b>unit</b> for XT-class computers, allowed normal {{memory to}} be mapped into the A0000-EFFFF (hex) address range, giving up to 952 KB for DOS programs. Programs such as Lotus 1-2-3, which {{accessed}} video memory directly, {{needed to be}} patched to handle this memory layout. Therefore, the 640 KB barrier was removed {{at the cost of}} hardware compatibility.|$|E
50|$|In {{virtual memory}} {{implementations}} and <b>memory</b> <b>management</b> <b>units,</b> a <b>memory</b> map refers to page tables, which store the mapping between a certain process's virtual memory layout {{and how that}} space relates to physical memory addresses.|$|R
50|$|VLX {{supports}} {{a variety of}} 32-bit/64-bit processors, single and multi-core processors, including processors from Intel, Texas Instruments, Freescale and ARM and Power architectures. VLX supports devices with and without <b>memory</b> <b>management</b> <b>units</b> and {{can take advantage of}} hardware virtualization and security support.|$|R
50|$|Bank {{switching}} {{was later}} supplanted by segmentation in many 16-bit systems, {{which in turn}} gave way to paging <b>memory</b> <b>management</b> <b>units.</b> In embedded systems, however, bank switching is still often used for its simplicity, low cost, and often better adaptation to those contexts than to general purpose computing.|$|R
25|$|The {{other main}} issue was that early Macs lack a <b>memory</b> <b>management</b> <b>unit</b> (MMU), which precludes the {{possibility}} of several fundamental modern features. An MMU would provide memory protection to ensure that programs cannot accidentally overwrite other program's memory, and it would provision shared memory. Lacking shared memory, the API was instead written so the operating system and application shares all memory, which is what allows QuickDraw to examine the application's memory for settings like the line drawing mode or color.|$|E
25|$|Throughout 2014, {{there was}} great {{progress}} with accuracy in mind, implementing features such as disc loading emulation, native support for GameCube controllers, near perfect audio emulation, and bug fixes for problems present since its earliest days. <b>Memory</b> <b>management</b> <b>unit</b> (MMU) improvements allow many games to boot and work properly for the first time. Development on Android devices has also been promising; as of December 2014, Dolphin can run on its most powerful devices, such as those using Nvidia Tegra processors, albeit with some difficulty.|$|E
25|$|Another PowerPC {{emulator}} is SheepShaver, {{which has}} been around since 1998 for BeOS on the PowerPC platform, but in 2002 was open sourced, and efforts began to port it to other platforms. Originally it was not designed for use on x86 platforms and required an actual PowerPC processor present in the machine it was running on similar to a hypervisor. Although it provides PowerPC processor support, it can run only up to Mac OS 9.0.4 because it does not emulate a <b>memory</b> <b>management</b> <b>unit.</b>|$|E
40|$|<b>Memory</b> <b>Management</b> <b>Units</b> (MMUs) are {{traditionally}} used by operating systems to implement disk-paged virtual memory. Some operating systems allow user programs {{to specify the}} protection level (inaccessible, readonly. read-write) of pages, and allow user programs t. o handle protection violations. bur. these mechanisms are not. always robust, efficient, or well-mat. ched {{to the needs of}} applications...|$|R
50|$|The IMMU and DMMU are <b>memory</b> <b>management</b> <b>units</b> for {{instructions}} and data, respectively. Each MMU contained a 32-entry fully associative {{translation lookaside buffer}} (TLB) that can map 4 KB, 64 KB or 1 MB pages. The write buffer (WB) has eight 16-byte entries. It enables the pipelining of stores. The bus interface unit (BIU) provided the SA-110 with an external interface.|$|R
50|$|National Semiconductor also {{produced}} related support chips like Floating Point <b>Units</b> (FPUs) NS32081, <b>Memory</b> <b>Management</b> <b>Units</b> (MMUs) NS32082, Direct Memory Access (DMA) NS32203 and Interrupt NS32202 Controllers. With the full set plus memory chips and peripherals, it was feasible {{to build a}} 32-bit computer system capable of supporting modern multi-tasking operating systems, something {{that had previously been}} possible only on expensive minicomputers and mainframes.|$|R
25|$|When {{executing}} {{software from}} NAND memories, virtual memory strategies are often used: memory contents {{must first be}} paged or copied into memory-mapped RAM and executed there (leading to the common combination of NAND + RAM). A <b>memory</b> <b>management</b> <b>unit</b> (MMU) in the system is helpful, but this can also be accomplished with overlays. For this reason, some systems will {{use a combination of}} NOR and NAND memories, where a smaller NOR memory is used as software ROM and a larger NAND memory is partitioned with a file system for use as a non-volatile data storage area.|$|E
25|$|To {{ensure that}} even the largest structs do not cause a {{performance}} penalty when they are handed off, Swift uses copy on write so that the objects are copied only {{if and when the}} program attempts to change a value in them. This means that the various accessors have what is in effect a pointer to the same data storage, but this takes place far below the level of the language, in the computer's <b>memory</b> <b>management</b> <b>unit</b> (MMU). So while the data is physically stored as one instance in memory, {{at the level of the}} application, these values are separate, and physical separation is enforced by copy on write only if needed.|$|E
25|$|A {{system call}} is a {{mechanism}} {{that is used}} by the application program to request a service from the operating system. They use a machine-code instruction that causes the processor to change mode. An example would be from supervisor mode to protected mode. This is where the operating system performs actions like accessing hardware devices or the <b>memory</b> <b>management</b> <b>unit.</b> Generally the operating system provides a library that sits between the operating system and normal programs. Usually it is a C library such as Glibc or Windows API. The library handles the low-level details of passing information to the kernel and switching to supervisor mode. System calls include close, open, read, wait and write.|$|E
50|$|As a result, memory {{barriers}} are required. A store barrier will flush the store buffer, ensuring all writes {{have been applied}} to that CPU's cache. A read barrier will flush the invalidation queue, thus ensuring that all writes by other CPUs become visible to the flushing CPU. Furthermore, <b>memory</b> <b>management</b> <b>units</b> do not scan the store buffer, causing similar problems. This effect is already visible in single threaded processors.|$|R
40|$|Abstract—The uClinux port is a {{derivative}} of Linux kernel intended for microcontrollers without <b>memory</b> <b>management</b> <b>units</b> (MMU) [1]. It provides a single shared address space for all processes. Whereas, uC/OS-II is a portable, ROMable, scalable, preemptive, real-time deterministic multitasking kernel for mi-croprocessors, microcontrollers and DSPs [2]. In this paper, we implemented uCos and uClinux kernels {{on the same}} NIOS-II platform and compared the performance. Index Terms—Embedded OS, uClinux, uCos, benchmarks, performance...|$|R
50|$|The CPU {{supplementary}} instruction capability {{does not}} as a rule apply to 8 or 16 bit CPUs, {{as many of these}} CPUs are used mostly as microcontrollers. On modern 32 and 64 bit CPUs the processor supplementary capability does not extend to Floating Point <b>Units</b> (FPUs) or <b>Memory</b> <b>Management</b> <b>Units</b> (MMUs) as these are considered to be fundamental core functionalities. Extensions to the core functionalities of the MMU and FPU may be considered CPU extensions however.|$|R
25|$|In {{many modern}} CPUs, the {{protection}} of the memory that hosts the TCB is achieved by adding in a specialized piece of hardware called the <b>memory</b> <b>management</b> <b>unit</b> (MMU), which is programmable by the operating system to allow and deny access to specific ranges of the system memory to the programs being run. Of course, the operating system is also able to disallow such programming to the other programs. This technique is called supervisor mode; compared to more crude approaches (such as storing the TCB in ROM, or equivalently, using the Harvard architecture), it has the advantage of allowing the security-critical software to be upgraded in the field, although allowing secure upgrades of the trusted computing base poses bootstrap problems of its own.|$|E
25|$|The Linux kernel is {{a widely}} ported {{operating}} system kernel, available for devices ranging from mobile phones to supercomputers; it runs on a highly diverse range of computer architectures, including the hand-held ARM-based iPAQ and the IBM mainframes System z9 or System z10. Specialized distributions and kernel forks exist for less mainstream architectures; for example, the ELKS kernel fork can run on Intel 8086 or Intel 80286 16-bit microprocessors, while the µClinux kernel fork may run on systems without a <b>memory</b> <b>management</b> <b>unit.</b> The kernel also runs on architectures that were only ever intended to use a manufacturer-created operating system, such as Macintosh computers (with both PowerPC and Intel processors), PDAs, video game consoles, portable music players, and mobile phones.|$|E
2500|$|A <b>memory</b> <b>management</b> <b>unit</b> (MMU), {{sometimes}} called paged <b>memory</b> <b>management</b> <b>unit</b> (PMMU), {{is a computer}} hardware unit having all memory references passed through itself, primarily performing the translation of virtual memory addresses to physical addresses. [...] It is usually implemented {{as part of the}} central processing unit (CPU), but it also can be {{in the form of a}} separate integrated circuit.|$|E
50|$|Among {{its main}} features, HSA defines a unified virtual address space for compute devices: where GPUs {{traditionally}} {{have their own}} memory, separate from the main (CPU) memory, HSA requires these devices to share page tables so that devices can exchange data by sharing pointers. This is to be supported by custom <b>memory</b> <b>management</b> <b>units.</b> To render interoperability possible and also to ease various aspects of programming, HSA {{is intended to be}} ISA-agnostic for both CPUs and accelerators, and to support high-level programming languages.|$|R
50|$|To support {{applications}} that require fast, real-time response, Synopsys offers the MQX RTOS. MQX is a small, real-time kernel that occupies a small memory footprint and supports fast context switch times. ARC processor cores with <b>Memory</b> <b>Management</b> <b>Units</b> (MMUs) {{are supported by}} Linux, and Synopsys maintains and optimizes the Linux kernel to run on these ARC processor cores. The Linux kernel was originally ported to ARC processors in 2006. The ARC port {{is part of the}} official release from kernel.org.|$|R
40|$|This {{document}} {{describes the}} verification {{of a set}} of <b>memory</b> <b>management</b> <b>units</b> (MMU). The verification effort demonstrates the use of hierarchical decomposition and abstract theories. The MMUs can be organized into a complexity hierarchy. Each new level in the hierarchy adds a few significant features or modifications to the lower level MMU. The units described include: (1) a page check translation look-aside module (TLM); (2) a page check TLM with supervisor line; (3) a base bounds MMU; (4) a virtual address translation MMU; and (5) a virtual address translation MMU with memory resident segment table...|$|R
2500|$|The {{original}} Sun 1 was a single-board computer {{built around}} the Motorola 68000 microprocessor and introduced in 1982. It included the original Sun 1 <b>memory</b> <b>management</b> <b>unit</b> that provided address translation, memory protection, memory sharing and memory allocation for multiple processes running on the CPU. [...] All access of the CPU to private on-board RAM, external Multibus memory, on-board I/O and the Multibus I/O ran through the MMU, where they were translated and protected in uniform fashion. The MMU was implemented in hardware on the CPU board.|$|E
2500|$|Work on the {{processor}} began in 1982 {{under the leadership}} of Yoichi Yano. About 250 engineers participated and the V60 (μPD70616) debuted in February 1986. It had a six-stage pipeline, built-in <b>memory</b> <b>management</b> <b>unit</b> and floating-point arithmetic. It was manufactured in 1.5µm on a two-layer aluminum CMOS process using 375,000 transistors on a [...] die. It operated at 5V and was initially packaged in a 68-pin PGA. The first version ran at 16MHz at attained 3.5 MIPS. Its sample price at launch was set to ¥100,000 ($588.23). It entered full-scale production in August 1986.|$|E
2500|$|The Core 2 <b>memory</b> <b>management</b> <b>unit</b> (MMU) in X6800, E6000 and E4000 {{processors}} {{does not}} operate to previous specifications [...] implemented in previous generations of x86 hardware. This may cause problems, {{many of them}} serious security and stability issues, with existing operating system software. Intel's documentation states that their programming manuals will be updated [...] "in the coming months" [...] with information on recommended methods of managing the translation lookaside buffer (TLB) for Core 2 to avoid issues, and admits that, [...] "in rare instances, improper TLB invalidation may result in unpredictable system behavior, such as hangs or incorrect data." ...|$|E
40|$|Abstract-Recent {{technological}} advances in <b>memory</b> <b>management</b> architectures, multiprocessor systems, and software architectures dictate a reevaluation {{of the virtual}} <b>memory</b> <b>management</b> support provided by an operating system. The problems posed by multiprocessor systems and the portability {{issues raised by the}} large variety of <b>memory</b> <b>management</b> <b>units</b> available have not been satisfactorily addressed by past virtual memory systems. In addition, increases in virtual memory functionality that can be provided by memory managed architectures have gone largely unnoticed by system designers. This paper describes the design, implementation, and evaluation of the Mach virtual <b>memory</b> <b>management</b> system. The Mach virtual memory system exhibits architecture indepedence, multiprocessor and distributed system support, and advanced functionality. The performance of this virtual memory system is shown to often exceed that of commercially developed <b>memory</b> <b>management</b> systems targeted at specific hardware architectures. Index Terms-Architecture independence, Mach, parallel operating systems, UNIX, virtual memory...|$|R
40|$|<b>Memory</b> <b>Management</b> <b>Units</b> (MMUs) are {{traditionally}} used by operating systems to implement disk-paged virtual memory. Some operating systems allow user programs {{to specify the}} protection level (inaccessible, readonly, read-write) of pages, and allow user programs to handle protection violations, but these mechanisms are not always robust, efficient, or well-matched {{to the needs of}} applications. We survey several user-level algorithms that make use of page-protection techniques, and analyze their common characteristics, in an attempt to answer the question, "What virtual-memory primitives should the operating system provide to user processes, and how well do today's operating systems provide them?"...|$|R
40|$|Abstract—An {{embedded}} RISC microprocessor core fabricated in a six-layer metal 0. 18 - m CMOS process {{implementing the}} ARM ™ V. 5 TE instruction set is described. The core described {{is the first}} implementation of the Intel XScale Microarchitecture™. (ARM is a registered trademark of Advanced RISC Machines, Ltd.) The microprocessor core, which includes caches, <b>memory</b> <b>management</b> <b>units,</b> and a bus controller, comprises a hard-embedded block 16. 77 mm 2 in size. The implementation is primarily custom logic {{in a variety of}} circuit styles. The processor dissipates 450 mW at 1. 3 V, 600 MHz, and scales between 55 m...|$|R
5000|$|... #Caption: Comparison of the I/O <b>memory</b> <b>management</b> <b>unit</b> (IOMMU) to the <b>memory</b> <b>management</b> <b>unit</b> (MMU).|$|E
5000|$|<b>Memory</b> <b>Management</b> <b>Unit</b> and Exception-Handling {{support for}} {{applications}} ...|$|E
50|$|In {{case of a}} Heterogeneous System Architecture (processor {{architecture}} that integrates different types of processors, such as CPUs and GPUs, with shared memory), the <b>memory</b> <b>management</b> <b>unit</b> (MMU) of the CPU and the input-output <b>memory</b> <b>management</b> <b>unit</b> (IOMMU) of the GPU have to share certain characteristics, like a common address space.|$|E
40|$|This {{hardware}} specification contains {{detailed information}} on power considerations, DC/AC electrical characteristics, and AC timing specifications for the MPC 875 /MPC 870. The CPU on the MPC 875 /MPC 870 is a 32 -bit core built on Power Architecture ™ technology that incorporates <b>memory</b> <b>management</b> <b>units</b> (MMUs) and instruction and data caches. For functional characteristics of the MPC 875 /MPC 870, refer to the MPC 885 PowerQUICC ™ Family Reference Manual. To locate published errata or updates for this document, refer to the MPC 875 /MPC 870 product summary page on our website listed on the back cover of this document or, contac...|$|R
50|$|The OR1200 design uses a Harvard memory {{architecture}} and therefore has separate <b>memory</b> <b>management</b> <b>units</b> (MMUs) for data and instruction memories. These MMUs each {{consist of a}} hash-based 1-way direct-mapped translation lookaside buffer (TLB) with page size of 8 KB and a default size of 64 entries. The TLBs are individually scalable from 16 to 256 entries. There is also a one-way direct-mapped cache each for both the instruction memory and for the data memory. Each cache has a default size of 8 KB, but both are individually scalable between 1 and 64 KB. The MMU includes support for virtual memory.|$|R
40|$|Abstract: A major {{trend in}} {{automotive}} industry is to enrich driver and passenger ex-perience with an increasing amount of consumer electronics and car- 2 -x functionality. A close interaction between this added functionality and the classical automotive do-mains allows for innovations that are valuable {{to the end}} customer and cannot be out-played easily by devices with a pure consumer electronic origin. Innovations of this class require a tight coupling, for instance by executing programs from both worlds on the same microprocessor. The latter introduces many challenges, especially regarding reliability, security and safety of such systems. A unified <b>memory</b> <b>management</b> ful-filling {{the requirements of the}} consumer electronics and automotive application could help to address these issues and is a challenge by itself. This paper shows that the pre-vailing implementation scheme for <b>memory</b> <b>management</b> <b>units</b> (MMUs) is not suited for the needs of such systems and points out a solution direction. ...|$|R
