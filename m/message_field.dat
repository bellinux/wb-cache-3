16|154|Public
5000|$|... defines failure codes {{returned}} in the Failure packet <b>message</b> <b>field</b> ...|$|E
5000|$|The {{borders of}} PDUs are always {{given by the}} PDUs' command_length field. Any <b>message</b> <b>field</b> must not exceed the end of PDU. If a field is not {{properly}} finished, it {{should be treated as}} truncated at the end of PDU, and it should not affect further PDUs.|$|E
50|$|WebCL, being a JavaScript based implementation, doesn’t return {{an error}} code when errors occur. Instead, it throws an {{exception}} such as OUT_OF_RESOURCES, OUT_OF_HOST_MEMORY, or the WebCL-specific WEBCL_IMPLEMENTATION_FAILURE. The exception object describes the machine-readable name and human-readable message describing the error. The syntax is as follows:From the code above, {{it can be}} observed that the <b>message</b> <b>field</b> can be a NULL value.|$|E
40|$|This {{document}} specifies an Internet standards track {{protocol for}} the Internet community, and requests discussion {{and suggestions for}} improvements. Please refer to the current edition of the "Internet Official Protocol Standards " (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited. Copyright Notice Copyright (C) The Internet Society (2006). IP over Infiniband (IPoIB) link-layer address is 20 octets long. This {{is larger than the}} 16 octets reserved for the hardware address in a Dynamic Host Configuration Protocol/Bootstrap Protocol (DHCP/BOOTP) message. The above inequality imposes restrictions {{on the use of the}} DHCP <b>message</b> <b>fields</b> when used over an IPoIB network. This document describes the use of DHCP <b>message</b> <b>fields</b> when implementing DHCP over IPoIB...|$|R
50|$|There is {{a subset}} of the {{protocol}} (Level I) that is very much tailored to the CAN bus and resource restricted microcontrollers. Protocol Level II is designed for Ethernet (UDP, TCP and own Ethernet-type Raw-Ethernet) and wireless physical layers. All share the same common <b>message</b> <b>fields</b> and framework and can be connected through gateways.|$|R
5000|$|ISO 15022: 1999 Securities—Scheme for <b>messages</b> (Data <b>Field</b> Dictionary) (replaces ISO 7775) ...|$|R
50|$|In {{the example}} above, the {{operation}} code 03 means submit <b>message.</b> <b>Field</b> 021 defines the destination address (telephone number), with field 033 is the user data (content) of the message. Response code 53 with a field 060 time stamp {{indicates that the}} message was accepted; if the message failed, the SMSC would reply with field 900 (error code) instead.A good number of supporting software to implement CIMD is available fromNokia's Website to build CIMD client. You can fire SMS from message center {{with the help of}} CIMD client tools.|$|E
50|$|In June 2015, Telegram {{launched}} {{a platform for}} third-party developers to create bots. Bots are Telegram accounts operated by programs. They can respond to messages or mentions, can be invited into groups and can be integrated into other programs. Dutch website Tweakers reported that an invited bot can potentially read all group messages when the bot controller changes the access settings silently at a later point in time. Telegram pointed out that it considered implementing a feature that would announce such a status change within the relevant group. Also there are inline bots, {{which can be used}} from any chat screen. In order to activate an inline bot, user needs to type in the <b>message</b> <b>field</b> a bot's username and query. The bot then will offer its content. User can choose from that content and send it within a chat.|$|E
40|$|Type-flaw attacks upon {{security}} protocols wherein {{agents are}} led to misinterpret message types have been reported frequently in the literature. Preventing them is crucial for protocol security and verification. Heather et al. proved that tagging every <b>message</b> <b>field</b> with it's type prevents all type-flaw attacks under a free message algebra and perfect encryption system. In this paper, we prove that type-flaw attacks can be prevented with the same technique even under the ACUN algebraic properties of XOR which is commonly used in "real-world" protocols such as SSL 3. 0. Our proof method is general and can be easily extended to other monoidal operators that possess properties such as Inverse and Idempotence as well. We also discuss how tagging {{could be used to}} prevent type-flaw attacks under other properties such as associativity of pairing, commutative encryption, prefix property and homomorphic encryption. Comment: 16 pages, Appeared in proceedings of Security with Rewriting Techniques (SecRet 09), Affiliated to CSF Symposium 2009, Port Jefferson, NY...|$|E
5000|$|GTP reuses {{aspects of}} GTP {{although}} to quote 3GPP TS 32.295 [...] "only the signalling plane of GTP is partly reused". GTP defines a different header, additional <b>messages,</b> <b>field</b> values, {{as well as}} a synchronisation protocol to avoid losing or duplicating CDRs on CGF or SGSN/GGSN failure. Transferred CDRs, if following 3GPP standards, are encoded in ASN.1.|$|R
5000|$|RFC 5293 - Editheader; {{allows a}} script to add and delete <b>message</b> header <b>fields.</b>|$|R
50|$|The <b>Message</b> Length <b>field</b> {{indicates}} {{the length of}} the Diameter message including the header fields and the padded AVPs.|$|R
40|$|III GPS-Squitter merges the {{capabilities}} ofAutomatic Dependent Surveillance (ADS) with the Mode S beacon system. In ADS, an aircraft determines {{its position on}} board by using satellite navigational data from a system such as the Global Positioning System (GPS). The information is then broadcast to ground and airborne users to provide surveillance ofthe aircraft. In GPS-Squitter, an aircraft would transmit the ADS information by using the Mode S squitter-a spontaneous periodic broadcast transmitted by all Mode S transponders. Currendy, the Mode S transponders emit a 56 -bit squitter once per second, and the squitters are used by the Traffic Alert and Collision Avoidance System (TCAS) to acquire the 24 -bit address ofthe aircraft. For the GPS-Squitter system, the squitter broadcast is extended to 112 bits {{to provide for the}} transmission of a 56 -bit ADS <b>message</b> <b>field.</b> This article defines the GPS-Squitter concept, describes its principal surveillance and data-link applications, and provides estimates ofthe expected performance in future moderate-to-high-density environments. The progra...|$|E
40|$|SOAP is an XML-based {{protocol}} that {{is widely}} used in Web services and that provides extensibility, portability, flexibility, and descriptiveness. Unfortunately, these attractive characteristics {{come at the expense}} of performance, threatening to preclude the use of SOAP for high performance computing. In particular, we have shown in previous work that serialization and deserialization of scientific data are by far the most expensive operations that limit SOAP’s performance. One technique for eliminating this performance bottleneck is differential serialization—saving copies of messages in the sender, and reserializing only the differences between the most recent message and the next one. In this paper, we build on our earlier introduction and investigation of differential serialization by describing improved algorithms for dynamically resizing message fields, which is necessary when newly serialized data requires a different amount of space than the old data occupied. In particular, we describe our implementation of stealing space from neighboring fields, and present a performance study that compares this new technique with others from previous work. Results show that stealing (1) performs better than other techniques for increasing <b>message</b> <b>field</b> size when extra space is limited, and (2) is effective at keeping message sizes from expanding over time, but results in a tradeoff with performance when compared against other approaches that allow message sizes to grow. ...|$|E
30|$|The last {{section of}} the Message Model, {{semantic}} annotations, enables the annotation of parsed data at various granularity. We support two types of semantic annotation: (i) domain knowledge (i.e., references to concepts in an ontology) and (ii) the scope of data. One may annotate an operation, a message, and/or any <b>message</b> <b>field</b> (either of complex or simple type). Such annotations support the synthesis of application-layer mediators in finding relevant matches between available data and data required to perform an operation. The data scope is important whenever applications configure the underlying middleware, causing application-specific data to be scattered over multiple layers. We mentioned that, {{in order to achieve}} mediation, we must identify and forward all application data. The element datascope set to application or middleware marks that the synthesis of application-layer mediators must consider this data as part of the application scope or, respectively, the middleware scope (in which case it should be ignored). However, the separation of middleware data is not sufficient as components may exhibit more complex data scoping. For example, Amiando uses a static key called ApiKey to control service access while Regonline uses a session id called ApiToken. Both data are instances of the same domain concept, but the mediator should never assign the ApiToken to ApiKey or vice versa: Amiando will not recognise session keys created by Regonline and Regonline will not accept access keys generated by Amiando. Still, the application-layer mediator synthesis tool must map the ApiToken between the subsequent Regonline requests.|$|E
25|$|Maximum {{speed is}} finite: No {{physical}} object, <b>message</b> or <b>field</b> line can travel {{faster than the}} speed of light in a vacuum.|$|R
50|$|X-No-Archive, {{also known}} colloquially as xna, is a {{newsgroup}} <b>message</b> header <b>field</b> {{used to prevent}} a Usenet message from being archived in various servers.|$|R
50|$|Over {{the next}} 7 years <b>messaging</b> {{activities}} were <b>fielded</b> by the Chinese {{company and its}} authorized agents, specifically designed to elicit Ideations and Decisions {{that would result in}} the takeover going through. In 2012, the takeover was completed after a coordinated and concerted <b>field</b> <b>messaging</b> activity.|$|R
40|$|Large-scale attacks, such {{as those}} {{launched}} by worms and zombie farms, pose {{a serious threat to}} our network-centric society. Existing approaches such as software patches are simply unable to cope with the volume and speed with which new vulnerabilities are being discovered. In this paper, we develop a new approach that can provide effective protection against a vast majority of these attacks that exploit memory errors in C/C++ programs. Our approach, called COVERS, uses a forensic analysis of a victim server's memory to correlate attacks to inputs received over the network, and automatically develop a signature that characterizes inputs that carry attacks. The signatures tend to capture characteristics of the underlying vulnerability (e. g., a <b>message</b> <b>field</b> being too long) rather than the characteristics of an attack, which makes them effective against variants of attacks. Our approach introduces low overheads (under 10 %), does not require access to source code of the protected server, and has successfully generated signatures for the attacks studied in our experiments, without producing false positives. Since the signatures are generated in tens of milliseconds, they can potentially be distributed quickly over the Internet to filter out (and thus stop) fastspreading worms. Another interesting aspect of our approach is that it can defeat guessing attacks reported against address-space randomization and instruction set randomization techniques. Finally, it increases the capacity of servers to withstand repeated attacks by a factor of 10 or more...|$|E
40|$|Abstract – The current {{version of}} the internet, IPV 4 was {{depleted}} of addresses on february 3, 2011. The storage of address {{has led to the}} introduction of IPV 6 which has 128 -bit (16 -byte) source and destination IP addresses. Many organisations do not see a reason to convert to IPV 6, and believe they are not running IPV 6. Whether an organisation knows it or not, any laptop/PC running Vista or Windows 7 is a vulnerability from which attacks can come that will be invisible to IPV 4 networks. Since the Internet today uses IPV 4 for 99 % of the traffic, it will be slow migrations to IPV 6. Three transition strategies are being employed: header translation, dual stack and tunnelling of IPV 6 inside IPV 4. Tunneling is the most precarious method for today’s IPV 4 networks. The IPV 6 packet is included inside the <b>message</b> <b>field</b> of an IPV 4 packet. The content of the IPV 6 packet will not be noticed by an IP 4 firewall or intrusion detection system. Hidden IPv 6 traffic running across an organisation’s network can wreak havoc, allow malware to enter the network, and be the basis for a denial of service attack. The only defence against such attacks is deep packet inspection (DPI). The widespread use of DPI is inevitable. The first serious security breach caused by tunnelled IPV 6 inside an IPV 4 packet is certain to come in the near future. This event will be a stimulus to organisation to defend against such attacks...|$|E
40|$|It {{is widely}} {{recognized}} that large-scale attacks, {{such as those}} launched by worms and zombie farms, pose a grave threat to our network-centric society. Existing approaches such as software patches are simply unable {{to cope with the}} volume and speed with which new vulnerabilities are being discovered. In this paper, we develop a new approach that can provide effective protection against a vast majority of these attacks that exploit memory errors in C/C++ programs. Our approach uses a forensic analysis of a victim server memory to correlate attacks to inputs received over the network, and automatically develop a signature that characterizes inputs that carry attacks. The signatures tend to capture characteristics of the underlying vulnerability (e. g., a <b>message</b> <b>field</b> being too long) rather than the characteristics of an attack, thereby making it effective against variants of attacks. Our approach introduces low overheads (under 10 %), does not require access to source code of the protected server, and has successfully generated signatures for all of the attacks that we studied in our experiments, without producing false alarms. Signature generation is fast, taking a few milliseconds at most. This enables such filters to be deployed very quickly, thereby providing protection against fast-spreading worms. Another interesting aspect of our approach is that it can defeat guessing attacks reported against (i) address space randomization and (ii) instruction set randomization techniques. Moreover, our approach greatly decreases the performance impact of unsuccessful attacks. In particular, availability of servers subjected to repeated attacks is improved by a factor of 10 or more by our approach. ...|$|E
25|$|<b>Message</b> type: This <b>field</b> {{identifies}} the handshake message type.|$|R
50|$|<b>Message</b> discriminator1-octet <b>field</b> used in all {{messages}} {{to discriminate between}} Transparent and Non-Transparent messages and also between Radio Link Layer Management, Dedicated Channel Management, Common Channel Management and TRX Management messages.|$|R
50|$|E-mail in Minuet resembles most {{standard}} e-mail programs — From:, To:, cc:, Bcc:, and <b>Message</b> body <b>fields.</b> Attachments use the BinHex and UUCP encoding schemes, which predated MIME and were popular in Minuet's days.|$|R
40|$|Abstract: On February 3, 2011 {{the current}} version of the Internet IPv 4 was {{depleted}} of addresses. Since the Internet today uses IPv 4 for 99 % of the traffic, it will be a slow migration to IPv 6. 1. The shortage of addresses has led to the introduction of IPv 6 which has 128 -bit (16 -byte) source and destination IP addresses. Many organizations do not see a reason to convert to IPv 6, and believe they are not running IPv 6. 2 whether an organization knows it or not, any laptop/PC running Vista or Windows 7 is a vulnerability from which attacks can come that will be invisible to IPv 4 networks. Three transition strategies are being employed: header translation, dual stack and tunneling of IPv 6 inside IPv 4. 4 Tunneling is the most precarious method for today’s IPv 4 networks. The IPv 6 packet is included inside the <b>message</b> <b>field</b> of an IPv 4 packet. The contents of the IPv 6 packet will not be noticed by an IPv 4 firewall or intrusion detection system. Hidden IPv 6 traffic running across an organization’s network can wreak havoc, allow malware to enter the network, and be the basis for a denial of service attack. The only defense against such attacks is deep packet inspection (DPI). The widespread use of DPI is inevitable. The first serious security breach caused by tunneled IPv 6 inside an IPv 4 packet is certain to come in the near future. This event will be a motivation to organizations to defend against such attacks...|$|E
40|$|One {{troublesome}} {{failure mode}} for Ground Based Augmentation Systems (GBAS) {{is the possibility}} of large discrepancies between satellite locations in space and the locations derived by the ephemeris data that they broadcast. For the Global Positioning System (GPS), nominal ephemeris errors are typically 10 meters or less, and it would take large errors (typically greater than 1 km) to be hazardous to GBAS users making precision approaches to Category I minima. Although most large errors will be detected by the GBAS ground segment <b>Message</b> <b>Field</b> Range Test, ephemeris errors orthogonal to the line-of-sight between a failed satellite and a GBAS ground station are not detectable by this simple test. To counter this possibility, RTCA has adopted new protection levels to quantify the potential impact of undetected ephemeris failures on user position errors for both precision approach and terminal area applications. These equations define position error bounds as functions of the approximate aircraft location with respect to each satellite and the GBAS ground station as well as the magnitude of the satellite orbit error detectable by the ground station. This Minimum Detectable Error (MDE) determines the "P-value " that is broadcast by the GBAS ground station for each satellite it has approved for use. Several GBAS monitor algorithms have been developed and tested for use in GBAS installations that lack SBAS coverage. One of these is a comparison between satellite positions given by the current satellite ephemeris and the ephemeris broadcast by the same satellite on its previous pass. Variants of this "YE-TE " test have been shown to support GBAS MDE's as low as 1100 meters, which will minimize the resulting impact on Category I user availability due to the ephemeris protection level equations. In addition, means of using raw measurements to initialize this monitor and to separately verify ephemerides in real-time are proposed...|$|E
40|$|Electronic {{communication}} is gradually becoming a larger part of today 2 ̆ 7 s society. This {{type of communication}} not only encompasses ways people stay in touch, but also how people manage or share their personal data. As this type of communication increases, the protecting of sensitive data becomes a goal amongst users. The goal of this thesis is to offer a secure solution for mobile devices to share data with other mobile devices. The idea is simple: provide a software solution that can be ported to multiple mobile device platforms that will allow a user to securely encrypt a message that can be sent using existing communication technologies from one mobile device to another, where that encrypted message can then be decrypted and used by the recipient. The method should rely on a common passkey that the sender and recipient agree upon through verbal communication in advance {{that can be used}} to encrypt and decrypt messages that are transmitted between them. The passkey should also never be documented (in the application or elsewhere) to prevent it from being discovered by an attacker. Although it would be possible to write this application on different platforms, the result is an application that is used on Apple 2 ̆ 7 s iPhone. The application uses the secure open-source Blowfish cipher. A sender can type in their plain-text message and a passkey. The application can then encrypt the plain-text message and output a cipher-text message that the sender can then copy and paste into a text message or email. The recipient can copy the ciphertext into the application 2 ̆ 2 s <b>message</b> <b>field</b> along with the shared passkey and then decrypt the message into its original plain-text format. This method offers the best flexibility, by taking advantage of technologies that mobile device customers use frequently, and a solid secure method of protecting their messages by way of the Blowfish cipher algorithm. The application presented in this thesis offers a way to enable secure messaging with mobile devices. With that being said, this application is not meant to be the final answer to this problem, especially since the current iteration has not been ported to other platforms. The application could also be modified to offer better support in the transmission of these messages as well to offer a better experience to the end user. With this introductory application, it is hoped that security in digital communications will be brought under the speculation of its users so that more secure options will become available...|$|E
40|$|This {{document}} {{describes how}} to send alarm information in syslog. It includes the mapping of ITU perceived severities onto syslog <b>message</b> <b>fields.</b> It {{also includes a}} number of alarm-specific SD-PARAM definitions from X. 733 and the IETF Alarm MIB. Status of This Memo This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the "Internet Official Protocol Standards " (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited. Copyright Notice Copyright (c) 2009 IETF Trust and the persons identified as th...|$|R
40|$|Protocol reverse {{engineering}} {{has often been}} a manual process that is considered time-consuming, tedious and error-prone. To address this limitation, a number of solutions have recently been proposed to allow for automatic protocol {{reverse engineering}}. Unfortunately, they are either limited in extracting protocol fields {{due to lack of}} program semantics in network traces or primitive in only revealing the flat structure of protocol format. In this paper, we present a system called AutoFormat that aims at not only extracting protocol fields with high accuracy, but also revealing the inherently “non-flat”, hierarchical structures of protocol messages. AutoFormat is based on the key insight that different protocol fields in the same message are typically handled in different execution contexts (e. g., the runtime call stack). As such, by monitoring the program execution, we can collect the execution context information for every message byte (annotated with its offset in the entire message) and cluster them to derive the protocol format. We have evaluated our system with more than 30 protocol messages from seven protocols, including two text-based protocols (HTTP and SIP), three binary-based protocols (DHCP, RIP, and OSPF), one hybrid protocol (CIFS/SMB), as well as one unknown protocol used by a real-world malware. Our results show that AutoFormat can not only identify individual <b>message</b> <b>fields</b> automatically and with high accuracy (an average 93. 4 % match ratio compared with Wireshark), but also unveil the structure of the protocol format by revealing possible relations (e. g., sequential, parallel, and hierarchical) among the <b>message</b> <b>fields...</b>|$|R
5000|$|Uzu: Appears in episode 11. Powers include {{consuming}} <b>messages</b> via magnetic <b>field,</b> burrowing, coiling body ...|$|R
5000|$|DMARC {{operates}} {{by checking}} that the domain in the <b>message's</b> [...] <b>field</b> (also called [...] "5322.From") is [...] "aligned" [...] with other authenticated domain names. If either SPF or DKIM alignment checks pass, then the DMARC alignment test passes.|$|R
5000|$|RFC 3864 {{describes}} {{registration procedures}} for <b>message</b> header <b>fields</b> at the IANA; it provides for permanent and provisional field names, including also fields defined for MIME, netnews, and HTTP, and referencing relevant RFCs. Common header fields for email include: ...|$|R
50|$|In common usage, the To field {{recipients}} {{are the primary}} audience of the <b>message,</b> CC <b>field</b> {{recipients are}} others to whom {{the author wishes to}} send the message publicly, and BCC field recipients are the others to whom the message is sent.|$|R
40|$|We {{consider}} {{the problem of}} content-based spam filtering for short text messages that arise in three contexts: mobile (SMS) communication, blog comments, and email summary information such as might be displayed by a low-bandwidth client. Short messages often consist {{of only a few}} words, and therefore present a challenge to traditional bag-of-words based spam filters. Using three corpora of short <b>messages</b> and <b>message</b> <b>fields</b> derived from real SMS, blog, and spam messages, we evaluate feature-based and compression-model-based spam filters. We observe that bag-of-words filters can be improved substantially using different features, while compression-model filters perform quite well as-is. We conclude that content filtering for short messages is surprisingly effective. SIN FINANCIACIÓN 0. 400 SJR (2007) Q 1, 52 / 235 Business, Management and accounting (miscellaneous) UE...|$|R
30|$|On SDM, the gloss_data_bytes fields {{transport}} the glosses (used to reference signs on LIBRAS Dictionary) {{that are being}} encoded. Since this field is inside a loop, several signs (glosses) can be transmitted in the same <b>message.</b> The <b>field</b> number_of_signs specifies the number of signs encoded in each SDM.|$|R
50|$|In {{order to}} be able to {{associate}} a possible error response with a request, the requester SHOULD use the field 'transactionIdentifier'. The requester SHOULD not make any assumption about the usage of <b>message</b> header <b>fields</b> by the responding service, in particular the usage of fields like Subject, Message-ID or References.|$|R
