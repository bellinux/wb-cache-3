178|135|Public
5|$|Ports use <b>Makefile</b> to {{automatically}} fetch the desired application's source code, either {{from a local}} or remote repository, unpack it on the system, apply patches to it and compile it. Depending {{on the size of}} the source code, compiling can take a long time, but it gives the user more control over the process and its result. Most ports also have package counterparts (i.e. pre-compiled binaries), giving the user a choice. Although this method is faster, the user has fewer customisation options.|$|E
500|$|Similarly, topological orderings of DAGs {{can be used}} {{to order}} the {{compilation}} operations in a <b>makefile.</b> The program evaluation and review technique uses DAGs to model the milestones and activities of large human projects, and schedule these projects to use as little total time as possible. Combinational logic blocks in electronic circuit design, and the operations in dataflow programming languages, involve acyclic networks of processing elements. DAGs can also represent collections of events and their influence on each other, either in a probabilistic structure such as a Bayesian network or as a record of historical data such as family trees or the version histories of [...] distributed revision control systems. DAGs can also be used as a compact representation of sequence data, such as the directed acyclic word graph representation of a collection of strings, or the binary decision diagram representation of sequences of binary choices. More abstractly, ...|$|E
2500|$|Cocoa {{applications}} are typically developed using the development tools provided by Apple, specifically Xcode (formerly Project Builder) and Interface Builder, using the languages Objective-C or Swift. However, the Cocoa programming environment {{can be accessed}} using other tools, such as Clozure CL, LispWorks, Object Pascal, Python, Perl, Ruby, and AppleScript {{with the aid of}} bridge mechanisms such as PasCocoa, PyObjC, CamelBones, RubyCocoa, and a D/Objective-C Bridge. A Ruby language implementation named MacRuby, which removes the need for a bridge mechanism, was formerly developed by Apple, while Nu is a Lisp-like language that can be used with Cocoa with no bridge. [...] It is also possible to write Objective-C Cocoa programs in a simple text editor and build it manually with GNU Compiler Collection (GCC) or clang from the command line or from a <b>makefile.</b>|$|E
50|$|Some {{directives}} in <b>makefiles</b> {{can include}} other <b>makefiles.</b>|$|R
50|$|Windows {{supports}} {{a variation of}} <b>makefiles</b> with its nmake utility. Standard Unix like <b>makefiles</b> can be executed in Windows in a Cygwin environment.|$|R
5000|$|... qmake is {{a utility}} that automates the {{generation}} of <b>makefiles.</b> <b>Makefiles</b> are used by the program make to build executable programs from source code; therefore qmake is a make-makefile tool, or makemake for short.|$|R
5000|$|A <b>makefile</b> is {{executed}} {{with the}} [...] command, e.g[...]By default, when make {{looks for the}} <b>makefile,</b> if a <b>makefile</b> name was not included as a parameter, it tries the following names, in order: <b>makefile</b> and <b>Makefile.</b>|$|E
50|$|Make {{searches}} the current directory for the <b>makefile</b> to use, e.g. GNU make searches files {{in order for}} a file named one of GNUmakefile, <b>makefile,</b> <b>Makefile</b> and then runs the specified (or default) target(s) from (only) that file.|$|E
50|$|A {{directive}} is {{an instruction}} for make {{to do something}} special while reading the <b>makefile</b> such as reading another <b>makefile.</b>|$|E
40|$|Abstract—Make {{is one of}} {{the oldest}} build {{technologies}} and is still widely used today, whether by manually writing <b>Makefiles,</b> or by generating them using tools like Autotools and CMake. Despite its conceptual simplicity, modern Make implementations such as GNU Make have become very complex languages, featuring functions, macros, lazy variable assignments and (in GNU Make 4. 0) the Guile embedded scripting language. Since we are interested in understanding how widespread such complex language features are, this paper studies the use of Make features in almost 20, 000 <b>Makefiles,</b> comprised of over 8. 4 million lines, from more than 350 different open source projects. We look at the popularity of features and the difference between hand-written <b>Makefiles</b> and those generated using various tools. We find that generated <b>Makefiles</b> use only a core set of features and that more advanced features (such as function calls) are used very little, and almost exclusively in hand-written <b>Makefiles.</b> I...|$|R
50|$|The <b>makefiles</b> {{produced}} {{follow the}} GNU Coding Standards.|$|R
50|$|In {{addition}} to Qt Creator, Qt provides qmake, a cross-platform build script generation tool that automates {{the generation of}} <b>Makefiles</b> for development projects across different platforms. Without such a tool, {{one would have to}} write different <b>Makefiles</b> for each platform, so it is useful for abstracting away the differences of various platforms.|$|R
5000|$|Automake aims {{to allow}} the {{programmer}} to write a <b>makefile</b> in a higher-level language, {{rather than having to}} write the whole <b>makefile</b> manually. In simple cases, it suffices to give: ...|$|E
5000|$|To {{use this}} <b>makefile</b> {{to create the}} {{executable}} file called edit, type [...] To use this <b>makefile</b> to delete the executable file and all the object files from the directory, type [...]|$|E
5000|$|Source control, <b>makefile</b> integration, unit testing, {{packaging}} and deployment, localization ...|$|E
50|$|<b>Makefiles</b> contain five {{kinds of}} things: {{explicit}} rules, implicit rules, variable definitions, directives, and comments.|$|R
5000|$|Historically, build {{automation}} {{was accomplished}} through <b>makefiles.</b> Today, {{there are two}} general categories of tools: ...|$|R
5000|$|... which builds Go {{binaries}} {{using only}} {{information in the}} source files themselves, no separate <b>makefiles</b> ...|$|R
5000|$|<b>Makefile</b> and ANT build {{integration}} {{are supported}} on equal footing.|$|E
5000|$|From this information, Automake {{generates a}} <b>makefile</b> {{that allows the}} user to: ...|$|E
5000|$|Generated 'configure' {{is written}} in Bourne shell and thus <b>Makefile</b> {{generation}} is slow.|$|E
50|$|Build {{files are}} {{provided}} for GCC <b>makefiles,</b> Visual Studio (2013 & 2015), Codelite, Code::Blocks and Xcode.|$|R
50|$|<b>Makefiles</b> {{originated}} on Unix-like {{systems and}} are still a primary software build mechanism in such environments.|$|R
5000|$|A robust module/object system. This {{provides}} module-based separate/incremental compilation (which is automatic without {{need for}} <b>makefiles).</b>|$|R
5000|$|The build procedure: The method (script, <b>makefile,</b> and so on) that {{invoked the}} build.|$|E
50|$|It {{automatically}} generates {{one or more}} Makefile.in from files called Makefile.am. Each Makefile.am contains, {{among other}} things, useful variable definitions for the compiled software, such as compiler and linker flags, dependencies and their versions, etc. The generated Makefile.ins are portable and compliant with the <b>Makefile</b> conventions in the GNU Coding Standards, and may be used by configure scripts to generate a working <b>Makefile.</b>|$|E
5000|$|A <b>Makefile,</b> which defines binary {{versions}} of VxWorks ROM images for programming into flash memory.|$|E
5000|$|Microsoft's NMAKE has {{predefined}} {{rules that}} can be omitted from these <b>makefiles,</b> e.g. [...] "c.obj $(CC)$(CFLAGS)".|$|R
50|$|Automake {{has been}} criticised for being complex {{compared}} to other tools like cmake and plain old <b>makefiles.</b>|$|R
50|$|Precompiled JWasm {{binaries}} {{are available}} for DOS, Windows and Linux. For OS/2 and FreeBSD, <b>makefiles</b> are supplied.|$|R
50|$|A <b>makefile</b> is a file {{containing}} {{a set of}} directives used with the make build automation tool.|$|E
50|$|It {{can be used}} to {{document}} any programming artifact, such as: classes, functions, tests, <b>makefile</b> entries, etc.|$|E
5000|$|... ‘#’ {{in a line}} of a <b>makefile</b> {{starts a}} comment. It {{and the rest of the}} line are ignored.|$|E
5000|$|... some no-named proof-of {{concepts}} {{based on}} make (since <b>makefiles</b> can easily express dependencies and be launched in parallel) ...|$|R
50|$|<b>Makefiles</b> {{can access}} {{any of a}} number of {{predefined}} internal macros, with '?' and '@' being the most common.|$|R
5000|$|POSIX {{includes}} {{standardization of}} the basic features and operation of the Make utility, and is implemented {{with varying degrees of}} completeness in Unix-based versions of Make. In general, simple <b>makefiles</b> may be used between various versions of Make with reasonable success. GNU Make, BSD Make and Makepp can be configured to look first for files named [...] "GNUmakefile", [...] "BSDmakefile" [...] and [...] "Makeppfile" [...] respectively, which allows one to put <b>makefiles</b> which use implementation-defined behavior in separate locations.|$|R
