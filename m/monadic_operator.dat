4|24|Public
50|$|In Haskell, the >> {{function}} is a <b>monadic</b> <b>operator.</b> It {{is used for}} sequentially composing two actions, discarding any value produced by the first. In that regard, {{it is like the}} statement sequencing operator in imperative languages, such as the semicolon in C.|$|E
40|$|AbstractWe {{define and}} study monadic MV-algebras as pairs of MV-algebras {{one of which}} is a special case of {{relatively}} complete subalgebra named m-relatively complete. An m-relatively complete subalgebra determines a unique <b>monadic</b> <b>operator.</b> A necessary and sufficient condition is given for a subalgebra to be m-relatively complete. A description of the free cyclic monadic MV-algebra is also given...|$|E
40|$|Generic NPs {{are marked}} with 2 ̆ 2 brow raise 2 ̆ 2. Habituals are marked with lexical TEND and/or aspectual {{reduplication}} for verbs. GEN is a dyadic operator with brow raise on its restriction. In contrast, HABITUAL is a <b>monadic</b> <b>operator</b> locally scoping on the verb. Treatment of these {{together under the}} heading 2 ̆ 2 characterizing sentences 2 ̆ 2 obscures necessary distinctions...|$|E
5000|$|The <b>monadic</b> <b>operators</b> {{result from}} the {{application}} , and the associated matrices have q rows and q columns. The two basic <b>monadic</b> <b>operators</b> for this two-valued vector logic are the identity and the negation: ...|$|R
5000|$|George Boole {{established}} {{the development of}} logical operations as polynomials. For the case of <b>monadic</b> <b>operators</b> (such as identity ornegation), the Boolean polynomials look as follows: ...|$|R
5000|$|The do-notation eases {{working with}} monads. This do-expression is {{equivalent}} to, but (arguably) easier {{to write and}} understand than, the de-sugared version employing the <b>monadic</b> <b>operators</b> directly: ...|$|R
40|$|We first extend {{existing}} work [FM 95, FM 97] on Propositional Lax Logic to a first-order language (QLL), {{presenting a}} soundness and completeness theorem for a Gentzen-type system via a syntactic translation into a classical first-order bimodal theory. Previous work [Men 90, Men 93, MF 96, Men 96] on applying Lax Logic {{to deal with}} behavioural constraints in formal hardware verification has demonstrated the complementary nature of abstraction and constraints; we proceed {{to show how the}} Lax Logic Programming (LLP) fragment of QLL can reveal abstractions behind Constraint Logic Programming (CLP). Our main tool is an intensional first-order extension of the Curry-Howard isomorphism between natural deduction proofs in PLL and terms of the computational lambda calculus. Instantiating the <b>monadic</b> <b>operator</b> of QLL by a generic notion of constraint computation, we factor a concrete CLP program into two parts: an abstract LLP program and an associated constraint table. These tables allow us to recover [...] ...|$|E
40|$|Representations of monadic MV-algebra, the {{characterization}} of locally finite monadic MV-algebras, with axiomatization of them, definability of non-trivial <b>monadic</b> <b>operators</b> on finitely generated free MV-algebras are given. Moreover it is shown that a finitely generated m-relatively complete subalgebra of a finitely generated free MV-algebra is projective...|$|R
40|$|We present partial {{translations}} of Haskell programs to Isabelle {{that have been}} imple-mented {{as part of the}} Hets-Programatica system. The logics HOLCF and Isabelle-HOL are targets — under stronger restrictions in the latter case — to translations that are essentially based on a shallow embedding approach. The AWE package has been used to support a translation of <b>monadic</b> <b>operators</b> based on theory morphisms...|$|R
5000|$|... {{or using}} the <b>monadic</b> {{composition}} <b>operator,</b> (f >=> g) x = (f x) >>= g: ...|$|R
40|$|We define an {{interpretation}} of modal languages with polyadic operators in modal languages that use <b>monadic</b> <b>operators</b> (diamonds) only. We also define a simulation operator which associates a logic $Λ^{sim}$ in the diamond language with each logic A in the language with polyadic modal connectives. We prove that this simulation operator transfers several useful properties of modal logics, such as finite/recursive axiomatizability, frame completeness and the finite model property, canonicity and first-order definability...|$|R
40|$|Theory of {{operators}} {{generated by}} binary fuzzy relations is highly increasing for its nature and applicability. The main {{goal of the}} paper is to present several representation theorems for operators induced by fuzzy relations (for example closure operators used in formal concept analysis, <b>monadic</b> <b>operators</b> or tense operators). Consequently we establish algebraic models with their semantics which are usable in the non-classical logic research and in the computer science research. The obtained results are applied {{in the theory of}} Pavelka's algebras...|$|R
40|$|In {{this article}} we {{introduce}} the variety of monadic BL-algebras as BL-algebras endowed with two <b>monadic</b> <b>operators</b> ∀ and ∃. After {{a study of the}} basic properties of this variety we show that this class is the equivalent algebraic semantics of the monadic fragment of Hájek's basic predicate logic. In addition, we start a systematic study of the main subvarieties of monadic BL-algebras, some of which constitute the algebraic semantics of well-known monadic logics: monadic Gödel logic and monadic Łukasiewicz logic. In the last section we give a complete characterization of totally ordered monadic BL-algebras...|$|R
40|$|A {{formalism}} {{for expressing}} the operational semantics of proof languages used in procedural theorem provers is proposed. It {{is argued that}} this formalism provides an elegant way to describe the computational features of proof languages, such as side effects, exception handling, and backtracking. The formalism, called proof monads, finds its roots in category theory, and in particular satisfies the monad laws. It is shown that the framework’s <b>monadic</b> <b>operators</b> are related to fundamental tactics and strategies in procedural theorem provers. Finally, the paper illustrates how proof monads {{can be used to}} implement semantically clean control structure mechanisms in actual proof languages. Keywords: structure...|$|R
40|$|Much of the monadic {{programming}} literature {{gets the}} types right but the abstraction wrong. Using monadic parsing as the motivating example, we demonstrate standard monadic programs in Scheme, recognize how they violate abstraction boundaries, and recover clean abstraction crossings through monadic reflection. Once monadic reflection is made explicit, {{it is possible}} to construct a grammar for monadic programming. This grammar, in turn, enables the redefinition of the <b>monadic</b> <b>operators</b> as macros that eliminate at expansion time the overhead imposed by functional representations. The result is very efficient monadic programs; for parsing, the output code is competitive with good handcrafted parsers...|$|R
40|$|Monads were {{introduced}} in computer science to express the semantics of programs with computational effects, while type and e ect inference was introduced to mark out those effects. In this article, we propose {{a combination of the}} notions of effects and monads, where the <b>monadic</b> <b>operators</b> are parameterized by effects. We establish some relationships between those generalized monads and the classical ones. Then we use a generalized monad to translate imperative programs into purely functional ones. We establish the correctness of that translation. This work has been put into practice in the Coq proof assistant to establish the correctness of imperative programs...|$|R
40|$|AbstractA {{formalism}} {{for expressing}} the operational semantics of proof languages used in procedural theorem provers is proposed. It {{is argued that}} this formalism provides an elegant way to describe the computational features of proof languages, such as side effects, exception handling, and backtracking. The formalism, called proof monads, finds its roots in category theory, and in particular satisfies the monad laws. It is shown that the framework’s <b>monadic</b> <b>operators</b> are related to fundamental tactics and strategies in procedural theorem provers. Finally, the paper illustrates how proof monads {{can be used to}} implement semantically clean control structure mechanisms in actual proof languages...|$|R
40|$|Most of the {{existing}} literature about monadic programming focuses on theory but does not address issues of software engineering. Using monadic parsing as a running example, we demonstrate monadic programs written in a typical style, recognize how they violate abstraction boundaries, and recover clean abstraction crossings through monadic reflection. Once monadic reflection is made explicit, {{it is possible to}} construct a grammar for monadic programming that is independent of domain-specific operations. This grammar, in turn, enables the redefinition of the <b>monadic</b> <b>operators</b> as macros that eliminate at expansion time the overhead imposed by functional representations. The results are very efficient monadic programs; for parsing, the output code is competitive with good hand-crafted parsers. 1...|$|R
40|$|AbstractDeviating from {{standard}} possible-worlds semantics, authors belonging {{to what might}} be called the ‘imperative tradition’ of deontic logic have proposed a semantics that directly represents norms (or imperatives). The paper examines possible definitions of (<b>monadic)</b> deontic <b>operators</b> in such a semantics and some properties of the resulting logical systems...|$|R
40|$|The paper {{focuses on}} {{extending}} {{to the first}} order case the semantical program for modalities first introduced by Dana Scott and Richard Montague. We focus {{on the study of}} neighborhood frames with constant domains and we o#er a series of new completeness results for salient classical systems of first order modal logic. Among other results we show {{that it is possible to}} prove strong completeness results for normal systems without the Barcan Formula (like FOL+K) in terms of neighborhood frames with constant domains. The first order models we present permit the study of many epistemic modalities recently proposed in computer science as well as the development of adequate models for <b>monadic</b> <b>operators</b> of high probability. We conclude by o#ering a general completeness result for the entire family of first order classical modal logics (encompassing both normal and non-normal systems) ...|$|R
40|$|This is a {{connected}} scries {{of arguments}} concerning paraconsistent logic. It is argued first that paraconsistency {{is an option}} worth pursuing in automated reasoning, then that the most popular paraconsistent logic, fde, is inadequate for the reconstruction of essential first order arguments. After a case is made for regarding quantifiers as dyadic rather than <b>monadic</b> <b>operators,</b> it is shown that the addition of such quantifiers to fde allows an implication connective to be defined yielding the known logic BN 4. Refining the treatment of implication {{in a manner similar}} to that found in intuitionist logic leads to the more interesting system BN. 1 Paraconsistency So many authors recently have speculated on the advantages of paraconsistent reasoning for the inference engines of intelligent systems managing large bodies of data that one hesitates to enter the lists again in support of the idea. Prominent among its champions ar...|$|R
40|$|Abstract. The paper {{focuses on}} {{extending}} {{to the first}} order case the semantical program for modalities first introduced by Dana Scott and Richard Montague. We focus {{on the study of}} neighborhood frames with constant domains and we offer a series of new completeness results for salient classical systems of first order modal logic. Among other results we show {{that it is possible to}} prove strong completeness results for normal systems without the Barcan Formula (like FOL + K) in terms of neighborhood frames with constant domains. The first order models we present permit the study of many epistemic modalities recently proposed in computer science as well as the development of adequate models for <b>monadic</b> <b>operators</b> of high probability. Models of this type are either difficult of impossible to build in terms of relational Kripkean semantics. We conclude by introducing general first order neighborhood frames and we offer a general completeness result in terms of them which circumvents some well-known problems of propositional and first order neighborhood semantics (mainly the fact that many classical modal logics are incomplete with respect to an unmodified version of neighborhood frames). We argue that the semantical program that thus arises surpasses both in expressivity and adequacy the standard Kripkean approach, even when it comes to the study of first order normal systems...|$|R
50|$|If the scalar values {{belong to}} the set {0, ½, 1}, this many-valued scalar logic is {{for many of the}} {{operators}} almost identical to the 3-valued logic of Łukasiewicz. Also, it has been proved that when the <b>monadic</b> or dyadic <b>operators</b> act over probabilistic vectors belonging to this set, the output is also an element of this set.|$|R
40|$|At tbe IBM Pisa Scientific Center an {{interactive}} package {{has been developed}} under CP- 67 /CMS, which is particularly helpful when the data to be processed are time series. The interactive facilities of the operating system CP- 67 /CMS are strenghtened {{in such a way}} as to allow an easy interactive correction procedure during the execution of any command. The central file of time series data is available to be interactively shared among several users. Each user can also keep and use her/his own private series. Time series can have annual, semestral, quarterly or monthly entries. Arithmetic, algebraic and trigonometric operators, special operators - mean, variance, maximum, minimum, lagging, variation rate, first difference and selection of a part of a series - are supplied for interactive use. When applied to a time series, <b>monadic</b> <b>operators</b> - logarithm, exponential, etc - return a new series with different numeric data. When applied to two time series with the same periodicity (e. g. both with annual data, etc) dyadic operators - mm, subtraction, etc - return a new series referring to the period common to both the original series. Three interactive methods of estimation are supplied: ordinary least squares (OLS), two stage least squares (TSLS), limited information single equation (LISE). Correlation matrix and graphic plotting routines are provided. In addition it is easy for users with some experience of computer processing to insert special functions in the IMTS environment. ...|$|R
40|$|International audienceWe {{propose a}} normal modal deontic logic {{based on a}} dyadic operator, similar in {{structure}} to the temporal "until". By bringing significant expressiveness to the logic, it allows both the denition of a <b>monadic</b> desirability <b>operator</b> similar to the SDL obligation, and {{the expression of the}} relative level of desirability of target formulae. The interpretation of this logic on a linear structure of worlds ordered by desirability makes its semantics more intuitive and concrete than the SDL deontic accessibility relation. We also show that the core modality of the logic permits to represent the Chisholm and Forrester paradoxes of deontic logic in a more precise way, which does not lead to inconsistencies...|$|R
40|$|Abstract One of {{the selling}} points for {{functional}} languages is {{the ease with}} which parsers for simple languages can be expressed. In this report we give an introduction to <b>monadic</b> and <b>operator</b> precedence parsing in functional languages, using the parsing of propositional logic formulas as an example. 1 Introduction A classical showcase for higher-order functional programming is functional parsing. The idea, which goes back at least to Burge [2], is that powerful parsers can be built simply by combining simple parsers (essentially functions from input strings to output tokens) by higher-order functions, so-called parser combinators, {{whose job it is to}} build complex structure trees from simpler trees. This approach has been followed up by Hutton [5], Fokker [4] and others. Recently the so-called monadic programming style has become popular in functional programming, and monadic parsing has appeared as a useful special case [6]. The Hugs distribution [7] includes a &quot;parser library &quot; which includes support for monadic style parsing...|$|R
40|$|The main {{thrust of}} the {{argument}} of this thesis is to show the possibility of articulating a method of construction or of synthesis [...] as against the most common method of analysis or division [...] which has always been (so we shall argue) a necessary component of scientific theorization. This method will {{be shown to be}} based on a fundamental synthetic logical relation of thought, that we shall call inversion [...] to be understood as a species of logical opposition, and as one of the basic <b>monadic</b> logical <b>operators.</b> Thus the major objective of this thesis is to This thesis {{can be viewed as a}} response to Larry Laudan's challenge, which is based on the claim that ``the case has yet to be made that the rules governing the techniques whereby theories are invented (if any such rules there be) are the sorts of things that philosophers should claim any interest in or competence at. '' The challenge itself would be to show that the logic of discovery (if at all formulatable) performs the epistemological role of the justification of scientific theories. We propose to meet this challenge head on: a) by suggesting precisely how such a logic would be formulated; b) by demonstrating its epistemological relevance (in the context of justification) and c) by showing that a) and b) can be carried out without sacrificing the fallibilist view of scientific knowledge. OBJECTIVES: We have set three successive objectives: one general, one specific, and one sub-specific, each one related to the other in that very order. (A) The general objective is to indicate the clear possibility of renovating the traditional analytico-synthetic epistemology. By realizing this objective, we attempt to widen the scope of scientific reason or rationality, which for some time now has perniciously been dominated by pure analytic reason alone. In order to achieve this end we need to show specifically that there exists the possibility of articulating a synthetic (constructive) logic/reason, which has been considered by most mainstream thinkers either as not articulatable, or simply non-existent. (B) The second (specific) task is to respond to the challenge of Larry Laudan by demonstrating the possibility of an epistemologically significant generativism. In this context we will argue that this generativism, which is our suggested alternative, and the simplified structuralist and semantic view of scientific theories, mutually reinforce each other to form a single coherent foundation for the renovated analytico-synthetic methodological framework. (C) The third (sub-specific) objective, accordingly, is to show the possibility of articulating a synthetic logic that could guide us in understanding the process of theorization. This is realized by proposing the foundations for developing a logic of inversion, which represents the pattern of synthetic reason in the process of constructing scientific definitions...|$|R
40|$|Technical Report N° 1582,UMR 8623 CNRS-Université Paris Sud-LRIRapport de Recherche N° 1582 I Formal Semantics of OCL 0. 1 Introduction 0. 2 Background 0. 2. 1 A Running Example for UML/OCL 0. 2. 2 Formal Foundation 0. 2. 3 How this Annex A was Generated from Isabelle/HOL Theories 0. 3 The Essence of UML-OCL Semantics 0. 3. 1 The Theory Organization 0. 3. 2 Denotational Semantics of Types 0. 3. 3 Denotational Semantics of Constants and Operations 0. 3. 4 Logical Layer 0. 3. 5 Algebraic Layer 0. 3. 6 Object-oriented Datatype Theories 0. 3. 7 Data Invariants 0. 3. 8 Operation Contracts 1 Formalization I: OCL Types and Core Definitions 1. 1 Preliminaries 1. 1. 1 Notations for the Option Type 1. 1. 2 Common Infrastructure for all OCL Types 1. 1. 3 Accommodation of Basic Types to the Abstract Interface 1. 1. 4 The Common Infrastructure of Object Types (Class Types) and States. 1. 1. 5 Common Infrastructure for all OCL Types (II) : Valuations as OCL Types 1. 1. 6 The {{fundamental}} constants 'invalid' and 'null' in all OCL Types 1. 2 Basic OCL Value Types 1. 3 Some OCL Collection Types 1. 3. 1 The Construction of the Pair Type (Tuples) 1. 3. 2 The Construction of the Set Type 1. 3. 3 The Construction of the Bag Type 1. 3. 4 The Construction of the Sequence Type 1. 3. 5 Discussion: The Representation of UML/OCL Types in Featherweight OCL 2 Formalization II: OCL Terms and Library Operations 2. 1 The Operations of the Boolean Type and the OCL Logic 2. 1. 1 Basic Constants 2. 1. 2 Validity and Definedness 2. 1. 3 The Equalities of OCL 2. 1. 4 Logical Connectives {{and their}} Universal Properties 2. 1. 5 A Standard Logical Calculus for OCL 2. 1. 6 OCL's if then else endif 2. 1. 7 Fundamental Predicates on Basic Types: Strict (Referential) Equality 2. 1. 8 Laws to Establish Definedness (δ -closure) 2. 1. 9 A Side-calculus for Constant Terms 2. 2 Property Profiles for OCL Operators via Isabelle Locales 2. 2. 1 Property Profiles for <b>Monadic</b> <b>Operators</b> 2. 2. 2 Property Profiles for Single 2. 2. 3 Property Profiles for Binary Operators 2. 2. 4 Fundamental Predicates on Basic Types: Strict (Referential) Equality 2. 2. 5 Test Statements on Boolean Operations. 2. 3 Basic Type Void: Operations 2. 3. 1 Fundamental Properties on Voids: Strict Equality 2. 3. 2 Basic Void Constants 2. 3. 3 Validity and Definedness Properties 2. 3. 4 Test Statements 2. 4 Basic Type Integer: Operations 2. 4. 1 Fundamental Predicates on Integers: Strict Equality 2. 4. 2 Basic Integer Constants 2. 4. 3 Validity and Definedness Properties 2. 4. 4 Arithmetical Operations 2. 4. 5 Test Statements 2. 5 Basic Type Real: Operations 2. 5. 1 Fundamental Predicates on Reals: Strict Equality 2. 5. 2 Basic Real Constants 2. 5. 3 Validity and Definedness Properties 2. 5. 4 Arithmetical Operations 2. 5. 5 Test Statements 2. 6 Basic Type String: Operations 2. 6. 1 Fundamental Properties on Strings: Strict Equality 2. 6. 2 Basic String Constants 2. 6. 3 Validity and Definedness Properties 2. 6. 4 String Operations 2. 6. 5 Test Statements 2. 7 Collection Type Pairs: Operations 2. 7. 1 Semantic Properties of the Type Constructor 2. 7. 2 Fundamental Properties of Strict Equality 2. 7. 3 Standard Operations Definitions 2. 7. 4 Logical Properties 2. 7. 5 Algebraic Execution Properties 2. 7. 6 Test Statements 2. 8 Collection Type Bag: Operations 2. 8. 1 As a Motivation for the (infinite) Type Construction: Type-Extensions as Bags 2. 8. 2 Basic Properties of the Bag Type 2. 8. 3 Definition: Strict Equality 2. 8. 4 Constants: mtBag 2. 8. 5 Definition: Including 2. 8. 6 Definition: Excluding 2. 8. 7 Definition: Includes 2. 8. 8 Definition: Excludes 2. 8. 9 Definition: Size 2. 8. 10 Definition: IsEmpty 2. 8. 11 Definition: NotEmpty 2. 8. 12 Definition: Any 2. 8. 13 Definition: Forall 2. 8. 14 Definition: Exists 2. 8. 15 Definition: Iterate 2. 8. 16 Definition: Select 2. 8. 17 Definition: Reject 2. 8. 18 Definition: IncludesAll 2. 8. 19 Definition: ExcludesAll 2. 8. 20 Definition: Union 2. 8. 21 Definition: Intersection 2. 8. 22 Definition: Count 2. 8. 23 Definition (future operators) 2. 8. 24 Test Statements 2. 9 Collection Type Set: Operations 2. 9. 1 As a Motivation for the (infinite) Type Construction: Type-Extensions as Sets 2. 9. 2 Basic Properties of the Set Type 2. 9. 3 Definition: Strict Equality 2. 9. 4 Constants: mtSet 2. 9. 5 Definition: Including 2. 9. 6 Definition: Excluding 2. 9. 7 Definition: Includes 2. 9. 8 Definition: Excludes 2. 9. 9 Definition: Size 2. 9. 10 Definition: IsEmpty 2. 9. 11 Definition: NotEmpty 2. 9. 12 Definition: Any 2. 9. 13 Definition: Forall 2. 9. 14 Definition: Exists 2. 9. 15 Definition: Iterate 2. 9. 16 Definition: Select 2. 9. 17 Definition: Reject 2. 9. 18 Definition: IncludesAll 2. 9. 19 Definition: ExcludesAll 2. 9. 20 Definition: Union 2. 9. 21 Definition: Intersection 2. 9. 22 Definition (future operators) 2. 9. 23 Logical Properties 2. 9. 24 Execution Laws with Invalid or Null or Infinite Set as Argument 2. 9. 25 General Algebraic Execution Rules 2. 9. 26 Test Statements 2. 10 Collection Type Sequence: Operations 2. 10. 1 Basic Properties of the Sequence Type 2. 10. 2 Definition: Strict Equality 2. 10. 3 Constants: mtSequence 2. 10. 4 Definition: Prepend 2. 10. 5 Definition: Including 2. 10. 6 Definition: Excluding 2. 10. 7 Definition: Append 2. 10. 8 Definition: Union 2. 10. 9 Definition: At 2. 10. 10 Definition: First 2. 10. 11 Definition: Last 2. 10. 12 Definition: Iterate 2. 10. 13 Definition: Forall 2. 10. 14 Definition: Exists 2. 10. 15 Definition: Collect 2. 10. 16 Definition: Select 2. 10. 17 Definition: Size 2. 10. 18 Definition: IsEmpty 2. 10. 19 Definition: NotEmpty 2. 10. 20 Definition: Any 2. 10. 21 Definition (future operators) 2. 10. 22 Logical Properties 2. 10. 23 Execution Laws with Invalid or Null as Argument 2. 10. 24 General Algebraic Execution Rules 2. 10. 25 Test Statements 2. 11 Miscellaneous Stuff 2. 11. 1 Definition: asBoolean 2. 11. 2 Definition: asInteger 2. 11. 3 Definition: asReal 2. 11. 4 Definition: asPair 2. 11. 5 Definition: asSet 2. 11. 6 Definition: asSequence 2. 11. 7 Definition: asBag 2. 11. 8 Collection Types 2. 11. 9 Test Statements 3 Formalization III: UML/OCL constructs: State Operations and Objects 3. 1 Introduction: States over Typed Object Universes 3. 1. 1 Fundamental Properties on Objects: Core Referential Equality 3. 1. 2 Logic and Algebraic Layer on Object 3. 2 Operations on Object 3. 2. 1 Initial States (for testing and code generation) 3. 2. 2 OclAllInstances 3. 2. 3 OclIsNew, OclIsDeleted, OclIsMaintained, OclIsAbsent 3. 2. 4 OclIsModifiedOnly 3. 2. 5 OclSelf 3. 2. 6 Framing Theorem 3. 2. 7 Miscellaneous 3. 3 Accessors on Object 3. 3. 1 Definition 3. 3. 2 Validity and Definedness Properties 4 Example: The Employee Analysis Model 4. 1 Introduction 4. 1. 1 Outlining the Example 4. 2 Example Data-Universe and its Infrastructure 4. 3 Instantiation of the Generic Strict Equality 4. 4 OclAsType 4. 4. 1 Definition 4. 4. 2 Context Passing 4. 4. 3 Execution with Invalid or Null as Argument 4. 5 OclIsTypeOf 4. 5. 1 Definition 4. 5. 2 Context Passing 4. 5. 3 Execution with Invalid or Null as Argument 4. 5. 4 Up Down Casting 4. 6 OclIsKindOf 4. 6. 1 Definition 4. 6. 2 Context Passing 4. 6. 3 Execution with Invalid or Null as Argument 4. 6. 4 Up Down Casting 4. 7 OclAllInstances 4. 7. 1 OclIsTypeOf 4. 7. 2 OclIsKindOf 4. 8 The Accessors (any, boss, salary) 4. 8. 1 Definition (of the association Employee-Boss) 4. 8. 2 Context Passing 4. 8. 3 Execution with Invalid or Null as Argument 4. 8. 4 Representation in States 4. 9 A Little Infra-structure on Example States 4. 10 OCL Part: Invariant 4. 11 OCL Part: The Contract of a Recursive Query 4. 12 OCL Part: The Contract of a User-defined Method 5 Example: The Employee Design Model 5. 1 Introduction 5. 1. 1 Outlining the Example 5. 2 Example Data-Universe and its Infrastructure 5. 3 Instantiation of the Generic Strict Equality 5. 4 OclAsType 5. 4. 1 Definition 5. 4. 2 Context Passing 5. 4. 3 Execution with Invalid or Null as Argument 5. 5 OclIsTypeOf 5. 5. 1 Definition 5. 5. 2 Context Passing 5. 5. 3 Execution with Invalid or Null as Argument 5. 5. 4 Up Down Casting 5. 6 OclIsKindOf 5. 6. 1 Definition 5. 6. 2 Context Passing 5. 6. 3 Execution with Invalid or Null as Argument 5. 6. 4 Up Down Casting 5. 7 OclAllInstances 5. 7. 1 OclIsTypeOf 5. 7. 2 OclIsKindOf 5. 8 The Accessors (any, boss, salary) 5. 8. 1 Definition 5. 8. 2 Context Passing 5. 8. 3 Execution with Invalid or Null as Argument 5. 8. 4 Representation in States 5. 9 A Little Infra-structure on Example States 5. 10 OCL Part: Invariant 5. 11 OCL Part: The Contract of a Recursive QueryII Conclusion 6 Conclusion 6. 1 Lessons Learned and Contributions 6. 2 Lessons Learned 6. 3 Conclusion and Future WorkIII AppendixA The OCL And Featherweight OCL SyntaxThe Unified Modeling Language (UML) {{is one of}} the few modeling languages that is widely used in industry. While UML is mostly known as diagrammatic modeling language (e. g., visualizing class models), it is complemented by a textual language, called Object Constraint Language (OCL). OCL is a textual annotation language, originally based on a three-valued logic, that turns UML into a formal language. Unfortunately the semantics of this specification language, captured in the “Annex A” of the OCL standard, leads to different interpretations of corner cases. Many of these corner cases had been subject to formal analysis since more than ten years. The situation complicated with the arrival of version 2. 3 of the OCL standard. OCL was aligned with the latest version of UML: this led to the extension of the three-valued logic by a second exception element, called null. While the first exception element invalid has a strict semantics, null has a non strict interpretation. The combination of these semantic features lead to remarkable confusion for implementors of OCL compilers and interpreters. In this paper, we provide a formalization of the core of OCL in HOL. It provides denotational definitions, a logical calculus and operational rules that allow for the execution of OCL expressions by a mixture of term rewriting and code compilation. Moreover, we describe a coding-scheme for UML class models that were annotated by code-invariants and code contracts. An implementation of this coding-scheme has been undertaken: it consists of a kind of compiler that takes a UML class model and translates it into a family of definitions and derived theorems over them capturing the properties of constructors and selectors, tests and casts resulting from the class model. However, this compiler is not included in this document. Our formalization reveals several inconsistencies and contradictions in the current version of the OCL standard. They reflect a challenge to define and implement OCL tools in a uniform manner. Overall, this document is intended to provide the basis for a machine-checked text “Annex A” of the OCL standard targeting at tool implementors...|$|R

