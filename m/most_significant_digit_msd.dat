10|10000|Public
2500|$|Radix sort is an {{algorithm}} that sorts numbers by processing individual digits. n numbers {{consisting of}} k digits each are sorted in O(n · k) time. [...] Radix sort can process digits of each number either {{starting from the}} least significant digit (LSD) or starting from the <b>most</b> <b>significant</b> <b>digit</b> (<b>MSD).</b> [...] The LSD algorithm first sorts the list by the least significant digit while preserving their relative order using a stable sort. Then it sorts them by the next digit, and so on from the least significant to the most significant, ending up with a sorted list. While the LSD radix sort {{requires the use of}} a stable sort, the MSD radix sort algorithm does not (unless stable sorting is desired). [...] In-place MSD radix sort is not stable. [...] It is common for the counting sort algorithm to be used internally by the radix sort. [...] A hybrid sorting approach, such as using insertion sort for small bins improves performance of radix sort significantly.|$|E
50|$|Most digital {{computers}} internally {{represent all}} of their data as electronic representations of binary numbers, so processing the digits of integer representations by groups of binary digit representations is most convenient. Two classifications of radix sorts are least significant digit (LSD) radix sorts and <b>most</b> <b>significant</b> <b>digit</b> (<b>MSD)</b> radix sorts. LSD radix sorts process the integer representations starting from the least digit and move towards the <b>most</b> <b>significant</b> <b>digit.</b> <b>MSD</b> radix sorts work the other way around.|$|E
50|$|A Least {{significant}} digit (LSD) Radix sort is a fast stable sorting algorithm {{which can be}} used to sort keys in integer representation order. Keys may be a string of characters, or numerical digits in a given 'radix'. The processing of the keys begins at the least {{significant digit}} (i.e., the rightmost digit), and proceeds to the most significant digit (i.e., the leftmost digit). The sequence in which digits are processed by an LSD radix sort is the opposite of the sequence in which digits are processed by a <b>most</b> <b>significant</b> <b>digit</b> (<b>MSD)</b> radix sort.|$|E
50|$|Take the <b>most</b> <b>significant</b> <b>digit</b> of each key.|$|R
50|$|It {{was set to}} {{mark the}} <b>most</b> <b>significant</b> <b>digit</b> of a number (wordmark).|$|R
50|$|The other, alternative, {{representation}} {{method is}} based ondensely packed decimal {{for most of}} thesignificand (except the <b>most</b> <b>significant</b> <b>digit).</b>|$|R
50|$|A <b>most</b> <b>{{significant}}</b> <b>digit</b> (<b>MSD)</b> radix sort {{can be used}} to sort keys in lexicographic order. Unlike a least {{significant digit}} (LSD) radix sort, a most significant digit radix sort does not necessarily preserve the original order of duplicate keys. An MSD radix sort starts processing the keys from the most significant digit, leftmost digit, to the least significant digit, rightmost digit. This sequence is opposite that of least significant digit (LSD) radix sorts. An MSD radix sort stops rearranging the position of a key when the processing reaches a unique prefix of the key. Some MSD radix sorts use one level of buckets in which to group the keys. See the counting sort and pigeonhole sort articles. Other MSD radix sorts use multiple levels of buckets, which form a trie or a path in a trie. A postman's sort / postal sort is a kind of MSD radix sort.|$|E
50|$|Radix sort is an {{algorithm}} that sorts numbers by processing individual digits. n numbers {{consisting of}} k digits each are sorted in O(n · k) time. Radix sort can process digits of each number either {{starting from the}} least significant digit (LSD) or starting from the <b>most</b> <b>significant</b> <b>digit</b> (<b>MSD).</b> The LSD algorithm first sorts the list by the least significant digit while preserving their relative order using a stable sort. Then it sorts them by the next digit, and so on from the least significant to the most significant, ending up with a sorted list. While the LSD radix sort {{requires the use of}} a stable sort, the MSD radix sort algorithm does not (unless stable sorting is desired). In-place MSD radix sort is not stable. It is common for the counting sort algorithm to be used internally by the radix sort. A hybrid sorting approach, such as using insertion sort for small bins improves performance of radix sort significantly.|$|E
40|$|In this work, {{we present}} some VLSI {{structures}} suitable for on-line arithmetic embedded algorithms using a radix-two fixed point signed digit system. As an application, we present on-line add/multiply architectures allowing the obtention of a zero-delay operator. An {{example of a}} circuit for on-line computation of several real functions using polynomials is also discussed. I- INTRODUCTION On-line arithmetic principles were introduced by Ercegovac and Trivedi in 1977 [1][2]. In this arithmetic, operands are represented in a redundant number system such as Avizienis' signed digit systems [3]. They are serially introduced starting from the <b>most</b> <b>significant</b> <b>digit</b> (<b>MSD).</b> Consequently, the result MSDs are first obtained, and can thus be exploited while computation is still in progress. This allows dynamically pushing the computation precision to any extent [4][5][6]. To obtain the first digit of the output of an operator, a small number, called the operator on-line delay, of digits of the inp [...] ...|$|E
5000|$|... 8 calls 8 =64, {{subtract}} 64 {{from top}} row numeral [...] "74", leaving one rod at the <b>most</b> <b>significant</b> <b>digit.</b>|$|R
5000|$|A {{third and}} final {{counting}} pass on the <b>most</b> <b>significant</b> <b>digit</b> of each key will produce an array of bucket sizes: ...|$|R
5000|$|Sorting by <b>most</b> <b>significant</b> <b>digit</b> (100s place) gives: Zero {{hundreds}} bucket: 045, 075, 090, 002, 024, 066 One hundreds bucket: 170 Eight hundreds bucket: 802 ...|$|R
40|$|In this paper, {{we present}} a VLSI {{realisation}} of an on-line arithmetic co-processor that implements a novel algorithm known as BKM. The obtained circuit computes the complex exponential or logarithm functions. All basic mathematical operations can hence be computed. The obtained circuit might be considered as the first on-line arithmetic co-processor. The chip was designed using a specific CMOS on-line library, a generated decision and control part and some full-custom blocs. 1 : Introduction On-line arithmetic operators use redundant operands that are serially introduced starting from the <b>most</b> <b>significant</b> <b>digit</b> (<b>MSD).</b> Consequently, the result MSDs are first obtained, and can thus be exploited while computation is still in progress [1]. To obtain the first digit of the output of an operator, a small number, called the operator on-line delay, of digits of the input operands are needed. From then on, a new result digit is generated for each new operand digit [2]. The CORDIC algorithm (COo [...] ...|$|E
40|$|Cloud Computing is a {{computing}} {{paradigm for}} delivering computational power, storage and applications as services via Internet on a pay-as-you-go basis to consumers. The data owner outsources local {{data to the}} public cloud server {{to reduce the cost}} of the data management. Critical data has to be encrypted to ensure privacy before outsourcing. The state-of-the-art SSE schemes search only over encrypted data through keywords, hence they do not provide effective data utilisation for large dataset files in cloud. We propose a Most Significant Index Generation Technique (MSIGT), that supports secure and efficient index generation time using a <b>Most</b> <b>Significant</b> <b>Digit</b> (<b>MSD)</b> radix sort. MSD radix sort is simple and faster in sorting array strings. A mathematical model is developed to encrypt the indexed keywords for secure index generation without the overhead of learning from the attacker/cloud provider. It is seen that the MSIGT scheme can reduce the cost of data on owner side to O(NT × 3) with a score calculation of O(NT). The proposed scheme is effective and efficient in comparison with the existing algorithms...|$|E
40|$|We {{propose the}} first {{hardware}} implementation of standard arithmetic operators – addition, multiplication, and division – that utilises constant compute resource but allows numerical precision {{to be adjusted}} arbitrarily at run-time. Traditionally, precision must be set at design-time so that addition and multiplication, which calculate the least significant digit (LSD) of their results first, and division, which calculates the <b>most</b> <b>significant</b> <b>digit</b> (<b>MSD)</b> first, can be chained together. To get around this, we employ online operators, which are always MSD-first, and thus allow successive operations to be pipelined. Even online operators require precision to be fixed at design-time because multiplication and division traditionally involve parallel adders. To avoid this, we propose an architecture, which we have implemented on an FPGA, that reuses a fixed-precision adder and stores residues in on-chip RAM. As such, we can use {{a single piece of}} hardware to perform calculations to any precision, limited only by the availability of on-chip RAM. For instance, we obtain an 8 x speed-up, compared to the parallel-in-serial-out (PISO) fixedpoint method, when executing 100 iterations of Newton’s method at a precision of 64 digits, while the product of circuit area and latency stays comparable...|$|E
50|$|This {{process is}} similar to {{performing}} long multiplication, but only having to perform the summation of some middle columns. While there are some carries that are not counted, computers usually perform arithmetic for many bits (32 or 64) and they round and we are only interested in the <b>most</b> <b>significant</b> <b>digit(s).</b> There {{is a possibility that}} a particular computation will be akin to failing to add a small number (e.g. 1) to the number 999999999999999, and that the error will propagate to the <b>most</b> <b>significant</b> <b>digit.</b>|$|R
5000|$|Complement {{the result}} {{if there is}} no carry out of the <b>most</b> <b>significant</b> <b>digit</b> (an {{indication}} that x was less than y). This is easier to implement with digital circuits than comparing and swapping the operands. But since taking the radix complement requires adding 1, it is difficult to do directly. Fortunately, a trick can be used to get around this addition: Instead of always setting a carry into the least <b>significant</b> <b>digit</b> when subtracting, the carry out of the <b>most</b> <b>significant</b> <b>digit</b> is used as the carry input into the least <b>significant</b> <b>digit</b> (an operation called an end-around carry). So if y ≤ x, the carry from the <b>most</b> <b>significant</b> <b>digit</b> that would normally be ignored is added, producing the correct result. And if not, the 1 is not added and the result is one less than the radix complement of the answer, or the diminished radix complement, which does not require an addition to obtain. This method is used by computers that use sign-and-magnitude to represent signed numbers.....|$|R
50|$|An {{automaton}} {{reading the}} base k digits of s(n) {{starting with the}} <b>most</b> <b>significant</b> <b>digit</b> {{is said to be}} direct reading, while an automaton starting with the least <b>significant</b> <b>digit</b> is reverse reading. The above definition holds whether s(n) is direct or reverse reading.|$|R
40|$|Many {{different}} number systems {{perhaps from}} the prehistoric era {{have been developed}} and evolved. Among them, binary number system {{is one of the}} simplest and effective number systems, and has been extensively used in digital systems. Studying number systems can help you understand the basic computing processes by digital systems. 1. 1 Positional Number Systems A good example of positional number system is the decimal number system in which we use them almost everywhere number is needed. Another example is the binary system that is used as the basic number system for all computers. In positional number systems, a number is represented by a string of digits where the position of each digit is associated with a weight. In general, a positional number is expressed as: d d ⋅ ⋅ ⋅ d d. d d ⋅ ⋅ ⋅ d m− 1 m− 2 1 0 − 1 − 2 − n where d {{is referred to as the}} <b>most</b> <b>significant</b> <b>digit</b> (<b>MSD)</b> and m− 1 d as the least significant digit − n (LSD). Each digit position has an associated weight b i where b is called the base or radix. The point in the middle is referred to as a radix point and is used to separate the integer and fractional part of a number. Integer part is in the left side of the radix point; fraction part is in the right side of the radix point. Fraction is a portion of magnitude of a number which is less than unit (e. g. fraction < 1) and thus it is called a fraction. Let D denote the value (or magnitude) of a positional number, then D can be always calculated by: m− i = − n 1 D = d ⋅...|$|E
5000|$|Decrease m by one. Let x be {{the leading}} (<b>most</b> <b>significant)</b> <b>digit</b> in a, x = a div β m and y the leading digit in b, y = b div β m.|$|R
2500|$|Benford's law, {{also called}} the first-digit law, is an {{observation}} about the frequency distribution of leading digits in many real-life sets of numerical data. The law states that in many naturally occurring collections of numbers, the leading <b>significant</b> <b>digit</b> {{is likely to be}} small. For example, in sets that obey the law, the number [...] appears as the <b>most</b> <b>significant</b> <b>digit</b> about 30% of the time, while [...] appears as the <b>most</b> <b>significant</b> <b>digit</b> less than 5% of the time. By contrast, if the digits were distributed uniformly, they would each occur about 11.1% of the time. Benford's law also makes predictions about the distribution of second digits, third digits, digit combinations, and so on.|$|R
5000|$|A signed (meaning {{negative}} or non-negative) digit string {{of a given}} length in a given base (or radix). This digit string {{is referred to as}} the significand, mantissa, or coefficient. The length of the significand determines the precision to which numbers can be represented. The radix point position is assumed always to be somewhere within the significand—often just after or just before the <b>most</b> <b>significant</b> <b>digit,</b> or to the right of the rightmost (least <b>significant)</b> <b>digit.</b> This article generally follows the convention that the radix point is set just after the <b>most</b> <b>significant</b> (leftmost) <b>digit.</b>|$|R
40|$|Abstract—The {{conversion}} between Tetrad Notation {{and other}} notational systems has attracted people’s attention; addition conjecture: if the maximum digit of base-N notation is (N- 1), then（N- 1 ）+（N- 1 ）is a binary <b>digit,</b> whose <b>most</b> <b>significant</b> <b>digit</b> is 1 and least <b>significant</b> <b>digit</b> is (N- 2); multiplication conjecture: if the maximum digit of base-N notation is (N- 1), then（N- 1 ）*（N- 1 ）is a binary <b>digit,</b> whose <b>most</b> <b>significant</b> <b>digit</b> is (N- 2) and least <b>significant</b> <b>digit</b> is 1; simple conversion conjecture: given, the radix of two sorts of number system N 1,N 2 are R 1,R 2 respectively, i is an integer greater than 2 or equals to 2, so if R 1 = R 2 i, then some relatively simple relationship of conversion exists {{between these two}} number systems...|$|R
50|$|Note that {{although}} Arabic is written {{from right to}} left, while English is written left to right, in both languages numbers are written with the <b>most</b> <b>significant</b> <b>digit</b> {{on the left and}} the least significant on the right.|$|R
50|$|The {{operation}} crank {{is turned}} and the divisor is subtracted from the accumulator repeatedly until {{the left hand}} (<b>most</b> <b>significant)</b> <b>digit</b> of the result is 0. The number showing on the multiplier dial is then the first digit of the quotient.|$|R
5000|$|Here {{since the}} place value of [...] {{is an even}} power of 10, we only {{need to work with}} the pair of <b>most</b> <b>significant</b> <b>digits</b> of the {{remaining}} term [...] at any m-th stage. The section below codifies this procedure.|$|R
5000|$|In the decimal {{representation}} method, the 16-digit significand {{is represented}} as a decimal coded positive integer, based on densely packed decimal with 5 groups of 3 <b>digits</b> (except the <b>most</b> <b>significant</b> <b>digit</b> encoded specially) are each represented in declets (10-bit sequences).|$|R
2500|$|A signed (meaning {{negative}} or non-negative) digit string {{of a given}} length in a given base (or radix). This digit string {{is referred to as}} the significand, mantissa, or coefficient. The length of the significand determines the precision to which numbers can be represented. [...] The radix point position is assumed always to be somewhere within the significand—often just after or just before the <b>most</b> <b>significant</b> <b>digit,</b> or to the right of the rightmost (least <b>significant)</b> <b>digit.</b> [...] This article generally follows the convention that the radix point is set just after the <b>most</b> <b>significant</b> (leftmost) <b>digit.</b>|$|R
50|$|The leading bit (s in the above) {{is a sign}} bit, and the {{following}} bits (xxx in the above) encode the additional exponent bits and {{the remainder of the}} <b>most</b> <b>significant</b> <b>digit,</b> but the details vary depending on the encoding alternative used.|$|R
40|$|The paper {{presents}} a general theory for developing new Svoboda-Tung (or simply NST) division algorithms not suffering the drawbacks of the "classical" Svoboda-Tung (or simply ST) method. NST avoids the drawbacks of ST by proper recoding {{of the two}} <b>most</b> <b>significant</b> <b>digits</b> of the residual before selecting the <b>most</b> <b>significant</b> <b>digit</b> of this recoded residual as the quotient digit. NST relies on the divisor being in the range [1, 1 + delta), where delta is a positive fraction depending upon: 1) the radix, 2) the signed digit set used to represent the residual, and 3) the recoding conditions of the two <b>most</b> <b>significant</b> <b>digits</b> of the residual. If the operands belong to the IEEE Std range [1, 2), {{they have to be}} conveniently prescaled. In that case, NST produces the correct quotient but the final residual is scaled by the same factor as the operands, therefore, NST is not useful in applications where the unsealed residual is necessary. An analysis of NST shows that previously published algorithms can be derived from the general theory proposed in the paper. Moreover, NST reveals a spectrum of new possibilities for the design of alternative division units. For a given radix-b, the number of different algorithms of this kind is b/sup 2 // 4...|$|R
500|$|... 7 + 9 = 16, and the digit 1 is the carry. An {{alternate}} strategy starts adding {{from the}} <b>most</b> <b>significant</b> <b>digit</b> on the left; this route makes carrying a little clumsier, {{but it is}} faster at getting a rough estimate of the sum. There are many alternative methods.|$|R
40|$|Number Decision Diagrams (NDD) {{provide a}} natural finite {{symbolic}} representation for regular set of integer vectors encoded as strings of digit vectors (least or <b>most</b> <b>significant</b> <b>digit</b> first). The convex {{hull of the}} set of vectors represented by a NDD is {{proved to be an}} effectively computable convex polyhedron...|$|R
5000|$|... 7 + 9 = 16, and the digit 1 is the carry. An {{alternate}} strategy starts adding {{from the}} <b>most</b> <b>significant</b> <b>digit</b> on the left; this route makes carrying a little clumsier, {{but it is}} faster at getting a rough estimate of the sum. There are many alternative methods.|$|R
2500|$|Cancellation: {{subtraction}} {{of nearly}} equal operands may cause extreme loss of accuracy. When we subtract two almost equal numbers we set the <b>most</b> <b>significant</b> <b>digits</b> to zero, leaving ourselves {{with just the}} insignificant, and most erroneous, digits. For example, when determining a derivative of a function the following formula is used: ...|$|R
40|$|International audienceNumber Decision Diagrams (NDD) {{provide a}} natural finite {{symbolic}} representation for regular set of integer vectors encoded as strings of digit vectors (least or <b>most</b> <b>significant</b> <b>digit</b> first). The convex {{hull of the}} set of vectors represented by a NDD is {{proved to be an}} effectively computable convex polyhedron...|$|R
50|$|Leading zeros {{also present}} {{whenever}} {{the number of}} digits is technically fixed (such as in a memory register), but the stored value is not large enough {{to result in a}} non-zero <b>most</b> <b>significant</b> <b>digit.</b> The count leading zeros operation efficiently determines the number of leading zero bits in a machine word.|$|R
