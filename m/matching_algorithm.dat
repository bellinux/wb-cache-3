4131|3714|Public
25|$|A {{matching}} in a graph is {{a subset}} of its edges, no two of which share an endpoint. Polynomial time algorithms are known for many algorithmic problems on matchings, including maximum matching (finding a matching that uses as many edges as possible), maximum weight matching, and stable marriage. In many cases, matching problems are simpler to solve on bipartite graphs than on non-bipartite graphs, and many matching algorithms such as the Hopcroft–Karp algorithm for maximum cardinality <b>matching</b> <b>algorithm</b> for maximum matchings in bipartite graphs|journal=SIAM Journal on Computing|volume=2|issue=4|pages=225–231|year=1973|doi=10.1137/0202019}}. work correctly only on bipartite inputs.|$|E
25|$|Fingerprint {{processing}} {{has three}} primary functions: enrollment, searching and verification. Among these functions, enrollment which captures fingerprint {{image from the}} sensor plays an important role. A {{reason is that the}} way people put their fingerprints on a mirror to scan can affect to the result in the searching and verifying process. Regarding to verification function, there are several techniques to match fingerprints such as correlation-based matching, minutiae-based matching, ridge feature-based matching and minutiae-based algorithm. However, the most popular algorithm was minutiae based <b>matching</b> <b>algorithm</b> due to its efficiency and accuracy.|$|E
25|$|Projected lattice {{geometries}} can {{be represented}} by so-called ‘lattice-fringe fingerprint plots’ (LFFPs), also called angular covariance plots. The horizontal axis of such a plot is given in reciprocal lattice length and {{is limited by the}} point resolution of the microscope. The vertical axis is defined as acute angle between Fourier transformed lattice fringes or electron diffraction spots. A 2D data point is defined by the length of a reciprocal lattice vector and its (acute) angle with another reciprocal lattice vector. Sets of 2D data points that obey Weiss’s zone law are subsets of the entirety of data points in an LFFP. A suitable search-match algorithm using LFFPs, therefore, tries to find matching zone axis subsets in the database. It is, essentially, a variant of a lattice <b>matching</b> <b>algorithm.</b>|$|E
40|$|Abstract: Many map <b>matching</b> <b>algorithms</b> {{have been}} {{developed}} to match GPS points to a digital map in previous studies. But the previous studies assume short polling time intervals(about 1 second) of the GPS data. And the map <b>matching</b> <b>algorithms</b> of such studies are not appropriate for the GPS data with relatively long polling time intervals(about 2 ~ 5 minutes). In this paper, we will review the previous map <b>matching</b> <b>algorithms</b> and discuss the map <b>matching</b> <b>algorithms</b> which can be used under circumstances of relatively long polling time intervals...|$|R
50|$|Template <b>matching</b> <b>algorithms</b> in CA {{have come}} to be called LDDMM, Large Deformation Diffeomorphic Metric Mapping; there are nowLDDMM {{template}} <b>matching</b> <b>algorithms</b> for <b>matching</b> landmark points, curves, surfaces, volumes.|$|R
40|$|Most of the schema {{matching}} {{tools are}} assembled from multiple <b>match</b> <b>algorithms,</b> each employing a particular technique to improve matching accuracy and making matching systems extensible and customizable {{to a specific}} domain. Recently, it has been {{pointed out that the}} main issue is how to select the most suitable <b>match</b> <b>algorithms</b> to execute for a given domain and how to adjust the multiple parameters. The solutions provided by current schema matching tools consist in aggregating the results obtained by several <b>match</b> <b>algorithms</b> {{to improve the quality of}} the discovered matches. In this article, we present a novel method to replace this aggregation function and its drawbacks. Unlike other composite matchers, our matching engine makes use of a decision tree to combine the most appropriate <b>match</b> <b>algorithms.</b> As a first consequence, the performance of the system is improved since only a subset of <b>match</b> <b>algorithms</b> from a large library is used. The second advantage is the improvement of the quality of matches. Indeed, for a given domain, only the most suitable <b>match</b> <b>algorithms</b> are used. Our approach is also able to learn the most appropriate <b>match</b> <b>algorithms</b> for a given domain by relying on the expert feedback. It can also selftune some parameters like thresholds and the performance versus quality ratio...|$|R
500|$|The Aanderaa–Karp–Rosenberg {{conjecture}} also {{states that}} the randomized decision tree complexity of non-trivial monotone functions is [...] The conjecture again remains unproven, but has been resolved for the property of containing a [...] clique for [...] This property {{is known to have}} randomized decision tree complexity [...] For quantum decision trees, the best known lower bound is , but no <b>matching</b> <b>algorithm</b> is known for the case of [...]|$|E
2500|$|... {{search engine}} of the [...] website, using the Daitch–Mokotoff Soundex and Beider–Morse Phonetic Name <b>Matching</b> <b>Algorithm</b> systems for {{approximate}} spellings of place names ...|$|E
2500|$|In contrast, it is {{possible}} to test whether a given graph [...] is very well covered in polynomial time. To do so, find the subgraph [...] of [...] consisting of the edges that satisfy the two properties of a matched edge in a very well covered graph, and then use a <b>matching</b> <b>algorithm</b> to test whether [...] has a perfect matching. Some problems that are NP-complete for arbitrary graphs, such as the problem of finding a Hamiltonian cycle, may also be solved in polynomial time for very well covered graphs.|$|E
40|$|Abstract. Most of the schema {{matching}} {{tools are}} assembled from multiple <b>match</b> <b>algorithms,</b> each employing a particular technique to improve matching accuracy and making matching systems extensible and customizable {{to a particular}} domain. Recently, it has been {{pointed out that the}} main issue is how to select the most suitable <b>match</b> <b>algorithms</b> to execute for a given domain and how to adjust the multiple knobs (e. g. threshold, performance, quality, etc.). The solutions provided by current schema matching tools consist in aggregating the results obtained by several <b>match</b> <b>algorithms</b> {{to improve the quality of}} the discovered matches. However, aggregation entails several drawbacks. In this article, we present a novel method for combining schema <b>matching</b> <b>algorithms.</b> The <b>matching</b> engine makes use of a decision tree to combine the most appropriate <b>match</b> <b>algorithms.</b> As a first consequence of using the decision tree, the performance of the system is improved since the complexity is bounded by the height of the decision tree. Thus, only a subset of these <b>match</b> <b>algorithms</b> is used during the matching process. The second advantage is the improvement of the quality of matches. Indeed, for a given domain, only the most suitable <b>match</b> <b>algorithms</b> are used. The experiments show the effectiveness of our approach w. r. t. other matching tools. ...|$|R
40|$|Integration {{of various}} {{fingerprint}} <b>matching</b> <b>algorithms</b> {{is a viable}} method to improve {{the performance of a}} fingerprint verification system. Different fingerprint <b>matching</b> <b>algorithms</b> are often based on different representations of the input fingerprints and hence complement each other. We use the logistic transform to integrate the output scores from three different fingerprint <b>matching</b> <b>algorithms.</b> Experiments conducted on a large fingerprint database confirm the effectiveness of the proposed integration scheme...|$|R
40|$|Virtual Output Queuing {{is widely}} used by fixed-length {{highspeed}} switches to overcome head-of-line blocking. This is done by means of <b>matching</b> <b>algorithms.</b> Maximum <b>matching</b> <b>algorithms</b> have good performance, but their implementation complexity is quite high. Maximal <b>matching</b> <b>algorithms</b> need speedup to guarantee good performance. Iterative algorithms (such as PIM and iSLIP) use multiple iterations to converge on a maximal match. The Dual Round-Robin Matching (DRRM) scheme has performance similar to iSLIP and lower implementation complexity. The objectiv...|$|R
2500|$|There is a [...] time {{algorithm}} to find {{a maximum}} matching or a maximum weight matching in a graph that is not bipartite; it is due to Jack Edmonds, is called the paths, trees, and flowers method or simply Edmonds' algorithm, and uses bidirected edges. A generalization of the same technique {{can also be used}} to find maximum independent sets in claw-free graphs. Edmonds' algorithm has subsequently been improved to run in time [...] time using Micali and Vazirani's <b>matching</b> <b>algorithm.</b> algorithm for finding maximum matching in general graphs ...|$|E
2500|$|The {{same idea}} {{of finding a}} maximal set of {{shortest}} augmenting paths works also for finding maximum cardinality matchings in non-bipartite graphs, and {{for the same reasons}} the algorithms based on this idea take [...] phases. However, for non-bipartite graphs, the task of finding the augmenting paths within each phase is more difficult. Building on the work of several slower predecessors, [...] showed how to implement a phase in linear time, resulting in a non-bipartite <b>matching</b> <b>algorithm</b> with the same time bound as the Hopcroft–Karp algorithm for bipartite graphs. The Micali–Vazirani technique is complex, and its authors did not provide full proofs of their results; subsequently, ...|$|E
5000|$|Aho-Corasick string <b>matching</b> <b>algorithm</b> (extension of Knuth-Morris-Pratt) ...|$|E
40|$|TREAT: A New and Efficient <b>Match</b> <b>Algorithm</b> for AI Production Systems {{describes}} the architecture and software systems embodying the DADO machine, a parallel tree-structured computer {{designed to provide}} significant performance improvements over serial computers of comparable hardware complexity in the execution of large expert systems implemented in production system form. This book focuses on TREAT as a <b>match</b> <b>algorithm</b> for executing production systems that is presented and comparatively analyzed with the RETE <b>match</b> <b>algorithm.</b> TREAT, originally designed specifically for the DADO machine architec...|$|R
5000|$|Maximum {{cardinality}} {{and minimum}} cost perfect <b>matching</b> <b>algorithms</b> ...|$|R
40|$|Generally, block <b>matching</b> <b>algorithms</b> are {{the most}} time {{consuming}} {{in the process of}} motion estimation in compressing the video for transmission. This paper gives a new block <b>matching</b> <b>algorithms</b> designed particularly for fast transmission purposes that will have less computations and almost same quality of the existing algorithms...|$|R
5000|$|... #Subtitle level 2: Beider-Morse Phonetic Name <b>Matching</b> <b>Algorithm</b> ...|$|E
5000|$|ASIFT -> Affine-Sift (A fully affine {{invariant}} image <b>matching</b> <b>algorithm)</b> ...|$|E
50|$|GNU grep {{implements}} {{a string}} <b>matching</b> <b>algorithm</b> {{very similar to}} Commentz-Walter.|$|E
40|$|To {{improve the}} {{matching}} accuracy, {{most of the}} schema matching tools aggregate the results obtained by several <b>matching</b> <b>algorithms.</b> The quality of matches depends on the adequacy and of the num-ber of <b>match</b> <b>algorithms</b> used, and their combination and aggre-gation strategy. However, this aggregation entails several draw-backs on the performance, quality and tuning aspects. In this paper, we present a novel method for combining schema matching algo-rithms, which enables to avoid these drawbacks. Unlike other com-posite matchers, {{it is able to}} learn the most appropriate match algo-rithms for a given schema matching scenario. Thus, the matching engine makes use of a decision tree to combine most appropriate <b>match</b> <b>algorithms.</b> As a first consequence of using the decision tree, the performance of the system is improved since the complexity is bounded by the height of the decision tree. For this purpose, for a given domain, only the most suitable <b>match</b> <b>algorithms</b> are used from a large library of <b>match</b> <b>algorithms.</b> The second advantage is the improvement of the quality of matches. 1...|$|R
5000|$|... #Subtitle level 2: A {{taxonomy}} of metadata <b>matching</b> <b>algorithms</b> ...|$|R
5000|$|... #Subtitle level 2: Comparison {{with other}} bipartite <b>matching</b> <b>algorithms</b> ...|$|R
50|$|The Aho-Corasick string <b>matching</b> <b>algorithm</b> {{formed the}} basis of the {{original}} Unix command fgrep.|$|E
50|$|This method {{utilizes}} the Wu-Manber approximate string <b>matching</b> <b>algorithm</b> {{to generate}} multiple sequence alignments.|$|E
5000|$|It {{is one of}} the {{earliest}} fast block <b>matching</b> <b>algorithm.</b> It runs as follows: ...|$|E
40|$|International audienceMost of the schema {{matching}} {{tools are}} assembled from multiple <b>match</b> <b>algorithms,</b> each employing a particular technique to improve matching accuracy and making matching systems extensible and customizable {{to a particular}} do- main. The solutions provided by current schema matching tools consist in aggre- gating the results obtained by several <b>match</b> <b>algorithms</b> {{to improve the quality}} of the discovered matches. However, aggregation entails several drawbacks. Re- cently, it has been pointed out that the main issue is how to select the most suitable <b>match</b> <b>algorithms</b> to execute for a given domain and how to adjust the multiple knobs (e. g. threshold, performance, quality, etc.). In this article, we present a novel method for selecting the most appropriate schema <b>matching</b> <b>algorithms.</b> The <b>matching</b> engine makes use of a decision tree to combine the most appro- priate <b>match</b> <b>algorithms.</b> As a first consequence of using the decision tree, the performance of the system is improved since the complexity is bounded by the height of the decision tree. Thus, only a subset of these <b>match</b> <b>algorithms</b> is used during the matching process. The second advantage is the improvement of the quality of matches. Indeed, for a given domain, only the most suitable match al- gorithms are used. The experiments show the effectiveness of our approach w. r. t. other matching tools...|$|R
30|$|<b>Match</b> <b>algorithm</b> returns 1.0 for case 1, case 3, {{and case}} 4 in Fig. 1 if the node labels are the same. For case 2, it computes the average arc weights of two {{identical}} arcs each taken from one tree and multiplies with the <b>Match</b> <b>algorithm</b> at their sub-trees recursively. It sums the matching value at every pair of such identical arcs. Note {{that it gives}} a small similarity as node equality (ε) to avoid zero matching value because of multiplication of recursive algorithm in case if all sub-trees matching value is zero. <b>Match</b> <b>algorithm</b> is given in Algorithm 3.|$|R
40|$|This is {{an article}} from the journal, Geoinformatica [© Springer Verlag]. The {{original}} publication {{is available at}} www. springerlink. comMap <b>matching</b> <b>algorithms</b> are utilised to support the navigation module of advanced transport telematics systems. The objective {{of this paper is}} to develop a framework to quantify the effects of spatial road network data and navigation sensor data on the performance of map <b>matching</b> <b>algorithms.</b> Three map <b>matching</b> <b>algorithms</b> are tested with different spatial road network data (map scale 1 : 1, 250; 1 : 2, 500 and 1 : 50, 000) and navigation sensor data (global positioning system (GPS) and GPS augmented with deduced reckoning) in order to quantify their performance. The algorithms are applied to different road networks of varying complexity. The performance of the algorithms is then assessed for a suburban road network using high precision positioning data obtained from GPS carrier phase observables. The results show that there are considerable effects of spatial road network data on the performance of map <b>matching</b> <b>algorithms.</b> For an urban road network, the results suggest that both the quality of spatial road network data and the type of navigation system affect the link identification performance of map <b>matching</b> <b>algorithms...</b>|$|R
5000|$|A string <b>matching</b> <b>algorithm</b> {{wants to}} find the {{starting}} index [...] in string [...] that matches the search word [...]|$|E
50|$|In {{such cases}} the {{mechanism}} implements some fuzzy string <b>matching</b> <b>algorithm</b> and possibly some algorithm for finding {{the similarity between}} text fragment and pattern.|$|E
50|$|The two parties' {{rank order}} lists are {{processed}} using the NRMP's <b>matching</b> <b>algorithm,</b> which creates stable (a proxy for optimal) matches between applicants and programs.|$|E
5000|$|<b>Matching</b> <b>algorithms</b> to {{identify}} irregularities in the transactions of users compared to previous profiles.|$|R
40|$|Exact String Matching is an {{essential}} issue in many computer science applications. Unfortunately, the performance of Exact String <b>Matching</b> <b>algorithms,</b> namely, executing time, {{does not address the}} needs of these applications. This paper proposes a general platform for improving the existing Exact String <b>Matching</b> <b>algorithms</b> executing time, called the PXSMAlg platform. The function of this platform is to parallelize the Exact String <b>Matching</b> <b>algorithms</b> using the MPI model over the Master or Slaves paradigms. The PXSMAlg platform parallelization process is done by dividing the Text into several parts and working on these parts simultaneously. This improves the executing time of the Exact String <b>Matching</b> <b>algorithms.</b> We have simulated the PXSMAlg platform in order to show its competence, through applying the Quick Search algorithm on the PXSMAlg platform. The simulation result showed significant improvement in the Quick Search executing time, and therefore extreme competence in the PXSMAlg platform. Comment: IEEE format, International Journal of Computer Science and Information Security, IJCSIS January 2010, ISSN 1947 5500, [URL]...|$|R
40|$|The {{importance}} and {{the contribution of}} string <b>matching</b> <b>algorithms</b> to the modern society cannot be overstated. From basic search algorithms such as spell checking and data querying, to advanced algorithms such as DNA sequencing, trend analysis and signal processing, string <b>matching</b> <b>algorithms</b> form the foundation of many aspects in computing that have been pivotal in technological advancement. In general, string <b>matching</b> <b>algorithms</b> {{can be divided into}} the categories of exact string matching and approximate string matching. We study each area and examine some of the well known algorithms. We probe {{into one of the most}} intriguing data structure in string algorithms, the suffix tree. The lowest common ancestor extension of the suffix tree is the key to many advanced string <b>matching</b> <b>algorithms.</b> With these tools, we are able to solve string problems that were, until recently, thought intractable by many. Another interesting and relatively new data structure in string algorithms is the suffix array, which has significant breakthroughs in its linear time construction in recent years. Primarily, this thesis focuses on approximate string matching using dynamic programming and hybrid dynamic programming with suffix tree. We study both approaches in detail and see how the merger of exact string matching and approximate string <b>matching</b> <b>algorithms</b> can yield synergistic results in our experiments...|$|R
