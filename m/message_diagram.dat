1|33|Public
40|$|Two of {{the most}} popular {{object-oriented}} development methods, Booch and Object Modelling Technique, are currently being integrated into one "Unified Method" by their respective authors, Grady Booch and James Rumbaugh. This document presents an analysis of Unified Method modelling tools based upon the first publicly available documentation. The elements of each tool are described and graphically presented. Expansion/compression capabilities of elements are described where appropriate. Modelling Tools of the Unified Method ii Contents 1 Introduction 1 2 The Note 2 3 Class Diagram 3 3. 1 Category 3. 2 Category Dependency 5 3. 3 Class 3. 4 Template Class 6 3. 5 Instantiated class 7 3. 6 Utility Class 8 3. 7 Object 3. 8 Relationship 9 3. 8. 1 Association 10 3. 8. 2 Generalisation 13 3. 9 Composite 14 3. 10 Constraint 15 4 Use-Case Diagram 17 4. 1 Use-case 4. 2 Actor 18 5 Scenario 19 5. 1 Message Trace Diagram 5. 1. 1 Object 5. 1. 2 Message 20 5. 2 Object <b>Message</b> <b>Diagram</b> 21 5. 2. 1 Object 22 5. 2. 2 Link 5. 2 [...] . ...|$|E
3000|$|Extension <b>messages</b> {{comprising}} cartoons, <b>diagrams</b> {{and images}} {{were incorporated into}} the following extension materials: [...]...|$|R
50|$|A Communication diagram models the {{interactions}} between objects or parts in terms of sequenced <b>messages.</b> Communication <b>diagrams</b> represent a combination of information taken from Class, Sequence, and Use Case Diagrams describing both the static structure and dynamic behavior of a system.|$|R
40|$|In this paper, {{we present}} a variant of <b>message</b> {{sequence}} <b>diagrams</b> called EETs (Extended Event Traces). We provide the graphical notation, discuss the methodological use of EETs to describe behavior of object-oriented business information systems, and sketch their semantics. Special emphasis is put on the different implications of using EETs for exemplary and complete interaction descriptions. The possibility to describe interactions between single objects as well as composite objects with EETs makes them particularly suitable to describe the behavior of large systems. 1 Introduction and Classification <b>Message</b> sequence <b>diagrams</b> {{are one of the}} most widely accepted graphical techniques for describing the dynamic behavior of systems. Originally developed for the design of technical systems (in particular: telecommunication protocols, cf. [IT 94, IT 96]), sequence diagrams have recently become increasingly popular in the field of business information systems. Most object-oriented analysis an [...] ...|$|R
40|$|A formal {{model of}} the {{information}} exchange process dur-ing a (building) project is presented. The process descrip-tion consists of the required input and output for each activ-ity in the project. The model is implemented by means of colored Petri Nets. Simulation of the model for a specific project shows any hidden inconsistency or incompleteness in the project description. From the simulation an activity net-work, time schedule and <b>message</b> exchange <b>diagram</b> can be deduced for the project...|$|R
40|$|In {{this paper}} {{we present a}} variant of <b>message</b> {{sequence}} <b>diagrams</b> called EETs Extended Event Traces We provide the graphical notation discuss the methodological use of EETs to describe behavior of object oriented business information systems and sketch their semantics Special emphasis is put on the different implications of using EETs for exemplary and complete interaction descriptions. The possibility to describe interactions between single objects as well as composite objects with EETs makes them particularly suitable to describe the behavior of large systems. Comment: 11 pages, 4 figure...|$|R
40|$|Scheme for coding {{facsimile}} messages {{promises to}} reduce data transmission requirements to one-tenth current level. Coding scheme paves way for true electronic mail in which handwritten, typed, or printed <b>messages</b> or <b>diagrams</b> sent virtually instantaneously - between buildings or between continents. Scheme, called Universal System for Efficient Electronic Mail (USEEM), uses unsupervised character recognition and adaptive noiseless coding of text. Image quality of resulting delivered messages improved over messages transmitted by conventional coding. Coding scheme compatible with direct-entry electronic mail {{as well as}} facsimile reproduction. Text transmitted in this scheme automatically translated to word-processor form...|$|R
40|$|New {{communication}} media {{offer new}} opportunities to exchange information between {{participants in a}} building project. A case study was done of a specific building project {{from the viewpoint of}} a company that produces concrete floors. An executable simulation model was used to create a formal description of the information exchange process. The output of the simulation is an activity schema, a <b>message</b> exchange <b>diagram</b> and a list of messages. The schemata give insight about the information flow and are a resource for developing a strategy for the introduction of electronic communication. The messages serve {{as a starting point for}} selecting a standardized electronic message or developing a special one. 1...|$|R
40|$|The {{existing}} code generations methods {{focus on}} UML Class diagram, which easily represents code structure such as class, method, attribute, but just possibly generate a skeleton code. In this paper we describe to apply UML <b>Message</b> Sequence <b>Diagram</b> (MSD) for representing interactive behavior among objects, and generate more sophisticated Java Code for Android Platform. We also propose code generation method based on Meta Object Facility (MOF) using model transformation technique. And we show metamodel of MSD and model transformation rules written by Acceleo. Using proposed method, we can optimize Java code of Android platform, and increase more code generation rate {{than the previous}} approaches...|$|R
50|$|However, {{communication}} diagrams use the free-form {{arrangement of}} objects and links as used in Object diagrams. In {{order to maintain the}} ordering of messages in such a free-form <b>diagram,</b> <b>messages</b> are labeled with a chronological number and placed near the link the message is sent over. Reading a communication diagram involves starting at message 1.0, and following the messages from object to object.|$|R
30|$|The {{semantic}} {{components of}} cognitive programming {{are defined by}} morphisms from the model’sformal components to a set interpretation system. When the set interpretation system of the cognitive model is represented using sets of documents, each interpretive document may be an abstract, book, comment or voice <b>message,</b> visual image, <b>diagram,</b> statistical regularity, survey result, the scale of an expert’s assessment of the relevance factor, etc.|$|R
40|$|Most model {{transformation}} approaches {{expressed to}} transform the static model structures of a system, but not involved with the behavioral model. Our previous model transformation [10] also focused on the structural model, especially class diagram, which was restricted to generate a detailed code. To solve this problem, we propose model transformation with both structural and behavioral models, that is, a <b>message</b> sequence <b>diagram</b> with a class diagram for developing heterogeneous software. This approach {{makes it possible to}} generate detailed codes through the static & behavioral expression of a system. This is also better to transform more specific design than the previous structure-based model transformation based on only static structure [11 - 15]. We show the application cases to perform model transformation on the three platforms—Android, iPhone, and Windows Phone...|$|R
40|$|The task of Business Engineering (BE) {{would be}} {{effective}} if provided with tools {{that support the}} analysis and understanding of a business system. This study aims at 1) empirically investigating the cognitive processes of analyzing multiple models of the object-oriented methodology, 2) identifying the problem solving strategy for understanding a business system, and 3) proposing a modeling formalism that fits the problem solving strategy. The {{results of this study}} show that existing object-oriented methodologies need to be revised for providing integrated and multi-dimensional views of the core business process. We suggest low-level use case diagrams and time, cost and quality dimensional <b>message</b> trace <b>diagrams</b> to provide a comprehensive modeling formalism of object-oriented business engineering. 1. Introduction The business environment of today is characterized by rapid flux [1]. Customers have become more sophisticated and demanding, competition has turned global and ferocious. This [...] ...|$|R
40|$|In m-healthcare service, {{accurate}} {{detection and}} notification of emergency situation {{are critical to}} chronic patients' life. Since they are usually performed by {{a limited number of}} medical staff, it is difficult to simultaneously support many patients in real-time. This article presents an architecture to support the emergency bio-data management for m-healthcare service using personalized emergency policy. The salient feature of the proposed architecture is that the decision on emergency is made using personalized emergency policy. Specifically, the structure of the detailed system components has also been designed. The emergency condition of the individual bio-data collected from wireless body area network is detected automatically using personalized emergency policy. The <b>message</b> flow <b>diagram</b> based on the personalized emergency policy is described. This enables quick emergency rescue service provided to the patient both accurately and immediately. The prototype of proposed system has been built to demonstrate the design concept...|$|R
40|$|The paper {{presents}} {{research related}} to the detailed design of interaction mechanisms among agents in an emotionally intelligent tutoring system, based {{on the set of}} agents for the modeling of learner’s emotions in intelligent tutoring systems developed at the Department of Systems Theory and Design of Riga Technical University in Latvia in 2008. Using sequence diagram defined in Agent Unified Modeling Language (AUML) methodology is shown design of interaction mechanisms among agents, considering learner’s facial features. The agent communication language FIPA ACL is used for <b>message</b> representation in <b>diagram...</b>|$|R
40|$|International audienceDespite {{the high}} level of automation, the {{practicability}} of formal veri cation through model-checking of large models is hindered by the combinatorial explosion problem. In this paper we apply a novel context-aware veri cation technique to the Landing Gear System (LGS). The idea is to express and verify requirements relative to certain environ- mental situations. The system environment is decomposed into several independent scenarios (contexts), which are successively composed with the system during reachability analysis. These contexts are speci ed us- ing a language called CDL (Context Description Language), based on activity and <b>message</b> sequence <b>diagrams.</b> The properties to be veri ed are speci ed with observer automata and attached to speci c regions in the context. This approach enables an automated context-guided de- composition of the veri cation into smaller problems, hence e ectively reducing the state-space explosion problem. In the case of the LGS this technique enabled the fully-automated decomposition of the veri cation into 885 smaller model-checking problems...|$|R
40|$|International audienceThis paper {{deals with}} the problem of the usage of formal techniques, based on model checking, where models are large and formal {{verification}} techniques face the combinatorial explosion issue. The goal of the approach is to express and verify requirements relative to certain context situations. The idea is to unroll the context into several scenarios and successively compose each scenario with the system and verify the resulting composition. We propose to specify {{the context in which the}} behavior occurs using a language called CDL (Context Description Language), based on activity and <b>message</b> sequence <b>diagrams.</b> The properties to be verified are specified with textual patterns and attached to specific regions in the context. The central idea is to automatically split each identified context into a set of smaller subcontexts and to compose them with the model to be validated. For that, we have implemented a recursive splitting algorithm in our toolset OBP (Observer-based Prover). This paper shows how this combinatorial explosion could be reduced by specifying the environment of the system to be validated...|$|R
40|$|The {{research}} {{reported in}} this article was {{funded in part by}} a grant from NASA. The views and conclusions contained herein {{are those of the authors}} and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the U. S. Government. The U. S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright annotations thereon. Formal verification of system-of-systems uses computer-based techniques to assure that the behavior of a subject system of systems complies with its formal correctness specifications. Such formal specifications are often created on the basis of natural-language (NL) requirement specifications. While NL documents such as marketing requirement documents and concept-ofoperation (CONOPS) documents contain NL requirements, they are almost never complete, i. e., they omit necessary NL requirements. To that end, UML analysis is an increasingly popular technique for requirement elicitation. This paper describes the process of identifying NL requirements of interest from UML analysis diagrams such as activity <b>diagrams)</b> and <b>Message</b> Sequence <b>Diagrams...</b>|$|R
40|$|Requirements Engineering (RE) {{investigates the}} impact of a future-oriented change vision, but the move towards this vision must {{consider}} a context heavily shaped by the past. As RE becomes a continuous process throughout the system lifecycle, it must achieve an effective combination of envisionment and traceability. In this paper, we describe a scenario-based solution to this problem which is based on an integration of five ingredients: (a) the persistent capture of context in the form of real world scenes captured in multimedia; (b) formal agent-oriented modelling with a semantics that allows distributed interactive animation; (c) <b>message</b> trace <b>diagrams</b> as a medium for exchanging animation test cases and traces; (d) a goal model to control and record the RE process; and (e) a process-integrated tool environment to ensure method-guidance and traceability with as little effort as possible. In addition to the basics of our approach, we also describe its prototypical implementation in the CREWS-EVE environment and demonstrate its usefulness with examples from a case study in the production industry. ...|$|R
40|$|RatSLAM is a {{navigation}} {{system based on}} the neural processes underlying navigation in the rodent brain, capable of operating with low resolution monocular image data. Seminal experiments using RatSLAM include mapping an entire suburb with a web camera and a long term robot delivery trial. This paper describes OpenRatSLAM, an open-source version of RatSLAM with bindings to the Robot Operating System framework to leverage advantages such as robot and sensor abstraction, networking, data playback, and visualization. OpenRatSLAM comprises connected ROS nodes to represent RatSLAM 2 ̆ 7 s pose cells, experience map, and local view cells, {{as well as a}} fourth node that provides visual odometry estimates. The nodes are described with reference to the RatSLAM model and salient details of the ROS implementation such as topics, <b>messages,</b> parameters, class <b>diagrams,</b> sequence diagrams, and parameter tuning strategies. The performance of the system is demonstrated on three publicly available open-source datasets...|$|R
40|$|Abstract. This work defines several control-flow {{coverage}} {{criteria for}} testing the interactions among {{a set of}} collaborating objects. The criteria are based on UML sequence diagrams that are reverse-engineered from the code under test. The sequences of <b>messages</b> in the <b>diagrams</b> are used to define the coverage goals for the family of criteria, {{in a manner that}} generalizes traditional testing techniques such as branch coverage and path coverage. We also describe a run-time analysis that gathers coverage measurements for each criterion. To compare the criteria, we propose an approach that estimates the testing effort required to satisfy each criterion, using analysis of the complexity of the underlying sequence diagrams. The criteria were investigated experimentally on a set of realistic Java components. The results of this study compare different approaches for testing of object interactions and provide insights for testers and for builders of test coverage tools. ...|$|R
40|$|DIAGEN [1] is a {{tool for}} {{generating}} diagram editors that respect the syntax of partic-ular diagram languages. Editors generated with DIAGEN work as follows: A drawing tool allows free-hand editing of diagrams, by arranging diagram primi-tives like boxes, circles, lines, text on a drawing pane. The set of available primitives depends on the particular diagram language. A scanner analyses the spatial relationships of diagram primitives, and reduces them to diagram symbols like states and transitions. Finally, a parser checks whether the diagram symbols are related according to the syntax of the diagram language, and produces a derivation structure. DIAGEN relies on hypergraphs and hypergraph transformation: diagrams are rep-resented as hypergraphs, the scanner is specified by hypergraph transformation rules, and the syntax of diagram languages is specified by hypergraph grammars. (See [5] for details.) Case studies with editors for control flow <b>diagrams,</b> Nassi-Shneiderman <b>diagrams,</b> <b>message</b> sequence charts, state charts, and UML class diagrams indicate that the syntax of practically every kind of diagram language—also for design language...|$|R
40|$|This report {{describes}} and illustrates several modelling techniques {{proposed by}} Communication Analysis; namely Communicative Event <b>Diagram,</b> <b>Message</b> Structures and Event Specification Templates. The Communicative Event Diagram {{is a business}} process modelling technique that adopts a communicational perspective by focusing on communicative interactions when describing the organizational work practice, {{instead of focusing on}} physical activities 1; at this abstraction level, we refer to business activities as communicative events. Message Structures is a technique based on structured text that allows specifying the messages associated to communicative events. Event Specification Templates are a means to organise the requirements concerning a communicative event. This report can be useful to analysts and business process modellers in general, since, according to our industrial experience, it is possible to apply many Communication Analysis concepts, guidelines and criteria to other business process modelling notations such as BPMN. Also, Message Structures can complement business process models created with other notations different than Communicative Event Diagram. Comment: 35 pages, 14 figures, 9 table...|$|R
40|$|With the {{standardization}} of CDMA 2000 - 1 x, EVDO, and its subsequent release/revisions (0, A, B, and C) each telecom vendor continues {{to develop their}} equipment as well as network management software for supporting EVDO services and defines EVDO performance parameters separately. This leads to sort of redundancy and perplexity in multivendor network environments in which network optimization engineer {{has to deal with}} all these performance parameters to optimize the system performance. There is need tounify these different EVDO performance parameters defined by different vendors to overcome this redundancy and confusion. To complete this objective we first has identified different EVDO key performance indicators defined by different vendors through their software i. e. element management systems (EMS). After identification of these KPIs we then take one most important KPI i. e., the Session Setup Success Rate (SSSR) and analyses its constituent counters and find out differences through dailystatistic reports, standard definitions formula and <b>message</b> flow <b>diagrams</b> defined by each vendor. Thenwe proposed a new KPI, HSN Ratio (Harmonic mean of session setup success and session negotiation success Ratios) to get a complete picture of end-to-end session setup success rate. Finally we have collected 15 days hourly statistic report of SSSR and session negotiation success rate defined by eachvendor through their EMS’s and applied minimum mean square error method to unify the proposed HSN ratio. As a result of this process we have figure out differences between multivendor KPIs and minimizes these differences to unify them. Similarly this whole process could be repeated to unify other EVDO KPIs...|$|R
40|$|Abstract: This paper {{proposes to}} use UML class {{diagrams}} and UML behavior diagrams like collabora-tion <b>diagrams,</b> activity <b>diagrams,</b> <b>message</b> sequence charts, and state-charts {{as a visual}} programming language. We describe a code generator that generates a (Java) implementation of an application from its UML specification. Thereby, we define a formal semantics for these UML diagrams and we define how different (kinds of) diagrams are combined to a complete executable specification. Generally, generating code from UML behavior diagrams is not well understood. Frequently, the semantics of a UML behavior diagram depends on the topic and the aspect that is modeled and on the designer that created it. In addition, UML behavior diagrams usually model only example scenarios and do not describe all possible cases and possible exceptions. We overcome these problems by restricting the UML notation to {{a subset of the}} language that has a pre-cise semantics. In addition, we define which kind of diagram should be used for which purpose and how the different kinds of diagrams are integrated to a consistent overall view. ...|$|R
40|$|Abstract. Scenario based {{requirements}} specifications are {{the industry}} norm for defining communication protocols. Basic scenarios captured as UML sequence <b>diagrams,</b> <b>Message</b> Sequence Charts (MSCs) or Live Sequence Charts (LSC) have partial order semantics that characterize system traces by restricting the possible order of events within those traces. The semantic partial {{order of the}} scenario specification is called the causal ordering. Semantic inconsistencies often occur in partial order scenarios between the specified causal ordering and the order that events can occur in practice. Such inconsistencies are known as race conditions. The paper proves {{that there is a}} unique race free partial order that is a minimal weakening of the causal ordering. In other words, there is a canonical generalization of the requirements that corrects all race conditions. Hence any race free generalization of the original scenario is in fact a generalization of the canonical scenario. The paper also proves the dual result, there is a unique race free partial order that is a minimal strengthening of the causal order. I. e. there is a canonical refinement of the requirements that corrects all race conditions. ...|$|R
40|$|This paper {{presents}} {{a novel approach}} to generate test cases by integrating UML design diagrams. To achieve this we consider using two behavior dependent UML diagrams like activity and sequence diagrams where sequence diagram is used to visualize the sequence of calls in a system to perform a specific functionality {{of the system and}} activity diagram describes the flow control from one activity to another without any <b>messages.</b> Both the <b>diagrams</b> represent the dynamic behavior of the system. Our approach consists of two phases. In the first phase the activity and sequence diagrams are converted to activity diagram graph and sequence diagram graph respectively. The second phase integrates both the graphs to generate an activity-sequence graph. Breadth first search (BFS) is applied on the activitysequence graph to generate all possible paths and test cases are generated. The generated test cases are suitable for system testing which can be used by developers and testers without writing test cases while developing code. The proposed approach uses high level technique like UML diagrams by which complex software can be represented with clarity and efficient manner which improves the efficiency, accuracy, validity, quality, and maximizes the level of automation in software industry...|$|R
40|$|Test suites are {{designed}} to validate the operation of a system against requirements. One important aspect of a test suite design {{is to ensure that}} system operation logic is tested completely. A test suite should drive a system through all abstract states to exercise all possible cases of its operation. This is a difficult task. Code coverage tools support test suite designers by providing the information about which parts of source code are covered during system execution. Unfortunately, code coverage tools produce only source code coverage information. For a test engineer it is often hard to understand what the noncovered parts of the source code do and how they relate to requirements. We propose a generic approach that provides design coverage of the executed software simplifying the development of new test suites. We demonstrate our approach on common design abstractions such as statecharts, activity <b>diagrams,</b> <b>message</b> sequence charts and structure diagrams. We implement the design coverage using Third Eye tracing and trace analysis framework. Using design coverage, test suites could be created faster by focussing on untested design elements. Comment: Short version of this paper to be published in Proceedings of 16 th IEEE International Conference on Automated Software Engineering (ASE 2001). 13 pages, 9 figure...|$|R
40|$|Abstract: Development-engineers use {{in their}} work {{languages}} intended for software or hardware systems design, and test engineers utilize languages effective in verification, analysis of the systems properties and testing. Automatic interfaces between languages of these kinds are {{necessary in order to}} avoid ambiguous understanding of specification of models of the systems and inconsistencies in the initial requirements for the systems development. Algorithm of automatic translation of MSC (<b>Message</b> Sequence Chart) <b>diagrams</b> compliant with MSC’ 2000 standard into Petri Nets is suggested in this paper. Each input MSC diagram is translated into Petri Net (PN), obtained PNs are sequentially composed in order to synthesize a whole system in one final combined PN. The principle of such composition is defined through the basic element of MSC language — conditions. While translating reference table is developed for maintenance of consistent coordination between the input system’s descriptions in MSC language and in PN format. This table is necessary to present the results of analysis and verification on PN in suitable for the development-engineer format of MSC diagrams. The proof of algorithm correctness is based on the use of process algebra ACP. The most significant feature of the given algorithm is the way of handling of conditions. The direction for future work is the development of integral, partially or completely automated technological process, which will allow designing system, testing and verifying its various properties in the one frame. Keywords: MSC diagram, MSC language, condition, automatic translation, Petri Net...|$|R
40|$|After {{investigating}} the typical hardware {{structure of a}} safety critical embedded system, we classify the various heterogeneous components with respect to certain criterias (e. g. manufacturing technology like microelectronics, micromechanics, microoptics; material, energy or information flow; discrete or contineous). Depending on classification, different modelling techniques must be used on different levels of abstraction (system level, subsystem level, device level, process level) and in different stages of the product design cycle (executable specifications, architectural design, performance simulation, timing simulation, synthesis and code generation, failure analysis, cross sensitivity analysis, design for testabilitiy etc.). Accordingly, modelling of components of heterogeneous systems use various mathematical descriptions (partial differential equations and ordinary differential equations for continuous or analog systems, boolean equations, finite state machines or petri nets for discrete event systems or digital systems), but also graphical modelling techniques are used like hierarchical black box <b>diagrams,</b> <b>message</b> sequence charts or data flow diagrams as well as various description languages. Simulating such a heterogeneous system very often needs the coupling of different specialized simulators creating additional problems for the already complex design, verification and optimization tasks. 8 Hybrid System Modeling and Simulation Ramine Nikoukhah INRIA, Domaine de Voluceau, 78153 Le Chesnay [...] France Ramine. Nikoukhah@inria. fr Abstract A formalism for hybrid system simulation is presented. This formalism, which is motivated {{in part by the}} Signal language and in particular its extension to continuous time systems, is the basis for the hybrid system [...] ...|$|R
40|$|Development-engineers use {{in their}} work {{languages}} intended for software or hardware systems design, and test engineers utilize languages effective in verification, analysis of the systems properties and testing. Automatic interfaces between languages of these kinds are {{necessary in order to}} avoid ambiguous understanding of specification of models of the systems and inconsistencies in the initial requirements for the systems development. Algorithm of automatic translation of MSC (<b>Message</b> Sequence Chart) <b>diagrams</b> compliant with MSC’ 2000 standard into Petri Nets is suggested in this paper. Each input MSC diagram is translated into Petri Net (PN), obtained PNs are sequentially composed in order to synthesize a whole system in one final combined PN. The principle of such composition is defined through the basic element of MSC language — conditions. While translating reference table is developed for maintenance of consistent coordination between the input system’s descriptions in MSC language and in PN format. This table is necessary to present the results of analysis and verification on PN in suitable for the development-engineer format of MSC diagrams. The proof of algorithm correctness is based on the use of process algebra ACP. The most significant feature of the given algorithm is the way of handling of conditions. The direction for future work is the development of integral, partially or completely automated technological process, which will allow designing system, testing and verifying its various properties in the one frame...|$|R
30|$|A lot of {{developments}} are conducted by groups or organizations. It {{is impossible for}} each member to understand all of the software specification in such group work. Therefore, the various consensus-building processes such as assessment, review and testing is conducted constantly between users and developers or between analysts and designers, etc. The user interface prototyping is an effective method for users to validate the requirements specification about users’ operation efficiently and intuitively, but the users can not confirm {{the validity of the}} internal aspects mostly. Therefore, the users often agree the requirements specification through user interface prototype system even if the system can not be actualized based on the specification. On the other hand, the more a development becomes large-scale, the more analysts are needed. In a large-scale development, the misunderstandings among analysts to the specification will cause serious reworking because invalid product is created based on the inconsistent specification {{as the result of the}} misunderstandings. Therefore, it is important for each analyst to have common understanding of the specification among all of the analysts sufficiently so as to prevent defining inconsistent specifications. Support of the verification of the specification without detailing is also necessary for analysts so that the analysts can clear the misunderstanding to the specification constantly before causing the serious reworking. The methods for generating a user interface prototype system from a requirements specification (Diaz et al. 1996; Elkoutbi et al. 2006) are useful for analysts to make users validate the external aspects of the system. (Elkoutbi et al. 2006) proposed how to write use cases by using UML collaboration diagrams, a UML class diagram and UML state machine diagrams. (Diaz et al. 1996) also proposed how to write use cases by using a UML use case <b>diagram,</b> <b>message</b> sequence charts and state transition diagrams. However, the support of these methods for verifying the internal aspects is weak because the generated prototype system visualizes external aspects only and does not have functions to achieve business logic. Therefore, the misunderstandings among the analysts for the internal aspects are hard to be cleared by each of the analysts. We try to improve this problem by visualizing the definition of the requirements specification about the internal aspects. Model checking techniques are useful for developers to validate a model based on specifications which are expressed as temporal logic efficiently and exhaustively. Such techniques are a promised approach to discover defects of the model early and sufficiently. Some researches try to detect defects of specifications or source codes (Aoki and Matsuura 2011; Choi and Watanabe 2005) by using model checking tools such as UPPAAL (UPPAAL 2010). (Choi et al. 2005) propose how to use the model checking technique for checking the consistency of a class specification and a page flow diagram, and for checking the consistency of the class specification and activity diagrams. The activity diagrams are a use-case-based behavioral model, so the activity diagrams contain brief definition for the internal aspects. However, this method can not verify the internal aspects because this method focuses on the checking for the external aspects. One of the essential difficulties for the model checking techniques is how the analysts define adequate temporal logic formulas. The consistency of the formulas is difficult to be kept by the analysts if the analysts define the formulas by distributed work with the misunderstanding of the way of design. To improve this problem, support of enhancing common understanding among the analysts is inevitable in order to share the understanding to the requirements specification precisely even if useful model checking techniques are used. Our approach aims for enhancing common understanding of the requirements specification for the analysts, and focuses on the internal aspects.|$|R

