0|523|Public
40|$|Abstract. The syntax of {{modeling}} languages is usually defined in two steps. The abstract syntax identifies modeling concepts whereas the <b>concrete</b> <b>syntax</b> clarifies how these modeling concepts are rendered by visual and/or textual elements. While the abstract syntax is often defined {{in form of}} a metamodel {{there is no such}} standard format yet for <b>concrete</b> <b>syntax</b> definitions; at least as long as the <b>concrete</b> <b>syntax</b> is not purely text-based and classical grammar-based approaches are not applicable. In a previous paper, we proposed to extend the metamodeling approach also to <b>concrete</b> <b>syntax</b> definitions. In this paper, we present an analysis technique for our <b>concrete</b> <b>syntax</b> definitions that detects inconsistencies between the abstract and the <b>concrete</b> <b>syntax</b> of a modeling language. We have implemented our approach on top of the automatic decision procedure Simplify. ...|$|R
40|$|International audienceMetamodeling {{is raising}} {{more and more}} {{interest}} {{in the field of}} language engineering. While this approach is now well understood for defining abstract <b>syntaxes,</b> formally defining <b>concrete</b> <b>syntaxes</b> with metamodels is still a challenge. <b>Concrete</b> <b>syntaxes</b> are traditionally expressed with rules, conforming to EBNF-like grammars, which can be processed by compiler compilers to generate parsers. Unfortunately, these generated parsers produce <b>concrete</b> <b>syntax</b> trees, leaving a gap with the abstract syntax defined by metamodels, and further ad-hoc hand-coding is required. In this paper we propose a new kind of specification for <b>concrete</b> <b>syntaxes,</b> which takes advantage of metamodels to generate fully operational tools (such as parsers or text generators). The principle is to map abstract <b>syntaxes</b> to <b>concrete</b> <b>syntaxes</b> via bidirectional mapping-models with support for both model-to-text, and text-to-model transformations...|$|R
40|$|Metamodeling {{is raising}} {{more and more}} {{interest}} {{in the field of}} language engineering. While this approach is now well understood for the definition of abstract syntaxes, the formal definition of <b>concrete</b> <b>syntaxes</b> is still a challenge. <b>Concrete</b> <b>syntaxes</b> are traditionally expressed with rules, conforming to EBNF-like grammars, which can be processed by compiler compilers to generate parsers. Unfortunately, these syntax defined by metamodels. This gap is usually filled by time consuming ad-hoc hand-coding. In this paper we propose a new kind of specification for <b>concrete</b> <b>syntaxes</b> that takes advantage of metamodels to generate tools (such as parsers or text generators) which directly manipulate abstract syntax trees. The principle is to map abstract <b>syntaxes</b> to <b>concrete</b> <b>syntaxes</b> via EBNF-like rules that explain how to render an abstract concept into a given <b>concrete</b> <b>syntax,</b> and how to trigger other rules to handle the properties of the concepts. The major difference with EBNF is that rules may have sub-rules, which can be automatically triggered based on the inheritance hierarchy of the abstract syntax concepts. Key words: abstract <b>concrete</b> <b>syntax</b> mapping, metamodeling...|$|R
50|$|SGML has an {{abstract}} syntax implemented by many possible <b>concrete</b> <b>syntaxes,</b> however, {{this is not}} the same usage as in {{an abstract}} syntax tree and as in a <b>concrete</b> <b>syntax</b> tree. In the SGML usage, a <b>concrete</b> <b>syntax</b> is a set of specific delimiters, while the abstract syntax is the set of names for the delimiters. The XML Infoset corresponds more to the programming language notion of abstract syntax introduced by John McCarthy.|$|R
40|$|Meta-modeling {{is raising}} {{more and more}} {{interest}} {{in the field of}} language engineering. While this approach is now well understood for defining abstract syntaxes, formally defining textual <b>concrete</b> <b>syntaxes</b> with meta-models is still a challenge. Textual <b>concrete</b> <b>syntaxes</b> are traditionally expressed with rules, conforming to EBNF-like grammars, which can be processed by compiler compilers to generate parsers. Unfortunately, these generated parsers produce <b>concrete</b> <b>syntax</b> trees, leaving a gap with the abstract syntax defined by meta-models, and further ad hoc hand-coding is required. In this paper we propose a new kind of specification for <b>concrete</b> <b>syntaxes,</b> which takes advantage of meta-models to generate fully operational tools (such as parsers or text generators). The principle is to map abstract syntaxes t...|$|R
40|$|A {{successful}} {{technique in}} modern Software Engineering practice {{is to develop}} domain-specific specification languages to characterize syntax to characterize the domain concepts and abstractions before developing a <b>concrete</b> <b>syntax.</b> Often, however, a good <b>concrete</b> <b>syntax</b> exists a priori: sometimes in sophisticated formal languages characterizing (often mathematical) domains but more often in miniature, legacycode languages, sorely in need of reverse engineering. In such cases, {{it is necessary to}} derive an appropriate abstract syntax – or its first cousin, an object-oriented model – from the <b>concrete</b> <b>syntax.</b> The relationships between <b>concrete</b> <b>syntax</b> and abstract syntax are quite regular; {{this is not to say}} that they are trivial. Herein, those relationships are explored and a transformation process is described that software engineers can use to produce a good abstract syntax specification (e. g. in C++) from a low-level <b>concrete</b> <b>syntax</b> specification (e. g. in YACC). Some details of how the heuristic process has been automated in the author's language processing system, Popart, are presented to introduce software engineers to the practical usage of automatic program generation concepts. Examples from the <b>concrete</b> <b>syntax</b> for CORBA’s IDL are used to illustrate the process...|$|R
40|$|National audienceGraphical Domain Specific Modeling Languages (DSML) are {{alternatives}} to general purpose modeling languages e. g. UML or SysML. They describe models with concepts and relations specific to a domain. Defining such languages consists of defining an abstract syntax and a graphical <b>concrete</b> <b>syntax</b> {{accompanied by a}} correspondence mapping between the elements of each one. Such process is composed of two phases: the abstract syntax definition and the <b>concrete</b> <b>syntax</b> definition. This paper describes concepts and mechanisms allowing to guide and to assist an expert from any engineering domain to define and formalize the <b>concrete</b> <b>syntax</b> of a graphical DSML considered as relevant in this domain. We define multiple classifications of the abstract syntax elements based both on the abstract syntax and on the <b>concrete</b> <b>syntax.</b> Grounded on those classifications, we present how {{a part of the}} <b>concrete</b> <b>syntax</b> can be generated automatically from an abstract syntax by a graphical role election...|$|R
40|$|ModelCC is a model-based parser {{generator}} that decouples language design from language processing. ModelCC provides two different mechanisms {{to specify the}} mapping from an abstract syntax model to a <b>concrete</b> <b>syntax</b> model: metadata annotations defined {{on top of the}} abstract syntax model specification and a domain-specific language for defining ASM-CSM mappings. Using a domain-specific language to specify the mapping from abstract to <b>concrete</b> <b>syntax</b> models allows the definition of multiple <b>concrete</b> <b>syntax</b> models for the same abstract syntax model. In this paper, we describe the ModelCC domain-specific language for abstract <b>syntax</b> model to <b>concrete</b> <b>syntax</b> model mappings and we showcase its capabilities by providing a meta-definition of that domain-specific language. Comment: arXiv admin note: substantial text overlap with arXiv: 1202. 659...|$|R
40|$|Modern Software Engineering {{practice}} advocates {{the development}} of domain-specific specification languages to characterize formally the idioms of discourse and jargon of specific problem domains. With poorly-understood domains {{it is best to}} construct an abstract syntax to characterize the domain concepts and abstractions before developing a <b>concrete</b> <b>syntax.</b> Often, however, a good <b>concrete</b> <b>syntax</b> exists a priori: sometimes in sophisticated formal languages characterizing (often mathematical) domains but more often in miniature, legacy-code languages, sorely in need of reverse engineering. In such cases, it is necessary to derive an appropriate abstract syntax – or its first cousin, an object-oriented model – from the <b>concrete</b> <b>syntax.</b> This report describes a transformation process that produces a good abstract representation from a low-level <b>concrete</b> <b>syntax</b> specification...|$|R
40|$|Abstract. Program {{generation}} and transformation systems manipulate large, parameterized object language fragments. Support for user-definable <b>concrete</b> <b>syntax</b> makes this easier but is typically restricted to certain object and meta languages. We show how Prolog can be retrofitted with <b>concrete</b> <b>syntax</b> and describe how a seamless interaction of <b>concrete</b> <b>syntax</b> fragments with an existing “legacy” meta-programming {{system based on}} abstract syntax is achieved. We apply the approach to gradually migrate the schemas of the AUTOBAYES program synthesis system to <b>concrete</b> <b>syntax.</b> First experiences show that this {{can result in a}} considerable reduction of the code size and an improved readability of the code. In particular, abstracting out fresh-variable {{generation and}} second-order term construction allows the formulation of larger continuous fragments and improves the “locality ” in the schemas. ...|$|R
40|$|Abstract. Metamodeling {{techniques}} are popular {{in describing the}} rules of special domains, namely, the abstract syntax, but these techniques do not support defining the <b>concrete</b> <b>syntax</b> (the presentation). The aim of our research {{is to provide a}} method to create the <b>concrete</b> <b>syntax</b> for metamodeling systems in a flexible, efficient way. To define the <b>concrete</b> <b>syntax,</b> several domainspecific languages have been created that support defining the visualization. The main concern {{of this paper is to}} present a model transformation method that processes our presentation definitions and transforms them automatically into source code. The source code implements a plug-in capable of editing the models. A termination analysis for the presented method is also provided. Keywords: Model Transformation, <b>Concrete</b> <b>Syntax,</b> Domain-Specific Modeling...|$|R
40|$|The paper {{presents}} innovative parser construction {{method and}} parser generator prototype which generates a computer language parser {{directly from a}} set of annotated classes in contrast to standard parser generators which specify <b>concrete</b> <b>syntax</b> of a computer language using BNF notation. A language with textual <b>concrete</b> <b>syntax</b> is defined upon the abstract syntax definition extended with annotations in the presented approach. Annotations define instances of <b>concrete</b> <b>syntax</b> patterns in a language. Abstract syntax of a language is inevitable input of the parser generator as well as language's <b>concrete</b> <b>syntax</b> pattern definitions. The process of parser implementation is presented on the concrete computer language - the Simple Arithmetic Language. The paper summarizes results of the studies of implemented parser generator and describes {{its role in the}} university courses...|$|R
40|$|Program {{generation}} and transformation systems manipulate large, pa- rameterized object language fragments. Support for user-definable <b>concrete</b> <b>syntax</b> makes this easier but is typically restricted to certain object and meta languages. We show how Prolog can be retrofitted with <b>concrete</b> <b>syntax</b> and describe how a seamless interaction of <b>concrete</b> <b>syntax</b> fragments with an existing legacy meta-programming {{system based on}} abstract syntax is achieved. We apply the approach to gradually migrate the schemas of the AUTOBAYES program synthesis system to <b>concrete</b> <b>syntax.</b> Fit experiences show that this {{can result in a}} considerable reduction of the code size and an improved readability of the code. In particular, abstracting out fresh-variable {{generation and}} second-order term construction allows the formulation of larger continuous fragments and improves the locality in the schemas...|$|R
50|$|It is {{straightforward}} {{to provide such}} an RDF <b>concrete</b> <b>syntax</b> for rules, but the presence of variables in rules goes beyond the RDF Semantics. Translation from the XML <b>Concrete</b> <b>Syntax</b> to RDF/XML could be easily accomplished by extending the XSLT transformation for the OWL XML Presentation syntax.|$|R
40|$|Abstract. The paper {{presents}} innovative parser construction {{method and}} parser generator prototype which generates a computer language parser {{directly from a}} set of annotated classes in contrast to standard parser generators which specify <b>concrete</b> <b>syntax</b> of a computer language using BNF notation. A language with textual <b>concrete</b> <b>syntax</b> is defined upon the abstract syntax definition extended with annotations in the presented approach. Annotations define instances of <b>concrete</b> <b>syntax</b> patterns in a language. Abstract syntax of a language is inevitable input of the parser generator as well as language’s <b>concrete</b> <b>syntax</b> pattern definitions. The process of parser implementation is presented on the concrete computer language – the Simple Arithmetic Language. The paper summarizes results of the studies of implemented parser generator and describes {{its role in the}} university courses...|$|R
5000|$|... a <b>concrete</b> <b>syntax</b> {{that fits}} well to model and {{metamodel}} writing.|$|R
5000|$|<b>Concrete</b> <b>syntax</b> is {{identified}} with phonology, broadly construed to include word order.|$|R
5000|$|... (and [...] "&#RE;&#RS;" [...] is a short-reference {{delimiter}} in the <b>concrete</b> <b>syntax),</b> then: ...|$|R
40|$|Within {{the context}} of (software) {{language}} engineering, language descriptions are considered first class citizens. One {{of the ways to}} describe languages is by means of a metamodel, which represents the abstract syntax of the language. Unfortunately, in this process many language engineers forget the fact that a language also needs a <b>concrete</b> <b>syntax</b> and a semantics. In this paper I argue that neither of these can be discarded from a language description. In a good language description the abstract syntax is the central element, which functions as pivot between <b>concrete</b> <b>syntax</b> and semantics. Furthermore, both <b>concrete</b> <b>syntax</b> and semantics should be described in a well-defined formalism...|$|R
40|$|In this paper, {{we apply}} the {{annotation}} scheme design methodology defined in (Bunt, 2010) and demonstrate its use for generating a mapping from an existing annotation scheme to a representation in GrAF format. The most important {{features of this}} methodology are (1) the distinction of the abstract and <b>concrete</b> <b>syntax</b> of an annotation language; (2) the specification of a formal semantics for the abstract syntax; and (3) the and <b>concrete</b> <b>syntax,</b> which guarantees that any <b>concrete</b> <b>syntax</b> inherits the semantics of the abstract syntax, and thus guarantees meaning-preserving mappings between representation formats. By way of illustration, we apply this mapping strategy to annotations from ISO-TimeML, PropBank, and FrameNet...|$|R
40|$|In {{building}} textual translators, implementors often {{distinguish between}} a <b>concrete</b> <b>syntax</b> and an abstract <b>syntax.</b> The <b>concrete</b> <b>syntax</b> describes the phrase {{structure of the}} input language and the abstract syntax describes a tree structure {{that can be used}} as the basis for performing semantic computations. Having two grammars imposes the requirement that there exist a mapping from the <b>concrete</b> <b>syntax</b> to the abstract syntax. The research presented in this paper led to a tool, called Maptool, that is designed to simplify the development of the two grammars. Maptool supports a modular approach to syntax development that mirrors the modularity found in semantic computations. This is done by allowing users to specify each of the syntaxes only partially as long as the sum of the fragments allows deduction of the complete syntaxes. Keywords: Abstract <b>syntax,</b> <b>concrete</b> <b>syntax,</b> modularity, parsing grammar, syntax development, syntax mapping, tree construction 1 Introduction The meaning of a co [...] ...|$|R
40|$|Abstract. This paper {{presents}} {{a solution to}} bridging the abstract and <b>concrete</b> <b>syntax</b> of a Web rule languages by using model transformations. Current specifications of Web rule languages such as Semantic Web Rule Language (SWRL) or RuleML define their abstract syntax (e. g., metamodel) and <b>concrete</b> <b>syntax</b> (e. g., XML schema) separately. Although the recent {{research in the area}} of Model-Driven Engineering (MDE) demonstrates that such a separation of two types of syntax is a good practice (due to the complexity of languages), one should also have tools that check validity of rules written in a <b>concrete</b> <b>syntax</b> with respect to the abstract syntax of the rule language. In this study, we use the REWERSE I 1 Rule Markup Language (R 2 ML), SWRL, and Object Constraint Language (OCL), whose abstract syntax is defined by using metamodeling, while their textual <b>concrete</b> <b>syntax</b> is defined by using either XML/RDF schema or Extended Backus-Naur Form (EBNF) syntax. We bridge this gap by a bi-directional transformation defined in a model transformation language (ATLAS Transformation Language, ATL). This transformation allowed us to discover a number of issues in both web rule language metamodels and their corresponding <b>concrete</b> <b>syntax,</b> and thus make them fully compatible. This solution also enables for sharing web rules between different web rule languages...|$|R
50|$|SPARQL Syntax Expressions (alternatively, SPARQL S-Expressions) is a <b>concrete</b> <b>syntax</b> for {{representing}} SPARQL Algebra expressions.|$|R
5000|$|HOG {{maintains}} Haskell Curry's {{distinction between}} tectogrammatical structure (abstract syntax) and phenogrammatical structure (<b>concrete</b> <b>syntax).</b>|$|R
5000|$|The usual (default) SGML <b>{{concrete}}</b> <b>syntax</b> resembles this example, {{which is}} the default HTML concrete syntax: ...|$|R
40|$|Thesis (M. S.) [...] Wichita State University, College of Liberal Arts and Sciences, Dept. of Computer ScienceSchütz is a programmer's editor {{designed}} by Dr. Rodney Bates. Through its language definition language, users may adapt Schütz to any programming language. Describing {{a programming language}} in the language definition language involves writing largely parallel rule sets in three different syntaxes—the <b>concrete</b> <b>syntax,</b> the abstract syntax, and the format syntax. In this thesis, we present a method for mechanically generating the <b>concrete</b> <b>syntax</b> rule set, given the rule sets {{of the other two}} syntaxes; we also prove that the <b>concrete</b> <b>syntax</b> rule sets thus generated are correct and unambiguous, given the same traits in the rule sets of the other two syntaxes...|$|R
30|$|Extraction In this step, the {{constituent}} {{parts of the}} job title are extracted from the <b>concrete</b> <b>syntax</b> tree.|$|R
50|$|Tefkat has an SQL-like <b>concrete</b> <b>syntax</b> {{designed}} to concisely convey {{the intent of}} each rule, pattern or template.|$|R
40|$|Abstract. Language-centric methodologies, {{triggered}} {{by the success of}} Domain Specific Languages, rely on precise specifications of modeling languages. While the definition of the abstract syntax is standardized by the 4 -layer metamodel architecture of the OMG, most language specifications are held informally for the description of the semantics and the (graphical) <b>concrete</b> <b>syntax.</b> This paper is tackling the problem of specifying the <b>concrete</b> <b>syntax</b> of a language in a formal and non-ambiguous way. We propose to define the <b>concrete</b> <b>syntax</b> by an extension of the already existing metamodel of the abstract syntax, which describes the concepts of the language, with a second layer describing the graphical representation of concepts by visual elements. In addition, an intermediate layer defines how elements of both layers are related to each other. Unlike similar approaches that became the basis of some CASE tools, the intermediate layer is not a pure mapping from abstract to <b>concrete</b> <b>syntax</b> but connects both layers in a flexible, declarative way. We illustrate our approach with a simplified form of statecharts...|$|R
40|$|In meta-programming with <b>concrete</b> object <b>syntax,</b> meta {{programs}} can be written using the <b>concrete</b> <b>syntax</b> of manipulated programs. Quotations of <b>concrete</b> <b>syntax</b> fragments and anti-quotations for meta-level expressions and variables are used to manipulate the abstract representation of programs. These small, isolated fragments are often ambiguous and must be explicitly disambiguated with quotation tags or types, using names from the non-terminals of the object language syntax. Discoverability of these names has been an open issue, as they depend on the (grammar) implementation and {{are not part of}} the <b>concrete</b> <b>syntax</b> of a language. Based on advances in interactive development environments, we introduce interactive disambiguation to address this issue, providing real-time feedback and proposing quick fixes in case of ambiguities This paper is a pre-print of: Proceedings of the 3 rd International Conference of Software Language Engineering (SLE 2010), Eindhoven (The Netherlands) 12 - 13 Oct. 2010, Lecture Notes in Computer Science, Springer, 201...|$|R
40|$|Model Driven Engineering (MDE) {{promotes}} {{the use of}} models as primary artefacts of a software development process, {{as an attempt to}} handle complexity through abstraction, e. g. to cope with the evolution of execution platforms. MDE follows a stepwise approach, by prescribing to develop abstract models further improved to integrate little by little details relative to the final deployment platforms. Thus, the application of an MDE process results in various models residing at various levels of abstraction. Each one of these models is expressed in a modeling language, in which one may find appropriate concepts for the abstraction level considered. Many advocate to use the right (modeling) language for the right purpose. This means that it is sometimes better approach to use small languages specific to the considered domain and abstraction level, than to use general purpose languages (e. g. UML) when they do not perfectly fit the (modeling) needs. As a matter of fact, an MDE development process, which involves many different domains and abstraction levels, should also involve a large variety of modeling languages. Project managers who want to apply an MDE process need to deal with this language proliferation to such an extent that, in the long run, one may infer that language engineers can become major actors of software development teams. We believe that comprehensive modeling language management facilities may considerably alleviate that MDE drawback. Such facilities may include modeling language definition, extension, adaptation, or composition. To define a (modeling) language, one needs to define its abstract syntax, its semantics, and one or more <b>concrete</b> <b>syntaxes.</b> This thesis focuses on <b>concrete</b> <b>syntax</b> definition for modeling languages, when the abstract syntax is given {{in the form of a}} metamodel. We will provide solutions both for textual and graphical <b>concrete</b> <b>syntaxes.</b> Some of our experiences in building textual languages (as MTL, a model transformation language), and graphical languages (as Netsilon, a web-application modeler) has shown that a lot of work was spent in implementing interface using traditional techniques, be it a text processor generated from a compiler compiler specification, or a modeler making use of modern 2 D graphical libraries. Indeed, abstract and <b>concrete</b> <b>syntax</b> were implemented in a disconnected way, and it was then necessary to assemble them, which became rapidly clumsy while abstract syntax evolved. We built our solution to <b>concrete</b> <b>syntax</b> definition as companions of the abstract syntax. The definition of <b>concrete</b> <b>syntax</b> we propose here made it possible to build automatic tools able to analyze or synthesize models from/to text, and to create graphical modelers. We will present a metamodel for textual <b>concrete</b> <b>syntax</b> definition to construct constructive reversible grammars. We will also propose a technique for graphical <b>concrete</b> <b>syntax</b> definition following a two-step process: specification and realization. Specification is a restrictive approach in which a metamodel defines a graphical <b>concrete</b> <b>syntax.</b> Both relations with abstract syntax and spatial relationships are expressed by means of constraints. The realization step proposes a way to provide the <b>concrete</b> <b>syntax</b> tree a meaning, by attributing it a graphical appearance, and by expressing possible user interactions. The structure of the document is the following. After introducing in deeper details the problem and the general structure of the solution we propose, we will take a tour of MDE, text and graph grammars. Then, we will present Netsilon as an example of an MDE tool to MDE development, which required both the definition of a graphical and a textual modeling language. The two following sections will present the solutions we propose for textual and graphical <b>concrete</b> <b>syntax</b> definition, respectively. Final remarks and possible improvements, especially regarding reusability in general of MDE meta-artifacts (like metamodels or model transformations), and of <b>concrete</b> <b>syntax</b> in particular, will conclude the document...|$|R
50|$|In the <b>concrete</b> <b>syntax</b> below, the prefixes bind {{more tightly}} than the {{parallel}} composition (|), and parentheses {{are used to}} disambiguate.|$|R
40|$|Tool {{support for}} {{language}} engineering has typically prioritises <b>concrete</b> <b>syntax</b> over abstract syntax by providing meta-languages for expressing <b>concrete</b> <b>syntax</b> and then mapping concrete to abstract structures. Text-based languages are usually specified using a BNF-like language {{used to generate}} a syntax-aware editor that includes features such as keyword completion. Similarly, graphical languages are defined using a declarative graphical syntax language, producing an editor that supports features such as shapes, graphs and edges. Projectional editors invert traditional approaches by prioritising abstract over <b>concrete</b> <b>syntax.</b> This paper describes a projectional meta-tool architecture, including general purpose abstract and concrete meta-languages, that uses declarative rules to integrate the syntax and tool support {{for a range of}} heterogeneous languages. The architecture has been implemented in Racket and the paper illustrates the architecture with concrete examples...|$|R
50|$|The <b>Concrete</b> <b>Syntax</b> Development project {{contains}} the Graphical Modeling Framework, an Eclipse-based framework {{dedicated to the}} graphical representation of EMF based models.|$|R
50|$|For instance, the OCaml {{expression}} (1 + 2) {{can also}} be written ((+) 1 2) or (((+) 1) 2). The difference is only {{at the level of}} the <b>concrete</b> <b>syntax,</b> since these three versions are equivalent representations of the same abstract syntax tree. As demonstrated by the definition of a revised syntax for OCaml, the same programming language can use different <b>concrete</b> <b>syntaxes.</b> They would all converge to an abstract syntax tree in a unique format that a compiler can handle.|$|R
40|$|International audienceDSML (Domain Specific Modeling Languages) are an {{alternative}} to general purpose modeling languages (e. g. UML or SysML) for describing models with concepts and relations specific to a domain. DSML design is often based on Ecore meta-models, which follow the class-relation paradigm and also require defining a <b>concrete</b> <b>syntax</b> which can be either graphical or textual. In this demo, we focus on graphical <b>concrete</b> <b>syntax,</b> and we introduce an approach and a tool (Diagraph) to assist {{the design of a}} graphical DSML. The main points are: non-intrusive annotations of the meta-model to identify nodes, edges, nesting structures and other graphical information; immediate validation of meta-models by immediate generation of an EMF-GMF instance editor supporting multi-diagramming. Diagraph plays the role of an extension to Ecore, and is based on a pattern recognition principle in order to infer most of the <b>concrete</b> <b>syntax...</b>|$|R
