39|15|Public
5000|$|Many Forth advocates {{call the}} process of {{creating}} a new implementation of Forth a meta-compilation and that it constitutes a <b>metacompiler.</b> The FORTH definition of <b>metacompiler</b> is: ...|$|E
50|$|Just replace X {{with any}} common language, C, C++ ,PASCAL, COBOL, FORTRAN, ADA, MODULA 2, etc. And X {{would be a}} meta {{compiler}} according to the FORTH usage of <b>metacompiler.</b> A <b>metacompiler</b> operates at an abstraction level above the compiler it compiles. It only operates at the same (self-hosting compiler)level when compiling itself. One has to see {{the problem with this}} definition of <b>metacompiler.</b> It can be applied to most any language.|$|E
50|$|See <b>metacompiler,</b> META II, and TREE-META.|$|E
50|$|The {{earliest}} Schorre <b>metacompilers,</b> META I and META II, {{were developed}} by D. Val Schorre at UCLA. Other Schorre based <b>metacompilers</b> followed. Each adding improvements to language analysis and/or code generation.|$|R
50|$|<b>Metacompilers</b> {{have played}} a {{significant}} role in both computer science and the build-up of the computer industry.|$|R
50|$|The {{characteristics}} of the metaprogramming metalanguages above are common to all Schorre <b>metacompilers</b> and those derived from them.|$|R
50|$|Complementing language-oriented programming, {{as well as}} {{all other}} forms of domain-specific languages, are the class of {{compiler}} writing tools called metacompilers. A <b>metacompiler</b> is not only useful for generating parsers and code generators for domain-specific languages, but a <b>metacompiler</b> itself compiles a domain-specific metalanguage specifically designed for the domain of metaprogramming.|$|E
50|$|Programming in FORTH {{is adding}} new {{words to the}} {{language}}. Changing the language {{in this way is}} metaprogramming. FORTH is a <b>metacompiler</b> because FORTH is a language specifically designed for metaprogramming. Programming in FORTH is extending FORTH adding WORDS to the forth vocabulary creates a new FORTH dialect. FORTH is a specialized <b>metacompiler</b> for FORTH language dialects.|$|E
50|$|A <b>metacompiler</b> is a metaprogram usually {{written in}} its own {{metalanguage}} or an existing computer programming language. The process of a <b>metacompiler,</b> written {{in its own}} metalanguage, compiling itself is equivalent to self-hosting compiler. Most common compilers written today are Self-hosting compilers. Self-hosting is a powerful tool, of many metacompilers, allowing the easy extension of their own metaprogramming metalanguage. The feature that separates a <b>metacompiler</b> apart from other compiler compilers is that it takes as input a specialized metaprogramming language that describes {{all aspects of the}} compilers operation. A metaprogram produced by a <b>metacompiler</b> is as complete a program as a program written in C++, BASIC or any other general programming language. The metaprogramming metalanguage is a powerful attribute allowing the ease of development of computer programming languages and other computer tools. Command line processors, text string transforming and analysis are easily coded using metaprogramming metalanguages of metacompilers.|$|E
50|$|Early <b>metacompilers</b> use {{the terms}} syntax-driven and syntax-directed {{translation}} in their descriptions. They have metaprogramming language features for outputing code.|$|R
50|$|<b>Metacompilers</b> {{that played}} a {{significant}} role in both computer science and the computer industry include Meta-II and its descendent TreeMeta.|$|R
5000|$|... adds introspection/reflection and {{serialization}} to C++ {{with the}} usage of C++ language-constructs only (a meta-language or <b>metacompilers</b> are not necessary) ...|$|R
5000|$|... "A <b>meta{{compiler}}</b> is a compiler which processes its own source code, {{resulting in}} an executable version of itself." ...|$|E
50|$|This Forth use of <b>metacompiler</b> is disputed in {{mainstream}} computer science. See Forth (programming language) and History of compiler construction. The actual Forth process of compiling {{itself is a}} combination of a Forth being a Self-hosting Extensible programming language and sometimes Cross compilation, long established terminology in computer science. Metacompilers are a general compiler writing system. Besides the FORTH <b>metacompiler</b> concept being indistinguishable from self-hosting and extensible language. The actual process acts at a lower level defining a minimum subset of forth words, {{that can be used to}} define additional forth words, A full FORTH implementation can then be defined from the base set. This sounds like a bootstrap process. The problem is that almost ever general purpose language compiler also fits the FORTH <b>metacompiler</b> description.|$|E
5000|$|When (self-hosting compiler) X {{processes}} its own source code, {{resulting in}} an executable version of itself, X is a <b>metacompiler.</b>|$|E
50|$|Besides parsing domain-specific languages, <b>metacompilers</b> {{are useful}} for {{generating}} {{a wide range of}} software engineering and analysis tools. The meta-compiler methodology is often found in program transformation systems.|$|R
50|$|With the {{resurgence}} of domain-specific languages {{and the need for}} parser generators which are easy to use, easy to understand, and easy to maintain, <b>metacompilers</b> are becoming a valuable tool for advanced software engineering projects.|$|R
50|$|In 1964, System Development Corporation began a {{major effort}} in the {{development}} of <b>metacompilers.</b> This effort includes powerful <b>metacompilers,</b> Bookl, and Book2 written in LISP which have extensive tree-searching and backup capability. An outgrowth of one of the Q-32 systems at SDC is Meta 5. The Meta 5 system incorporates backup of the input stream and enough other facilities to parse any context-sensitive language. This system was successfully released to a wide number of users and had many string-manipulation applications other than compiling. It has many elaborate push-down stacks, attribute setting and testing facilities, and output mechanisms. The fact that Meta 5 successfully translates JOVIAL programs to PL/l programs clearly demonstrates its power and flexibility.|$|R
50|$|Schorre {{bootstrapped}} Meta II from Meta I {{during the}} Spring of 1963. The {{paper on the}} refined <b>metacompiler</b> system presented at the 1964 Philadelphia ACM conference is the first paper on a <b>metacompiler</b> available as a general reference. The syntax and implementation technique of Schorre's system {{laid the foundation for}} most of the systems that followed. The system was implemented on a small 1401, and was used to implement a small ALGOL-like language.|$|E
50|$|Late in 1964, Lee Schmidt {{bootstrapped}} the <b>metacompiler</b> EQGEN, {{from the}} PDP-l to the Beckman 420. EQGEN was a logic equation generating language.|$|E
50|$|Besides being {{useful for}} domain-specific {{language}} development, a <b>metacompiler</b> {{is itself a}} prime example of a domain-specific language, designed for the domain of compiler writing.|$|E
50|$|<b>Metacompilers</b> {{differ from}} parser generators. They take {{a program in}} a metaprogramming language, and have grammar {{analyzing}} rules and code production transforms that output executable code. They can be programmed in their own metalanguages enabling them to compile themselves, making them self-hosting extensible language compilers.|$|R
50|$|The syntax {{language}} {{is similar to}} that of Dewey Val Schorre's line of <b>metacompilers.</b> It most resembles TREEMETA having tree building operations in the syntax language. The unparse rules of TREEMETA are extended to work with the object oriented generator language based on LISP 2.|$|R
5000|$|Another {{approach}} is to use meta-level compilation (MC),. [...] <b>Metacompilers</b> constructed for this purpose may extend the compilers with lightweight, system specific checkers and optimizers. These extensions need to be written by system implementers in a high level language and dynamically linked to the compilers to do strict static analysis.|$|R
50|$|<b>Metacompiler</b> metalanguages are {{powerful}} string and symbol processing languages {{that are also}} useful for generating {{a wide range of}} other software engineering and analysis tools.|$|E
50|$|META II is {{the first}} {{documented}} version of a <b>metacompiler,</b> as it compiles to machine code {{for one of the}} earliest instances of a virtual machine.|$|E
50|$|An analogy can be drawn: That as a C++ {{compiler}} {{takes as}} input a C++ programming language program, a <b>metacompiler</b> takes as input a metaprogramming metalanguage program.|$|E
50|$|Forth is {{an example}} of a self-hosting compiler. The self {{compilation}} and cross compilation features of Forth are commonly confused with metacompilation and <b>metacompilers.</b> Like Lisp, Forth is an extensible programming language. It is the extensible programming language features of Forth and Lisp that enable them to generate new versions of themselves or port themselves to new environments.|$|R
50|$|In {{programming}} it {{is common}} to use the programming language name to refer to both the compiler and the programming language. The context distinguishing the meaning. A C++ program is compiled using a C++ compiler. That also applies in the following. For example, META II is both the compiler and the language. The metalanguages in the Schorre line of <b>metacompilers</b> are functional programming languages that use top down grammar analyzing syntax equations having embedded output transformation constructs.|$|R
50|$|The {{early history}} of <b>metacompilers</b> is closely tied {{with the history of}} SIG/PLAN Working group 1 on Syntax Driven Compilers. The group was started {{primarily}} through the effort of Howard Metcalfe in the Los Angeles area. In the fall of 1962 Howard Metcalfe designed two compiler-writing interpreters. One used a bottom-to-top analysis technique based on a method described by Ledley and Wilson. The other used a top-to-bottom approach based on a work by glennie to generate random English sentences from a context-free grammar.|$|R
50|$|However, on {{examining}} {{the concept of}} programming in FORTH, adding new words to the dictionary, extending the language {{in this way is}} metaprogramming. It is this metaprogramming in forth that makes it a <b>metacompiler.</b>|$|E
50|$|A <b>metacompiler</b> is a {{software}} development tool used chiefly {{in the construction}} of compilers, translators, and interpreters for other programming languages. They are a subset of a specialized class of compiler writing tools called compiler-compilers that employ metaprogramming languages.Metaprogramming is the writing of computer programs with the ability to treat programs as their data. The input to a <b>metacompiler</b> is a metaprogram written in a specialized metalanguage designed chiefly for the purpose of constructing compilers. The language of the compiler produced is called the object language. The minimal input producing a compiler is a metaprogram specifying the object language grammar and semantic transformations into an object program.|$|E
50|$|Lee Schmidt at Bolt, Beranek, and Newman wrote a <b>metacompiler</b> in March 1963 that {{utilized}} a CRT {{display on}} the time-sharing PDP-l. This compiler produced actual machine code rather than interpretive code and was partially bootstrapped from Meta I.|$|E
50|$|META I was a hand {{compiled}} <b>metacompiler</b> used {{to compile}} META II. Little else {{is known of}} META I except that the initial compilation of META II produced nearly identical code {{to that of the}} hand coded META I compiler.|$|E
50|$|Many metacompilers {{build on}} the work of Val Schorre. His META II, first {{released}} in 1962, was the first documented <b>metacompiler.</b> META II accepted grammars and code generation rules, and was able to compile itself and other languages. It also translated to one of the earliest instances of a virtual machine.|$|E
50|$|These {{changes made}} that META II and its {{derivative}} programming languages able {{to define and}} extend their own metalanguage. In so doing {{the ability to use}} a natural language description, metalinguistic variable, language construct description was lost. Many spin-off metalanguages were inspired by BNF. See META II, TREE-META, and <b>Metacompiler.</b>|$|E
