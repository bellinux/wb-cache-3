680|82|Public
5|$|Unlike C++, C# {{does not}} support <b>multiple</b> <b>inheritance,</b> {{although}} a class can implement any number of interfaces. This was a design decision by the language's lead architect to avoid complication and simplify architectural requirements throughout CLI. When implementing multiple interfaces that contain a method with the same signature, C# allows implementing each method depending on which interface that method is being called through, or, like Java, allows implementing the method once, and have that be the one invocation on a call through any of the class's interfaces.|$|E
25|$|In 1989, C++ 2.0 was released, {{followed}} by the updated second edition of The C++ Programming Language in 1991. New features in 2.0 included <b>multiple</b> <b>inheritance,</b> abstract classes, static member functions, const member functions, and protected members. In 1990, The Annotated C++ Reference Manual was published. This work {{became the basis for}} the future standard. Later feature additions included templates, exceptions, namespaces, new casts, and a boolean type.|$|E
25|$|Similar to Java, UnrealScript is {{object-oriented}} without <b>multiple</b> <b>inheritance</b> (classes all {{inherit from}} a common Object class), and classes are defined in individual files named for the class they define. Unlike Java, UnrealScript does not have object wrappers for primitive types. Interfaces are only supported in Unreal Engine generation 3 and a few Unreal Engine 2 games. UnrealScript supports operator overloading, but not method overloading, except for optional parameters.|$|E
40|$|Clustering {{systems can}} {{discover}} intentional structures in data and extract new knowledge from a database. Many incremental and non-incremental clustering algorithms have been proposed, {{but they have}} some problems. Incremental algorithms work very efficiently, but their performance is strongly affected by the input order of instances. On the other hand, non-incremental algorithms are independent of the input order of instances but often {{take a long time}} to build clusters for a large database. Moreover, most of incremental and non-incremental algorithms build concept hierarchies with single inheritance. Many real world problems require different points of view to be solved. Concept hierarchies with <b>multiple</b> <b>inheritances</b> are useful for such problems. We propose a non-incremental and efficient algorithm which builds concept hierarchies with <b>multiple</b> <b>inheritances.</b> Introduction Clustering systems can discover intentional structures in data. It groups instances which have similar feature [...] ...|$|R
40|$|A table object, {{defined and}} {{described}} in XML, {{is treated as}} the basic unit in a free-link topology that enables <b>multiple</b> <b>inheritances</b> for each node. In this paper, a novel table navigation system called TableHunter is introduced. Each table object {{is presented in the}} TableHunter as a node of a map structure, and supports a context+focus view. 1...|$|R
40|$|Author(s) : {{see above}} • Address: see above A table object, defined and {{described}} in XML, {{is treated as}} the basic unit in a free-link topology that enables <b>multiple</b> <b>inheritances</b> for each node. In this paper, a novel table navigation system called TableHunter is introduced. Each table object {{is presented in the}} TableHunter as a node of a map structure, and supports a context+focus view. 1...|$|R
25|$|Another {{key feature}} of ObjC is {{its use of}} protocols, known in most modern {{languages}} as interfaces. Protocols promise that a particular class implements a set of methods, meaning that other objects in the system can call those methods on any object supporting that protocol. This is often used in modern OO languages {{as a substitute for}} <b>multiple</b> <b>inheritance,</b> although the feature sets are not entirely similar. A common example of a protocol in Cocoa is the NSCopying protocol, which defines one method, copyWithZone, that implements deep copying on objects.|$|E
2500|$|Lisp deeply {{influenced}} Alan Kay, {{the leader}} of the research team that developed Smalltalk at Xerox PARC; and in turn Lisp was influenced by Smalltalk, with later dialects adopting object-oriented programming features (inheritance classes, encapsulating instances, message passing, etc.) in the 1970s. [...] The Flavors object system introduced the concept of <b>multiple</b> <b>inheritance</b> and the mixin. The Common Lisp Object System provides <b>multiple</b> <b>inheritance,</b> multimethods with multiple dispatch, and first-class generic functions, yielding a flexible and powerful form of dynamic dispatch. It has served as the template for many subsequent Lisp (including Scheme) object systems, which are often implemented via a metaobject protocol, a reflective metacircular design in which the object system is defined in terms of itself: Lisp was only the second language after Smalltalk (and {{is still one of the}} very few languages) to possess such a metaobject system. Many years later, Alan Kay suggested that as a result of the confluence of these features, only Smalltalk and Lisp could be regarded as properly conceived object-oriented programming systems.|$|E
2500|$|This feature {{makes it}} easy to develop {{efficient}} languages within languages. [...] For example, the Common Lisp Object System can be implemented cleanly as a language extension using macros. [...] This means that if an application needs a different inheritance mechanism, it can use a different object system. [...] This is in stark contrast to most other languages; for example, Java does not support <b>multiple</b> <b>inheritance</b> and there is no reasonable way to add it.|$|E
40|$|The {{object-oriented}} programming paradigm provides {{strong support for}} code re-use via inheritance mechanisms. Currently, Java {{is one of the}} most widely used objected-oriented programming languages, but Java supports only single code inheritance. Unfortunately, code repetition is sometimes unavoidable without some form of <b>multiple</b> code <b>inheritance.</b> Historically, <b>multiple</b> code <b>inheritance</b> mechanisms in programming languages have been problematic. This is due to the tight coupling of code and data layout, along with funda-mental semantic issues with <b>multiple</b> data layout <b>inheritance.</b> Since Java’s class mechanism is used for both inheriting code for methods (i. e., code-type) and inheriting state informa-tion (i. e., data-type), a mechanism for separating the code-type and data-type inheritance is necessary to solve the <b>multiple</b> code <b>inheritance</b> problem. We describe the implementation of MCI-Java, an extension to Sun’s Java 1. 2. 2 that separates code-types and data-types and thereby enables a <b>multiple</b> code <b>inheritance</b> mech-anism. IBM’s Jikes Compiler 1. 15 is modified to provide compiler support for MCI-Java. At the source-code level, minor Java syntax changes are required for MCI-Java. At the Vir-tual Machine level, minor changes to the code loader and linker are required, but no change is made to the highly-optimized bytecode execution procedure. Lastly, we empirically demonstrate that the MCI-Java Virtual Machine, and the modi-fied IBM Jikes Compiler, do not degrade the performance of Java programs, when compared with the classic Java Virtual Machine and the original IBM Jikes Compiler...|$|R
50|$|In December 2010, ForgeRock {{released}} OpenDJ 2.4.0 including fixes {{and support}} for new features like Collective Attributes, Microsoft Active Directory Permissive Modification Control, and <b>multiple</b> objectclass <b>inheritance.</b>|$|R
40|$|Abstract. An {{important}} {{research of}} information retrieval technology {{is how to}} express the intention of users accurately and make a sensible judgment on the semantic similarity between conceptual entities. A scheme is presented to calculate the semantic similarity, which takes multi-inheritance of entities and property values into consideration, and then optimizes the computing process based on the tree structure of inheritance relationship. When the instance <b>multiple</b> <b>inheritances</b> are relatively complex, the accuracy rate is more pronounced than existing methods. The experimental {{results show that the}} scheme proposed in this paper can calculate semantic similarity more accurately even in ontology-based knowledge base...|$|R
2500|$|Inheritance {{allows one}} data type to acquire {{properties}} of other data types. Inheritance from a base class may be declared as public, protected, or private. This access specifier determines whether unrelated and derived classes can access the inherited public and protected {{members of the}} base class. Only public inheritance corresponds to what is usually meant by [...] "inheritance". The other two forms are much less frequently used. If the access specifier is omitted, a [...] "class" [...] inherits privately, while a [...] "struct" [...] inherits publicly. Base classes may be declared as virtual; this is called virtual inheritance. Virtual inheritance ensures that only one instance of a base class exists in the inheritance graph, avoiding some of the ambiguity problems of <b>multiple</b> <b>inheritance.</b>|$|E
2500|$|JSR 335, JEP 126: Language-level {{support for}} lambda {{expressions}} (officially, lambda expressions; unofficially, closures) under Project Lambda and default methods (virtual extension methods) which allow {{the addition of}} methods to interfaces without breaking existing implementations. There was an ongoing debate in the Java community on whether to add support for lambda expressions. Sun later declared that lambda expressions would be included in Java and asked for community input to refine the feature. Supporting lambda expressions also allows the performance of [...] functional-style operations on streams of elements, such as MapReduce-inspired transformations on collections. Default methods allow an author of an API to add new methods to an interface without breaking the old code using it. Although it was not their primary intent, default methods also allow <b>multiple</b> <b>inheritance</b> of behavior (but not state).|$|E
2500|$|Ruby is object-oriented: every {{value is}} an object, {{including}} classes and instances of types {{that many other}} languages designate as primitives (such as integers, booleans, and [...] "null"). Variables always hold references to objects. Every function is a method and methods are always called on an object. Methods defined at the top level scope become methods of the Object class. Since this class is an ancestor of every other class, such methods can be called on any object. They are also visible in all scopes, effectively serving as [...] "global" [...] procedures. Ruby supports inheritance with dynamic dispatch, [...] mixins and singleton methods (belonging to, and defined for, a single instance rather than being defined on the class). Though Ruby does not support <b>multiple</b> <b>inheritance,</b> classes can import modules as mixins.|$|E
40|$|The {{reference}} class {{problem in}} probability {{theory and the}} <b>multiple</b> <b>inheritances</b> (extensions) problem in non-monotonic logics {{can be referred to}} as special cases of con icting beliefs. The current solution accepted in the two domains is the speci city priority principle. By analyzing an example, several factors (ignored by the principle) are found to be relevant to the priority of a reference class. A new approach, Non-Axiomatic Reasoning System (NARS), is discussed, where these factors are all taken into account. It is argued that the solution provided by NARS is better than the solutions provided by probability theory and non-monotonic logics. ...|$|R
40|$|The {{capability}} to systematize and manage an emerging Linguistic and Ontology/Concept Knowledge {{is key to}} an editor's usability. Convenient and intuitive presentations and manipulations of a Word and its Concept, Concept's interlinking concepts and relations are essential. Concept hierarchies also have <b>multiple</b> <b>inheritances,</b> convenient and insightful presentations while keeping the associations straight is a challenge. Therefore, our aim {{is to create a}} visualization that will effectively display all this elements {{and at the same time}} let the user perform various operations easily on the Linguistic and Ontology/Concept Knowledge. This paper describes the management console for the Linguistic and Conceptual part...|$|R
50|$|Some {{languages}} may {{implement a}} record as {{an array of}} addresses pointing to the fields (and, possibly, to their names and/or types). Objects in object-oriented languages are often implemented in rather complicated ways, especially in languages that allow <b>multiple</b> class <b>inheritance.</b>|$|R
2500|$|The label {{systemic}} {{is related}} to the system networks used in the description of human languages. System networks capture the dimension of choice at each stratum of the linguistic system to which they are applied. The system networks of the lexicogrammar make up systemic functional grammar. A system network is a theoretical tool to describe the sets of options available in a language variety; it represents abstract choice and does not correspond to a notion of actual choice or make psychological claims. Formally system networks correspond to type lattices in formal lattice theory, although they are occasionally erroneously mistaken for flowcharts or directed decision trees. Such directionality is always only a property of particular implementations of the general notion and may be made for performance reasons in, for example, computational modelling. System networks commonly employ <b>multiple</b> <b>inheritance</b> and [...] "simultaneous" [...] systems, or choices, which therefore combine to generate very large descriptive spaces.|$|E
2500|$|<b>Multiple</b> <b>inheritance</b> is a C++ feature {{not found}} in most other languages, {{allowing}} a class {{to be derived from}} more than one base class; this allows for more elaborate inheritance relationships. For example, a [...] "Flying Cat" [...] class can inherit from both [...] "Cat" [...] and [...] "Flying Mammal". Some other languages, such as C# or Java, accomplish something similar (although more limited) by allowing inheritance of multiple interfaces while restricting the number of base classes to one (interfaces, unlike classes, provide only declarations of member functions, no implementation or member data). An interface as in C# and Java can be defined in C++ as a class containing only pure virtual functions, often known as an abstract base class or [...] "ABC". The member functions of such an abstract base class are normally explicitly defined in the derived class, not inherited implicitly. C++ virtual inheritance exhibits an ambiguity resolution feature called dominance.|$|E
5000|$|... {{to model}} <b>multiple</b> <b>inheritance</b> in a {{language}} in which <b>multiple</b> <b>inheritance</b> is not supported ...|$|E
40|$|The {{language}} {{design process}} should {{be supported by}} modularity and abstraction {{in a manner that}} allows incremental changes as easily as possible. To at least partially fullfil this ambitious goal a new object-oriented attribute grammar specication language which supports <b>multiple</b> attribute grammar <b>inheritance</b> is introduced. <b>Multiple</b> attribute grammar <b>inheritance</b> is a structural organization of attribute grammars where the attribute grammar inherits the specifications from ancestor attribute grammars, may add new specifications or may override some specifications from ancestor specifications. With the proposed approach a language designer has the chance to design incrementally a language or reuse some fragments from other programming language specifications. The <b>multiple</b> attribute grammar <b>inheritance</b> is first introduced using an example, and thereafter by a formal model. The proposed approach is successfully implemented in the compiler/interpreter generator tool LISA ver. 2. 0...|$|R
40|$|This article {{reports on}} {{one part of}} an {{on-going}} project, the Near Future School, which aims to translate and explore the potential of participatory design fiction practices for use with young people and those that work with them to explore near future scenarios of education that open up alternative and plural futures {{in the context of}} processes of foreclosure in a neoliberalising society. The focus here is to explore the practical and ethical issues of developing a speculative form of governance, using the philosophy of Benedict de Spinoza, as an act of imaginative world building through participatory design fictions. The research raises a series of questions and issues relating to understanding how design fiction’s <b>multiple</b> <b>inheritances,</b> from fiction and design or art and design, need to be better understood and enacted within participatory design fiction processes...|$|R
40|$|Abstract. This paper {{introduces}} {{a programming language}} that makes it convenient to extend large software systems and even to compose them in a modular way. JX/MI supports <b>multiple</b> nested <b>inheritance,</b> building on earlier work on nested inheritance in the language JX. Nested inheritance permits modular, type-safe extension of a package (including nested packages and classes), while preserving existing type relationships. <b>Multiple</b> nested <b>inheritance</b> enables simultaneous extension {{of two or more}} classes or packages, composing their types and behavior while resolving conflicts with a relatively small amount of code. The utility of JX/MI is demonstrated by using it to construct two composable, extensible frameworks: a compiler framework for Java, and a peer-to-peer networking system. Both frameworks support composition of extensions. For example, two compilers adding different, domain-specific features to Java can be composed to obtain a compiler for a language that supports both sets of features. ...|$|R
50|$|In {{software}} engineering, the Twin {{pattern is}} a software design pattern that allows developers to model <b>multiple</b> <b>inheritance</b> in programming languages {{that do not}} support <b>multiple</b> <b>inheritance.</b> This pattern avoids {{many of the problems}} with <b>multiple</b> <b>inheritance.</b>|$|E
5000|$|It {{provides}} {{a mechanism for}} <b>multiple</b> <b>inheritance</b> by allowing multiple classes to use the common functionality, but without the complex semantics of <b>multiple</b> <b>inheritance.</b>|$|E
5000|$|...NET {{does not}} offer <b>multiple</b> <b>inheritance.</b> Nevertheless, in some use cases <b>multiple</b> <b>inheritance</b> support would be helpful for [...]NET applications. In {{languages}} such as Ruby these use cases were solved with mixins.|$|E
40|$|In this paper, {{we present}} a method to plot a {{directed}} acyclic graph (DAG) which represents a hierarchical structure with <b>multiple</b> <b>inheritances.</b> This method {{is used in the}} thesaurus browser `xthes 2 ̆ 7 to display 2 ̆ 7 is-a 2 ̆ 7 relationship between nodes in a thesaurus or ontology. Because it is noted that the problem of minimizing arc crossings in a DAG is NP-hard, we need a fast heuristic algorithm. `xthes 2 ̆ 7 draws a DAG as follows. At first, it splits a DAG into a tree and other non-tree arcs. Then, it rearranges the order of children nodes by clustering subtrees, and reverses the order of subtrees in the clusters, to make the length of inter-subtree links as short as possible. Finally, it minimizes the distance between subtrees in bottom-up manner, and decides the position of the nodes and arcs. By the experiment, it was confirmed that our node-exchanging method saves about 50...|$|R
50|$|Craniofrontonasal {{dysplasia}} (CFND) {{is a rare}} type of FND with X linked <b>inheritance.</b> <b>Multiple</b> {{features are}} characteristic for CFND such as craniosynostosis of the coronal sutures (prematurely closed cranial sutures), dry frizzy curled hair, splitting of the nails and facial asymmetry.|$|R
40|$|A {{suggestion}} by John McCarthy {{for general}} formulations of <b>multiple</b> defeasible <b>inheritance</b> in ordinary nonmonotonic logic is examined {{and found to}} suffer {{from a variety of}} technical problems, including 1) its restriction to object/class/property networks, 2) unintuitive results in “Nixon diamond”-type networks, 3) unnecessary closed-world assumptions, and 4) susceptibility to unintended models when generalized. A family of theories is presented that substantially revises McCarthy’s formulation to avoid these problems and restrictions. Finally, an inference control strategy for computing the theory is identified whose tractabilit...|$|R
50|$|Unlike C++, Java {{does not}} support {{operator}} overloading or <b>multiple</b> <b>inheritance</b> for classes, though <b>multiple</b> <b>inheritance</b> is supported for interfaces. This simplifies the language and aids in preventing potential errors and anti-pattern design.|$|E
50|$|CLOS allows <b>multiple</b> <b>inheritance.</b> When {{the default}} {{order in which}} methods are {{executed}} in <b>multiple</b> <b>inheritance</b> is not correct, the programmer may resolve the diamond inheritance problems by specifying the order of method combinations.|$|E
50|$|Sass {{supports}} <b>multiple</b> <b>inheritance.</b>|$|E
40|$|Java has multiple-inheritance of interfaces, {{but only}} singleinheritance of code. This {{situation}} results in duplicated code in Java library classes and application code. This paper describes a generalization to the Java Virtual Machine (JVM) to support multiple-inheritance of code. Our approach places code in interfaces. This extension {{can be implemented}} by adding {{a small amount of}} code to a few locations in a JVM. Furthermore, a set of simple scripts allows a programmer to use <b>multiple</b> code <b>inheritance</b> with existing javac compilers. Word Count = 9, 273...|$|R
40|$|This paper {{describes}} a unification-based lexicon system for NLP applications that incorporates mechanisms for <b>multiple</b> default <b>inheritance.</b> Such systems are intractable {{in the general}} case [...] the approach adopted here places a number of restrictions on the inheritance hierarchy in order to {{remove some of the}} sources of complexity while retaining more desirable properties. Implications of the design choices are discussed, comparisons are drawn with related work in computational linguistics and AI, and illustrative examples from the lexicons of German and English are given. 1...|$|R
40|$|Abstract We {{investigate}} a technique from the literature, called the phantom types tech-nique, that uses parametric polymorphism, type constraints, and unification of polymorphic types to model a subtyping hierarchy. Hindley-Milner type systems,such {{as the one}} found in ML, {{can be used to}} enforce the subtyping relation. We show that this technique can be used to encode any finite subtyping hierarchy(including hierarchies arising from <b>multiple</b> interface <b>inheritance).</b> We then formally demonstrate the suitability of the phantom types technique for capturingsubtyping by exhibiting a type-preserving translation from a simple calculus with bounded polymorphism to a calculus embodying the type system of ML...|$|R
