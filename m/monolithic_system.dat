146|476|Public
25|$|Mac OS is {{characterized}} by its <b>monolithic</b> <b>system.</b> From its original release through System 4, it ran only one application at a time. Even so, it was noted for its ease of use. Mac OS gained cooperative multitasking with System 5, which ran on the Macintosh SE and Macintosh II. It was criticized for its very limited memory management, lack of protected memory, no access controls, and susceptibility to conflicts among extensions that provide additional functionality such as networking or support for a particular device.|$|E
50|$|<b>Monolithic</b> <b>system</b> {{can have}} {{different}} meanings in the contexts of computer software and hardware.|$|E
5000|$|Decentralisation: {{there is}} no {{designated}} controlling agent (or the system is effectively reduced to a <b>monolithic</b> <b>system)</b> ...|$|E
40|$|A wide {{panoply of}} machine {{learning}} methods {{is available for}} application to the Predictive Toxicology Evaluation (PTE) problem. The authors have built four <b>monolithic</b> classification <b>systems</b> based on Tilde, Progol, C 4. 5 and naive bayesian classification. These systems have been trained using the PTE dataset, and their accuracy has been tested using the unseen PTE 1 data set as test set. A Multi Agent Decision System (MADES) has been built using the aforementioned <b>monolithic</b> <b>systems</b> to build classification agents. The MADES was trained and tested with the same data sets used with the <b>monolithic</b> <b>systems.</b> Results show that {{the accuracy of the}} MADES improves the accuracies obtained by the <b>monolithic</b> <b>systems.</b> We believe that in most real world domains the combination of several approaches is stronger than the individuals. Introduction The Predictive Toxicology Evaluation (PTE) Challenge (Srinivasan et al. 1997) was devised by the Oxford University Computing Laboratory to test the suitability [...] ...|$|R
40|$|This paper {{considers}} how two kernelized systems, Mach 3. 0 {{with the}} BSD 4. 3 Single Server and CHORUS/MiX V. 4, move data {{to and from}} files {{under a variety of}} circumstances. We give an overview of the kernel abstractions and system servers and describe in detail the read() and write() paths of these two systems. We then break down their read() and write() performance and compare them to two <b>monolithic</b> <b>systems,</b> Mach 2. 6 MSD(BSD 4. 3) and System V R 4. 0. We then describe the compromises each of the two kernelized systems made in order to achieve a goal of performance comparable to the <b>monolithic</b> <b>systems.</b> We conclude with a description of what techniques each system uses that could benefit both each other and traditional <b>monolithic</b> <b>systems.</b> 1...|$|R
40|$|Proceeding of: AAAI Spring Symposium on Predictive Toxicology, AAAI Press, Stanford, March 1999 A wide {{panoply of}} machine {{learning}} methods {{is available for}} application to the Predictive Toxicology Evaluation (PTE) problem. The authors have built four <b>monolithic</b> classification <b>systems</b> based on Tilde, Progol, C 4. 5 and naive bayesian classification. These systems have been trained using the PTE dataset, and their accuracy has been tested using the unseen PTE 1 data set as test set. A Multi Agent Decision System (MADES) has been built using the aforementioned <b>monolithic</b> <b>systems</b> to build classification agents. The MADES was trained and tested with the same data sets used with the <b>monolithic</b> <b>systems.</b> Results show that {{the accuracy of the}} MADES improves the accuracies obtained by the <b>monolithic</b> <b>systems.</b> We believe that in most real world domains the combination of several approaches is stronger than the individuals. Introduction The Predictive Toxicology Evaluation (PTE) Challenge (Srinivasan et al. 1997) was devised by the Oxford University Computing Laboratory to test the suitability [...] . Publicad...|$|R
50|$|On most {{mainstream}} processors, {{obtaining a}} service is inherently more expensive in a microkernel-based system than a <b>monolithic</b> <b>system.</b> In the <b>monolithic</b> <b>system,</b> {{the service is}} obtained by a single system call, which requires two mode switches (changes of the processor's ring or CPU mode). In the microkernel-based system, the service is obtained by sending an IPC message to a server, and obtaining the result in another IPC message from the server. This requires a context switch if the drivers are implemented as processes, or a function call if they are implemented as procedures. In addition, passing actual data to the server and back may incur extra copying overhead, while in a <b>monolithic</b> <b>system</b> the kernel can directly access the data in the client's buffers.|$|E
50|$|In a <b>monolithic</b> <b>system,</b> a bug in {{a driver}} can easily crash the whole kernel. This {{is far less}} likely to occur in MINIX 3.|$|E
50|$|OpenTag {{implements}} DASH7 Mode 2, which specifies a <b>monolithic</b> <b>system</b> encompassing OSI layers {{one through}} six, part of layer seven, {{as well as}} the application layer. OpenTag is designed to be light and compact, as it is targeted to run on resource-constrained micro-controllers. As a <b>monolithic</b> <b>system,</b> it does not implement different layers of the OSI model {{in a way that will}} enable them to be deployed on systems that differ from the typical, and nearly universal, MCU+RF transceiver architecture, utilized by WSN and M2M nodes. However, the OpenTag RTOS employs an exokernel architecture (as of version 0.4), so a monolithic kernel is not required. Applications developed for OpenTag may safely reference the library or directly access the hardware, as befits the exokernel design model.|$|E
40|$|The {{idea behind}} microservices {{architecture}} {{is to develop}} a single large, complex application as a suite of small, cohesive, independent services. On the other way, <b>monolithic</b> <b>systems</b> get larger over the time, deviating from the intended architecture, and becoming risky and expensive to evolve. This paper describes a technique to identify and define microservices on <b>monolithic</b> enterprise <b>systems.</b> As the major contribution, our evaluation shows that our approach was able to identify relevant candidates to become microservices on a 750 KLOC banking system. Comment: Alessandra Levcovitz; Ricardo Terra; Marco Tulio Valente. Towards a Technique for Extracting Microservices from <b>Monolithic</b> Enterprise <b>Systems.</b> 3 rd Brazilian Workshop on Software Visualization, Evolution and Maintenance (VEM), p. 97 - 104, 201...|$|R
40|$|This {{document}} is {{intended as a}} first step in evaluating the current environment with respect to Integrated Library Systems (ILS). To date ILSs have been proprietary <b>monolithic</b> <b>systems</b> encompassing the major operations of the library: circulation, acquisitions, cataloguing and a public catalogue or OPAC...|$|R
40|$|High-end {{enterprise}} storage {{has traditionally}} consisted of <b>monolithic</b> <b>systems</b> with customized hardware, multiple redundant components and paths, and no single point of failure. Distributed storage systems realized through networked storage nodes offer several advantages over <b>monolithic</b> <b>systems</b> such as lower cost and increased scalability. In {{order to achieve}} reliability goals associated with enterprise-class storage systems, redundancy {{will have to be}} distributed across the collection of nodes to tolerate both node and drive failures. In this paper, we present alternatives for distributing this redundancy, and models to determine the reliability of such systems. We specify a reliability target and determine the configurations that meet this target. Further, we perform sensitivity analyses where selected parameters are varied to observe their effect on reliability. 1...|$|R
50|$|Mac OS is {{characterized}} by its <b>monolithic</b> <b>system.</b> It was noted as {{easy to use and}} featured cooperative multitasking for most of its history, but it was criticized for its limited memory management, lack of protected memory and access controls, and susceptibility to conflicts among extensions.|$|E
50|$|Most {{succeeding}} object-oriented languages {{differed from}} Smalltalk {{in that they}} were compiled and executed in a discrete runtime environment, rather that being dynamically integrated into a <b>monolithic</b> <b>system</b> like the early Smalltalk environments. Nevertheless, {{the concept of a}} table-like or graphic browser to navigate a class hierarchy caught on.|$|E
50|$|<b>Monolithic</b> <b>System</b> Technology (MST) {{increased}} packaging {{density and}} circuit performance by replacing discrete transistors and diodes with {{one to four}} monolithic integrated circuits (resistors now external from the package on the module). Each MST chip holds about 5 circuits and is the approx equivalent of an SLT card. Circuits used NPN transistors.|$|E
40|$|Protected shared {{libraries}} {{are a new}} {{mechanism for}} building fast applicationextensible user-level operating system services. They extend notions previously found in dynamically linked shared libraries and thread migration to provide a new structuring model for operating system services. Early prototypes indicate that the performance of protected shared library services will be good, and that services can be made flexible with minimum overhead. 1. Introduction Modern operating system structures are evaluated on their performance, modularity and flexibility. <b>Monolithic</b> <b>systems</b> have generally provided the best performance whereas microkernel -based systems are modular [1] and, hence, more easily maintained. With the use of thread migration [10] [8], modular systems can achieve performance close to that of <b>monolithic</b> <b>systems.</b> However, neither <b>monolithic</b> nor microkernel-based structures, in themselves, seem particularly well suited to application-specific extensibility. This paper propose [...] ...|$|R
2500|$|Ten Principles for the Establishment of a <b>Monolithic</b> Ideological <b>System</b> ...|$|R
40|$|A Virtual Shared Disk (VSD) is a {{software}} abstraction that allows multiple nodes, running independent {{images of the}} operating system, to access a device physically attached to {{only one of the}} nodes as if the device were attached to all nodes. In this paper we consider the design and implementation of such a Virtual Shared Disk on the AIX operating system. We also describe a reliable VSD, which in the case of twin-tailed disks allows transparent takeover of the VSD by a backup node, while applications only experience a delay. 1 Introduction The availability of powerful microprocessors has made clusters an attractive alternative to <b>monolithic</b> <b>systems.</b> Applications that can partition their computation among several nodes can take advantage of this architecture, which typically offers better price-performance than the <b>monolithic</b> <b>systems.</b> Such applications include large scientific computations, database and transaction processing systems, decision support systems, etc. Many of these applic [...] ...|$|R
5000|$|Multiple {{projects}} {{can have}} separate, distinct codebases, or {{can have a}} single, shared or [...] This is particularly the case for related projects, such as those developed within the same company. In more detail, a monolithic codebase typically entails a single repository (all the code in one place), and often a common build system or common libraries. Whether the codebase is shared or split {{does not depend on}} the system architecture and actual build results; thus, a monolithic codebase, which is related to the actual development, does not entail a <b>monolithic</b> <b>system,</b> which is related to software architecture or a single monolithic binary. As a result, a monolithic codebase may and (for large codebases) often will consist of separate components, instead of carrying only a single system or single binary; a distributed codebase (with multiple components) can be used to build a single <b>monolithic</b> <b>system</b> or even a single binary. For example, the Linux kernel is architecturally a single monolithic kernel, but it consists of separate binaries (loadable components), and is developed in multiple distributed repositories.|$|E
50|$|Mac OS is {{characterized}} by its <b>monolithic</b> <b>system.</b> From its original release through System 4, it ran only one application at a time. Even so, it was noted for its ease of use. Mac OS gained cooperative multitasking with System 5, which ran on the Macintosh SE and Macintosh II. It was criticized for its very limited memory management, lack of protected memory, no access controls, and susceptibility to conflicts among extensions that provide additional functionality such as networking or support for a particular device.|$|E
50|$|The IBM 3705 Communications Controller is {{a simple}} {{computer}} which attaches to an IBM System/360 or System/370. Its purpose is to connect communication lines to the mainframe channel. It was a first communications controller of the popular IBM 37xx series. It was announced in March 1972. Designed for semiconductor memory which was not ready {{at the time of}} announcement, the 3705-I had to use 1.2 microsecond core storage; the later 3705-II uses 1.0 microsecond SRAM. <b>Monolithic</b> <b>System</b> Technology components, similar to those in S/370, were used.|$|E
40|$|The article {{deals with}} {{characteristics}} {{and performance of}} interaction protocols between virtual file system and file system, their influence on processing power of microkernel operating systems. User mode implementation of ext 2 file system for MINIX 3 OS is used to show that in microkernel operating systems file object identification time might increase up to 26 times in comparison with <b>monolithic</b> <b>systems.</b> Therefore, we present efficiency analysis of various hashing methods for file systems, running in user mode. Studies have shown that using hashing methods recommended in this paper {{it is possible to}} achieve competitive performance of the considered component of I/O stacks in microkernel and <b>monolithic</b> operating <b>systems.</b> ...|$|R
5000|$|Smaller and Focused 'Apps': Today’s <b>monolithic</b> <b>systems</b> and {{applications}} {{have too many}} interdependencies of databases, operate inconsistently, and are not inherently integrated. Being {{able to take advantage}} of many of the common software platform services described above, modular apps will be significantly smaller,simpler, and focused. These apps will be much lighter weight in functionality,and, as a result, significantly easier and faster to develop.|$|R
40|$|Current {{approaches}} in distributed computing {{are not sufficient}} to completely meet the needs for cross-platform application-to-application integration. The present trend is moving away from tightly coupled <b>monolithic</b> <b>systems</b> towards systems of loosely coupled components. The new-emerging Web Services concept was designed to meet these requirements of business-to-business application interaction. Web Services {{are based on a}} set of open, platform independent standards to reach a high level of acceptance...|$|R
50|$|Apple Computer {{licensed}} {{the cache}} based accelerator design from Zip Technologies for their {{design of the}} Apple IIc Plus. This enabled the computer to run 4 times faster than its 1 MHz predecessor, the Apple IIc. Rather than using a <b>monolithic</b> <b>System</b> in Package design of the Zip Chip, which may have caused overhead clearance problems as well as added cost to the compact Apple IIc Plus, Apple economically separated the Zip Chip design into its individual components, using off the shelf static RAM chips for the 8 KB cache.|$|E
50|$|The BORO {{method is}} {{designed}} to be a simple, repeatable process for developing formal ontologies. The method takes an extensional approach to ontology development. The method aims to be grounded in physical reality so that if followed to the letter the method should consistently produce the same ontology given the same inputs. It can then be used for comparing multiple data-sources for semantic matches/mismatches and for re-engineering multiple legacy systems into a coherent whole (either as a new <b>monolithic</b> <b>system,</b> or as a method for designing federation of existing systems).|$|E
50|$|The {{major change}} between these {{experimental}} kernels and Mach was {{the decision to}} make {{a version of the}} existing 4.2BSD kernel re-implemented on the Accent message-passing concepts. Such a kernel would be binary compatible with existing BSD software, making the system immediately useful for everyday use while still being a useful experimental platform. Additionally, the new kernel would be designed from the start to support multiple processor architectures, even allowing heterogeneous clusters to be constructed. In order to bring the system up as quickly as possible, the system would be implemented by starting with the existing BSD code, and reimplementing it bit by bit as inter-process communication-based (IPC-based) programs. Thus Mach would begin as a <b>monolithic</b> <b>system</b> similar to existing UNIX systems, and evolve more towards the microkernel concept over time.|$|E
40|$|An {{automated}} nano-LC-MS/MS platform without {{trap column}} was established, which only used a 20 cm lauryl methacrylate-ethylene dimethacrylate (LMA-EDMA) monolithic capillary column to allow preconcentration and separation of peptides. The monolithic column had {{the advantages of}} good permeability and low backpressure resulting in higher flow rates for capillary columns. Tryptic digests of bovine albumin and yeast protein extract were tested using the <b>monolithic</b> column <b>system.</b> High proteomic coverage using this approach were demonstrated in this study. Furthermore, peptide samples extracted from mouse liver were separated by using the <b>monolithic</b> column <b>system</b> combined with size-exclusion chromatography prefractionation. This <b>monolithic</b> column <b>system</b> might be a promising alternative for the automated system previously using a trap column for routine proteome and peptide profiling analysis...|$|R
25|$|Monolithic kernels are {{designed}} {{to have all of}} their code in the same address space (kernel space), which some developers argue is necessary to increase the performance of the system. Some developers also maintain that <b>monolithic</b> <b>systems</b> are extremely efficient if well written. The monolithic model tends to be more efficient through the use of shared kernel memory, rather than the slower IPC system of microkernel designs, which is typically based on message passing.|$|R
30|$|One-story precast {{concrete}} structures constitute {{a significant part}} of industrial buildings in earthquake-prone regions in Turkey. Post-earthquake observations revealed that beam-column connections are widely influence the overall seismic response of {{precast concrete}} structures (Saatcioglu et al. 2001; Ozden and Meydanli 2003; Senel and Palanci 2013). It is still a challenging subject to develop precast concrete beam-column connections emulating the seismic performance of <b>monolithic</b> <b>systems</b> to maintain advantages of precast construction process for multi-story buildings.|$|R
5000|$|A {{multi-agent system}} (M.A.S.) is a {{computerized}} system composed of multiple interacting intelligent agents within an environment. Multi-agent {{systems can be}} used to solve problems that are difficult or impossible for an individual agent or a <b>monolithic</b> <b>system</b> to solve. Intelligence may include some methodic, functional, procedural approach, algorithmic search or reinforcement learning. Although there is considerable overlap, a multi-agent system is not always the same as an agent-based model (ABM). The goal of an ABM is to search for explanatory insight into the collective behavior of agents (which don't necessarily need to be [...] "intelligent") obeying simple rules, typically in natural systems, rather than in solving specific practical or engineering problems. The terminology of ABM tends to be used more often in the sciences, and MAS in engineering and technology. Topics where multi-agent systems research may deliver an appropriate approach include online trading, disaster response, and modelling social structures.|$|E
5000|$|These GPO {{productions}} and {{the many}} wartime propaganda films led to an industry of animators with a diversity of design styles, well versed in conveying messages efficiently and clearly. As Van Norris notes, {{the influence of the}} combined demand from smaller commercial and governmental contracts would encourage the development of a variety of boutique production companies, as opposed to the more <b>monolithic</b> <b>system</b> developing concurrently in the United States. [...] Coming from this background, Halas and Batchelor maintained their position one of the leading European animation companies, producing many commercials and short films during most of {{the second half of the}} twentieth century and were responsible for producing the influential and ground breaking animated feature Animal Farm in 1954, a departure from the predominantly US-sourced animated films being exhibited at the time for its explicitly political content and more adult-oriented tone. Future animation production in the UK would likewise maintain a generally darker tone than U.S.-based productions.|$|E
40|$|In this paper, we {{introduce}} {{some pressure}} segregation methods {{obtained from a}} non-standard version of the discrete <b>monolithic</b> <b>system,</b> where the continuity equation {{has been replaced by}} a pressure Poisson equation obtained at the discrete level. In these methods it is the velocity instead of the pressure the extrapolated unknown. Moreover, predictor–corrector schemes are suggested, again motivated by the new <b>monolithic</b> <b>system.</b> Key implementation aspects are discussed, and a complete stability analysis is performed. We end with a set of numerical examples in order to compare these methods with classical pressure-correctio...|$|E
50|$|Monolithic kernels are {{designed}} {{to have all of}} their code in the same address space (kernel space), which some developers argue is necessary to increase the performance of the system. Some developers also maintain that <b>monolithic</b> <b>systems</b> are extremely efficient if well written. The monolithic model tends to be more efficient through the use of shared kernel memory, rather than the slower IPC system of microkernel designs, which is typically based on message passing.|$|R
50|$|A {{number of}} {{commercial}} multi-server systems exist, {{in particular the}} real-time systems QNX and Integrity. No comprehensive comparison of performance relative to <b>monolithic</b> <b>systems</b> has been published for those multiserver systems. Furthermore, performance {{does not seem to}} be the overriding concern for those commercial systems, which instead emphasize reliably quick interrupt handling response times (QNX) and simplicity for the sake of robustness. An attempt to build a high-performance multiserver operating system was the IBM Sawmill Linux project.However, this project was never completed.|$|R
40|$|Environment of {{computer}} systems in organization evolved from <b>monolithic</b> <b>systems</b> to network of many smaller nodes connected in to distributed systems. These nodes need {{the ability to}} comprehensible {{communicate with each other}} in heterogeneous environment of infrastructure that is still changing and in context of permanent changes of requirements. This work identifies possible application of SOAP as a communication carrier in given environment. SOAP as a simple and very extensible protocol based upon XML promises wide application in solving this problem...|$|R
