5|1|Public
5000|$|... #Caption: A <b>master-slave</b> <b>D</b> <b>flip-flop.</b> It {{responds}} on {{the falling}} {{edge of the}} enable input (usually a clock) ...|$|E
5000|$|... #Caption: An {{implementation}} of a <b>master-slave</b> <b>D</b> <b>flip-flop</b> that is triggered on the rising edge of the clock ...|$|E
50|$|A <b>master-slave</b> <b>D</b> <b>flip-flop</b> {{is created}} by {{connecting}} two gated D latches in series, and inverting the enable input to one of them. It is called master-slave because the second latch in the series only changes {{in response to a}} change in the first (master) latch.|$|E
40|$|Flip-Flops are off many types. Choosing {{the correct}} type FF for any {{application}} {{is very important}} to achieve high performance. the data look ahead <b>d</b> <b>Flip-Flop</b> (DLDFF) from the family of master-slave type is compared with pulse triggered conditional capture Flip-Flop(CCFF). The effect of clock gating on the performance of these Flip-Flops are analyzed. The two Flip-Flops are compared, with clock gating for power and delay and their field of application is determined. Our simulation results in 0. 18 µm CMOS technology in HSPICE indicates that DLDFF, for various load values 75 % power and 60 % delay reduction than DFF due to gating. but Clock Gated CCFF consumes more power on increasing load. Hence for applications that include large load, DLDFF will be the best choice. CGCCFF works well on high frequencies applications with 75 % power reduction and 60 % higher performance than CCFF. A 8 -bit synchronous counter is implemented DLDFF and CGCCFF saves 38 % and 15 % power consumption on clock gating than DFF and CCFF counterparts. The Pavg obtained for CGCCFF is proved as very much high when compared to DLDFF due to the increased load in couter. Hence it is determined that DLDFF is works well on large circuits and CGCCFF for high frequency applications...|$|R
5000|$|For a positive-edge {{triggered}} <b>master-slave</b> <b>D</b> <b>flip-flop,</b> {{when the}} clock {{signal is low}} (logical 0) the [...] "enable" [...] seen by the first or [...] "master" [...] D latch (the inverted clock signal) is high (logical 1). This allows the [...] "master" [...] latch to store the input value when the clock signal transitions from low to high. As the clock signal goes high (0 to 1) the inverted [...] "enable" [...] of the first latch goes low (1 to 0) and the value seen at the input to the master latch is [...] "locked". Nearly simultaneously, the twice inverted [...] "enable" [...] of the second or [...] "slave" [...] D latch transitions from low to high (0 to 1) with the clock signal. This allows the signal captured at the rising edge of the clock by the now [...] "locked" [...] master latch {{to pass through the}} [...] "slave" [...] latch. When the clock signal returns to low (1 to 0), the output of the [...] "slave" [...] latch is [...] "locked", and the value seen at the last rising edge of the clock is held while the [...] "master" [...] latch begins to accept new values in preparation for the next rising clock edge.|$|E
40|$|Digital {{circuits}} can exhibit metastable behavior {{when there}} are setup and hold time violations in the circuits. This paper describes the experimental method to detect metastability behavior of a flip-flop [1] and a circuit to measure the delay in the data path. We used a <b>master-slave</b> <b>D</b> <b>flip-flop</b> to observe the metastability and tried to observe the metastability behavior with both digital IC’s and an FPGA. We developed a PCB layout for the PCB board for the metastability detection circuit. Theoretical study and experimental research have confirmed that digital circuits can exhibit metastable behavior when the input to the flip-flop is asynchronous to the system clock. When an asynchronous input violates the setup and hold times of the flip-flop, the resulting metasatble state can cause oscillatory behavior in the output of th...|$|E

