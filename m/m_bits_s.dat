0|615|Public
50|$|There {{are various}} notations used to {{represent}} word length and radix point in a binary fixed-point number. In the following list, f represents the number of fractional <b>bits,</b> <b>m</b> the number of magnitude or integer <b>bits,</b> <b>s</b> the number of sign bits, and b {{the total number of}} bits.|$|R
40|$|A {{method for}} storing a vector of process data {{elements}} (D 1,..., D 8) {{that have a}} size of n bits from a register file (RF) into a memory (M) is described. The memory is arranged for storage of a vector of storage data elements in locations (M 1,..., M 5) having a size of <b>m</b> <b>bits,</b> wherein <b>m</b> 2 ̆ 6 gt;n. The method comprises the steps of: exchanging <b>bits</b> (<b>S</b> 2) between process data elements in the vector stored in mutually subsequent register elements, the exchanging resulting in a vector of modified data elements (DmI,..., Dm 8), shuffling (S 3) groups of k subsequent bits in the resulting vector, [...] storing (S 4) the resulting shuffled vector of modified data elements as a vector of storage data elements in the memory (M) ...|$|R
40|$|Abstract. Let G be an {{embedded}} planar {{undirected graph}} that has n vertices, m edges, and f faces {{but has no}} self-loop or multiple edge. If G is triangulated, we can encode it using 4 <b>m</b> − 1 <b>bits,</b> improving on the best previous bound of about 1. 53 <b>m</b> <b>bits.</b> In case exponential time 3 is acceptable, roughly 1. 08 <b>m</b> <b>bits</b> {{have been known to}} suffice. If G is triconnected, we use at most (2. 5 + 2 log 3) min{n, f} − 7 bits, which is at most 2. 835 <b>m</b> <b>bits</b> and smaller than the best previous bound of 3 <b>m</b> <b>bits.</b> Both of our schemes take O(n) time for encoding and decoding...|$|R
5000|$|Five <b>bits</b> named <b>m.</b> Two of the <b>m</b> <b>bits</b> {{are used}} for {{replacing}} existing escape codes and for specifying {{the length of the}} instruction. The remaining three <b>m</b> <b>bits</b> are reserved for future use, such as specifying vector lengths >256 bits, specifying different instruction lengths, or extending the opcode space, however as of 2013, Intel decided to introduce a new encoding scheme, the EVEX prefix, rather than expand the remaining <b>m</b> <b>bits.</b>|$|R
5000|$|Pn = Head (Xn, M). Select {{the first}} <b>M</b> <b>bits</b> of Xn to create Pn. As {{described}} in step 3, the first <b>M</b> <b>bits</b> of Xn contain Pn. We queue this last (possibly partial) block for eventual output.|$|R
5000|$|Xn = Dn XOR C. Exclusive-OR Dn with C {{to create}} Xn. Looking {{at the first}} <b>M</b> <b>bits,</b> this step has the result of XORing Cn (the first <b>M</b> <b>bits</b> of the {{encryption}} process' En−1) with the (now decrypted) Pn XOR Head (En−1, M) (see steps 4-5 of the encryption process). In other words, we have CBC decrypted the first <b>M</b> <b>bits</b> of Pn. Looking at the last B−M bits, this recovers the last B−M bits of En−1.|$|R
40|$|Let G be an {{embedded}} planar {{undirected graph}} that has n vertices, m edges, and f faces {{but has no}} self-loop or multiple edge. If G is triangulated, we can encode it using 4 / 3 m- 1 bits, improving on the best previous bound of about 1. 53 <b>m</b> <b>bits.</b> In case exponential time is acceptable, roughly 1. 08 <b>m</b> <b>bits</b> {{have been known to}} suffice. If G is triconnected, we use at most (2. 5 + 23) {n,f}- 7 bits, which is at most 2. 835 <b>m</b> <b>bits</b> and smaller than the best previous bound of 3 <b>m</b> <b>bits.</b> Both of our schemes take O(n) time for encoding and decoding...|$|R
5000|$|Pn = Head (Dn, M). Select {{the first}} <b>M</b> <b>bits</b> of Dn to create Pn. As {{described}} in step 3 of the ECB encryption process, the first <b>M</b> <b>bits</b> of Dn contain Pn. We queue this last (possibly partial) block for eventual output.|$|R
25|$|<b>M</b> (<b>bits</b> 0–4) is the {{processor}} mode bits.|$|R
3000|$|With the {{embedding}} approach, {{the smart}} meter needs to send its load profile forecast consisting of <b>m</b> <b>bits</b> {{of data to}} the third party. All |U| utilities need to send |L_u| template load profiles of <b>m</b> <b>bits</b> each, totaling |U||L_u|m bits. For the communication of the best-matching indices (u [...]...|$|R
5000|$|Cn = Head (En−1, M). Select {{the first}} <b>M</b> <b>bits</b> of En−1 to create Cn. The final {{ciphertext}} block, Cn, {{is composed of}} the leading <b>M</b> <b>bits</b> of the second-to-last ciphertext block. In all cases, the last two blocks are sent in a different order than the corresponding plaintext blocks.|$|R
5000|$|Dn = En−1 XOR P. Exclusive-OR En−1 with P {{to create}} Dn. For the first <b>M</b> <b>bits</b> of the block, this is {{equivalent}} to CBC mode; the first <b>M</b> <b>bits</b> of the previous block's ciphertext, En−1,are XORed with the <b>M</b> <b>bits</b> of plaintext of the last plaintext block. The zero padding of P in step 4 was important, because it makes the XOR operation's effect on the last B−M bits equivalent to copying the last B−M bits of En−1 {{to the end of}} Dn. These are the same bits that were stripped off of En−1 in step 3 when Cn was created.|$|R
50|$|The X.25-ness of connections, namely {{datagram}} control, {{was exposed}} to applications (both client and server) as an extra control byte {{at the beginning of}} each read and write through a connection. As was customary in network header processing, this byte was usually accessed at a -1 offset within any application's networking code, only the buffer allocation and the read(2)/write(2) calls were usually aware of it. This byte contained the X.25 M, D, and Q bits (for More, Delivery, and Qualifier). DNET never implemented the D (delivery confirmation) bit, but the other two were useful, particularly the <b>M</b> <b>bit.</b> The <b>M</b> <b>bits</b> were how datagrams were delimited. A byte-stream application could safely ignore them. Any read with a clear <b>M</b> <b>bit</b> indicated that the read result contained an entire datagram and could be safely processed. Reads that were too small to contain an entire datagram would get the part that would fit into the buffer, with the <b>M</b> <b>bit</b> set. <b>M</b> <b>bits</b> would continue to be set on reads until a read contained the end of the original datagram. Datagrams were never packed together, you could get at most one per read. Any write with the <b>M</b> <b>bit</b> set would propagate to the other end with the <b>M</b> <b>bit</b> set, indicating to the other end that it should not process the data yet as it was incomplete. (The network was free to coalesce M'd data at its discretion.) The usual application merely wrote an entire datagram at once with a clear <b>M</b> <b>bit,</b> and was coupled with a small read loop to accumulate entire datagrams before delivery to the rest of an application. (Though not often required due to automatic fragmentation and reassembly within the protocol stack, this protective loop ensured that allowable exposed fragmentation was never harmful.) The Q bit was a simple marker, and could be used to mark 'special' datagrams. In effect it was a single header bit that could be used to mark metadata.|$|R
3000|$|A Bloom filter (BF, for short) is {{a simple}} space-efficient {{randomized}} data structure for representing a set {{in order to support}} membership queries [5]. The BF uses an array of <b>m</b> <b>bits</b> and k independent hash functions for the probabilistic representation of a set of items S = {s_ 1,s_ 2, [...]..., s_n}. Initially all <b>m</b> <b>bits</b> in the array are set to 0.|$|R
5000|$|Two of the <b>m</b> <b>bits</b> for {{replacing}} existing escape codes (0F, 0F 38 and 0F 3A;).|$|R
40|$|We show lower bounds {{that come}} close to our upper bounds (for a large range of n and ffl) : Schemes that answer queries with just one bitprobe and error {{probability}} ffl must use Ω (nffl log(1 =ffl) log <b>m)</b> <b>bits</b> of storage; if the error is restricted to queries not in S, then the scheme must use Ω (n 2 ffl 2 log(n=ffl) log <b>m)</b> <b>bits</b> of storage. We als...|$|R
3000|$|... } is {{a binary}} vector of <b>M</b> <b>bits,</b> where a 1 {{indicates}} the corresponding band is unused and 0 indicates otherwise.|$|R
5000|$|Data Transfer is {{initiated}} with a START <b>bit</b> (<b>S)</b> signaled by SDA {{being pulled}} low while SCL stays high.|$|R
40|$|Abstract: We {{present an}} 8 -bit field {{programmable}} gate array (FPGA) implementation of 128 -bit block and 128 -bit key Advanced Encryption Standard (AES) Rijndael. The 8 -bit Rijndael encryption data path operates at 13. 7 MHz and consumes 226 clock cycles resulting in a throughput of 7. 8 <b>M</b> <b>bits</b> per second. The Rijndael decryption data path operates at 8. 8 MHz and consumes 226 clock cycles resulting in a throughput of 5 <b>M</b> <b>bits</b> per second. 1...|$|R
50|$|Because every non-zero digit {{has to be}} {{adjacent}} to two 0s, the NAF representation can be implemented such that it only takes a maximum of <b>m</b> + 1 <b>bits</b> for a value that would normally be represented in binary with <b>m</b> <b>bits.</b>|$|R
3000|$|Suppose a {{database}} is constituted with <b>M</b> <b>bits</b> × = x 1,...,xM. To be secure, the protocol should satisfy the following properties [13]: [...]...|$|R
40|$|In this paper, we {{consider}} procedures for logic and arithmetic operations with DNA molecules. We first show a DNA representation of n binary numbers of <b>m</b> <b>bits,</b> and propose a procedure to assign {{the same values}} for the representation. The representation enables addressing feature, and the procedure is applicable to n binary numbers of <b>m</b> <b>bits</b> in O(1) steps in parallel. Next, we propose a procedure for logic operations. The procedure enables any boolean operation whose input and output are defined by a truth table, and executes different kinds of boolean operations simultaneously for any pair of n binary numbers of <b>m</b> <b>bits</b> in O(1) lab steps using O(mn) DNA strands. Finally, we propose a procedure for additions of pairs of two binary numbers. The procedure executes O(n) additions of two m-bit binary numbers in O(1) steps using O(mn) DNA strands...|$|R
3000|$|For instance, in Chord [3], {{keys and}} node IDs are encoded over a fixed size of <b>m</b> <b>bits,</b> taking value from 0 to 2 [...]...|$|R
40|$|Tanya Y. Berger-Wolf Edward M. Reingold y October 19, 1998 Abstract We {{consider}} {{the problem of}} communication over multiple channels in which channels can fail and the information sent over those channels is lost. The goal is to recover {{as much of the}} original information as possible while having as little redundancy as possible. We analyze the problem of designing an encoding that minimizes the decoding error in case of channel failure; we give tight lower bounds and an optimal algorithm. 1 Problem Statement Consider sending lg <b>m</b> <b>bits</b> of information over k independent channels. We want to partition the lg <b>m</b> <b>bits</b> into k subsets so that if all k subsets are received, the original information can be completely reconstructed. A trivial solution would be to send k blocks of (lg <b>m)</b> =k <b>bits</b> each; if any block fails to arrive, that part of the information is lost. Alternatively, we could send k complete copies, a total of k lg <b>m</b> <b>bits,</b> so that even if {{all but one of the}} channels f [...] ...|$|R
3000|$|... and {{mapped to}} {{quadrature}} amplitude modulation (QAM) symbols each carrying b= log 2 <b>M</b> <b>bits,</b> where <b>M</b> is the chosen constellation size. The encoding rate [...]...|$|R
50|$|It {{is known}} as fully {{parallel}} processing in which an array on n x <b>m</b> <b>bits</b> is processes at one time. Maximum parallelism is achieved here.|$|R
40|$|Communicated by Editor’s name In this paper, we {{consider}} procedures for logic and arithmetic operations with DNA molecules. We first show a DNA representation of n binary numbers of <b>m</b> <b>bits,</b> and propose a procedure to assign {{the same values}} for the representation. The representation enables addressing feature, and the procedure is applicable to n binary numbers of <b>m</b> <b>bits</b> in O(1) steps in parallel. Next, we propose a procedure for logic operations. The procedure enables any boolean operation whose input and output are defined by a truth table, and executes different kinds of boolean operations simultaneously for any pair of n binary numbers of <b>m</b> <b>bits</b> in O(1) lab steps using O(mn) DNA strands. Finally, we propose a procedure for additions of pairs of two binary numbers. The procedure executes O(n) additions of two m-bit binary numbers in O(1) steps using O(mn) DNA strands...|$|R
3000|$|... =rcode× log 2 <b>M</b> <b>bits</b> per symbol where p= 1,…,P are the {{different}} discrete bit indices available. The bit rate for each spreading sequence {{is represented by}} [...]...|$|R
40|$|Local Area Networks {{are widely}} {{accepted}} and establish on the market. In order to search additional capabilities {{it is desirable}} the interconnection of the existing LANs, which {{can be done by}} a backbone network that spans distances of a broad site, like a university campus or an industrial site with multiple buildings. High Speed Local Area Networks (i. e. FDDI) are suitable for backbone applications. The high cost of HSLAN connections and the existing equipment, will mean that most users will be connected to dominant LANs, Ethernet and Token Ring. However, some users will need to be directly connected to the backbone because they will require high bandwidth and low packets delay for their graphics or imaged-based applications. It will be presented a high performance data communications switch able to act as a HSLAN, in the way that it can offer high bandwidth and low packets delay for high demanding applications. The data communication switch is a modular system, developed with conventional technology, that {{takes the form of a}} card cage supporting a number of modules. The modules communicate by means of a wide band parallel back plane bus. Each module deals with the distributed management of the parallel bus, namely the assignment of the access rights, and with the dialog with the outside world, by means of specific interfaces (Access Processors). An Access Processor for IEEE 802. 3 or Ethernet technology will be described. This Access Processor is able to connect workstations by 10 <b>M</b> <b>bit</b> / <b>s</b> data channels, in a point-to-point star topology. The IEEE 802. 3 Access Processor was designed with filtering and addressing functions in order to perform IEEE 802. 3 or Ethernet Local Area Networks interconnection, without additional communication relays. The interconnection of others LANs or HSLAN s will also be discussed. Particularly, an Access Processor for the FDDI technology will be referred. It will be presented a management architecture, based on the Simple Network Management Protocol, suitable for the referred applications. Finally, it will be presented an evaluation study, by simulation techniques, of the data communication switch. This evaluation study demonstrates that the system presents low packets delay and it is suitable for high demanding applications such as coded video switchingAvailable from Fundacao para a Ciencia e a Tecnologia, Servico de Informacao e Documentacao, Av. D. Carlos I, 126, 1249 - 074 Lisboa, Portugal / FCT - Fundação para o Ciência e a TecnologiaSIGLEPTPortuga...|$|R
3000|$|... <b>m</b> <b>bits.</b> Finally, {{the index}} of the key {{requires}} log 2 |l| bits. Consequently, the bit length of l MACs is l∗(log 2 p+ log 2 m+ log 2 |l|) bits.|$|R
5000|$|... where u is {{a string}} of i uniformly random <b>bits,</b> <b>s</b> is {{a string of}} l uniformly random bits, and y is a string of l+1 uniformly random bits.|$|R
3000|$|With {{frames of}} <b>M</b> <b>bits,</b> BER is the {{bit error rate}} and γ denotes the {{received}} signal-to-noise ratio (SNR). The BER, for noncoherent frequency shift keyed (FSK) transmission, can be expressed as [...]...|$|R
3000|$|The {{following}} program {{builds a}} Bloom filter corresponding to set A. The bit vector V of the Bloom filter has <b>m</b> <b>bits,</b> using k hash functions h 1, h 2, …, hk: [...]...|$|R
5000|$|Floating-point numbers {{provide a}} way to trade off {{signal-to-noise}} ratio {{for an increase in}} dynamic range. For n bit floating-point numbers, with n-m bits in the mantissa and <b>m</b> <b>bits</b> in the exponent: ...|$|R
5000|$|... #Caption: [...] "Full adder" [...] {{logic circuit}} that adds two binary digits, A and B, {{along with a}} carry input Cin, {{producing}} the sum <b>bit,</b> <b>S,</b> and a carry output, Cout.|$|R
3000|$|... and {{mapped to}} symbols using a {{quadrature}} amplitude modulation scheme (QAM) with M constellations to transmit data {{at a rate}} b = log 2 <b>M</b> <b>bits</b> per symbol. The channel encoder rate is [...]...|$|R
