0|2474|Public
40|$|In {{this paper}} we provide an {{overview}} of CPM, a cross-layer framework for Constrained Power Management, and we present its application on a real use case. This framework involves different layers of a typical embedded system, ranging from device drivers to applications. The main goals of CPM are (i) to aggregate applications’ QoS requirements and (ii) to exploit them to support an efficient coordination between different drivers’ local <b>optimization</b> <b>policies.</b> This role is supported by a system-wide and multi-objective <b>optimization</b> <b>policy</b> which could be also changed at run-time. In this paper we mostly focus on a real use case to show the very low overhead of CPM both on the management of QoS requirements and on the tracking of hardware crossdependencies, which cannot be directly considered by local <b>optimization</b> <b>policies...</b>|$|R
50|$|In <b>many</b> <b>optimization</b> problems, one {{seeks to}} {{minimize}} a functional defined on an infinite-dimensional space {{such as a}} Banach space.|$|R
30|$|The {{numerical}} {{resolution of}} a nonlinear programming problem is standard, by gradient methods, penalization, quasi-Newton, dual methods, etc. (see, e.g., [9, 50, 57, 81]). There exist <b>many</b> efficient <b>optimization</b> packages such as IPOPT (see [86]), MUSCOD-II (see [39]), or the Minpack project (see [66]) for <b>many</b> <b>optimization</b> routines.|$|R
2500|$|... 4.11 was {{released}} on 14 August 2013. Kontact and Nepomuk received <b>many</b> <b>optimizations.</b> The first generation Plasma Workspaces entered maintenance-only development mode.|$|R
40|$|Abstract. In {{ubiquitous}} environments, {{the content}} adaptable services can be dynamically provided {{to adapt the}} frequent changes of contexts. These services have common things that the kinds of context factors are limited to ubiquitous environment, though the contexts are flexible. To reuse service architecture can be reasonable for effective adaptable service. In this paper, we propose a reusable architecture with product line techniques for content adaptable applications in ubiquitous environment. It can describe reusable points for service and <b>optimization</b> <b>policies.</b> Description of reusable points is to define variation points and their variants {{and to find out}} the dependencies between them. <b>Optimization</b> <b>policies</b> are to build the variant selection strategies. These can accomplish to define the decision model based on content adaptable service, and to help the reuse more effective. ...|$|R
500|$|In <b>many</b> <b>optimization</b> problems, the {{objective}} functionf is separable: that is, f {{is the sum}} of many summand-functions, each of which has its own argument: ...|$|R
40|$|Genetic {{algorithms}} {{have been}} widely used in <b>many</b> practical <b>optimization</b> problems. Inspired by natural selection, operators, including mutation, crossover and selection, provide effective heuristics for search and black-box optimization. However, they have not been shown useful for deep reinforcement learning, possibly due to the catastrophic consequence of parameter crossovers of neural networks. Here, we present Genetic <b>Policy</b> <b>Optimization</b> (GPO), a new genetic algorithm for sample-efficient deep <b>policy</b> <b>optimization.</b> GPO uses imitation learning for policy crossover in the state space and applies policy gradient methods for mutation. Our experiments on Mujoco tasks show that GPO as a genetic algorithm is able to provide superior performance over the state-of-the-art policy gradient methods and achieves comparable or higher sample efficiency...|$|R
5000|$|In <b>many</b> <b>optimization</b> problems, the {{objective}} function f is separable: that is, f {{is the sum}} of many summand-functions, each of which has its own argument: ...|$|R
40|$|This paper {{presents}} dynamic feedback, {{a technique}} that enables computations to adapt dynamically to different execution environ-ments. A compiler that uses dynamic feedback produces several {{different versions of the}} same source code; each version uses a dif-ferent <b>optimization</b> <b>policy.</b> The generated code alternately performs sampling phases and production phases. Each sampling phase mea-sures the overhead of each version in the current environment. Each production phase uses the version with the least overhead in the pre-vious sampling phase. The computation periodically resamples to adjust dynamically to changes in the environment. We have implemented dynamic feedback {{in the context of a}} par-allelizing compiler for object-based programs. The generated code uses dynamic feedback to automatically choose the best synchro-nization <b>optimization</b> <b>policy.</b> Our experimental results show that the synchronization <b>optimization</b> <b>policy</b> has a significant impact on the overall performance of the computation, that the best policy varies from program to program, that the compiler is unable to stat-ically choose the best policy, and that dynamic feedback enables the generated code to exhibit performance that is comparable to that of code that has been manually tuned to use the best policy. We have also performed a theoretical analysis which provides, under certain assumptions, a guaranteed optimality bound for dynamic feedback relative to a hypothetical (and unrealizable) optimal algorithm that uses the best policy at every point during the execution. ...|$|R
40|$|Abstract. Well-engineered compilers use a {{carefully}} selected set of <b>optimizations,</b> heuristic <b>optimization</b> <b>policies,</b> and a phase ordering. Designing a single optimization heuristic that {{works well with}} other optimization phases is a challenging task. Although compiler designers evaluate heuristics and phase orderings before deployment, compilers typically do not statically evaluate nor refine {{the quality of their}} optimization decisions during a specific compilation. This paper identifies a class of optimizations for which the compiler can statically evaluate the effectiveness of its heuristics and phase interactions. When necessary, it then modifies and reapplies its <b>optimization</b> <b>policies.</b> We call this approach convergent compilation, since it iterates to converge on high quality code. This model incurs additional compilation time to avoid some of the difficulties of predicting phase interactions and perfecting heuristics This work was motivated by the TRIPS architecture which has resourc...|$|R
40|$|More {{and more}} {{parallel}} applications are {{running in a}} distributed environment {{to take advantage of}} easily available and inexpensive commodity resources. For data intensive applications, employing multiple distributed storage resources has many advantages. In this paper, we present a Multi-Storage I/O System (MS-I/O) that can not only effectively manage various distributed storage resources in the system, but also provide novel high performance storage access schemes. MS-I/O employs <b>many</b> state-of-the-art I/O <b>optimizations</b> such as collective I/O, asynchronous I/O etc. and a number of new techniques such as data location, data replication, subfile, superfile and data access history. In addition, <b>many</b> MS-I/O <b>optimization</b> schemes can work simultaneously within a single data access session, greatly improving the performance. Although I/O optimization techniques can help improve performance, it also complicates I/O system. In addition, most optimization techniques have their limitations. Therefore, selecting accurate <b>optimization</b> <b>policies</b> requires expert knowledge which is not suitable for end users who may have little knowledge of I/O techniques. So the task of I/O optimization decision should be left to the I/O system itself, that is, automatic from user’s point of view. We present a User Access Pattern data structure which is associated with each dataset that can help MS-I/O easily make accurate I/O optimization decisions. ...|$|R
50|$|<b>Many</b> <b>optimization</b> {{problems}} are formulated as constrained or unconstrained mathematical programs, either linear programs (LP) or mixed integer programs (MIP), for which many solution techniques and commercial solvers are available.|$|R
5000|$|JIT code {{generally}} offers {{far better}} performance than interpreters. In addition, it can {{in some cases}} offer better performance than static compilation, as <b>many</b> <b>optimizations</b> are only feasible at run-time: ...|$|R
5000|$|... Implementation of Search Engine <b>Optimization</b> (SEO) <b>policies</b> and {{strategies}} and web positioning.|$|R
40|$|This paper aims {{to reduce}} the prebuffering requirements, while {{maintaining}} continuity, for video streaming. Current approaches do this by making use of adaptive media playout (AMP) {{to reduce the}} playout rate. However, this introduces playout distortion to the viewers and increases the viewing latency. We approach this by proposing a frame rate optimization framework that adjusts both the encoder frame generation rate and the decoder playout frame rate. Firstly, we model this problem as the joint adjustment of the encoder frame generation interval and the decoder playout frame interval. This model is used with a discontinuity penalty virtual buffer to track the accumulated difference between the receiving frame interval and the playout frame interval. We then apply Lyapunov optimization to the model to systematically derive a pair of decoupled <b>optimization</b> <b>policies.</b> We show that the occupancy of the discontinuity penalty virtual buffer is correlated to the video discontinuity and that this framework produces a very low playout distortion {{in addition to a}} significant reduction in the prebuffering requirements compared to existing approaches. Secondly, we introduced a delay constraint into the framework by using a delay accumulator virtual buffer. Simulation results show that the the delay constrained framework provides a superior tradeoff between the video quality and the delay introduced compared to the existing approach. Finally, we analyzed the impact of delayed feedback between the receiver and the sender on the <b>optimization</b> <b>policies.</b> We show that the delayed feedbacks have a minimal impact on the <b>optimization</b> <b>policies.</b> I...|$|R
40|$|Dynamic power {{management}} schemes (also called policies) {{can be used}} to control the power consumption levels of electronic systems, by setting their components in different states, each characterized by a performance level and a power consumption. In this paper, we describe power-managed systems using a finite-state, stochastic model. Furthermore, we show that the fundamental problem of finding an optimal policy which maximizes the average performance level of a system, subject to a constraint on the power consumption, can be formulated as a stochastic <b>optimization</b> problem called <b>policy</b> <b>optimization.</b> <b>Policy</b> <b>optimization</b> can be solved exactly in polynomial time (in the number of states of the model). We implemented a <b>policy</b> <b>optimization</b> tool and tested the quality of the optimal policies on a realistic case study. ...|$|R
30|$|From the {{simulation}} results, {{we conclude that}} our approach is able to acquire robust <b>optimization</b> <b>policies</b> for different complex scenarios and maintains a significantly better performance in terms of coverage and capacity with low energy consumption. This especially results in a dramatic improvement in energy efficiency. Finally, RL-FNN converges with an acceptable rate and is therefore applicable to different dynamic scenarios and applications.|$|R
40|$|Abstract. We {{present a}} novel approach, based on {{probabilistic}} for-mal methods, to developing cross-layer resource <b>optimization</b> <b>policies</b> for resource limited distributed systems. One {{objective of this}} approach is to enable system designers to analyze designs in order to study de-sign tradeoffs and predict the possible property violations as the system evolves dynamically over time. Specifically, an executable formal spec-ification is developed for each layer under consideration (for example, application, middleware, operating system). The formal specification is then analyzed using statistical model checking and statistical quantita-tive analysis, to determine the impact of various resource management policies for achieving desired end-to-end QoS properties. We describe how existing statistical approaches have been adapted and improved to provide analyses of given cross-layered <b>optimization</b> <b>policies</b> with quan-tifiable confidence. The ideas are tested in a multi-mode multi-media case study. Experiments from both theoretical analysis and Monte-Carlo simulation followed by statistical analyses demonstrate the applicability of this approach to the design of resource-limited distributed systems...|$|R
50|$|<b>Many</b> <b>optimizations</b> have {{improved}} {{the performance of}} the JVM over time. However, although Java was often the first Virtual machine to implement them successfully, they have often been used in other similar platforms as well.|$|R
50|$|Several {{techniques}} {{exist to}} reduce delay of traffic. Generally the algorithms {{attempt to reduce}} delays (user time), stops, exhaust gas emissions, or some other measure of effectiveness. <b>Many</b> <b>optimization</b> software are geared towards pre-timed coordinated systems.|$|R
3000|$|There are <b>many</b> <b>optimization</b> {{methods for}} {{solving the problem}} (3). After we get the final result of {{representation}} coefficient matrix Z, we can use is {{as a kind of}} similarity to construct an affinity graph (|Z| + |Z [...]...|$|R
50|$|Some retargetable compilers, e.g., GCC, {{become so}} widely ported and {{developed}} {{that they now}} include support for <b>many</b> <b>optimizations</b> and machine specific details {{that the quality of}} code often surpasses that of non-retargetable compilers on many cpus.|$|R
30|$|Basmadjian et al. [5] {{presented}} different prediction {{models for}} power consumption in servers, storage devices and network equipments. For power saving they provided a three step model {{that consisted of}} optimization, reconfiguration and monitoring. The authors claimed that if the energy <b>optimization</b> <b>policy</b> could be guided by power consumption prediction models, then about 20  % energy consumption could be saved for typical single site private cloud data-centers.|$|R
50|$|<b>Many</b> <b>optimization</b> {{problems}} {{involve some}} set of variables and some set of constraints. A problem is called semi-infinite if one (but not both) of these sets is finite. The study of such problems {{is known as}} semi-infinite programming.|$|R
50|$|NextLabs {{provides}} policy-driven information {{risk management}} software that automates security controls and compliance procedures across enterprise business processes. It holds 27 patents in attribute-based <b>policies,</b> <b>policy</b> <b>optimization,</b> and cross-application <b>policy</b> enforcement and analytics.|$|R
5000|$|Ekeland {{explained}} {{the success of}} methods of convex minimization on large problems {{that appeared to be}} non-convex. In <b>many</b> <b>optimization</b> problems, the objective function f are separable, that is, the sum of many summand-functions each with its own argument: ...|$|R
40|$|International audienceThe {{socioeconomic}} {{impact of}} cloud solutions and particularly PaaS (platform as a service) solutions {{is becoming increasingly}} critical. The main objective of PaaS providers is to generate the maximum profit from the services they provide. This requires them to face a number of challenges such as efficiently managing the underlying resources and satisfying the SLAs of the hosted applications. In this paper, we consider a cloud-bursting PaaS environment where the PaaS provider owns some private resources {{and is able to}} rent public cloud resources on demand. In that context, we propose a profit-efficient solution for managing such a system under SLA constraints. We define a profit <b>optimization</b> <b>policy</b> that evaluates the cost of hosting each application using public and private resources and chooses the option that generates the highest profit. During peak periods, the <b>optimization</b> <b>policy</b> considers two more options. The first option is to obtain some resources from running applications, taking into account the payment of penalties if their promised quality of service is affected. The second option is to wait until private resources become available, taking into account the payment of penalties if the quality of service promised to the new application is affected. Furthermore, we designed and implemented an open cloud-bursting PaaS system, called Meryn, which integrates the proposed <b>optimization</b> <b>policy</b> and provides support for batch and MapReduce applications. The results of our evaluation show the effectiveness of our approach in optimizing the provider profit. Indeed, compared to a basic approach, our approach provides up to 11. 59 % and 9. 02 % more provider profit in, respectively, simulations and experiments...|$|R
40|$|Partial {{redundancy}} elimination (PRE) techniques play {{an important}} role in optimizing compilers. <b>Many</b> <b>optimizations,</b> such as elimination of redundant expressions, communication optimizations, and load-reuse optimizations, employ PRE as an underlying technique for improving the efficiency of a program. Classical approache...|$|R
30|$|As {{mentioned}} in Section  1, the (EP) contains <b>many</b> <b>optimization</b> related problems as special cases. Therefore, we derive {{the continuity of}} the results of Section  3 for such special cases. In this section, we give applications to constrained minimization problems and Nash-equilibrium problems.|$|R
40|$|Loops in {{programs}} {{are the source}} of <b>many</b> <b>optimizations</b> leading to performance improvements, particularly on modern high-performance architectures as well as vector and multithreaded systems. Among the optimization techniques, loop peeling is an important technique {{that can be used to}} parallelize computations...|$|R
25|$|<b>Many</b> <b>optimization</b> {{algorithms}} need {{to start}} from a feasible point. One way to obtain such a point is to relax the feasibility conditions using a slack variable; with enough slack, any starting point is feasible. Then, minimize that slack variable until slack is null or negative.|$|R
5000|$|IEEE 802.15.3b-2005 {{amendment}} {{was released on}} May 5, 2006. It enhanced 802.15.3 to improve implementation and interoperability of the MAC. This amendment include <b>many</b> <b>optimizations,</b> corrected errors, clarified ambiguities, and added editorial clarifications while preserving backward compatibility. Among other changes, the amendment defined the following new features: ...|$|R
30|$|In our POMDP model, {{the vehicle}} node {{has to make}} a {{decision}} whenever a slot has elapsed. These instant times are called decision epochs. The optimal <b>optimization</b> <b>policy</b> can be obtained from value iteration algorithms in this formulation. Using the POMDP-derived policy, a channel state is observed according to the information from last slot. Based on the observation, the system jointly considers the number of messages/data blocks selection and relay selection to maximize the system throughput.|$|R
40|$|International audience—Retailers {{are confronted}} to make {{ordering}} decisions {{for a large}} category of products offered to end consumers. In this paper, we extend the classical mono-product News-Vendor Problem to a multi-product News-Vendor Problem with demand transferring and demand substitution. We focus on the joint determination of optimal product assortment and optimal order quantities. Computational algorithms are presented to solve the problem. We compare the global <b>optimization</b> <b>policy</b> with some other policies used in practice by numerical examples...|$|R
50|$|In computing, an {{extended}} basic block {{is a collection}} of basic blocks of the code within a program with certain properties that make them highly amenable to <b>optimizations.</b> <b>Many</b> compiler <b>optimizations</b> operate on extended basic blocks.|$|R
5000|$|<b>Many</b> natural <b>optimization</b> {{problems}} in computational geometry are LP-type: ...|$|R
