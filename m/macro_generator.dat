1|13|Public
40|$|This {{document}} {{explains the}} SUIF <b>Macro</b> <b>Generator</b> (smgn). smgn is a a grammar-based tool that allows to parse an input le {{according to a}} grammar specication. The resulting parse tree can then be easily navigated and manipulated with a specic macro language. Even though smgn has been specically written for the SUIF system, its design is general enough to be useful for the translation of domain specic languages. Furthermore, since smgn is interpretative and easy to grasp, it is well suited for rapid prototyping. Because the macro language is easiest to grasp with concrete examples, we give at least one for every major construct. Strictly speaking, {{the nature of the}} manual is probably rather a mixture of tutorial and reference guide. Please help to improve this manual by sending corrections and omissions to kienle@cs. ucsb. edu. Acknowledgments Thanks {{to the members of the}} SUIF team at Portland Group, Inc. (PGI) and Stanford University for making smgn available|and for making it genera [...] ...|$|E
50|$|The SAM76 {{language}} is a list and string processor designed for interactive and user-directed applications, including artificial intelligence programming, and permits high portability from machine to machine. The language shares certain features in common with LISP, Forth, and shell programming languages of the UNIX operating system.Claude A. R. Kagan, the language's developer, sought to combine within a single interpretive processor, the characteristics of two different string and general-purpose <b>macro</b> <b>generators</b> and the provisions to embed multiple infix operator mathematical systems.|$|R
40|$|This article {{describes}} emerging research into how visual programming languages {{may lead to}} and even require {{the development of new}} software engineering support paradigms. Keywords: visual programming languages, software engineering, end-user programming, end-user software engineering, Forms/ 3. 1. Introduction Visual programming languages (VPLs) are becoming increasingly common in several domains. For example, visual programming languages or sublanguages are becoming the most common way to do some kinds of GUI programming, are becoming the most common way of specifying visualization graphics depicting scientific data, and are also starting to appear as <b>macro</b> <b>generators</b> for end-user applications. However, despite the increase in the use of VPLs for these and other programming tasks, there has been almost no attention to software engineering support mechanisms when working in these languages. Visual programming is programming in whic...|$|R
40|$|This paper {{deals with}} a GaAs data-path {{compiler}} for the public domain ALLIANCE CAD SYSTEM[l]. Based upon <b>macro</b> cells <b>generators,</b> cells libraries, and software tools, it provides a fast and easy way to describe and implement bit-sliced structures for DCFL logic. The use of over cells-routing, power supplies sharing and multiple access termi­nals coupled to a symbolic approach leads to a high density portable layout...|$|R
40|$|A set of {{analog device}} and <b>macro</b> module <b>generators</b> has been {{implemented}} in the GDT environment. The generators are technology and design rules independent and can assist effectively design of analog circuits in BiCMOS and I²L technologies. The design flow starts with a hierarchical schematic, generates automatically all components needed, and performs analog routing followed by a postprocessing. Design of a VCO circuit will be demonstrated as an example...|$|R
50|$|Projects in {{development}} by third parties include on-board and/or computer-side converters, interpreters, code <b>generators,</b> <b>macro</b> assemblers, or compilers for Fortran, other Basic variants, awk, C, Cobol, Rexx, Perl, Python, Tcl, Pascal Delphi, and operating system shells like DOS/Win95 batch, OS/2 batch, WinNT/2000 shell, Unix shells, and DCL.|$|R
50|$|Frame {{technology}} (FT) is a language-neutral (i.e., processes various languages) {{system that}} manufactures custom software from reusable, machine-adaptable building blocks, called frames. FT {{is used to}} reduce the time, effort, and errors involved in the design, construction, and evolution of large, complex software systems. Fundamental to FT {{is its ability to}} stop the proliferation of similar but subtly different components, an issue plaguing software engineering, for which programming language constructs (subroutines, classes, or templates/generics) or add-in techniques such as <b>macros</b> and <b>generators</b> failed to provide a practical, scalable solution.|$|R
40|$|A公司是一家中外合资公司，主要经营小型汽油发电机组的生产和销售。企业在产品、价格、市场份额等方面遇到了极大地挑战。本论文通过对中国国内小型汽油发电机组市场的宏观经济环境、市场竞争格局、营销环境以及A公司基本状况的分析。根据分析结果和A公司的实际情况，对国内小型汽油发电机组目标市场进行市场细分和选择，并有针对性的制定了营销组合策略，涵盖了产品策略、价格策略、渠道策略和促销策略。结果表明：A公司目前有着较大的市场份额，且需求广泛，产品质量好、品牌价值显著，发展前景良好。但也存在着诸多潜在威胁，如流通渠道建设还处在较低的水平，渠道管理亟待提升；国内低价仿制品不仅严重影响公司的声誉和形象，而且在不断侵 [...] . A {{company is}} a {{joint-venture}} company,mainly engaged in the production and sales of small gasoline generator。Enterprise product, price,market share has met great challenges。 This paper through the guests on china's domestic market for small gasoline <b>generator's</b> <b>macro</b> - economic environment and market competition pattern and marketing environment and {{the analysis of the}} basic status of A company and [...] . 学位：工商管理硕士院系专业：管理学院工商管理教育中心（MBA中心）_工商管理硕士(MBA) 学号：X 200515502...|$|R
40|$|TPS is a card-based word {{processor}} {{for use with}} the IBM OS/MVT operating system. TPS commands are imbedded in the free-format text input stream. User defined macros (with arguments) and a report <b>generator</b> <b>macro</b> library, (TPSLIB) provide automated formatting facilities similiar to those available from a competent technical typist. This report is a primer for TPS and TPSLIB; appendices provide detailed reference information and examples. (Author) [URL]...|$|R
50|$|One of {{the worst}} {{scenarios}} {{in the world of}} viruses would be a tool allowing to create a new virus by modifying an existing one.For executable files, it is hard to create this kind of tool. But it is very simple for macro viruses since sources of macros are always available. Based on the same idea of polymorphic macros, a macro can perform modifications to all macros present in the document. Considering this, there is just a few modifications to make to the macro in order to convert it in a macro virus mutator.So it is quite easy to create <b>macro</b> virus <b>generators,</b> so it is possible to create quickly several thousands of the known viruses.|$|R
40|$|Object {{oriented}} databases (OODBs) {{are composed}} of semi-independent objects but must also provide {{for the maintenance of}} inter-object consistency, especially with respect to constraints arising from class hierarchies and inter-object references. Hence the problem to provide consistent generic update methods. We address the problem how to derive such methods from the structure of an OODB schema by the specification of <b>generator</b> <b>macros</b> for them. These generators are based on a strict mathematical formalization of OODB concepts including the possibility to represent syntactic components of the language as values within the language itself, which is known to form the basis of linguistic reflection. Moreover, the approach can be extended to the enforcement of user-defined integrity constraints that give rise to context sensitive macros turning each user-defined method into branches of its greatest consistent specialization...|$|R
40|$|The SAS macro {{language}} is another language layering {{on top of}} regular SAS code. Used properly, it can make programming easier and more fun. While not every program is improved by using macros–adding another syntax to learn and additional debugging challenges – we gain using <b>macros</b> as code <b>generators,</b> saving repetitive and tedious effort, for passing parameters to avoid hard coding, and to pass code fragments, thereby making certain tasks easier than using regular SAS alone. Macros facilitate conditional execution {{and can be used}} as program modules—standardized and re-useable throughout your organization. We will examine macros and macro variables, statements, and functions. We will introduce interaction between macros and regular SAS language, offer tips on debugging, and the SAS macro options. MACROS The Macros consist of collections of regular SAS program statements, macro variables, macro language statements, and macro functions contained within a %MACRO and a %MEND. The %MACRO statement includes a name and the macro is called using the macro’s name preceded by a “%”...|$|R
40|$|We have {{designed}} and implemented a single-chip microcomputer (which we call SCHEME- 79) which directly interprets a typed pointer variant of SCHEME, a dialect {{of the language}} LISP. To support this interpreter the chip implements an automatic storage allocation system for heap-allocated data and an interrupt facility for user interrupt routines implemented in SCHEME. We describe how the machine architecture is tailored to support the language, and the design methodology by which the hardware was synthesized. We develop an interpreter for SCHEME written in LISP which {{may be viewed as}} a microcode specification. This is converted by successive compilation passes into actual hardware structures on the chip. We develop a language embedded in LSIP for describing layout artwork so we can procedurally define <b>generators</b> for generalized <b>macro</b> components. The <b>generators</b> accept parameters to produce the specialized instances used in a particular design. We discuss the performance of the current design and directions for improvement, both in the circuit performance and in the algorithms implemented by the chip. A complete annotated listing of the microcode embodied by the chip is included...|$|R
40|$|Domain-specific {{languages}} (DSLs) are {{of increasing}} importance in scientific high-performance computing to reduce development costs, {{raise the level}} of abstraction and, thus, ease scientific programming. However, designing and implementing DSLs is not an easy task, as it requires knowledge of the application domain and experience in language engineering and compilers. Consequently, many DSLs follow a weak approach using <b>macros</b> or text <b>generators,</b> which lack many of the features that make a DSL a comfortable for programmers. Some of these features [...] -e. g., syntax highlighting, type inference, error reporting, and code completion [...] -are easily provided by language workbenches, which combine language engineering techniques and tools in a common ecosystem. In this paper, we present the Parallel Particle-Mesh Environment (PPME), a DSL and development environment for numerical simulations based on particle methods and hybrid particle-mesh methods. PPME uses the meta programming system (MPS), a projectional language workbench. PPME is the successor of the Parallel Particle-Mesh Language (PPML), a Fortran-based DSL that used conventional implementation strategies. We analyze and compare both languages and demonstrate how the programmer's experience can be improved using static analyses and projectional editing. Furthermore, we present an explicit domain model for particle abstractions and the first formal type system for particle methods. Comment: Submitted to ACM Transactions on Mathematical Software on Dec. 25, 201...|$|R

