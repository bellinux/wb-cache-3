59|6|Public
40|$|WSN, <b>macroprogramming,</b> Python, {{distributed}} systems. PySense aims at bringing wireless sensor (and "internet of things") <b>macroprogramming</b> to {{the audience}} of Python programmers. WSN <b>macroprogramming</b> is an emerging approach where the network {{is seen as a}} whole and the programmer focuses only on the application logic. The PySense runtime environment partitions the code and transmits code snippets to the right nodes finding a balance between energy consumption and computing performances. ...|$|E
40|$|<b>Macroprogramming</b> {{abstract}}ions provide abstract distributeddatastructurestosimplifytheprogrammingofwireless embedded networks. However, none of {{the current}} <b>macroprogramming</b> systems provide debugging support for applicationdevelopment. WehavedevelopedMDB,aGDBlike post-mortem debugger for the MacroLab <b>macroprogramming</b> abstraction. In this demonstration, we show how MDB enables application development and debugging at a single level of abstraction. MDB {{eliminates the need for}} a programmer toreasonabout low-level event tracesandmessage passing protocols, instead allowing debugging in terms of abstract data types. We expect MDB to fill a crucial link inthedevelopmentcycleasamacroprogramprogressesfrom thedrawing board toreal deployment...|$|E
40|$|This {{work was}} partly {{supported}} by the EC FP 7 Connect ProjectInternational audienceSupport for heterogeneity has been incorporated within a <b>Macroprogramming</b> framework. Policies for handling runtime and data routing for communication between nodes in a heterogeneous network were designed and implemented. Then, <b>Macroprogramming</b> support was added to compile Macroprograms and generate code for the heterogeneous network...|$|E
30|$|As {{outlined}} above, existing macroprogramming-based DSMSs {{follow a}} static approach where the <b>macroprograms</b> are compiled into microprograms that are deployed once for all. Specific techniques {{can be used}} to dynamically update the network: (i) dynamic reconfiguration and (ii) dynamic deployment. However, the former techniques usually assume that the tasks are already implemented on the devices [37], while the latter techniques usually support binary deployment (e.g., Deluge [16]). Instead, a DSMS for the WoT must provide a high-level of dynamicity by making possible to change both the global and the local behaviors of the network at any time. To this end, the developers should be provided a way to represent WoT applications as abstract programs that are distributed dynamically in the actual network. In addition, sandboxes should be used to increase the overall reliability, as an attacker can benefit from arbitrary binary deployment to deploy malicious code on any open device.|$|R
40|$|ABSTRACT: Scheduling of {{construction}} projects that have multiple units, wherein activities repeat from one unit to another, always represent {{a major challenge}} to project managers. These projects require schedules that ensure the uninterrupted usage of resources from an activity in one unit to the similar activity in the next unit and maintaining logic constraints at the same time. The scheduling method {{presented in this paper}} considers both logic and resource continuity constraints. The method utilizes the critical path method network of a single unit. Start-to-start and finish-to-finish relationships are used. Constant activity production rate is assumed. The proposed approach determines the controlling path (logically and resource critical units) in a simplified way. To automate the proposed algorithm, a <b>macroprogram</b> has been written on commercial scheduling software. Details of the model development and implementation are described, and an example application is presented to validate the proposed approach. The advantages, limitations, and future extensions of the proposed approach are then discussed...|$|R
40|$|This diploma thesis {{deals with}} {{usability}} of the SAS {{system and its}} components for building and running data warehouse and complete solution of Business Intelligence. In the beginning it introduces the meaning and benefits of putting on Business Intelligence and its spot in an organization. It especially focuses on the running BI project in Kooperativa, a. s., insurance company. The main goal of this thesis is to aim on ETL processes of data warehouse, their specificity, characteristics and regular tasks solved across data layers, measuring their performance and feasibility of ETL optimalization. This optimalization can be considered from two {{different points of view}} – the first is a creation and maintenance of the ETL source code, the second is tuning for faster data processing. Log files, which are are the main source for performance monitoring, are processed by <b>macroprogram</b> specially tailored to this particular reason. Gained results are analyzed and on that basis I outline spots that need attention. The last part offers comparison of some alternatives to data transformation process typically solved by ETL tasks. Acquired results could be taken as hints used in designing and tweaking other akin ETL processes...|$|R
40|$|In this paper, {{we present}} COSMOS, a novel {{architecture}} for <b>macroprogramming</b> heterogeneous sensor network systems. <b>Macroprogramming</b> entails aggregate system behavior specification, {{as opposed to}} device-specific applications that indirectly express distributed behavior through explicit messaging between nodes. COS-MOS is comprised of a <b>macroprogramming</b> language, mPL, and an operating system, mOS. mPL macroprograms specify distributed system behavior using statically verifiable compositions of reusable user-provided, or system supported functional components. mOS provides component management and a lean execution environment for mPL in heterogeneous resource-constrained sensor networks. COSMOS facilitates composition of complex real-world applications that are robust, scalable and adaptive in dynamic datadriven sensor network environments. The mOS architecture allows runtime application instantiation, with over-the-air reprogramming of the network. An important and novel aspect of COSMOS {{is the ability to}} easily extend its component basis library to add rich <b>macroprogramming</b> abstractions to mPL, tailored to domain and resource constraints, without modifications to the OS. A fully functional version of COSMOS is currently in use at the Bowen Labs for Structural Engineering, at Purdue University, for highfidelity structural dynamics measurements. We present comprehensive experimental evaluation using macro- and micro- benchmarks to demonstrate performance characteristics of COSMOS. 1...|$|E
40|$|International audienceThough several {{high-level}} {{application development}} (<b>macroprogramming)</b> approaches {{have been proposed}} in literature for wireless sensor networks (WSN), {{there is a need}} to enable support for expressing and supporting end-to-end non-functional constraints such as latency in WSN macroprograms. We augment an existing <b>macroprogramming</b> language and its compilation process to enable the specification of end-to-end requirements, and propose task mapping algorithms to satisfy those requirements through a constraint programming approach. Through evaluations on realistic application task graphs, we show that our constraint programming model can effectively capture the end-to-end requirements and efficiently solves the combinatorial problem introduced...|$|E
40|$|UnrestrictedWireless Sensor Networks (WSNs) {{are rapidly}} {{emerging}} as {{a new class of}} distributed pervasive systems, with applications in a diverse range of domains such as traffic management, building environment management, target tracking, etc. Most, if not all, WSN application design is currently performed at the node-level, with developers manually customizing various protocols to realize their applications. This makes it difficult for the typical domain-expert application developer (e. g., a building system designer) to develop applications for them, and is a hindrance to their wide acceptance. To address this problem, the field of <b>macroprogramming</b> has emerged, which aims to provide high-level programming abstractions to assist in application development for WSNs. Although several <b>macroprogramming</b> approaches have been studied, the area of compilation of these macroprograms to node-level code is still largely unexplored.; This thesis addresses the issues involved in the compilation of sensor network macroprograms. The emphasis is on data-driven <b>macroprogramming,</b> where the application is represented as a set of tasks running on the system's nodes [...] producing, processing and acting on data items or streams to achieve the system's goals. In addition to a modular framework for the overall compilation process, formal models for the task-mapping problem which arises in this context are discussed. Results from optimal result-producing mixed-integer programming techniques and algorithmic heuristics for the above problem are presented. We also present the design and implementation of a graphical toolkit for sensor network <b>macroprogramming...</b>|$|E
40|$|The aims of {{this project}} are twofold. They are firstly, to {{implement}} a microprogram development system that allows the programmer to write microcode for any microprogrammable machine, and secondly, to build a microprogrammable machine, incorporating the user friendliness of a simulator, while still providing the 'hands on' experience obtained actual hardware. Microprogram development involves a two stage process. The {{first step is to}} describe the target machine, using format descriptions and mnemonic-based template definitions. The second stage involves using the defined mnemonics to write the microcodes for the target machine. This includes an assembly phase to translate the mnemonics into the binary microinstructions. Three main components constitute the microprogrammable machine. The Arithmetic and Logic Unit (ALU) is built using chips from Advanced Micro Devices' Am 29 ØØ bit-slice family, the action of the Microprogram Control Unit (MCU) is simulated by software running on an IBM Personal Computer, and a section of the IBM PC's main memory acts as the Control Store (CS) for the system. The ALU is built on a prototyping card that plugs into one of the slots on the IBM PC's mother board. A hardware simulator program, that produces the effect of the ALU, has also been developed. A small assembly language has been developed using the system, to test the various functions of the system. A mini-assembler has also been written to facilitate assembly of the above language. A group of honours students at Rhodes University tested the microprogram development system. Their ideas and suggestions have been tabulated in this report and some of them have been used to enhance the system's performance. The concept of allowing 'inline' microinstructions in the <b>macroprogram</b> is also investigated in this report and a method of implementing this is shown...|$|R
40|$|Aiming {{to achieve}} the ideal time of ovum pick-up (OPU) for in vitro embryo {{production}} (IVP) in crossbred heifers, two Latin square design studies investigated the effect of ovarian follicular wave synchronization with estradiol benzoate (EB) and progestins. For each experiment, crossbred heifers stage of estrous cycle was synchronized either with a norgestomet ear implant (Experiment 1) or a progesterone intravaginal device (Experiment 2) for 7 d, followed by the administration of 150 mu g D-cloprostenol. On Day 7, all follicles > 3 mm in diameter were aspirated and implants/devices were replaced by new ones. Afterwards, implant/device replacement was conducted every 14 d. Each experiment had three treatment groups. In Experiment I (n = 12), heifers in Group 2 X had their follicles aspirated twice a week and those in Groups 1 X and 1 X-EB were submitted to OPU {{once a week for}} a period of 28 d. Heifers from Group 1 X-EB also received 2 mg EB i. m. immediately after each OPU session. In Experiment 2 (n = 11), animals from Group 0 EB did not receive EB while heifers in Groups 2 EB and 5 EB received 2 and 5 mg of EB respectively, immediately after OPU. The OPU sessions were performed once weekly for 28 d. Therefore, in both experiments, four OPU sessions were performed in heifers aspirated once a week and in Experiment 1, eight OPU sessions were done in heifers aspirated twice a week. Additionally, during the 7 -d period following follicular aspiration, ovarian ultrasonography examinations were conducted to measure diameter of the largest follicle and blood samples were collected for FSH quantification by RIA. In Experiment 1, all viable oocytes recovered were in vitro matured and fertilized. Results indicated that while progestin and EB altered follicular wave patterns, this treatment did not prevent establishment of follicular dominance on the ovaries of heifers during OPU at 7 -d intervals. Furthermore, the proposed stage of follicular wave synchronization strategies did not improve the number and quality of the recovered oocytes, or the number of in vitro produced embryos. (C) 2009 Elsevier B. V. All rights reserved. Embrapa - <b>Macroprogram</b> IICNPq[141077 / 2004 - 2...|$|R
40|$|Pyricularia oryzae is {{a species}} complex that causes blast disease {{on more than}} 50 species of poaceous plants. Pyricularia oryzae has a {{worldwide}} distribution as a rice pathogen {{and in the last}} 30 years emerged as an important wheat pathogen in southern Brazil. We conducted phylogenetic analyses using 10 housekeeping loci for 128 isolates of P. oryzae sampled from sympatric populations of wheat, rice, and grasses growing in or near wheat fields. Phylogenetic analyses grouped the isolates into three major clades. Clade 1 comprised isolates associated only with rice and corresponds to the previously described rice blast pathogen P. oryzae pathotype Oryza (PoO). Clade 2 comprised isolates associated almost exclusively with wheat and corresponds to the previously described wheat blast pathogen P. oryzae pathotype Triticum (PoT). Clade 3 contained isolates obtained from wheat as well as other Poaceae hosts. We found that Clade 3 is distinct from P. oryzae and represents a new species, Pyricularia graminis-tritici (Pgt). No morphological differences were observed among these species, but a distinctive pathogenicity spectrum was observed. Pgt and PoT were pathogenic and highly aggressive on Triticum aestivum (wheat), Hordeum vulgare (barley), Urochloa brizantha (signal grass), and Avena sativa (oats). PoO was highly virulent on the original rice host (Oryza sativa), and also on wheat, barley, and oats, but not on signal grass. We conclude that blast disease on wheat and its associated Poaceae hosts in Brazil is caused by multiple Pyricularia species. Pyricularia graminis-tritici was recently found causing wheat blast in Bangladesh. This indicates that P. graminis-tritici represents a serious threat to wheat cultivation globally. This work was funded by FAPESP (São Paulo Research Foundation, Brazil) research grants to P. C. Ceresini (2013 / 10655 - 4 and 2015 / 10453 - 8), EMBRAPA/Monsanto research grant (<b>Macroprogram</b> II) to J. L. N. Maciel, and research grants from FINEP (Funding Authority for Studies and Projects, Brazil) and FAPEMIG (Minas Gerais Research Foundation, Brazil) to E. Alves (CAG-APQ- 01975 - 5). P. C. Ceresini and E. Alves were supported by research fellowships from Brazilian National Council for Scientific and Technological Development - CNPq (Pq- 2 307361 / 2012 - 8 and 307295 / 2015 - 0). S. I. Moreira was supported by Doctorate research fellowship from CAPES (Higher Education Personnel Improvement Coordination, Brazil). V. L. Castroagudin was supported by Post-Doctorate research fellowships from CNPq (PDJ 150490 / 2013 - 5, from 2012 – 2014), and FAPESP/CAPES (PDJ 2014 / 25904 - 2, from 2015 – 2016). We thank CAPES for sponsoring the establishment of the ‘Centro de Diversidade Genética no Agroecossistema’ (Pro-equipamentos 775202 / 2012). www. ingentaconnect. com/content/nhn/pimjam 2017 Microbiology and Plant Patholog...|$|R
40|$|Wireless sensor {{networks}} are increasingly employed to develop sophisticated applications beyond simple data gathering. In these scenarios, heterogeneous nodes are deployed, and multiple parallel activities must be performed {{to achieve the}} application goals. Therefore, application developers require the ability to partition the system based on the node characteristics, and specify the interactions between different partitions to implement the processing germane to different activities. Node-level programming abstractions for sensor networks have already tackled this problem by providing a notion of scoping. However, the level of abstraction achieved is still not suited to implementing non-trivial, large-scale applications. In this paper we demonstrate how the aforementioned issue can be addressed by enabling scoping concepts in <b>macroprogramming</b> for sensor networks. Using <b>macroprogramming,</b> developers reason {{at a higher level}} of abstraction, focusing on the behavior to be achieved by the system as a whole. By enabling scoping in <b>macroprogramming,</b> they can capture the essence of a significant class of distributed, embedded applications in a very concise manner. This extremely simplifies the development process, and increases the maintainability and re-usability of the resulting implementations. ...|$|E
40|$|Abstract. Macroprogramming—the {{technique}} of specifying {{the behavior of}} the system, as opposed to the constituent nodes—provides application developers with high level abstractions that alleviate the programming burden in develop- ing wireless sensor network (WSN) applications. However, as the semantic gap between <b>macroprogramming</b> abstractions and node-level code is considerably wider than in traditional programming, converting the high level specification to running code is a daunting process, and a major hurdle to the acceptance of <b>macroprogramming.</b> In this paper, we propose a general compilation framework for a data-driven <b>macroprogramming</b> language that allows for plugging in different modules implementing various stages of compilation. We also demonstrate an actual instantiation of our framework by showing an end-to-end solution for compiling macro- programs. Our compiler provides the final code to be deployed on real nodes as well as an estimate of the costs the running system will incur, e. g., in terms of messages exchanged. We compared the auto-generated code against a hand- coded version for the same application behavior to verify the outcome of our compiler...|$|E
40|$|<b>Macroprogramming</b> is an {{application}} development technique for {{wireless sensor networks}} (WSNs) where the developer specifies {{the behavior of the}} system, as opposed to that of the constituent nodes. In this proposed demonstration, we would like to present Srijan, a toolkit that enables application development for WSNs in a graphical manner using data-driven <b>macroprogramming.</b> It can be used in various stages of application development, viz. i) specification of application as a task graph, ii) customization of the autogenerated source files with domain-specific imperative code, iii) specification of the target system structure, iv) compilation of the macroprogram into individual customized runtimes for each constituent node of the target system, and finally v) deployment of the auto generated node-level cod...|$|E
40|$|This paper {{presents}} market-based <b>macroprogramming</b> (MBM), a {{new paradigm}} for achieving globally efficient behavior in sensor networks. Rather than programming the individual, low-level behaviors of sensor nodes, MBM defines a virtual market where nodes sell "actions" (such as taking a sensor reading or aggregating data) in response to global price information. Nodes take actions to maximize their own utility, subject to energy budget constraints. The behavior of the network is determined by adjusting the price vectors for each action, rather than by directly specifying local node actions, resulting in a globally efficient allocation of network resources. We present the market-based <b>macroprogramming</b> paradigm, {{as well as several}} experiments demonstrating its value for a sensor network vehicle tracking application...|$|E
40|$|Data-driven <b>macroprogramming</b> of {{wireless}} sensor networks (WSNs) provides an easy to use high-level task graph representation to the application developer. However, determining an energy-efficient initial placement of these tasks onto the nodes of the target network poses a set of interesting problems. We present a framework to model this task-mapping problem arising in WSN <b>macroprogramming.</b> Our model can capture placement constraints in tasks, as well as multiple possible routes in the target network. Using our framework, we provide mathematical formulations for the task-mapping problem for two different metrics — energy balance and total energy spent. For both metrics, we address scenarios where a) a single or b) multiple paths are possible between nodes. Due to the complex nature of the problems, these formulations are not linear. We provide linearization heuristics for the same, resulting in mixed-integer programming (MIP) formulations. We also provide efficient heuristics for the above. Our experiments show that our heuristics give the same results as the MIP for real-world sensor network macroprograms, and show a speedup of up to several orders of magnitude. We also provide worst-case performance bounds of the heuristics. Index Terms—Sensor Networks, Task-Mapping, <b>Macroprogramming.</b> I...|$|E
40|$|Regardless of the {{application}} domain and deployment scope, the ability to retrieve information {{is critical to the}} successful functioning of any wireless sensor network (WSN) system. In general, information extraction procedures can be categorized into three main approaches: agent-based, query-based and <b>macroprogramming.</b> Of the three, query-based systems are the most popular mainly because they provide a usable, high level interface to the sensor network while abstracting away some of the low level details like the network topology and radio communication. In contrast, <b>macroprogramming</b> provides a more general-purpose approach to distributed computation compared to traditional query-based approaches and focus on programming the network as a whole rather than programming the individual devices that form the network. The agent-based approach tailors the information extraction mechanism to the type of information needed and the configuration of the network it needs to be extracted from. This report surveys extensively the literature in the area of WSN information extraction, highlights the benefits of in-network processing and proposes a novel hybrid approach that incorporates query and <b>macroprogramming</b> techniques for information extraction in large-scale, informational systems. The feasibility of the approach is demonstrated through simulation. This is an interim report of work covered {{in the first year of}} the PhD program entitled as above...|$|E
40|$|Abstract — There {{is growing}} {{interest}} in the networked sensing community in the technique of <b>macroprogramming,</b> where the end-user can design a system using a high level description without worrying about the node-level details. Since the burden of customizing the code to the target architecture is moved to the compiler that translates the high-level description to generate node-level codes, research on the issues involved in compilation of such a program assumes importance. In this paper, we list some issues {{that need to be}} resolved by the designers of a compiler for such a <b>macroprogramming</b> framework, including the decisions {{to be made in the}} choice of an abstraction, the design of the runtime system and the generating of the code for each node. We discuss some solution techniques that we are currently exploring to solve the above problems. I...|$|E
40|$|Translation of a macroprogram to node-level microprograms is {{a complex}} and {{challenging}} task for a compiler. Developing of a robust <b>macroprogramming</b> compiler framework poses a unique challenge because users need to create optimized function decompositions, in a modular way, such {{that they can be}} composed with other compiler functionality such as optimization and debugging. This differs from most compilers because they typically employ a fixed set of code optimizations for a particular target platform. We present a <b>macroprogramming</b> compiler for MacroLab which has a modular architecture that provides users with a two layer interface: one to tackle user created optimized function decompositions and another to handle low-level compiler modifications. Our results show that the introduction of new decompositions and compiler optimizations can be accomplished with a small number of lines of code and typically written in a matter of hours. Categories andSubjectDescriptor...|$|E
40|$|International audienceOwing to {{the large}} scale of {{networked}} sensor systems, ease of program- ming remains a hurdle in their wide acceptance. High-level application development techniques, or <b>macroprogramming</b> provides an easy to use high-level representation to the application developer, who can focus on specifying {{the behavior of the}} system, as opposed to the constituent nodes of the wireless sensor network (WSN). This chapter provides an overview of the current approaches to high-level appli- cation design for WSNs, going into the details related to data-driven macroprogram- ming. Details of one such language are provided, in addition to the approach taken to the compilation of data-driven macroprograms to node-level code. An implemen- tation of the modular compilation framework is also discussed, as well as a graphical toolkit built around it that supports data-driven <b>macroprogramming.</b> Through exper- iments, it is shown that the code generated by the compiler matches hand-generated implementations of the applications, while drastically reducing the time and effort involved in developing real-world WSN applications...|$|E
40|$|Over {{the past}} years of {{research}} in Wireless Sensor Networks (WSNs), both the hardware used to construct WSNs and the languages used to describe their functionality have evolved. The Sun Small Programmable Object Technology (Sun SPOT) nodes are the latest offering in the former domain, with a Java virtual machine running on the metal. On the programming side, <b>macroprogramming</b> frameworks such as the Abstract Task Graph (ATaG) have been developed that aim to greatly reduce {{the burden of the}} application developer {{for a wide range of}} WSN applications. In this work, we present an end-to-end solution for <b>macroprogramming</b> WSN applications on Sun SPOT nodes using ATaG- a data-driven programming paradigm. We will demonstrate all the stages starting from the specification of the application to its compilation and deployment on actual sensor nodes, thus showcasing the power of our toolchain. We believe that our research will enable wide adoption of WSNs among a range of end-users who will now have a concrete end-to-end toolkit to develop WSN applications. ...|$|E
40|$|Abstract Owing to {{the large}} scale of {{networked}} sensor systems, ease of program-ming remains a hurdle in their wide acceptance. High-level application development techniques, or <b>macroprogramming</b> provides an easy to use high-level representation to the application developer, who can focus on specifying {{the behavior of the}} system, as opposed to the constituent nodes of the wireless sensor network (WSN). This chapter provides an overview of the current approaches to high-level appli-cation design for WSNs, going into the details related to data-driven macroprogram-ming. Details of one such language are provided, in addition to the approach taken to the compilation of data-driven macroprograms to node-level code. An implemen-tation of the modular compilation framework is also discussed, as well as a graphical toolkit built around it that supports data-driven <b>macroprogramming.</b> Through exper-iments, it is shown that the code generated by the compiler matches hand-generated implementations of the applications, while drastically reducing the time and effort involved in developing real-world WSN applications. ...|$|E
40|$|Abstract. Data-driven <b>macroprogramming</b> of {{wireless}} sensor networks (WSNs) provides an easy to use high-level task graph representation to the application developer. However, determining an energy-efficient initial placement of these tasks onto the nodes of the target network poses a set of interesting problems. We present a framework to model this task-mapping problem arising in WSN <b>macroprogramming.</b> Our model can capture task placement constraints, and supports easy specification of energy-based optimization goals. Using our framework, we provide mathematical formulations for the task-mapping problem for two different metrics — energy balance and total energy spent. Due to the complex nature of the problems, these formulations are not linear. We provide linearization heuristics for the same, resulting in mixed-integer programming (MIP) formulations. We also provide efficient heuristics for the above. Our experiments show that the our heuristics give the same results as the MIP for real-world sensor network macroprograms, and show a speedup of up to several orders of magnitude. ...|$|E
40|$|Regardless of the {{application}} domain and deployment scope, the ability to retrieve information {{is critical to the}} successful functioning of any wireless sensor network (WSN) system. In general, information extraction procedures can be categorized into three main approaches: agent-based, query-based and <b>macroprogramming</b> led. Whilst query-based systems are the most popular, <b>macroprogramming</b> techniques provide a more general-purpose approach to distributed computation. Finally, the agent-based approaches tailor the information extraction mechanism to the type of information needed and the configuration of the network it needs to be extracted from. This suite of three papers (Part I-III) offers an extensive survey of the literature in the area of WSN information extraction, covering in Part I and Part II the three main approaches above. Part III highlights the open research questions and issues faced by deployable WSN system designers and discusses the potential benefits of both in-network processing and complex querying for large scale wireless informational systems...|$|E
40|$|License, which permits {{unrestricted}} use, distribution, {{and reproduction}} in any medium, provided the original work is properly cited. Wireless Networks of Embedded Systems (WNES) are notoriously difficult and tedious to program. The difficulty is mostly originated from low-level details in system and network programming. This includes distributedly managing and accessing resources from a dynamic set of nodes in hostile and volatile networks. To simplify WNES programming, we propose Declarative Resource Naming (DRN) that abstracts out the mentioned low-level details by programming a WNES {{in the large}} (i. e., <b>macroprogramming).</b> DRN provides programming simplicity, expressiveness, tunability, on-the-fly reprogrammability, and in-network data aggregation for energy savings. None of existing <b>macroprogramming</b> paradigms supports all of the mentioned features. Furthermore, DRN is an integration of declarative and imperative programming. The low-level details are declaratively abstracted out, but the main algorithm remains procedural. This allows programming simplicity without an adverse impact on the expressiveness. We have implemented and evaluated DRN on two platforms: Smart Message and Maté. Our result indicates that DRN enables programmers to develop energy-efficient applications with the desired flexibility and quality. 1...|$|E
40|$|Recent prototypical {{systems have}} {{demonstrated}} applications of {{wireless sensor networks}} in diverse sensing and data processing domains. As applications of sensor networks mature, there is an increasing realization of the complexity associated with programming large numbers of resource and energy constrained heterogeneous devices that operate cooperatively in highly dynamic environments. In this thesis, we investigate sensor network macroprogramming: a novel high-level programming model that entails specification of aggregate distributed system behavior. Our <b>macroprogramming</b> architecture facilitates development of self-organized sensor network systems that are scalable, energy-efficient, and verifiable. This model {{is in contrast to}} {{the state of the art}} that involves programming of low-level behavior of individual nodes, which is a non-trivial, effort-intensive, and error-prone task. ^ We undertake a comprehensive study to address fundamental challenges in macro-programming sensor networks. Specifically, we make the following contributions towards realization of a comprehensive <b>macroprogramming</b> infrastructure. First, we present a high-level programming model and associated infrastructure, COSMOS, which allows explicit specification of distributed coordinated behavior in contrast to the traditional model of programming individual nodes. We present a lean operating system that supports COSMOS applications, and features support for scalable distributed data flow based programs. Second, we examine the complexity of developing applications that adaptively manage resource tradeoffs under constraints, and argue that such applications require static behavioral verification. To this end we propose a high-level logic language and an associated synthesis engine that verifies user programs and generates robust applications. Third, we present a compiler for sensor network applications that generates energy-efficient and low messaging cost primitives from specifications of complex distributed sensornet protocols. Finally, we present an in-network data compression protocol that enables application independent high-resolution sensor monitoring while minimizing the energy footprint. We support claims of efficiency and effectiveness of our <b>macroprogramming</b> infrastructure with experiences from a real-world deployment of our system and comprehensive empirical evaluation. ...|$|E
30|$|Another related {{field is}} <b>macroprogramming</b> of sensor {{networks}} [25 – 28]. For example, in [25] the authors provide an SQL-like interface where the entire network is abstracted as a relational database (table). Contrary to their approach, we utilize more general set theory to define operations on our IntentScopes. This gives more flexibility to developers, since SDG-Pro also allows dynamic, custom properties {{to be included}} in scope definitions, but comes at the cost of additional performance overhead.|$|E
40|$|We present our ongoing work on {{the design}} of <b>macroprogramming</b> abstractions to program sensing and {{actuating}} applications using robot swarms. Robots can sample the environment and act on it where no other sensor can reach, e. g., to monitor the environment at altitude with aerial robots. Programming the individual behavior of multiple coordinating robots is difficult. We design LiftOff, a <b>macroprogramming</b> abstraction that allows to program robot swarms collectively, by creating the illusion of a single computing device that occupies the entire physical space of interest. We achieve this by giving variables and values in a programming language a spatial semantics. In LiftOff, values may be associated to a location, and programmers use the same variable to access different values at different locations, sparing the need to manually create a mapping from variables to spatial values. LiftOff applications execute synchronously or based on lazy evaluation. The former allows precise program analysis, e. g., using model checking, whilst the latter potentially executes faster. In this paper, we report on LiftOff’s initial design and prototypes. Categories and Subject Descriptors [Software and its engineering]: General programming languagesVery high level languages; [Computer systems organization]: Embedded and cyber-physical system...|$|E
40|$|International audienceData-driven <b>macroprogramming</b> of {{wireless}} sensor networks (WSNs) provides an easy to use high-level task graph representation to the application developer. However, determining an energy-efficient initial placement of these tasks onto the nodes of the target network poses a set of interesting problems. We present a framework to model this task-mapping problem arising in WSN <b>macroprogramming.</b> Our model can capture placement constraints in tasks, as well as multiple possible routes in the target network. Using our framework, we provide mathematical formulations for the task-mapping problem for two different metrics [...] energy balance and total energy spent. For both metrics, we address scenarios where a) a single or b) multiple paths are possible between nodes. Due to the complex nature of the problems, these formulations are not linear. We provide linearization heuristics for the same, resulting in mixed-integer programming (MIP) formulations. We also provide efficient heuristics for the above. Our experiments show that our heuristics give the same results as the MIP for real-world sensor network macroprograms, and show a speedup of up to several orders of magnitude. We also provide worst-case performance bounds of the heuristics...|$|E
40|$|Sensor network <b>macro{{programming}}</b> {{systems like}} Kairos can greatly simplify programming a distributed sensor network application by expressing it as a centralized sequential computation on shared node state. However, the accuracy and timely {{availability of the}} results can be adversely affected by software, node hardware, and network failures. Ideally, a <b>macroprogramming</b> system should relieve the programmer from having to explicitly handle such failures by providing high-level facilities for failure recovery. In this paper, we show that there exist generic techniques that can recover sensor network computations from various classes of failures. We then evaluate the efficacy of two recovery invocation strategies: directed recovery, in which Kairos invokes a declaratively-specified generic recovery method; and transparent recovery in which Kairos itself invokes an appropriate recovery method at a suitable point in the macroprogram, without programmer assistance. We evaluate these techniques on the primary metrics of application accuracy and availability against three qualitatively different sensor network applications, written in Kairos, running on a 36 -node test-bed. Our main result is that transparent recovery can ensure worst-case correctness of the recovered application to within 40 % of that of the non-faulting application across a wide range and severity of software and hardware faults, and can improve an application's availability in the presence of faults by a factor of up to 2. 75...|$|E
40|$|Programming {{wireless}} sensor networks is a major challenge, {{even for}} experienced programmers. To alleviate this problem, prior work has proposed a paradigm shift from node-level microprogramming to <b>macroprogramming,</b> where the user specifies a distributed ap-plication using a single macroprogram that is automatically trans-lated into a set of node-level microprograms. This paper makes the case that node-level microprogramming itself can be made much easier by using the right set of programming abstractions. To sup-port this claim, this paper presents µSETL, a programming abstrac-tion for sensor networks based on set theory. Sets offer a power-ful formalism and high expressiveness, yet are a natural way o...|$|E
40|$|Wireless Sensor Networks (WSNs) {{are a key}} {{enabling}} technology for Ambient Intelligence. <b>Macroprogramming</b> has been proposed as a technique for facilitating programming WSNs, but current solutions do not provide the combination of dynamicity and query specification that {{would be useful to}} domain experts. We have implemented the first query engine which provides both these features. Our system leverages AI methods such as multiagent systems and sophisticated meta-level knowledge representation techniques {{to keep track of the}} domain knowledge and to enable adaptation in query processing. Such adaptations include dynamic representations, transformations, optimizations and deployment strategies translating queries into a system of automatically generated mobile actors in a WSN...|$|E
40|$|Wireless sensor {{networks}} research has, till date, made impressive {{advances in}} platforms and software services. Research {{in the area}} has moved on to consider an essential piece of sensor network technology—support for programming wireless sensor network applications and systems components at a suitably high level of abstraction. Two broad classes of programming models are currently being investigated by the community. One class focuses on providing higher-level abstractions for specifying a node's local behavior in a distributed computation. Examples of this approach include the recent work on node-local or region-based abstractions. By contrast, a second and less-explored class of research considers programming a sensor network in the large called <b>macroprogramming...</b>|$|E
40|$|We {{present a}} <b>macroprogramming</b> {{framework}} called Macro-Lab {{that offers a}} vector programming abstraction similar to Matlab for Cyber-Physical Systems (CPSs). The user writes a single program for the entire network using Matlab-like operations such as addition, find, and max. The framework executes these operations across the network in a distributed fashion, a centralized fashion, or something between the two – whichever is most efficient for the target deployment. We call this approach deployment-specific code decomposition (DSCD). MacroLab programs can be executed on mote-class hardware such as the Telos [24] motes. Our results indicate that MacroLab introduces almost no additional overhead in terms of message cost, power consumption, memory footprint, or CPU cycles over TinyOS programs. Categories andSubjectDescriptors C. 3 [Special-Purpose and Application-Based Systems]...|$|E
40|$|Programming Wireless Networks of Embedded Systems (WNES) is {{notoriously}} difficult and tedious. To simplify WNES programming, we propose Declarative Resource Naming (DRN) to program WNES {{as a whole}} (i. e., <b>macroprogramming)</b> instead of several networked entities. DRN allows programmers to declaratively describe a set of desired resources by their run-time properties and to map this set to a variable. Using DRN, resource accesses are simplified to completely network-transparent accesses of variables. DRN provides both individual and group accesses to the desired set. Group accesses (i. e., parallel accesses) reduce total access time and energy consumption because of possible in-network processing. Additionally, we can associate each set with tuning parameters (e. g., timeout, energy budget) to bound access time or to tune resource consumption. ...|$|E
