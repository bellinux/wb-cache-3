186|341|Public
25|$|Build 4029 (build date of June 19, 2003), {{was leaked}} on September 23, 2003. This build {{contained}} {{few of the}} technologies new to build 4015. Windows Explorer went {{through a number of}} other changes. Larger image and video previews were displayed in a tooltip when the mouse hovered over a file, column-level filtering of results was introduced, and overall performance of Explorer was somewhat improved over build 4015, though the <b>memory</b> <b>leak</b> issues were not entirely resolved. There was also a new analog clock user interface. Batch image processing of images was also introduced, making it possible for a user to rotate a number of images at once.|$|E
25|$|The {{placement}} delete {{functions are}} called from placement new expressions. In particular, {{they are called}} if the constructor of the object throws an exception. In such a circumstance, {{in order to ensure}} that the program does not incur a <b>memory</b> <b>leak,</b> the placement delete functions are called. A placement new expression first calls the placement operator new function, then calls the constructor of the object upon the raw storage returned from the allocator function. If the constructor throws an exception, it is necessary to deallocate that storage before propagating the exception back to the code that executed the placement new expression, and that is the purpose of the placement delete functions.|$|E
2500|$|If no {{matching}} placement {{delete function}} exists, no deallocation function is {{called in the}} event of an exception being thrown by a constructor within a placement new expression. There are also some (older) C++ implementations that do not support placement delete (which, like the exception-throwing allocator functions, were an addition made to C++ when it was standardized) at all. In both such situations, an exception being thrown by a constructor when allocating using a custom allocator will result in a <b>memory</b> <b>leak.</b> [...] (In the case of the older C++ implementations, a <b>memory</b> <b>leak</b> will also occur with non-placement new expressions.) ...|$|E
40|$|<b>Memory</b> <b>leaks</b> {{are known}} to be a major cause of {{reliability}} and performance issues in software. This paper describes a run-time scheme that detects and removes <b>memory</b> <b>leaks</b> with minimal performance overhead and with no modifications to application source code. The scheme consists of a first stage where a pattern recognition technique proactively detects subtle <b>memory</b> <b>leaks,</b> followed by a more resource-intensive second stage that scans the memory space of an application and removes detected <b>memory</b> <b>leaks.</b> The pattern recognition technique in the first stage is based on the multivariate state estimation technique (MSET) which provides accurate detection of subtle <b>memory</b> <b>leaks</b> with very little overhead. The second stage is only activated when problems are identified by the first stage. For our prototype, this second stage is based on debugging and analysis tools provided by Solaris 10. Due to the low-overhead impact of the first stage, the system can be monitored for <b>memory</b> <b>leaks</b> without incurring noticeable performance degradation. We present and discuss some results from our unique proactive detection and debugging methodology. ...|$|R
50|$|Languages which {{exclusively}} use {{garbage collection}} {{are known to}} avoid the last two classes of defects. <b>Memory</b> <b>leaks</b> can still occur (and bounded leaks frequently occur with generational or conservative garbage collection), but are generally less severe than <b>memory</b> <b>leaks</b> in manual systems.|$|R
40|$|Despite Java's {{automatic}} reclamation of <b>memory,</b> <b>memory</b> <b>leaks</b> {{remain an}} important problem. For example, we frequently encounter <b>memory</b> <b>leaks</b> that cause production servers to crash. These servers represent an increasingly common class of Java applications: they are large scale {{and they make}} heavy use of frameworks. For these applications, existing tools require too much expertise, and, even for experts, require many hours interpreting low-level details. In addition, they are often too expensive to use in practice. We present an automated, adaptive, and scalable tool for diagnosing <b>memory</b> <b>leaks,</b> called LeakBot. LeakBot incorporate...|$|R
2500|$|Before {{the release}} of Windows 7, InfoWorld {{reported}} an alleged <b>memory</b> <b>leak</b> in CHKDSK; according to the report, the chkdsk /r command would cause the memory consumption to reach the maximum and the system to crash. Randall C. Kennedy of InfoWorld attributed the original report to [...] "various Web sources" [...] and said that in his tests, the memory consumption reached above 90%, {{although he did not}} experience a crash. Nevertheless, Kennedy took the memory consumption for a critical bug that would derail Windows 7's launch and cynically chastised Microsoft. Tom Warren of Neowin dismissed Kennedy's assessment of the alleged leak's significance. Steven Sinofsky of Microsoft also responded that Microsoft could not reproduce a crash either but that the massive memory consumption was by design, to improve performance, and not a leak. Ed Bott of ZDNet also reviewed the claim with his own tests and observed that no crash would occur. Noting that chkdsk /r, by design, does not work on the system drive while Windows is online, Bott concluded [...] "it’s arguably a feature, not a bug, and the likelihood that you’ll ever crash a system this way is very, very small and completely avoidable." ...|$|E
2500|$|Build 4015 (build date of March 28, 2003) {{was leaked}} to the Internet on April 28, 2003. A number of {{features}} Microsoft {{had been working on}} were rolled into this build, such as a range of parental controls, also moved and enlarged the Windows logo to {{the left side of the}} Start button a lot of additional configurability for the sidebar (including being able to put it below the start bar at the bottom of the screen), and the notion of [...] "Libraries" [...] (later known as virtual folders) of files. These libraries collected content from around the hard drive. The user could then filter this content and save it in a folder. Microsoft had originally intended to replace all special shell folders (My Documents, My Music, etc.) with virtual folders. However, this change was deemed too drastic and was dropped after Beta 1's release in mid-2005. Libraries were later included in Windows 7. This build was also notable for the debut of the boot screen progress bar that is seen in the final release (though 4015's version was blue, not green). A new Download Manager shell location suggested that Internet Explorer would get a Mozilla-style download manager, though no such functionality was apparent. Significant <b>memory</b> <b>leak</b> problems with Windows Explorer and the Sidebar made this build difficult to use, which resulted in some third-party hacks to mitigate the problem. The back-end database of Outlook Express changed completely, and became dependent on WinFS to store its email. WinFS itself still had significant performance and memory usage issues, and so it became common for testers to disable WinFS entirely, thus rendering Outlook Express inoperative.|$|E
50|$|A <b>memory</b> <b>leak</b> tool or memory {{debugger}} is a {{programming tool}} for finding memory leaks and buffer overflows. A <b>memory</b> <b>leak</b> {{is a particular}} kind of unnecessary memory consumption by a computer program, where the program fails to release memory that is no longer needed. Examples of <b>memory</b> <b>leak</b> detection tools used by Mozilla are the XPCOM <b>Memory</b> <b>Leak</b> tools.Validation tools are used to check if pieces of code conform to the specified syntax. An example of a validation tool is Splint.|$|E
5000|$|Memory {{allocation}} and release, {{garbage collection}} and <b>memory</b> <b>leaks.</b>|$|R
40|$|This thesis {{has been}} a study in memory {{management}} in C/C++, with practical work in finding and solving <b>memory</b> <b>leaks</b> in a large project. A background theory of C++ and memory management has been presented along with the memory problems that can arise in development in C/C++. Several topics in minimizing memory problems with using inbuilt C++ libraries and the Boost libraries have also been presented. There is also {{an overview of the}} PLC-Opt 2. 2 Beta application and its inner workings. The method was to learn all about memory management and solve the <b>memory</b> <b>leaks</b> in PLC-Opt. The results showed that there were approximately 28. 000 instances of <b>memory</b> <b>leaks</b> and the end result showed that approximately 700 instances of leaks remained unresolved. A list with clues of the remaining <b>memory</b> <b>leaks</b> was provided in the Future work chapter...|$|R
50|$|Assistance for {{assessing}} memory usage and detecting <b>memory</b> <b>leaks</b> in programs.|$|R
50|$|If the <b>memory</b> <b>leak</b> {{is in the}} kernel, the {{operating}} system itself will likely fail. Computers without sophisticated memory management, such as embedded systems, may also completely fail from a persistent <b>memory</b> <b>leak.</b>|$|E
50|$|In {{computer}} science, a <b>memory</b> <b>leak</b> {{is a type}} {{of resource}} leak that occurs when a computer program incorrectly manages memory allocations {{in such a way that}} memory which is no longer needed is not released. In object-oriented programming, a <b>memory</b> <b>leak</b> may happen when an object is stored in memory but cannot be accessed by the running code. A <b>memory</b> <b>leak</b> has symptoms similar to a number of other problems and generally can only be diagnosed by a programmer with access to the program's source code.|$|E
5000|$|Purify: mainly memory {{corruption}} {{detection and}} <b>memory</b> <b>leak</b> detection.|$|E
50|$|LeakFix: A {{tool that}} {{automatically}} fixes <b>memory</b> <b>leaks</b> in C programs.|$|R
5000|$|A memory {{debugger}} is a {{programming tool}} for finding <b>memory</b> <b>leaks</b> and buffer overflows. These {{are due to}} bugs related to the allocation and deallocation of dynamic memory. Programs written in languages that have garbage collection, such as managed code, might also need memory debuggers, e.g. for <b>memory</b> <b>leaks</b> due to [...] "living" [...] references in collections.|$|R
40|$|It is well {{accepted}} that pointers {{are a common}} source of memory anomalies such as loosing references to dynamic records without deallocating them (also known as <b>memory</b> <b>leaks).</b> This paper presents a novel pointer analysis framework that detects <b>memory</b> <b>leaks</b> by statically analyzing the behavior of programs. Our approach is based on symbolic evaluation of programs. Symbolic evaluation is an advanced static symbolic analysis that is centered around symbolic variable values, assumptions about and constraints between variable values, and control ow information (path conditions). As part of symbolic evaluation we introduce a new symbolic heap algebra for modeling heap operations. Predicates { dened over the program's input { are derived which allow to detect <b>memory</b> <b>leaks.</b> Our approach goes beyond previous work in the eld of statically detecting <b>memory</b> <b>leaks</b> by considering also path conditions which increases the accuracy of our results, symbolically modeling heap data structures and heap [...] ...|$|R
50|$|If {{a program}} has a <b>memory</b> <b>leak</b> and its memory usage is {{steadily}} increasing, {{there will not}} usually be an immediate symptom. Every physical system has a finite amount of memory, and if the <b>memory</b> <b>leak</b> is not contained (for example, by restarting the leaking program) it will eventually cause problems.|$|E
5000|$|<b>Memory</b> <b>leak</b> - when memory usage is not tracked or tracked {{incorrectly}} ...|$|E
5000|$|To put {{it another}} way, a <b>memory</b> <b>leak</b> arises from a {{particular}} kind of programming error, and without access to the program code, someone seeing symptoms can only guess {{that there might be a}} <b>memory</b> <b>leak.</b> It would be better to use terms such as [...] "constantly increasing memory use" [...] where no such inside knowledge exists.|$|E
2500|$|Kerberos 4 <b>memory</b> <b>leaks</b> provide {{sensitive}} credential information via remote attacks, Nov 1996 ...|$|R
40|$|<b>Memory</b> <b>leaks</b> are {{recognized}} {{to be one}} of the major causes of memory exhaustion problems in complex software systems. This paper proposes a practical approach to detect aging phenomena caused by <b>memory</b> <b>leaks</b> in distributed objects Off-The-Shelf middleware, which are commonly used to develop critical applications. The approach, which is validated on a real-world case study from the Air Traffic Control domain, defines algorithms and ad hoc support tools to perform data filtering and to find the best trade off between experimentation time and statistical accuracy of aging trend estimates. Experiments show that fixing <b>memory</b> <b>leaks</b> is not always the key to solve memory exhaustion problems...|$|R
5000|$|Dmalloc {{can find}} <b>memory</b> <b>leaks,</b> off-by-one errors, and usage of invalid {{addresses}} in some library functions calls.|$|R
5000|$|Valgrind [...] is a {{programming}} tool for memory debugging, <b>memory</b> <b>leak</b> detection, and profiling.|$|E
50|$|Valgrind, a {{programming}} tool for memory debugging, <b>memory</b> <b>leak</b> detection, and profiling, uses dynamic recompilation.|$|E
5000|$|Plumbr is {{a popular}} <b>memory</b> <b>leak</b> {{detection}} tool for applications running on Java Virtual Machine ...|$|E
40|$|<b>Memory</b> <b>leaks</b> {{remain a}} {{significant}} challenge for C and C++ developers. Leaky applications become slower {{over time as}} their working set grows, triggering paging, and can eventually become unresponsive. At the same time, <b>memory</b> <b>leaks</b> remain notoriously difficult to debug, and comprise {{a large number of}} reported bugs in mature applications. Existing approaches like conservative garbage collection can only remedy leaks of unreachable objects. In addition, they can impose unacceptable runtime or space overheads, or cause legal C/C++ applications to fail or retain excessive memory. This paper presents Plug, a runtime system for C/C++ applications that allows applications to deliver high performance in the face of both reachable and unreachable <b>memory</b> <b>leaks.</b> It uses a novel heap layout that isolates leaked objects from non-leaked objects, allowing them to be completely paged out to disk. Plug further reduces the space impact of leaks by employing virtual compaction, an approach that leverages virtual memory primitives to allow physical memory compaction without moving objects. We demonstrate Plug’s low overhead and its effectiveness at tolerating real <b>memory</b> <b>leaks.</b> 1...|$|R
2500|$|... – Microsoft's {{analysis}} of how webpages can cause <b>memory</b> <b>leaks</b> in Internet Explorer, and how developers can prevent them ...|$|R
5000|$|A space leak {{occurs when}} a {{computer}} program uses more memory than necessary. In contrast to <b>memory</b> <b>leaks,</b> where the <b>leaked</b> <b>memory</b> is never released, the memory consumed by a space leak is released, but later than expected.|$|R
50|$|Some other {{debugging}} tools {{have been}} designed to work with GDB, such as <b>memory</b> <b>leak</b> detectors.|$|E
50|$|The <b>memory</b> <b>leak</b> lasts {{until the}} system is reset. For example: if the elevator's power were turned off or in a power outage, the program would stop running. When power was turned on again, the program would restart and all the memory would be {{available}} again, but the slow process of <b>memory</b> <b>leak</b> would restart together with the program, eventually prejudicing the correct running of the system.|$|E
50|$|The term {{is derived}} from <b>memory</b> <b>leak.</b> Handle leaks, like memory leaks, are {{specific}} instances of resource leaks.|$|E
40|$|<b>Memory</b> <b>leaks</b> are a {{continuing}} {{problem in the}} software developed with programming languages, such as C and C++. A recent approach adopted by some researchers is to tolerate leaks in the software application and to reclaim the <b>leaked</b> <b>memory</b> by use of specially constructed memory allocation routines. However, such routines replace the usual general-purpose memory allocator and {{tend to be less}} efficient in speed and in memory utilization. We propose a new scheme which coexists with the existing memory allocation routines and which reclaims <b>memory</b> <b>leaks.</b> Our scheme identifies and reclaims <b>leaked</b> <b>memory</b> at the kernel level. There are some major advantages to our approach: (I) the application software {{does not need to be}} modified; (2) the application does not need to be suspended while <b>leaked</b> <b>memory</b> is reclaimed; (3) a remote host can be used to identify the <b>leaked</b> <b>memory,</b> thus minimizing impact on the application program's performance; and (4) our scheme does not degrade the service availability of the application while detecting and reclaiming <b>memory</b> <b>leaks.</b> We have implemented a prototype that works with the GNU C library and with the Linux kernel. Our prototype has been tested and evaluated with various real-world applications. Our results show that the computational overhead of our approach is around 2 % of that incurred by the conventional memory allocator in terms of throughput and average response time. We also verified that the prototype successfully suppressed address space expansion caused by <b>memory</b> <b>leaks</b> when the applications are run on synthetic workloads. close...|$|R
50|$|With garbage {{collected}} languages it {{may become}} a source of <b>memory</b> <b>leaks</b> as it introduces global strong references to the objects.|$|R
5000|$|Memory safety: finding <b>memory</b> <b>leaks,</b> dereferences of {{dangling}} pointers, {{and discovering}} cases where {{a block of}} memory is freed more than once.|$|R
