11|139|Public
50|$|William McCune {{proved the}} {{conjecture}} in 1996, using the automated theorem prover EQP. For a complete {{proof of the}} Robbins conjecture in one consistent notation and following McCune closely, see Mann (2003). Dahn (1998) simplified McCune's <b>machine</b> <b>proof.</b>|$|E
5000|$|BOPP is a non-fibrous and non-porous polymer. Compared {{with paper}} {{banknotes}}, banknotes made using BOPP {{are harder to}} tear, more resistant to folding, more resistant to soil, waterproof (and washing <b>machine</b> <b>proof),</b> harder to burn, easier to machine process, and are shreddable and recyclable {{at the end of}} their lives.|$|E
50|$|Nuprl {{was first}} {{released}} in 1984, and was first {{described in detail}} in the book Implementing Mathematics with the Nuprl Proof Development System, published in 1986. Nuprl 2 was the first Unix version. Nuprl 3 provided <b>machine</b> <b>proof</b> for mathematical problems related to Girard's Paradox and Higman's lemma. Nuprl 4, the first version developed for the World Wide Web, was used to verify cache coherency protocols and other computer systems.|$|E
40|$|We formalize proofs over Generic Haskell-style polytypic {{programs}} in the proof assistant Coq. This {{makes it possible to}} do fully formal (<b>machine</b> verified) <b>proofs</b> over polytypic programs with little ef-fort. Moreover, the formalization {{can be seen as a}} <b>machine</b> verified <b>proof</b> that polytypic proof specialization is correct with respect to polytypic property specialization...|$|R
5000|$|As [...] "Smullyan's ‘Drinkers’ principle" [...] or just [...] "Drinkers' principle" [...] {{it appears}} in H.P. Barendregt's [...] "The quest for correctness" [...] (1996), {{accompanied}} by some <b>machine</b> <b>proofs.</b> Since then it has made regular appearance as an example in publications about automated reasoning; it is sometimes used to contrast the expressiveness of proof assistants.|$|R
40|$|One can {{construct}} any finite-state machine as {{a cascade}} interconnection of machines whose inputs either permute the states or reset {{them all to}} one state. Each permutation group needed in the construction is a homomorphic image of a group generated {{by the action of}} a set of input sequences on a state subset of the original <b>machine.</b> <b>Proofs</b> of these facts will be given and their application to the Krohn-Rhodes theory described...|$|R
40|$|In this paper, we {{describe}} {{the application of the}} interactive theorem prover Coq to the security analysis of bytecode as used in Java. We provide a generic specification and proof of non-interference for bytecode languages using the Coq module system. We illustrate the use of this formalization by applying it to a small subset of Java bytecode. The emphasis of the paper is on modularity of a language formalization and its analysis in a <b>machine</b> <b>proof...</b>|$|E
40|$|Abstract. This paper {{introduces}} Proof General Kit, {{a framework}} for software components tailored to interactive proof development. The goal of the framework is to enable flexible environments for managing formal proofs across their life-cycle: creation, maintenance and exploitation. The framework connects together different kinds of component, exchanging messages using a common communication infrastructure and protocol called PGIP. The main channel connects provers to displays. Provers are the back-end interactive proof engines and displays are components for interacting with the user, allowing browsing or editing of proofs. At {{the core of the}} framework is a broker middleware component which manages proof-in-progress and mediates between components. 1 Introducing Proof General Kit The use of interactive <b>machine</b> <b>proof</b> is becoming more widespread, and larger and more complex formalisations are being undertaken in application areas such as hardware or software verification, and formalisation of mathematics, even u...|$|E
40|$|Transreal {{arithmetic}} {{is a total}} arithmetic {{that contains}} real arithmetic, but which has no arithmetical exceptions. It allows the specification of the Universal Perspex Machine which unifies geometry with the Turing Machine. Here we axiomatise the algebraic structure of transreal arithmetic so that it provides a total arithmetic on any appropriate set of numbers. This opens up the possibility of specifying a version of floating-point arithmetic {{that does not have}} any arithmetical exceptions and in which every number is a first-class citizen. We find that literal numbers in the axioms are distinct. In other words, the axiomatisation does not require special axioms to force non-triviality. It follows that transreal arithmetic must be defined on a set of numbers that contains {-infinity, - 1, 0, 1, infinity, nullity} as a proper subset. We note that the axioms {{have been shown to be}} consistent by <b>machine</b> <b>proof.</b> This record was migrated from the OpenDepot repository service in June, 2017 before shutting down...|$|E
5000|$|... 1934: IBM 801The IBM 801 Bank <b>Proof</b> <b>machine</b> {{to clear}} bank checks is introduced. A {{new type of}} <b>proof</b> <b>machine,</b> the 801 lists and {{separates}} checks, endorses them, and records totals. It dramatically improves {{the efficiency of the}} check clearing process.|$|R
40|$|The {{existing}} readable machine proving methods {{deal with}} geometry problems using some geometric quantities. In this paper, {{we focus on}} the mass point method which directly deals with the geometric points rather than the geometric quantities. We propose two algorithms, Mass Point Method and Complex Mass Point Method, which can deal with the Hilbert intersection point statements in affine geometry and the linear constructive geometry statements in metric geometry respectively. The two algorithms are implemented in Maple as provers. The results of hundreds of non-trivial geometry statements run by our provers show that the mass point method is efficient and the <b>machine</b> <b>proofs</b> are human-readable. © 2011 Springer-Verlag. The existing readable machine proving methods deal with geometry problems using some geometric quantities. In this paper, {{we focus on the}} mass point method which directly deals with the geometric points rather than the geometric quantities. We propose two algorithms, Mass Point Method and Complex Mass Point Method, which can deal with the Hilbert intersection point statements in affine geometry and the linear constructive geometry statements in metric geometry respectively. The two algorithms are implemented in Maple as provers. The results of hundreds of non-trivial geometry statements run by our provers show that the mass point method is efficient and the <b>machine</b> <b>proofs</b> are human-readable. © 2011 Springer-Verlag...|$|R
40|$|To {{be sure of}} {{the meaning}} of a {{programming}} language, we need to have its formal semantics. But semantic specifications are hard to write, {{and it is difficult to}} be convinced that they are correct. Having an executable semantics helps, since this allows the semantics to be tested on real programs which tends to expose many mistakes. But ultimately the correctness of the semantics has to be proved and then preferably by means of a computerized proof assistant to avoid mistakes in the proof. This is why we are working towards <b>machine</b> <b>proofs</b> with executable formal specifications. The extended abstract that follows is a step towards that goal...|$|R
40|$|International audienceGEOTHER {{provides}} an environment for handling and proving theorems in geometry automatically. In this environment, geometric theorems {{are represented by}} means of predicate specifications. Several functions are implemented that allow one to translate the specification of a geometric theorem into an English or Chinese statement, into algebraic expressions, and into a logic formula automatically. Geometric diagrams can also be drawn automatically from the predicate specification, and the drawn diagrams may be modified and animated with a mouse click and dragging. Five algebraic provers based on Wu’s method of characteristic sets, the Gröbner basis method, and other triangularization techniques are available for proving such theorems in elementary (and differential) geometry. Geometric meanings of the produced algebraic nondegeneracy conditions can be interpreted automatically, in most cases. PostScript and HTML files can be generated, also automatically, to document the manipulation and <b>machine</b> <b>proof</b> of the theorem. This paper presents these capabilities of GEOTHER, addresses some implementation issues, reports {{on the performance of}} GEOTHER’s algebraic provers, and discusses a few challenging problems...|$|E
40|$|We {{have shown}} by <b>machine</b> <b>proof</b> that F 24 = 2 ^ 2 ^ 24 + 1 is composite. The {{rigorous}} Pépin primality test was performed using independently developed programs running simultaneously on two different, physically separated processors. Each program employed a floating-point, FFT-based discrete weighted transform (DWT) to effect multiplication modulo F 24. The final, respective Pépin residues obtained {{by these two}} machines were in complete agreement. Using intermediate residues stored periodically {{during one of the}} floating-point runs, a separate algorithm for pure-integer negacyclic convolution verified the result in a “wavefront” paradigm, by running simultaneously on numerous additional machines, to effect piecewise verification of a saturating set of deterministic links for the Pépin chain. We deposited a final Pépin residue for possible use by future investigators in the event that a proper factor of F 24 should be discovered; herein we report the more compact, traditional Selfridge-Hurwitz residues. For the sake of completeness, we also generated a Pépin residue for F 23, and via the Suyama test determined that the known cofactor of this number is composite...|$|E
40|$|We show two lower bounds {{that are}} proved using related ideas. The {{results are not}} {{necessarily}} so interesting in their own right, but the proofs are interesting as rare examples in complexity theory when we can prove a direct lower bound {{on the power of}} a (uniform) complexity class! 1. 1 One-Tape Turing Machines We first show a language L requiring quadratic time to decide on a one-tape Turing machine. Besides being interesting in its own right, it separates the power of one-tape and two-tape machines (since L can be decided in linear time on a two-tape Turing machine). For a finite string x over any alphabet, let ¯x be the reverse of x. Taking Σ = { 0, 1, #}, define the language of palindromes as: L def = {x¯x | x ∈ Σ ∗}. Theorem 1 Deciding L requires time Ω(n 2) on a one-tape Turing <b>machine.</b> <b>Proof</b> Let M be a one-tape Turing machine deciding L. For each n which is a multiple of four, consider the following subset of L: Ln def = {x # n 2 ¯x | x ∈ { 0, 1 } n 4 }. For any x ∈ Ln and position i ∈ { 1, [...] ., n} on the tape of M, let Ci(x), the crossing sequence on x at position i, denote the ordered sequence of states that M is in as the head of M crosses over the line between the ith and (i + 1) th cells (in either direction). Define C(x) de...|$|E
40|$|Article dans revue scientifique avec comité de lecture. International audienceThis article {{presents}} one human <b>proof</b> and three <b>machine</b> <b>proofs</b> of a challenging geometric theorem {{that gives a}} beautiful representation of the area of an arbitrary quadrilateral {{in terms of its}} four sides and four internal angles. These proofs demonstrate the power, capability and features of automated deduction methods and tools, which reduce qualitative difficulty to quantitative complexity versus traditional methods with individual ingenious ideas, for mathematical theorem proving. The present case study not only results in four probably new proofs of a hard theorem but also contributes to understanding the significance of developing effective algorithms and software tools for automated theorem proving in mathematics using advanced computing technology...|$|R
40|$|Abstract. This note {{describes}} Proof General, a {{tool for}} developing <b>machine</b> <b>proofs</b> with an interactive proof assistant. Interaction is based around a proof script, which is {{the target of a}} proof development. Proof General provides a powerful user-interface with relatively little effort, alleviating the need for a proof assistant to provide its own GUI, and providing a uniform appearance for diverse proof assistants. Proof General has a growing user base and is currently used for several interactive proof systems, including Coq, LEGO, and Isabelle. Support for others is on the way. Here we give a brief overview of what Proof General does and the philosophy behind it; technical details are available elsewhere. The program and user documentation are available on the web a...|$|R
30|$|However, proofs of {{programming}} language formalisms (e.g. type systems and semantics) are usually long and error prone. In {{order to give}} more reliability to these proofs, programming language researchers have been developing, in recent years, {{a large number of}} works devoted to <b>machine</b> assisted <b>proofs</b> [1, 6, 10, 28].|$|R
40|$|Three {{studies in}} the machine {{assisted}} proof of recursion implementation are described. The verification system used is Edinburgh LCF (Logic for Computable Functions). Proofs are generated, in LCF, in a goal-oriented fashion by the application of strategies reflecting informal proof plans. LCF is introduced in Chapter 1. We present three case studies in which proof strategies are developed and (except in the third) tested in LCF. Chapter 2 contains {{an account of the}} machine generated proofs of three program transformations (from recursive to iterative function schemata). Two of the examples are taken from Manna and Waldinger. In each case, the recursion is implemented by the introduction of a new data type, e. g., a stack or counter. Some progress is made towards the development of a general strategy for producing the equivalence proofs of recursive and iterative function schemata by machine. Chapter 3 is concerned with the machine generated proof of the correctness of a compiling algorithm. The formulation, borrowed from Russell, includes a simple imperative language with a while and conditional construct, and a low level language of labelled statements, including jumps. We have, in LCF, formalised his denotational descriptions of the two languages and performed a proof of the preservation of the semantics under compilation. In Chapter 4, we express and informally prove the correctness of a compiling algorithm for a language containing declarations and calls of recursive procedures. We present a low level language whose semantics model a standard activation stack implementation. Certain theoretical difficulties (connected with recursively defined relations) are discussed, and a proposed proof in LCF is outlined. The emphasis in this work is less on proving original theorems, or even automatically finding proofs of known theorems, than on (i) exhibiting and analysing the underlying structure of proofs, and of <b>machine</b> <b>proof</b> attempts, and (ii) investigating the nature of the interaction (between a user and a computer system) required to generate proofs mechanically; that is, the transition from informal proof plans to behaviours which cause formal proofs to be performed...|$|E
5000|$|Turing's {{proof is}} made {{difficult}} by number of definitions required and its subtle nature. See Turing <b>machine</b> and Turing's <b>proof</b> for details.|$|R
40|$|We {{describe}} a faithful representation of value-passing recursive parametric CCS processes in Alf, an implementation of Martin-Lof's constructive type theory. The representation is interesting because we borrow {{as much as}} possible from Alf including the domain of value and state expressions and the ability to evaluate them. Usually substitution of either channel values for channel variables and processes for process variables play a necessary role in the semantics. However, substitution is also borrowed from Alf by using higher-order functions. The main importance of this representation is that it allows us to borrow Alf's off-the-shelf theorems about data types and provides a uniform setting for doing various kinds <b>machine</b> assisted <b>proofs,</b> such as bisimulation proofs, equational reasoning, verification of Hennessy-Milner logic formulas. 1 Introduction <b>Machine</b> checked <b>proofs</b> of CCS processes require finite representations of the processes. However, for infinite value and state domains, [...] ...|$|R
50|$|The first machine, an FSM {{plus two}} counters, is {{equivalent}} in {{power to a}} Turing machine. See the article on counter <b>machines</b> for a <b>proof.</b>|$|R
40|$|Recent work by Siegelmann {{has shown}} that the {{computational}} power of neural networks matches that of Turing <b>Machines.</b> <b>Proofs</b> are based on a fractal encoding of states to simulate the memory and operations of stacks. In the present work, it is shown that similar stack-like dynamics can be learned in recurrent neural networks from simple sequence prediction tasks. Two main types of network solutions are found and described qualitatively as dynamical systems: damped oscillation and entangled spiraling around fixed points. The potential and limitations of each solution type are established in terms of generalization on two different context-free languages. Both solution types constitute novel stack implementations [...] generally in line with Siegelmann 's theoretical work [...] which supply insights into how embedded structures of languages can be handled in analog hardware. Keywords: Recurrent neural network, dynamical system, stack, learning, contextfree language, analysis, computa [...] ...|$|R
30|$|Note: The clauses “VARIABLES” and “INITIALISATION” {{will also}} include the {{declaration}} and the initialization of variables of type “NATURAL” describing the occurrence of each token color of a given place, denoted occ_eltcolor_idplace. These variables represent only {{the state of the}} places (marking) of the Petri Net. They will mainly allow expression properties invariants and help the <b>machines</b> automatic <b>proof</b> of the Atelier B.|$|R
40|$|The mondex {{challenge}} : <b>machine</b> checked <b>proofs</b> for {{an electronic}} purse / D. Haneberg [...] . - In: FM 2006 : Formal methods : 14 th International Symposium on Formal Methods, Hamilton, Canada, August 21 - 27, 2006; proceedings / Jayadev Misra [...] . (eds.). - Berlin [u. a. ] : Springer, 2006. - S. 16 - 31. - (Lecture notes in computer science; 4085...|$|R
50|$|The {{majority}} of the arguments of how to bound the empirical process, rely on symmetrization, maximal and concentration inequalities and chaining. Symmetrization is usually {{the first step of}} the proofs, and since it is used in many <b>machine</b> learning <b>proofs</b> on bounding empirical loss functions (including the proof of the VC inequality which is discussed in the next section) it is presented here.|$|R
40|$|We {{present a}} new {{approach}} to hardware verification based on describing circuits in Monadic Second-order Logic (M 2 L). We show how to use this logic to represent generic designs like n-bit adders, which are parameterized in space, and sequential circuits, where time is an unbounded parameter. M 2 L admits a decision procedure, implemented in the Mona tool [16], which reduces formulas to canonical automata. The decision problem for M 2 L is non-elementary decidable and thus unlikely to be usable in practice. However, we have used Mona to automatically verify, or find errors in, a number of circuits studied in the literature. Previously published <b>machine</b> <b>proofs</b> of the same circuits are based on deduction and may involve substantial interaction with the user. Moreover, our approach is orders of magnitude faster for the examples considered. We show why the underlying computations are feasible and how our use of Mona generalizes standard BDD-based hardware reasoning...|$|R
40|$|The Yahalom {{protocol}} is one {{of those}} analyzed by Burrows et al. [5]. Based upon their analysis, they have proposed modifications to make the protocol easier to understand and to analyze. Both versions of Yahalom have now been analyzed using Isabelle/HOL. Modified Yahalom satisfies strong security goals, and the original version is adequate. The mathematical reasoning behind these <b>machine</b> <b>proofs</b> is presented informally. An appendix gives extracts from a formal proof. Yahalom presents special difficulties because the compromise of one session key compromises other secrets. The proofs show that the resulting losses are limited. They rely on a new proof technique, which involves reasoning about the relationship between keys and the secrets encrypted by them. This technique is applicable to other difficult protocols, such as Kerberos IV [2]. The new proofs do not rely on a belief logic. They use a fundamentally different formal model: the inductive method. They confirm the BAN analysis and [...] ...|$|R
40|$|The goal of {{this work}} is to draw a formal {{connection}} between steps taken by abstract machines and reductions {{in a system of}} proof terms for a version the sequent calculus. We believe that by doing so we shed light on some essential characteristics of abstract <b>machines,</b> <b>proofs</b> in sequent calculus systems, and weak normalization of λ-terms. The machines that we consider are the (callby-name) Krivine machine and a call-by-value machine that may be called a “right-to-left CEK machine ” but with some modifications {{can be seen as a}} proto-ZINC machine. The formal connection we exhibit is, in fact, an embedding of the machines into the term calculus. We embed run-time data structures, such as the control stack and environment, in such a way that the operational semantics of the machine corresponds to reduction steps in the calculus. The abstract machine machine transitions are captured as term reductions. This is in contrast to specifying the operational semantics on top of th...|$|R
40|$|The Italian Ministry of Research (MIUR) {{funded in}} the past years {{research}} projects aimed to an optimization of the analysis activities in the Italian CMS computing Centers. A new grant started in 2013, and activities are already ongoing in 9 INFN sites, all hosting local CMS groups. Main {{focus will be on}} the creation of an italian storage federation (via Xrootd initially, and later HTTP) which allows all the italian CMS physicists to a privileged access to CMS data and simulations. Another task will focus on the optimization of the last step of a CMS analysis, via interactive access to resources; this will result in a number of small- to medium-sized analysis centers, where access will be granted at national level to multicore <b>machines,</b> <b>PROOF</b> facilities, high throughput local queues. An important part of this last activity will imply experimenting with on demand analysis machine instantiation via Clouds, using the experience and the resources INFN is building on the subject...|$|R
40|$|This thesis {{provides}} {{an account of}} a development of tools towards making verification of object-oriented programs more feasible. We note that proofs in program verification logics are typically long, yet, mathematically, not very deep; these observations suggest the thesis that computers can significantly ease the burden of program verification. We give evidence supporting this by applying computers to (1) automatically check and (2) automatically infer large parts of proofs. Taking the logic (AL) of Abadi and Leino as our starting point, we initially show how the logic can be embedded into a higher-order logic theorem prover, by way of introducing axioms, using a mix of both higher-order abstract syntax (HOAS) and a direct embedding of the assertion logic. The tenacity and exactness of the theorem prover ensures that no proof obligation is inadvertently lost during construction of a proof; we inherit any automatic facilities such as tactics which take us part way towards goal (2); and moreover, we achieve goal (1), since we inherit <b>machine</b> <b>proofs</b> which can be checked automatically. We present som...|$|R
40|$|Theoretical {{work has}} been {{developed}} for establishing stability characteristics of the damping and synchronizing torque coefficients, and five theorems are formulated and proved analytically in this paper. These are applied to the simple poly-phase induction machine and synchronous reluctance <b>machine.</b> The <b>proofs</b> depend {{on the characteristics of}} D-decomposition diagram, power/frequency relation in small-signal stability, and eigenvalue loci. The theorems are developed for all ranges of working and not working conditions and examples for those applications are given. 1...|$|R
50|$|The Mark Twain Museum at the Territorial Enterprise, a {{separate}} entity from the above, operates {{a museum in}} the original Territorial Enterprise building in Virginia City, NV. The museum features the original desk used by Mark Twain when he was editor of the paper. Other exhibits include antique printing presses, an early Linotype <b>machine,</b> a <b>proof</b> press, stone composing tables (one of which Mark Twain and other employees of the paper used to sleep on), and various other antiques.|$|R
40|$|An axiomatization in LCF of a {{substantial}} subset of PASCAL (including I/O) is presented. The correctness {{of a program}} for the " McCarthy Airline" reservation system is then stated and proved in this axiomatization. An interesting aspect of such a program is that it deals with a potentially infinite sequence of inputs. The statement of the LCF theorem asserting its partial correctness and the <b>machine.</b> checked <b>proof</b> of a such a theorem (carried out using the Stanford LCF proof-checker) are presented and discussed...|$|R
40|$|Schneider generalizes {{a number}} of {{protocols}} for Byzantine fault tolerant clock synchronization and presents a uniform proof for their correctness. The authors present a <b>machine</b> checked <b>proof</b> of this schematic protocol that revises {{some of the details}} in Schneider's original analysis. The verification was carried out with the EHDM system developed at the SRI Computer Science Laboratory. The mechanically checked proofs include the verification that the egocentric mean function used in Lamport and Melliar-Smith's Interactive Convergence Algorithm satisfies the requirements of Schneider's protocol...|$|R
40|$|We {{propose a}} dependently typed {{formalization}} {{for a simple}} class of sequential decision problems. For this class of problems, we im- plement a generic version of Bellman's backwards induction algorithm [2] and a <b>machine</b> checkable <b>proof</b> that the proposed implementation is correct. The formalization is generic. It is presented in Idris, {{but it can be}} easily translated to other dependently-typed programming languages. We conclude with an informal discussion of the problems we have faced in extending the formalization to generic monadic sequential decision problems. PostprintNon peer reviewe...|$|R
