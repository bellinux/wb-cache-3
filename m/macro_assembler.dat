89|33|Public
5|$|In December 1974 Bill Gates was {{a student}} at Harvard University and Paul Allen worked for Honeywell in Boston. They saw the Altair 8800 {{computer}} in the January 1975 issue of Popular Electronics and knew it was powerful enough to support a BASIC interpreter. They wanted {{to be the first to}} offer BASIC for the Altair computer, and the software development tools they had previously created for their Intel 8008 microprocessor based Traf-O-Data computer would give them a head start. While their friend, Paul Gilbert, was building the computer, Allen wrote a program that ran on a DEC PDP-10 time-sharing computer that simulated the 8008 system. He also modified DEC's <b>macro</b> <b>assembler</b> to produce the machine code for the 8008 microprocessor. The Traf-O-Data software could be written and debugged before the computer hardware was complete.|$|E
25|$|A <b>macro</b> <b>assembler</b> {{includes}} a macroinstruction facility so that (parameterized) assembly language text {{can be represented}} by a name, and that name {{can be used to}} insert the expanded text into other code.|$|E
25|$|The {{program code}} for the Sinclair Spectrum version {{was written on}} an IBM AT-compatible {{computer}} using a <b>macro</b> <b>assembler,</b> while the graphics were designed on an Atari ST, then downloaded onto the IBM AT, before being downloaded to the Spectrum and debugged using a specially developed monitor.|$|E
25|$|In addition, it was {{designed}} to have all of the power possessed by earlier general <b>macro</b> <b>assemblers</b> but with the unfortunate syntactic and semantic difficulties removed.|$|R
50|$|Keil {{provides}} {{a broad range}} of development tools like ANSI C compiler, <b>macro</b> <b>assemblers,</b> debuggers and simulators, linkers, IDE, library managers, real-time operating systems and evaluation boards for Intel 8051, Intel MCS-251, ARM, and XC16x/C16x/ST10 families.|$|R
2500|$|In {{assembly}} language, {{the term}} [...] "macro" [...] represents {{a more comprehensive}} concept than it does in some other contexts, {{such as in the}} C programming language, where its #define directive typically is used to create short single line <b>macros.</b> <b>Assembler</b> <b>macro</b> instructions, like macros in PL/I and some other languages, can be lengthy [...] "programs" [...] by themselves, executed by interpretation by the assembler during assembly.|$|R
25|$|Some {{assemblers}} {{have incorporated}} structured programming elements to encode execution flow. The earliest {{example of this}} approach was in the Concept-14 macro set, originally proposed by Dr. Harlan Mills (March 1970), and implemented by Marvin Kessler at IBM's Federal Systems Division, which extended the S/360 <b>macro</b> <b>assembler</b> with IF/ELSE/ENDIF and similar control flow blocks. This {{was a way to}} reduce or eliminate the use of GOTO operations in assembly code, one of the main factors causing spaghetti code in assembly language. This approach was widely accepted in the early '80s (the latter days of large-scale assembly language use).|$|E
2500|$|It is also {{possible}} to use solely the macro processing abilities of an assembler to generate code written in completely different languages, for example, to generate a version of a program in COBOL using a pure <b>macro</b> <b>assembler</b> program containing lines of COBOL code inside assembly time operators instructing the assembler to generate arbitrary code. IBM OS/360 uses macros to perform system generation. The user specifies options by coding a series of assembler macros. [...] Assembling these macros generates a job stream to build the system, including job control language and utility control statements.|$|E
2500|$|... the MinGW and Cygwin {{projects}} {{also provide}} {{such an environment}} based on the GNU Compiler Collection (GCC), using a stand-alone header file set, to make linking against the Win32-specific DLLs simple. LCC-Win32 is a C compiler maintained by Jacob Navia, freeware for non-commercial use. Pelles C is a freeware C compiler maintained by Pelle Orinius. Free Pascal is a free software Object Pascal compiler that supports the Windows API. The MASM32 package is a mature project providing support for the Windows API under Microsoft <b>Macro</b> <b>Assembler</b> (MASM) by using custom made or converted headers and libraries from the Platform SDK. Flat assembler FASM allows building Windows programs without using an external linker, even when running on Linux.|$|E
50|$|By {{the late}} 1950s the macro {{language}} {{was followed by}} the <b>Macro</b> <b>Assemblers.</b> This was a combination of both where one program served both functions, that of a macro pre-processor and an assembler in the same package. This allowed assembly language programmers to implement their own macro-language and allowed limited portability of code between two machines running the same CPU but different operating systems, for example, early versions of MSDOS and CPM-86. The macro library would need to be written for each target machine but not the overall assembly language program. Note that more powerful <b>macro</b> <b>assemblers</b> allowed use of conditional assembly constructs in macro instructions that could generate different code on different machines or different operating systems, reducing the need for multiple libraries.|$|R
50|$|Projects in {{development}} by third parties include on-board and/or computer-side converters, interpreters, code generators, <b>macro</b> <b>assemblers,</b> or compilers for Fortran, other Basic variants, awk, C, Cobol, Rexx, Perl, Python, Tcl, Pascal Delphi, and operating system shells like DOS/Win95 batch, OS/2 batch, WinNT/2000 shell, Unix shells, and DCL.|$|R
50|$|The 68k {{emulation}} {{is written}} in C and uses gcc <b>assembler</b> <b>macros</b> where necessary to speed up certain complex instructions.|$|R
2500|$|Macro {{assemblers}} often allow macros to take parameters. Some assemblers include quite sophisticated macro languages, incorporating such {{high-level language}} elements as optional parameters, symbolic variables, conditionals, string manipulation, and arithmetic operations, all usable during {{the execution of}} a given macro, and allowing macros to save context or exchange information. Thus a macro might generate numerous assembly language instructions or data definitions, based on the macro arguments. This {{could be used to}} generate record-style data structures or [...] "unrolled" [...] loops, for example, or could generate entire algorithms based on complex parameters. For instance, a [...] "sort" [...] macro could accept the specification of a complex sort key and generate code crafted for that specific key, not needing the run-time tests that would be required [...] for a general procedure interpreting the specification. An organization using assembly language that has been heavily extended using such a macro suite can be considered to be working in a higher-level language, since such programmers are not working with a computer's lowest-level conceptual elements. Underlining this point, macros were used to implement an early virtual machine in SNOBOL4 (1967), which was written in the SNOBOL Implementation Language (SIL), an assembly language for a virtual machine, which was then targeted to physical machines by transpiled to a native assembler via a <b>macro</b> <b>assembler.</b> This allowed a high degree of portability for the time.|$|E
5000|$|Assemblers: ASM-One <b>Macro</b> <b>Assembler,</b> Devpac Assembler, Metacomco <b>Macro</b> <b>Assembler,</b> SEKA Assembler ...|$|E
5000|$|Atari <b>Macro</b> <b>Assembler</b> (AMAC) [...] - [...] A <b>macro</b> <b>assembler</b> {{released}} by Atari Program Exchange (APX) in disk form. Copy protected.|$|E
50|$|Assembler XF was {{an upgrade}} of Assembler F which {{included}} the new System/370 architecture instructions. This version provided a common assembler for OS/VS and DOS/VS systems. Other changes included relaxing restrictions on expressions and <b>macro</b> processing. <b>Assembler</b> XF required a minimum partition/region size of 64 KB (virtual). Recommended size was 128 KB.|$|R
5000|$|Like DPPX, it {{was written}} in the PL/S-like PL/DS language. The applications, {{including}} much of DOSF, however, were written an interpreted language that was [...] "compiled" [...] using the System/370 <b>assembler</b> <b>macro</b> facility.|$|R
25|$|During the {{development}} of TTM, {{it became apparent that}} applications other than <b>assembler</b> <b>macro</b> processing were possible. These include data editing, text manipulation, expression compiling, and macro processing for language processors other than assemblers.|$|R
50|$|Technical Assembly System (TASS) â€” A <b>macro</b> <b>assembler.</b>|$|E
5000|$|Development kit: code editor with a <b>macro</b> <b>assembler</b> (FASM) {{integrated}} ...|$|E
50|$|Supports Microsoft <b>macro</b> <b>assembler</b> (MASM) 5 and 6 syntax (incomplete).|$|E
50|$|Partitioned {{datasets}} {{can store}} {{any type of}} data, but they are often used to store executable programs, or load modules, sometimes called binaries in other systems. Other uses include system <b>assembler</b> <b>macro</b> definitions, job control procedures, and program source code.|$|R
5000|$|... "WTO" [...] is an <b>assembler</b> <b>macro</b> {{that generates}} an {{operating}} system call. Because of saving registers and later restoring and returning, this small program is usable as a batch program invoked {{directly by the}} operating system Job control language (JCL) like this: ...|$|R
50|$|With the {{exception}} of the assemblers for the IBM System/360 Model 20 the IBM assemblers were largely upward-compatible. The differences were mainly in the complexity of expressions allowed and in <b>macro</b> processing. OS/360 <b>assemblers</b> were originally designated according to their memory requirements.|$|R
5000|$|JWASM <b>Macro</b> <b>Assembler,</b> {{licensed}} {{under the}} Sybase Open Watcom EULA.|$|E
5000|$|Pelle's <b>Macro</b> <b>Assembler,</b> a {{component}} of the Pelles C development environment.|$|E
50|$|Fully {{supports}} Microsoft <b>macro</b> <b>assembler</b> 6 syntax, all MASM 8 instructions sets.|$|E
5000|$|Nonetheless, {{adopting}} the same discipline as in structured programming can greatly improve the readability and maintainability of such code.This {{may take the}} form of conventions limiting the use of [...] to correspond to the standard structures, or use of a set of <b>assembler</b> <b>macros</b> for [...] and [...] constructs.|$|R
5000|$|It is, of course, {{perfectly}} {{possible to}} generate the above code [...] "inline" [...] using a single <b>assembler</b> <b>macro</b> statement, specifying just four or five operands (or alternatively, {{make it into a}} library subroutine, accessed by a simple call, passing a list of parameters), making the optimization readily accessible to inexperienced programmers.|$|R
5000|$|<b>Assembler</b> <b>macros</b> {{provide an}} {{alternative}} approach to inlining whereby a sequence of instructions can normally be generated inline by macro expansion from a single macro source statement (with zero or more parameters). One of the parameters might be an option to alternatively generate a one-time separate subroutine containing the sequence and processed instead by an inlined call to the function.Example: MOVE FROM=array1,TO=array2,INLINE=NO ...|$|R
50|$|A <b>Macro</b> <b>Assembler</b> for {{translating}} {{assembly language}} programs into executable machine code.|$|E
50|$|IBM {{recognized}} {{the problems with}} the <b>Macro</b> <b>Assembler</b> and created an automated program generator named DMS. DMS later became Cross System Product (CSP) on the 8100. DMS was essentially a screen painter; it could do simple edits such as field range checking or numeric tests but more complex logic still had to be coded using the <b>Macro</b> <b>Assembler.</b>|$|E
5000|$|The 3790 {{failed to}} achieve the success IBM intended, due to several issues. [...] It had a complex {{programming}} language, The 3790 <b>Macro</b> <b>Assembler,</b> and the customers {{found it difficult to}} deploy applications on it. The <b>Macro</b> <b>Assembler</b> ran only on an IBM mainframe and then the compiled and linked object was moved to the 3790 for testing.|$|E
5000|$|Basic Mapping Support {{defines the}} screen format through <b>assembler</b> <b>macros</b> {{such as the}} following. This was {{assembled}} to generate both the physical map set [...] - [...] a load module in a CICS load library [...] - [...] and a symbolic map set [...] - [...] a structure definition or DSECT in PL/I, COBOL, assembler, etc. which was copied into the source program.|$|R
50|$|A {{partitioned}} {{data set}} (PDS) is a data set containing multiple members, each of which holds a separate sub-data set, similar to a directory in other types of file systems. This type of data set {{is often used to}} hold executable programs (load modules), source program libraries (especially <b>Assembler</b> <b>macro</b> definitions), and Job Control Language. A PDS may be compared to a Zip file or COM Structured Storage.|$|R
50|$|Stage 1 is the {{compilation}} of {{a sequence of}} <b>assembler</b> <b>macro</b> instructions describing the configuration to be installed or updated. The assembler does not actually compile any object code, but instead compiles a series of PUNCH pseudo-ops in order to generate a job stream for Stage 2. As IBM changed the nomenclature for OS/360 options, it also changed the Sysgen macro definitions to use newer names for the options.|$|R
