19|795|Public
50|$|Critics of SVOT {{as applied}} to <b>message</b> <b>sequencing</b> argue that this concept is not scalable. As the world moves towards systems spread over many {{processing}} nodes, the effort involved in negotiating a single agreed-upon sequence becomes prohibitive.|$|E
40|$|Two {{important}} issues {{that need to}} be addressed when designing medium access control (MAC) protocols for Wavelength Division Multiplexing networks are <b>message</b> <b>sequencing</b> and channel assignment. Channel assignment addresses the problem of choosing an appropriate data channel via which a message is transmitted. This problem has been addressed extensively in the literature. On the other hand, <b>message</b> <b>sequencing,</b> which addresses the order in which messages are sent, has rarely been addressed. In this paper, we propose a new reservation-based message scheduling algorithm called RO-EATS that addresses both the channel assignment and <b>message</b> <b>sequencing</b> during its scheduling process. We formulate an analytical model and conduct extensive simulations to evaluate the performance of this algorithm. We compare the performance results of a well-known algorithm which only addresses the channel assignment issue with those of our new algorithm. The comparison shows that our new algorithm gives significant improvement over scheduling algorithms that do not consider <b>message</b> <b>sequencing.</b> As a result, we anticipate that these research results will lead to new approaches to message scheduling on WDM networks. (C) 1999 published by Elsevier Science B. V. All rights reserved...|$|E
40|$|<b>Message</b> <b>sequencing</b> {{and channel}} {{assignment}} are two important issues {{that need to}} be addressed when scheduling variable-length messages in a wavelength division multiplexing (WDM) network. Channel assignment addresses the problem of choosing an appropriate data channel via which a message is transmitted to a node. This problem has been addressed extensively in the literature. On the other hand, <b>message</b> <b>sequencing</b> which addresses the order in which messages are sent, has rarely been addressed. In this paper, we propose a set of scheduling techniques for single-hop WDM passive star networks, which address both the sequencing aspect and the assignment aspect of the problem, In particular, we develop two priority schemes for sequencing messages in a WDM network in order to increase the overall performance of the network. We evaluate the proposed algorithms, using analytical modeling and extensive discrete-event simulations, by comparing their performance with state-of-the-art scheduling algorithms that only address the assignment problem [9], We find that significant improvement in performance can be achieved using our scheduling algorithms where <b>message</b> <b>sequencing</b> and channel assignment are simultaneously taken into consideration. This suggests that, when scheduling messages in WDM networks, one has to consider <b>message</b> <b>sequencing,</b> as well as channel assignment. As a result, we anticipate that this research mill open new directions into the problem of on-line scheduling in WDM networks...|$|E
40|$|An {{effective}} way to assemble partial views of a distributed system is to compute their product. Given two languages of <b>message</b> <b>sequence</b> charts generated by <b>message</b> <b>sequence</b> graphs, we {{address the problem of}} computing a <b>message</b> <b>sequence</b> graph that generates their product. Since all MSCs generated by a <b>message</b> <b>sequence</b> graph may be run within fixed bounds on the message channels, a subproblem is to decide whether the considered product is existentially bounded. We show that this question is undecidable but turns decidable in the restricted case where all shared events belong to the same process. For this case, we propose sufficient conditions under which a <b>message</b> <b>sequence</b> graph representing the product can be constructed...|$|R
50|$|For the {{inductive}} hypothesis, {{we assume}} that for some j+1 ≤ p and any <b>message</b> <b>sequence</b> Mj+1, NMj = Praccepts w and then prove the hypothesis for j and any <b>message</b> <b>sequence</b> Mj.|$|R
40|$|We {{extend the}} formal {{developments}} for <b>message</b> <b>sequence</b> charts (MSCs) to support scenarios with {{lost and found}} messages. We define a notion of extended compositional <b>message</b> <b>sequence</b> charts (ECMSCs) which subsumes the notion of compositional <b>message</b> <b>sequence</b> charts in expressive power but additionally allows to define lost and found messages explicitly. As usual, ECMSCs can be combined by means of choice and repetition to (extended) compositional <b>message</b> <b>sequence</b> graphs. We show that [...] -despite extended expressive power [...] -model checking of monadic second-order logic (MSO) for this framework remains to be decidable. The key technique to achieve our results is to use an extended notion for linearizations...|$|R
40|$|In {{scheduling}} {{the transmission}} of messages in a WDM network, we are facing not only the channel assignment problem but also <b>message</b> <b>sequencing</b> problem. In this paper, we propose and evaluate a new reservation-based message scheduling algorithm for single-hop, WDM passive star lightwave network which addresses both the assignment aspect and the sequencing aspect of the problem. We compare {{the performance of the}} algorithm which only addresses the channel assignment issue with the performance of our new algorithm theoretically and experimentally and demonstrate that our new algorithm has significant improvement over the performance of a WDM network with a scheduling algorithm that does not consider the <b>message</b> <b>sequencing</b> problem. As a result, we anticipate that this research can open new directions into the problem of message scheduling on WDM networks...|$|E
40|$|This {{document}} {{describes a}} mechanism to add origin authentication, message integrity, replay resistance, <b>message</b> <b>sequencing,</b> and detection of missing messages to the transmitted syslog messages. This specification {{is intended to be}} used in conjunction with the work defined in RFC 5424, "The Syslog Protocol". Status of This Memo This is an Internet Standards Track document. This document {{is a product of the}} Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by th...|$|E
40|$|Abstract. Building {{conversation}} protocols {{has traditionally}} been an art more than a science, as their construction is often guided by designers’ intuition rather than by a principled approach. In this paper we present a model for building conversation protocols using inference principles that allow the computational specification and verification of <b>message</b> <b>sequencing</b> and turn-taking. This model, {{which is based on}} the negotiation of social commitments, results in highly flexible protocols that support agent heterogeneity while abiding by software engineering practices. We exemplify the specification of protocols using the contract net protocol, a common interaction protocol from the multiagent literature. ...|$|E
40|$|This {{article is}} {{organized}} as follows: section 2 introduces our notation for <b>Message</b> <b>Sequence</b> Charts. Then, section 3 shows how a basic <b>Message</b> <b>Sequence</b> Chart can be decomposed into {{a set of}} basic patterns. Section 4 introduces the notion of irreducible <b>message</b> <b>sequence</b> charts, a kind of "normal form" based on composition of basic patterns. Section 5 provides an algorithm for computing an irreducible form for a HMSC, before conclusion. 2 Notation...|$|R
40|$|<b>Message</b> <b>Sequence</b> Charts is a {{graphical}} and textual {{language for}} the description and speci cation {{of the interactions}} between system components and their environment. The language is standardized by the ITU-TS (the Telecommunication Standardization section of the International Telecommunication Union, the former CCITT). The main area of application for <b>Message</b> <b>Sequence</b> Charts is as an overview specication of the communication behavior of real-time systems, in particular telecommunication switching systems. <b>Message</b> <b>Sequence</b> Charts {{may be used for}} requirement specication, interface spec-i cation, simulation and validation, test-case specication and documentation of real-time systems. In this paper we present a formal semantics of <b>Message</b> <b>Sequence</b> Charts exploiting techniques from process algebra. This semantics is proposed for standardization within the ITU-TS. We start with the semantics of the core language of <b>Message</b> <b>Sequence</b> Charts, Basic <b>Message</b> Se-quence Charts, and subsequently add other features such as process creation and termination, re nement and timer handling. ...|$|R
40|$|In {{a network}} {{computing}} platform, tasks compete with others for shared resources to communicate messages. Incremental computing masks communication latency by overlapping computation with communication. However, a <b>sequence</b> of <b>messages</b> {{with a large}} latency variance still makes computations proceed intermittently. In this paper, {{the impact of the}} <b>message</b> <b>sequence</b> on computation efficiency is studied and a framework which employs a well organized <b>message</b> <b>sequence</b> to maximize the efficiency of computations is introduced. Firstly, a network computing model for performing incremental computations is proposed. Based on the model, theorems are developed as the groundwork based on which algorithms for finding a well organized <b>message</b> <b>sequence</b> are derived. Finally, algorithms which find a well organized <b>message</b> <b>sequence</b> in 1 ((r k...|$|R
40|$|<b>Message</b> <b>sequencing</b> {{and channel}} {{assignment}} are two important aspects {{to consider in}} optimizing the performance of Wavelength Division Multiplexing (WDM) networks. A scheduling technique, Multiple-Messagesper -Node with Shortest Job First priority (MMN-SJF), has been proposed to tackle these two areas simultaneously and offers a globally optimizing approach to scheduling. In this paper, a reconfigurable testbed consisting of several interconnected FPGAs for analyzing such scheduling algorithms is introduced and in particular, a prototype scheduler is developed to investigate the implementation and hardware complexity associated with MMN-SJF. We find that the MMN-SJF scheduling technique can be implemented cost effectively and with only simple logic blocks. 1. Introduction Wavelength Division Multiplexing (WDM) is an effective way of utilizing the large bandwidth of an optical fiber. By allowing multiple messages to be transmitted in parallel, {{on a number of}} channels, this t [...] ...|$|E
40|$|In {{cell lines}} derived from {{patients}} with multiple myeloma (MM) {{we have found}} an elevation {{in the amount of}} the c-myc protein which is not accompanied by an increase in the level of mRNA or a change in the half-life of the protein. There is a 3. 4 fold enhancement in the degree of association of the c-myc message with polysomes. This is not accompanied by an alteration in polysome size or a change in the transit time of the c-myc mRNA on the polysomes thus suggesting that there is in increase in the degree of mobilisation of the c-myc <b>message.</b> <b>Sequencing</b> of the c-myc 5 'UTR has revealed the presence of a mutation in all the MM cell lines studied and we demonstrate that this mutation causes altered binding of cellular proteins to this RNA species...|$|E
40|$|The {{complexity}} and efficiency {{aspects of a}} distributed application protocol (e. g., replicated data access, decentralized commit) are often intertwined with the application-specific communication requirements between protocol entities and the underlying support for communication. For example, the choice between recovery by application from a mis-ordered message delivery versus providing message ordering property in the communication layer (CL) is based on tradeoffs between protocol {{complexity and}} efficiency. The paper systematically analyzes these tradeoffs in a quantitative manner. The analysis is based on message ordering and atomicity, which refer to consistent event ordering at protocol entities. Enforcing these properties in the CL leads to uniform communication structure of applications. However, the CL incurs message and execution time overhead due {{to the need to}} maintain extensive communication state (e. g., <b>message</b> <b>sequencing).</b> When these properties are not supported by CL but a [...] ...|$|E
40|$|Circuitry {{simultaneously}} inserts message framing {{information and}} detects noise errors in binary code data transmissions. Separate message groups are framed without requiring both framing bits and error-checking bits, and predetermined <b>message</b> <b>sequence</b> {{are separated from}} other <b>message</b> <b>sequences</b> without being hampered by intervening noise...|$|R
40|$|When one transmits {{a secret}} <b>message</b> <b>sequence</b> on a random number type {{subliminal}} channel, he/she has {{to convert the}} secret <b>message</b> <b>sequence</b> into a (practically) indistinguishable random number sequence first, and then embeds it on a carrier sequence. Otherwise the carrier sequence could be distinguished from one that contains no secret message. If others can distinguish whether a secret <b>message</b> <b>sequence</b> {{is embedded in the}} carrier sequence, the carrier sequence cannot be a subliminal channel. That is, a converter to convert any <b>message</b> <b>sequence</b> into a (practically) indistinguishable one is required. Moreover in many applications of subliminal channels, the deconverter corresponding to the converter should be self-synchronized with the converted sequence, because additional information to synchronize reduces the indistinguishability. Therefore, both (practical) indistinguishability and self-synchronization are required to the converter for subliminal channels. Vernum encryption can convert any <b>message</b> <b>sequences</b> into perfectly indistinguishable random number sequences. However the receivers cannot decode the <b>message</b> <b>sequences</b> from anywhere of the converted sequences without any knowledge of the synchronization. On the contrary, (ECB), CBC, CFB mode block ciphers and self-synchronizing stream ciphers can realize the self-synchronization. However, most of the output sequences can be distinguished from real or well-designed random number sequences by using the birthday paradox distinguishers we propose in this paper under some conditions...|$|R
40|$|<b>Message</b> <b>sequence</b> charts (MSC) are {{commonly}} used in designing communication systems. They allow describing the communication skeleton of a system {{and can be used}} for finding design errors. First, a specification formalism that is based on MSC graphs, combining finite <b>message</b> <b>sequence</b> charts, is presented. We present then an automatic validation algorithm for systems described using the <b>message</b> <b>sequence</b> charts notation. The validation problem is tightly related to a natural language-theoretic problem over semi-traces (a generalization of Mazurkiewicz traces, which represent partially ordered executions). We show that a similar and natural decision problem is undecidable. ...|$|R
40|$|Sequencing {{messages}} and channel assignment are two important issues {{that need to}} be addressed in scheduling messages in a WDM network. Channel assignment addresses the problem of choosing an appropriate data channel via which a message is transmitted to a node. This problem has been addressed extensively in the literature. Among reservation-based techniques, <b>message</b> <b>sequencing</b> which addresses the order in which messages are sent, has rarely been addressed. In this paper, we propose a set of reservation-based scheduling techniques for single-hop, WDM passive star networks which address both the sequencing aspect and the assignment aspect of the problem. Two priority schemes for sequencing messages, and their performance tradeoffs are also discussed in the paper. We evaluate the proposed algorithms by comparing their performance with an algorithm that only addresses the assignment problem, through a number of experiments. The results of the experiments show significant improvements in pe [...] ...|$|E
40|$|Summary: This {{paper is}} first a plea that formal methods {{researchers}} start studying and building {{support for the}} plethora of concurrency APIs being proposed. Formal methods researchers have shown heightened interest {{on the topic of}} transaction memories. However, a corresponding level of interest on other APIs (elaborated below) is lacking. Second, this paper explores ideas on how GUIs for formal methods tools applicable to real world concurrency APIs might differ from other GUIs (such as for traditional debuggers). While many ideas, such as <b>message</b> <b>sequencing</b> charts, have been pioneered in tools such as SPIN [1], each proposed concurrency API has enough nuances of concurrency, resource usage, communication, and synchronization that every attempt must be made to display them in an intuitively appealing manner. This paper elaborates on these statements, and then walks the reader through these features of ISP [5, 6], our push-button dynamic formal verifier of Message Passing Interface [3] (MPI) programs. ISP has a graphical user interface (GUI) that is particularly tailored to give users insights into the message passing concurrenc...|$|E
40|$|Splicing {{mutations}} {{account for}} approximately 10 % of lesions causing genetic diseases, but few branchpoint sequence (BPS) lesions have been reported. In 3 families with autosomal recessive {{congenital erythropoietic porphyria}} (CEP) resulting from uroporphyrinogen III synthase (URO-synthase) deficiency, sequencing the promoter, all 10 exons and the intron/exon boundaries did not detect a mutation. Northern analyses of lymphoblast mRNAs from 2 patients and reverse-transcribed polymerase chain reaction (RT-PCR) of lymphoblast mRNAs from all 3 patients revealed multiple longer transcripts involving intron 9 {{and low levels of}} wild-type <b>message.</b> <b>Sequencing</b> intron 9 RT-PCR products and genomic DNA in each case revealed homozygosity for a novel BPS mutation (c. 661 - 31 T→G) and alternatively spliced transcripts containing 81, 246, 358, and 523 nucleotides from intron 9. RT-PCR revealed aberrant transcripts in both wild-type and CEP lymphoblasts, whereas BPS mutation reduced the wild-type transcript and enzyme activity in CEP lymphoblasts to approximately 10 % and 15 % of normal, respectively. Although the + 81 -nucleotide alternative transcript was in-frame, it only contributed approximately 0. 2 % of the lymphoblast URO-synthase activity. Thus, the BPS mutation markedly reduced the wild-type transcript and enzyme activity, thereby causing the disease. This is the first BPS mutation in the last intron, presumably accounting for the observed 100 % intron retention without exon skipping...|$|E
40|$|<b>Message</b> <b>Sequence</b> Charts are {{a widely}} used {{technique}} for the visualization {{of the communication}} between system components. We present a formal semantics of Basic <b>Message</b> <b>Sequence</b> Charts, exploiting techniques from process algebra. This semantics {{is based on the}} semantics of the full language as being proposed for standardization in the International Telecommunication Union...|$|R
40|$|We {{present a}} {{graphical}} approach to security protocol representation. Protocol runs {{can be viewed}} as <b>Message</b> <b>Sequence</b> Charts. <b>Message</b> <b>Sequence</b> Charts are an appropriate graphical representation of security protocols. We show how sequence charts can be constructed from protocol runs of a broad range of processes in the Security Protocol Language (SPL). In their graphical form, <b>Message</b> <b>Sequence</b> Charts make the behaviour of a protocol easier to understand. They are particularly valuable when runs exhibit undesired behaviour, where they can give a concise account on how to attack protocol weaknesses. The relation between MSCs and SPL process runs is at the basis of the protocol visualization capabilities of the χ-Sim tool. The tool allows developers to simulate protocols programmed in an implementation of SPL. The resulting runs can be rendered graphically as MSCs. Key words: Security Protocols, <b>Message</b> <b>Sequence</b> Charts. ...|$|R
40|$|<b>Message</b> <b>sequence</b> charts are {{a widely}} used {{notation}} to express requirements specifications of multi-agent systems. The semantics of <b>message</b> <b>sequence</b> charts {{can be defined}} algebraically {{in the theory of}} agents and insertion functions. Using this algebra, one can split <b>message</b> <b>sequence</b> chart scenarios into sets of Hoare triples consisting of precondition, the specification of a finite process, and a postcondition. We refer to such triples as “basic protocols. ” In this paper, we discuss tools to prove properties of systems described as basic protocols, such as the completeness (at each of its stages the system behavior has a possible continuation) and consistency (at each stage the system behavior is deterministic) of the specification, or the correspondence of the specified behavior to given scenarios. Together, these tools constitute a powerful environment for the formal verification of requirements specifications expressed through <b>message</b> <b>sequence</b> charts. 1...|$|R
40|$|Nowadays, {{the spread}} of {{computer}} networks and Internet increases dramati- cally the number of end users who, at the same time, become more demand- ing {{in terms of the}} provided capacity as well as the provided Internet services and applications. Optical networking using Wavelength Division Multiplex- ing (WDM) o ers an excellent way to exploit the huge bandwidth of optical bers and, thus, it is the most promising technology for coping with the aforementioned demands and meeting both present and future needs. Using the star topology, a WDM network can be con gured as a broadcast-and- select network in which all of the inputs from the various network nodes will be combined by a passive star coupler via two-way bers. An important issue in such WDM networks is to specify the way that the nodes transmit on the available channels. Thus, a media access control (MAC) protocol is necessary in order to unleash the network's capabilities by introducing a scheduling algorithm which will allocate the network resources in an e#cient way. The rst part of the thesis presents two novel MAC protocols for broadcast- and-select WDM star networks with tunable transmitters and xed re- ceivers. The proposed protocols fall in a special category of pre-transmission coordination-based protocols, since they do not use any control channel and the transmission coordination is accomplished by transmitting control pack- ets over the data channels. Their core idea is based on the observation that the network load is asymmetric and, thus, there is a need of a scheduling scheme which would take into account the speci c demands of each node. The new protocols are based on the use of clustering techniques and, more speci cally, they organize the network's nodes into groups, i. e. clusters, ac- cording to the number of their requests per channel. Based on the obtained clusters, they de ne their transmission priority beginning from the nodes belonging to the cluster with greater demands and ending to the nodes of cluster with fewer requests. In this way, they manage to decrease both the unused timeslots as well as the schedule length and as a result the net- work performance is signi cantly upgraded without aggravating the time complexity of the scheduling algorithm. The protocols presented {{in the second part of}} the thesis are for broadcast- and-select WDM star networks with tunable transmitters and tunable re- ceivers. Channel assignment and <b>message</b> <b>sequencing</b> are two main key issues that have to be addressed when designing MAC protocols for these networks. Up to now, popular scheduling techniques consider either channel assignment or <b>message</b> <b>sequencing</b> issue but not both of them, and, thus, they su er from low performance, especially when operating under heavy tra#c. The proposed protocols of this part are also based on clustering techniques, as the ones of the rst part, but in this case both the criterion and aim of clustering is di erent. More speci cally, these protocols cre- ate groups of similar source nodes on the basis of the destination nodes of their messages and their goal is to decrease the probability of scheduling consecutive messages to the same destination. Extensive simulation results are presented which indicate that the proposed schemes lead to a signi - cantly higher throughput-delay performance, in comparison to conventional scheduling algorithms. It is important to be noted that this is the rst time that clustering techniques are applied to the MAC layer and to the optical networks generally. ...|$|E
40|$|A {{development}} scheme for complex reactive systems leads from a userfriendly requirements capture method, called play-in scenarios, to full behavioral descriptions of system parts, {{and from there}} to final implementation. In a 1992 Computer article, 1 I tried to present an optimistic view of the future of development methods for complex systems. Research since then only supports this optimism, as I will attempt to show. This article presents a general, rather sweeping {{development scheme}}, combining ideas that have been {{known for a long time}} with more recent ones. The scheme makes it possible to go from a high-level userfriendly requirements capture method—which I call play-in scenarios—via a rich language for describing <b>message</b> <b>sequencing</b> to a full model of the system, {{and from there to}} final implementation. A cyclic process of verifying the system against requirements and synthesizing system parts from the requirements is central to the proposal. The article puts special emphasis on the languages, methods, and computerized tools that allow smooth but rigorous transitions between the various stages of the scheme. In contrast to database systems, this article focuses on systems that have a dominant reactive, event-driven facet. For these systems, modeling and analyzing behavior is the most crucial and problematic issue. MODELING THE SYSTEM Over the years, the main approaches to high-level system modeling have been structured-analysis/structured-design (SA/SD) and object-oriented analysis and design (OOAD). The two modeling approaches are about a decade apart in initial conception and evolution. Over the years, both approaches have yielded visual formalisms for capturing the various parts of a An early version of this article appeared in Proc. Fundamenta...|$|E
40|$|While it is {{recognised}} that driver distraction is {{a contributor}} to highway crashes and that roadside advertising may contribute to this distraction, criteria {{for the management of}} roadside advertising devices varies significantly across jurisdictions within Australia and internationally. A significant emerging safety issue is the use of digital display technology for outdoor advertising signs. This technology allows the display of attention-capturing messages that may cause drivers to be even less attentive to the driving task than is the case with traditional roadside advertising. In addition, some recent digital billboards are now capable of “interacting” with drivers, by displaying personalised messages, or by encouraging drivers to call a number displayed on the billboard. The project presented was designed to facilitate the harmonization of road agency criteria for the management of roadside advertising devices and promote improved and consistent good practice by road agencies. It was concluded that fundamental human factors considerations strongly suggest that in some driving situations {{it is likely that the}} movement or changes in luminance created by digital displays will involuntarily capture attention and that particularly salient emotional and engaging material will recruit attention to the detriment of driving performance, particularly in inexperienced drivers. It is also clear that roadside advertising is distracting and that it may lead to poorer vehicle control. While at this time studies providing direct evidence that roadside advertising plays a significant role in distraction based crashes are currently not available, nevertheless, this is a real risk that must be considered in the provision of a safe system for driving. Guidance principles were designed. These principles were divided into both sign design recommendations and sign placement recommendations and covered factors such as; movement, dwell time, transition time, <b>message</b> <b>sequencing,</b> quantity of information, information content / meaning, luminance, longitudinal placement, lateral placement, vertical placement, orientation / viewing angle, sight distance / visibility, and speed environment...|$|E
40|$|<b>Message</b> <b>Sequence</b> Charts are {{a visual}} {{representation}} of the system specification which shows how all the participating processes are interacting with each other. <b>Message</b> <b>Sequence</b> Graphs provide modularity by easily allowing combination {{of more than one}} <b>Message</b> <b>Sequence</b> Charts to show more complicated system behavior. Requirements modeled as <b>Message</b> <b>Sequence</b> Graphs give a global view of the system as interaction across all the participating processes can be viewed. Thus systems modeled as <b>Message</b> <b>Sequence</b> Graphs are like sequential composition of parallel process. This makes it very attractive during the requirements gathering and review phases as it needs inter-working between different stakeholders with varied domain knowledge and expertise – requirements engineers, system designers, end customers, test professionals etc. In this thesis we give a detailed construction of a finite-state transition system for a com-connected <b>Message</b> <b>Sequence</b> Graph. Though this result is fairly well-known in the literature there has been no precise description of such a transition system. Several analysis and verification problems concerning MSG specifications can be solved using this transition system. The transition system can be used to construct correct tools for problems like model-checking and detecting implied scenarios in MSG specifications. There are several contributions of this thesis. Firstly, we have provided a detailed construction of a transition system exactly implementing the <b>message</b> <b>sequence</b> graph. We have provided the detailed correctness arguments for this construction. Secondly, this construction works for general <b>Message</b> <b>Sequence</b> Graphs and not limited to com-connected graphs alone, although, we show that a finite model can be ensured only if the original graph is com-connected. Also, we show that the construction works for both synchronous and asynchronous messaging systems. Thirdly, we show how to find implied scenarios using the transition model we have generated. We also discuss some of the flaws in the existing approaches. Fourthly we provide a proof of undecidability argument for non com-connected MSG with synchronous messaging...|$|R
40|$|The {{document}} {{presents a}} formal semantics of <b>Message</b> <b>Sequence</b> Charts using techniques from process algebra. The semantic constructions are introduced incrementally. This means that first the semantics of Basic <b>Message</b> <b>Sequence</b> Charts is given, and that subsequently additional features are added until the complete language is covered. Examples are added which explain {{the use of}} the semantic functions...|$|R
40|$|The {{parameter}} of {{the stable}} non-Gaussian noise sequence is modulated by the binary <b>message</b> <b>sequence</b> {{to achieve a}} secure communication system. The characteristic exponent 'alpha' of a stable non-Gaussian noise sequence carries the binary information. The receiver of the proposed random communication system demodulates the received signal by estimating {{the parameters of the}} transmitted noise sequence to recover the binary <b>message</b> <b>sequence...</b>|$|R
40|$|In this thesis, we {{investigate}} {{the problem of}} scheduling and managing variable-length message transmission on single-hop passive-star coupled WDM optical networks. We study this scheduling problem when the specified WDM optical networks provide the following three types of transmission services: ordinary network transmission service, best-effort real-time transmission service, and guaranteed deterministic bounded-delay transmission service. Our main contributions lie in that 1) We have put forward a general technique, which addresses both network resource assignment issue and the message transmission sequencing issue within a single framework; 2) We have proposed a set of scheduling algorithms {{which can be used}} to schedule variable-length message transmission with or without time constraints; and 3) We have set up a systematic scheme to provide guaranteed deterministic bounded-delay service to real-time application streams composed of variable-length messages. In particular, we have proposed and investigated the following algorithms which are original ideas for scheduling and managing variable-length message transmission. The Frame Shortest Job First Serve (F-SJF) algorithm, the Frame Longest Job First Serve (F-LJF) algorithm, the Frame and Queue Shortest Job First Serve (FQ-SJF) algorithm, the Frame and Queue Longest Job First Serve (FQ-LJF) algorithm, the Multiple-message- per-Node Shortest Job First Serve (MMN-SJF) algorithm, and the Multiple-message-per-Node Longest Job First Serve (MMN-LJF) algorithm combine the <b>message</b> <b>sequencing</b> schemes with the channel assignment algorithm to efficiently schedule message tramsmissions on WDM optical networks. The Receiver-Oriented Earliest AvaiLable Time Slot (RO-EATS) algorithm takes advantage of the special properties of the specified WDM network environment to eliminate message transmission blocking and to increase utilization of the network resources. The Frame Minimum Laxity First Serve (F-MLF) algorithm and the Frame and Queue Minimum Laxity First Serve (FQ-MLF) algorithm are designed to efficiently schedule the transmission of variable-length messages with time constraints. We have proposed an admission control algorithm called Sum Subset Search (SSS) algorithm which considers multiple application streams simultaneously requesting guaranteed deterministic bounded-delay service and evaluates which of the new application streams can be accepted. We have also proposed another scheduling algorithm called Adaptive Round-Robin Earliest AvaiLabLe Time Slot (ARR-EATS) algorithm which is dedicated to scheduling the transmission of variable-length message to ensure their deterministic bounded-delay service. All of those scheduling algorithms have been evaluated by both simulation experiments and mathematical models. They have been proved to be efficient scheduling algorithms in the specified WDM optical networks and could contribute to the design of future generation multimedia WDM optical networks...|$|E
40|$|In {{the article}} ”From Play-In Scenarios to Code: An Achievable Dream” [8] D. Harel {{outlines}} an exiting {{new way of}} developing software {{with the aid of}} the new and expressively powerful language of live sequence charts (LSC) [1] for describing <b>message</b> <b>sequencing.</b> The language of LSC is a highly visual approach for modeling behavioral requirements and is based on message sequence charts [13]. LSC introduces the ability to specify mandatory behavior in charts through the notion of “liveness”, events that must happen. The development process described involves using a friendly capture method called “play-in” to create the behavioral requirements in the formal LSC language. Algorithms are then used to synthesize system behavior parts from the requirements and the system can in turn be verified against the requirements. Cyclic synthesis and verification is used until a sufficient system model has been created. From the system model, code and final implementation can be generated. This thesis is a study of the language of LSC and how code generation can be applied in different stages of this development process. We present the constructs and elements of the LSC language and further extensions of the specification. The method for executing LSCs called “play-out” is also presented. Three applications of code generation in the development process are introduced. We explore the possibility synthesizing system behavior in the form of statecharts from LSCs, and from there using developed tools to generate the actual code. Only an outline of a synthesis algorithm is available, and we present the main aspects of it. The “playout” methodology is a way of executing LSCs. We outline a methodology for integrating a “play-out” engine into a partial implemented system in order to execute it as it was fully operational. This allows us to test the behavioral requirements or utilize the result as a final implementation. We also present a way of generating code directly from an LSC specification with certain constraints, and thus circumventing the need for a system model with behavior. We have developed a tool called “LSC Visualizer”, which is able to read LSCs stored in our own XML format. We have also developed a prototype “play-out” engine that can be coupled with existing system models as well as a prototype for generating code directly from an LSC specification. An algorithm for building an event-tree that describes the partial order has been constructed, and is utilized by the “LSC Visualizer” and both prototypes...|$|E
40|$|Masteroppgave i informasjons- og kommunikasjonsteknologi 2003 - Høgskolen i Agder, GrimstadIn {{the article}} ”From Play-In Scenarios to Code: An Achievable Dream” [8] D. Harel {{outlines}} an exiting {{new way of}} developing software {{with the aid of}} the new and expressively powerful language of live sequence charts (LSC) [1] for describing <b>message</b> <b>sequencing.</b> The language of LSC is a highly visual approach for modeling behavioral requirements and is based on message sequence charts [13]. LSC introduces the ability to specify mandatory behavior in charts through the notion of “liveness”, events that must happen. The development process described involves using a friendly capture method called “play-in” to create the behavioral requirements in the formal LSC language. Algorithms are then used to synthesize system behavior parts from the requirements and the system can in turn be verified against the requirements. Cyclic synthesis and verification is used until a sufficient system model has been created. From the system model, code and final implementation can be generated. This thesis is a study of the language of LSC and how code generation can be applied in different stages of this development process. We present the constructs and elements of the LSC language and further extensions of the specification. The method for executing LSCs called “play-out” is also presented. Three applications of code generation in the development process are introduced. We explore the possibility synthesizing system behavior in the form of statecharts from LSCs, and from there using developed tools to generate the actual code. Only an outline of a synthesis algorithm is available, and we present the main aspects of it. The “playout” methodology is a way of executing LSCs. We outline a methodology for integrating a “play-out” engine into a partial implemented system in order to execute it as it was fully operational. This allows us to test the behavioral requirements or utilize the result as a final implementation. We also present a way of generating code directly from an LSC specification with certain constraints, and thus circumventing the need for a system model with behavior. We have developed a tool called “LSC Visualizer”, which is able to read LSCs stored in our own XML format. We have also developed a prototype “play-out” engine that can be coupled with existing system models as well as a prototype for generating code directly from an LSC specification. An algorithm for building an event-tree that describes the partial order has been constructed, and is utilized by the “LSC Visualizer” and both prototypes...|$|E
40|$|<b>Message</b> <b>Sequence</b> Charts are {{a popular}} {{formalism}} {{for the design}} of distributed systems executions based on pomset composition. However, this formalism in its basic form is not expressive enough to model typical behaviors such as sliding windows executions. A solution is to embed in MSCs the expressive power of communicating automata, as in CMSCs (another extension of <b>Message</b> <b>sequence</b> charts). However, most basic problems become undecidable for CMSCs. This paper proposes an extension to <b>message</b> <b>sequence</b> charts which extends the expressive power of MSCs while preserving the decidability of some properties. This modification extends sequential composition, but still rely on compositions of closed communication patterns (messages are emitted and received in the same pomset). This paper gives a definition of this new formalism called ``sliding'' <b>message</b> <b>Sequence</b> charts (or SMSCs). SMSCs can be ill-formed, and we provide a decision procedure to detect and transform such SMSCs inti well-formed ones. Then, the expressive power of SMSCs is compared to that of HMSCS, CMSCs, sure CMSCs and HMSC projections...|$|R
5000|$|MSC <b>Message</b> <b>Sequence</b> Chart. Another ITU-T related {{notation}} {{to describe}} the dynamic behavior of a system.|$|R
5000|$|PragmaDev Studio can {{generate}} TTCN-3 test cases out of <b>Message</b> <b>Sequence</b> Charts {{resulting from a}} simulation.|$|R
