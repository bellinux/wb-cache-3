0|3025|Public
40|$|Various {{types of}} survey errors, {{especially}} nonresponse errors, may seriously deteriorate data quality. Nonresponse has more one {{reason to worry}} about its harmful effects on the survey estimates. So, nonresponse and methods dealing with nonresponse have increasingly become a standard part of survey sampling. A nonresponse occurs in a survey when, for any reason, a selected unit does not respond. The usual methods of estimation {{in the presence of}} nonresponse give biased results. Because of this special estimation techniques are required to deal with the problem. Imputation and reweighting are two standard methods provided by the literature for treating nonresponse. In the recent years, scientist became increased to concern with the calibration approach to reweigthing method in the presence of nonresponse. The calibration approach generates the final weights which are {{as close as possible to}} specified design weights, while respecting known auxiliary population totals or unbiased estimates of these totals. This calibration procedure requires the formulation of a suitable auxiliary vector, through a selection from a possible larger set of auxiliary variables. In this study standard methods for the reduction of bias and errors arising from nonresponse are explained. The calibration approach is examined as theoretically and simulation is performed by <b>macro</b> <b>generated</b> in C++ <b>programming</b> language to study how alternative specifications of the auxiliary vector affect the quality of estimators derived by the calibration technique. In the application, the calibration estimators and quality measures such as relative bias, variance are computed and interpreted for the population total...|$|R
40|$|Using the SAS ® <b>Macro</b> {{language}} to <b>generate</b> data listing <b>programs</b> {{eliminates the need}} to create these programs from scratch. In most cases the programs are simple – consisting primarily of proc report statements. Using the SAS ® <b>Macro</b> {{language to}} <b>generate</b> these statements automatically can significantly {{reduce the amount of}} time required to write these programs. Once the listing <b>programs</b> are <b>generated,</b> it can be edited, and modified. Macro %Gen-list Logic: The %Gen-list macro requires the library reference to your data (i. e., libin: the library name where the SAS dataset resides), and name of the dataset (i. e., dsn). If you would like to produce one data list you should choose dsn=DM or {{if you would like to}} produce all the data listings choose _all_. The macro default value for the dsn parameter _all _ is used to generate the whole library listing. Another option to store your <b>generated</b> <b>programs</b> is outdir (i. e., the output directory to store the <b>generated</b> <b>program).</b> The <b>macro</b> uses the contents procedure to identify the name of each dataset and each variable and attribute. These will be used to create a SAS program consisting of proc report statements using the information that was gathered from the contents procedure. The outpu...|$|R
50|$|TELON is an {{application}} code generator that uses <b>macros</b> to <b>generate</b> COBOL, COBOL/II, or PL/I code that can run natively {{in the target}} environment without run-time proprietary code. Developers create screen designs in the TELON Design Facility (TDF) and define attributes for the screen. The design can then be run through a prototyper to test screen flow. Next, <b>macros</b> <b>generate</b> the code using the information created by the TDF. Lastly, the TELON Test Facility is used, in conjunction with code debuggers, to search for and fix bugs before the application is moved into production.|$|R
50|$|Most {{assemblers}} provide <b>macros</b> to <b>generate</b> common {{sequences of}} instructions.|$|R
40|$|The SAS ® macro {{facility}} {{is a great}} tool for adding flexibility to your programs. You can create a <b>macro</b> that will <b>generate</b> pieces of code on the fly, and then use that macro to insert the code later in your program. By doing this, you can alter the way a program works without having to hard-code the changes. Even a <b>macro</b> that <b>generates</b> a small section of code can be very helpful {{if you are using}} a program repeatedly. This paper offers a simple example of a macro that illustrates this idea. This <b>macro</b> <b>generates</b> a list that is used in a WHERE statement inside a data step to select the records that are read from another data set. This paper is intended for SAS users of all skill levels...|$|R
5000|$|There {{are many}} fractal <b>generating</b> <b>programs</b> available, both free and commercial. Notable fractal <b>generating</b> <b>programs</b> include: ...|$|R
50|$|VBA code {{interacts with}} the {{spreadsheet}} through the Excel Object Model, a vocabulary identifying spreadsheet objects, {{and a set of}} supplied functions or methods that enable reading and writing to the spreadsheet and interaction with its users (for example, through custom toolbars or command bars and message boxes). User-created VBA subroutines execute these actions and operate like <b>macros</b> <b>generated</b> using the <b>macro</b> recorder, but are more flexible and efficient.|$|R
40|$|In {{order to}} {{increase}} the readability of the <b>generated</b> <b>programs,</b> a decompiling system has been implemented which integrates a decompiler, dcc, and an automatic signature generator, dccSign. Signatures for libraries and compilers are stored in a database that is read by the decompiler, thus, the <b>generated</b> <b>programs</b> can make use of known library names, such as WriteLn() and printf() ...|$|R
40|$|Robustness is {{essential}} for <b>programs</b> <b>generated</b> by Genetic <b>Programming</b> (GP). This paper presents a method to improve the robustness. The method employs non-determinism in two ways: one is to evolve robot programs in noisy environments and another is to use probabilistic branch in the function set. The experiment is carried out on robot navigation problems. The result of the experiment shows that the robustness of robot programs has been improved. The analysis shows that the robustness {{is caused by the}} acquired "experience" and the amount of reuse of this experience while performing the task. Key words: Robustness, Robot programs, Non-determinism, Evolutionary Computation, Genetic Programming 1. Introduction Artificial Intelligence (AI) has been widely used to automatically <b>generate</b> <b>programs.</b> Genetic Programming (GP) [1] is one of methods that becomes popular in automatic <b>generating</b> <b>programs.</b> Our experiment use GP to <b>generate</b> <b>programs</b> for controlling a robot. GP is performed [...] ...|$|R
2500|$|It is also {{possible}} to use solely the macro processing abilities of an assembler to generate code written in completely different languages, for example, to generate a version of a program in COBOL using a pure macro assembler program containing lines of COBOL code inside assembly time operators instructing the assembler to generate arbitrary code. IBM OS/360 uses macros to perform system generation. The user specifies options by coding a series of assembler macros. [...] Assembling these <b>macros</b> <b>generates</b> a job stream to build the system, including job control language and utility control statements.|$|R
5000|$|Quiz/exam <b>generating</b> <b>program</b> allows {{professors to}} design tests {{in a variety}} of formats ...|$|R
50|$|Similarly, forms {{generators}} manage online {{interactions with}} the application system users or <b>generate</b> <b>programs</b> to do so.|$|R
40|$|Run-time {{specialization}} (RTS) is {{a technique}} that e#ciently <b>generates</b> specialized <b>programs</b> with respect to runtime values. For e#ciently <b>generating</b> specialized <b>programs,</b> RTS constructs compiled native code fragments called templates at compile-time, and <b>generates</b> a specialized <b>program</b> by merely copying the templates. The <b>generated</b> <b>programs</b> are, on the other hand, less e#cient, since the technique prevents many optimizations. This study proposes bytecode specialization (BCS), which <b>generates</b> <b>programs</b> in a bytecode language, and then translates the generated bytecode into native code by using Just-In-Time (JIT) compilers. The advantages of BCS are: (1) e#cient specialization processes {{that are similar to}} RTS, (2) e#cient specialized programs thanks to the optimizations of JIT compilers, and (3) independence of source-to-bytecode compilers and of bytecode-to-native compilers thanks to our proposed binding-time analysis, which directly handles bytecode programs. Thus far, we have implement [...] ...|$|R
2500|$|Jhc, a Haskell {{compiler}} {{written by}} John Meacham, emphasizes speed {{and efficiency of}} <b>generated</b> <b>programs</b> and exploring new program transformations.|$|R
5000|$|Frieder Nake: On {{generative}} aesthetics - two picture <b>generating</b> <b>programs.</b> Proc. of the International Symposium Computer Graphics, Uxbridge: Brunel University 1970 ...|$|R
5000|$|Jhc is a Haskell {{compiler}} {{written by}} John Meacham emphasising speed {{and efficiency of}} <b>generated</b> <b>programs,</b> and exploring new program transformations.|$|R
5000|$|The <b>GENERATE</b> <b>macro</b> in the Sysgen input {{can be any}} {{of several}} types: ...|$|R
40|$|Contrasts are an {{important}} component of the armamentarium of the statistician. In the SAS/STAT R○ GLM, ANOVA, MIXED, and GENMOD procedures, the contrasts are used to answer specific additional questions. In many cases, it is difficult to define contrasts which are estimable, or correctly formed. A macro which converts a question about differences between cells (defined in several ways) into estimable contrasts is described. This macro uses SAS/IML R ○ to convert the comparison into the various components of the comparison into SAS R ○ system contrasts. Using several macro components unique to the SAS/IML system, the <b>macro</b> <b>generates</b> contrasts which are invariably estimable...|$|R
40|$|Run-time {{specialization}} (RTS) techniques e#ciently <b>generate</b> specialized <b>programs</b> {{with respect}} to run-time values. They construct compiled native-code fragments called templates at compile-time, and <b>generate</b> a specialized <b>program</b> by merely copying the templates. The <b>generated</b> <b>programs</b> are less e#cient than those generated by static partial evaluation techniques because the RTS techniques prevent many optimizations. The proposed bytecode specialization (BCS) technique is used to <b>generate</b> <b>programs</b> in a bytecode language and then translate the generated bytecode into native code by using a just-in-time (JIT) compiler. Its advantages are (1) e#cient specialization processes {{that are similar to}} those of RTS techniques, (2) e#cient specialized programs thanks to optimizations by the JIT compilers, and (3) that it is independent of the source-to-bytecode and the bytecode-to-native compilers thanks to a binding-time analysis algorithm that directly handles bytecode programs. Th [...] ...|$|R
40|$|During {{the last}} year we built several {{solutions}} for opening our ET++ applications for internal and external scripting. The most annoying part to be coded manually was the code stubs that translate a string based request into the invocation of a member function. For this reason we built an ET++ specific solution that provides dispatchable member functions in an inexpensive, non-intrusive way. Our solution consists of {{an extension of the}} <b>macro</b> <b>generated</b> ET++ run time meta information. To make a member function dispatchable, a developer has to write one <b>macro</b> call. This <b>generates</b> a member function meta object providing information about arguments and a function that serves to invoke the respective member function. These two generated parts work {{in the context of the}} dynamic invocation framework, which embodies an architecture that can be customized for varying interfacing needs. 1. Introduction Our team has been developing interactive standalone applications based on the ET++ applicati [...] ...|$|R
50|$|Images of fractals can {{be created}} by fractal <b>generating</b> <b>programs.</b> Because of the {{butterfly}} effect a small change in a single variable can have a unpredictable outcome.|$|R
40|$|Software {{product line}} {{engineering}} is one approach to implement sets of related programs efficiently. Software product lines (SPLs) {{can be implemented}} by code transformations which are combined in order to <b>generate</b> a <b>program.</b> A code transformation may add functionality to a base program or may alter its structure. Though implemented with less effort, <b>generated</b> <b>programs</b> are harder to debug because debug changes must effect the SPL transformations which the program was built from. In this paper, we present {{a new approach to}} debug programs (of an SPL) <b>generated</b> by <b>program</b> transformations...|$|R
40|$|By design, the SRC- 6 {{reconfigurable}} {{computer is}} programmed in the MAP C programming language {{within the framework}} provided by the SRC Carte ™ development environment. The functionality of the original language can be extended via third party subroutines, called macros. These macros, typically implemented in Verilog Hardware Description Language, are brought into the MAP C program via configuration files that define the interface between the macros and the MAP C language. In this paper, we describe a process of using the Verilog source for SRC <b>macros</b> <b>generated</b> from the MathWorks Simulink ® designs built using Xilinx System Generator ™ for DSP and Xilinx Blockset. We also describe an example application that takes advantage of this programming model...|$|R
50|$|The Air Force Armament Museum Foundation is a {{volunteer}} body {{that runs the}} fund <b>generating</b> <b>programs</b> of the Armament Museum and decides how funds donated to the museum are spent.|$|R
5000|$|... "WTO" [...] is an {{assembler}} <b>macro</b> that <b>generates</b> {{an operating}} system call. Because of saving registers and later restoring and returning, this small program is usable as a batch program invoked {{directly by the}} operating system Job control language (JCL) like this: ...|$|R
40|$|The paper {{addresses}} {{the issue of}} microprocessor and microcontroller testing, and follows an approach based on the generation of a test program. The proposed method relies on two phases: in the first, a library of code fragments (named <b>macros)</b> is <b>generated</b> by hand based on {{the knowledge of the}} instruction set, only. In the second phase, an optimization algorithm is run to suitably select macros and values for their parameters. The algorithm only relies on RT-level information, and exploits a suitable RT-level fault model to guide the test program generation. A major advantage of the proposed approach {{lies in the fact that}} it does not require any knowledge about the low level implementation of the processor. Experimental results gathered on an i 8051 model using a prototypical implementation of the approach show that it is able to <b>generate</b> test <b>programs</b> whose gate-level fault coverage is higher than the one obtained by comparable gate-level ATPG tools, while the computational effort and the length of the <b>generated</b> test <b>program</b> are similar. The method is thus suitable to be applied during the incoming inspection test phase performed on small processors, and for developing implementation-independent test suites for soft IP cores. 1...|$|R
50|$|SMT solvers {{are useful}} both for verification, proving the {{correctness}} of programs, software testing based on symbolic execution, and for synthesis, <b>generating</b> <b>program</b> fragments by searching over {{the space of}} possible programs.|$|R
40|$|Abstract. In feature-oriented programming, {{a feature}} is an {{increment}} in program functionality and is implemented by a feature module. <b>Programs</b> are <b>generated</b> by composing feature modules. A <b>generated</b> <b>program</b> {{may be used}} by other client programs but occasionally must be transformed to match a particular legacy interface {{before it can be}} used. We call the mismatch of the interface of a <b>generated</b> <b>program</b> and a client-desired in-terface an incompatibility. We introduce the notion of refactoring feature modules (RFMs) that extend feature modules with refactorings. We ex-plain how RFMs reduce incompatibilities and facilitate reuse, and report our experiences on five case studies. ...|$|R
50|$|StructuralEquality, Memoize, json, {{and with}} are <b>macros</b> which <b>generate</b> code in compile time. Though {{some of them}} (StructuralEquality, Memoize) can look like C# attributes, during compiling, they will be {{examined}} by the compiler and transformed to appropriate code using logic predefined by their macros.|$|R
40|$|T-EDIT is a {{powerful}} collection of editing macros designed specifically for TEX. The macros {{are designed to be}} used with the KEDIT editor on IBM PC or PC-compatible computers. The user is aided in every step of the preparation of a completed document. Menus or prompting messages are included with many of the macros. Over 1250 TEX andAMS-TEX control sequences may be accessed through menus. The control sequences may either be inserted directly into the text or assigned to function keys. T-EDIT can be used to control the TEXing and possible previewing of output. Debugging features are included. <b>Macros</b> <b>generating</b> several lines of complicated TEX source code are available, and TEX macros have been designed to be used with several of the code-generating macros...|$|R
40|$|Several {{techniques}} for <b>generating</b> readable <b>programs</b> from SDL specifications are presented. These techniques {{can be used}} to produce programs in a standard object-oriented programming language which preserve the appearance of the source SDL specification. The main technique is to postpone most semantic transformations until the run-time of the generated system. We show how the so-called start-up time of the <b>generated</b> <b>program</b> {{can be used to}} restructure it from a readable form (which is used for inspections) into efficient run-time structures (which are used to execute it within the corresponding run-time support system). We present some details of the new approach and compare it with a few other code generators. We show that the application of the new techniques does not imply any loss of efficiency of the <b>generated</b> <b>programs</b> as compared to more conventional approaches [...] H...|$|R
50|$|Aside {{from these}} reach-out activities, the Community Extension Service of SRCB {{extended}} its expertise through different {{programs such as}} SRCB Trisikad Livelihood Project, MISTP Trainers' Financial Loan Program, Micro-Entrepreneurs' Loan Program and Women's Income <b>Generating</b> <b>Program.</b>|$|R
40|$|Abstract: Genetic {{programming}} {{is a powerful}} technique for automatically <b>generating</b> <b>program</b> code from {{a description of the}} desired functionality. However it is frequently distrusted by users because the <b>programs</b> are <b>generated</b> with reference to a training set, and there is no formal guarantee that the <b>generated</b> <b>programs</b> will operate as intended outside of this training set. This paper describes a way of including constraints into the fitness function of a genetic programming system, so that the evolution is guided towards a solution which satisfies those constraints and so that a check can be made when a solution satisfies those constraints. This is applied to a problem in mobile robotics...|$|R
50|$|<b>Macros</b> allow <b>generating</b> {{boilerplate}} code {{with added}} static checks {{performed by the}} compiler. They {{reduce the amount of}} code that must be written by hand, make code generation safer, and allow <b>programs</b> to <b>generate</b> code with compiler checks, while keeping source code relatively small and readable.|$|R
50|$|The next day, Tiki Bar TV {{moved to}} the #1 slot in the iTunes Podcast charts, and as such Tiki Bar TV {{was one of the}} first user <b>generated</b> <b>programs</b> to gain {{worldwide}} popularity via the iTunes distribution model.|$|R
5000|$|The IBM/360 and {{derivatives}} had powerful {{macro assembler}} facilities that were {{often used to}} generate complete assembly language programs [...] or sections of programs (for different operating systems for instance). Macros provided with CICS transaction processing system had assembler <b>macros</b> that <b>generated</b> COBOL statements as a pre-processing step.|$|R
