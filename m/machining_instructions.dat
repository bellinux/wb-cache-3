6|875|Public
50|$|Once {{the design}} of the product’s {{components}} is complete, the method of manufacturing is defined. This includes CAD tasks such as tool design; including creation of CNC <b>Machining</b> <b>instructions</b> for the product’s parts as well as creation of specific tools to manufacture those parts, using integrated or separate CAM (computer-aided manufacturing) software. This will also involve analysis tools for process simulation of operations such as casting, molding, and die-press forming.Once the manufacturing method has been identified CPM comes into play. This involves CAPE (Computer Aided Production Engineering) or CAP/CAPP (Computer Aided production planning) tools for carrying out factory, plant and facility layout and production simulation e.g. press-line simulation, industrial ergonomics, as well as tool selection management.Once components are manufactured, their geometrical form and size can be checked against the original CAD data with the use of computer-aided inspection equipment and software.Parallel to the engineering tasks, sales product configuration and marketing documentation work take place. This could include transferring engineering data (geometry and part list data) to a web based sales configurator and other desktop publishing systems.|$|E
5000|$|The {{operational}} concept of EBF3 {{is to build}} a near-net-shape metal part directly from a computer-aided design (CAD) file. Current computer-aided machining practices start with a CAD model and use a post-processor to write the <b>machining</b> <b>instructions</b> (G-code) defining the cutting tool paths needed to make the part. EBF3 uses a similar process, starting with a CAD model, numerically slicing it into layers, then using a post-processor to write the G-code defining the deposition path and process parameters for the EBF3 equipment. It uses a focused electron beam in a vacuum environment to create a molten pool on a metallic substrate. The beam is translated with respect {{to the surface of the}} substrate while metal wire is fed into the molten pool. The deposit solidifies immediately after the electron beam has passed, having sufficient structural strength to support itself. The sequence is repeated in a layer-additive manner to produce a near-net-shape part needing only finish machining. The EBF3 process is scalable for components from fractions of an inch to tens of feet in size, limited mainly by the size of the vacuum chamber and amount of wire feedstock available.|$|E
40|$|International audienceThis paper {{presents}} an intelligent process planning system for generating <b>machining</b> <b>instructions</b> for prismatic parts. The generated instruction includes machine tool information, machining sequence, tool and setup information, machining parameters, and tool path. In the proposed system, part information is {{received as a}} STEP AP 224 feature model. One novel aspect of the proposed system is implementation of a formal OWL ontology for representation of machine tool and cutting tool capability knowledge as well as part information. OWL-based ontology enables automated ontological reasoning during process planning. Also, SWRL rule modeling approach is adopted for identifying feasible machine tools and cutting tools and also specifying process parameters. A proof-of-concept implementation is presented as well in this paper...|$|E
5000|$|In the {{top most}} {{simulation}} level the microcode simulator continuously executes micro instructions without interrupt. In this level, <b>machine</b> <b>instruction</b> by <b>machine</b> <b>instruction</b> is loaded. So, {{it is possible}} to focus on the interaction of the CPU with external devices.|$|R
25|$|That such minimalism is {{possible}} {{does not mean}} that it is necessarily desirable; after all, computers theoretically need only one <b>machine</b> <b>instruction</b> (subtract one number from another and branch if the result is negative), but practical computers have dozens or even hundreds of <b>machine</b> <b>instructions.</b>|$|R
5000|$|LOADALL, undocumented <b>machine</b> <b>instructions</b> purportedly used by Microsoft's RAMDRIVE.SYS ...|$|R
40|$|Manufacturing {{firms are}} seeking more {{efficient}} methods of CNC manufacture. ISO 14649 informally known as STEP-NC {{has been proposed}} as a high-level hierarchical manufacturing information model {{as a replacement for}} the low-level <b>machining</b> <b>instructions</b> of ISO 6983 and RS 274 D. In this paper, the applicability of STEP-NC as an enabler for creating an adaptive global manufacturing system is examined. The overall framework of the system is presented followed by an outline of its information requirements. Suitability of STEP-NC to support each requirement is then studied with the necessary additions highlighted. Finally, a test component is used in conjunction with a prototype of the advanced global manufacturing system to demonstrate the applicability of the STEP-NC standard to support manufacturing information in such a system. (C) 2006 Elsevier Ltd. All rights reserved...|$|E
40|$|Research {{focused on}} design {{integrated}} CAD and CAM {{has been conducted}} since the 1980 s and will continue {{in order to achieve}} CAD/CAM integration. CAD/CAM systems have become a common tool in industries to design parts and simulate the manufacturing machining. This research focuses on the area of interoperable CNC machining systems and CNC systems based on the evolving STEP-NC standard. This paper describes and illustrates a STEP compliant CAD/CAPP/CAM System for the manufacture of rotational components on CNC turning centres. A structured view of a STEP compliant CAD/CAPP/CAM system framework supporting the next generation of intelligent CNC controllers for turn/mill component manufacture is provided. Finally the proposed system is outlined by the modelling of a turning workstation and through the use of user interface dialogs that depict the information held in the models. The case study demonstrates that the new approach can generate <b>machining</b> <b>instructions</b> equivalent to currently used G-codes for the same component...|$|E
40|$|This is an Author's Accepted Manuscript of {{an article}} {{published}} in the International Journal of Computer Integrated Manufacturing, available online at: [URL] present two methods for process planning of 2. 5 D machined parts. The first method is based on feature recognition from a 3 D model. We embedded the shape and the machining method of two generic classes of machining features in a set of OPS 5 rules to form a machining feature recognizer. When successfully recognizing a machining feature, <b>machining</b> <b>instructions,</b> in terms of the tool entrance face, drive face and part face, for cutting the machining feature will be generated and further processed to produce NC codes. The second method is based on learning the shape and the machining method of the machining feature. When a machining feature cannot be recognized by the former feature recognizer, the user can use the machining feature as a positive training example to instruct the system about the tool entrance face, drive face and part face of the machining feature. The system then builds a new rule, using the boundary shape of the unrecognized machining feature as the rule's matching condition and the acquired machining instruction as the rule's action. The new rule can be used subsequently for process planning of machining features that have shapes similar to the memorized one...|$|E
5000|$|... #Subtitle level 3: Advantages of stack <b>machine</b> <b>instruction</b> sets ...|$|R
5000|$|... #Subtitle level 2: Analogy to {{bytecode}} / virtual <b>machine</b> <b>instruction</b> set ...|$|R
5000|$|The NAR 2 {{processor}} uses 32-bit machine words. Each <b>Machine</b> <b>instruction</b> contains: ...|$|R
5000|$|The {{next logical}} phase is the {{disassembly}} of <b>machine</b> code <b>instructions</b> into a <b>machine</b> independent intermediate representation (IR). For example, the Pentium <b>machine</b> <b>instruction</b> mov eax, ebx+0x04might be translated to the IR eax := mebx+4; ...|$|R
40|$|This book {{presents}} a comprehensive, structured, up-to-date survey on instruction selection. The survey is structured {{according to two}} dimensions: approaches to instruction selection from the past 45 years are organized and discussed according to their fundamental principles {{and according to the}} characteristics of the supported <b>machines</b> <b>instructions.</b> The fundamental principles are macro expansion, tree covering, DAG covering, and graph covering. The <b>machine</b> <b>instruction</b> characteristics introduced are single-output, multi-output, disjoint-output, inter-block, and interdependent <b>machine</b> <b>instructions.</b> The survey also examines problems that have yet to be addressed by existing approaches. The book is suitable for advanced undergraduate students in computer science, graduate students, practitioners, and researchers. QC 20160810 </p...|$|R
5000|$|... efficiency: a {{statistically}} dominant fraction of <b>machine</b> <b>instructions</b> must be executed without VMM intervention ...|$|R
5000|$|TXT records {{contain the}} <b>machine</b> <b>instructions</b> or data which {{is held by}} the module.|$|R
40|$|Basic {{building}} blocks of the computer: logic gates, memory cells, wires. • Units built from these (like register units, control unit). • Other Hardware components (monitors, hard disks • Representation and manipulation of data. • <b>Machine</b> <b>instructions</b> and assembly languages. • Translation of high level languages into <b>machine</b> <b>instructions.</b> • High performance architectures like super scalar/pipelined architectures and instruction level parallelism...|$|R
40|$|In {{a virtual}} machine interpreter, the code for each virtual <b>machine</b> <b>instruction</b> has {{similarities}} to code for other instructions. We present an interpreter generator that automatically generates code for the virtual <b>machine</b> <b>instructions</b> from simple instruction descriptions; it generates code for the virtual machine interpreter, for generating virtual machine code, for virtual machine code disassembly, for tracing, and for profiling...|$|R
5000|$|From the 1940s to {{the late}} 1970s, {{a large portion of}} {{programming}} was done in assembly language; higher-level instructions mean greater programmer productivity, so an important advantage of microcode was the relative ease by which powerful <b>machine</b> <b>instructions</b> can be defined. The ultimate extension of this are [...] "Directly Executable High Level Language" [...] designs, in which each statement of a high-level language such as PL/I is entirely and directly executed by microcode, without compilation. The IBM Future Systems project and Data General Fountainhead Processor are examples of this. During the 1970s, CPU speeds grew more quickly than memory speeds and numerous techniques such as memory block transfer, memory pre-fetch and multi-level caches were used to alleviate this. High-level <b>machine</b> <b>instructions,</b> made possible by microcode, helped further, as fewer more complex <b>machine</b> <b>instructions</b> require less memory bandwidth. For example, an operation on a character string can be done as a single <b>machine</b> <b>instruction,</b> thus avoiding multiple instruction fetches.|$|R
5000|$|Uses a non-virtualized, model-dependent <b>machine</b> <b>instruction</b> as {{a signal}} between CMS and CP: DIAG ("diagnose").|$|R
5000|$|Efficiency / Performance: A {{statistically}} dominant {{fraction of}} <b>machine</b> <b>instructions</b> must be executed without VMM intervention.|$|R
5000|$|On {{a system}} that uses {{conditional}} branching, this might translate to <b>machine</b> <b>instructions</b> looking similar to: ...|$|R
50|$|Since there is, typically, a {{one-to-one}} {{relationship between}} assembly <b>instructions</b> and <b>machine</b> <b>instructions,</b> the instruction path length is frequently taken {{as the number}} of assembly instructions required to perform a function or particular section of code. Performing a simple table lookup on an unsorted list of 1,000 entries might require perhaps 2,000 <b>machine</b> <b>instructions</b> (on average, assuming uniform distribution of input values), while performing the same lookup on a sorted list using a binary search algorithm might require only about 40 <b>machine</b> <b>instructions,</b> a very considerable saving. Expressed in terms of instruction path length, this metric would be reduced in this instance by a massive factor of 50 - a reason why actual instruction timings might be a secondary consideration compared to a good choice of algorithm requiring a shorter path length.|$|R
5000|$|... #Caption: A {{high-level}} illustration {{showing the}} decomposition of <b>machine</b> <b>instructions</b> into micro-operations, performed during typical fetch-decode-execute cycles.|$|R
50|$|Execution {{optimization}} {{has gone}} even further; processors not only translate many <b>machine</b> <b>instructions</b> {{into a series}} of μops, but also do the opposite when appropriate; they combine certain <b>machine</b> <b>instruction</b> sequences (such as a compare followed by a conditional jump) into a more complex μop which fits the execution model better and thus can be executed faster or with less machine resources involved. This is also known as macro-op fusion.|$|R
40|$|Prolog {{has been}} widely {{recognized}} as a powerful programming language for artificial intelligence. It was also chosen as a kernel language for the Japanese Fifth Generation Project. The project is a large scale effort to initiate {{a new generation of}} computing. Due to the wide range of applications that Prolog has, many methods have been developed for extracting parallelism from standard Prolog in order to achieve faster execution on a multiprocessor. This project designs an execution model for Prolog, which attempts to exploit the parallelism mainly at the argument level through the unification operation. The model consisting of a number of virtual <b>machine</b> <b>instructions,</b> has been implemented in Occam 2 on a Transputer Development System. A few Prolog procedures have been hand compiled to the virtual <b>machine</b> <b>instructions,</b> and have been run on a Transputer Development System with a single transputer. This model of virtual <b>machine</b> <b>instructions</b> can be applied to a multiple transputer system. This project gives the details of the implementation of the virtual <b>machine</b> <b>instructions...</b>|$|R
5000|$|Run-time control ... With all implementations, debug tools {{can start}} and stop the processor, modify registers, and single-step <b>machine</b> <b>instructions.</b>|$|R
5000|$|... {{simulating}} a few <b>machine</b> <b>instructions</b> {{that are}} present on some, but not all, {{models of the}} S/360 or S/370 computers, ...|$|R
50|$|From {{either of}} two 3-instruction base sets {{all the other}} counter <b>machine</b> <b>instructions</b> can be derived. Both have {{advantages}} and disadvantages.|$|R
40|$|This paper {{describes}} a PC-based mainframe computer emulator called VisibleZ {{and its use}} in teaching mainframe Computer Organization and Assembly Programming classes. VisibleZ models IBM’s z/Architecture and allows direct interpretation of mainframe assembly language object code in a graphical user interface environment that was developed in Java. The VisibleZ emulator acts as an interactive visualization tool to simulate enterprise computer architecture. The provided architectural components include main storage, CPU, registers, Program Status Word (PSW), and I/O Channels. Particular attention is given to providing visual clues to the user by color-coding screen components, <b>machine</b> <b>instruction</b> execution, and animation of the machine architecture components. Students interact with VisibleZ by executing <b>machine</b> <b>instructions</b> in a step-by-step mode, simultaneously observing the contents of memory, registers, {{and changes in the}} PSW during the fetch-decode-execute <b>machine</b> <b>instruction</b> cycle. The object-oriented design and implementation of VisibleZ allows students to develop their own instruction semantics by coding Java for existing specific z/Architecture <b>machine</b> <b>instructions</b> or design and implement new <b>machine</b> <b>instructions.</b> The use of VisibleZ in lectures, labs, and assignments is described in the paper and supported by a website that hosts an extensive collection of related materials. VisibleZ has been proven a useful tool in mainframe Assembly Language Programming and Computer Organization classes. Using VisibleZ, students develop a better understanding of mainframe concepts, components, and how the mainframe computer works. ACM Computing Classification System (1998) : C. 0, K. 3. 2...|$|R
50|$|In modern CPUs this is {{accomplished}} on the processor itself, in a single <b>machine</b> <b>instruction,</b> {{rather than having to}} go through RAM.|$|R
50|$|In 1936 Konrad Zuse {{anticipated}} in two patent {{applications that}} <b>machine</b> <b>instructions</b> could {{be stored in}} the same storage used for data.|$|R
50|$|Microcode {{typically}} {{resides in}} special high-speed memory and translates <b>machine</b> <b>instructions,</b> state <b>machine</b> data or other input into sequences of detailed circuit-level operations. It separates the <b>machine</b> <b>instructions</b> from the underlying electronics so that instructions {{can be designed}} and altered more freely. It also facilitates the building of complex multi-step instructions, while reducing the complexity of computer circuits. Writing microcode is often called microprogramming and the microcode in a particular processor implementation is sometimes called a microprogram.|$|R
50|$|In 1936, Konrad Zuse also {{anticipated}} in two patent {{applications that}} <b>machine</b> <b>instructions</b> could {{be stored in}} the same storage used for data.|$|R
5000|$|User-accessible {{registers}} {{can be read}} {{or written}} by <b>machine</b> <b>instructions.</b> The most common division of user-accessible registers is into data registers and address registers.|$|R
40|$|We {{show how}} to {{generate}} {{the back end of}} an optimizing compiler from a formal description of the syntax and semantics of <b>machine</b> <b>instructions.</b> Our generated back ends for x 86, ARM, and PowerPC perform as well as their hand-written counterparts. Automatic generation is enabled by two new ideas: a model of machine-level computation that reduces back-end generation to the problem of finding implementations of about a hundred simple, machine-level operations; and an algorithm that finds these implementations by combining <b>machine</b> <b>instructions.</b> 1...|$|R
