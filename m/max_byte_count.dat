0|100|Public
5000|$|<b>Byte</b> <b>count,</b> two hex digits, {{indicating}} {{the number of}} bytes (hex digit pairs) in the data field. The maximum <b>byte</b> <b>count</b> is 255 (0xFF). 16 (0x10) and 32 (0x20) are commonly used <b>byte</b> <b>counts.</b>|$|R
40|$|TCP’s delayed {{acknowledgment}} algorithm {{has been}} shown to hurt TCP performance. One method of gaining the performance lost by reducing the number of acknowledgments sent is to use a limited <b>byte</b> <b>counting</b> algorithm. However, we show that as outlined in [All 98], limited <b>byte</b> <b>counting</b> is too aggressive in some situations. This paper defines an appropriate <b>byte</b> <b>counting</b> algorithm to fix this aggressiveness. This paper shows that appropriate <b>byte</b> <b>counting</b> is a better overall algorithm. In addition, a scaled version of the appropriate <b>byte</b> <b>counting</b> algorithm, which provides finer-grained control over the aggressiveness of the algorithm, is outlined. In addition, unlike previous work this paper considers the impact of <b>byte</b> <b>counting</b> flows on competing traffic and shows that it is not fundamentally unfair to competing flows that do not use the new algorithm. ...|$|R
40|$|TCP's delayed {{acknowledgment}} algorithm {{has been}} shown to hurt TCP performance. One method of gaining the performance lost by reducing the number of acknowledgments sent is to use a limited <b>byte</b> <b>counting</b> algorithm. However, we show that as outlined in [All 98], limited <b>byte</b> <b>counting</b> is too aggressive in some situations. This paper defines an appropriate <b>byte</b> <b>counting</b> algorithm to fix this aggressiveness. This paper shows that appropriate <b>byte</b> <b>counting</b> is a better overall algorithm. In addition, a scaled version of the appropriate <b>byte</b> <b>counting</b> algorithm, which provides finer-grained control over the aggressiveness of the algorithm, is outlined. In addition, unlike previous work this paper considers the impact of <b>byte</b> <b>counting</b> flows on competing traffic and shows that it is not fundamentally unfair to competing flows that do not use the new algorithm. 1 Introduction The slow start algorithm [Jac 88, APS 99] TCP uses to initially determine the available bandwidth of a network path has been [...] ...|$|R
50|$|No {{capability}} for transmit buffer <b>byte</b> <b>count</b> of zero.Receive lockup may occur if bus latency is large.External loopback on a live network may cause reception of invalid loopback failure indications.Receive descriptor zero <b>byte</b> <b>count</b> buffer interpreted as 4096 available bytes.Will poll computer memory every 1.6 ms for new packets to transmit.|$|R
5000|$|Payload <b>byte</b> <b>count</b> size {{depends on}} the value of the `DATA_LENGTH` field.|$|R
5000|$|Operands {{that are}} <b>byte</b> <b>counts</b> are {{normally}} decimal, {{but may be}} preceded by [...] for octal and [...] for hexadecimal.|$|R
5000|$|Block mode: FTP {{breaks the}} data into several blocks (block header, <b>byte</b> <b>count,</b> and data field) and then passes {{it on to}} TCP.|$|R
50|$|Fixed-size {{characters}} can be helpful, {{but even}} if there is a fixed <b>byte</b> <b>count</b> per code point (as in UTF-32), there is not a fixed <b>byte</b> <b>count</b> per displayed character due to combining characters. If you are working with a particular API heavily and that API has standardised on a particular Unicode encoding, it is generally a good idea to use the encoding that the API does to avoid the need to convert before every call to the API. Similarly if you are writing client-server software, it may simplify matters to use the same format for processing that you are communicating in.|$|R
5000|$|UINT880 - Header UINT32 - Number of {{triangle}}s [...] foreach triangle REAL323 - Normal vector REAL323 - Vertex 1 REAL323 - Vertex 2 REAL323 - Vertex 3 UINT16 - Attribute <b>byte</b> <b>count</b> end ...|$|R
50|$|The {{first word}} is the opcode; {{the first part}} of the second word is the <b>byte</b> <b>count</b> field, the second part is the {{destination}} operand and the third part is the source operand. These instructions supported on the 990/12.|$|R
50|$|The program reads either {{standard}} input or {{a list of}} files and generates {{one or more of}} the following statistics: newline count, word <b>count,</b> and <b>byte</b> <b>count.</b> If a list of files is provided, both individual file and total statistics follow.|$|R
5000|$|Checksum, two hex digits, {{the least}} {{significant}} byte of ones' complement of {{the sum of}} the values represented by the two hex digit pairs for the <b>byte</b> <b>count,</b> address and data fields. See example section for a detailed checksum example.|$|R
40|$|Abstract—We {{report the}} first {{statistical}} analysis of Internet backbone traffic, based on traces with levels of aggregation 10 times larger and timestamp accuracy 1000 times better than in previous studies. We analyze the first three moments, marginal distributions and correlation structures of packet size, packet inter-arrival time, <b>byte</b> <b>count</b> and packet count, and find that the highly aggregated Internet backbone traffic is still longrange dependent and self-similar. In fact, all time series examined (packet size, inter-arrival time, <b>byte</b> <b>count,</b> packet count) exhibit long-range dependency and self-similarity. In addition to the now-classical analysis at large time-scales (> 100 ms), we report the first statistically relevant results on the short-term correlation ([50 µs, 10 ms]) of <b>byte</b> and packet <b>count</b> processes. We also study the fitness of various analytical models to the traffic traces. The empirical queuing analysis confirms the long-range dependence detected through direct analysis by showing that the queue behavior at high level of aggregation still diverges greatly from that predicted by Poisson model. As expected, statistical multiplexing gains improve the queuing performance, leading to economy of scale. I...|$|R
40|$|Added {{fragments}} to exceptions, allowing {{retrieval of}} incomplete receives' contents, and <b>byte</b> <b>count</b> on incomplete sends. Changed Stream {{to use an}} fread/fwrite duo instead of stream_copy_to_stream() {{for the sake of}} stability. Tweaked Stream::isAcceptingData() and NetworkStream::isAvailable(), in order to work around a reproducible hang on Linux. Doc fixes...|$|R
5000|$|... cksum is {{a command}} in Unix-like {{operating}} systems that generates a checksum value for a file or stream of data. The cksum command reads each file given in its arguments, or standard input if no arguments are provided, and outputs the file's CRC checksum and <b>byte</b> <b>count.</b>|$|R
5000|$|<b>Byte</b> <b>count,</b> two hex digits, {{indicating}} {{the number of}} bytes (hex digit pairs) that follow {{in the rest of}} the record (address + data + checksum). This field has a minimum value of 3 for 16-bit address field plus 1 checksum byte, and a maximum value of 255 (0xFF).|$|R
50|$|The {{first part}} of the first word is the opcode, {{the second part of the}} first word {{indicates}} a checkpoint register; the {{first part of}} the second word is the <b>byte</b> <b>count</b> field, the second part is the destination operand and the third part is the source operand. These instruction supported on the 990/12.|$|R
40|$|This paper {{presents}} a simulation study of various TCP acknowledgment generation and utilization techniques. We investigate the standard version of TCP {{and the two}} standard acknowledgment strategies employed by receivers: those that acknowledge each incoming segment and those that implement delayed acknowledgments. We show the delayed acknowledgment mechanism hurts TCP performance, especially during slow start. Next we examine three alternate mechanisms for generating and using acknowledgments designed to mitigate {{the negative impact of}} delayed acknowledgments. The first method is to generate delayed ACKs only when the sender is not using the slow start algorithm. The second mechanism, called <b>byte</b> <b>counting,</b> allows TCP senders {{to increase the amount of}} data being injected into the network based on the amount of data acknowledged rather than on the number of acknowledgments received. The last mechanism is a limited form of <b>byte</b> <b>counting.</b> Each of these mechanisms is evaluated in a simulate [...] ...|$|R
40|$|The {{origin-destination}} (OD) {{traffic matrix}} {{of a computer}} network is useful for solving problems in design, routing, con guration debugging, monitoring, and pricing. Directly measuring this matrix is not usually feasible but less informative link measurements are easy to obtain. This work studies the inference of OD <b>byte</b> <b>counts</b> from link <b>byte</b> <b>counts</b> measured at router interfaces under a fixed routing scheme. A basic model of the OD counts assumes that they are independent normal over OD pairs and iid over successive measurement periods. The normal means and variances are functionally related through a power law. We deal with the time-varying nature of the counts by fitting the basic iid model locally using a moving data window. Identifiability of the model is proved for router link data and maximum likelihood is used for parameter estimation. The OD counts are estimated by their conditional expectations given the link counts and estimated parameters. OD estimates are forced to be [...] ...|$|R
5000|$|Despite its {{official}} status, the unit mebibyte is not commonly used even when reporting <b>byte</b> <b>counts</b> calculated in binary multiples, but is often represented as megabytes. Formally, one megabyte denotes 1000 × 1000 bytes. The discrepancy may cause confusion, since operating systems using the binary method report lower numerical values for storage size than advertised by manufacturers, such as disk drive manufacturers who strictly use decimal units.|$|R
5000|$|A {{partially}} standardized list {{of up to}} six parameters {{known as}} P1 through P6. The first two parameters typically specify the I/O buffer starting address (P1), and the I/O <b>byte</b> <b>count</b> (P2). The remaining parameters vary with the operation, and the particular device. For example, for a computer terminal, P3 might be the time {{to allow for the}} read to complete whereas, for a disk drive, it might be the starting block number of the transfer.|$|R
40|$|Monitoring {{the traffic}} volumes of {{elephant}} flows, including the total <b>byte</b> <b>count</b> per flow, {{is a fundamental}} capability for online network measurements. We present an asymptotically optimal algorithm for solving this problem {{in terms of both}} space and time complexity. This improves on previous approaches, which can only count the number of packets in constant time. We evaluate our work on real packet traces, demonstrating an up to X 2. 5 speedup compared to the best alternative. Comment: Accepted to IEEE INFOCOM 201...|$|R
5000|$|... struct ireq { /* Structure of {{incoming}} request */ short ir_fc; /* Function code */ short ir_rn; /* Request number */ long ir_opid; /* Owner ID {{that you gave}} on open or mount */ long ir_bc; /* <b>Byte</b> <b>count</b> */ long ir_upar; /* User parameter */ long ir_rad; /* Random address */ ushort ir_uid; /* User ID */ ushort ir_gid; /* User group */ time_t ir_time; /* Request time */ ulong ir_nph; ulong ir_npl; /* Node and process ID */}; ...|$|R
50|$|Each Ethernet frame must be {{processed}} {{as it passes}} through the network. Processing {{the contents of a}} single large frame is preferable to processing the same content broken up into smaller frames, as this makes better use of available CPU time by reducing interrupts. This also minimizes the overhead <b>byte</b> <b>count</b> and reduces the number of frames needing to {{be processed}}. This is analogous to physically mailing a packet of papers instead of several single envelopes with one sheet each, saving envelopes and cutting sorting time.|$|R
40|$|Abstract: System {{administrators are}} in an {{increasing}} degree involved with the troubleshooting of solving network problems concerning the quality of service for the different applications. Adding more bandwidth {{is not always the}} option to solve network bottlenecks. This is where QoS – Quality of Service aware network plays an important part. If your network has real time traffic like voice, video etc, configuring and maintaining the right QoS parameters becomes all the more important. QoS obviously means Quality of Service. On Analysis it was evaluated that the traffic is queued in "router A " because of the bottleneck. The Custom Queuing mechanism differentiated traffic between queues based on the type of service (TOS). Traffic is sent from each queue in a roundrobin fashion. Queues send traffic proportionally to their <b>byte</b> <b>count.</b> In this network queues with high index have higher <b>byte</b> <b>count.</b> As a result of this classification traffic with higher TOS gets better delay. In case study 2, the traffic is queued in router A because of the bottleneck. In this, the WFQ mechanism differentiates traffic between queues based on the type of service (TOS). Queues send traffic proportionally to their weight. Queues with high index have higher weight. As a result of this classification traffic with higher TOS gets better delay...|$|R
5000|$|A <b>byte</b> <b>count</b> can be {{followed}} by a suffix to specify a multiple of that count; in this case an omitted integer is understood to be 1. A bare size letter, or one followed by , specifies a multiple using powers of 1024. A size letter followed by [...] specifies powers of 1000 instead. For example, [...] and [...] are equivalent to , whereas [...] is equivalent to [...] This notation is upward compatible with the SI prefixes for decimal multiples and with the IEC 60027-2 prefixes for binary multiples.|$|R
5000|$|... returns a void pointer (...) , which {{indicates}} {{that it is a}} pointer to a region of unknown data type. The use of casting is required in C++ due to the strong type system, whereas {{this is not the case}} in C. The lack of a specific pointer type returned from [...] is type-unsafe behaviour according to some programmers: [...] allocates based on <b>byte</b> <b>count</b> but not on type. This is different from the C++ new operator that returns a pointer whose type relies on the operand. (See C Type Safety.) ...|$|R
50|$|At any instant in time, a file {{might have}} a size, {{normally}} expressed as number of bytes, that indicates how much storage {{is associated with the}} file. In most modern operating systems the size can be any non-negative whole number of bytes up to a system limit. Many older operating systems kept track only of the number of blocks or tracks occupied by a file on a physical storage device. In such systems, software employed other methods to track the exact <b>byte</b> <b>count</b> (e.g., CP/M used a special control character, Ctrl-Z, to signal the end of text files).|$|R
40|$|Developers {{of network}} {{applications}} or network hardware need simulations {{to test their}} products before introducing them into the market. Today, several traffic models are available that can generate packet streams with a behavior close to real-life network traffic. Most of these are discrete models, and thus generate a sequence of packet or <b>byte</b> <b>counts</b> for subsequent time intervals. This generated traffic now has to be imported into the OPNET simulator. This paper will study the possibility of entering such bin counts into OPNET as (background) traffic flows. Optimal settings will be sought {{to make sure the}} desired traffic behavior is achieved...|$|R
50|$|Standard DMA, {{also called}} {{third-party}} DMA, uses a DMA controller. A DMA controller can generate memory addresses and initiate memory {{read or write}} cycles. It contains several hardware registers that can be written and read by the CPU. These include a memory address register, a <b>byte</b> <b>count</b> register, and one or more control registers. The control registers could specify the source, the destination, {{the direction of the}} transfer (reading from the I/O device or writing to the I/O device), the size of the transfer unit, and/or the number of bytes to transfer in one burst depending on what features the DMA controller provides.|$|R
50|$|GNU Sharutils {{is a set}} of {{utilities}} to handle shell archives. The GNU shar utility produces a single file out of many files and prepares them for transmission by electronic mail services, for example by converting binary files into plain ASCII text. A shell archive is a collection of files that can be unpacked by the Bourne shell. A wide range of features provide extensive flexibility in manufacturing shar archives and in specifying shar smartness. For example, shar may compress files, uuencode binary files, split long files and construct multi-part mailings, ensure correct unsharing order, and provide md5sum or <b>byte</b> <b>count</b> verification.|$|R
5000|$|Slave devices {{measure the}} time {{necessary}} {{to receive the}} 0x55 <b>byte</b> by <b>counting</b> signal transitions. This time is then used by the slaves to determine the bit period and synchronize with the master.|$|R
40|$|In this work, {{we present}} {{the results of our}} {{empirical}} study on 802 : 11 wireless LAN network traffic. We collect the packet trace from existing campus wireless LAN infra-structure. We analyze four different data sets: aggregate traffic, upstream traffic, down-stream traffic, tcp only packet trace from aggregate traffic. We analyze the time series aspects of underlying traffic (<b>byte</b> <b>count</b> process and packet count process), marginal dis-tribution of time series, and packet size distribution. We found that in all four data sets there exist long-range dependent properties in terms of <b>byte</b> <b>count</b> and packet count proc-ess. Inter-arrival distribution is well fitted with Pareto distribution. Upstream traffic, i. e. from the user to Internet, exhibits significant difference in packet size distribution from the rests. Average packet size of upstream traffic is 151 : 7 byte while average packet size {{of the rest of the}} data sets are all greater than 260 bytes. Packets with full data payloads constitute 3 % and 10 % in upstream traffic and downstream traffic, respectively. Despite the significant difference in packet size distribution, all four data sets have similar Hurst values. The Hurst alone does not properly explain the stochastic characteristics of the underlying traffic. We model the underlying traffic using fractional-ARIMA (FARIMA) and fractional Gaussian Noise (FGN). While the fractional Gaussian Noise based method is computationally more efficient, FARIMA exhibits superior performance in accurately modeling the underlying traffic...|$|R
40|$|Operating {{a network}} without {{accurate}} traffic statistics is not desirable. Commonly used data sources are SNMP [1], flow-level data, e. g., CISCO's NETFLOW, or packet level data. The first data source provides low volume, coarse-grained, non-application specific data. The latter one provides high volume, fine-grain data and application specific information. NetFlow lies {{somewhere in between}} in terms of both: volume and level of detail. In this paper we ask the question how and how accurately can one infer information from NetFlow. More specifically {{we are interested in}} TCP connection summaries and accurately aggregated packet and <b>byte</b> <b>counts.</b> The same techniques apply to application specific (per port) summaries...|$|R
40|$|Abstract. We {{demonstrate}} that the browser implementation used at a host can be passively identified with significant precision and recall, using only coarse summaries of web traffic to and from that host. Our techniques utilize connection records containing only the source and destination addresses and ports, packet and <b>byte</b> <b>counts,</b> and the start and end times of each connection. We additionally provide two applications of browser identification. First, we show how to extend a network intrusion detection system to detect {{a broader range of}} malware. Second, we demonstrate the consequences of web browser identification to the deanonymization of web sites in flow records that have been anonymized...|$|R
5000|$|All common {{arithmetic}} {{instructions are}} provided - including a divide and remainder (which {{are the only}} instructions that are not single cycle). Comparison instructions compute a truth value (0 or 1) into a register, avoiding the use of flags. Many instructions have an immediate version that allows a single operand with a value of between 0 and 11 inclusive, encoding many common cases such as [...] "i = i + 1". In the case of bit operations such as shift, the immediate value encodes common cases. Extra instructions are provided for reversing bits and <b>bytes,</b> <b>count</b> leading zeros, digital signal processing, and long integer arithmetic.|$|R
