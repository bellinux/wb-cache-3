329|427|Public
25|$|The first {{memory segment}} (64 KB) of the {{conventional}} <b>memory</b> <b>area</b> is named lower memory or low <b>memory</b> <b>area.</b>|$|E
25|$|The {{ability of}} DOS {{versions}} 5.0 {{and later to}} move their own system core code into the high <b>memory</b> <b>area</b> (HMA) through the DOS=HIGH command gave another boost to free memory.|$|E
25|$|In modern {{operating}} systems, memory {{which is}} accessed less frequently can be temporarily stored on disk or other media {{to make that}} space available for use by other programs. This is called swapping, as an area of memory {{can be used by}} multiple programs, and what that <b>memory</b> <b>area</b> contains can be swapped or exchanged on demand.|$|E
50|$|Other {{potential}} {{causes of}} data loss included {{the corruption of}} DoubleSpace's <b>memory</b> <b>areas</b> by other programs, DoubleSpace's <b>memory</b> <b>areas</b> were not protected, because MS-DOS ran in real mode. Microsoft attempted to remedy this in the MS-DOS 6.2 version of DoubleSpace (via a feature called DoubleGuard that would check for such corruption).|$|R
50|$|The Global Descriptor Table or GDT is a data {{structure}} used by Intel x86-family processors {{starting with the}} 80286 in order to define {{the characteristics of the}} various <b>memory</b> <b>areas</b> used during program execution, including the base address, the size and access privileges like executability and writability. These <b>memory</b> <b>areas</b> are called segments in Intel terminology.|$|R
5000|$|Memory {{protection}} (tasks {{are allowed}} to allocate to protected <b>memory</b> <b>areas</b> if need be) ...|$|R
25|$|Passwords are {{protected}} in memory while KeePass is running. On Windows Vista and later versions, passwords are encrypted in process memory using Windows Data Protection API, which allows storing {{the key for}} memory protection in a secure, non-swappable <b>memory</b> <b>area.</b> On previous Windows systems, KeePass falls back to using the ARC4 cipher with a temporary, random session key.|$|E
25|$|Bjarne Stroustrup {{originally}} observed, in {{his book}} The Design and Evolution of C++, that pointer placement new is necessary for hardware that expects a certain object at a specific hardware address. It is also required {{for the construction of}} objects that need to reside in a certain <b>memory</b> <b>area,</b> such as an area that is shared between several processors of a multiprocessor computer.|$|E
25|$|As DOS {{applications}} grew {{larger and}} more complex in the late 1980s, it became common practice to free up conventional memory by moving the device drivers and TSR programs into upper memory blocks (UMBs) in the upper <b>memory</b> <b>area</b> (UMA) at boot, {{in order to maximize}} the conventional memory available for applications. This had the advantage of not requiring hardware changes, and preserved application compatibility.|$|E
5000|$|... an {{alternative}} to the more complex scheme that includes memory coalescence that allows a heap to be broken across multiple <b>memory</b> <b>areas.</b>|$|R
50|$|Memory Card Comfort by Speed-Link — A sort of Controller Pak {{with four}} {{separate}} <b>memory</b> <b>areas,</b> and 123 pages each, selectable via a small switch.|$|R
50|$|Communication between Virtual Machines is {{achieved}} by means of Events (named communication channels) and shared <b>memory</b> <b>areas.</b> The hardware architecture also provides semaphore instructions INCT (increment-and-test) and TDEC (test-and-decrement).|$|R
25|$|The Shared Memory Net-Lib, on {{the other}} hand, manages {{connections}} between multiple instances of SQL Server that exist on one computer. It uses a shared <b>memory</b> <b>area</b> to communicate between the processes. This is inherently secure; {{there is no need}} for data encryption between instances of SQL Server that exist on one computer as the operating system does not allow any other process access to the instances' area of shared memory.|$|E
25|$|Later, two new {{versions}} were released: Windows/286 2.1 and Windows/386 2.1. Like prior {{versions of}} Windows, Windows/286 2.1 used the real-mode memory model, but {{was the first}} version to support the High <b>Memory</b> <b>Area.</b> Windows/386 2.1 had a protected mode kernel with LIM-standard EMS emulation. All Windows and DOS-based applications {{at the time were}} real mode, running over the protected mode kernel by using the virtual 8086 mode, which was new with the 80386 processor.|$|E
25|$|Windows NT {{kernel mode}} has {{full access to}} the {{hardware}} and system resources of the computer and runs code in a protected <b>memory</b> <b>area.</b> It controls access to scheduling, thread prioritization, memory management and the interaction with hardware. The kernel mode stops user mode services and applications from accessing critical areas of the operating system {{that they should not}} have access to; user mode processes must ask the kernel mode to perform such operations on their behalf.|$|E
50|$|The {{standard}} {{definition for}} MHP is: The MHP draws an analogy between the processing and storage areas of a computer, with the perceptual, motor, cognitive and <b>memory</b> <b>areas</b> {{of the computer}} user.|$|R
5000|$|Among {{the more}} {{advanced}} features was the ability to [...] "base" [...] a variable or array, making the memory location dynamic and modifiable during execution. SBasic programs {{had the ability to}} access <b>memory</b> <b>areas</b> reserved for the operating system unless prohibited from doing so by the operating system itself. (Kaypro's CP/M had no such prohibitions.) This enabled direct utilization and modification of DMA and other <b>memory</b> <b>areas.</b> This feature also permitted a program to modify itself at run-time. This capability also allowed modifying the instruction pointer, so a program could effectively link other executable modules that were read during execution as data.|$|R
50|$|The {{local and}} system <b>memory</b> <b>areas</b> are not noticeably {{separate}} {{to the user}} and often HyperMemory solutions are advertised as having as much as 4096 MB RAM when this is actually referring to the potential use of system RAM.|$|R
25|$|Hardware {{expansion}} boards {{could use}} any of the upper <b>memory</b> <b>area</b> for ROM addressing, so the upper memory blocks were of variable size and in different locations for each computer, depending on the hardware installed. Some windows of upper memory could be large and others small. Loading drivers and TSRs high would pick a block and try to fit the program into it, until a block was found where it fit, or it would go into conventional memory.|$|E
2500|$|Memory {{managers}} on 386-based systems (such as QEMM or MEMMAX (+V) in DR-DOS) {{could achieve}} the same effect, adding conventional memory at 640 KB and moving the barrier to 704 KB (up to segment B000, the start of MDA/HGC) or 736 KB (up to segment B800, {{the start of the}} CGA). [...] Only CGA could be used in this situation, because Enhanced Graphics Adapter (EGA) video memory was immediately adjacent to the conventional <b>memory</b> <b>area</b> below the 640 KB line; the same <b>memory</b> <b>area</b> could not be used both for the frame buffer of the video card and for transient programs.|$|E
2500|$|Version 5.0 (Retail) – {{includes}} a full-screen editor. [...] A number of bugs required re issue. First version to support 3.5-inch, 2.88 MB floppy drives and diskettes. Hard disk partitions greater than 32 MiB {{and up to}} a maximum size of 2 GiB was now provided by the MS-DOS kernel. First version to load portions of the operating system into the high <b>memory</b> <b>area.</b>|$|E
40|$|The Oracle {{professionals}} or DBA’s {{should know}} how to accurately predict the high-water mark of RAM demands for their database, and fully allocate the RAM, reserving only enough to accommodate spikes in user connections. For an Oracle server, in this paper {{the goal is to}} keep all the RAM memory demands of the database and database connections beneath the amount of physical RAM memory. In an Oracle environment, we can accurately control the amount of RAM memory that is used by the database instance System Global Area (SGA). This is because the Oracle database administrator can issue alter system command to change the RAM <b>memory</b> <b>areas,</b> and can grow and shrink the RAM <b>memory</b> <b>areas</b> on as needed basis...|$|R
40|$|AbstractDeveloping a {{real-time}} {{system in}} Java requires awareness of memory behaviour {{in addition to}} software functional requirements. The Real-Time Specification for Java (RTSJ) introduces a scoped memory model to avoid garbage collection delays in critical real-time applications which need to meet hard real-time constraints. Scoped memory management has certain advantages over garbage collection in terms of predictability. However, developing a real-time application using scoped <b>memory</b> <b>areas</b> (regions) may suffer from both design and runtime errors. Moreover, from a memory footprint perspective, the inability to determine precisely how many scoped <b>memory</b> <b>areas</b> should be used and which objects or threads should be allocated into these scoped <b>memory</b> <b>areas</b> makes using RTSJ problematic for developing real-time systems. In this paper, {{a survey of the}} current approaches to improve scoped memory management and new emerging challenges in RTSJ scoped memory management model are presented. Categorizing those problems and challenges provides a picture of the issues researchers have yet to investigate and to support solutions for an optimal scoped memory model. Current approaches and a set of benchmarks used to evaluate current solutions are presented and new research questions in developing real-time Java systems using a scoped memory model are proposed...|$|R
50|$|During the {{vertical}} blanking interval, the driver orders the video card to either rapidly copy the off-screen graphics area into the active display area (double buffering), or treat both <b>memory</b> <b>areas</b> as displayable, and simply switch {{back and forth}} between them (page flipping).|$|R
2500|$|Windows 2.1 was {{released}} in two different versions: Windows/286 and Windows/386. Windows/386 uses the virtual 8086 mode of the Intel 80386 to multitask several DOS programs and the paged memory model to emulate expanded memory using available extended memory. Windows/286, {{in spite of its}} name, runs on both Intel 8086 and Intel 80286 processors. It runs in real mode but can make use of the high <b>memory</b> <b>area.</b>|$|E
2500|$|In a {{monolithic}} kernel, all OS services run {{along with the}} main kernel thread, thus also residing in the same <b>memory</b> <b>area.</b> This approach provides rich and powerful hardware access. Some developers, such as UNIX developer Ken Thompson, maintain that it is [...] "easier to implement {{a monolithic}} kernel" [...] than microkernels. The main disadvantages of monolithic kernels are the dependencies between system components a bug in a device driver might crash the entire system {{and the fact that}} large kernels can become very difficult to maintain.|$|E
2500|$|The {{design of}} the {{original}} IBM PC placed the Color Graphics Adapter (CGA) memory map and other hardware in the 384 KB upper <b>memory</b> <b>area</b> (UMA). The need for more RAM grew faster than the needs of hardware to utilize the reserved addresses, which resulted in RAM eventually being mapped into these unused upper areas to utilize all available addressable space. This introduced a reserved [...] "hole" [...] (or several holes) into the set of addresses occupied by hardware {{that could be used}} for arbitrary data. Avoiding such a hole was difficult and ugly and not supported by DOS or most programs that could run on it. Later, space between the holes would be used as upper memory blocks (UMBs).|$|E
25|$|A {{successful}} overlay {{destroys the}} previous memory address {{space of the}} process, and all its <b>memory</b> <b>areas,</b> that were not shared, are reclaimed by the operating system. Consequently, all its data that were not passed to the new program, or otherwise saved, becomes lost.|$|R
40|$|This report {{presents}} optimisations mechanisms within MPICH/Madeleine, {{the implementation}} of MPICH over Madeleine. These mechanisms aim to decrease the communication time of derived datatypes for which data is stored in noncontiguous <b>memory</b> <b>areas.</b> The report presents the mechanisms {{as well as some}} performance evaluation...|$|R
50|$|When {{a program}} is started, the free <b>memory</b> <b>areas</b> {{are long and}} {{contiguous}}. Over time and with use, the long contiguous regions become fragmented into smaller and smaller contiguous areas. Eventually, it may become impossible for the program to obtain large contiguous chunks of memory.|$|R
50|$|The {{extended}} memory manager is {{also responsible for}} managing allocations in the high <b>memory</b> <b>area</b> (HMA) and the upper <b>memory</b> <b>area</b> (UMA; {{also referred to as}} upper memory blocks or UMBs). In practice the upper <b>memory</b> <b>area</b> will be provided by the expanded memory manager (EMM), after which DOS will try to allocate them all and manage them itself.|$|E
50|$|In memory management, {{the high}} <b>memory</b> <b>area</b> (HMA) is the RAM area {{consisting}} of 65520 bytes beyond the upper <b>memory</b> <b>area</b> of an IBM AT or compatible computer.|$|E
50|$|The <b>memory</b> <b>area</b> from 9800h to 987Fh behaves as RAM {{as long as}} the {{deformation}} register is reset. The <b>memory</b> <b>area</b> from 9880h to 98FFh is write only; if {{you read}} it, it'll always return FFh. Watch out for reading from the deformation register, as this will set bit 6.|$|E
30|$|The regular {{access pattern}} to the stack cache will {{not benefit from}} set associativity. Therefore, the stack cache is a simple direct-mapped cache. The stack {{contains}} local variables and the write frequency is higher than for other <b>memory</b> <b>areas.</b> The high frequency mandates a write back organization.|$|R
50|$|Scatter-gather or {{vectored}} I/O DMA {{allows the}} transfer of data to and from multiple <b>memory</b> <b>areas</b> in a single DMA transaction. It {{is equivalent to the}} chaining together of multiple simple DMA requests. The motivation is to off-load multiple input/output interrupt and data copy tasks from the CPU.|$|R
40|$|Abstract. The Real-Time Specification for Java [1] (RTSJ) {{introduces}} {{the concept of}} nested-scope <b>memory</b> <b>areas</b> to Java. This design allows a programmer to allocate objects {{in areas that are}} ignored by the garbage collector. Unfortunately, the specification of scoped <b>memory</b> <b>areas</b> currently involves the introduction of unwieldy, application-specific constructs that can ruin the reusability of the affected software. We propose the use of aspects [2], in particular the AspectJ [3] system, to transform a Java program into a scope-aware RTSJ program automatically. Moreover, we have developed analysis that automatically determines storage scopes, in response to information provided by an instrumented form of the application at hand. That instrumentation is also accomplished using aspects. Here we present our ongoing work in using aspects to detect and specify memory scopes automatically in Java programs. ...|$|R
