9|6|Public
50|$|PowerPoint {{introduced}} {{many new}} changes {{with the release}} of PowerPoint 97. It incorporated the Visual Basic for Applications (VBA) language, underlying all <b>macro</b> <b>generation</b> in Office 97.|$|E
50|$|In the 1960s, {{assembly}} languages {{were developed}} to support library COPY and quite sophisticated conditional <b>macro</b> <b>generation</b> and preprocessing abilities, CALL to (subroutines), external variables and common sections (globals), enabling significant code re-use and isolation from hardware specifics via use of logical operators such as READ/WRITE/GET/PUT. Assembly was, and still is, used for time critical systems and often in embedded systems as it gives the most direct control of what the machine does.|$|E
5000|$|Artifacts {{defined by}} end users may be objects {{describing}} some automated behavior or control sequence, such as database requests or grammar rules, which can be described with programming paradigms such as programming by demonstration, programming withexamples, visual programming, or <b>macro</b> <b>generation.</b> They can also be parameters that choose between alternative predefined behaviors of an application. Other artifacts of end-user development may also refer {{to the creation of}} user-generated content such as annotations, which may be or not computationally interpretable (i.e. can be processed by associated automated functions).'''''' ...|$|E
40|$|In {{a number}} of tasks {{the need for a}} macro {{preprocessor}} arises. Most macro preprocessors, are either syntactically tied to the language they support (e. g., cpp, the C preprocessor, or the lisp macro facility), or they are limited in their functionality (cpp), or may even have an arcane syntax (e. g. m 4, chakotay). We propose a macro preprocessor - PYM - based on the Python scripting language, which retains the complete expressivity of Python for writing macros, and thus is not limited by an arcane syntax or a limitation in its functionality. The complete implementation of this macro preprocessor is a Python script of around 200 lines of code, and includes the three main functions of macro definition, macro expansion, and file inclusion. Using Python's exception mechanism, conditional termination of expansion both on a per file, and overall level has been implemented. PYM {{has been shown to be}} useful for <b>macro</b> based <b>generation</b> of VRML files, and for <b>macro</b> based <b>generation</b> of HTML files for a dynamic web server...|$|R
40|$|Register-level {{architecture}} of modern digital computer systems, digital logic, machinelevel representation of data, assembly-level machine organization, and alternative architectures. Laboratory emphasizes machine instruction execution, addressing techniques, program segmentation and linkage, <b>macro</b> definition and <b>generation,</b> and computer solution {{of problems in}} assembly language...|$|R
40|$|This article {{describes}} the syntax editing concepts used by the Operations Sustaining Engineering Section in implementing System Performance Test software for the Mark 4 -A era. The processing functions are discussed, {{as well as the}} necessary data structures and table <b>generation</b> <b>macros</b> used in implementing those functions. In addition, the procedural and software interfaces which have been developed for users of the syntax editor are described, including the forms required for establishing directive and parameter characteristics...|$|R
40|$|ABSTRACT: The {{development}} and automatic generation of Built-In Self-Test (BIST) configurations for Atmel AT 40 K series Field Programmable Gate Arrays (FPGAs) are described. These BIST configurations completely test the programmable logic and routing {{resources in the}} core of the FPGA along with the dedicated Random Access Memories (RAMs) dispersed within the array. The BIST configurations are generated using Atmel’s <b>Macro</b> <b>Generation</b> Language (MGL) for any size FPGA. The advantages and limitations of this approach are discussed. 1 1...|$|E
40|$|In {{this paper}} {{we present a}} tool for <b>macro</b> <b>generation</b> of soft cores {{performing}} arithmetic operations {{for a wide variety}} of operand sizes and architectures. The tool produces structural Verilog descriptions. Hence, any commercial synthesis tool can be used to map the produced designs to a specific technology. The generator covers all four basic operations: addition, subtraction, multiplication and division. Therefore, applications requiring arithmetic cores, as for example digital signal processing and multimedia applications, can be completed faster and with less effort. 1...|$|E
40|$|In {{this paper}} we propose a {{technique}} for learning efficient strategies for solving a certain class of problems. The method, RWM, makes use of two separate methods, namely, refinement and <b>macro</b> <b>generation.</b> The former is a method for partitioning a given problem into a sequence of easier subproblems. The latter is for efficiently learning composite moves which are useful in solving the problem. These methods and a system that incorporates them are described in detail. The kind of strategies learned by RWM are based on the GPS problem solving method. Examples of strategies learned for different types of problems are given. RWM has learned good strategies for some problems which are difficult by human standards. © 1990...|$|E
40|$|The {{purpose of}} the work herein {{reported}} has been an investigation of macro processing (including language extension and text editing schemes). We present a text manipulation system wllose constructs {{have been designed to}} facilitate the use of the system to construct macro processors and to implement such schemes. The concepts of recognition of <b>macro</b> calls and <b>generation</b> of replacement text have been generalized so that any kind of recognitionsubstitution scheme can readily be implemented in the language (called GAME). Chapter I contains, by way of introduction, a discussion of what macros are and how the evolution of macro systems leads to a general language, like G_E. Chapter 2 presents a definition of the macro recognition and expansion process so that some kind of distinction ca...|$|R
40|$|This thesis {{addresses}} hando? {{issues in}} a WCDMA system with space-time block coded transmit antenna diversity. Soft hando? has traditionally been used in CDMA systems because {{of its ability to}} provide an improved link performance due to the inherent <b>macro</b> diversity. Next <b>generation</b> systems will incorporate transmit diversity schemes employing several transmit antennas at the base station. These schemes have been shown to improve downlink transmission performance especially capacity and quality. This research investigates the possibility that the diversity obtained through soft hando? can be compensated for by the diversity obtained in a transmit diversity system with hard hando?. We analyze the system for two performance measures, namely, the probability of bit error and the outage probability, in order to determine whether the improvement in link performance, as a result of transmit diversity in a system with hard hando?s obviates the need for soft hando?s...|$|R
40|$|Since Muller and Schupp {{have shown}} that monadic secondorder logic is decidable for {{context-free}} graphs in [MS 85], several specialized procedures {{have been developed for}} related problems, mostly for sublogics like the modal -calculus, or even its alternation-free fragment. This work shows the decidability of s 1 s, the trace version of msol, for the richer set of <b>macro</b> graphs. The <b>generation</b> mechanism of <b>macro</b> graphs is of higher-order nature and relates to the context-free one like macro grammars [Fis 68] relate to context-free grammars. Technically, the result follows from the decidability of the emptiness problem of the trace language of a macro graph with fairness. The decision procedure is given in form of a tableau system. Soundness and completeness follow from the relation of the (finite) tableaux to their infinite unfoldings. This kind of proof promises to be helpful in the derivation of further results. 1 Introduction During the eighties several modal logics like [...] ...|$|R
40|$|This paper {{proposes a}} model of {{learning}} by discovery. The model consists of a program which discovers macro operators while conducting a best first heuristic search {{in the domain of}} puzzles. This work extends some recent work on permutation puzzles (Korf, 1982) and operator-decomposable puzzles (Korf, 1983), and is related to the earlier work on MACROPS (Fikes, Hart, and Nilsson, 1972). This work is part of a doctoral dissertation currently in progress at MIT, in which the model will be used to explore learning in conjunction with additional search paradigms and numerous alternative heuristics for <b>macro</b> <b>generation</b> and selection. The specific heuristic reported on here is that of using peaks of the evaluation function to segment the paths of the search tree in order to discover macros. The technique seems particularly valuable in difficult puzzles where only imperfect or approximate evaluation functions are available...|$|E
40|$|In Automated Planning, {{generating}} macro-operators (macros) is {{a well-known}} reformulation approach {{that is used to}} speed-up the planning process. Most of the <b>macro</b> <b>generation</b> techniques aim for using the same set of generated macros on every problem instance of a given domain. This limits the usefulness of macros in scenarios where the environment and thus the structure of instances is dynamic, such as in real-world applications. Moreover, despite the wide availability of parallel processing units, {{there is a lack of}} approaches that can take advantage of multiple parallel cores, while exploiting macros. In this paper we propose the Macro sets Evolution (MEvo) approach. MEvo has been designed for overcoming the aforementioned issues by exploiting multiple cores for combining promising macros –taken from a given pool– in different sets, while solving continuous streams of problem instances. Our empirical study, involving 5 state-of-the-art planning engines and a large number of planning instances, demonstrates the effectiveness of the proposed MEvo approac...|$|E
40|$|We {{present a}} {{framework}} for generating content-adaptive macros that can transfer complex photo manipulations to new target images. We demonstrate applications of our framework to face, landscape and global manipulations. To create a content-adaptive macro, we make use of multiple training demonstrations. Specifically, we use automated image labeling and machine learning techniques to learn the dependencies between image features and the parameters of each selection, brush stroke and image processing operation in the macro. Although our approach is limited to learning manipulations {{where there is a}} direct dependency between image features and operation parameters, we show that our framework is able to learn a large class of the most commonly-used manipulations using as few as 20 training demonstrations. Our framework also provides interactive controls to help macro authors and users generate training demonstrations and correct errors due to incorrect labeling or poor parameter estimation. We ask viewers to compare images generated using our content-adaptive macros with and without corrections to manually generated ground-truth images and find that they consistently rate both our automatic and corrected results as close in appearance to the ground-truth. We also evaluate the utility of our proposed <b>macro</b> <b>generation</b> workflow via a small informal lab study with professional photographers. The study suggests that our workflow is effective and practical in the context of real-world photo editing...|$|E

