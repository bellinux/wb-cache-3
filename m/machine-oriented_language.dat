2|9|Public
5000|$|... "Application of the <b>Machine-Oriented</b> <b>Language</b> Epsilon to Software Development", I.V. Pottosin et al., in Machine Oriented Higher Level Languages, W. van der Poel, N-H 1974, pp. 417-434 ...|$|E
5000|$|The most {{advanced}} model was Minsk-32, developed in 1968. It supported COBOL, FORTRAN and ALGAMS (a version of ALGOL). This and earlier versions also used a <b>machine-oriented</b> <b>language</b> called AKI (AvtoKod [...] "Inzhener", i.e., [...] "Engineer's Autocode"). It stood {{somewhere between the}} native assembly language SSK (Sistema Simvolicheskogo Kodirovaniya, or [...] "System of symbolic coding") and higher-level languages, like FORTRAN.|$|E
50|$|PL-11 is a {{high-level}} <b>machine-oriented</b> programming <b>language</b> for the PDP-11, developed by R.D. Russell of CERN in 1971. Written in Fortran IV, it {{is similar to}} PL360 and is cross-compiled on other machines.|$|R
40|$|Within {{the paper}} a {{description}} of communication model of plug-in based emuStudio emulation platform is given. The platform mentioned above allows the emulation of whole computer systems, configurable {{to the level of}} its components, represented by the plug-in modules of the platform. Development tasks still are in progress at the home institution of the authors. Currently the platform is exploited for teaching purposes within subjects aimed at <b>machine-oriented</b> <b>languages</b> and computer architectures. Versatility of the platform, given by its plug-in based architecture is a big advantage, when used as a teaching support tool. The paper briefly describes the emuStudio platform at its introductory part and then the mechanisms of inter-module communication are described...|$|R
40|$|A new language, Feldspar, is presented, {{enabling}} high-level and platform-independent {{description of}} {{digital signal processing}} (DSP) algorithms. Feldspar is a pure functional language embedded in Haskell. It offers a high-level dataflow style of programming, {{as well as a}} more mathematical style based on vector indices. The key to generating efficient code from such descriptions is a high-level optimization technique called vector fusion. Feldspar is based on a low-level, functional core language which has a relatively small semantic gap to <b>machine-oriented</b> <b>languages</b> like C. The core language serves as the interface to the back-end code generator, which produces C. For very small examples, the generated code performs comparably to hand-written C code when run on a DSP target. While initial results are promising, to achieve good performance on larger examples, issues related to memory access patterns and array copying will have to be addressed...|$|R
40|$|For decades we {{have been}} using Chomsky's {{generative}} system of grammars, particularly context-free grammars (CFGs) and regular expressions (REs), to express the syntax of programming languages and protocols. The power of generative grammars to express ambiguity is crucial to their original purpose of modelling natural languages, but this very power makes it unnecessarily difficult both to express and to parse <b>machine-oriented</b> <b>languages</b> using CFGs. Parsing Expression Grammars (PEGs) provide an alternative, recognition-based formal foundation for describing machineoriented syntax, which solves the ambiguity problem by not introducing ambiguity in the first place. Where CFGs express nondeterministic choice between alternatives, PEGs instead use prioritized choice. PEGs address frequently felt expressiveness limitations of CFGs and REs, simplifying syntax definitions and making it unnecessary to separate their lexical and hierarchical components. A linear-time parser can be built for any PEG, avoiding both the complexity and fickleness of LR parsers and the inefficiency of generalized CFG parsing. While PEGs provide a rich set of operators for constructing grammars, they are reducible to two minimal recognition schemas developed around 1970, TS/TDPL and gTS/GTDPL, which are here proven equivalent in effective recognition power...|$|R
40|$|This paper {{describes}} {{features for}} programming CAMAC easily and efficiently in the programming language PL- 11. PL- 11 is an intermediate-level, <b>machine-oriented</b> programming <b>language</b> for the PDP- 11 computer. It {{was designed and}} implemented as the programming tool for the on-line minicomputers used in data acquisition at the CERN OMEGA project. Because all the experiment electronics {{are connected to the}} computer via CAMAC, facilities have been incorporated into PL- 11 that enable the physicists to program both CAMAC and the PDP- 11 in a single language. This paper, which is a condensation of an earlier paper, discussed just the features of the language that are related to CAMAC...|$|R
40|$|We {{present a}} {{language}} for programmable controllers (PLC) that {{conforms to the}} International Standard IEC 1131. This language has a fully formalized syntactic and semantic definition. Moreover, {{there is also a}} formal definition of the <b>machine-oriented</b> target <b>language</b> such that the whole compilation process is rigorously specified. The availability of these formal definitions also allows early prototyping and systematic testing on several levels of abstraction. INTRODUCTION Safety-critical applications necessitate high quality in the software production process. One important ingredient for achieving this high quality is the use of well-designed programming languages and adequate support tools, such as compilers. The language design has to be oriented towards the application domain, it must conform to given standards, and it must be easily comprehensible. In order to foster the acceptance of such languages in safety-critical environments, the relevant support tools have to meet high sta [...] ...|$|R
40|$|In {{this paper}} we present {{interface}} techniques {{that support the}} writing process of <b>machine-oriented</b> controlled natural <b>languages</b> which are well-defined and tractable fragments of English that can be translated unambiguously into a formal target language. Since these languages have grammatical and lexical restrictions, {{it is important to}} provide a text editor that assists the writing process by using lookahead information derived from the grammar. We will discuss the requirements to such a lookahead text editor and introduce the semantic wiki AceWiki as an application where this technology plays an important role. We investigate two different approaches how lookahead information can be generated dynamically while a text is written and compare the runtimes and practicality of these approaches in detail. ...|$|R
40|$|This paper {{presents}} {{a survey of}} research in controlled natural languages {{that can be used}} as high-level knowledge representation languages. Over the past 10 years or so, a number of <b>machine-oriented</b> controlled natural <b>languages</b> have emerged that can be used as high-level interface languages to various kinds of knowledge systems. These languages are relevant to the area of computational linguistics since they have two very interesting properties: firstly, they look informal like natural languages and are therefore easier to write and understand by humans than formal languages; secondly, they are precisely defined subsets of natural languages and can be translated automatically (and often deterministically) into a formal target language and then be used for automated reasoning. We present and compare the most mature of these novel languages, show how they can balance the disadvantages of natural languages and formal languages for knowledge representation, and discuss how domain specialists can be supported writing specifications in controlled natural language. ...|$|R

