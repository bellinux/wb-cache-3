155|277|Public
50|$|Members of a view {{can request}} that <b>multicast</b> <b>messages</b> {{be sent to}} a process group without {{knowledge}} of the membership that will apply {{at the time of}} delivery.|$|E
50|$|As noted earlier, {{the members}} of a group observe the same {{sequence}} of upcalls starting when they initially join: an initial view and then a sequence of new views and <b>multicast</b> <b>messages.</b> All members of a group receive any particular multicast in the same view, and the multicast is delivered to all non-failed members of that view.|$|E
5000|$|Continuity Check Protocol (CCP): [...] "Heartbeating" [...] {{messages}} for CFM. The Continuity Check Message (CCM) {{provides a means}} to detect connectivity failures in an MA. CCMs are <b>multicast</b> <b>messages.</b> CCMs are confined to a domain (MD). These messages are unidirectional and do not solicit a response. Each MEP transmits a periodic multicast Continuity Check Message inward towards the other MEPs.|$|E
5000|$|Reliable unicast and <b>multicast</b> <b>message</b> transmission. Lost {{messages}} are retransmitted ...|$|R
40|$|OTM Confederated International Conferences, CoopIS, DOA, GADA, and ODBASE 2006; Montpellier; France; 29 October 2006 through 3 November 2006 Group {{communication}} {{is an important}} paradigm for fault tolerance in large scale systems. We describe various group architectures as pipelined, hierarchical, daisy and hypercube groups each consisting of separate clusters, investigate the theoretical performance bounds of these architectures and evaluate their experimental performances using MPI group communication primitives. We first derive time bounds for <b>multicast</b> <b>message</b> deliveries in these architectures and then provide tests to measure the times taken for the same operation. The <b>multicast</b> <b>message</b> delivery times are tested against the number of clusters within a group {{and the size of}} the <b>multicast</b> <b>message.</b> We conclude that daisy architecture is favorable both in terms of delivery times and message sizes theoretically and experimentally...|$|R
5000|$|... in {{computer}} networks, {{it may be}} useful in identifying an efficient way to route a <b>multicast</b> <b>message</b> to a set of destinations.|$|R
50|$|The basic {{guarantee}} {{associated with}} the model is that all processes belonging to a group see the same events, in the same order. The platform senses failures (using timeouts) but reports them in a consistent manner to all group members. <b>Multicast</b> <b>messages</b> may be initiated concurrently by multiple senders, but will be delivered in some fixed order selected by the protocols implementing the model.|$|E
50|$|Quorums {{are used}} to {{guarantee}} the safety properties of Gbcast by ensuring {{that there is a}} single globally agreed-upon sequence of group views and <b>multicast</b> <b>messages</b> and by preventing progress in more than one partition if a group becomes fragmented into two or more partitions (disjoint subsets of members that can communicate with other members of their subsets, but not with members of other subsets). Quorums are defined for a specific view.|$|E
50|$|An IP {{multicast}} group address {{is used by}} sources and the receivers to send and receive <b>multicast</b> <b>messages.</b> Sources use the group address as the IP destination address in their data packets. Receivers use this group address to inform the network that {{they are interested in}} receiving packets sent to that group. For example, if some content is associated with group 239.1.1.1, the source will send data packets destined to 239.1.1.1. Receivers for that content will inform the network that they are interested in receiving data packets sent to the group 239.1.1.1. The receiver joins 239.1.1.1. The protocol typically used by receivers to join a group is called the Internet Group Management Protocol (IGMP).|$|E
50|$|In IEEE 1588-2002, all PTP {{messages}} are sent using <b>multicast</b> <b>messaging,</b> while IEEE 1588-2008 introduced {{an option for}} devices to negotiate unicast transmission on a port-by-port basis.|$|R
40|$|A Method for {{transmitting}} {{a message}} from a sender (2) {{to a set of}} multiple receivers (4 a- 4 d) over a network comprises sending a <b>multicast</b> <b>message</b> (10) to the set of multiple receivers (4 a- 4 d) and receiving acknowledgement messages (12) from a subset of the receivers (4 a, 4 b, 4 d), each acknowledgement message (12) indicating the receipt of the <b>multicast</b> <b>message</b> (10) by a single receiver. The method further comprises sending a unicast message (14) to a receiver of the set of receivers which {{is not part of the}} subset of the receivers (4 c) ...|$|R
40|$|Abstract. Group {{communication}} {{is an important}} paradigm for fault tolerance in large scale systems. We describe various group architectures as pipelined, hierarchical, daisy and hypercube groups each consisting of separate clusters, investigate the theoretical performance bounds of these architectures and evaluate their experimental performances using MPI group communication primitives. We first derive time bounds for <b>multicast</b> <b>message</b> deliveries in these architectures and then provide tests to measure the times taken for the same operation. The multicast mes-sage delivery times are tested against the number of clusters within a group {{and the size of}} the <b>multicast</b> <b>message.</b> We conclude that daisy ar-chitecture is favorable both in terms of delivery times and message sizes theoretically and experimentally. ...|$|R
50|$|The set {{of group}} members changes {{each time a}} member fails or joins, and Gbcast {{is also used to}} {{maintain}} group membership by means of special multicasts that are delivered to the application as “new view” events, but that also adjust the group membership list maintained by the Gbcast protocol library. The application thus sees a series of membership views that start with an “initial view” when a particular group member joins, and then evolve over time, and that are ordered with respect to other view-changing events and <b>multicast</b> <b>messages.</b> These multicasts are delivered to all the non-failed members listed in the view during which delivery is scheduled, a property referred to as virtual synchrony.|$|E
50|$|The leader proposes some {{sequence}} {{of one or}} more <b>multicast</b> <b>messages</b> by using the 1-to-all reliable network layer to send the message(s) {{to the members of the}} most current view, identifying each by means of an integer sequence number. The sequence numbers reset to 1 as each new view is defined (via a special kind of multicast, as explained below). A leader “talks to itself”, participating in the protocol just as do other members. During recovery (discussed below), a new leader might re-propose some previously proposed view or message, as the new leader attempts to complete protocols that the old leader might have started but failed to complete. When this occurs, the new leader will respect the original sequencing and will re-propose the identical view or message.|$|E
50|$|The term live {{distributed}} {{object was}} first used informally {{in a series of}} presentations given in the fall of 2006 at an ICWS conference, STC conference, and at the MSR labs in Redmond, WA, and then formally defined in 2007, in an IEEE Internet Computing article. Originally, the term was used to refer to the types of dynamic, interactive Web content that is not hosted on servers in data centers, but rather stored on the end-user's client computers, and internally powered by instances of reliable multicast protocols. The word live expressed the fact that the displayed information is dynamic, interactive, and represents current, fresh, live content that reflects recent updates made by the users (as opposed to static, read-only, and archival content that has been pre-assembled). The word distributed expressed the fact that the information is not hosted, stored at a server in a data center, but rather, it is replicated among the end-user computers, and updated in a peer-to-peer fashion through a stream of <b>multicast</b> <b>messages</b> that may be produced directly by the end-users consuming the content; a more comprehensive discussion of the live object concept in the context of Web development can be found in Krzysztof Ostrowski's Ph.D. dissertation.|$|E
40|$|This paper {{presents}} an efficient routing and flow control mechanism to implement multidestination message passing in wormhole networks. It is targeted to {{situations where the}} size of message data is very small, like in invalidation and update messages in distributed shared-memory multipro-cessors (DSMs) with hardware cache coherence. The mech-anism is a variation of tree-based multicast with pruning to avoid deadlocks. The new scheme does not require that the destination addresses in a given <b>multicast</b> <b>message</b> be ordered, thereby avoiding any ordering overhead. It al-lows messages to use any deadlock-free routing functionand only requires one startup for each <b>multicast</b> <b>message.</b> The new scheme has been evaluated on several k-ary n-cube networks under synthetic loads. The {{results show that the}} proposed scheme is faster than other multicast mechanisms when the multicast traffic is composed of short messages. 1...|$|R
50|$|When an mDNS client {{needs to}} resolve a host name, it sends an IP <b>multicast</b> query <b>message</b> that asks the host having that name to {{identify}} itself. That target machine then <b>multicasts</b> a <b>message</b> that includes its IP address. All machines in that subnet can then use that information to update their mDNS caches.|$|R
40|$|Abstract — SOAP {{has been}} widely adopted as a simple, robust and {{extensible}} XML-based protocol for the exchange of messages among web services. Unfortunately, SOAP communications have two major performance-related drawbacks: i) verbosity, related to XML, that leads to increased network traffic, and ii) high computational burden of XML parsing and processing, that leads to high latency. In this paper, we address these two issues and introduce a novel framework for Differential SOAP Multicasting (DSM). The main idea consists in identifying the common pattern and differences between SOAP messages, modeled as trees, so as to <b>multicast</b> similar <b>messages</b> together. Our method {{is based on the}} well known concept of Tree Edit Distance, built upon a novel filter-differencing architecture to reduce message aggregation time, identifying only those messages which are relevant (i. e., similar enough) for similarity evaluation. In addition, our technique exploits a dedicated differencing output format specifically designed to carry the minimum amount of diff information, in the <b>multicast</b> <b>message,</b> so as to minimize the <b>multicast</b> <b>message</b> size, and therefore reducing the network traffic. The battery of simulation experiments conducted to evaluate our approach shows the relevance of our method in comparison with traditional and dedicated multicasting techniques...|$|R
5000|$|GDOI [...] "interprets" [...] IKE or ISAKMP for {{the group}} {{security}} domain in addition to pair-wise security associations. GDOI uses an IKE v1 Phase 1 security association for authenticating a GDOI member to a GDOI controller. The IKE/GDOI Phase 1 cryptographic protocol exchange protects {{a new type of}} Phase 2 exchange in which the member requests ("pulls") group state from the controller. The [...] "group key" [...] is the most important state in a GDOI member. The group key encrypts keys that decrypt application data. Thus, the group key is also called a [...] "key encrypting key" [...] in GDOI. A group's key-encrypting key is used for the [...] "Rekey Security Association". Once the [...] "Rekey-SA" [...] is established, the GDOI controller can send ("push") unsolicited updates to the group security association to members over multicast, broadcast or unicast channels. This is why GDOI is called a [...] "multicast key management system" [...] as it uses and supports multicast messaging for very large groups. These <b>multicast</b> <b>messages</b> are unsolicited messages and are therefore called [...] "push" [...] messages, which are unsolicited messages sent from the controller to the members; explicit requests from a member to a controller are called [...] "pull" [...] messages in GDOI. Thus GDOI group key updates are pushed and can reach any number of group members with a single efficient transmission from the controller.|$|E
3000|$|... are the {{corresponding}} transmit power levels selected for BS-i when scheduled to transmit its <b>multicast</b> <b>messages</b> in time slot j, and the indicator function I [...]...|$|E
40|$|We study {{dependable}} {{group communication}} for largescale and delay-sensitive mission critical applications. The {{goal is to}} design a protocol that imposes low loads on bottleneck network links and provides both stable throughput and fast delivery of <b>multicast</b> <b>messages</b> even {{in the presence of}} frequent node and link failures. To this end, we propose our GoCast protocol. GoCast builds a resilient overlay network that is proximity aware and has balanced node degrees. <b>Multicast</b> <b>messages</b> propagate rapidly through an efficient tree embedded in the overlay. In the background, nodes exchange message summaries (gossips) with their overlay neighbors and pick up missing messages due to disruptions in the tree-based multicast. Our simulation based on real Internet data shows that, compared with a traditional gossip-based multicast protocol, GoCast can reduce the delivery delay of <b>multicast</b> <b>messages</b> by a factor of 8. 9 when no node fails or a factor of 2. 3 when 20 % nodes fail. 1...|$|E
30|$|Use {{cases for}} {{multicast}} IPC are connectionless servers that propagate {{information to the}} (local) network [53] e.g. simultaneous updates of databases (replication), the propagation of intermediate results in grids, multiplayer games or realtime news [54]. <b>Multicast</b> <b>messaging</b> has also been found applicable to Map Reduce {{where it can be}} used to propagate tasks and results [55].|$|R
30|$|Multicast routing {{protocols}} in {{wireless sensor networks}} are required for sending the same message to multiple different destinations. In this paper, we propose two different distributed algorithms for multicast routing in wireless sensor networks which make use of location information of sensor nodes. Our first algorithm groups the destination nodes according to their angular positions and forwards the <b>multicast</b> <b>message</b> toward each group {{in order to reduce}} the number of total branches in multicast tree which also reduces the number of messages transmitted. Our second algorithm calculates an Euclidean minimum spanning tree at the source node by using the positions of the destination nodes. The <b>multicast</b> <b>message</b> is forwarded to destination nodes according to the calculated MST. This helps in reducing the total energy consumed for delivering the message to all destinations by decreasing the number of total transmissions. Evaluation results show that the algorithms we propose are scalable and energy efficient, so they are good candidates to be used for multicasting in wireless sensor networks.|$|R
40|$|International audience—Emerging ITS {{applications}} such as fleet manage-ment and point of interest distribution require vehicles to have Internet access. However, allowing vehicles to access to the Internet is particularly challenging due to the special char-acteristics of the vehicular environment. So far, multicasting approaches have been demonstrated to be effective for supporting group communication in traditional networks. However, such Internet-to-VANET multicast service involves several challenges including efficient multicast mobility management and <b>multicast</b> <b>message</b> delivery. This paper proposes a scheme that combines the existing multicast mobility management scheme with vehicular networking solutions to achieve Internet-to-VANET multicasting. The proposed scheme aims to: (i) provide multicast mobility management with low control overhead and efficient bandwidth utilization, as well as (ii) extend the service coverage provided by VANET membership management and <b>multicast</b> <b>message</b> delivery protocol. Simulation results indicate that our Motion-MAODV scheme improves the performance of both MAODV and traditional flooding dissemination schemes {{in terms of both}} packet delivery ratio and end-to-end transmission latency...|$|R
40|$|The {{question}} of increase of efficiency of {{transfer of the}} information {{is considered due to}} formation of the steady virtual channel. For routing it is offered to use a steady subgraph of <b>multicast</b> <b>messages.</b> The algorithm of formation of maximum steady way is offered. ?????????? ?????? ??????????? ???????????????? ???????? ?????????? ? ????????? ?????. ??? ????????????? ???????????? ???????????? ?????????? ??????? ????????????? ???????? ?????????. ????????? ???????? ???????????? ??????????? ??????????? ????...|$|E
3000|$|The {{number of}} {{multicast}} packets per frame {{required to be}} transmitted by base stations with <b>multicast</b> <b>messages</b> to distribute is assigned by the upper layer operations and {{is determined by the}} statistics of total offered load and the desired delay-throughput performance metrics. These calculations produce the requirement of [...]...|$|E
30|$|Both GOOSE and SMV {{messages}} are <b>multicast</b> <b>messages,</b> so the static multicast management or GMRP can be adopted to manage them. Static multicast management and GMRP works in similar pattern, {{both of which}} are achieved by maintaining the internal filtering database (FDB) in the switch, and the final filtering work is done by switching chip according to the FDB.|$|E
40|$|In this paper, {{we study}} {{the problem of}} {{constructing}} minimum energy multicast trees in Wireless Ad hoc NETworks (WANETs). We propose a distributed algorithm G-REMiT which adapts an existing group-shared multicast tree into a more energy-efficient multicast tree through local refinements. The algorithm {{takes into account the}} <b>multicast</b> <b>message</b> arrival rates on its various incident links and their respecting forwarding costs (in terms of energy it has to expend in forwarding them all its tree neighbors except the one from which it received the <b>multicast</b> <b>message)</b> to determine how to locally restructure a tree so as to improve tree’s energy cost (TEC) without causing the tree to get disconnected. Our qualitative analysis and simulations show that G-REMiT(MST), which denotes the G-REMiT algorithm with minimum spanning tree as the initial tree, outperforms other proposed algorithms such as BIP/MIP and EWMA. Key words: Wireless ad hoc networks, multicast, energy efficient, distributed algorithm, localized optimizatio...|$|R
40|$|Web services’ (WS) {{emphasis}} on open standards provides substantial benefits over previous application integration techniques. A major WS feature is SOAP, a simple, robust and extensible XML-based protocol for {{the exchange of}} messages. For this reason, SOAP WS on virtual hosts are now widely used to provide shared functionalities on clouds. Unfortunately, SOAP has two major performance-related drawbacks: i) verbosity, related to XML, that leads to increased network traffic, and ii) high computational burden of XML parsing and processing, that leads to high latency. In this paper, we address these two issues and present new results regarding our framework for Differential SOAP Multicasting (DSM). The main idea behind our framework is identifying the common pattern and differences between SOAP messages, modeled as trees, so as to <b>multicast</b> similar <b>messages</b> together. Our method {{is based on the}} well known concept of Tree Edit Distance, built upon a novel filter-differencing architecture to reduce message aggregation time, identifying only those messages which are relevant (i. e., similar enough) for similarity evaluation. In this paper we focus on recent improvements to the filter-differencing architecture, including a dedicated differencing output format designed to carry the minimum amount of diff information, in the <b>multicast</b> <b>message,</b> so as to minimize the <b>multicast</b> <b>message</b> size, and therefore reduce the network traffic. Simulation experiments highlight the relevance of our method in comparison with traditional and dedicated multicasting techniques. PublishedN/...|$|R
40|$|Abstract Multicast routing {{protocols}} in {{wireless sensor networks}} are required for sending the same message to multiple different destinations. In this paper, we propose two different distributed algorithms for multicast routing in wireless sensor networks which make use of location information of sensor nodes. Our first algorithm groups the destination nodes according to their angular positions and forwards the <b>multicast</b> <b>message</b> toward each group {{in order to reduce}} the number of total branches in multicast tree which also reduces the number of messages transmitted. Our second algorithm calculates an Euclidean minimum spanning tree at the source node by using the positions of the destination nodes. The <b>multicast</b> <b>message</b> is forwarded to destination nodes according to the calculated MST. This helps in reducing the total energy consumed for delivering the message to all destinations by decreasing the number of total transmissions. Evaluation results show that the algorithms we propose are scalable and energy efficient, so they are good candidates to be used for multicasting in wireless sensor networks. </p...|$|R
40|$|Introduction Prototype-based {{languages}} (PBLs) {{are good}} at sharing information between objects, while sharing is a ubiquitous problem in distributed application programming (due to concurrency and partial failures). New language concepts can exploit the advantages of PBLs to ease the distribution problems. Distributed Object Inheritance Objects can share information with {{each other through the}} use of object inheritance. When an object receives a message that it does not know it can delegate that message to its object parent, which then executes that message in the context of original receiver. The child - parent object relation may be distributed over multiple machines. Communication Patterns Object inheritance raises the split object problem. The split object problem can be solved by transparent <b>multicast</b> <b>messages,</b> depending on the required semantics of the split object. <b>Multicast</b> <b>messages</b> are introduced via: WE keyword Multivalue references Per Object When objects are conc...|$|E
40|$|DTLS is a {{standardized}} security protocol {{designed to provide}} end-to-end secure communication among two peers, and particularly considered for the emerging Internet of Things. In order to protect group communication, the IETF {{is currently working on}} a method to secure <b>multicast</b> <b>messages</b> through the same DTLS security services. However, such an approach relies on traditional DTLS sessions to protect unicast responses to <b>multicast</b> <b>messages.</b> This increases the amount of security material stored by group members and can have a relevant impact on network performance. In this paper we propose an extension to the IETF approach which allows to efficiently protect group responses by reusing the same group key material. Our proposal does not require to establish additional DTLS sessions, thus preserving high communication performance within the group and limiting storage overhead on group members. Furthermore, we discuss a suitable key management policy to provision and renew group key material...|$|E
40|$|Delivering {{information}} to every user on a pre-specified geographic area via the Internet {{can be accomplished}} by geocasting in single-hop cellular networks. Geocasting is the mechanism to <b>multicast</b> <b>messages</b> to the network nodes whose physical locations lie within a given geographic area, termed the target area. In this paper, we propose the use of cellular ad hoc augmented network (CAHAN...|$|E
40|$|This letter {{considers}} a two-receiver multiple-input multiple-output (MIMO) Gaussian broadcast channel model with integrated services. Specifically, we combine two sorts of service messages, and serve them simultaneously: one <b>multicast</b> <b>message</b> intended for both receivers and one confidential message intended {{for only one}} receiver. The confidential message is kept perfectly secure from the unauthorized receiver. Due to the coupling of service messages, it is intractable to seek capacity-achieving transmit covariance matrices. Accordingly, we propose a suboptimal precoding scheme based on the generalized singular value decomposition (GSVD). The GSVD produces several virtual orthogonal subchannels between the transmitter and the receivers. Subchannel allocation and power allocation between <b>multicast</b> <b>message</b> and confidential message are jointly optimized to maximize the secrecy rate in this letter, subject {{to the quality of}} multicast service (QoMS) constraints. Since this problem is inherently complex, a difference-of-concave (DC) algorithm, together with an exhaustive search, is exploited to handle the power allocation and subchannel allocation, respectively. Numerical results are presented to illustrate the efficacy of our proposed strategies. Comment: IEEE Signal Processing Letters (Volume: 23, Issue: 11, Nov. 2016...|$|R
30|$|To illustrate, {{conventional}} message queues {{are frequently}} deployed to enable parallelism {{by using a}} broker to decouple the sender and receiver. The publish/subscriber paradigm where subscribers are notified when a message that is interesting to them has arrived is a very popular means to achieve asynchronous message passing communication although the underlying protocols (e.g. TCP or RPC) are strictly synchronous. CMQ instead is inherently asynchronous and offers <b>multicast</b> <b>Messaging</b> without {{the need to maintain}} publish/subscriber channels.|$|R
40|$|We {{address the}} problem of {{providing}} transparent, reliable, and efficient network-level multicasting in wormhole LANs. We describe some alternatives for achieving deadlock-free multicasting using fast buffer reservation techniques at the host interface level. Tradeoffs involving complexity and performance of various solutions are discussed, and are illustrated using simulation results. Our results show that in most cases the straightforward approach of sending multiple unicast copies of the <b>multicast</b> <b>message</b> at the originator host {{turns out to be the}} most simple and effective approac...|$|R
