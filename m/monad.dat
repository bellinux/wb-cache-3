1855|879|Public
25|$|The {{simplest}} <b>monad</b> is {{the identity}} <b>monad,</b> which attaches no information to values.|$|E
25|$|A type {{constructor}} that defines, {{for every}} underlying type, how {{to obtain a}} corresponding monadic type. In Haskell's notation, {{the name of the}} <b>monad</b> represents the type constructor. If M {{is the name of the}} <b>monad</b> and t is a data type, then Mnbsp&t is the corresponding type in the <b>monad.</b>|$|E
25|$|The <b>monad</b> {{represents}} computations with a sequential structure: a <b>monad</b> defines what {{it means}} to chain operations together. This enables the programmer to build pipelines that process data in a series of steps (i.e. a series of actions applied to the data), in which each action is decorated with the additional processing rules provided by the <b>monad.</b> A <b>monad</b> is defined by a return operator that creates values, and a bind operator used to link the actions in the pipeline; this definition must follow a set of axioms called <b>monad</b> laws, which are needed for the composition of actions in the pipeline to work properly.|$|E
40|$|We {{introduce}} a generalization of <b>monads,</b> called relative <b>monads,</b> allowing for underlying functors between different categories. Examples include finite-dimensional vector spaces, untyped and typed lambda-calculus syntax and indexed containers. We {{show that the}} Kleisli and Eilenberg-Moore constructions carry over to relative <b>monads</b> and are related to relative adjunctions. Under reasonable assumptions, relative <b>monads</b> are monoids in the functor category concerned and extend to <b>monads,</b> giving rise to a coreflection between relative <b>monads</b> and <b>monads.</b> Arrows are also an instance of relative <b>monads...</b>|$|R
5000|$|It is {{possible}} to define <b>monads</b> in a 2-category [...] <b>Monads</b> described above are <b>monads</b> for [...]|$|R
40|$|Abstract. The use of <b>monads</b> to {{structure}} functional programs is de-scribed. <b>Monads</b> provide a convenient framework for simulating effects {{found in other}} languages, such as global state, exception handling, out-put, or non-determinism. Three case studies are looked at in detail: how <b>monads</b> ease the modification of a simple evaluator; how <b>monads</b> act {{as the basis of}} a datatype of arrays subject to in-place update; and how <b>monads</b> can be used to build parsers. ...|$|R
25|$|The {{notation}} of list comprehensions {{is similar}} to the set-builder notation, but sets can't be made into a <b>monad,</b> since there's a restriction on the type of computation to be comparable for equality, whereas a <b>monad</b> does not put any constraints on the types of computations. Actually, the Set is a restricted <b>monad.</b>|$|E
25|$|The {{operations}} {{that define the}} <b>monad</b> must fulfil several properties to allow the correct composition of monadic functions (i.e. functions that use values from the <b>monad</b> as their arguments or return value). Because a <b>monad</b> can insert additional operations around a program's domain logic, monads {{can be considered a}} sort of aspect-oriented programming. The domain logic can be defined by the application programmer in the pipeline, while required aside bookkeeping operations can be handled by a pre-defined <b>monad</b> built in advance.|$|E
25|$|Two {{examples}} are often given when introducing monads: the Maybe <b>monad,</b> which represent computations where expressions can contain null values, and the I/O <b>monad,</b> which represent computations that interact with input/output effects. Of course, monads are {{not restricted to}} the Haskell language. The examples section below shows in JavaScript the Writer <b>monad,</b> which accumulates a separate log alongside the main chain of values in a computation.|$|E
40|$|Parameterised <b>monads</b> {{have the}} same {{relationship}} to adjunctions with parameters as <b>monads</b> do to adjunctions. In this paper, we investigate algebras for parameterised <b>monads.</b> We identify the Eilenberg-Moore category of algebras for parameterised <b>monads</b> and prove a generalisation of Beck’s theorem characterising this category. We demonstrate an application of this theory to the semantics of type and effect systems...|$|R
40|$|Models of {{iterated}} computation, such as (completely) iterative <b>monads,</b> often {{depend on}} a notion of guardedness, which guarantees unique solvability of recursive equations and requires roughly that recursive calls happen only under certain guarding operations. On the other hand, many models of iteration do admit unguarded iteration. Solutions are then no longer unique, and in general not even determined as least or greatest fixpoints, being instead governed by quasi-equational axioms. <b>Monads</b> that support unguarded iteration in this sense are called (complete) Elgot <b>monads.</b> Here, we propose to equip (Kleisli categories of) <b>monads</b> with an abstract notion of guardedness and then require solvability of abstractly guarded recursive equations; examples of such abstractly guarded pre-iterative <b>monads</b> include both iterative <b>monads</b> and Elgot <b>monads,</b> the latter by deeming any recursive definition to be abstractly guarded. Our main result is then that Elgot <b>monads</b> are precisely the iteration-congruent retracts of abstractly guarded iterative <b>monads,</b> the latter being defined as admitting unique solutions of abstractly guarded recursive equations; in other words, models of unguarded iteration come about by quotienting models of guarded iteration...|$|R
2500|$|Leibniz's {{best known}} {{contribution}} to metaphysics is {{his theory of}} <b>monads,</b> as exposited in Monadologie. According to Leibniz, <b>monads</b> are elementary particles with blurred perceptions of one another. [...] <b>Monads</b> can also {{be compared to the}} corpuscles of the Mechanical Philosophy of René Descartes and others. <b>Monads</b> are the ultimate elements of the universe. The <b>monads</b> are [...] "substantial forms of being" [...] with the following properties: they are eternal, indecomposable, individual, subject to their own laws, un-interacting, and each reflecting the entire universe in a pre-established harmony (a historically important example of panpsychism). <b>Monads</b> are centers of force; substance is force, while space, matter, and motion are merely phenomenal.|$|R
25|$|A state <b>monad</b> {{allows a}} {{programmer}} to attach state information {{of any type}} to a calculation. Given any value type, the corresponding type in the state <b>monad</b> is a function which accepts a state, then outputs a new state (of type s) along with a return value (of type t). This is similar to an environment <b>monad,</b> except that it also return a new state, and thus allows modeling a mutable environment.|$|E
25|$|Every <b>monad</b> {{arises from}} some adjunction—in fact, {{typically}} from many adjunctions—in the above fashion. Two constructions, called {{the category of}} Eilenberg–Moore algebras and the Kleisli category are two extremal {{solutions to the problem}} of constructing an adjunction that gives rise to a given <b>monad.</b>|$|E
25|$|A <b>monad</b> is a {{construction}} that, given an underlying type system, embeds a corresponding type system (called the monadic type system) into it (that is, each monadic type {{acts as the}} underlying type). This monadic type system preserves all significant aspects of the underlying type system, while adding features particular to the <b>monad.</b>|$|E
5000|$|The 2-category of <b>monads</b> in [...] is the 2-category of monoidal <b>monads</b> [...] {{and it is}} {{isomorphic}} to the 2-category [...] of monoidales (or pseudomonoids) in {{the category}} of <b>monads</b> , (lax) monoidal arrows between them and monoidal cells between them.|$|R
5000|$|The {{following}} <b>monads</b> on {{the category}} of sets, with its cartesian monoidal structure, are not monoidal <b>monads</b> ...|$|R
40|$|<b>Monads</b> are now an {{everyday}} tool in functional programming for abstracting and delimiting effects. The link between <b>monads</b> and effect systems is well-known, {{but in their}} typical use, <b>monads</b> provide a much more coarse-grained view of effects. Effect systems capture fine-grained information about the effects, but <b>monads</b> provide only a binary view: effectful or pure. Recent theoretical work has unified fine-grained effect systems with <b>monads</b> using a monad-like structure indexed by a monoid of effect annotations (called parametric effect <b>monads).</b> This aligns the power of <b>monads</b> {{with the power of}} effect systems. This paper leverages recent advances in Haskell's type system (as provided by GHC) to embed this approach in Haskell, providing user-programmable effect systems. We explore a number of practical examples that make Haskell even better and safer for effectful programming. Along the way, we relate the examples to other concepts, such as Haskell's implicit parameters and coeffects...|$|R
25|$|The Communist League of America, 1932-34. New York: <b>Monad</b> Press, 1985.|$|E
25|$|The Great Labor Uprising of 1877. New York: <b>Monad</b> Press, 1977.|$|E
25|$|A do-block in this <b>monad</b> {{performs}} variable substitution; donbsp&{xnbsp&<-nbsp&2;nbsp&returnnbsp&(3*x)} {{results in}} 6.|$|E
5000|$|One {{interesting}} {{fact about}} commutative strong <b>monads</b> {{is that they}} are [...] "the same as" [...] symmetric monoidal <b>monads.</b> More explicitly, ...|$|R
5000|$|Opmonoidal <b>monads</b> {{have been}} studied under various names; Ieke Moerdijk {{introduced}} them as Hopf <b>Monads,</b> in works of Bruguières and Virelizier they are called bimonads, by analogy to [...] "bialgebra", reserving the term [...] "Hopf monad" [...] for opmonoidal <b>monads</b> with an antipode, in analogy to [...] "Hopf algebras".|$|R
40|$|Relative <b>monads</b> are a {{generalisation}} {{of ordinary}} <b>monads</b> where the underlying functor {{need not be}} an endofunctor. In this paper, we describe a formalisation of the basic theory of relative <b>monads</b> in the interactive theorem prover and dependently typed programming language Agda. The formalisation comprises the requisite basic category theory, the central concepts {{of the theory of}} relative <b>monads</b> and adjunctions, which are compared to their ordinary counterparts, and two running examples from programming theory. 1...|$|R
25|$|The Left Opposition in the U.S., 1928-31. New York: <b>Monad</b> Press, 1981.|$|E
25|$|A <b>monad</b> may {{encapsulate}} {{values of}} a particular data type, creating a new type associated with a specific additional computation, typically to handle special cases of the type. For example, the simple Maybe <b>monad</b> encapsulates variables which may have a null value, representing an option type, and automatically ensures that null values are not passed as arguments to functions that cannot handle them, serving as an alternative programming technique to throwing and catching exceptions when null values arise. Another example is the List <b>monad,</b> where the empty list is a constant value of type List, and the cons operator binds a plain value {{as the head of}} a previous list.|$|E
25|$|Mother Jones Speaks: Collected Writings and Speeches. New York : <b>Monad</b> Press, 1983.|$|E
40|$|AbstractWe {{extend the}} basic {{concepts}} of Street’s formal theory of <b>monads</b> from {{the setting of}} 2 -categories to that of double categories. In particular, we introduce the double category Mnd(C) of <b>monads</b> in a double category C and define {{what it means for}} a double category to admit the construction of free <b>monads.</b> Our main theorem shows that, under some mild conditions, a double category that is a framed bicategory admits the construction of free <b>monads</b> if its horizontal 2 -category does. We apply this result to obtain double adjunctions which extend the adjunction between graphs and categories and the adjunction between polynomial endofunctors and polynomial <b>monads...</b>|$|R
5000|$|Leibniz is {{also known}} for his theory of <b>monads,</b> as exposited in Monadologie. <b>Monads</b> are to the metaphysical realm what atoms are to the physical/phenomenal. They can also be {{compared}} to the corpuscles of the Mechanical Philosophy of René Descartes and others. <b>Monads</b> are the ultimate elements of the universe. The <b>monads</b> are [...] "substantial forms of being" [...] with the following properties: they are eternal, indecomposable, individual, subject to their own laws, un-interacting, and each reflecting the entire universe in a pre-established harmony (a historically important example of panpsychism). <b>Monads</b> are centers of force; substance is force, while space, matter, and motion are merely phenomenal.|$|R
5000|$|... 1. Idealism, {{since it}} denies things in {{themselves}} (besides <b>monads)</b> and multiplies them in {{different points of}} view. <b>Monads</b> are “perpetual living mirrors of the universe.” ...|$|R
25|$|<b>Monad</b> {{transformers}} — {{which allow}} monads to be composed in a modular and convenient way.|$|E
25|$|In many Gnostic systems, God {{is known}} as the <b>Monad,</b> the One. God is the high source of the pleroma, the region of light. The various emanations of God are called æons. According to Hippolytus, this view was {{inspired}} by the Pythagoreans, who called the first thing that came into existence the <b>Monad,</b> which begat the dyad, which begat the numbers, which begat the point, begetting lines, etc.|$|E
25|$|Schrenk, Lorenz P., and Frey, Robert L. Northern Pacific Pioneer Steam Era. St. Paul : <b>Monad</b> Publications, 2010.|$|E
40|$|Abstract. <b>Monads</b> are a {{technique}} {{widely used in}} functional program-ming languages to address many dierent problems. This paper presents extensions, a functional-logic programming technique that constitutes an alternative to <b>monads</b> in several situations. Extensions permit the de-nition of easily reusable functions {{in the same way}} as <b>monads,</b> but are based on simpler concepts taken from logic programming, and hence they lead to more appealing and natural denitions of types and functions. Moreover, extensions are compatible with interesting features typical of logic programming, like multiple modes of use, while <b>monads</b> are not. ...|$|R
50|$|The pure {{functional}} programming language Haskell implements them using <b>monads,</b> derived from category theory. <b>Monads</b> offer a way to abstract certain types of computational patterns, including (but not limited to) modeling of computations with mutable state (and other side effects such as I/O) in an imperative manner without losing purity. While existing <b>monads</b> may be easy to apply in a program, given appropriate templates and examples, many students find them difficult to understand conceptually, e.g., when asked to define new <b>monads</b> (which is sometimes needed for certain types of libraries).|$|R
50|$|<b>Monads</b> {{are used}} in {{functional}} programming to express types of sequential computation (sometimes with side-effects). See <b>monads</b> in functional programming, and the more mathematically oriented Wikibook module b:Haskell/Category theory.|$|R
