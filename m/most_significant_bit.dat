316|10000|Public
5|$|The SSEM {{represented}} negative numbers using two's complement, as most computers still do. In that representation, {{the value}} of the <b>most</b> <b>significant</b> <b>bit</b> denotes the sign of a number; positive numbers have a zero in that position and negative numbers a one. Thus the range of numbers that could be held in each 32-bit word was −231 to +231−1 (decimal: −2,147,483,648 to +2,147,483,647).|$|E
25|$|The {{result is}} a signed binary number {{representing}} the decimal value −5 in two's-complement form. The <b>most</b> <b>significant</b> <b>bit</b> is 1, so the value represented is negative.|$|E
25|$|This process {{depends upon}} restricting to 8 bits of precision; a carry to the (nonexistent) 9th <b>most</b> <b>significant</b> <b>bit</b> is ignored, {{resulting}} in the arithmetically correct result of 1010.|$|E
50|$|The xy2d {{function}} works top down, {{starting with}} the <b>most</b> <b>significant</b> <b>bits</b> of x and y, and building up the <b>most</b> <b>significant</b> <b>bits</b> of d first. The d2xy function works in the opposite order, {{starting with the}} least <b>significant</b> <b>bits</b> of d, and building up x and y starting with the least <b>significant</b> <b>bits.</b> Both functions use the rotation function to rotate and flip the (x,y) coordinate system appropriately.|$|R
50|$|By extension, the <b>most</b> <b>significant</b> <b>bits</b> (plural) are {{the bits}} closest to, and including, the MSB.|$|R
5000|$|... (in this case, each octet is padded {{individually}} with null bits {{on their}} unused <b>most</b> <b>significant</b> <b>bits).</b>|$|R
25|$|When using Bit-Encoded-Notation, {{quantities}} like C4 means bit 4 {{from data}} byte C. Each bit is numerated from 0 to 7, so 7 is the <b>most</b> <b>significant</b> <b>bit</b> and 0 {{is the least}} significant bit.|$|E
25|$|A two's-complement {{number system}} encodes {{positive}} and negative numbers in a binary number representation. The weight of each bit is a power of two, except for the <b>most</b> <b>significant</b> <b>bit,</b> whose weight is the negative of the corresponding power of two.|$|E
25|$|Jonathan Swift's 1726 satire, , {{in which}} civil war erupts {{over whether the}} big end or the little end of a boiled egg is the proper end to crack open (analogous to {{counting}} from the end that contains the <b>most</b> <b>significant</b> <b>bit</b> or the least significant bit).|$|E
3000|$|... (a) accumulates the {{differences}} between the two numbers starting from the <b>most</b> <b>significant</b> <b>bits.</b> The state variable [...]...|$|R
5000|$|Choose the {{encoding}} of x, , be {{the first}} [...] <b>most</b> <b>significant</b> <b>bits</b> after the decimal point of Z.|$|R
5000|$|The three <b>most</b> <b>significant</b> <b>bits</b> of the {{instruction}} define the opcode, and divide {{the instruction}}s into 8 classes: ...|$|R
25|$|KOI8-R – 8-bit native Russian {{character}} encoding. Invented in the USSR {{for use on}} Soviet clones of American IBM and DEC computers. The Cyrillic characters go in {{the order}} of their Latin counterparts, which allowed the text to remain readable after transmission via a 7-bit line that removed the <b>most</b> <b>significant</b> <b>bit</b> from each byte—the result became a very rough, but readable, Latin transliteration of Cyrillic. Standard encoding of early 1990s for Unix systems and the first Russian Internet encoding.|$|E
500|$|The Mark 1 had no {{operating}} system; {{its only}} system software {{was a few}} basic routines for input and output. As in the SSEM from which it was developed, and {{in contrast to the}} established mathematical convention, the machine's storage was arranged with the least significant digits to the left; thus a one was represented in five bits as [...] "10000", rather than the more conventional [...] "00001". Negative numbers were represented using two's complement, as most computers still do today. In that representation, the value of the <b>most</b> <b>significant</b> <b>bit</b> denotes the sign of a number; positive numbers have a zero in that position and negative numbers a one. Thus the range of numbers that could be held in each 40-bit word was −239 to +239−1 (decimal: -549,755,813,888 to +549,755,813,887).|$|E
2500|$|The lsbit-first {{representation}} is a hexadecimal number with [...] bits, the <b>most</b> <b>significant</b> <b>bit</b> {{of which is}} always 1. [...] The <b>most</b> <b>significant</b> <b>bit</b> represents the coefficient of [...] and the least significant bit represents the coefficient of [...]|$|E
5000|$|Rotate: the operand {{is treated}} as a {{circular}} buffer of bits so its least and <b>most</b> <b>significant</b> <b>bits</b> are effectively adjacent.|$|R
5000|$|S: Fill the <b>most</b> <b>significant</b> <b>bits</b> {{with the}} value of (&minus;m) in two's {{complement}} notation. Fill the remaining (y + 1) bits with zeros.|$|R
50|$|Fourteen bit point codes can {{be written}} {{in a number of}} formats. The most common formats are decimal number, {{hexadecimal}} number, or 3-8-3 format (3 <b>most</b> <b>significant</b> <b>bits,</b> 8 middle <b>bits,</b> 3 least <b>significant</b> <b>bits).</b>|$|R
2500|$|In two's {{complement}} notation, a non-negative {{number is}} represented by its ordinary binary representation; in this case, the <b>most</b> <b>significant</b> <b>bit</b> is 0. Though, the range of numbers represented {{is not the same}} as with unsigned binary numbers. [...] For example, an 8-bit unsigned number can represent the values 0 to 255 (11111111). [...] However a two's complement 8-bit number can only represent positive integers from 0 to 127 (01111111), because the rest of the bit combinations with the <b>most</b> <b>significant</b> <b>bit</b> as '1' represent the negative integers −1 to −128.|$|E
2500|$|The <b>most</b> <b>significant</b> <b>bit</b> is 0, so {{the pattern}} {{represents}} a non-negative value. To convert to −5 in two's-complement notation, the bits are inverted; 0 becomes 1, and 1 becomes 0: ...|$|E
2500|$|The msbit-first {{representation}} is a hexadecimal number with [...] bits, the {{least significant bit}} of which is always 1. [...] The <b>most</b> <b>significant</b> <b>bit</b> represents the coefficient of [...] and the least significant bit represents the coefficient of [...]|$|E
50|$|ITU-T STL {{defines the}} {{algorithm}} for decoding as follows (it puts the decoded {{values in the}} 13 <b>most</b> <b>significant</b> <b>bits</b> of the 16-bit output data type).|$|R
5000|$|Differential coding: In {{order to}} get a rotation-invariant constellation, this unit shall apply a {{differential}} encoding of the two <b>Most</b> <b>Significant</b> <b>Bits</b> (MSBs) of each symbol.|$|R
25|$|Overflow is {{detected}} {{the same way}} as for addition, by examining the two leftmost (<b>most</b> <b>significant)</b> <b>bits</b> of the borrows; overflow has occurred if they are different.|$|R
2500|$|The <b>most</b> <b>significant</b> <b>bit</b> {{determines the}} sign of the number and is {{sometimes}} called the sign bit. Unlike in sign-and-magnitude representation, the sign bit also has the weight [...] shown above. Using [...] bits, all integers from [...] to [...] can be represented.|$|E
2500|$|Unsigned binary numbers can {{be ordered}} by a simple lexicographic ordering, where the bit value 0 is defined as less than the bit value 1. [...] For two's {{complement}} values, {{the meaning of the}} <b>most</b> <b>significant</b> <b>bit</b> is reversed (i.e. 1 is less than 0).|$|E
2500|$|Since DOS 7.1 the two most-significant bits of {{this cluster}} entry may hold two {{optional}} bitflags representing the current volume status on FAT16 and FAT32, {{but not on}} FAT12 volumes. These bitflags are not supported by all operating systems, but operating systems supporting this feature would set these bits on shutdown and clear the <b>most</b> <b>significant</b> <b>bit</b> on startup: ...|$|E
50|$|The prev_byte_lc_msbs {{value is}} set to the lc (up to 4, from the LZMA header or LZMA2 {{properties}} packet) <b>most</b> <b>significant</b> <b>bits</b> of the previous uncompressed byte.|$|R
40|$|In order toalleviate {{the effect}} of the {{settling}} time of an operational 	amplifier used in a serial A-D converter， the following two methods are 	proposed : 	 1. The m <b>most</b> <b>significant</b> <b>bits</b> are obtained by a parallel converter， the 	remaining bits being obtained by a serial converter. 	 2. The m <b>most</b> <b>significant</b> <b>bits</b> are obtaned by direct use of a high speed 	comparator instead of the operational amplifier. Conversion errors incurred 	due to the poor gain of the comparator are corrected for during the succeeding 	conversion process using the operational amplifier...|$|R
5000|$|Once in 4-bit mode, {{character}} and control data are transferred as pairs of 4-bit [...] "nibbles" [...] {{on the upper}} data pins, D7-D4. The four <b>most</b> <b>significant</b> <b>bits</b> (7-4) must be written first, followed by the four least <b>significant</b> <b>bits</b> (3-0).|$|R
2500|$|Bits 17A–51A encode {{the time}} of the {{following}} minute in binary-coded decimal, <b>most</b> <b>significant</b> <b>bit</b> first. [...] Beginning with bit 17A comes 4 bits of tens of years, 4 bits of years, 1 bit of tens of months, 4 bits of months, 2 bits of tens of days, 4 bits of days, 3 bits of day of week (0=Sunday), 2 bits of tens of hours, 4 bits of hours, 3 bits of tens of minutes, and 4 bits of minutes.|$|E
2500|$|Endianness {{refers to}} the {{sequential}} order in which bytes are arranged into larger numerical values, when stored in computer memory or secondary storage, or when transmitted over digital links. Endianness is of interest in computer science because two conflicting and incompatible formats are in common use: words may be represented in big-endian or little-endian format, depending on whether bits or bytes or other components are ordered from the big end (<b>most</b> <b>significant</b> <b>bit)</b> or the little end (least significant bit).|$|E
2500|$|In this binary expansion, let us {{denote the}} {{positions}} from 0 (leftmost bit, or <b>most</b> <b>significant</b> <b>bit)</b> to 32 (rightmost bit). The 24-bit significand will stop at position23, shown as the underlined bit [...] above. The next bit, at position24, called the round bit or rounding bit, {{can be used}} as follows to round the number on 24 bits to nearest (there are specific rules for halfway values, which is not the case here). This bit, which is [...] in this example, is added to the integer formed by the leftmost 24 bits, yielding: ...|$|E
40|$|Abstract—Let p be a prime and let c be {{an integer}} modulo p. The Pollard {{generator}} (PG) is a sequence (un) of pseudo-random numbers {{defined by the}} relation un+ 1 ≡ u 2 n+c mod p. It is shown that if c and 9 / 14 of the <b>most</b> <b>significant</b> <b>bits</b> of two consecutive values un, un+ 1 of the PG are given, one can recover in polynomial time the initial value u 0 with a probabilistic algorithm. This result is an improvement of a theorem in a recent paper which requires that 2 / 3 of the <b>most</b> <b>significant</b> <b>bits</b> be known...|$|R
40|$|In a {{previous}} paper [quant-ph/ 0408045] we described a quantum algorithm to prepare an arbitrary state of a quantum register with arbitrary fidelity. Here we present an alternative algorithm {{which uses a}} small number of quantum oracles encoding the <b>most</b> <b>significant</b> <b>bits</b> of the absolute value of the complex amplitudes, and {{a small number of}} oracles encoding the <b>most</b> <b>significant</b> <b>bits</b> of the phases. The algorithm given here is considerably simpler than the one described in [quant-ph/ 0408045], on the assumption that a sufficient amount of knowledge about the distribution of the absolute values of the complex amplitudes is available. Comment: 13 page...|$|R
2500|$|The four <b>most</b> <b>significant</b> <b>bits</b> of {{the code}} point are stored in the {{remaining}} low order four bits of this byte (1110 [...] ), leaving 12 bits {{of the code}} point yet to be encoded (...).|$|R
