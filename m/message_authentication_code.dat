517|1194|Public
25|$|The {{connection}} ensures integrity {{because each}} message transmitted includes a message integrity check using a <b>message</b> <b>authentication</b> <b>code</b> to prevent undetected loss or alteration {{of the data}} during transmission.|$|E
25|$|A <b>message</b> <b>authentication</b> <b>code</b> {{computed}} {{over the}} Protocol message, with additional key material included. Note that this field may be encrypted, or not included entirely, {{depending on the}} state of the connection.|$|E
25|$|<b>Message</b> <b>authentication</b> <b>code</b> (MAC) is {{used for}} data integrity. HMAC {{is used for}} CBC mode of block ciphers and stream ciphers. AEAD is used for Authenticated {{encryption}} such as GCM mode and CCM mode.|$|E
50|$|<b>Message</b> <b>authentication</b> is {{typically}} achieved by using <b>message</b> <b>authentication</b> <b>codes</b> (MACs), authenticated encryption (AE) or digital signatures.|$|R
5000|$|CBC-MAC, OMAC and PMAC - Methods to turn block ciphers into <b>message</b> <b>authentication</b> <b>codes</b> (MACs).|$|R
5000|$|OMAC and PMAC - Other {{methods to}} turn block ciphers into <b>message</b> <b>authentication</b> <b>codes</b> (MACs).|$|R
25|$|Because RC4 is {{a stream}} cipher, {{it is more}} {{malleable}} than common block ciphers. If not used together with a strong <b>message</b> <b>authentication</b> <b>code</b> (MAC), then encryption is vulnerable to a bit-flipping attack. The cipher is also vulnerable to a stream cipher attack if not implemented correctly.|$|E
25|$|The HTTP {{scheme was}} {{designed}} by Phillip Hallam-Baker at CERN in 1993 and does not incorporate subsequent improvements in authentication systems, such as the development of keyed-hash <b>message</b> <b>authentication</b> <b>code</b> (HMAC). Although the cryptographic construction that is used {{is based on the}} MD5 hash function, collision attacks were in 2004 generally believed to not affect applications where the plaintext (i.e. password) is not known. However, claims in 2006 cause some doubt over other MD5 applications as well. So far, however, MD5 collision attacks have not been shown to pose a threat to digest authentication, and the RFC 2617 allows servers to implement mechanisms to detect some collision and replay attacks.|$|E
2500|$|Addition of the ChaCha20 {{stream cipher}} with the Poly1305 [...] <b>message</b> <b>authentication</b> <b>code</b> ...|$|E
50|$|<b>Message</b> <b>authentication</b> <b>codes</b> (MACs) {{are often}} built from block ciphers. CBC-MAC, OMAC and PMAC are examples.|$|R
5000|$|... k-wise {{independence}} {{is used in}} the proof that k-independent hashing functions are secure unforgeable <b>message</b> <b>authentication</b> <b>codes.</b>|$|R
25|$|Numbering {{subsequent}} Application {{records with}} a sequence number and using this sequence {{number in the}} <b>message</b> <b>authentication</b> <b>codes</b> (MACs).|$|R
2500|$|The TLS {{protocol}} exchanges records—which encapsulate {{the data}} to be exchanged in a specific format (see below). Each record can be compressed, padded, appended with a <b>message</b> <b>authentication</b> <b>code</b> (MAC), or encrypted, all depending {{on the state of}} the connection. Each record has a content type field that designates the type of data encapsulated, a length field and a TLS version field. The data encapsulated may be control or procedural messages of the TLS itself, or simply the application data needed to be transferred by TLS. The specifications (cipher suite, keys etc.) required to exchange application data by TLS, are agreed upon in the [...] "TLS handshake" [...] between the client requesting the data and the server responding to requests. The protocol therefore defines both the structure of payloads transferred in TLS and the procedure to establish and monitor the transfer.|$|E
50|$|Security {{was based}} on the <b>message</b> <b>authentication</b> <b>code.</b>|$|E
5000|$|Keyed-Hash <b>Message</b> <b>Authentication</b> <b>Code</b> (HMAC) {{based on}} SHA-256, ...|$|E
50|$|<b>Message</b> <b>authentication</b> <b>codes</b> (MACs) (also called keyed hash functions) {{are often}} built from hash functions. HMAC {{is such a}} MAC.|$|R
50|$|Tresorit encrypts files using {{client-side}} encryption with AES-256 before uploading them. Files {{are also}} secured by HMAC <b>message</b> <b>authentication</b> <b>codes</b> applied on SHA-512 hashes.|$|R
30|$|When {{completing}} the AV and Key generation operation, the RADIUS server and the MS apply the HMAC-SHA 1 - 128 function to generate two <b>message</b> <b>authentication</b> <b>codes,</b> AT_MAC and AT_RES attributes, respectively. Furthermore, both <b>message</b> <b>authentication</b> <b>codes</b> are exchanged each other between the RADIUS server and the MS for providing {{the support of}} mutual HMAC authentication operations. In other words, the RADIUS server provides the AT_MAC attribute to the UE for a legal authorization. On the other hand, the MS also provides the AT_RES attribute to the RADIUS server for proofing legal access [14].|$|R
5000|$|Output: {{ciphertext}} and authentication tag (<b>Message</b> <b>Authentication</b> <b>Code).</b>|$|E
5000|$|FIPS PUB 198-1 The Keyed-Hash <b>Message</b> <b>Authentication</b> <b>Code</b> (HMAC) ...|$|E
5000|$|Informally, a <b>message</b> <b>authentication</b> <b>code</b> {{consists}} of three algorithms: ...|$|E
50|$|Lars Ramkilde Knudsen (born 21 February 1962) is a Danish {{researcher}} in cryptography, {{particularly interested in}} the design and analysis of block ciphers, hash functions and <b>message</b> <b>authentication</b> <b>codes</b> (MACs).|$|R
5000|$|The {{responder}} is authenticated in the initialization stage, by the validating {{the signature}} against the public key presented by its certificate (authentication freshness is ensured by the requester's nonce). The requester is subsequently authenticated in the continuation stage {{by the use}} of HMAC <b>message</b> <b>authentication</b> <b>codes</b> (<b>authentication</b> freshness is ensured by the requester's ability to decrypt the responders's nonce).|$|R
50|$|Connascence of {{algorithm}} is when multiple components must {{agree on a}} particular algorithm. <b>Message</b> <b>authentication</b> <b>codes</b> are {{an example of this}} form of connascence. Both sides of the exchange must implement exactly the same hashing algorithm or the authentication will fail.|$|R
5000|$|... #Subtitle level 2: An Example of <b>Message</b> <b>Authentication</b> <b>Code</b> Algorithm ...|$|E
5000|$|FIPS PUB 198 The Keyed-Hash <b>Message</b> <b>Authentication</b> <b>Code</b> (HMAC) 2002 ...|$|E
5000|$|See {{internet}} draft VMAC: <b>Message</b> <b>Authentication</b> <b>Code</b> using Universal Hashing ...|$|E
50|$|The Data Authentication Algorithm (DAA) is {{a former}} U.S. {{government}} standard for producing cryptographic <b>message</b> <b>authentication</b> <b>codes.</b> DAA is defined in FIPS PUB 113, which was withdrawn on September 1, 2008. The algorithm is not considered secure by today's standards.|$|R
25|$|<b>Message</b> <b>authentication</b> <b>codes</b> (MACs) {{are much}} like {{cryptographic}} hash functions, except that a secret key {{can be used}} to authenticate the hash value upon receipt; this additional complication blocks an attack scheme against bare digest algorithms, and so has been thought worth the effort.|$|R
50|$|Theoretical {{model was}} {{published}} in early 2015 by Maciej A. Czyzewski. It was designed specifically to combine the benefits of hash function and pseudo-random function. However, {{it can be used}} to implement many cryptographic primitives, including cryptographic hashes, <b>message</b> <b>authentication</b> <b>codes</b> and randomness extractors.|$|R
50|$|A <b>Message</b> <b>authentication</b> <b>code</b> (MAC) is a {{cryptography}} {{method that}} uses a secret key to encrypt a message. This method outputs a MAC value that can be decrypted by the receiver, using the same secret key used by the sender. The <b>Message</b> <b>Authentication</b> <b>Code</b> protects both a message's data integrity {{as well as its}} authenticity.|$|E
50|$|It is {{free for}} all uses (no patents).In cryptography, CMAC (Cipher-based <b>Message</b> <b>Authentication</b> <b>Code)</b> is a block cipher-based <b>message</b> <b>authentication</b> <b>code</b> algorithm. It {{may be used to}} provide {{assurance}} of the authenticity and, hence, the integrity of binary data. This mode of operation fixes security deficiencies of CBC-MAC (CBC-MAC is secure only for fixed-length messages).|$|E
5000|$|Addition of the ChaCha20 {{stream cipher}} with the Poly1305 <b>message</b> <b>authentication</b> <b>code</b> ...|$|E
40|$|Traditionally, {{cryptography}} {{has been}} {{understood as the}} art of providing secure communication over insecure channels. The classical {{solution to this problem}} is to use encryption and <b>message</b> <b>authentication</b> <b>codes,</b> such that the data can be recovered and checked for errors, only if the correct secret key is known...|$|R
40|$|We have {{developed}} a practical state-machine replication algorithm that tolerates Byzantine faults: it works correctly in asynchronous systems like the Internet and it incorporates several optimizations that improve the response time of previous algorithms by more than an order of magnitude. This paper describes {{the most important of}} these optimizations. It explains how to modify the base algorithm to eliminate the major performance bottleneck in previous systems — public-key cryptography. The optimization replaces public-key signatures by vectors of <b>message</b> <b>authentication</b> <b>codes</b> during normal operation, and it overcomes a fundamental limitation on the power of <b>message</b> <b>authentication</b> <b>codes</b> relative to digital signatures — the inability to prove that a message is authentic to a third party. As a result, authentication is more than two orders of magnitude faster while providing the same level of security. ...|$|R
30|$|Upon {{receiving}} the EAP-request message, the MS first decrypts *AT_Counter_A(i) and *AT_Nonce_A(i) with K_auth(i - 1) key to acquire Nonce_A(i) and Counter_A(i) attributes. Then the MS performs the iterative AVs generation operations {{as well as}} in the AP to re-derive fresh key sets (MK(i), K_encr(i), K_auth(i)) and <b>message</b> <b>authentication</b> <b>codes</b> (AT_XMAC(i) and AT_RES(i)).|$|R
