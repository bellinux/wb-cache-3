42|17|Public
50|$|A {{general-purpose}} <b>macro</b> <b>processor</b> {{or general}} purpose preprocessor is a <b>macro</b> <b>processor</b> {{that is not}} tied to or integrated with a particular language or piece of software.|$|E
5000|$|The MTS command <b>macro</b> <b>processor</b> {{allows users}} to define their own MTS commands. It {{provides}} a [...] "scripting" [...] language with conditional commands and is available for use with any lines read from *SOURCE* by user programs or command language sub-systems as well with MTS commands. <b>Macro</b> <b>processor</b> lines are usually prefixed with the greater than character (>). The command <b>macro</b> <b>processor</b> is controlled using the $SET command {{as well as by}} I/O modifiers on FDnames.|$|E
50|$|General-purpose <b>macro</b> <b>processor</b> (GPP) {{to process}} {{application}} messages.|$|E
50|$|Unlike most earlier <b>macro</b> <b>processors,</b> m4 {{does not}} target any {{particular}} computer or human language; historically, however, its development originated {{for supporting the}} Ratfor dialect of Fortran. Unlike some other <b>macro</b> <b>processors,</b> m4 is Turing-complete {{as well as a}} practical programming language.|$|R
5000|$|... #Subtitle level 2: Examples {{of general}} purpose <b>macro</b> <b>processors</b> ...|$|R
50|$|<b>Macro</b> <b>processors</b> {{became popular}} when programmers {{commonly}} used assembly language. In {{those early days}} of programming, programmers noted that much of their programs consisted of repeated text, and they invented simple means for reusing this text. Programmers soon discovered the advantages not only of reusing entire blocks of text, but also of substituting different values for similar parameters. This defined the usage range of <b>macro</b> <b>processors.</b>|$|R
50|$|ML/1 (Macro Language/One) is a {{powerful}} general purpose <b>macro</b> <b>processor.</b>|$|E
5000|$|... m3, a <b>macro</b> <b>processor</b> for the AP-3 minicomputer, the {{predecessor}} to m4 ...|$|E
5000|$|... m4 {{has many}} uses in code generation, but (as with any <b>macro</b> <b>processor)</b> {{problems}} {{can be hard to}} debug.|$|E
50|$|<b>Macro</b> <b>processors</b> {{have been}} used for {{language}} expansion (defining new language constructs that can be expressed in terms of existing language components), for systematic text replacements that require decision making, and for text reformatting (e.g. conditional extraction of material from an HTML file).|$|R
50|$|George H. Mealy (December 31, 1927 - June 21, 2010 in Scituate, Massachusetts) was an American {{mathematician}} {{and computer}} scientist {{who invented the}} namesake Mealy machine, a type of finite state transducer. He was also a pioneer of modular programming, one of the lead designers of the IPL-V programming language, and an early advocate of <b>macro</b> <b>processors</b> in assembly language programming.|$|R
5000|$|... the {{intention}} {{was that the}} caller would provide {{the name of a}} variable, and the [...] "global" [...] variable or constant b would be used to multiply [...] "a". If foo is called with the parameter , the macro expansion of [...] occurs. To avoid any possible ambiguity, users of <b>macro</b> <b>processors</b> can parenthesize formal parameters inside macro definitions, or callers can parenthesize the input parameters.|$|R
5000|$|... m4 is a {{general-purpose}} <b>macro</b> <b>processor</b> {{included in}} all UNIX-like operating systems, {{and is a}} component of the POSIX standard.|$|E
5000|$|The General Purpose Macroprocessor is a contextual pattern {{matching}} <b>macro</b> <b>processor,</b> {{which could be}} described as a combination of regular expressions, EBNF and AWK ...|$|E
50|$|Other lexical preprocessors {{include the}} {{general-purpose}} m4, {{most commonly used}} in cross-platform build systems such as autoconf, and GEMA, an open source <b>macro</b> <b>processor</b> which operates on patterns of context.|$|E
2500|$|This is because, as was {{realized}} in the 1960s, the concept of [...] "macro processing" [...] is independent {{of the concept of}} [...] "assembly", the former being in modern terms more word processing, text processing, than generating object code. The concept of macro processing appeared, and appears, in the C programming language, which supports [...] "preprocessor instructions" [...] to set variables, and make conditional tests on their values. Note that unlike certain previous <b>macro</b> <b>processors</b> inside assemblers, the C preprocessor is not Turing-complete because it lacks the ability to either loop or [...] "go to", the latter allowing programs to loop.|$|R
40|$|As multiprocessors become commercially available, a {{great deal}} of concern is being focused on the {{problems}} involved in writing and debugging software for such machines. Earlier work described the use of monitors implemented by <b>macro</b> <b>processors</b> to attain portable code. This work formulates a general-purpose monitor which simplifies the programming of a wide class of numeric algorithms. We believe that the approach of describing a set of schedulable units of computation advocated by Brown offers a real simplification for the applications programmer. In this paper, we propose a straight-forward programming paradigm for describing schedulable units of computation that allows the description of many algorithms with very little effort...|$|R
40|$|The {{purpose of}} the work herein {{reported}} has been an investigation of macro processing (including language extension and text editing schemes). We present a text manipulation system wllose constructs {{have been designed to}} facilitate the use of the system to construct <b>macro</b> <b>processors</b> and to implement such schemes. The concepts of recognition of macro calls and generation of replacement text have been generalized so that any kind of recognitionsubstitution scheme can readily be implemented in the language (called GAME). Chapter I contains, by way of introduction, a discussion of what macros are and how the evolution of macro systems leads to a general language, like G_E. Chapter 2 presents a definition of the macro recognition and expansion process so that some kind of distinction ca...|$|R
50|$|The {{language}} {{was designed by}} Brian Kernighan and Dennis Ritchie for the original versions of UNIX. It {{is an extension of}} an earlier <b>macro</b> <b>processor</b> m3, written by Ritchie for the AP-3 minicomputer.|$|E
5000|$|... many {{applications}} {{continue to use}} m4 {{as part of the}} GNU Project's autoconf. It also appears in the configuration process of sendmail (a widespread mail transfer agent) and for generating footprints in the gEDA toolsuite. The SELinux Reference Policy relies heavily on the m4 <b>macro</b> <b>processor.</b>|$|E
50|$|A <b>macro</b> <b>processor</b> is {{a program}} that copies a stream of text {{from one place to}} another, making a {{systematic}} set of replacements as it does so. Macro processors are often embedded in other programs, such as assemblers and compilers. Sometimes they are standalone programs {{that can be used to}} process any kind of text.|$|E
30|$|Improvements {{were not}} {{dependent}} on the window search size; results only depended {{on the size of}} the <b>macro</b> block <b>processor</b> and algorithm; lower improvement correlated with a higher size. For example, for the FST algorithm, performances moved from 10 % to 55 %, while for the other algorithms that were different than the pure exhaustive full search (TSST and 2 DLOG), the performance moved from 30 % to 0 %.|$|R
50|$|End-user {{development}} tailors {{systems to}} meet the user's specific needs. User-written software include spreadsheet templates, word <b>processor</b> <b>macros,</b> scientific simulations, graphics and animation scripts; even email filters {{are a kind of}} user software. Users create this software themselves and often overlook how important it is.|$|R
40|$|Abstract—This paper {{proposes a}} {{technique}} that mitigates multi-bit-upset (MBU) in multi-bit-latch (MBL) without performance degradation by applying well-slits. The area overhead in an MBL <b>macro</b> for <b>processor</b> design, which includes a clock buffer and a checker, is only 5. 4 % in a 28 nm technology. Sixty-hour acceler-ated neutron irradiation test observed no MBUs in the MBL with well-slits. The proposedmitigation technique achieved excellent ro-bustness against MBUwithout any increase in SBU rate. TheMBL with the proposed mitigation technique helps improve reliability of electronic devices. Index Terms—Latch, multiple cell upset, neutron, single event, soft-error. I...|$|R
5000|$|A single compile-time builtin, , was added. Also in 1966 Robert Rosin {{published}} {{a pair of}} articles discussing development of the preprocessor. This development was based in a [...] "SHARE XXVI Memo" [...] from earlier the same year and a paper by Mark Elson. Rosin credits MAD as the only previous example of a <b>macro</b> <b>processor</b> in a high-level language.|$|E
50|$|The <b>macro</b> <b>processor</b> adds commands, constants, {{functions}} and expressions to Wylbur. Even when the command syntax {{does not include}} parameters defined to be expressions, the user can use the forms %(expression) and %%(expression) to force evaluation. If the expression is a function with no argument or a variable then the parentheses may be omitted, e.g., %.TIME instead of %(.TIME). A doubled % requests that the valued be quoted.|$|E
50|$|Early {{contributors}} included Rick Meyers (project {{lead and}} MPW Shell command interpreter), Jeff Parrish (MPW Shell editor), Dan Smith (MPW Shell commands), Ira Ruben (assembler {{and many of}} the tools including Backup, PasMat, and more), Fred Forsman (Make, Print, SADE, and assembler <b>macro</b> <b>processor),</b> Al Hoffman (Pascal compiler) Roger Lawrence (Pascal and C compilers, including the error messages), Ken Friedenbach (linker), Johan Strandberg (Rez, DeRez, RezDet), Steve Hartwell (C libraries), and Dan Allen (MacsBug, editor). The Apple Numerics Group also contributed math libraries.|$|E
40|$|Part 5 : Hardware ImplementationInternational audienceThe Elliptic Curve Digital Signature Algorithm (ECDSA) and the Advanced Encryption Standard (AES) {{are two of}} {{the most}} popular {{cryptographic}} algorithms used worldwide. In this paper, we present a hardware implementation of a low-resource cryptographic processor that provides both digital signature generation using ECDSA and encryption/decryption services using AES. The implementation of ECDSA is based on the recommended F_p 192 NIST elliptic curve and AES uses 128 -bit keys. In order to meet the low-area requirements, we based our design on a sophisticated hardware architecture where a 16 -bit datapath gets heavily reused by all algorithms and the memory is implemented as a dedicated RAM <b>macro.</b> The proposed <b>processor</b> has a total chip area of 21 502 GEs where AES needs only 2 387 GEs and SHA- 1 requires 889  GEs...|$|R
40|$|Pixel Data Access is an interprocess {{communication}} technique that enables users of {{graphical user interfaces}} to automate certain tasks. By accessing {{the contents of the}} display buffer, users can search for pixel representations of interface elements, and then initiate actions such as mouse clicks and keyboard entries. While this technique has limitations it offers users of current systems some unusually powerful features that are especially appealing in the area of end-user programming. KEYWORDS: End-User Programming, Programming by Example, Pixel Data Access, Interprocess Communication, Graphical Macros. INTRODUCTION Users of many systems appreciate the power they have to create novel automations that extend the power of these systems. <b>Macros</b> in word <b>processors</b> such as Emacs, WordPerfect, and Word enable users to record frequent sequences of actions for repeated replay and save them for future use. Macros can automate tasks such as making back-up files, merging complex lists, or con [...] ...|$|R
50|$|Source code {{generation}} {{is the process}} of generating source code based on an ontological model such as a template and is accomplished with a programming tool such as a template processor or an integrated development environment (IDE). These tools allow the generation of source code through any of various means. A <b>macro</b> <b>processor,</b> such as the C preprocessor, which replaces patterns in source code according to relatively simple rules, is a simple form of source code generator. Source-to-source code generation tools also exist.|$|E
50|$|The C {{preprocessor}} is not Turing-complete, but {{it comes}} very close: recursive computations can be specified, but with a fixed upper bound {{on the amount of}} recursion performed. However, the C preprocessor is not designed to be, nor does it perform well as, a general-purpose programming language. Since the C preprocessor does not have features of some other preprocessors, such as recursive macros, selective expansion according to quoting, and string evaluation in conditionals, it is very limited in comparison to a more general <b>macro</b> <b>processor</b> such as m4.|$|E
50|$|The {{language}} incorporated {{ideas from}} PL/I, ALGOL and XPL, {{and had an}} integrated <b>macro</b> <b>processor.</b> Unlike other contemporary languages such as Pascal, C or BASIC, PL/M had no standard input or output routines. It included features targeted at the low-level hardware specific to the target microprocessors, and as such, it could support direct access to any location in memory, I/O ports and the processor interrupt flags in a very efficient manner. PL/M was the first higher level programming language for microprocessor-based computers and was the original implementation language for the CP/M operating system. Many Intel and Zilog Z80 based embedded systems were programmed in PL/M during the 1970s and 1980s. For instance, the firmware of the Service Processor component of CISC AS/400 was written in PL/M.|$|E
40|$|The FHDL (Florida Hardware Design Language) <b>Macro</b> <b>processor</b> {{provides}} {{a mechanism for}} extending the language features provided by the other components of the FHDL system (the ROM language, the PLA language, and the logic specification language). The primary use of the <b>Macro</b> <b>processor</b> is to provide flexible cells, such as ripple-carry adders, that can expand to match {{the size of the}} interface. The use of the <b>Macro</b> <b>processor</b> for this purpose is transparent with more standard hierarchical specification mechanisms. In addition, the <b>Macro</b> <b>processor</b> was designed to be an implementation vehicle for more sophisticated hardware specification and synthesis systems. The <b>Macro</b> <b>processor</b> provides most of the features found in other macro languages, and provides several new features that are found in few, if any, existing macro languages. The use of the <b>Macro</b> <b>processor</b> for high-level synthesis is the subject of much on-going research...|$|E
40|$|The goal of {{this work}} is to design and {{implement}} general-purpose <b>macro</b> <b>processor.</b> This <b>macro</b> <b>processor</b> supports common features such as conditional evaluation, file inclusion, user-defined macros and manipulations with macros in runtime. Various modifications of {{the configuration of the}} <b>macro</b> <b>processor</b> are possible in run-time as well. Also it is possible to change the way of invoking built-in commands Several examples are included to demonstrate implemented features. The work also contains brief description, history and comparison with existing macro processors and theoretical principles of macro processing...|$|E
40|$|An {{increasing}} {{amount of}} software is being implemented in a portable form. A popular way of accomplishing {{this is to}} encode the software in a specially designed machine-independent language and then to map this language, often using a <b>macro</b> <b>processor,</b> into the assembly language of each desired object machine. The design of the machine-independent language is the key factor in this operation. This paper discusses {{the relative merits of}} pitching this language at a high level or a low level, and presents some comparative results. Key Words and Phrases: portable software, level of language, machine independent, <b>macro</b> <b>processor,</b> efficienc...|$|E
40|$|The SAS ® macro facility, which {{includes}} macro variables and macro programs, {{is the most}} useful tool to develop your own applications. Beginning SAS programmers often don’t realize {{that the most important}} function in learning a macro program is understanding the macro language processing rather than just learning the syntax. The lack of understanding includes how SAS statements are transferred from the input stack to the <b>macro</b> <b>processor</b> and the DATA step compiler, what role the <b>macro</b> <b>processor</b> plays during this process, and when best to utilize the interface to interact with the macro facility during the DATA step execution. In this talk, these issues are addressed via creating simple macro applications step-by-step...|$|E
