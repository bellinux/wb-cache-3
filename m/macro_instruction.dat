16|36|Public
50|$|STXIT was an IBM System/360 series {{mainframe}} computer <b>macro</b> <b>instruction</b> under the DOS/VSE operating system, {{and was also}} available for the UNIVAC Series 90 mainframes running its TOS/DOS operating system and later on its VS/9 operating system.|$|E
5000|$|A <b>macro</b> <b>instruction</b> named IOSADMF, {{which has}} been {{described}} as an API that avoids [...] "direct, low-level use of ADMF," [...] can be used to read or write data to or from a hiperspace. Hiperspaces are created using DSPSERV CREATE.|$|E
5000|$|A <b>macro</b> <b>instruction</b> {{is a line}} of {{computer}} program coding that results {{in one or more}} lines of program coding in the target programming language, sets variables for use by other statements, etc. In the mid-1950s, when assembly language programming was commonly used to write programs for digital computers, the use of macro instructions was initiated for two main purposes: {{to reduce the amount of}} program coding that had to be written by generating several assembly language statements from one <b>macro</b> <b>instruction</b> and to enforce program writing standards, e.g. specifying input/output commands in standard ways. Macro instructions were effectively a middle step between assembly language programming and the high-level programming languages that followed, such as FORTRAN and COBOL. Two of the earliest programming installations to develop [...] "macro languages" [...] for the IBM 705 computer were at Dow Chemical Corp. in Delaware and the Air Material Command, Ballistics Missile Logistics Office in California. A <b>macro</b> <b>instruction</b> written in the format of the target assembly language would be processed by a macro compiler, which was a pre-processor to the assembler, to generate one or more assembly language instructions to be processed next by the assembler program that would translate the assembly language instructions into machine language instructions.|$|E
25|$|Greenwald, I.D., Handling <b>Macro</b> <b>Instructions.</b> CACM 2, No. 11 (1959), 21-22.|$|R
50|$|For the 7070 {{these are}} done using 7070 Autocoder {{declarative}} statements and <b>Macro</b> <b>instructions.</b>|$|R
25|$|Mcllroy, M.D., Using SAP <b>Macro</b> <b>Instructions</b> to Manipulate Symbolic Expressions. Bell Telephone Laboratories Computation Center (1960).|$|R
50|$|The Clipper {{architecture}} used {{a simplified}} instruction set compared to earlier CISC architectures, {{but it did}} incorporate some more complicated instructions than were present in other contemporary RISC processors. These instructions were implemented in a so-called <b>Macro</b> <b>Instruction</b> ROM within the Clipper CPU. This scheme allowed the Clipper to have somewhat higher code density than other RISC CPUs.|$|E
5000|$|In IBM {{mainframe}} operating systems, such as OS/360, MVS, z/OS, a Data Control Block (DCB) is {{a description}} of a dataset in a program. A DCB is coded in Assembler programs using the DCB <b>macro</b> <b>instruction</b> (which expands into a large number of [...] "define constant" [...] instructions). High level language programmers use library routines containing DCBs.|$|E
50|$|Most {{assembly}} languages {{will have}} a <b>macro</b> <b>instruction</b> or an interrupt address available for the particular system to intercept events such as illegal op codes, program check, data errors, overflow, divide by zero, and other such. IBM and Univac mainframes had the STXIT macro. Digital Equipment Corporation RT11 systems had trap vectors for program errors, i/o interrupts, and such. DOS has certain interrupt addresses. Microsoft Windows has specific module calls to trap program errors.|$|E
5000|$|Computers in the 1950s and 1960s {{often did}} not have {{operating}} systems in the modern sense. Application programs called IOCS routines in a resident monitor or included <b>macro</b> <b>instructions</b> that expanded to IOCS routines ...|$|R
5000|$|The easy-to-learn RISC {{instruction}} {{set of the}} PIC assembly language code can make the overall flow difficult to comprehend. Judicious use of simple macros can increase the readability of PIC assembly language. For example, the original Parallax PIC assembler ("SPASM") has macros, which hide W and make the PIC look like a two-address machine. It has <b>macro</b> <b>instructions</b> like [...] (move the data from address a to address b) and [...] (add data from address a to data in address b). It also hides the skip instructions by providing three-operand branch <b>macro</b> <b>instructions,</b> such as [...] (compare a with b and jump to dest {{if they are not}} equal).|$|R
5000|$|The ports {{associated}} with the ALU may act as an accumulator, allowing creation of <b>macro</b> <b>instructions</b> that abstract away the underlying TTA:lda r1 [...] "load ALU": move value to ALU operand 1add r2 add: move value to add triggersta r3 [...] "store ALU": move value from ALU result ...|$|R
5000|$|The {{programmer}} specifies [...] in his Data Control Block (DCB) {{to indicate}} use of BSAM.As a basic access method BSAM reads and writes member data in blocks and the I/O operation proceeds asynchronously {{and must be}} tested for completion using the [...] macro. BSAM uses the standard system macros , , , ,and [...] The [...] <b>macro</b> <b>instruction</b> returns position of the last block read or written, and the [...] macro will reposition to the location identified by a previous [...]|$|E
5000|$|Although use of STARTIO by {{customers}} is {{not supported}} by IBM, nevertheless its <b>macro</b> <b>instruction</b> and its associated [...] "branch entry" [...] have remained remarkably stable throughout the forty-year-long (as of 2014) transition from MVS/370 to z/OS, as STARTIO is the sole method of performing lowest-level physical I/O operations on channel-attached devices on MVS/370 and subsequent instances of the OS. In particular, VSAM and VTAM use STARTIO, as, of course, do EXCP, XDAP and EXCPVR, and certain instances of IMS/VS and JES, most particularly where Channel-to-Channel operations are involved.|$|E
5000|$|In MVS/370 and {{successor}} {{versions of}} IBM mainframe operating systems, Start Input/Output (STARTIO) is a <b>macro</b> <b>instruction</b> and a [...] "branch entry" [...] for low-level device access, where the programmer {{is responsible for}} providing a list of device-specific CCWs, that is, a channel program, to be executed by I/O channels, control units and devices {{and a number of}} [...] "exits", several of which may be immediate returns to the Input/Output Supervisor (IOS). Invokers of STARTIO must be in supervisor mode and key 0. STARTIO interfaces directly with the IOS component of MVS.|$|E
5000|$|The email was {{allegedly}} from the US Federal Reserve, saying something about restrictions in [...] "U.S. Federal Wire and ACH online payments." [...] Not {{only was the}} notice itself fraudulent, the attached Excel spreadsheet (.xls) contained <b>macro</b> <b>instructions</b> (a downloader) to download a Windows executable virus, most likely Dyreza or Dridex malware.|$|R
2500|$|In {{assembly}} language, {{the term}} [...] "macro" [...] represents {{a more comprehensive}} concept than it does in some other contexts, {{such as in the}} C programming language, where its #define directive typically is used to create short single line <b>macros.</b> Assembler <b>macro</b> <b>instructions,</b> like <b>macros</b> in PL/I and some other languages, can be lengthy [...] "programs" [...] by themselves, executed by interpretation by the assembler during assembly.|$|R
50|$|Stage 1 is the {{compilation}} of {{a sequence of}} assembler <b>macro</b> <b>instructions</b> describing the configuration to be installed or updated. The assembler does not actually compile any object code, but instead compiles a series of PUNCH pseudo-ops in order to generate a job stream for Stage 2. As IBM changed the nomenclature for OS/360 options, it also changed the Sysgen macro definitions to use newer names for the options.|$|R
5000|$|Dynamic linking from Assembler {{language}} {{programs in}} IBM OS/360 and its successors is done typically using a LINK <b>macro</b> <b>instruction</b> containing a Supervisor Call instruction that activates {{the operating system}} routines that makes the library module to be linked available to the program. Library modules may reside in a [...] "STEPLIB" [...] or [...] "JOBLIB" [...] specified in control cards and only available to a specific execution of the program, in a library included in the LINKLIST in the PARMLIB (specified at system startup time), or in the [...] "link pack area" [...] where specific reentrant modules are loaded at system startup time.|$|E
5000|$|The {{programmer}} specifies [...] in his Data Control Block (DCB) {{to indicate}} use of BPAM.As a basic access method BPAM reads and writes member data in blocks and the I/O operation proceeds asynchronously {{and must be}} tested for completion using the [...] macro. BPAM uses the standard system macros , , , ,and [...] The [...] <b>macro</b> <b>instruction</b> returns position of the last block read or written, and the [...] macro will reposition to the location identified by a previous [...] The [...] macro {{can be used to}} build a list of the addresses of members specified by the programmer for later use, if desired. [...] positions to a single member, specified by name, which requires a directory lookup on disk, or by address previously retrieved by [...] The [...] macro is used to update the directory when a member is added, deleted, changed (including renamed), or replaced.|$|E
50|$|While macro {{instructions}} can {{be defined}} by a programmer for any set of native assembler program instructions, typically macros are associated with macro libraries delivered with the operating system allowing access to operating system functions such as peripheral access by access methods (including macros such as OPEN, CLOSE, READ and WRITE) and other operating system functions such as ATTACH, WAIT and POST for subtask creation and synchronization. Typically such macros expand into executable code, e.g., for the EXIT macroinstruction, a list of define constant instructions, e.g., for the DCB macro, {{or a combination of}} code and constants, with the details of the expansion depending on the parameters of the <b>macro</b> <b>instruction</b> (such as a reference to a file and a data area for a READ instruction); he executable code often terminated in either a branch and link register instruction to call a routine, or a supervisor call instruction to call an operating system function directly.|$|E
50|$|This {{buffering}} {{means that}} the fetch and decode stages can be more detached from the execution units than is feasible in a more traditional microcoded (or hard-wired) design. As this allows a degree of freedom regarding execution order, it makes some extraction of instruction level parallelism out of a normal single-threaded program possible (provided that dependencies are checked etc.). It opens up for more analysis and therefore also for reordering of code sequences in order to dynamically optimize mapping and scheduling of μops onto machine resources (such as ALUs, load/store units etc.). As this happens on the μop-level, sub-operations of different machine (<b>macro)</b> <b>instructions</b> may often intermix in a particular μop-sequence, forming partially reordered machine instructions as {{a direct consequence of}} the out-of-order dispatching of microinstructions from several <b>macro</b> <b>instructions.</b> However, this {{is not the same as}} the micro-op fusion, which aims at the fact that a more complex microinstruction may replace a few simpler microinstructions in certain cases, typically in order to minimize state changes and usage of the queue and reorder buffer space, therefore reducing power consumption. Micro-op fusion is used in some modern CPU designs.|$|R
5000|$|As a {{basic access}} method BDAM reads and writes member data in blocks and the I/O {{operation}} proceeds asynchronously {{and must be}} tested for completion using the [...] macro. BDAM uses the standard system macros , , , ,and [...] The [...] or [...] <b>macro</b> <b>instructions</b> must provide the block address of the desired record. The [...] macro has {{to be used to}} wait for completion of a specific operation before the data can be accessed or the data buffer reused. It is possible to start multiple input/output operations to run concurrently.|$|R
5000|$|The {{assembler}} for BPS is {{the true}} [...] "basic assembler." [...] It {{was intended to be}} loaded from cards and would run on an 8 KB System/360 (except Model 20). It had no support for <b>macro</b> <b>instructions</b> or extended mnemonics (such as BH in place of BC 2 to branch if condition code 2 indicates a high compare). It could assemble only a single control section and did not allow dummy sections (structure definitions). Parenthesized expressions were not allowed and expressions were limited to three terms with the only operators being '+', '-', and '*'.|$|R
50|$|While the {{contents}} of the UCB has changed as MVS evolved, the concept has not. It is a representation to the channel command processor of an external device. Inside every UCB is a representation of a subchannel information block, that is used in the SSCH assembler instruction (put in the IRB, for input, or put in the ORB, for output), to start a chain of channel commands, known as CCWs. CCWs are queued onto the UCB with the STARTIO macro interface, although that reference does NOT discuss the STARTIO macro as that <b>macro</b> <b>instruction</b> is NOT an IBM-supported interface, not withstanding the fact that that interface has remained the same for at least the past three decades. The STARTIO interface will either start the operation immediately, should the Channel Queue be empty, or it will queue the request on the Channel Queue for deferred execution. Such deferred execution will be initiated immediately when the request is {{at the head of the}} queue and the device becomes available, even if another program is in control at that instant. Such is the basic design of Input/Output Supervisor (IOS).|$|E
5000|$|The {{original}} {{source is}} the paper <b>Macro</b> <b>Instruction</b> Extensions of Compiler Languages, {{according to the}} early and influential paper TRAC, A Text-Handling Language: One of the main design goals was that the input script of TRAC (what is typed in by the user) should be identical to the text which guides the internal action of the TRAC processor. In other words, TRAC procedures should be stored in memory as a string of characters exactly as the user typed them at the keyboard. If the TRAC procedures themselves evolve new procedures, these new procedures should also be stated in the same script. The TRAC processor in its action interprets this script as its program. In other words, the TRAC translator program (the processor) effectively converts the computer into a new computer with a new program language -- the TRAC language. At any time, {{it should be possible}} to display program or procedural information in the same form as the TRAC processor will act upon it during its execution. It is desirable that the internal character code representation be identical to, or very similar to, the external code representation. In the present TRAC implementation, the internal character representation is based upon ASCII. Because TRAC procedures and text have the same representation inside and outside the processor, the term homoiconic is applicable, from homo meaning the same, and icon meaning representation....Following suggestion of McCullough, W. S., based upon terminology due to Peirce, C. S. s McIlroy. M. D., [...] "Macro Instruction Extensions of Compiler Languages," [...] Comm. ACM, p. 214-220; April, 1960.|$|E
40|$|In LISP 1. 5 special {{forms are}} used for three logically {{separate}} purposes: a) to reach the alist, b) to allow functions to have an indefinite number of arguments, and c) to keep arguments from being evaluated. New LISP interpreters can easily satisfy need (a) by making the alist a SPECIAL-type or APVAL-type entity. Uses (b) and (c) can be replaced by incorporating a <b>MACRO</b> <b>instruction</b> expander in define. I am proposing such an expander...|$|E
50|$|In older {{operating}} {{systems such as}} those used on IBM mainframes, full operating system functionality was only available to assembler language programs, not to high level language programs (unless assembly language subroutines were used, of course), as the standard <b>macro</b> <b>instructions</b> did not always have counterparts in routines available to high-level languages. In modern {{operating systems}} such as Unix and its derivatives, operating system access is provided through subroutines, usually provided by dynamic libraries. High-level languages such as C offer comprehensive access to operating system functions, obviating the need for assembler language programs for such functionality.|$|R
40|$|Typed {{assembly}} languages {{provide a}} way to generate machinecheckable safety proofs for machine-language programs. But the soundness proofs of most existing typed assembly languages are hand-written and cannot be machine-checked, which is worrisome for such large calculi. We have designed and implemented a low-level typed assembly language (LTAL) with a semantic model and established its soundness from the model. Compared to existing typed assembly languages, LTAL is more scalable and more secure; it has no <b>macro</b> <b>instructions</b> that hinder low-level optimizations such as instruction scheduling; its type constructors are expressive enough to capture dataflow information, support the compiler's choice of data representations and permit typed position-independent code; and its type-checking algorithm is completely syntax-directed...|$|R
50|$|By {{the late}} 1950s the macro {{language}} {{was followed by}} the Macro Assemblers. This was a combination of both where one program served both functions, that of a macro pre-processor and an assembler in the same package. This allowed assembly language programmers to implement their own macro-language and allowed limited portability of code between two machines running the same CPU but different operating systems, for example, early versions of MSDOS and CPM-86. The macro library would need to be written for each target machine but not the overall assembly language program. Note that more powerful macro assemblers allowed use of conditional assembly constructs in <b>macro</b> <b>instructions</b> that could generate different code on different machines or different operating systems, reducing the need for multiple libraries.|$|R
40|$|This {{publication}} {{shows the}} formats {{of the major}} control blocks and tables used {{by more than one}} component of the System/ 360 Operating System control program. Descriptions of each field within the control blocks or tables follow each format illustration. File No. 5360 - 36 Order No. GC 28 - 6628 - 9 The system control blocks described in this publication will be changed by IBM {{from time to time to}} extend the capabilities of the operating system. Programs should refer to these control blocks only through +ho system <b>macro</b> <b>instruction</b> facili ties provided in the operating system. (For example, a field of the Data Control Block should only be referred to by use of the DCBD <b>macro</b> <b>instruction.)</b> Programs that refer to the control blocks by other means do so at the risk of not executing correctly in the future. los L Tenth Edition (April, 1973) This is a major reV 1 S 1 on of, and obsoletes, GC 28 - 6628 - 8. The changes in content made in this edition for this release are enumerated in a summary of amendments which follows the table of contents. Changes or additions to the text and illustrations are indicated by a vertical line to the left of the change. I This edition applies to release 21. 7 of IBM System/ 360 operating System and to all subsequent releases until otherwise indicated in new editions or Technical Newsletters. changes are continually made to the information herein; before using this publication in connection with the operation of IBM systems, consult the latest IBM System/ 360 and System/ 370 Bibliography, GA 22 - 6822, for the editions that are applicable and current. Request ~ for copies of IBM publications should be made to your IBM representative or to the IBM branch office serving your locality. A form for readers ' COn~ents is provided at the back of this publication. If the form has been removed, comments may be addressed to IBM Corporation, publications Development...|$|E
40|$|Garbage {{collectors}} {{are notoriously}} hard to verify, {{due to their}} lowlevel interaction with the underlying system and the general difficulty in reasoning about reachability in graphs. Several papers have presented verified collectors, but either the proofs were handwritten or the collectors were too simplistic to use on practical applications. In this work, we present two mechanically verified garbage collectors, both practical enough to use for real-world C# benchmarks. The collectors and their associated allocators consist of x 86 assembly language <b>instructions</b> and <b>macro</b> <b>instructions,</b> annotated with preconditions, postconditions, invariants, and assertions. We used the Boogie verification generator and the Z 3 automated theorem prover to verify this assembly language code mechanically. We provide measurements comparing {{the performance of the}} verified collector with that of the standard Bartok collectors on off-the-shelf C # benchmarks, demonstrating their competitiveness. D. 2. 4 [Software Engineer...|$|R
50|$|In an OS {{environment}} on a 360/67 with spooled {{input and output}} files, the compiler will recompile itself in about 25 seconds. The compiler is approximately 2700 card images. Thus, when the OS scheduler time is subtracted from the execution time given above, it is seen that the compiler runs at a speed in excess of 100 cards per second (for dense code).In a DOS {{environment on}} a 360/30, the compiler is limited only by {{the speed of the}} card reader. The compiler has successfully recompiled itself on a 64K 360/30 at a rate of 1200 cards per minute (the speed of the card reader). This is impressive when compared to the time required for the DOS Assembler to assemble the interface module which consists of under 250 cards. When the <b>macro</b> <b>instructions</b> are expanded, the DOS interface has 972 card images and the Assembler takes 15 minutes for the assembly.|$|R
40|$|AbstractThis paper {{introduces}} two new complex instructions {{over the}} application with specific instruction set processor. For the MCS- 51 family, utilizing a reserved bit, and the unused machine code “A 5 h” we can modify the conventional instruction set architecture (ISA) and develop two <b>macro</b> <b>instructions</b> for data manipulation. One {{of them is}} to move a block of data from specific memory locations to any other memory locations, while the other developed instruction is to obtain maximum byte-value within a group of 8 -bytes and load it into the Accumulator. There are two basic steps to achieve such developments, step- 1; at which we modify {{the architecture of the}} conventional microcontroller 8051 using hardware description language HDL. In the second step we modify the instruction set architecture (ISA) of μC 8051. Such development improves the performance of the μC including fast execution time, decrease machine code size, so decrease storage requirements and provide low power consumption...|$|R
40|$|Describes the {{internal}} {{logic of the}} system service routine used in TSS/ 360. The system service routines are non-resident programs that can be invoked either directly by the user, {{through the use of}} system com-mands and <b>macro</b> <b>instructions,</b> or indirectly, in res-ponse to requests from other system components. The system service routines are divided into eight categories: catalog services; external storage allo-cation; device management; virtual memory allocation; small virtual memory allocation; symbolic library services; control section store; and serviceability aids. Appendixes describe VAM and SAM OSCB formats and catalog SBLOCK formats. This material is intended for persons involved in program maintenance, and system programmers who are altering the program design. It can be used to locate specific areas of the program, and it enables the reader to relate these areas to the corresponding pro-gram listings. Program logic information is not nec-essary for the use and operation of the program. Prerequisite Publications The reader must be familiar with the information presented in...|$|R
40|$|This paper {{introduces}} two new complex instructions {{over the}} application with specific instruction set processor. For the MCS- 51 family, utilizing a reserved bit, and the unused machine code “A 5 h” we can modify the conventional instruction set architecture (ISA) and develop two <b>macro</b> <b>instructions</b> for data manipulation. One {{of them is}} to move a block of data from specific memory locations to any other memory locations, while the other developed instruction is to obtain maximum byte-value within a group of 8 -bytes and load it into the Accumulator. There are two basic steps to achieve such developments, step- 1; at which we modify {{the architecture of the}} conventional microcontroller 8051 using hardware description language HDL. In the second step we modify the instruction set architecture (ISA) of μC 8051. Such development improves the performance of the μC including fast execution time, decrease machine code size, so decrease storage requirements and provide low power consumption...|$|R
