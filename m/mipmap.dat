64|101|Public
5000|$|<b>Mipmap,</b> Pyramid (image processing) - similar {{techniques}} in image processing ...|$|E
50|$|Each {{bitmap image}} of the <b>mipmap</b> set is a {{downsized}} duplicate of the main texture, but at a certain reduced level of detail. Although the main texture would still be used when the view is sufficient to render it in full detail, the renderer will switch to a suitable <b>mipmap</b> image (or in fact, interpolate between the two nearest, if trilinear filtering is activated) when the texture is viewed from a distance or at a small size. Rendering speed increases since the number of texture pixels (texels) being processed per display pixel can be much lower for similar results with the simpler <b>mipmap</b> textures. If using {{a limited number of}} texture samples per display pixel (as is the case with bilinear filtering) then artifacts are reduced since the <b>mipmap</b> images are effectively already anti-aliased. Scaling down and up is made more efficient with mipmaps as well.|$|E
50|$|Trilinear {{filtering}} is {{a remedy}} {{to a common}} artifact seen in mipmapped bilinearly filtered images: an abrupt and very noticeable change in quality at boundaries where the renderer switches from one <b>mipmap</b> level to the next. Trilinear filtering solves this by doing a texture lookup and bilinear filtering on the two closest <b>mipmap</b> levels (one higher and one lower quality), and then linearly interpolating the results. This results in a smooth degradation of texture quality as distance from the viewer increases, rather than a series of sudden drops. Of course, closer than Level 0 {{there is only one}} <b>mipmap</b> level available, and the algorithm reverts to bilinear filtering.|$|E
50|$|Less {{commonly}} used, OpenGL {{and other}} APIs support nearest-neighbor sampling from individual <b>mipmaps</b> whilst linearly interpolating the two nearest <b>mipmaps</b> {{relevant to the}} sample.|$|R
5000|$|Texturing: 1D/2D/3D textures, cubemaps, multi-texturing, texture arrays, texture rectangles, {{render to}} texture, texture {{coordinate}} generation, texture combiners, <b>mipmapping</b> and <b>mipmaps</b> generation, anisotropic filtering, compressed textures, depth textures, integer textures, non normalized textures, texture buffers, multisample textures.|$|R
5000|$|... 31.25 megapixels/second (texturing, {{perspective}} correction, bilinear filtering, translucency, Z-buffering, <b>mipmapping,</b> fog) ...|$|R
5000|$|... #Caption: An {{example of}} <b>mipmap</b> image storage: the {{principal}} {{image on the}} left is accompanied by filtered copies of reduced size.|$|E
50|$|Another {{solution}} to the downscale problem of bi-sampling scaling are mipmaps. A <b>mipmap</b> is a prescaled set of downscale copies. When downscaling the nearest larger <b>mipmap</b> is used as the origin, to ensure no scaling below the useful threshold of bilinear scaling is used. This is algorithm is fast, and easy to optimize. It is standard in many frameworks such as OpenGL. The cost is using more image memory, exactly one third more in the standard implementation.|$|E
50|$|To {{solve this}} problem, trilinear {{filtering}} interpolates between {{the results of}} bilinear filtering on the two mipmaps nearest to the detail required for the polygon at the pixel. If the pixel would take up 1/100 of the texture in one direction, trilinear filtering would interpolate between the result of filtering the 128*128 <b>mipmap</b> as y1 with x1 as 128, {{and the result of}} filtering on the 64*64 <b>mipmap</b> as y2 with x2 as 64, and then interpolate to x = 100.|$|E
25|$|Only {{bilinear}} texture filtering is supported; <b>mipmapped</b> {{textures and}} anisotropic filtering are not supported.|$|R
5000|$|<b>Mipmapping</b> {{was invented}} by Lance Williams in 1983 and is {{described}} in his paper Pyramidal parametrics. From the abstract: [...] "This paper advances a 'pyramidal parametric' prefiltering and sampling geometry which minimizes aliasing effects and assures continuity within and between target images." [...] The [...] "pyramid" [...] can be imagined as the set of <b>mipmaps</b> stacked {{on top of each}} other.|$|R
5000|$|<b>Mipmapping</b> (toggle with Insert key; {{required}} for correct functioning of some games, like the Jak series) ...|$|R
5000|$|... #Caption: An {{example of}} {{anisotropic}} <b>mipmap</b> image storage: the principal {{image on the}} top left is accompanied by filtered, linearly transformed copies of reduced size. (click to compare to previous, isotropic mipmaps of the same image) ...|$|E
50|$|OpenGL ES 1.1 added {{features}} such as mandatory support for multitexture, better multitexture support (including combiners and dot product texture operations), automatic <b>mipmap</b> generation, vertex buffer objects, state queries, user clip planes, and greater control over point rendering.|$|E
50|$|The {{origin of}} the term, <b>mipmap,</b> is an initialism of Latin Multum In Parvo (much in a small space), and map, {{modelled}} on bitmap.The term 'pyramids' is still commonly used in a GIS context. In GIS software, pyramids are primarily used for speeding up rendering times.|$|E
50|$|Trilinear {{filtering}} is {{an extension}} of the bilinear texture filtering method, which also performs linear interpolation between <b>mipmaps.</b>|$|R
5000|$|... #Caption: An {{illustration}} of texture filtering methods showing a trilinear <b>mipmapped</b> texture {{on the left}} and the same texture enhanced with anisotropic texture filtering on the right.|$|R
5000|$|Differential cone-tracing, {{considering}} a differential angular neighborhood around a ray, avoids {{the complexity of}} exact geometry intersection but requires a LOD representation of the geometry and appearance of the objects. <b>MIPmapping</b> is an approximation of it limited to {{the integration of the}} surface texture within a cone footprint. Differential ray-tracing [...] extends it to textured surfaces viewed through complex paths of cones reflected or refracted by curved surfaces. The full differential cone-tracing - including geometry and appearance filtering - is mostly applicable as volumetric cone-tracing, relying on 3D <b>MIPmapping.</b>|$|R
5000|$|... #Caption: In {{the case}} of an RGB image with three {{channels}} stored as separate planes, the total <b>mipmap</b> can be visualized as fitting neatly into a square area twice as large as the dimensions of the original image on each side. It also shows visually how using mipmaps requires 33% more memory.|$|E
5000|$|In {{computer}} graphics, mipmaps (also MIP maps) or pyramids [...] are pre-calculated, optimized {{sequences of}} images, {{each of which}} is a progressively lower resolution representation of the same image. The height and width of each image, or level, in the <b>mipmap</b> is a power of two smaller than the previous level. Mipmaps {{do not have to be}} square. They are intended to increase rendering speed and reduce aliasing artifacts. A high-resolution <b>mipmap</b> image is used for high-density samples, such as for objects close to the camera. Lower-resolution images are used as the object appears farther away. This is a more efficient way of downfiltering (minifying) a texture than sampling all texels in the original texture that would contribute to a screen pixel; it is faster to take a constant number of samples from the appropriately downfiltered textures. Mipmaps are widely used in 3D computer games, flight simulators, other 3D imaging systems for texture filtering and 2D as well as 3D GIS software. Their use is known as mipmapping. The letters [...] "MIP" [...] in the name are an acronym of the Latin phrase multum in parvo, meaning [...] "much in little". Since mipmaps, by definition, are pre-allocated, additional storage space is required to take advantage of them. They are also related to wavelet compression. <b>Mipmap</b> textures are used in 3D scenes to decrease the time required to render a scene. They also improve the scene's realism, at the cost of 1/3 more memory per texture.|$|E
5000|$|A {{challenge}} is {{presented by the}} texture cache small size of only 4 KB. This leads to developers needing to stretch small textures over a comparatively larger space. The console's bilinear filtering only blurs them. When mipmapping is used, texture width requirements and the extra storage for the <b>mipmap</b> levels limit the largest <b>mipmap</b> level to 2 KB. Toward {{the end of the}} Nintendo 64's market cycle, certain developers innovated with new techniques of precomputing their textures, {{such as the use of}} multi-layered texturing and heavily clamped, small texture pieces, to simulate larger textures; and with the streaming of precomputed textures into the small texture cache from the large, high speed, cartridge medium. Examples of this ingenuity are found in Rare's Perfect Dark, Banjo-Tooie, and Conker's Bad Fur Day and in Factor 5's Indiana Jones and the Infernal Machine. [...] Some games use plain colored Gouraud shading instead of texturing on certain surfaces, especially in games with themes not targeting realism (e.g., Super Mario 64).|$|E
50|$|In {{anisotropic}} implementations, the filtering may {{incorporate the}} same filtering algorithms used to filter the square maps of traditional <b>mipmapping</b> during {{the construction of}} the intermediate or final result.|$|R
40|$|We {{present a}} method for the {{efficient}} calculation of multi-resolution radiosity form factors using programmable graphics hardware. <b>Mipmapped</b> ID textures are used to allow for highly refined patches with the <b>mipmapping</b> mechanism working as a hardware accelerated oracle for the dynamic linking of patch hierarchies. The actual form factor values for unoccluded patches are then computed with the analytic differential area to polygon form factor using programmable graphics hardware. The resulting method allows for the efficient calculation of radiosity solutions with refined patch hierarchies as well as form factor values that are more accurate than those computed with the traditional hemicube algorithm. ...|$|R
40|$|This paper {{presents}} a GPU-based, fast, and accurate dynamic height field rendering technique that scales well to large scale height fields. Current real-time rendering algorithms for dynamic height fields employ approximate ray-height field intersection methods, whereas accurate algorithms require pre-computation {{in the order}} of seconds to minutes and are thus not suitable for dynamic height field rendering. We alleviate this problem by using maximum <b>mipmaps,</b> a hierarchical data structure supporting accurate and efficient rendering while simultaneously lowering the pre-computation costs to negligible levels. Furthermore, maximum <b>mipmaps</b> allow for view-dependent level-of-detail rendering. In combination with hierarchical ray-stepping this results in an efficient intersection algorithm for large scale height fields...|$|R
50|$|There {{is also an}} {{approach}} specialised for texture mapping called mipmapping, which works by creating lower resolution, pre-filtered versions of the texture map. When rendering the image, the appropriate-resolution <b>mipmap</b> is chosen and hence the texture pixels (texels) are already filtered when they arrive on the screen. Mipmapping is generally combined with various forms of texture filtering {{in order to improve}} the final result.|$|E
50|$|Clipmapping is {{a method}} of {{clipping}} a <b>mipmap</b> to a subset of data pertinent to the geometry being displayed. This is useful for loading as little data as possible when memory is limited, such as on a graphics processing unit. The technique is used for LODing in NVIDIA’s implementation of voxel cone tracing. The high-resolution levels of the mipmapped scene representation are clipped to a region near the camera while lower resolution levels are clipped further away.|$|E
50|$|By {{representing}} {{less interesting}} {{regions of the}} volume in a coarser resolution, the data input overhead can be reduced. On closer observation, the data in these regions can be populated either by reading from memory or disk, or by interpolation. The coarser resolution volume is resampled to a smaller size {{in the same way}} as a 2D <b>mipmap</b> image is created from the original. These smaller volume are also used by themselves while rotating the volume to a new orientation.|$|E
50|$|Once this is {{done the}} rest becomes easy: perform {{bilinear}} filtering on the two <b>mipmaps</b> with pixel sizes that are immediately larger and smaller than the calculated size of the pixel, and then interpolate between them as normal.|$|R
5000|$|Geomipmapping or {{geometrical}} <b>mipmapping</b> is a real-time block-based terrain rendering algorithm {{developed by}} W.H. de Boer in 2000 {{that aims to}} reduce CPU processing time which is a common bottleneck in level of detail approaches to terrain rendering.|$|R
40|$|Volume models often show high complexity. Local {{details and}} overall shape may {{sometimes}} {{be difficult to}} perceive. Unsharp masking techniques improve the perception of those small features by increasing the local contrast. In this paper we present a simple and fast method for feature enhancement based on 3 D <b>mipmaps.</b> In contrast to other approaches, in addition to increasing luminance on the feature details, we also darken the valleys of the volume thus increasing local contrast and making neighboring details more visible. Our approach is fast and simple, with small memory requirements thanks {{to the use of}} 3 D <b>mipmaps.</b> We also propose a color selection strategy, based on harmonic colors, that further enhances the salient features without abrupt or uncomfortable color changes. Peer ReviewedPostprint (published version...|$|R
50|$|Since it uses both {{larger and}} smaller mipmaps, trilinear {{filtering}} {{cannot be used}} in places where the pixel is smaller than a texel on the original texture, because mipmaps larger than the original texture are not defined. Fortunately bilinear filtering still works, {{and can be used}} in these situations without worrying too much about abruptness because bilinear and trilinear filtering provide the same result when the pixel size is exactly the same as the size of a texel on the appropriate <b>mipmap.</b>|$|E
50|$|Direct3D 11.0 {{features}} include: Support for Shader Model 5.0, Dynamic shader linking, addressable resources, additional resource types, subroutines, geometry instancing, coverage as pixel shader input, programmable interpolation of inputs, new texture compression formats (1 new LDR {{format and}} 1 new HDR format), texture clamps to limit WDDM preload, require 8-bits of subtexel and sub-mip precision on texture filtering, 16K texture limits, Gather4(support for multi-component textures, support for programmable offsets), DrawIndirect, conservative oDepth, Depth Bias, addressable stream output, per-resource <b>mipmap</b> clamping, floating-point viewports, shader conversion instructions, improved multithreading.|$|E
5000|$|This method still uses nearest {{neighbor}} interpolation, but adds mipmapping [...] - [...] first the nearest <b>mipmap</b> level is chosen according to distance, then the nearest texel center is sampled {{to get the}} pixel color. This reduces the aliasing and shimmering significantly during minification but does not eliminate it entirely. In doing so it improves texture memory access and cache-line reuse through avoiding arbitrarily large access strides through texture memory during rasterization. This does not help with blockiness during magnification as each magnified texel will still appear as a large rectangle.|$|E
50|$|<b>Mipmapping</b> is a {{standard}} technique used to save some of the filtering work needed during texture minification. It is also highly beneficial for cache coherency - without it the memory access pattern during sampling from distant textures will exhibit extremely poor locality, adversely affecting performance even if no filtering is performed.|$|R
40|$|We {{present a}} {{technique}} which uses existing OpenGL capabilities to approximate {{the effect of}} blurry specular reflections and indirect diffuse illumination. It makes use of environment maps, <b>mipmapping</b> with level of detail control, and possibly texture borders. The method is extremely simple to implement, in some cases requiring just a single additional OpenGL statement...|$|R
50|$|Although most of {{the time}} LOD is applied to {{geometry}} detail only, the basic concept can be generalized. Recently, LOD techniques also included shader management to keep control of pixel complexity.A form of level of detail management has been applied to texture maps for years, under the name of <b>mipmapping,</b> also providing higher rendering quality.|$|R
