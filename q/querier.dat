66|10000|Public
50|$|In {{order for}} IGMP, and thus IGMP snooping, to function, a {{multicast}} router must {{exist on the}} network and generate IGMP queries. The tables created for snooping (holding the member ports for each a multicast group) {{are associated with the}} <b>querier.</b> Without a <b>querier</b> the tables are not created and snooping will not work. Furthermore, IGMP general queries must be unconditionally forwarded by all switches involved in IGMP snooping. Some IGMP snooping implementations include full <b>querier</b> capability. Others are able to proxy and retransmit queries from the multicast router.|$|E
50|$|If IGMP {{snooping}} {{is enabled}} on a switch, or more commonly a wireless router/switch, it will interfere with UPnP/DLNA device discovery (SSDP) if incorrectly or incompletely configured (e.g. without an active <b>querier</b> or IGMP proxy), making UPnP appear unreliable.|$|E
50|$|IGMPv2 accelerates {{the process}} of leaving a group and adjusts other timeouts. Leave-group {{messages}} are sent to 224.0.0.2. A group-specific query is introduced. Group-specific queries are sent to the group's multicast address. A means for routers to select an IGMP <b>querier</b> for the network is introduced.|$|E
30|$|In our method, {{we define}} the <b>query</b> depth in Neo 4 j as follows: when we <b>query</b> from the {{starting}} node A to node B, we define the <b>query</b> depth as one; further, if we <b>query</b> from node B to another node C, that is, we <b>query</b> from A, through node B, to node C, we define the <b>query</b> depth as two, and so on. The <b>query</b> methods {{are divided into}} single <b>query</b> and traversal <b>query,</b> both of them do multi-query depth <b>query.</b> Although the middle <b>query</b> process of the single <b>query</b> may contain multiple results, it finally returns one <b>query</b> result only. Compared with the single <b>query,</b> traversal <b>query</b> will return all results of every depth, and it will only return {{the number of the}} nodes {{as the result of the}} <b>query</b> since the amount of the data is large. Taking Neo 4 j <b>query</b> as an example, single <b>query</b> and traversal <b>query</b> respectively perform five kinds of <b>queries</b> whose <b>query</b> depths are five. The final result of a single <b>query</b> is only one node; however, the middle result may have multiple nodes. Specially, count <b>query</b> is the <b>query</b> whose <b>query</b> result is the number of nodes, and the traversal <b>query</b> is the <b>query</b> which returns a specific number of nodes.|$|R
40|$|Abstract—In this paper, {{we focus}} on the <b>query</b> problem of {{trajectory}} tracking of moving targets in a wireless sensor network. Our motivation is to design in-network storage and <b>querying</b> protocols to support <b>queries</b> for searching a given target signature in a low <b>query</b> latency, high <b>query</b> reliability, and energy efficient manner. We propose a target trajectory <b>query</b> protocol, which combines index-based <b>query</b> and random <b>query</b> schemes. The <b>query</b> protocol guarantees <b>query</b> reliability and energy efficiency. In an index-based <b>queries</b> scheme, each target trajectory has an index, which is stored at an index node (designated node). <b>Query</b> nodes send <b>query</b> messages to the index node to get results. Naturally, index-based <b>queries</b> can guarantee <b>query</b> reliability, but the disadvantage is the <b>query</b> hotspot problem, which reduces the lifetime of the sensor network. A random <b>queries</b> scheme, which is based on opportunistic target signature propagation, sends <b>query</b> messages in random chosen directions to hit a sensor node that contains the given target signature near the <b>query</b> node. However, <b>queries</b> for targets whose signature propagation is very limited need a large number of random <b>query</b> messages to achieve high <b>query</b> reliability. Our algorithm combines the two <b>query</b> schemes. It takes advantages of both of them, and eliminates each individual’s disadvantages. Performance analysis and simulation studies show that our <b>query</b> protocol is superior to index-based <b>queries</b> in terms of the <b>query</b> hotspot problem, and it is superior to random <b>queries</b> in terms of energy efficiency, <b>query</b> latency, and <b>query</b> reliability. Index Terms—Target signature; linked list; opportunistic propagation; random query; <b>query</b> reliability I...|$|R
5000|$|<b>Query</b> {{rewriting}} is {{the process}} of automatically reformulating a search <b>query</b> to more accurately capture its intent. <b>Query</b> expansion adds additional <b>query</b> terms, such as synonyms, in order to retrieve more documents and thereby increase recall. <b>Query</b> relaxation removes <b>query</b> terms to reduce the requirements for a document to match the <b>query,</b> thereby also increasing recall. Other forms of <b>query</b> rewriting, such as automatically converting consecutive <b>query</b> terms into phrases and restricting <b>query</b> terms to specific fields, aim to increase precision. Apache Lucene search engine [...] uses <b>query</b> rewrite to transform complex <b>queries</b> to more primitive <b>queries,</b> such as expressions with wildcards (e.g. quer*) into a boolean <b>query</b> of the matching terms from the index (such as <b>query</b> OR <b>queries).</b>|$|R
5000|$|QQIC (Querier's Query Interval Code) : This code is used {{to specify}} the Query Interval value (in seconds) used by the <b>querier.</b> If the number is below 128, the value is used directly. If the value is 128 or more, it is {{interpreted}} as an exponent and mantissa.|$|E
50|$|Additionally, some {{switches}} with layer 3 capabilities {{can act as}} an IGMP <b>querier.</b> In networks {{where there}} is no router present to act as a multicast router, a switch with IGMP snooping enabled can be used to generate the needed IGMP messages to get users to subscribe to multicast traffic.|$|E
50|$|The IGMP {{protocol}} {{is implemented}} {{on a particular}} host and within a router. A host requests membership to a group through its local router while a router listens for these requests and periodically sends out subscription queries. A single router per subnet is elected to perform this querying function. Some multilayer switches include an IGMP <b>querier</b> capability to allow their IGMP snooping features {{to work in the}} absence of an IP multicast capability in the larger network.|$|E
40|$|Users submit <b>queries</b> to {{an online}} {{database}} via its <b>query</b> interface. <b>Query</b> interface parsing, which is im-portant for many applications, understands the <b>query</b> capabilities of a <b>query</b> interface. Since most <b>query</b> interfaces are organized hierarchically, {{we present a}} novel <b>query</b> interface parsing method, StatParser (Sta-tistical Parser), to automatically extract the hierarchical <b>query</b> capabilities of <b>query</b> interfaces. StatParser automatically learns from a set of parsed <b>query</b> interfaces and parses new <b>query</b> interfaces. StatParser starts from a small grammar and enhances the grammar {{with a set of}} probabilities learned from parsed <b>query</b> interfaces under the maximum-entropy principle. Given a new <b>query</b> interface, the probability-enhanced grammar identifies the parse tree with the largest global probability to be the <b>query</b> capabilities of the <b>query</b> interface. Experimental results show that StatParser very accurately extracts the <b>query</b> capabilities and can effectively overcome the problems of existing <b>query</b> interface parsers...|$|R
50|$|An {{example of}} a {{monotonic}} <b>query</b> is a select-project-join <b>query</b> containing only conditions of equality (also known as conjunctive <b>queries).</b> Examples of non-monotonic <b>queries</b> are aggregation <b>queries,</b> or <b>queries</b> with set difference.|$|R
40|$|<b>Query</b> folding {{refers to}} the {{activity}} of determining if and how a <b>query</b> can be answered using a given set of resources, which might be materialized views, cached results of previous <b>queries,</b> or <b>queries</b> answerable by another database. We investigate <b>query</b> folding in the context where <b>queries</b> and resources are conjunctive <b>queries.</b> We develop an exponential-time algorithm that finds all foldings, and a polynomial-time algorithm for the subclass of acyclic <b>queries.</b> Our results {{can be applied to}} <b>query</b> optimization in centralized databases, to <b>query</b> processing in distributed databases, and to <b>query</b> answering in federated databases. 1 Introduction <b>Query</b> folding {{refers to the}} activity of determining if and how a <b>query</b> can be answered using a given set of resources. These resources might be materialized views, cached results of previous <b>queries,</b> or even <b>queries</b> answerable by another database. <b>Query</b> folding is important because the base relations referred to in a <b>query</b> might be stored remotely a [...] ...|$|R
30|$|Some PIR {{protocols}} {{are called}} Symmetric Private Information Retrieval, when they {{comply with the}} Data Privacy requirement [13]. This condition states that the <b>querier</b> cannot distinguish between a database that possesses only the information he requested, and a regular one; in other words, that the <b>querier</b> does not get more information than he asked for.|$|E
40|$|Today’s {{topic is}} {{zero-knowledge}} databases (and zero-knowledge sets). In a ZK set, the <b>querier</b> submits x and should only learn if x is {{in a set}} D or not, in a provable way. But in a ZK database, the <b>querier</b> submits x and should only learn the corresponding database value D(x) (which might be the empty symbol), in a provable way. We’ll define ZK databases an...|$|E
40|$|With {{the wide}} {{propagation}} of internet-based social networks into our lives, {{there is a}} need for new mechanisms to control the release and use of personal data. As a step toward this goal, we develop a recommendation system that protects the privacy of user answers while allowing the <b>querier</b> to learn an aggregate weighted average of individual scores. Due to the use of social network connections, the <b>querier</b> obtains a more relevant and trustworthy result than what generic anonymous recommendation systems provide. We also give experimental performance results for our solution as well as for several recently developed secure computation techniques, which is of independent interest. ...|$|E
40|$|Large {{volume of}} <b>queries</b> over {{large volume of}} users allows search engine to build methods for {{generating}} <b>query</b> suggestion for input <b>query.</b> <b>Query</b> recommendation methods are powerful technique to generate related <b>queries</b> or alternate <b>queries</b> as a <b>query</b> suggestion for original <b>query</b> which is given by user in the search engine first time. In this review paper we discussed about <b>query</b> recommendation methods and comparison between different methods how the <b>query</b> suggestion is given by these methods for the input <b>query</b> by user in search engine. Some <b>query</b> recommendation method do not covers the unseen and rare <b>queries</b> {{but some of them}} covers these <b>queries</b> by some additional feature added such as generalize the <b>query</b> token of input <b>query</b> by a suitable place holder from hierarchy tool wordnet 3. 0 or wekepedia by yago mapping. These generalization techniques are also discussed in this paper...|$|R
40|$|Declarative <b>query</b> {{languages}} {{are an important}} feature of database management systems and have {{played an important role}} in their success. As database management technology enters the multimedia information system area, the availability of special-purpose <b>query</b> languages for multimedia applications will be equally important. In this report, we survey multimedia <b>query</b> languages and <b>query</b> models. Particularly, we look at those systems from the point of view of well-defined <b>queries,</b> fuzzy <b>queries,</b> visual <b>queries,</b> and <b>query</b> presentations. Several research issues, such as generic multimedia <b>query</b> languages, incremental <b>queries,</b> fuzzy <b>queries,</b> spatio-temporal <b>queries,</b> feature storage and organization, are also identified. In our opinion these are vital issues for the success and development of a multimedia <b>query</b> language...|$|R
40|$|Abstract — <b>Query</b> {{processing}} in sensor networks {{has recently}} received significant {{attention from the}} research community. Processing <b>queries</b> in an energy efficient manner is a crucial challenge. There exists numerous ways to process a <b>query</b> in sensor networks. Choosing {{an efficient way to}} process the <b>query</b> is essential for <b>query</b> optimization. In this paper, we consider a <b>query</b> optimizer for sensor networks. By examining <b>query</b> plans, each of which specifies a way to execute the <b>query,</b> our <b>query</b> optimizer estimates the energy the <b>query</b> plan may consume. A <b>query</b> plan that will potentially utilize the least energy is chosen for execution. Simulation results show that the <b>query</b> plan chosen by our <b>query</b> optimizer consumes a significant less amount of energy than our simulation of TinyDB, a state-of-the-art <b>query</b> processing engine for sensor networks. I...|$|R
40|$|Itz {{this paper}} we address rlze proble 17 z of e/zsuri/zg tlze {{correctness}} of query results retur-/led 6). atz u/ztrusted pn'vate database. The database okvtzs rlze data and /nay nzodi ' it at any rime. The <b>querier</b> is allo~ved to execute queries over this database; however it /nay/lot Ieanz a/z). thing nzore than the result of these legal queries. The <b>querier</b> does not necessarily trust the database and would like rlze owtier to furtzislz proof that the data has nor been tnodijed in response to recent events suclz as tlze submission of the query We develop two metrics that capture rlze correctness of query answers and propose a range of solutions that provide a trade-off between rlze degree of exposure of private data, and the overhead of generation and verijcation of tlze proof: Our proposed solutio/zs are rested rlzrouglz i/npleme/ztation using PostgreSQL. ...|$|E
40|$|In {{this paper}} we {{address the problem of}} {{ensuring}} the correctness of query results returned by an untrusted private database. The database owns the data and may modify it at any time. The <b>querier</b> is allowed to execute queries over this database; however it may not learn anything more than the result of these legal queries. The <b>querier</b> does not necessarily trust the database and would like the owner to furnish proof that the data has not been modified in response to recent events such as the submission of the query. We develop two metrics that capture the correctness of query answers and propose a range of solutions that provide a trade-off between the degree of exposure of private data, and the overhead of generation and verification of the proof. Our proposed solutions are tested on real data through implementation using PostgreSQL. 1...|$|E
40|$|The {{aim of this}} {{technical}} report is to complement the work in [To et al. 2014] by proposing a Group Key Exchange protocol so that the <b>Querier</b> and TDSs (and TDSs themselves) can securely create and exchange the shared key. Then, the security of this protocol is formally proved using the game-based model. Finally, we perform the comparison between this protocol and other related works...|$|E
50|$|In {{database}} theory, a conjunctive <b>query</b> is {{a restricted}} form of first-order <b>queries.</b> Many first-order <b>queries</b> {{can be written}} as conjunctive <b>queries.</b> In particular, {{a large part of}} <b>queries</b> issued on relational databases can be expressed in this way. Conjunctive <b>queries</b> also have a number of desirable theoretical properties that larger classes of <b>queries</b> (e.g., the relational algebra <b>queries)</b> do not share.|$|R
30|$|A more {{detailed}} analysis {{has been conducted}} to show some specific <b>query</b> properties and their relation with QbE STD performance focusing on the two best QbE STD systems (system 1 and system 4 b). We have set two different categories as follows: worst <b>queries</b> and best <b>queries.</b> The former are those that contribute with a negative ATWV within the final performance and the latter are those that posses the best ATWV contribution within the final performance. Twelve different <b>queries</b> belong to the worst <b>query</b> category, and ten different <b>queries</b> do to the best <b>query</b> category. Among the worst <b>queries,</b> there are ten <b>queries</b> that belong {{to one of the}} worst groups based on the earlier analyses (short-length <b>queries,</b> high-energy <b>queries</b> for system 4 b, and low-energy <b>queries</b> for system 1). Among the best <b>queries,</b> there are seven <b>queries</b> that belong to one of the best groups presented in the previous analyses (medium energy <b>queries</b> and long-length <b>queries).</b>|$|R
30|$|We then study {{why some}} <b>queries</b> are not {{identified}} by SimAttack (i.e., Misclassified and Unknown <b>queries</b> on Fig. 13). Results {{show that the}} proportion of <b>queries</b> in the these two categories changes according to the number of fake <b>queries.</b> For instance, for 1 fake <b>query,</b> unknown <b>queries</b> represent 78.9 % of non-identified <b>queries</b> while misclassified <b>queries</b> represent 21.1 %. If we consider 7 fake <b>queries,</b> these percentages change to 40.8 and 59.2 %, respectively.|$|R
40|$|We {{propose a}} {{distributed}} multiresolution representation of sensor network data so that large-scale summaries {{are readily available}} by querying {{a small fraction of}} sensor nodes, anywhere in the network, and small-scale details are available by querying a larger number of sensors, locally in the region of interest. A global <b>querier</b> (such as a mobile collector or unmanned aerial vehicle) can obtain a lossy to lossless representation of the network data, according to the desired resolution. A local <b>querier</b> (such as a sensor node) can also obtain either large-scale trends or local details, by querying its immediate neighborhood. We want the encoding to be robust to arbitrary, even time-varying, wireless communication connectivity graphs. Thus we want to avoid cluster heads or deterministic hierarchies that are not robust to single points of failure. We propose a randomized encoding which enables both robustness, and distributed computation that does not require long distance coordination or awareness of network connectivity at individual sensors. Our distributed encoding algorithm operates on local neighborhoods of the communication graph...|$|E
40|$|Social search {{systems such}} as Aardvark and Facebook Questions allow users to pose {{questions}} to their social network in real time. Upon receiving a question on a particular topic, Aardvark for example forwards the question to available “experts ” close to the <b>querier</b> in the social network to facilitate immediate, relevant answers to questions that prove too complex for web searches, e. g., when “Googling it ” {{is not likely to}} yield adequate answers. While such systems have tremendous potential to tap into expertise, they are monolithic and do not provide adequate privacy. For example, Aardvark and Facebook have complete knowledge of the social network’s structure, and users cannot pose anonymous queries or hide their areas of expertise. Thus the success of these systems will be limited to more general categories of questions and expertise, since many users will avoid asking or answering questions related to sensitive topics such as health, political activism, sexual orientation, and even innocuous questions which may make the <b>querier</b> seem ignorant. We propose Pythia, the first distributed peer-to-peer (P 2 P) social-network architectur...|$|E
40|$|Abstract. Database {{outsourcing}} is {{a popular}} industry trend which involves organizations delegating their data management needs to an external service provider. Since a service provider is almost never fully trusted, security and privacy of outsourced data are important concerns. This paper focuses on integrity and authenticity issues in outsourced databases. Whenever someone queries a hosted database, the returned results must be demonstrably authentic: the <b>querier</b> needs to establish – in an efficient manner – that both integrity and authenticity (with respect to the actual data owner) are assured. To this end, some recent work [19] examined two relevant signature schemes: a condensed variant of batch RSA [3] and an aggregated signature scheme based on bilinear maps [6] In this paper, we introduce the notion of immutability for aggregated signature schemes. Immutability refers {{to the difficulty of}} computing new valid aggregated signatures from a set of other aggregated signatures. This is an important feature, particularly for outsourced databases, since lack thereof enables a frequent <b>querier</b> to eventually amass enough aggregated signatures to answer other (un-posed) queries, thus becoming a de facto service provider. Since prior work does not offer immutability, we propose several practical techniques to achieve it. ...|$|E
40|$|Abstract. Through the {{in-depth}} {{study of the}} existing distributed database <b>query</b> processing technology, this paper proposes a distributed database <b>query</b> processing program. This program optimizes the existing <b>query</b> processing, stores the commonly used <b>query</b> results according to the <b>query</b> frequency, to be directly used by the subsequent <b>queries</b> or used as intermediate <b>query</b> results, thus avoiding possible transmission {{of a large number}} of data, thereby reducing the <b>query</b> time and improving <b>query</b> efficiency...|$|R
5000|$|A <b>query</b> optimizer {{will not}} always choose the most {{efficient}} <b>query</b> plan for a given <b>query.</b> In some databases the <b>query</b> plan can be reviewed, problems found, and then the <b>query</b> optimizer gives hints {{on how to improve}} it. In other databases alternatives to express the same <b>query</b> (other <b>queries</b> that return the same results) can be tried. Some <b>query</b> tools can generate embedded hints in the <b>query,</b> for use by the optimizer.|$|R
5000|$|<b>Query</b> level {{features}} or <b>query</b> features, which depend {{only on the}} <b>query.</b> For example, {{the number}} of words in a <b>query.</b> Further information: <b>query</b> level feature ...|$|R
40|$|This article {{presents}} P 4 Q, a fully decentralized gossip-based protocol to personalize query processing in social tagging systems. P 4 Q dynamically associates each user with social acquaintances sharing similar tagging behaviors. Queries are gossiped among such acquaintances, computed on-the-fly in a collaborative, yet partitioned manner, and results are iteratively refined {{and returned to}} the <b>querier.</b> Analytical and experimental evaluations convey the scalability of P 4 Q for top-k query processing, as well its inherent ability to cope with users updating profiles and departing...|$|E
40|$|A secure {{index is}} a data {{structure}} {{that allows a}} <b>querier</b> with a “trapdoor ” for a word x to test in O(1) time only if the index contains x; The index reveals no information about its contents without valid trapdoors, and trapdoors can only be generated with a secret key. Secure indexes allow a <b>querier</b> to check if a document contains a keyword without having to decrypt the entire document, a property that is especially useful for large documents and large document collections. In this paper, we formally define a secure index and formulate a security model for indexes known as semantic security against adaptive chosen keyword attack (ind-cka). We also develop an efficient ind-cka secure index construction called z-idx using pseudo-random functions and Bloom filters. We apply z-idx to two real world document sets and show that index sizes are reasonable. Furthermore, the computational cost is low — a 866 MHz Pentium machine can search through about 15000 indexes per second. We also show how to use z-idx to implement searches on encrypted data. This search scheme inherits the efficiency of z-idx, the ability to handle arbitrary updates, and is indifferent to the compression and encryption algorithm used on the documents. ...|$|E
40|$|AbstractWe {{assume that}} a {{database}} of personal information comprises records of individuals that contain confidential or sensitive fields. Queries about the distribution of a sensitive field within a selected population in the database can be submitted to the data center. However, {{the answers to the}} queries may leak confidential information about some individuals, even though no identification information is provided. Inspired by decision theory, we present two quantitative models for privacy protection in such a database query or linkage environment. One models the value of information from the viewpoint of the <b>querier,</b> while the other models the damage caused by and compensation for privacy leakage. In both models, we define the information state by a class of probability distributions on a set of possible confidential values. These states can be modified and refined by the user’s knowledge acquisition behavior. In the first model, the value of information is defined as the expected gain of the <b>querier,</b> and privacy is protected by imposing costs on the answers to the queries to balance any potential gain. In the second model, the safety of information is guaranteed by ensuring that anyone misusing private information must pay more compensation than the value of the possible gain...|$|E
40|$|We review {{existing}} <b>query</b> {{answering systems}} for sensor data. We then propose an extended <b>query</b> answering approach termed smart <b>query,</b> specifically for marine sensor data. The smart <b>query</b> answering system integrates pattern <b>queries</b> and continuous <b>queries.</b> The proposed smart <b>query</b> system considers both streaming data and historical data from marine sensor networks. The smart <b>query</b> also uses <b>query</b> relaxation technique and semantics from domain knowledge as a recommender system. The proposed smart <b>query</b> benefits in building {{data and information}} systems for marine sensor networks...|$|R
40|$|Session: QoS, <b>Query</b> Processing, Optimization (full paper) International audienceThis paper {{concerns}} {{the integration of}} the Case Based Reasoning (CBR) paradigm in <b>query</b> processing, providing a way to optimize <b>queries</b> when there is no prior knowledge on <b>queried</b> data sources and certainly no related metadata such as data statistics. Our <b>Query</b> Optimization by Learning (QOL) approach optimizes <b>queries</b> using cases generated from the evaluation of similar past <b>queries.</b> A <b>query</b> case comprises: (i) the <b>query,</b> (ii) the <b>query</b> plan and (iii) the measures (computational resources consumed) of the <b>query</b> plan. The work also {{concerns the}} way the CBR process interacts with the <b>query</b> plan generation process. This process uses classical heuristics and makes decisions randomly (e. g. when there is no statistics for join ordering and selection of algorithms, routing protocols); It also (re) uses cases (existing <b>query</b> plans) for similar <b>queries</b> parts, improving the <b>query</b> optimization and evaluation efficiency...|$|R
40|$|Navigational <b>queries</b> for graph-structured data, such as {{the regular}} path <b>queries</b> and the {{context-free}} path <b>queries,</b> are usually evaluated to a relation of node-pairs $(m, n) $ such {{that there is a}} path from $m$ to $n$ satisfying the conditions of the <b>query.</b> Although this relational <b>query</b> semantics has practical value, we believe that the relational <b>query</b> semantics can only provide limited insight {{in the structure of the}} graph data. To address the limits of the relational <b>query</b> semantics, we introduce the all-path <b>query</b> semantics and the single-path <b>query</b> semantics. Under these path-based <b>query</b> semantics, a <b>query</b> is evaluated to all paths satisfying the conditions of the <b>query,</b> or, respectively, to a single such path. While focusing on context-free path <b>queries,</b> we provide a formal framework for evaluating <b>queries</b> on graphs using both path-based <b>query</b> semantics. For the all-path <b>query</b> semantics, we show that the result of a <b>query</b> can be represented by a finite context-free grammar annotated with node-information relevant for deriving each path in the <b>query</b> result. For the single-path <b>query</b> semantics, we propose to search for a path of minimum length. We reduce the problem of finding such a path of minimum length to finding a string of minimum length in a context-free language, and for deriving such a string we propose a novel algorithm. Our initial results show that the path-based <b>query</b> semantics have added practical value and that <b>query</b> evaluation for both path-based <b>query</b> semantics is feasible, even when <b>query</b> results grow very large. For the single-path <b>query</b> semantics, determining strict worst-case upper bounds on the size of the <b>query</b> result remains the focus of future work...|$|R
