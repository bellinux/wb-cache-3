23|32|Public
5000|$|IBM DB2 LUW {{supports}} a <b>Quiesce</b> command {{that is used}} to indicate a state for which all users have been locked out of a database or an instance (of databases) so that administrative tasks can be performed. See DB2 <b>Quiesce</b> Command ...|$|E
5000|$|Microsoft Windows SharePoint Services 3.0 and Microsoft Office SharePoint Server 2007/2010 {{support a}} <b>QUIESCE</b> or <b>QUIESCE</b> FROM TEMPLATE (2010) option within the Central Administration {{operations}} window. This allows an administrator {{to stop the}} server farm from accepting new user connections and gradually brings any long-running applications offline without causing data loss.|$|E
5000|$|Symantec's Livestate - now {{includes}} a <b>quiesce</b> process, as does VMware's VI3 snapshot and VCB features. Symantec supports Exchange and SQL.|$|E
5000|$|A graceful {{shutdown}} of WebSphere MQ is called <b>quiescing.</b> See <b>Quiescing</b> MQ.|$|R
5000|$|... cputimeused_limit -- {{provides}} {{the amount of}} CPU time, expressed in milliseconds, that a request thread may consume before having its WLM enclave <b>quiesced.</b> A <b>quiesced</b> enclave is considered below discretionary in terms of WLM priorities.|$|R
5000|$|JADE Object Oriented Database {{system can}} perform a <b>quiesced</b> backup with the {{parameter}} 'quiesced=true'. The database {{is placed in}} a quiescent state by allowing current active transactions to complete and then flushing modified buffers from cache to the stable database. See http://www.jade.co.nz/docs/jade/Default.htm#resources/dbadmin/chapter_3_-_administering_the_jade_database/online_quiesced_backup.htm. During a <b>quiesced</b> backup, updating transactions are not permitted and attempts to execute database transactions raise a database exception.|$|R
5000|$|ORACLE also {{supports}} a <b>Quiesce</b> command since version 9i which allows existing users {{to continue to}} use resources but disallows new resources being made available. See Oracle High Availability Features ...|$|E
50|$|Data {{transfer}} may be temporarily {{suspended by}} using the <b>QUIESCE</b> method. While the path is suspended, no further message transfers are allowed on the path until the RESUME method is invoked by the virtual machine that initially suspended the path.|$|E
5000|$|IBM DB2 for z/OS, OS/390 and IBM i Operating System has {{a utility}} command called <b>QUIESCE,</b> used {{in order to}} make it write all data {{belonging}} to a certain database (a logical entity in a DB2 subsystem) from the buffers, helping utility programs get DRAIN access on the datasets quickly.|$|E
40|$|Abstract. We {{present a}} {{lightweight}} type-and-effect system for Java programs that features two major innovations over extant object-oriented effects systems: initialization effects, which are writes to an object’s state {{while it is}} being constructed, and <b>quiescing</b> fields, which are fields that are never written after an object is constructed. We also present a novel taxonomy of degrees of method purity in object-oriented programs, which characterizes methods whose effects are confined to their receiver object. Finally, we find significant amounts of mostly-functional behavior in realistic Java programs: in the benchmarks we analyzed, between 48 – 53 % of declared fields were identifiable as <b>quiescing</b> and between 24 – 78 % of dynamic field reads were from <b>quiescing</b> fields...|$|R
5000|$|... "Script Hooks"—allowing {{integration}} of customized scripts that are executed at specific points during administrators' backup strategy lifecycle. For instance, databases {{and other services}} can be <b>quiesced</b> before a backup starts and then relaunched after the backup completes successfully.|$|R
6000|$|It was Miss Cotton, who, {{while this}} process of <b>quiescing</b> lasted, {{appeared}} not to know Mrs. Brinkley. When she became aware of her, all was lost again. [...] "Mrs. Brinkley!" [...] she cried, {{as well as one}} can cry in whisper. [...] "Is it possible?" ...|$|R
5000|$|Microsoft Visual Studio Team Foundation Server {{supports}} <b>quiesce</b> functionality {{by using}} the TFS Service Control command-line utility. More information exists about this command-line utility in the MSDN Library. A Microsoft Knowledge Base article describes it by indicating that it disables access to Team Foundation Server services {{for the duration of}} servicing operations. See Microsoft Support KB 950893 ...|$|E
50|$|To <b>quiesce</b> is {{to pause}} or alter a device or {{application}} {{to achieve a}} consistent state, usually {{in preparation for a}} backup or other maintenance. In software applications that modify information stored on disk, this generally involves flushing any outstanding writes; see buffering. With telecom applications, this generally involves allowing existing callers to finish their call but preventing new calls from initiating.|$|E
5000|$|SYBASE ASE 12.0 {{and above}} support a <b>QUIESCE</b> DATABASE command that {{prevents}} any process from running commands that {{write to the}} transaction log. The primary purpose is to stop all update activity so the database files can be copied or backed up using OS level utilities. While the database is quiesced, it is still available to users for read-only queries. See http://manuals.sybase.com/onlinebooks/group-as/asg1251e/sag/@Generic__BookView;pt=72438?DwebQuery=quiesce+database ...|$|E
50|$|Perhaps {{the best}} known support for this was {{incorporated}} into Microsoft Shadow Copies which was introduced in Microsoft Windows Server 2003. For an application to be <b>quiesced</b> during the shadow copy process, it must register itself {{as a writer and}} it is responsible for putting itself into a quiescent mode upon notification.|$|R
50|$|Shadow copy backups are a {{new high}} speed backup method. Shadow copy backups are {{dramatically}} faster because the copy is virtually made after {{a brief period of}} <b>quiescing</b> an application. As subsequent updates are made to the data, the virtual copy is materialized. In some cases, hardware support for shadow copy backups means that actually saving the virtual copies is unnecessary. Shadow copy backups are always full backups.|$|R
40|$|Abstract: Software {{transactional}} memory (STM) is {{a promising}} programming model that adapts many concepts bor-rowed from the databases world to control concurrent accesses to memory (RAM) locations. In this {{paper we propose}} a new classification for the active states of a transaction; a new memory <b>quiescing</b> algorithm, to allow the safe transition of a memory block form transactional to non-transactional space; we compare word and object transactional grain units; and evaluate the cost of consistent state validation, arguing that this cost can be minimized by performing partial validation on problematic code regions. ...|$|R
50|$|The fog alarm was a {{diaphone}} which horn {{was mounted}} {{on the south side}} of the lighthouse building, 33 ft above water level, and pointed 165°30' (a bearing of S 8° E). The horn was operated by compressed air, and every minute would issue three 2-second blasts separated by 3-second intervals of silence, <b>quiesce</b> for 48 seconds after the third blast, then repeated the pattern.|$|E
5000|$|Logical {{instructions}} are Move Characters, Move with offset, Move Immediate, Move Numerics, Move Zones, Compare Logical Immediate, Compare Logical Characters, Edit, And immediate, Or immediate, Test under Mask, and Translate. One logical instruction {{unique to the}} Model 20 is [...] "Halt and Proceed" [...] (HPR, operation code X'99') which will <b>quiesce</b> input/output and stop the processor displaying a code to the operator. Operation can be restarted by pressing the [...] "start" [...] button.|$|E
50|$|A {{geophyte}} (earth+plant) is a {{plant with}} an underground storage organ including true bulbs, corms, tubers, tuberous roots, enlarged hypocotyls, and rhizomes. Most plants with underground stems are geophytes {{but not all}} plants that are geophytes have underground stems. Geophytes are often physiologically active even when they lack leaves. They are able to survive during adverse environmental conditions by going {{into a state of}} <b>quiesce</b> and later resume growth from their storage organs, which contain reserves of carbohydrates and water, when the environmental conditions are favourable again.|$|E
40|$|We {{develop a}} {{framework}} for addressing correctness and timeliness-of-propagation issues for reactive constraints - global constraints or user-defined constraints that are implemented through constraint propagation. The notion of propagation completeness is introduced to capture timeliness of constraint propagation. A generalized form of arc-consistency is formulated which unifies many local consistency conditions in the literature. We show that propagation complete implementations of reactive constraints achieve this arc-consistency when propagation <b>quiesces.</b> Finally, we use the framework to state and prove an impossibility result: that CHR cannot implement a common relation with a desirable degree of timely constraint propagation...|$|R
50|$|Traditional pessimistic {{replication}} systems try {{to guarantee}} {{from the beginning}} that all of the replicas are identical to each other, as if there was only a single copy of the data all along. Optimistic replication does away with this in favor of eventual consistency, meaning that replicas are guaranteed to converge only when the system has been <b>quiesced</b> for a period of time. As a result {{there is no longer a}} need to wait for all of the copies to be synchronized when updating data, which helps concurrency and parallelism. The trade-off is that different replicas may require explicit reconciliation later on, which might then prove difficult or even insoluble.|$|R
40|$|On shared-memory systems, Cilk-style work-stealing [5] {{has been}} used to {{effectively}} parallelize irregular task-graph based applications such as Unbalanced Tree Search (UTS) [24, 28]. Therearetwomaindifficultiesinextendingthisapproach to distributed memory. In the shared memory approach, thieves (nodes without work) constantly attempt to asynchronously steal work from randomly chosen victims until they find work. In distributed memory, thieves cannot autonomously steal work from a victim without disrupting its execution. When work is sparse, this results in performance degradation. In essence, a direct extension of traditional work-stealing to distributed memory violates the work-first principle underlying work-stealing. Further, thieves spend useless CPU cycles attacking victims that have no work, resulting in system inefficiencies in multi-programmed contexts. Second, it is non-trivial to detect active distributed termination (detect that programs at all nodes are looking for work, hence there is no work). This problem is well-studied and requires careful design for good performance. Unfortunately, in most existing languages/frameworks, application developers are forced to implement their own distributed terminationdetection. In this paper, we develop a simple set of ideas that allow work-stealing to be efficiently extended to distributed memory. First, we introduce lifeline graphs: low-degree, lowdiameter, fully-connected directed graphs. Such graphs can be constructed from k-dimensional hypercubes. When a node is unable to find work after w unsuccessful steals, it <b>quiesces</b> after informing the outgoing edges in its lifeline graph. Quiescent nodes do not disturb other nodes. A <b>quiesced</b> node is reactivated when work arrives from a lifeline, anditselfsharesthisworkwiththoseofitsincominglifelines that are activated. Termination occurs precisely when computationatallnodeshasquiesced. Inalanguagesuchas X 10...|$|R
5000|$|Snapshot backup: A {{snapshot}} is an instantaneous {{function of}} some storage systems that presents {{a copy of}} the file system as if it were frozen at a specific point in time, often by a copy-on-write mechanism. An effective way to back up live data is to temporarily <b>quiesce</b> them (e.g. close all files), take a snapshot, and then resume live operations. At this point the snapshot can be backed up through normal methods. [...] While a snapshot is very handy for viewing a filesystem as it was at a different point in time, it is hardly an effective backup mechanism by itself.|$|E
50|$|The lost packets {{force the}} TCP {{protocol}} to perform error recovery, but the initial (streamlined) recovery attempts fail because the retransmitted packets are lost {{in exactly the}} same way as the original packets. Eventually, the TCP transmission window becomes full and the TCP protocol refuses to transmit any further data until the previously-transmitted data is acknowledged. This, in turn, will <b>quiesce</b> the new traffic over the connection, leaving only the retransmissions and acknowledgments. Since the retransmission timer grows progressively longer between attempts, eventually a retransmission will occur when there is no reverse traffic on the connection, and the acknowledgment are finally received. This will restart the TCP traffic, which in turn immediately causes lost packets as streaming resumes.|$|E
5000|$|Thread Hang Recovery -- A {{facility}} {{that attempts to}} interrupt Java threads in the servant region JVM when the request timer has expired. If interruption is not possible it provides a mechanism to delay the EC3 abend of the servant region, {{which is the way}} WAS z/OS refreshes a JVM. The new function provides several enhancements over prior versions of WAS z/OS: the ability to set a custom number of threads per servant JVM; the ability to set a threshold percent of threads that may be marked hung before processing an EC3 abend; and a new [...] "excessive CPU" [...] variable that will <b>quiesce</b> the WLM enclave of a thread that has exceeded a specified amount of CPU time.|$|E
50|$|Streaming backup is {{a backup}} method where copies of all desired {{database}} files and the necessary log files are {{made during the}} backup process. File copies may be saved directly to tape or {{can be made to}} any other storage device. No <b>quiescing</b> of activity of any kind is required with streamed backups. Both the database and log files are check summed to ensure that no data corruptions exist within the data set during the backup process. Streaming backups may also be incremental backups. Incremental backups are ones in which only the log files are copied and which can be restored along with a previous full backup to bring all databases to a recent state.|$|R
40|$|Using a {{previously}} described retinal explant culture system as an acute injury model, we here explore {{the role of}} C 1 q, the initiator of the classical complement pathway, in neuronal cell survival and retinal homeostasis. Full-thickness adult rat retinal explants were divided into four groups, receiving the following supplementation: C 1 q (50 nM), C 1 -inhibitor (C 1 -inh; Berinert; 500 mg/l), C 1 q + C 1 -inh, and no supplementation (culture controls). Explants were kept for 12 h or 2 days after which they were examined morphologically and with a panel of immunohistochemical markers. C 1 q supplementation protects ganglion cells from degeneration within the explant in vitro system. This effect is correlated to an attenuated endogenous production of C 1 q, and a <b>quiesced</b> gliotic response...|$|R
40|$|Severe data {{contention}} {{may exist}} between short update transactions and long read-only queries if both are {{to access the}} same database through a conventional concurrency control method. In this paper, we present dynamic finite versioning (DFV) schemes to effectively support concurrent processing of transactions and queries. Without acquiring locks, queries read from a small, fixed number of dynamically derived, transaction-consistent, but maybe slightly obsolete, logical snapshots of the database. On the other hand, transactions access the most up-to-date data in the database without data contention from queries. Intermediate versions created between snapshots are automatically discarded. Furthermore, dirty pages updated by active transactions are allowed to be written back into the database before commitment (i. e., the STEAL policy), {{and at the same}} time, consistent logical snapshots can be advanced automatically without <b>quiescing</b> the ongoing transactions or queries. 1 Introduction C [...] ...|$|R
50|$|Particular {{care must}} be taken when {{designing}} systems with bussed signals which are wired to more than one hot-swap component. When a hot-swap component is inserted its input and output signal pins will represent a temporary short-circuit to ground. This can cause unwanted ground-level pulses on the signals which can disturb the operation of other hot-swap components in the system. This was a problem for early parallel SCSI disk-drives. One common design solution is to protect bussed signal pins with series diodes or resistors. CMOS buffer devices are now available with specialized inputs and outputs that minimize disturbance of bussed signals during the hot-swap operation. If all else fails, another solution is to <b>quiesce</b> the operation of all components during the hot-swap operation.|$|E
40|$|Systems, {{methods and}} {{apparatus}} are provided through {{which in some}} embodiments an autonomic environmental safety device may be quiesced. In at least one embodiment, a method for managing an autonomic safety device, such as a smoke detector, based on functioning state and operating status of the autonomic safety device includes processing received signals from the autonomic safety device to obtain {{an analysis of the}} condition of the autonomic safety device, generating one or more stay-awake signals based on the functioning status and the operating state of the autonomic safety device, transmitting the stay-awake signal, transmitting self health/urgency data, and transmitting environment health/urgency data. A <b>quiesce</b> component of an autonomic safety device can render the autonomic safety device inactive for a specific amount of time or until a challenging situation has passed...|$|E
40|$|There {{are times}} when the {{execution}} of an object needs to be suspended and later resumed either due to the object responding to external events or processing requirements internal to the object. The Microthread pattern simplifies the management of an object’s execution when the object needs to start, stop, and resume its execution. This pattern has shown itself to be useful in both stand alone and distributed applications. An example usage is shown along with the benefits and liabilities of using the pattern. An implementation outline is also provided along with some sample code. Finally, patterns related to the Microthread pattern are listed. 1. 0 Intent Allow an object to start, stop, and resume its execution. This allows an object to be contextually sensitive to events during its execution or to <b>quiesce</b> while waiting for events or resources needed to continue execution...|$|E
40|$|Any highly {{available}} data warehouse will use {{some form of}} data replication to tolerate machine failures. In this paper, we demonstrate that we can leverage this data redundancy to build an integrated approach to recovery and high availability. Our approach, called HARBOR, revives a crashed site by querying remote, online sites for missing updates and uses timestamps to determine which tuples need to be copied or updated. HARBOR {{does not require a}} stable log, recovers without <b>quiescing</b> the system, allows replicated data to be stored non-identically, and is simpler than a log-based recovery algorithm. We compare the runtime overhead and recovery performance of HARBOR to those of two-phase commit and ARIES, the gold standard for log-based recovery, on a three-node distributed database system. Our experiments demonstrate that HARBOR suffers lower runtime overhead, has recovery performance comparable to ARIES’s, and can tolerate the fault of a worker and efficiently bring it back online. 1...|$|R
40|$|In {{software}} transactional memory (STM) systems, it {{is useful}} to isolate a memory region accessed by one thread from all others, so that it can then operate on it “privately”, that is, without the instrumentation overhead of inter-transactional synchronization. Allowing transactions to implicitly privatize memory is a source of major performance degradation in state-of-the-art STMs. The alternative, to explicitly declare and guarantee privacy only when needed, has been argued to be too tricky to be useful for general programming. This paper proposes private transactions, a simple intermediate that combines the ease of use of implicit privatization, with the efficiency that can be obtained from explicitly knowing which regions are private. We present a new scalable <b>quiescing</b> algorithm for implicit privatization using private transactions, applicable to virtually any STM algorithm, including the best performing TL 2 /LSA-style STMs. The new algorithm delivers virtually unhindered performance at all privatization levels when private transactions involve work, and even under the extreme case of empty private transactions, allows for a scalable “pay as you go ” privatization overhead depending on the privatization level. 1...|$|R
40|$|Abstract: Most {{information}} systems projects are over budget, under specified, delivered late, {{and fail to}} meet organizational expectations. A key reason for these characterizations is that during the {{information systems}} development, requirements both change and are being introduced. This paper presents a strategy whereby full development is started only {{after a series of}} realistic code-generator produced prototypes are created through mission-based database design techniques. The quickly accomplished prototypes are demonstrated to key user groups, and are iterated until they truly reflect a <b>quiesced</b> set of valid and accurate requirements. Production class systems created through CASE, metadata repositories and code generators will then be on-budget, correctly specified, timely, and will meet organization expectations. 1. Overview Many, if not most, information technology (IT) projects exhibit these characteristics: over budget, under specified, delivered late, and fail to meet organizational expectations. [1], [2], [3] The United States Government’s General Accounting Office (GAO) has been studying IT projects for a number of years, and a review of 10 of the GAO studies clearly shows that the main reason s why IT systems fail {{has nothing to do with}} IT. [4], [5]...|$|R
