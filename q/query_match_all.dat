0|10000|Public
40|$|As {{the fuzzy}} data {{management}} {{has become one}} of the main research topics and directions, the question of how to obtain the useful information by means of keyword query from fuzzy XML documents is becoming a subject of an increasing needed investigation. Considering the keyword query methods on crisp XML documents, smallest lowest common ancestor (SLCA) semantics is one of the most widely accepted semantics. When users propose the keyword query on fuzzy XML documents with the SLCA semantics, the query results are always incomplate, with low precision, and with no possibilities values returned. Most of keyword query semantics on XML documents only consider <b>query</b> results <b>matching</b> <b>all</b> keywords, yet users may also be interested in the <b>query</b> results <b>matching</b> partial keywords. To overcome these limitations, in this paper, we investigate how to obtain more comprehensive and meaningful results of keyword querying on fuzzy XML documents. We propose a semantics of object-oriented keyword querying on fuzzy XML documents. First, we introduce the concept of "object tree", analyze different types of matching result object trees and find the "minimum result object trees" which contain all keywords and "result object trees" which contain partial keywords. Then an object-oriented keyword query algorithm ROstack is proposed to obtain the root nodes of these matching result object trees, together with their possibilities. At last, experiments are conducted to verify the effectiveness and efficiency of our proposed algorithm...|$|R
40|$|We {{consider}} {{the problem of}} designing an information retrieval system on which partial <b>match</b> <b>queries</b> have to be answered. Each record in the system consists of a list of attributes, and a partial <b>match</b> <b>query</b> specifies the values {{of some of the}} attributes. The records am stored in buckets in a secondary memory, and in order to answer a partial <b>match</b> <b>query</b> <b>all</b> the buckets that may contain a record satisfying the specifications of that query must be retrieved. The bucket in which a given record is stored is found by a multiple key hashing function, which maps each attribute to a string of a fixed number of bits. The address of that bucket is then represented by the string obtained by concatenating the strings on which the various attributes were mapped. A partial <b>match</b> <b>query</b> may specify only part of the bits in the string representing the address, and the larger the number of bits specified, the smaller the number of buckets that have to be retrieved in order to answer the query. The optimization problem considered in this paper is that of deciding to how many bits each attribute should be mapped by the bashing function above, so that the expected number of buckets retrieved per query is minimized. Efficient solutions for special cases of this problem have been obtained in [l], [12], and [14]. It is shown that in general the problem is NP-hard, and that if P # NP, it is also not fully approximable. Two heuristic algorithms for the problem are also given and compared...|$|R
50|$|Since {{sources of}} data within the data grid {{will consist of}} data from {{multiple}} separate systems and networks using different file naming conventions, {{it would be difficult}} for a user to locate data within the data grid and know they retrieved what they needed based solely on existing physical file names (PFNs). A universal or unified name space makes it possible to create logical file names (LFNs) that can be referenced within the data grid that map to PFNs. When an LFN is requested or <b>queried,</b> <b>all</b> <b>matching</b> PFNs are returned to include possible replicas of the requested data. The end user can then choose from the returned results the most appropriate replica to use. This service is usually provided as part of a management system known as a Storage Resource Broker (SRB). Information about the locations of files and mappings between the LFNs and PFNs may be stored in a metadata or replica catalogue. The replica catalogue would contain information about LFNs that map to multiple replica PFNs.|$|R
40|$|Index {{structures}} for multiple sets {{can be classified}} into those that group entries according to their key values and those that group entries according to their set membership. The former are particularly suited for exact <b>match</b> <b>queries</b> on <b>all</b> indexed sets, the latter especially support range queries on {{a small number of}} all indexed sets. The goal is to thoroughly evaluate the performance of both grouping strategies. There exist two reasons for adding a new index structure to the evaluation: (1) The performance potentials of set grouping index structures are not yet fully exploited. (2) Up to now, the database administrator has to choose between key grouping and set grouping index structures, supporting either exact <b>match</b> or range <b>queries.</b> What is needed is a more flexible index structure that can be tuned to a given query mix containing both, exact <b>match</b> and range <b>queries.</b> These two reasons led us {{to the development of the}} CG-tree. The focus of the paper is on intr [...] ...|$|R
5000|$|Command Line Tools: {{these are}} simple Java and [...]NET applications, {{built on the}} SDK, each of which {{provides}} a single function, such as resolve, <b>query,</b> <b>match,</b> and register.|$|R
5000|$|Google {{for example}} calls {{this sort of}} {{information}} [...] "Knowledge Graph", if a search <b>query</b> <b>matches</b> it will display an additional sub-window on right hand side with information from its sources.|$|R
40|$|As {{biological}} pathway databases continually increase {{in size and}} availability, efficient tools and techniques to query these databases are needed to mine useful biological information. A plethora of existing techniques already allow for exact or approximate <b>query</b> <b>matching.</b> Despite initial success, power-ful techniques used for XML and RDF <b>query</b> <b>matching</b> {{have yet to be}} sufficiently exploited for use in <b>query</b> <b>matching</b> in the bioinformatics domain. In this paper, we employ the transitive closure to focus on <b>matching</b> hierarchical <b>queries,</b> i. e., finding pathways or graphs that possess a query’s overall hierarchical structure. This approach allows for a greater latitude in fuzzy matching by focusing on the overall hierarchies of queries and graphs. Since hierarchies are only inherent in directed acyclic graphs, we have also developed a robust heuristic to heuristically solve the minimum feedback arc set problem. Analysis on 53 H. sapiens and 23 S. cerevisiae cyclic KEGG pathways have shown that our heuristic performs quite favorably. We have implemented the techniques in an easy to use GUI softwar...|$|R
30|$|The chapterization of {{the paper}} is as follows: Section 2 {{presents}} the theoretical background. Section 3 illustrates the proposed method, <b>query</b> <b>matching,</b> and overall framework. Section 4 provides the experimental results, and Section 5 forms the concluding part {{of the paper}}.|$|R
40|$|The {{threat that}} malware poses to RFID systems was {{identified}} only recently. Fortunately, all currently known RFID malware {{is based on}} SQLIA. Therefore, in this chapter we propose a dual pronged, tag based SQLIA detection and prevention method optimized for RFID systems. The first technique is a SQL <b>query</b> <b>matching</b> approach that uses simple string comparisons and provides strong security against {{a majority of the}} SQLIA types possible on RFID systems. To provide security against second order SQLIA, which is a major gap in the current literature, we also propose a tag data validation and sanitization technique. The preliminary evaluation of our <b>query</b> <b>matching</b> technique is very promising, showing 100 % detection rates and 0 % false positives for all attacks other than second order injection...|$|R
40|$|LSI {{and related}} methods Given {{a set of}} k basis vectors (x 1 [...] . xk) = Xk, express the data matrix A {{in terms of the}} columns of this basis [...] That is, solve the least squares problem: min Y ‖A−XkY‖. The basis vectors xj may be the left {{singular}} vectors, or the centroids of some clustering of the data vectors into k clusters. Also express the query in the new basis, and perform <b>query</b> <b>matching</b> in the new subspace spanned by the xj, j = 1 [...] . k. Linear Algebra Methods for Data Mining, Spring 2007, University of Helsinki 1 Note: • SVD gives the best approximation of A in terms of minimizing distance between A and XkY (in the euclidean norm). • But: centroids seem to give a better (reduced dimensional) representa-tion of the original documents (at least for well clustered data). • That is, with centroids it seems possible to use even smaller reduced dimension than SVD to get results of similar quality. • Centroids play a very similar role as do singular vectors in LSI. • BUT:Centroids/Concept vectors are sparse. Singular vectors are essentially full. Linear Algebra Methods for Data Mining, Spring 2007, University of Helsinki 2 <b>Query</b> <b>matching</b> <b>Query</b> <b>matching</b> is usually done using cosine similarity: cos(θ(q,aj)) = qTaj ‖q‖‖aj ‖ ≥ tol Varying tolerance you vary the precision and recall: P...|$|R
40|$|In our {{previous}} work,we introduced the Wigan Peer-to-Peer database server, {{which is based}} on the popular BitTorrent file-sharing protocol. In Wigan, users (peers) cache the results of queries they receive and make these available to future users. A central component, known as the Tracker, keeps a record of which users have submitted which queries and uses this record to provide a new user submitting a query with a list of one or more peers that already have these query results. In this paper, we describe the <b>query</b> <b>matching</b> process which occurs at the Tracker, thus highlighting the differences between <b>query</b> <b>matching</b> in a P 2 P database and file matching in a P 2 P filesharing system and the challenges these differences posed. © 2010 University of Newcastle upon Tyne. Printed and published by the University of Newcastle upon Tyne...|$|R
50|$|Through this scheme, network {{topology}} awareness {{can be used}} to tune the network behaviour to more efficiently distribute data. For example, in a Peer-to-Peer network, more responsive identification and delivery of content can be achieved. In the Azureus application, Vivaldi is used to improve the performance of the distributed hash table that facilitates <b>query</b> <b>matches.</b>|$|R
30|$|More precisely, our {{contribution}} consists in proposing (1) {{a framework for}} using spatio-semantic similarity measures to search the log of an SOLAP server to find the set of candidate relevant <b>queries</b> <b>matching</b> the current <b>query.</b> (2) Generating recommendations and classifying the recommended queries in order to present first the most relevant ones. (3) Implementing the approach and evaluating its efficiency.|$|R
40|$|Abstract — E-learning {{plays the}} major role for {{gathering}} {{the best kind}} of knowledge through online. Semantic based E-learning methodology provides the rich learning content extracted from various web resources. It is most suitable and effective for content processing and retrieving methodologies. Ontology is defined as a representation of a shared conceptualization of a particular domain and is a major componenet of the semantic web. Semantic web-based E-Learning system focus on the RDF data model and improves the efficiency of the E-Learning system. The web data is mined by means of structured semantic process. The main problem in web-based data extraction is lacking in heterogeneous web services discovery. The E-learning content mostly focus on single domain ontologies and lacks in complex <b>query</b> <b>matching</b> process. This paper surveys about heterogeneous semantic based E-learning framework in order to improve the complex query data processing and <b>query</b> <b>matching</b> mechanism. This heterogeneous based E-learning framework incorporates content from various domains...|$|R
40|$|International audienceIn this paper, {{we propose}} a novel query {{language}} for video indexing and retrieval that (1) enables to make queries {{both at the}} image level and at the semantic level (2) enables the users to define their own scenarios based on semantic events and (3) retrieves videos with both exact matching and similarity <b>matching.</b> For a <b>query</b> language, four main issues must be addressed: data modeling, query formulation, query parsing and <b>query</b> <b>matching.</b> In this paper we focus and give contributions on data modeling, query formulation and <b>query</b> <b>matching.</b> We are currently using color histograms and SIFT features at the image level and 10 types of events at the semantic level. We have tested the proposed query language for the retrieval of surveillance videos of a metro station. In our experiments the database contains more than 200 indexed physical objects and 48 semantic events. The results using different types of queries are promising...|$|R
40|$|Tree {{patterns}} are fundamental to querying tree-structured data like XML. Because of {{the heterogeneity of}} XML data, it is often more appropriate to permit approximate <b>query</b> <b>matching</b> and return ranked answers, {{in the spirit of}} Information Retrieval, than to return exact matches. In this paper, we study the problem of approximate XML <b>query</b> <b>matching,</b> based on tree pattern relaxations, and devise efficient algorithms to evaluate relaxed tree patterns. We consider weighted tree patterns, where exact and relaxed weights, associated with nodes and edges of the pattern, are used to compute the scores of query answers. We are interested in two problems: (i) finding answers whose scores are at least as large as a given threshold, and (ii) finding the top-k answers. We design data pruning algorithms where intermediate query results are filtered dynamically during the evaluation process. Finally, we show experimentally that our approach outperforms rewriting-based and post-pruning strategies. We develop several optimizations that exploit scores of intermediate results to improve query evaluation efficiency...|$|R
5000|$|Match image - The <b>query</b> is <b>matched</b> against {{billions of}} images in Google's back end.|$|R
30|$|The methods {{explained}} in the preliminary section distinguish the texture pattern in an image effectively. However, the micro-patterns are not portrayed clearly. Against this background, a new approach for texture classification is proposed by incorporating {{the advantages of the}} abovementioned techniques. In this section, the proposed theoretical information is presented. Then, the technique adopted for <b>query</b> <b>matching</b> is discussed. Finally, an overview of the framework is enumerated.|$|R
40|$|We {{present a}} {{knowledge-based}} query expansion technique to improve document retrieval effectiveness. The general concept terms in a query are substituted {{by a set}} of specific concept terms used in the corpus that co-occur with the key query concept. Since the expanded <b>query</b> <b>matches</b> with the document index terms much better, experimental results reveal that such query expansion produces better retrieval effectiveness than the unexpanded ones...|$|R
50|$|However, {{websites}} {{can offer}} PPC ads. Websites that utilize PPC ads will display an advertisement when a keyword <b>query</b> <b>matches</b> an advertiser's keyword list, {{or when a}} content site displays relevant content. Such advertisements are called sponsored links or sponsored ads, and appear adjacent to, above, or beneath organic results on search engine results pages, or anywhere a web developer chooses on a content site.|$|R
5000|$|In {{terms of}} syntax, {{to add a}} {{negative}} keyword to a campaign or ad group, simply include a minus sign (-) prefix (e.g. -jobs). Negative keywords can be added in multiple ways, to allow for more precision, whereby -job will exclude ads most broadly, -"jobs" [...] will exclude all phrases containing the word & -jobs will only exclude ads when a <b>query</b> <b>matches</b> exactly.|$|R
30|$|For {{the results}} {{obtained}} in Fig.  5 for the ORB prototype, it was seen that the <b>queries</b> <b>matched</b> accurately for the typical range (− 10 % to + 10 %). The results ORB prototype dropped for higher ranges; however, further work {{can be done to}} improve this, which is suggested in Section 5. This meant that for the real-world applications, it would be robust which corresponds to research done.|$|R
40|$|We {{consider}} {{the problem of}} finding and ranking paths in semistructured data without necessarily knowing its full structure. The query language we adopt comprises conjunctions of regular path queries, allowing path variables {{to appear in the}} bodies and the heads of rules, so that paths can be returned to the user. We propose an approximate <b>query</b> <b>matching</b> semantics which adapts standard notions of approximation from string matching to graph <b>matching.</b> <b>Query</b> results are returned to the user ranked in order of increasing “distance” to the user’s original query. We show that the top-k approximate answers can be returned in polynomial time {{in the size of the}} database graph and the query...|$|R
40|$|This work {{presents}} {{a study to}} bridge topic modeling and personalized search. A probabilistic topic model is used to extract topics from user search history. These topics {{can be seen as}} a roughly summary of user preferences and further treated as feedback within the KL-Divergence retrieval model to estimate a more accurate query model. The topics more relevant to current query contribute more in updating the query model which helps to distinguish between relevant and irrelevant parts and filter out noise in user search history. We designed task oriented user study and the results show that: (1) The extracted topics can be used to cluster queries according to topics. (2) The proposed approach improves ranking quality consistently for <b>queries</b> <b>matching</b> user past interests and is robust for <b>queries</b> not <b>matching</b> past interests. ...|$|R
5000|$|Several MTS {{commands}} {{that use}} file names or lists of file names allow {{the use of}} file-name patterns: COPY, DESTROY, DUPLICATE, EMPTY, EDIT, FILESTATUS, FILEMENU, LIST, LOCKSTATUS, PERMIT, RENAME, RENUMBER, and TRUNCATE. A question-mark (?) is the pattern match character. A single question-mark used in a file-name will match zero or more characters. [...] "?" [...] <b>matches</b> <b>all</b> files for the current signon ID, [...] "?.S" [...] <b>matches</b> <b>all</b> files that end with [...] ".S", [...] "A?B" [...] <b>matches</b> <b>all</b> files that begin with [...] "A" [...] and end with [...] "B", [...] "A?B?C" [...] <b>matches</b> <b>all</b> files that start with [...] "A", end with [...] "C", and contain a [...] "B". Two or more consecutive question-marks match [...] "n-1" [...] characters. [...] "???.S" [...] <b>matches</b> <b>all</b> four character file-names that end with [...] ".S", and [...] "????" [...] <b>matches</b> <b>all</b> three character file-names. [...] "W163:?" [...] <b>matches</b> <b>all</b> files under the signon ID [...] "W163" [...] to which the current user has some access.|$|R
50|$|A media query {{consists}} of a media type and one or more expressions, involving media features, which resolve to either true or false. The result of the query is true if the media type specified in the media <b>query</b> <b>matches</b> the type of device the document is being displayed on and all expressions in the media query are true. When a media query is true, the corresponding style sheet or style rules are applied, following the normal cascading rules.|$|R
40|$|Abstract. We {{consider}} {{the problem of}} finding and ranking paths in semistructured data without necessarily knowing its full structure. The query language we adopt comprises conjunctions of regular path queries, allowing path variables {{to appear in the}} bodies and the heads of rules, so that paths can be returned to the user. We propose an approximate <b>query</b> <b>matching</b> semantics which adapts standard notions of approximation from string matching to graph <b>matching.</b> <b>Query</b> results are returned to the user ranked in order of increasing “distance ” to the user’s original query. We show that the top-k approximate answers can be returned in polynomial time {{in the size of the}} database graph and the query. ...|$|R
40|$|Content based video <b>{{querying}}</b> {{and video}} <b>matching</b> systems are {{popular in the}} recent technology. The content based video querying takes a sample video clip as an input query and performs the searching operation {{in the collection of}} videos which are stored in the video database. This proposal, introduces a novel content-based video matching and copy elimination system that finds the most relevant video segments from video database based on the given query video clip. For effective video copy elimination based on the feature extraction the proposed system applies the scheme names as Dense SIFT_OP (DSIFT_OP). This performs the feature extraction, copy elimination and effective <b>query</b> <b>matching</b> from the video collections. This thesis overcomes the problem of video frame minin...|$|R
40|$|Web {{search is}} {{ubiquitous}} {{in our daily}} lives. Caching has been ex-tensively used to reduce the computation time of the search en-gine and reduce the network traffic beyond a proxy server. Another form of web search, known as online shortest path search, is popu-lar due to advances in geo-positioning. However, existing caching techniques are ineffective for shortest path queries. This is due to several crucial differences between web search results and shortest path results, in relation to <b>query</b> <b>matching,</b> cache item overlapping, and query cost variation. Motivated by this, we identify several properties that are essen-tial {{to the success of}} effective caching for shortest path search. Our cache exploits the optimal subpath property, which allows a cached shortest path to answer any query with source and target nodes on the path. We utilize statistics from query logs to estimate the benefit of caching a specific shortest path, and we employ a greedy algo-rithm for placing beneficial paths in the cache. Also, we design a compact cache structure that supports efficient <b>query</b> <b>matching</b> at runtime. Empirical results on real datasets confirm the effective-ness of our proposed techniques. 1...|$|R
40|$|Next-generation converged {{networks}} shall deliver many {{innovative services}} over the standardized SIPbased IMS signaling infrastructure. Several such services exploit the joint presence information of a consumer, i. e. SIP entity requesting a service, and a vendor, i. e. SIP resource providing a service. Presence information {{is a collection}} of contextual attributes (e. g. location, availability, reputation), some of which change dynamically. Moreover, this collective presence information is distributed across multiple presence servers. While performing <b>query</b> <b>matching</b> based on joint presence information, a server usually routes each query to a locally available resource. However, skews in the spatio-temporal distribution of queries and resources may require queries to be routed to alternate servers with available resources. We propose a novel Resource-Aware Query Routing scheme, called RAQR, where each server proactively establishes gradients to suitable servers via a diffusion-based algorithm. Gradients are set up whenever a server anticipates scarcity of resources and withdrawn when the resource crunch is mitigated. We compare RAQR with alternative resource matching schemes and show that it adapts to spatio-temporal variations in resource availability, thereby leading to effective <b>query</b> <b>matching</b> with minimal control overhead...|$|R
40|$|BLAST-based {{similarity}} searches {{are commonly}} used in several applications involving both nucleotide and protein sequences. These applications span from simple tasks such as mapping sequences over a database to more complex procedures as clustering or annotation processes. When the amount of analysed data increases, manual inspection of BLAST results become a tedious procedure. Tools for parsing or filtering BLAST results for different purposes are then required. We describe here PARIGA ([URL] a server that enables users to perform all-against-all BLAST searches on two sets of sequences selected by the user. Moreover, since it stores the two BLAST output in a python-serialized-objects database, results can be filtered according to several parameters in real-time fashion, without re-running the process and avoiding additional programming efforts. Results can be interrogated by the user using logical operations, for example to retrieve cases where two <b>queries</b> <b>match</b> same targets, or when sequences from the two datasets are reciprocal best hits, or when a <b>query</b> <b>matches</b> a target in multiple regions. The Pariga web server {{is designed to be}} a helpful tool for managing the results of sequence similarity searches. The design and implementation of the server renders all operations very fast and easy to use...|$|R
5000|$|Sky Italia (UEFA: delayed Italy <b>matches,</b> <b>all</b> other <b>matches</b> live. CONMEBOL: <b>all</b> <b>matches</b> live) ...|$|R
40|$|Chatterbots are {{computer}} programs that simulate intelligent conversation. They {{make use of}} various techniques such as pattern matching, indexing, sentence reconstruction, and even natural language processing. In this paper we present an approach to chatterbots that mixes pattern matching with indexing and <b>query</b> <b>matching</b> methods inspired by information retrieval. We propose a model in which new sentences can be produced from existing ones using an evolutionary algorithm adapted {{to the structure of}} the natural language. KEY WORDS genetic algorithms, natural language processing, chatterbot...|$|R
40|$|Abstract. The {{presence}} of structure inside XML documents poses the hard challenge of providing flexible <b>query</b> <b>matching</b> methods for effective retrieval of results. In this paper we present {{an approach that}} faces this issue in a twofold fashion: 1) it exploits new approximations on data structure; 2) it provides a relevance ranking method {{that takes into account}} the degree of correctness and completeness of results with respect to a given query, as well as the degree of cohesion of data retrieved. ...|$|R
40|$|Abstract: This paper {{presents}} an algorithm to improve a web search query {{based on the}} feedback on the viewed documents. A user who is searching {{for information on the}} Web marks the retrieved (viewed) documents as relevant or irrelevant to further expose the information needs expressed in the original query. A new web search <b>query</b> <b>matching</b> this improved understanding of the user’s information needs is synthesized from these text documents. The methodology provides a way for creating web search <b>query</b> that <b>matches</b> the user’s information need even when the user may have difficulty in doing so directly due to lack of experience in the query design or lack of familiarity of the search domain. A user survey has shown that the algorithmically formed query has recall coverage and precision characteristics better than those achieved by the experienced human web searchers. ...|$|R
40|$|Sponsored search {{becomes an}} easy {{platform}} to match potential consumers' intent with merchants' advertising. Advertisers express {{their willingness to}} pay for each keyword in terms of bids to the search engine. When a user's <b>query</b> <b>matches</b> the keyword, the search engine evaluates the bids and allocates slots to the advertisers that are displayed along side the unpaid algorithmic search results. The advertiser only pays the search engine when its ad is clicked by the user and the price-per-click {{is determined by the}} bids of other competing advertisers...|$|R
