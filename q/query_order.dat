25|829|Public
5000|$|Term reordering: in {{information}} retrieval {{this is a}} standard technique to reduce the work involved in retrieving results. This transformation is invisible to the user, since the results ordering uses the original <b>query</b> <b>order</b> to determine relevance.|$|E
40|$|Hemaspaandra, Hempel, and Wechsung [cs. CC/ 9909020] {{raised the}} {{following}} questions: If one is allowed one question {{to each of}} two different information sources, does {{the order in which}} one asks the questions affect the class of problems that one can solve with the given access? If so, which order yields the greater computational power? The answers to these questions have been learned-inasfar as they can be learned without resolving whether or not the polynomial hierarchy collapses-for both the polynomial hierarchy and the boolean hierarchy. In the polynomial hierarchy, <b>query</b> <b>order</b> never matters. In the boolean hierarchy, <b>query</b> <b>order</b> sometimes does not matter and, unless the polynomial hierarchy collapses, sometimes does matter. Furthermore, the study of <b>query</b> <b>order</b> has yielded dividends in seemingly unrelated areas, such as bottleneck computations and downward translation of equality. In this article, we present some of the central results on <b>query</b> <b>order.</b> The article is written {{in such a way as}} to encourage the reader to try his or her own hand at proving some of these results. We also give literature pointers to the quickly growing set of related results and applications. Comment: 15 page...|$|E
40|$|Hemaspaandra, Hempel, and Wechsung [cs. CC/ 9909020] {{initiated}} {{the field of}} <b>query</b> <b>order,</b> which studies {{the ways in which}} computational power is affected by the order in which information sources are accessed. The present paper studies, for the first time, <b>query</b> <b>order</b> as it applies to the levels of the polynomial hierarchy. We prove that the levels of the polynomial hierarchy are order-oblivious. Yet, we also show that these ordered query classes form new levels in the polynomial hierarchy unless the polynomial hierarchy collapses. We prove that all leaf language classes - and thus essentially all standard complexity classes - inherit all order-obliviousness results that hold for P. Comment: 14 page...|$|E
40|$|In certain {{database}} {{applications such}} as deductive databases, batch query processing, and recursive query processing etc., a single query can {{be transformed into a}} set ofclosely related database queries. Great benefits can be obtained by executing a group of related queries all to-gether in a single unijied multi-plan instead of executing each <b>query</b> separately. In <b>order</b> to achieve this, Multiple Query Optimization (MQO) identifies common task(s) (e. g. common subezpressions, joins, etc.) among a set of query plans and creates a single unified plan (multi-plan) which can be executed to obtain the required out-puts forall queries at once. In this paper, anew heuris-tic function (f=), dynamic <b>query</b> <b>ordering</b> heuristics, and Depth-First Branch-and-Bound (DFBB) are de-jined and experimentally evaluated, and compared with existing methods which use A * and static query order-ing. Our experiments show that all three of f., DFBB, and dynamic <b>query</b> <b>ordering</b> help to improve the perfor-mance of our h 4 Q 0 algorithm. ...|$|R
40|$|The {{exchange}} and storage of XML data {{is becoming increasingly}} important. In contrast to conventional semistructured data [4, 1], the labels in a document-oriented representation such as XML are ordered. Furthermore, regular expressions (DTDs) describe the horizontal (and vertical) structure of the data. Traditional query languages for semi-structured data ignore the horizontal order and are therefore limited in their expressiveness and optimizability. We describe a query language for <b>querying</b> <b>ordered</b> semistructured data. This query language provides primitives for specifying more powerful <b>queries</b> on <b>ordered</b> semistructured data. Furthermore, we describe how horizontal type information in DTDs is used to optimize queries based on finite automata...|$|R
5000|$|The mean {{reciprocal}} rank is {{a statistic}} measure for evaluating any process {{that produces a}} list of possible responses {{to a sample of}} <b>queries,</b> <b>ordered</b> by probability of correctness. The reciprocal rank of a query response is the multiplicative inverse of the rank of the first correct answer. The mean reciprocal rank is the average of the reciprocal ranks of results for a sample of queries Q: ...|$|R
40|$|Abstract: Hemaspaandra, Hempel, and Wechsung [HHW] {{initiated}} the eld of <b>query</b> <b>order,</b> which studies {{the ways in}} which computational power is a ected by the order in which information sources are accessed. The present paper studies, for the rst time, <b>query</b> <b>order</b> as it applies to the levels of the polynomial hierarchy. P C:D denotes the class of languages computable by a polynomial-time machine that is allowed one query to C followed by one query to D [HHW]. We prove that the levels of the polynomial hierarchy are order-oblivious: P p j: p k = P p k: p j. Yet, we also show that these ordered query classes form new levels in the polynomial hierarchy unless the polynomial hierarchy collapses. We prove that all leaf language classes|and thus essentially all standard complexity classes|inherit all order-obliviousness results that hold for P...|$|E
40|$|Abstract—In {{the query}} model of multi-variate {{function}} compu-tation, {{the values of}} the variables are queried sequentially, in an order that may depend on previously revealed values, until the function’s value can be determined. The function’s computation query complexity is the lowest expected number of queries required by any <b>query</b> <b>order.</b> Instead of computation, it is often easier to consider verification, where the value of the function is given and the queries aim to verify it. The lowest expected number of queries necessary is the function’s verification query complexity. We show that for all symmetric functions of indepen-dent binary random variables, the computation and verification complexities coincide. This provides a simple method for finding the query complexity and the optimal <b>query</b> <b>order</b> for computing many functions. We also show that if the symmetry condition is removed, there are functions whose verification complexity is strictly lower than their computation complexity, and mention that the same holds when the independence or binary conditions are removed. I...|$|E
40|$|In {{the query}} model of multivariate {{function}} computation, {{the values of}} the inputs are queried se-quentially in an order that may depend on previously revealed values until the function’s value can be determined. The function’s computation query complexity is the lowest expected number of queries required by any <b>query</b> <b>order.</b> Instead of computation, it is often easier to consider verification, where the value of the function is given and the queries aim to verify it. The lowest expected number of queries necessary is the function’s verification query complexity. We show that for all symmetric func-tions of independent binary random variables, the computation and verification complexities coincide. This provides a simple method for finding the query complexity and optimal <b>query</b> <b>order</b> for computing many functions. We also show that after relaxing any of the symmetry, independence, or binary inputs restrictions, there are functions whose verification complexity is strictly lower than their computation complexity. ...|$|E
6000|$|... "Plenty {{good boy}} stop along Langa-Langa?" [...] Van Horn, unperturbed, politely <b>queried,</b> in <b>order</b> to make {{conversation}} and advertise nonchalance.|$|R
40|$|In [1] the {{collapse}} result theorem was proved for locally generic <b>queries</b> over <b>ordered</b> domain with Pseudo-finite Homogeneity Property. In {{a very interesting}} paper of Baldwin and Benedikt [2] {{the collapse}} result theorem was proved for locally generic <b>queries</b> over <b>ordered</b> domains without the independence property. It means that over such a domain, order-generic extended queries fail to express more than restricted queries. It was observed by Baldwin and Benedikt in [2] that any theory without the independence property is P-reducible. I prove that, for the P-reducible theories, a version of Pseudo-finite Homogeneity Property holds...|$|R
30|$|Data {{models and}} <b>queries</b> must support <b>order</b> and time based operations.|$|R
40|$|We {{show that}} {{the order in which}} different-size-rounds of {{parallel}} queries to Σ p i, i 1, are made never matters. This solves a problem left open by previous papers in that area [HHH 98 a, BC]. Our results shed new light on the numberof -queries tradeoffs between parallel, a mixture of parallel and sequential, and pure sequential access to Σ p i oracles. 1 Introduction In this paper we solve an open question related to <b>query</b> <b>order</b> in the polynomial hierarchy. We show that when making two consecutive rounds of parallel queries to a Σ p i oracle, i 1, the order in which these rounds are made never matters. However, in contrast to cases that already have been considered in the literature, [HHH 98 a, BC], the query rounds can not be made simultaneously unless the polynomial hierarchy collapses. Our results extend to the case of more than two rounds of parallel queries. Such generalized <b>query</b> <b>order</b> classes can also be seen as complexity classes being based on a mix [...] ...|$|E
40|$|People are {{impatient}} and discount future rewards more {{when they are}} asked to delay consumption than when they are offered the chance to accelerate consumption. The three experiments reported here provide a process-level account for this asymmetry, with implications for designing decision environments that promote less impulsivity. In Experiment 1, a thought-listing procedure showed that people decompose discount valuation into two queries. Whether one considers delayed or accelerated receipt of a gift certificate influences the order in which memory is queried to support immediate versus delayed consumption, and the order of queries affects the relative number of patient versus impatient thoughts. Relative frequency and clustering of impatient thoughts predicts discounting and mediates the discounting asymmetry. Experiment 2 implicated <b>query</b> <b>order</b> causally: When participants listed reasons for immediate versus delayed consumption in the order used spontaneously in acceleration and delay decisions, the discounting asymmetry was replicated; reversing the order in which reasons were listed eliminated the asymmetry. The results of Experiment 3, which used an implicit-memory task, support a memory-interference account of the effect of <b>query</b> <b>order...</b>|$|E
40|$|We study <b>query</b> <b>order</b> {{within the}} {{polynomial}} hierarchy. P C:D denotes {{the class of}} languages computable by a polynomial-time machine that is allowed one query to C followed by one query to D [HHW]. We prove that the levels of the polynomial hierarchy are order-oblivious: P Σ p j :Σ p k = P Σ p k :Σ p j. Yet, we also show that these ordered query classes form new levels in the polynomial hierarchy unless the polynomial hierarchy collapses. We prove that all leaf language classes [...] -and thus essentially all standard complexity classes [...] -inherit all order-obliviousness results that hold for P. 1 Introduction <b>Query</b> <b>order</b> was introduced by Hemaspaandra, Hempel, and Wechsung [HHW] in order to study whether {{the order in which}} information sources are accessed has any effect on the class of problems that can be solved. In the everyday world, the order in which we access information is crucial, and the work of Hemaspaandra, Hempel, and Wechsung [HHW] shows that this [...] ...|$|E
40|$|Support of <b>order</b> in <b>query</b> {{processing}} is {{a crucial}} component in relational database systems, {{not only because the}} output of a query is often required to be sorted in a specific order, but also because employing order properties can significantly reduce the query execution cost. Therefore, finding an effective approach to answer <b>queries</b> over <b>ordered</b> data is important to the efficiency of query processing in relational databases. In this dissertation, an ordered relational database model is proposed, which captures both data tuples of relations and tuple ordering in relations. Based on this conceptual model, <b>ordered</b> relational <b>queries</b> are formally defined in a two-sorted first-order calculus, which serves as a yardstick to evaluate expressive power of other <b>ordered</b> <b>query</b> representations. The primary purpose of this dissertation is to investigate the expressive power of different <b>ordered</b> <b>query</b> representations. Particularly, the completeness problem of ordered relational algebras is studied with respect to the first-order calculus: does there exist an ordered algebra such that any first-order expressible <b>ordered</b> relational <b>query</b> can be expressed by a finite sequence of ordered operations? The significance of studying the completeness problem of ordered relational algebras is in that the completeness of ordered relational algebras leads to the possibility of implementing a finite set of ordered operators to express all first-order expressible <b>ordered</b> <b>queries</b> in relational databases. The dissertation then focuses on the completeness problem of <b>ordered</b> conjunctive <b>queries.</b> This investigation is performed in an incremental manner: first, the <b>ordered</b> conjunctive <b>queries</b> with data-decided <b>order</b> is considered; then, the <b>ordered</b> conjunctive <b>queries</b> with t-decided <b>order</b> is studied; finally, the completeness problem for the general <b>ordered</b> conjunctive <b>queries</b> is explored. The completeness theorem of ordered algebras is proven for all three classes of <b>ordered</b> conjunctive <b>queries.</b> Although this <b>ordered</b> relational database model is only conceptual, and ordered operators are not implemented in this dissertation, we do prove that a complete set of ordered operators exists to retrieve all first <b>order</b> expressible <b>ordered</b> <b>queries</b> in the three classes of <b>ordered</b> conjunctive <b>queries.</b> This research sheds light on the possibility of implementing a complete set of ordered operators in relational databases to solve the performance problem of order-relevant queries...|$|R
40|$|As {{scientific}} instruments and computer simulations produce {{more and more}} data, the task of locating the essential information to gain insight becomes increasingly difficult. FastBit is an efficient software tool to address this challenge. In this article, we present {{a summary of the}} key underlying technologies, namely bitmap compression, encoding, and binning. Together these techniques enable FastBit to answer structured (SQL) <b>queries</b> <b>orders</b> of magnitude faster than popular database systems. To illustrate how FastBit is used in applications, we present three examples involving a high-energy physics experiment, a combustion simulation, and an accelerator simulation. In each case, FastBit significantly reduces the response time and enables interactive exploration on terabytes of data. ...|$|R
40|$|Structured Query Language (PROC SQL) is a {{database}} language {{found in the}} Base SAS ® software. It enables access to data stored in SAS data sets or tables using a powerful assortment of statements, clauses, options, functions, and other language features. This paper presents core concepts of this powerful language {{as well as its}} many applications and is intended for SAS users who desire an overview of the capabilities of this exciting procedure. Attendees will explore the construction of simple SQL <b>queries,</b> <b>ordering</b> and grouping data, the application of case logic for data reclassification, the creation and use of views, and the construction of simple inner and outer joins...|$|R
40|$|We {{study the}} {{computational}} power of machines that specify their own acceptance types, and {{we show that}} they accept exactly the languages in R #P m (NP). We study the effect of <b>query</b> <b>order</b> on computational power, and show that P BH j [1]:BH k [1] [...] -the languages computable via a polynomial-time machine given one query to the jth level of the boolean hierarchy followed by one query to the kth level of the boolean hierarchy [...] -equals R p j+ 2 kΓ 1 -tt (NP) if j is even and k is odd, and equals R p j+ 2 k-tt (NP) otherwise. Thus, unless the polynomial hierarchy collapses, it holds that for each 1 j k: P BH j [1]:BH k [1] = P BH k [1]:BH j [1] () (j = k) (j is even k = j + 1). We extend our analysis to apply to more general query classes. 1 Introduction This paper studies two related topics: the power of self-specifying acceptance types {{and the importance of}} <b>query</b> <b>order.</b> By acceptance type, we mean the set of numbers of accepting paths that cause a machine to accept. Many co [...] ...|$|E
40|$|The growing {{access to}} {{large amounts of}} text data opens more {{opportunities}} in information processing. Given a list of complex questions {{and a set of}} relevant documents, the task of producing an informative and coherent summary of those documents in response to the questions has attracted {{a great deal of attention}} recently. However, the problem of organizing information for summarization so that the generated summary is coherent has received relatively little attention. Several approaches have been proposed for sentence ordering in single-document and generic multiple-document summarization, but no single method has been found to address sentence ordering in query-based summarization. In this thesis, we propose and implement an algorithm that combines constraints from <b>query</b> <b>order</b> and topical relatedness in human produced summaries of multiple documents in response to multiple questions. To test the effectiveness of the constraints, we construct a new query-based corpus from the human produced summaries for the Document Understanding Conference(DUC) 2006 evaluation. We then conduct experiments, using an automatic evaluation method based on Kendall 2 ̆ 7 s Tau, to evaluate and compare the effectiveness of our approaches to others. Our results show that both <b>query</b> <b>order</b> and topical relatedness improve the ordering performance when compared to a baseline method, and a combination of these two constraints achieves even better results...|$|E
40|$|We {{study the}} effect of <b>query</b> <b>order</b> on {{computational}} power, and show that -the languages computable via a polynomial-time machine given one query to the jth level of the boolean hierarchy followed by one query to the kth level of the boolean hierarchy-equals j+ 2 k- 1 if j is even and k is odd, and equals j+ 2 k otherwise. Thus, unless the polynomial hierarchy collapses, it holds that for each 1 ≤ j ≤ k: = (j=k) (jis even k=j+ 1). We extend our analysis to apply to more general query classes. Comment: 18 pages, 1 figure (earlier version appears as UR-CS-TR- 95 - 596...|$|E
40|$|Abstract. As {{scientific}} instruments and computer simulations produce {{more and more}} data, the task of locating the essential information to gain insight becomes increasingly difficult. FastBit is an efficient software tool to address this challenge. In this article, we present {{a summary of the}} key techniques, namely bitmap compression, encoding and binning. The advances in these techniques have led to a search tool that can answer structured (SQL) <b>queries</b> <b>orders</b> of magnitude faster than popular database systems. To illustrate how FastBit is used in applications, we present three examples involving a high-energy physics experiment, a combustion simulation, and an accelerator simulation. In each case, FastBit significantly reduces the response time and enables interactive exploration on terabytes of data. 1...|$|R
30|$|Consequently, {{we propose}} {{the use of}} a VPL for formulating BIM <b>queries</b> in <b>order</b> to {{overcome}} the low intuitiveness of existing query languages and make formal query functionalities accessible to the end users. In the following sections, the methodical principles of VP are discussed.|$|R
40|$|International audienceTo combine and <b>query</b> <b>ordered</b> {{data from}} {{multiple}} sources, {{one needs to}} handle uncertainty about the possible orderings. Examples of such “order-incomplete” data include integrated event sequences such as log entries; lists of properties (e. g., hotels and restaurants) ranked by an unknown function reflecting relevance or customer ratings; and documents edited concurrently with an uncertain order on edits. This paper introduces a query language for order-incomplete data, based on the positive relational algebra with order-aware accumulation. We use partial orders to represent order-incomplete data, and study possible and certain answers for queries in this context. We show that these problems are respectively NP-complete and coNP-complete, but identify many tractable cases depending on the query operators or input partial orders...|$|R
40|$|ABSTRACT—People are {{impatient}} and discount future rewards more {{when they are}} asked to delay consumption than when they are offered the chance to accelerate consumption. The three experiments reported here provide a process-level account for this asymmetry, with implications for designing decision environments that promote less impulsivity. In Experiment 1, a thought-listing procedure showed that people decompose discount valuation into two queries. Whether one considers delayed or accelerated receipt of a gift certificate influences the order in which memory is queried to support immediate versus delayed consumption, and the order of queries affects the relative number of patient versus impatient thoughts. Relative frequency and clustering of impatient thoughts predicts discounting and mediates the discounting asymmetry. Experiment 2 implicated <b>query</b> <b>order</b> causally: When participants listed reasons for immediate versus delayed consumption in the order used spontaneously in acceleration and delay decisions, the discounting asymmetry was replicated; reversing the order in which reasons were listed eliminated the asymmetry. The results of Experiment 3, which used an implicit-memory task, support a memoryinterference account of the effect of <b>query</b> <b>order.</b> People’s willingness to trade immediate pleasure for later benefits determines whether they save adequately for retirement, imbibe too much alcohol, or reduce energy consumption to curb climate risks for future generations (Kirby & Herrnstein, 1995; Mischel, Grusec, & Masters, 1969; Weber, 2004, 2006). Choices between alternatives that differ in size and time to delivery (e. g., a $ 50 gift certificate today or a $ 100 gift certificate a year from today) are modeled by the discounted-utility model (Samuelson, Address correspondence to Elke U. Weber, Columbia University...|$|E
40|$|Keeping views fresh by {{maintaining}} the consistency between materialized views and their base {{data in the}} presence of base updates is a critical prob-lem for many applications, including data warehousing and data integra-tion. While heavily studied for traditional databases, the maintenance of XML views remains largely unexplored. Maintaining XML views is com-plex due to the richness of the XML data model and the powerful capabili-ties of XML query languages, such as XQuery. This dissertation proposes a comprehensive solution for the general problem of maintaining materialized XQuery views. Our solution is the first to enable the maintenance of a large class of XQuery views including XPath expressions, FLWOR expressions, and Element Constructors. These views may contain arbitrary result construction and arbitrary grouping and join operations. Our solution also supports the unique order requirements of XQuery including source document order and <b>query</b> <b>order.</b> Th...|$|E
40|$|This paper {{presents}} an enhanced vector space model, Multi-Term Adjacency Keyword-Order Model, {{to improve the}} relevancy of search results, specifically document search. Our model {{is based on the}} concept of keyword grouping. The keyword-order relationship in the adjacency terms is taken into consideration in measuring a term's weight. Assigning more weights to adjacency terms in a <b>query</b> <b>order</b> results in the document vector being moved closer to the query vector, and hence increases the relevancy between the two vectors and thus eventually results in documents with better relevancy being retrieved. The performance of our model is measured based on precision metrics against the performance of a classic vector space model and the performance of a Multi-Term Vector Space Model. Results show that our model performs better in retrieving more relevant results based on a particular search query compared to both the other models...|$|E
40|$|We {{consider}} relational databases organized over an ordered domain {{with some}} additional relations [...] -a typical {{example is the}} ordered domain of rational numbers together with the ternary relation + of addition. In {{the focus of our}} study are the first <b>order</b> <b>queries</b> that are invariant under order-preserving "permutations" [...] -such queries are called (order-) generic. We show that for an arbitrary ordered divisible Abelian group order-generic queries fail to express more than pure <b>order</b> <b>queries,</b> and that, moreover, the generic queries can be effectively translated into pure <b>order</b> <b>queries.</b> For example, every order-generic query over rational numbers with + can be effectively rewritten without +. An important difference of this paper from a recent series of related pape [...] ...|$|R
30|$|Dynamically {{evaluating}} protected <b>queries</b> in <b>order</b> {{to measure}} {{their level of}} protection over time represents an interesting research agenda for future works. For instance, thanks to this dynamic assessment, {{it will be possible}} to adapt the queries protection before sending them, and to reinforce the user awareness.|$|R
50|$|Vision {{is started}} by {{clicking}} its icon. The main {{goal of the}} team {{was to create a}} fast and elegant IRC to make it easy to chat, discuss and solve <b>queries.</b> In <b>order</b> to do this, they found the design had to be simple and easy-to-use.|$|R
40|$|When {{asked to}} delay consumption, people are {{impatient}} and discount future rewards more than when offered {{the chance to}} accelerate consumption. Three experiments provide a process-level account for this asymmetry, with implications {{for the design of}} decision environments that promote less impulsivity. In Experiment 1, a thought-listing procedure shows that people decompose discount valuation into two queries. Considering delayed vs. accelerated receipt of a gift-certificate influences the order in which memory is queried to support immediate vs. delayed consumption, which affects the number of patient vs. impatient thoughts. Relative frequency and clustering of impatient thoughts predicts discounting and mediates the discounting asymmetry. Experiment 2 implicates query-order causally: Listing reasons for immediate vs. delayed consumption in the orders people use spontaneously in acceleration and delay decisions replicates the discounting asymmetry; reversing this order eliminates it. Experiment 3 supports a memory-interference account of the effect of <b>query</b> <b>order,</b> using an implicit-memory task...|$|E
40|$|Voters prefer {{political}} {{candidates who are}} currently in office (incumbents) over new candidates (challengers). Using the premise of query theory (Johnson, Häubl & Keinan, 2007), we clarify the underlying cognitive mechanisms by asking whether memory retrieval sequences affect political decision making. Consistent with predictions, Experiment 1 (N = 256) replicated the incumbency advantage and showed that participants tended to first query information about the incumbent. Experiment 2 (N = 427) showed that experimentally manipulating participants’ <b>query</b> <b>order</b> altered {{the strength of the}} incumbency advantage. Experiment 3 (N = 713) replicated Experiment 1 and, in additional experimental conditions, showed that the effects of incumbency can be overridden by more valid cues, like the candidates’ ideology. Participants queried information about ideologically similar candidates earlier and also preferred these ideologically similar candidates. This is initial evidence for a cognitive, memory-retrieval process underling the incumbency advantage and political decision making...|$|E
40|$|The e ect of <b>query</b> <b>order</b> on NP-completeness is investigated. A {{sequence}} ~ D = (D 1 �::: �Dk) {{of decision}} problems is de ned to be sequentially complete for NP if each Di 2 NP and every problem in NP can {{be decided in}} polynomial time with one query to each ofD 1 �::: �Dk in this order. It is shown that, if NP contains a language that is p-generic {{in the sense of}} Ambos-Spies, Fleischhack, and Huwig [3], then for every integer k 2, there is a sequence ~ D =(D 1 �::: �Dk) suchthat ~ D is sequentially complete for NP, but no nontrivial permutation (Di 1 �::: �Dik) of ~ D is sequentially complete for NP. It follows that such a sequence ~ D exists if there is any strongly positive, p-computable probability measure such that p(NP) 6 = 0. ...|$|E
40|$|This paper {{reports on}} our {{proof-of-concept}} interactive visualization dashboard to support general practitioners (GPs) explore patient follow-up in their practice. The dashboard enables GPs to create visual <b>queries</b> in <b>order</b> to filter patients. Using the dashboard, GPs themselves can verify their practice with official quality indicators. status: publishe...|$|R
40|$|This article {{proposes a}} cache pattern with multi-queries and {{describes}} the multi-query optimization with scheduling, caching and pipelining. A set of cache patterns {{is derived from}} a set of class of multi-queries that are loaded into the cache. Each cache pattern represents a unique equivalence class in the set of patterns. The multi-query optimization with scheduling, caching and pipelining provides efficient heuristics, for a good <b>queries</b> <b>ordering</b> using a single invocation on the entire batch of queries. Multi-query optimization chooses the results of sub-expression that should be admitted to or discarded from cache, when it executes queries. We introduce the heuristic of pair queries and define the equivalence class of multi-queries from cache pattern. We show that the union of all equivalence classes of queries from the cache patterns is the set of cache patterns...|$|R
50|$|Commissioner Lee Hamilton <b>queried</b> if the <b>order</b> was {{to shoot}} down the plane, to which Mineta replied {{that he did not}} know that specifically.|$|R
