5254|2737|Public
5|$|The {{right-hand}} {{side of the}} above equation is the sure information, i.e. information which can be certainly extracted from the database regardless of what values are used to replace Nulls in the database. In the example we considered above, it's {{easy to see that}} the intersection of all possible models (i.e. the sure information) of the query selecting WHERE Age = 22 is actually empty because, for instance, the (unlifted) query returns no rows for the relation EmpH37. More generally, it was shown by Imielinski and Lipski that Codd tables are a weak representation system if the <b>query</b> <b>language</b> is restricted to projections, selections (and renaming of columns). However, as soon as we add either joins or unions to the <b>query</b> <b>language,</b> even this weak property is lost, as evidenced in the next section.|$|E
25|$|XQuery (XML Query) is an XML <b>query</b> <b>language</b> {{strongly}} {{rooted in}} XPath and XML Schema. It provides methods to access, manipulate and return XML, and is mainly {{conceived as a}} <b>query</b> <b>language</b> for XML databases.|$|E
25|$|Unlike {{relational}} databases, {{which had}} SQL {{as the standard}} <b>query</b> <b>language,</b> and widespread APIs such as ODBC, JDBC and OLEDB, {{there was no such}} unification in the OLAP world for a long time. The first real standard API was OLE DB for OLAP specification from Microsoft which appeared in 1997 and introduced the MDX <b>query</b> <b>language.</b> Several OLAP vendors – both server and client – adopted it. In 2001 Microsoft and Hyperion announced the XML for Analysis specification, which was endorsed by most of the OLAP vendors. Since this also used MDX as a <b>query</b> <b>language,</b> MDX became the de facto standard.|$|E
50|$|Similar {{considerations}} {{apply for}} <b>query</b> <b>languages</b> on {{other types of}} data, e.g. XML <b>query</b> <b>languages</b> such as XQuery.|$|R
40|$|This {{article is}} firstly an {{introduction}} into <b>query</b> <b>languages</b> for the Semantic Web, secondly an in-depth {{comparison of the}} languages introduced. Only RDF <b>query</b> <b>languages</b> are considered because, as of the writing of this paper, <b>query</b> <b>languages</b> for other Semantic Web data modeling formalisms, especially OWL, are still an open research issue, and {{only a very small}} number of, furthermore incomplete, proposals for querying Semantic Web data modeled after other formalisms than RDF exist. The limitation to a few RDF <b>query</b> <b>languages</b> is motivated both by the objective of an in-depth comparison of the languages addressed and by space limitations. During the three years before the writing of this article, more than three dozen proposals for RDF <b>query</b> <b>languages</b> have been published! Not only such a large number, but also the often immature nature of the proposals makes the focus on few, but representative languages a necessary condition for a non-trivial comparison. For this article, the following RDF <b>query</b> <b>languages</b> have been, admittedl...|$|R
40|$|This short paper {{discusses}} {{the need to}} include into RDF <b>query</b> <b>languages</b> the ability to directly query graph properties from RDF data. We study the support that current RDF <b>query</b> <b>languages</b> give to these features, to conclude that they are currently not supported. We propose a set of basic graph properties that should be added to RDF <b>query</b> <b>languages</b> and provide evidence for this view...|$|R
25|$|The {{predominant}} <b>query</b> <b>language</b> for RDF graphs is SPARQL. SPARQL is an SQL-like language, and {{a recommendation}} of the W3C as of January 15, 2008.|$|E
25|$|Data mining {{specific}} functionality {{is exposed}} via the DMX <b>query</b> <b>language.</b> Analysis Services includes various algorithms—Decision trees, clustering algorithm, Naive Bayes algorithm, time series analysis, sequence clustering algorithm, linear and logistic regression analysis, and neural networks—for use in data mining.|$|E
25|$|Richard Thomas Snodgrass is an American {{computer}} scientist and writer, currently {{employed as a}} professor at the University of Arizona. He {{is best known for his}} work on temporal databases, <b>query</b> <b>language</b> design, query optimization and evaluation, storage structures, database design, and ergalics (the science of computing).|$|E
30|$|Selection and {{filtering}} {{data for}} the user’s needs is a well-understood task in computer science, and various approaches are available. A promising approach is the usage of formal <b>query</b> <b>languages.</b> In this paper, selected common <b>query</b> <b>languages</b> are examined and assessed for processing building model information. Based on the analysis, {{we come to the}} conclusion that textual <b>query</b> <b>languages</b> are too complex to be employed by typical end users in the construction industry such as architects and engineers.|$|R
40|$|We {{investigate}} {{complexity of}} the problem for logic <b>query</b> <b>languages</b> with complex values: check whether a query defines a nonempty set. The problem for recursive <b>query</b> <b>languages</b> with complex values is undecidable, so we study the complexity of nonrecursive queries. By complex values we understand values such as trees, finite sets, and multisets. Due to the well-known correspondence between relational <b>query</b> <b>languages</b> and datalog, our results {{can be considered as}} results about relational <b>query</b> <b>languages</b> with complex values. The paper gives a complete complexity classification of the problem for nonrecursive logic programs over trees depending on the underlying signature, presence of negation, and range restrictedness. We also prove several results about finite sets and multisets...|$|R
40|$|A {{decade of}} {{experience}} with research proposals as well as standardized <b>query</b> <b>languages</b> for the conventional Web and the recent emergence of <b>query</b> <b>languages</b> for the Semantic Web call for a reconsideration of design principles for Web and Semantic Web <b>query</b> <b>languages.</b> This article first argues that {{a new generation of}} versatile Web <b>query</b> <b>languages</b> is needed for solving the challenges posed by the changing Web: We call versatile those <b>query</b> <b>languages</b> able to cope with both Web and Semantic Web data expressed in any (Web or Semantic Web) markup language. This article further suggests that (well-known) referential transparency and (novel) answer-closedness are essential features of versatile <b>query</b> <b>languages.</b> Indeed, they allow queries to be considered like forms and answers like form-fillings {{in the spirit of the}} “query-by-example ” paradigm. This article finally suggests that the decentralized and heterogeneous nature of the Web requires incomplete data specifications (or “incomplete queries”) and incomplete data selections (or “incomplete answers”) : the form-like query can be specified without precise knowledge of the queried data and answers can be restricted to contain only an excerpt of the queried data. 1...|$|R
25|$|Modern {{versions}} of crystallographic databases {{are based on}} the relational database model. Communication with the database usually happens via a dialect of the Structured <b>Query</b> <b>Language</b> (SQL). Web-based databases typically process the search algorithm on the server interpreting supported scripting elements, while desktop-based databases run locally installed and usually precompiled search engines.|$|E
25|$|The TSQL2 Temporal <b>Query</b> <b>Language,</b> The TSQL2 Language Design Committee {{consisted}} of Richard T. Snodgrass (chair), Ilsoo Ahn, Gad Ariav, Don Batory, James Clifford, Curtis E. Dyreson, Ramez Elmasri, Fabio Grandi, Christian S. Jensen, Wolfgang Käfer, Nick Kline, Krishna Kulkarni, T. Y. Cliff Leung, Nikos Lorentzos, John F. Roddick, Arie Segev, Michael D. Soo and Suryanarayana M. Sripada, Kluwer Academic Publishers, 1995, 674+xxiv pages, , QA76.9.D3T4125.|$|E
25|$|Given its {{proximity}} to {{the headquarters of the}} Oracle Corporation, a maker of database software, some have speculated that the airport code of SQL is a humorous reference to this large neighbor; in databases, SQL stands for Structured <b>Query</b> <b>Language.</b> In fact the airport was SQL years before June 16, 1977, the date of incorporation of Software Development Laboratories which became the Oracle corporation.|$|E
30|$|MapReduce (MR) is a {{criterion}} of Big Data processing model with parallel and distributed large datasets. This model knows difficult {{problems related to}} low-level and batch nature of MR that gives rise to an abstraction layer {{on the top of}} MR. Therefore; several High-Level MapReduce <b>Query</b> <b>Languages</b> built on the top of MR provide more abstract <b>query</b> <b>languages</b> and extend the MR programming model. These High-Level MapReduce <b>Query</b> <b>Languages</b> remove the burden of MR programming away from the developers and make a soft migration of existing competences with SQL skills to Big Data. This paper investigates the very used—common High-Level MapReduce <b>Query</b> <b>Languages</b> built directly on the top of MR that translate queries into executable native MR jobs. It evaluates the performance of the four presented High-Level MapReduce Query Languages: JAQL, Hive, Big SQL and Pig, with regards to their insightful perspectives and ease of programming. The baseline metrics reported are increasing input size, scale-out number of nodes and controlling number of reducers. The experimental results study the technical advantages and limitations of each High-Level MapReduce <b>Query</b> <b>Languages.</b> Finally, the paper provides a summary for developers to choose the High-Level MapReduce <b>Query</b> <b>Languages</b> which fulfill their needs and interests.|$|R
40|$|<b>Query</b> <b>languages</b> for graph {{databases}} {{started to}} be investigated some 25 years ago. With much current data, such as linked data on the Web and social network data, being graph-structured, {{there has been a}} recent resurgence in interest in graph <b>query</b> <b>languages.</b> We provide a brief survey of many of the graph <b>query</b> <b>languages</b> that have been proposed, focussing on the core functionality provided in these languages. We also consider issues such as expressive power and the computational complexity of query evaluation. 1...|$|R
40|$|In the {{database}} framework of [Kanellakis et al. 1990] it was argued that constraint <b>query</b> <b>languages</b> should take as input constraint databases and give as output other constraint databases {{that use the}} same type of atomic constraints. This closed-form requirement has been difficult to realize in constraint <b>query</b> <b>languages</b> that contain the negation symbol. This paper describes a general approach to restricting constraint <b>query</b> <b>languages</b> with negation to safe subsets that contain only programs that are evaluable in closed-form on any valid [...] ...|$|R
25|$|Btrieve was modularized {{starting}} with version 6.15 {{and became one}} of two database front-ends that plugged into a standard software interface called the Micro-Kernel Database Engine. The Btrieve front-end supported the Btrieve API and the other front-end was called Scalable SQL, a relational database product based upon the MKDE that used its own variety of Structured <b>Query</b> <b>Language,</b> otherwise known as SQL. After these versions were released (Btrieve 6.15 and ScalableSQL v4) the company was renamed to Pervasive Software prior to their IPO. Shortly thereafter the Btrieve and ScalableSQL products were combined into the products now known and sold as Pervasive.SQL or PSQL. Btrieve continued for a few years while ScalableSQL was quickly dropped. Customers were encouraged to upgrade to Pervasive.SQL which supported both SQL and Btrieve applications.|$|E
500|$|... (The above has to {{hold for}} queries taking {{any number of}} tables as arguments, but the {{restriction}} to one table suffices for this discussion.) Clearly Codd tables do not have this strong property if selections and projections are considered {{as part of the}} <b>query</b> <b>language.</b> For example, all the answers to ...|$|E
500|$|Thus when {{unions are}} added to the <b>query</b> <b>language,</b> Codd tables are not even a weak {{representation}} system of missing information, meaning that queries over them don't even report all sure information. It's important to note here that semantics of UNION on Nulls, which are discussed in a later section, did not even come into play in this query. The [...] "forgetful" [...] nature of the two sub-queries was all that it took to guarantee that some sure information went unreported when the above query was run on the Codd table Emp.|$|E
40|$|The {{integration}} of <b>query</b> <b>languages</b> and programming languages {{is still a}} central problem of database research. In particular, issues {{with respect to the}} impedance mis-match are of interest. In this paper, we introduce features of a newly developed integrated database programming and <b>querying</b> <b>language</b> (i) DBPQL, which unites properties from object-oriented programming <b>languages,</b> <b>query</b> <b>languages</b> and database programming languages. Our main focus is on those integrated language properties that support simul-taneous processing and their implications on other data-base system components. 1...|$|R
50|$|Static {{analysis}} {{techniques for}} software verification {{can be applied}} also in the scenario of <b>query</b> <b>languages.</b> In particular, the *Abstract interpretation framework has been extended {{to the field of}} <b>query</b> <b>languages</b> for relational databases as a way to support sound approximation techniques. The semantics of <b>query</b> <b>languages</b> can be tuned according to suitable abstractions of the concrete domain of data. The abstraction of relational database system has many interesting applications, in particular, for security purposes, such as fine grained access control, watermarking, etc.|$|R
40|$|Recent {{research}} in the area of temporal databases has proposed a number of <b>query</b> <b>languages</b> that vary in their expressive power and the semantics they provide to users. These <b>query</b> <b>languages</b> represent a spectrum of solutions to the tension between clean semantics and efficient evaluation. Often, these <b>query</b> <b>languages</b> are implemented by translating temporal queries into standard relational queries. However, the compiled queries are often quite cumbersome and expensive to execute even using state-ofthe -art relational products. This paper presents an optimization technique that produces more efficient translated SQL queries by taking into account the properties of the encoding used for temporal attributes. For concreteness, this translation technique is presented in the context of SQL/TP; however, these techniques are also applicable to other temporal <b>query</b> <b>languages.</b> ...|$|R
500|$|Null (or NULL) is {{a special}} marker used in Structured <b>Query</b> <b>Language</b> to {{indicate}} that a data value {{does not exist in}} the database. [...] Introduced by the creator of the relational database model, E. F. Codd, SQL Null serves to fulfil the requirement that all true relational database management systems (RDBMS) support a representation of [...] "missing information and inapplicable information". [...] Codd also introduced the use of the lowercase Greek omega (ω) symbol to represent Null in database theory. [...] In SQL, NULL is a reserved word used to identify this marker.|$|E
2500|$|Mondrian OLAP server is an {{open-source}} OLAP server {{written in}} Java. It supports the MDX <b>query</b> <b>language,</b> the XML for Analysis and the [...] interface specifications.|$|E
5000|$|CQLF (CODYASYL <b>Query</b> <b>Language,</b> Flat) is a <b>query</b> <b>language</b> for CODASYL-type databases; ...|$|E
50|$|APIs and <b>query</b> <b>languages</b> OLAP servers support.|$|R
50|$|Other {{examples}} of RDF <b>Query</b> <b>languages</b> include RDFDBQL.|$|R
5000|$|Microsoft Analysis Services {{supports}} the following <b>query</b> <b>languages</b> ...|$|R
5000|$|TMQL Topic Map <b>Query</b> <b>Language</b> is a <b>query</b> <b>language</b> for Topic Maps; ...|$|E
5000|$|Molecular <b>Query</b> <b>Language</b> - <b>query</b> <b>language</b> {{allowing}} also numerical properties, e.g. physicochemical {{values or}} distances ...|$|E
50|$|The {{most common}} <b>query</b> <b>language</b> {{used with the}} {{relational}} model is the Structured <b>Query</b> <b>Language</b> (SQL).|$|E
40|$|Temporal Databases 34 3. 2. 2 Relational Database Histories 36 3. 3 Temporal Queries 36 3. 3. 1 Abstract Temporal <b>Query</b> <b>Languages</b> 37 3. 3. 2 Expressive Power 41 3. 3. 3 Space-efficient Encoding of Temporal Databases 44 3. 3. 4 Concrete Temporal <b>Query</b> <b>Languages</b> 46 3. 3. 5 Evaluation of Abstract <b>Query</b> <b>Languages</b> using Compilation 47 3. 3. 6 SQL and Derived Temporal <b>Query</b> <b>Languages</b> 48 3. 4 Temporal Integrity Constraints 53 3. 4. 1 Notions of {{constraint}} satisfaction 53 3. 4. 2 Temporal Integrity Maintenance 54 3. 4. 3 Temporal Constraint Checking 56 3. 5 Multidimensional Time 58 3. 5. 1 Why Multiple Temporal Dimensions? 59 3. 5. 2 Abstract <b>Query</b> <b>Languages</b> for Multi-dimensional Time 59 3. 5. 3 Encoding of Multi-dimensional Temporal Databases 61 3. 6 Beyond First-order Temporal Logic 62 3. 7 Conclusion 65 References 65 4 The Role of Deontic Logic in the Specification of Information Systems 71 J. -J. Ch. Meyer, R. J. Wieringa, and F. P. M. Dignum 4. 1 Introduction: Soft Constraints and Deontic Logic 72 4. 1. 1 Integrity Constrai [...] ...|$|R
40|$|Temporal Databases 4 1. 2. 2 Relational Database Histories 5 1. 3 Temporal Queries 6 1. 3. 1 Abstract Temporal <b>Query</b> <b>Languages</b> 7 1. 3. 2 Expressive Power 11 1. 3. 3 Space-efficient Encoding of Temporal Databases 13 1. 3. 4 Concrete Temporal <b>Query</b> <b>Languages</b> 15 1. 3. 5 Evaluation of Abstract <b>Query</b> <b>Languages</b> using Compilation 16 1. 3. 6 SQL and Derived Temporal <b>Query</b> <b>Languages</b> 18 1. 4 Temporal Integrity Constraints 22 1. 4. 1 Notions of Constraint Satisfaction 22 1. 4. 2 Temporal Integrity Maintenance 23 1. 4. 3 Temporal Constraint Checking 25 1. 5 Multidimensional Time 27 1. 5. 1 Why Multiple Temporal Dimensions? 27 1. 5. 2 Abstract <b>Query</b> <b>Languages</b> for Multi-dimensional Time 28 1. 5. 3 Encoding of Multi-dimensional Temporal Databases 30 1. 6 Beyond First-order Temporal Logic 31 1. 7 Conclusions 33 References 33 Index 39 v 1 TEMPORAL LOGIC IN INFORMATION SYSTEMS Jan Chomicki and David Toman Abstract: Temporal {{logic is}} {{obtained}} by adding temporal connectives to a logic language. Explicit references to time are hid [...] ...|$|R
5000|$|... {{database}} <b>query</b> <b>languages,</b> like SQL {{that have}} UNIX_TIMESTAMP (...) like commands ...|$|R
