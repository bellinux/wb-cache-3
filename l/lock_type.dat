21|136|Public
5000|$|... #Caption: A warded <b>lock</b> <b>type</b> key {{with its}} main parts {{labelled}} ...|$|E
50|$|C++14 adds {{a shared}} timed mutex and a {{companion}} shared <b>lock</b> <b>type.</b>|$|E
5000|$|The {{earliest}} fetters {{found in}} archaeological excavations {{date from the}} prehistoric age and are mostly of the puzzle <b>lock</b> <b>type.</b> Fetters are also referenced in ancient times in the Bible ( [...] ,,) ...|$|E
5000|$|The common {{interactions}} between these <b>lock</b> <b>types</b> {{are defined by}} blocking behavior as follows: ...|$|R
5000|$|Several {{variations}} and refinements {{of these}} major <b>lock</b> <b>types</b> exist, with respective variations of blocking behavior. If a first lock blocks another lock, the two locks are called incompatible; otherwise the locks are compatible. Often, <b>lock</b> <b>types</b> blocking interactions {{are presented in}} the technical literature by a Lock compatibility table. The following is an example with the common, major lock types: ...|$|R
5000|$|Regardless of <b>locking</b> <b>type,</b> {{stepping}} type piezoelectric motors—linear and rotary—use {{the same}} mechanism to create movement: ...|$|R
50|$|A lock is {{a system}} object {{associated}} with a shared resource such as a data item of an elementary type, a row in a database, or a page of memory. In a database, a lock on a database object (a data-access lock) {{may need to be}} acquired by a transaction before accessing the object. Correct use of locks prevents undesired, incorrect or inconsistent operations on shared resources by other concurrent transactions. When a database object with an existing lock acquired by one transaction needs to be accessed by another transaction, the existing lock for the object and the type of the intended access are checked by the system. If the existing <b>lock</b> <b>type</b> does not allow this specific attempted concurrent access type, the transaction attempting access is blocked (according to a predefined agreement/scheme). In practice, a lock on an object does not directly block a transaction's operation upon the object, but rather blocks that transaction from acquiring another lock on the same object, needed to be held/owned by the transaction before performing this operation. Thus, with a locking mechanism, needed operation blocking is controlled by a proper lock blocking scheme, which indicates which <b>lock</b> <b>type</b> blocks which <b>lock</b> <b>type.</b>|$|E
50|$|Locking (e.g., Two-phase locking - 2PL) - Controlling {{access to}} data by locks {{assigned}} to the data. Access of a transaction to a data item (database object) locked by another transaction may be blocked (depending on <b>lock</b> <b>type</b> and access operation type) until lock release.|$|E
50|$|Ball <b>lock</b> <b>type</b> quick {{disconnects}} {{seem to be}} {{the most}} popular way to connect both gas and liquid lines to the Cornelius keg for home brew dispensing. A typical beer line to control foaming has a 3/16th internal diameter giving it a resistance of 2 psi per foot. It is common to serve at pressures between 9 and 11 PSI.|$|E
50|$|Many {{variants}} of SS2PL exist that utilize various <b>lock</b> <b>types</b> with various semantics in different situations, including cases of lock-type change during a transaction. Notable are variants that use Multiple granularity locking.|$|R
50|$|Byte-range <b>locking</b> <b>type</b> is {{determined}} by the dwFlags parameter in the LockFileEx function used to lock a region of a file. The Windows API function LockFile can also be used and acquires an exclusive lock on the region of the file.|$|R
5000|$|There are {{two basic}} {{configurations}} of NEMA plug and socket: straight-blade and locking. Numbers prefixed by L are twist-lock, others are straight blade. <b>Locking</b> <b>type</b> connectors are found mostly in industrial applications and are not common in residential and light commercial use.|$|R
50|$|Two-phase locking is {{the most}} common {{transaction}} concurrency control method in DBMSs, used to provide both serializability and recoverability for correctness. In order to access a database object a transaction first needs to acquire a lock for this object. Depending on the access operation type (e.g., reading or writing an object) and on the <b>lock</b> <b>type,</b> acquiring the lock may be blocked and postponed, if another transaction is holding a lock for that object.|$|E
50|$|A {{lens mount}} {{may be a}} screw-threaded type, a bayonet-type, or a breech-lock (friction <b>lock)</b> <b>type.</b> Modern still camera lens mounts are of the bayonet type, because the bayonet {{mechanism}} precisely aligns mechanical and electrical features between lens and body. Screw-threaded mounts are fragile and do not align the lens in a reliable rotational position, yet types such as the C-mount interface are still widely in use for other applications like video cameras and optical instrumentation.|$|E
50|$|Interchangeable cores can be {{extracted}} from one <b>lock</b> <b>type</b> (bored cylindrical lock, mortise lock, padlock and so forth) and then installed into another without requiring the removal or disassembly of any single component. These units are readily adapted for master keying systems {{and can be}} set up with spare cores and keys for quick replacement when security is compromised, such as when a key is lost or stolen or when a personnel change takes place. Extracted cores can then be recombinated without urgency and placed back into maintenance storage for future use.|$|E
5000|$|Lock and key systems {{where there}} are many <b>types</b> of <b>locks</b> and many <b>types</b> of keys and every type of key opens {{multiple}} <b>types</b> of <b>locks.</b> Not only {{do you need to}} know the types of the objects involved, but the subset of [...] "information about a particular key that are relevant to seeing if a particular key opens a particular lock" [...] is different between different <b>lock</b> <b>types.</b>|$|R
50|$|Two <b>types</b> of <b>locks</b> are {{utilized}} by the basic protocol: Shared and Exclusive locks. Refinements {{of the basic}} protocol may utilize more <b>lock</b> <b>types.</b> Using <b>locks</b> that block processes, 2PL {{may be subject to}} deadlocks that result from the mutual blocking of two or more transactions.|$|R
40|$|We present {{optional}} locking as {{a method}} for significantly speeding up distributed locks, and we generalize it to mul-tiple <b>lock</b> <b>types</b> obeying a conflict relation. The generalized version can simulate the message passing paradigm on top of Distributed Shared Memory (DSM) with no more mes-sages than explicit message passing would need. Thus we argue that message passing {{can be viewed as}} a true spe-cial case of optional locking. As a consequence, the attrac-tiveness of DSM programming models should increase sig-nificantly due to well-recognized advantages such as sim-plicity and reduced software engineering cost; mixtures of both message passing and shared data access patterns can be treated uniformly. Measurements and simulations based on database benchmarks indicate a substantial performance improvement of optional locking over conventional locking even in presence of multiple <b>lock</b> <b>types...</b>|$|R
50|$|The {{automatic}} center buffer coupler of AAR tight <b>lock</b> <b>type</b> at {{the coach}} end has a support frame which provides an anti-climbing protection. The coupler can be opened {{from the side}} by a lever. The design allows the use of screw coupler instead of center buffer coupler. Therefore a fixing plate for buffers is also provided. The inter-vehicle coupler for the supply of the 750 V from the generator car is located below the under-frame. Due to the moving situation 4 brake hoses are to be used at the coach end which are brought to two hoses behind the coupler.|$|E
5000|$|In {{databases}} {{an index}} is a data structure, {{part of the}} database, used by a database system to effectively navigate access to user data. Index data are system data distinct from user data, and consist primarily of pointers. Changes in a database (by insert, delete, or modify operations), may require indexes to be updated to maintain accurate user data accesses. Index locking is a technique used to maintain index integrity. A portion of an index is locked during a database transaction when this portion is being accessed by the transaction {{as a result of}} attempt to access related user data. Additionally, special database system transactions (not user-invoked transactions) may be invoked to maintain and modify an index, as part of a system's self-maintenance activities. When a portion of an index is locked by a transaction, other transactions may be blocked from accessing this index portion (blocked from modifying, and even from reading it, depending on <b>lock</b> <b>type</b> and needed operation). Index Locking Protocol guarantees that Phantom Phenomenon won't occur. Index locking protocol states: ...|$|E
5000|$|Strong strict two {{phase locking}} (SS2PL) {{is a common}} {{mechanism}} utilized in database systems since their early days in the 1970s (the [...] "SS" [...] in the name SS2PL is newer though) to enforce both conflict serializability and strictness (a special case of recoverability which allows effective database recovery from failure) of a schedule. In this mechanism each datum is locked by a transaction before accessing it (any read or write operation): The item is marked by, associated with a lock of a certain type, depending on operation (and the specific implementation; various models with different lock types exist; in some models locks may change type during the transaction's life). As a result, access by another transaction may be blocked, typically upon a conflict (the lock delays or completely prevents the conflict from being materialized and {{be reflected in the}} precedence graph by blocking the conflicting operation), depending on <b>lock</b> <b>type</b> and the other transaction's access operation type. Employing an SS2PL mechanism means that all locks on data on behalf of a transaction are released only after the transaction has ended (either committed or aborted).|$|E
50|$|Hand Throttle: <b>Locking</b> and {{non-locking}} <b>types</b> {{are available}} to allow control of engine rpm from dashboard. <b>Locking</b> <b>type</b> is especially useful when the trucks engine is used to drive an accessory unit with high power demands, such as a winch or compressor. Throttle can be set part-way open while the driver is outside of the cab doing other jobs. Available on all models with the 4.9L and 5.8L engines. Not available with speed control or engine usage indicator.|$|R
40|$|Abstract—Motivated by {{the recent}} {{inclusion}} of spin locks into the Autosar 4. 0 real-time OS standard, the worst-case blocking in spin locks is analyzed using mixed-integer linear programming. Four queue orders and two preemption models are studied: (i) FIFO-ordered spin locks, (ii) unordered spin locks, (iii) priorityordered spin locks with unordered tie-breaking, and (iv) priorityordered spin locks with FIFO-ordered tie-breaking, each analyzed assuming both preemptable and non-preemptable spinning. Of the eight <b>lock</b> <b>types,</b> seven have not been analyzed in prior work. Concerning the sole exception (non-preemptable FIFO spin locks), the new analysis is more accurate than prior approaches (since no critical section is {{accounted for more than}} once) and shown to be asymptotically less pessimistic. The eight <b>lock</b> <b>types</b> are empirically compared with schedulability experiments, and concrete suggestions for an improved Autosar spin lock API are derived. I...|$|R
50|$|Most NEMA {{connectors}} {{are named}} following a simple alphanumeric code consisting of: a numeral preceding a hyphen, a numeral following the hyphen, and letters {{at the beginning}} and end of the code to indicate whether the connector is a <b>locking</b> <b>type</b> and whether it is a plug (male connector) or the corresponding receptacle (female connector).|$|R
40|$|This paper {{initially}} {{presents a}} brief but fairly exhaustive survey of solutions to the concur-rency control problem for B-trees. We then propose a new solution, which is character-ized {{by the use of}} variable-length indices, the employment of a single <b>lock</b> <b>type</b> for the usual access operations and preemptive splits as well as delayed catenations and subdivisions. We also introduce a new compaction algorithm and its concurrent execution, using a new <b>lock</b> <b>type.</b> ...|$|E
40|$|Nagaragawa Estuary Barrage {{has several}} type fishways, {{which are the}} fishladders with guide flow, the <b>lock</b> <b>type</b> fishway and the brook type fishway, etc. The fishways account for 12 % of the total width of the river at the barrage. The fishladders with guide flows were {{improved}} on the original type, for example the top of fishladder shapes. In springs of 1994 and 1995, surveys were conducted to confirm the state of fishways and fishes travelling up the fishways...|$|E
40|$|For a field F of {{characteristic}} {{zero and}} an additive subgroup G of F, a Lie algebra B(G) of <b>lock</b> <b>type</b> is defined with basis {L_a,i,c|a ∈ G, i>- 2 } and relations [L_a,i,L_b,j]=((i+ 1) b-(j+ 1) a) L_a+b,i+j+a_̣a,-b_̣i+j,- 2 c, [c,L_a,i]= 0. Given a total order ≻ on G compatible with its group structure, and any Λ∈ B(G) _ 0 ^*, a Verma B(G) -module M(Λ,≻) is defined, and the irreducibility of M(Λ,≻) is completely determined. Furthermore, it is proved that an irreducible highest weight B(Z) -module is quasifinite if {{and only if}} it is a proper quotient of a Verma module. Comment: LaTeX, 13 page...|$|E
40|$|Abstract—Motivated by the {{widespread}} use of spin locks in embedded multiprocessor real-time systems, the worst-case block-ing in spin locks is analyzed using mixed-integer linear program-ming. Four queue orders and two preemption models are studied: (i) FIFO-ordered spin locks, (ii) unordered spin locks, (iii) priority-ordered spin locks with unordered tie-breaking, and (iv) priority-ordered spin locks with FIFO-ordered tie-breaking, each analyzed assuming both preemptable and non-preemptable spinning. Of the eight <b>lock</b> <b>types,</b> seven have not been analyzed in prior work. Concerning the sole exception (non-preemptable FIFO spin locks), the new analysis is asymptotically less pessimistic and typically much more accurate since no critical section is accounted for more than once. The eight <b>lock</b> <b>types</b> are empirically compared in schedulability experiments. While the presented analysis is generic in nature and applicable to real-time systems in general, it is specifically motivated by the recent inclusion of spin locks into the AUTOSAR standard, and four concrete suggestions for an improved AUTOSAR spin lock API are derived from the results. I...|$|R
40|$|This report extends our {{behavioral}} {{type and}} effect system for detecting dealocks in [8] by polymorphism and formalizing type inference (wrt. the <b>lock</b> <b>types.</b> Our inference is defined {{for a simple}} concurrent, first-order language. From the inferred effects, after suitable abstractions to keep the state space finite, we either obtain the verdict that the program will not deadlock, or that it may deadlock. We show soundness and completeness of the type inference...|$|R
5000|$|Unlike other friction-based LSD {{designs that}} combine a common spider gear [...] "open" [...] {{differential}} {{in combination with}} friction materials that inhibit differentiation, the torque sensing design is a unique type of differential, with torque bias inherent to its design, not as an add-on. Torque bias is only applied when needed, and does not inhibit differentiation. The result is a true differential that does not bind up like LSD and <b>locking</b> <b>types,</b> but still gives increased power delivery under many road conditions.|$|R
40|$|The Logical-Logical Framework LLF is an {{extension}} of the Harper-Honsell-Plotkin’s Edinburgh Logical Framework LF with logical predicates. This is done by defining <b>lock</b> <b>type</b> constructors, which are a sort of ⋄ modality constructors, releasing their argument under the con- dition that a possibly external predicate is satisfied on an appropriate typed judgement. Lock types are defined using the standard pattern of Constructive Type Theory, i. e. via introduction and elimination rules. Using LLF, one can factor out the complexity of encoding specific fea- tures of logical systems which are awkward in LF, e. g. side-conditions in the application of rules in Modal Logics, or pre- and post-conditions in programming languages and logics. Once these conditions have been factored out, their verification can be delegated to an external proof en- gine, in the style of Poincar ́e Principle. We investigate and characterize the metatheoretical properties of the calculus underpinning LLF, such as strong normalization, confluence, subject reduction, and decidability...|$|E
40|$|AbstractConcurrent {{object-oriented}} systems must {{prevent the}} interference that may arise when multiple threads simultaneously access shared components. We present a simple approach for implementing flexible locking strategies in an object-oriented system, {{in which the}} components themselves may be composite objects. We express exclusion requirements as sets of conflict pairs on component interfaces. Given knowledge of the dependency between the interface of a composite object and its internal components, we show how external exclusion requirements can be calculated from internal requirements, and further, how any potential concurrent activity outside an object can be projected into potential concurrency for the internal components. With our approach we can defer the distribution of locks in the system until deployment: the placement of locks and choice of <b>lock</b> <b>type</b> for a component can depend on its operating environment. A Galois connection between the outward mapping of exclusion requirements, and the inward mapping of potential concurrency, limits how many locks are worth considering. In this paper we only deal with exclusion control, including mutexes, read–write locks and read–write sets, and do not cover state-dependent locking or transaction-based approaches...|$|E
40|$|Dynamic {{information}} flow policies, such as declassification, {{are essential for}} practically useful {{information flow}} control systems. However, most systems proposed to date that handle dynamic information flow policies suffer from a common drawback. They build on semantic models of security which are inherently flow insensitive, which means that many simple intuitively secure programs will be considered insecure. In this paper we address this problem {{in the context of}} a particular system, flow locks. We provide a new flow sensitive semantics for flow locks based on a knowledge-style definition (following Askarov and Sabelfeld), in which the knowledge gained by an actor observing a program run is constrained according to the flow locks which are open at the time each observation is made. We demonstrate the applicability of the definition in a soundness proof for a simple flow <b>lock</b> <b>type</b> system. We also show how other systems can be encoded using flow locks, as an easy means to provide these systems with flow sensitive semantics. Categories and Subject Descriptors F. 3. 2 [Logics an...|$|E
50|$|One drive {{technique}} uses piezoelectric ceramics {{to push a}} stator. These piezoelectric motors use {{three groups}} of crystals—two locking, and one motive that permanently connects to either the motor's casing or stator (not both). The motive group, sandwiched between the other two, provides the motion. These piezoelectric motors are fundamentally stepping motors, with each step comprising either two or three actions, based on the <b>locking</b> <b>type.</b> These motors are also known as inchworm motors Another mechanism uses surface acoustic waves (SAW) to generate linear or rotational motion.|$|R
40|$|Abstract. Concurrency {{control is}} {{essential}} to the correct functioning of a database due to the need for correct, reproducible results. For this reason, and because concurrency control is a well-formulated problem, there has developed an enormous body of literature studying the performance of concurrency control algorithms. Most of this literature uses either analytic modeling or random number-driven simulation, and explicitly or implicitly makes certain assumptions about the behavior of transactions and the patterns by which they set and unset locks. Because of the difficulty of collecting suitable measurements, there have been only a few studies which use trace-driven simulation, and still less study directed toward the characterization of concurrency control behavior of real workloads. In this paper, we present a study of three database workloads, all taken from IBM DB 2 relational database systems running commercial applications in a production environment. This study considers topics such as frequency of locking and unlocking, deadlock and blocking, duration of <b>locks,</b> <b>types</b> of <b>locks,</b> correlations between applications of <b>lock</b> <b>types,</b> two-phase versus non-two-phase locking, when locks are held and released, etc. In each case, we evaluate the behavior of the workload relative to the assumptions commonly made in the research literature and discuss the extent to which those assumptions may or may not lead to erroneous conclusions...|$|R
50|$|A snib is a {{manually}} operated catch for the internal <b>locking</b> of Yale <b>type</b> <b>locks.</b> Once operated it prevents key holders {{from using the}} lock externally, or allows the door to be closed without the lock engaging. Colloquial (Scottish/Irish) also the button inside car doors for locking the car.|$|R
