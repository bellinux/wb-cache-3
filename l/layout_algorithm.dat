302|447|Public
25|$|A general {{technique}} {{to improve performance}} is to avoid work. A good example {{is the use of}} a fast path for common cases, improving performance by avoiding unnecessary work. For example, using a simple text <b>layout</b> <b>algorithm</b> for Latin text, only switching to a complex <b>layout</b> <b>algorithm</b> for complex scripts, such as Devanagari. Another important technique is caching, particularly memoization, which avoids redundant computations. Because of the importance of caching, there are often many levels of caching in a system, which can cause problems from memory use, and correctness issues from stale caches.|$|E
500|$|... which {{implements}} a correlation-based graph <b>layout</b> <b>algorithm</b> {{that not}} only facilitates a quick visualization {{of the differences in}} the analyzed microbial communities (in terms of their taxonomic composition), but also provides insights into the inherent inter-microbial interactions occurring therein. Notably, this <b>layout</b> <b>algorithm</b> also enables grouping of the metagenomes based on the probable inter-microbial interaction patterns rather than simply comparing abundance values of various taxonomic groups. In addition, the tool implements several interactive GUI-based functionalities that enable users to perform standard comparative analyses across microbiomes.|$|E
50|$|Graphviz, {{software}} that implements a multilevel force-directed <b>layout</b> <b>algorithm</b> (among many others) {{capable of handling}} very large graphs.|$|E
5000|$|TeX and LaTeX, {{from which}} jsMath {{inherits}} its syntax and <b>layout</b> <b>algorithms</b> ...|$|R
40|$|There {{are several}} graph <b>layout</b> <b>algorithms</b> {{available}} to automatically display a computer network. This study applies seven existing <b>layout</b> <b>algorithms</b> {{to a computer}} network and compares their readability, complexity, and speed. These algorithms generate network diagrams {{that are difficult to}} quickly interpret. To address this issue two improved <b>layout</b> <b>algorithms</b> called the XY Control algorithm and Voting algorithm were developed. The XY algorithm is a new type of force-directed model with an improved gridlike appearance relative to other force-directed algorithms. The Voting algorithm is a directed hierarchal layout technique that provides better space utilization while minimizing edge crossings. Both new algorithms are comparable in speed to the existing algorithms. 2...|$|R
5000|$|Layout {{networks}} in two dimensions. A variety of <b>layout</b> <b>algorithms</b> are available, including cyclic and spring-embedded layouts.|$|R
50|$|A general {{technique}} {{to improve performance}} is to avoid work. A good example {{is the use of}} a fast path for common cases, improving performance by avoiding unnecessary work. For example, using a simple text <b>layout</b> <b>algorithm</b> for Latin text, only switching to a complex <b>layout</b> <b>algorithm</b> for complex scripts, such as Devanagari. Another important technique is caching, particularly memoization, which avoids redundant computations. Because of the importance of caching, there are often many levels of caching in a system, which can cause problems from memory use, and correctness issues from stale caches.|$|E
50|$|In January 2012, the {{so-called}} Page <b>Layout</b> <b>Algorithm</b> Update (also {{known as the}} Top Heavy Update) was released, which targeted websites with too many ads, or too little content above the fold.|$|E
50|$|In {{contrast}} to regular Voronoi treemap algorithms, {{which do not}} provide deterministic layouts, <b>layout</b> <b>algorithm</b> for Voronoi treemaps can be extended to provides {{a high degree of}} layout similarity for varying hierarchies. Similar approaches exist for the tree-map based case.|$|E
40|$|Visualisations {{implemented}} as {{virtual worlds}} can allow users to comprehend large graphs more e#ectively. Good 3 D <b>layout</b> <b>algorithms</b> {{are an important}} element. Angle has been developed as a platform for experimenting with 3 D force-directed <b>layout</b> <b>algorithms.</b> The big-bang modification is proposed {{as a means of}} obtaining e#ciently good 3 D layouts {{for a wide range of}} graphs. Results are presented and compared with those from a conventional approach. ...|$|R
50|$|At some time, it did {{not support}} {{a wide range of}} {{different}} <b>layout</b> <b>algorithms,</b> unlike, for instance, GraphViz or GUESS.|$|R
40|$|Abstract—The CONcrete Visual assistEd Transformation (CONVErT) {{framework}} provides {{facilities to}} generate reusable notations and compose them {{to form a}} wide variety of visual-isations. With an increased number of notations in large scale visualisations, it is crucial to use advanced <b>layout</b> <b>algorithms</b> to improve understandability of such complex visualisations. This showpiece paper demonstrates how advanced <b>layout</b> <b>algorithms</b> can be integrated into the notation specifications of CONVErT to generate layouts of complex visualisations. I...|$|R
5000|$|Development on Servo {{is still}} at an early stage; however, it can already render Wikipedia and GitHub, and {{successfully}} passes the Acid2 test. It features innovations like a parallel <b>layout</b> <b>algorithm</b> and its own CSS3 and HTML5 parser implemented in Rust.|$|E
5000|$|A key goal in {{comparative}} metagenomics {{is to identify}} microbial group(s) which are responsible for conferring specific characteristics to a given environment. However, due to issues in the sequencing technologies artifacts need to be accounted for like in metagenomeSeq. Others have characterized inter-microbial interactions between the resident microbial groups. A GUI-based comparative metagenomic analysis application called Community-Analyzer has been developed by Kuntal et al. [...] which implements a correlation-based graph <b>layout</b> <b>algorithm</b> that not only facilitates a quick visualization {{of the differences in}} the analyzed microbial communities (in terms of their taxonomic composition), but also provides insights into the inherent inter-microbial interactions occurring therein. Notably, this <b>layout</b> <b>algorithm</b> also enables grouping of the metagenomes based on the probable inter-microbial interaction patterns rather than simply comparing abundance values of various taxonomic groups. In addition, the tool implements several interactive GUI-based functionalities that enable users to perform standard comparative analyses across microbiomes.|$|E
5000|$|For authoring, {{there are}} related mind mapping and concept mapping products, such as FreeMind. Typically these {{do not allow}} the end user to change focus from node to node. For display, there is {{analogous}} software for moving node to node, including: Visual Thesaurus from ThinkMap, TuneGlue, Lexipedia, and Prefuse Flare, and the Discovr apps. (The Discovr app, which also uses radial layouts, with a different <b>layout</b> <b>algorithm</b> which is primarily force-based.) ...|$|E
40|$|The {{design of}} {{automatic}} <b>layout</b> <b>algorithms</b> for single graphs {{is a well}} established field, and some recent studies show how these algorithms affect human understanding. By contrast, <b>layout</b> <b>algorithms</b> for graphs that change over time are relatively immature, and few studies exist to evaluate their effectiveness empirically. This paper presents two new dynamic graph <b>layout</b> <b>algorithms</b> and empirical investigations of how effective these algorithms are with respect to human understanding. Central to each algorithm is the "mental map": {{the degree to which}} the layout supports continuous understanding. This work aims to evaluate the importance of the mental map, alongside traditional static graph aesthetics, in answering questions about dynamic graphs. We discover that a simple concept of the mental map is not sufficient for increasing understanding of the graph...|$|R
40|$|TR-COSC 04 / 01 Visualisations {{implemented}} as {{virtual worlds}} can allow users to comprehend large graphs more e ectively. Good 3 D <b>layout</b> <b>algorithms</b> {{are an important}} element. Angle has been devel- oped as a platform for experimenting with 3 D force-directed <b>layout</b> <b>algorithms.</b> The big-bang modi cation is proposed {{as a means of}} obtaining e ciently good 3 D layouts {{for a wide range of}} graphs. Results are presented and compared with those from a conventional approach...|$|R
40|$|Homophily is {{a concept}} in social network {{analysis}} that states that in a network a link is more probable, if the two individuals have a common characteristic. We study the question if an observer can assess homophily {{by looking at the}} node-link diagram of the network. We design an experiment that investigates three different <b>layout</b> <b>algorithms</b> and asks the users to estimate the degree of homophily in the displayed network. One of the <b>layout</b> <b>algorithms</b> is a classical force-directed method, the other two are designed to improve node distinction based on the common characteristic. We study how each of the three <b>layout</b> <b>algorithms</b> helps to get a fair estimate, and whether {{there is a tendency to}} over or underestimate the degree of homophily. The stimuli in our experiments use different network sizes and different proportions of the cluster sizes...|$|R
50|$|The WilmaScope 3D graph {{visualisation}} {{system is}} a Java 3D application that creates real-time 3D animations of dynamic graph (network) structures. It comes {{with a number of}} <b>layout</b> <b>algorithm</b> plugins, and supports the creation of plugins for new layout algorithms. 3D geometries for graph element, glyphs and algorithms for graph generation, and modification are loaded dynamically as plugins. This provides a flexible platform for all manner of graph visualisation applications, and the system has been successfully applied to a number of graph visualisation problems.|$|E
5000|$|... == Operation == The user {{interface}} {{is based on}} radial layouts where a node is connected to 1-6 other nodes. It displays an interactive, graphic map. The user begins by searching or browsing a pre-selected set of recommended items. Tapping causes a node to expand, to display related items. Double-tapping takes the user to a page of content about the artist or app. [...] The interface uses a force-based <b>layout</b> <b>algorithm</b> which causes the new child nodes to pop out of the parent node, repelling nearby nodes, and quickly settle into positions that minimize overlap. The graph algorithm was developed by Tamás Nepusz, a PhD in graph theory who previously worked at Last.fm as a research engineer.|$|E
5000|$|Diagram data is {{normally}} not contained {{with the program}} source, such that the UML tool, {{at least in the}} initial step, has to create some random layout of the graphical symbols of the UML notation or use some automatic <b>layout</b> <b>algorithm</b> to place the symbols {{in a way that the}} user can understand the diagram. For example, the symbols should be placed at such locations on the drawing pane that they don't overlap. Usually, the user of such a functionality of a UML tool has to manually edit those automatically generated diagrams to attain some meaningfulness. It also often doesn't make sense to draw diagrams of the whole program source, as that represents just too much detail to be of interest at the level of the UML diagrams.|$|E
40|$|Abstract: When {{creating}} an editor for a visual language, a challenging task is the layout specification. Many visual languages, e. g., Ecore diagrams or Petri nets, show similar layout characteristics, and hence reuse of layout behavior should be enabled. For that purpose, we introduce {{the concept of}} layout patterns, which en-capsulates certain layout behavior. With the approach, {{it is possible to}} combine different <b>layout</b> <b>algorithms,</b> e. g., standard graph drawing algorithms and constraint-based algorithms. In addition, rule-based <b>layout</b> <b>algorithms</b> may be used that are specifically tailored to the interactive nature of visual language editors...|$|R
40|$|Applying the {{multilevel}} paradigm to energy-based <b>layout</b> <b>algorithms</b> {{can improve}} both {{the quality of}} the resulting drawings as well as the running time of the layout computation. In order to do this, approaches for the different multilevel phases refinement, placement, layout, and optionally scaling and postprocessing need to be implemented. A number of multilevel <b>layout</b> <b>algorithms</b> have been proposed already, which differ in the way these phases are realized. We present an experimental study that investigates the influence of varying combinations with respect to running time and quality criteria...|$|R
40|$|In this article, {{the authors}} explore {{the use of}} graph <b>layout</b> <b>algorithms</b> for {{visualizing}} proximity matrices such as those obtained in cultural domain analysis. Traditionally, multidimensional scaling {{has been used for}} this purpose. The authors compare the two approaches to identify conditions when each approach is effective. As might be expected, they find that multidimensional scaling shines when the data are of low dimensionality and are compatible with the defining characteristics of Euclidean distances, such as symmetry and triangle inequality constraints. However, when one is working with data that do not fit these criteria, graph <b>layout</b> <b>algorithms</b> {{do a better job of}} communicating the structure of the data. In addition, graph <b>layout</b> <b>algorithms</b> lend themselves to interactive use, which can yield a deeper and more accurate understanding of the data. Keywords: multidimensional scaling; visualization; social network analysis; graph layout algorithms; cultural domain analysis; proximity matrices Visualization of proximity matrices is commonly used in cultural domai...|$|R
5000|$|All WPF {{applications}} {{start with}} two threads: one {{for managing the}} UI and another background thread for handling rendering and repainting. Rendering and repainting is managed by WPF itself, without any developer intervention. The UI thread houses the Dispatcher (via an instance of [...] ), which maintains a queue of UI operations {{that need to be}} performed (as a tree of [...] objects), sorted by priority. UI events, including changing a property that affects the layout, and user interaction events raised are queued up in the dispatcher, which invokes the handlers for the events. Microsoft recommends that the event handlers only update the properties to reflect new content for application responsiveness, with the new content being generated or retrieved in a background thread. The render thread picks up a copy of the visual tree and walks the tree calculating which components will be visible and renders them to Direct3D surfaces. The render thread also caches the visual tree, so only changes to the tree need to be communicated, which will result in updating just the changed pixels. WPF supports an extensible layout model. Layout is divided into two phases: Measure; and Arrange. The Measure phase recursively calls all elements and determines the size they will take. In the Arrange phase, the child elements are recursively arranged by their parents, invoking the <b>layout</b> <b>algorithm</b> of the layout module in use.|$|E
40|$|Fas-induced {{apoptosis}} pathway model [1] and ASE cell fate {{simulation model}} [2] {{are used to}} compare the performances of gird layout algorithms, LK-gird <b>layout</b> <b>algorithm,</b> CB-grid <b>layout</b> <b>algorithm,</b> and SCCB-grid <b>layout</b> <b>algorithm.</b> The initial layout of each model is obtained by using Eades initial <b>layout</b> <b>algorithm,</b> and then the above algorithms are applied to the initial layouts. The initial and resulting layouts of each model are shown in Figure 1 and Figure 2. The numbers of edge-edge crossings and node-edge crossings in the initial and resulting layouts of each model are described in Table 1 and Table 2, respectively. As is shown in Figures 1 (b) and 2 (b), nodes are separated to several clusters in the resulting layouts of LK-grid <b>layout</b> <b>algorithm</b> and the layouts look compact. However, theses layouts actually have lots of crossings, and especially the number of node-edge crossings is huge comparing to those of other two grid layout algorithms. As is shown in Figures 1 and 2, the resulting layouts of CB-grid <b>layout</b> <b>algorithm</b> and SCCB-grid <b>layout</b> <b>algorithm</b> have major difference in the number of alignments nodes having the same attribute. These alignments are circled with blue boxes. Table 1 : The numbers of edge-edge crossings and node-edge crossings in layout for Fas-induced apoptosis pathway model...|$|E
40|$|Abstract: Graph {{transformation}} {{is used in}} various different research areas and has been implemented in several tool environments. However, the layout of graph trans-formation sequences is often perceived as not optimal and remains {{to be a difficult}} task. This is partly due to the slightly different requirements for layouting graph transformation sequences compared to standard graph sequences. In this paper, we clearly define these special requirements and present a <b>layout</b> <b>algorithm</b> which ful-fills them. This <b>layout</b> <b>algorithm</b> allows the user to keep track of changes during transformation steps by introducing a concept of node aging and protection of se-nior node positions in the layout. Furthermore, this <b>layout</b> <b>algorithm</b> introduces a concept of layout patterns. We extended the well-known spring embedder <b>layout</b> <b>algorithm</b> by these new concepts and implemented the new algorithm in AGG, an environment for Attributed Graph Grammars. The <b>layout</b> <b>algorithm</b> has been tested with various graph grammars. A brief outlook describes how this <b>layout</b> <b>algorithm</b> can also be used for different kinds of graph sequences, e. g. sequences of succes-sively developing class diagrams...|$|E
5000|$|... yEd can {{automatically}} arrange diagram elements using {{a variety}} of graph <b>layout</b> <b>algorithms,</b> including force-based <b>layout,</b> hierarchical layout (for flowcharts), orthogonal layout (for UML class diagrams), and tree layout (for organization charts).|$|R
40|$|Thesis (Ph. D.) [...] University of Hawaii at Manoa, 1995. Includes bibliographical {{references}} (leaves 134 - 138). Microfiche. xv, 138 leaves, bound ill. 29 cmMost existing automatic layout {{techniques are}} designed to generate layouts that look pleasant to the eye by improving aesthetics of graphs. Aesthetics, however, do not reflect layout requirements derived from semantics, preference or individual situations. It is important for an automatic layout technique to generate customized layouts according to specific requirements given by the user or applications. This thesis investigates how to generate customized layouts using selected <b>layout</b> <b>algorithms.</b> A key to this problem {{is to improve the}} expressive power of existing algorithms and integrate different techniques to deal with various layout requirements. LYCA is a graph tool that uses incremental optimization algorithms to draw directed and undirected graphs. It integrates a constraint solver to process constraints. Compared with other works, LYCA has several distinctive features: The force-directed placement algorithm is improved to generate compact layouts for graphs with large vertices.; A novel usage of the divide-and-conquer approach is introduced to generated structured layouts.; The constraint solver and the <b>layout</b> <b>algorithms</b> are integrated in a simple and efficient way. In addition, the solver and <b>layout</b> <b>algorithms</b> cooperate to ensure layout quality.; Different interface techniques are used to help the user diagnose layout problems and interact with the <b>layout</b> <b>algorithms</b> directly. Those features provide a tight coupling of the user and the layout tool. Users can generate customized layouts with LYCA easily and flexibly...|$|R
40|$|Textual {{annotations}} {{are important}} elements {{in all but}} the most simple visual interfaces. In order to integrate textual annotations smoothly into the dynamic graphical content of interactive information systems, fast yet high-quality label <b>layout</b> <b>algorithms</b> are required. With the ongoing pervasion of mobile applications these requirements are shifted from workstations to comparatively low-performance mobile devices. Fortunately, ubiquitous network access is also on the advance, so that mobile applications can employ remote layout services on external workstations. This paper presents two novel label <b>layout</b> <b>algorithms</b> for relevancedriven dynamic visualizations in interactive information systems. They are employed to generate adaptive visualizations in a mobile maintenance support scenario...|$|R
3000|$|The <b>layout</b> <b>algorithm</b> is {{outlined}} in Algorithm 1, that is conceptually recursive but implemented iteratively: [...]...|$|E
40|$|This paper {{describes}} a three-dimensional extension of a enclosure+connection layout technique, called EncCon tree. The three-dimensional visualization includes layout and navigation. The <b>layout</b> <b>algorithm</b> directly generalizes the two-dimensional EncCon tree <b>layout</b> <b>algorithm</b> to three-dimensional {{space in which}} nodes {{at the same level}} of the hierarchy are placed onto the same plane. The interactive navigation uses standard three-dimensional viewing techniques which include view transformation, rotation and zoom...|$|E
40|$|Both {{the quality}} of the results of TeX`s formula <b>layout</b> <b>algorithm</b> and the {{complexity}} of its description in the TeXbook are hard to beat. The algorithm is (verbally) described as an imperative program with very complex control flow and complicated manipulations of the data structures representing formulae. In a forthcoming textbook, we describe TeX`s formula <b>layout</b> <b>algorithm</b> as a functional program transforming mlist-terms into box-terms. This transformation is given in this paper...|$|E
50|$|Extensions to {{the core}} system, {{including}} emulation of other window managers and unusual <b>layout</b> <b>algorithms,</b> such as window tiling based on the Fibonacci spiral, have been implemented by the active community and are available as a library.|$|R
40|$|Abstract Background Graph {{drawing is}} an {{integral}} part of many systems biology studies, enabling visual exploration and mining of large-scale biological networks. While a number of <b>layout</b> <b>algorithms</b> are available in popular network analysis platforms, such as Cytoscape, it remains poorly understood how well their solutions reflect the underlying biological processes that give rise to the network connectivity structure. Moreover, visualizations obtained using conventional <b>layout</b> <b>algorithms,</b> such as those based on the force-directed drawing approach, may become uninformative when applied to larger networks with dense or clustered connectivity structure. Methods We implemented a modified layout plug-in, named Multilevel Layout, which applies the conventional <b>layout</b> <b>algorithms</b> within a multilevel optimization framework to better capture the hierarchical modularity of many biological networks. Using a wide variety of real life biological networks, we carried out a systematic evaluation of the method in comparison with other <b>layout</b> <b>algorithms</b> in Cytoscape. Results The multilevel approach provided both biologically relevant and visually pleasant layout solutions in most network types, hence complementing the layout options available in Cytoscape. In particular, it could improve drawing of large-scale networks of yeast genetic interactions and human physical interactions. In more general terms, the biological evaluation framework developed here enables one to assess the layout solutions from any existing or future graph drawing algorithm as well as to optimize their performance for a given network type or structure. Conclusions By making use of the multilevel modular organization when visualizing biological networks, together with the biological evaluation of the layout solutions, one can generate convenient visualizations for many network biology applications. </p...|$|R
50|$|In {{computer}} science, graph transformation, or graph rewriting, {{concerns the}} technique of creating a new graph out of an original graph algorithmically. It has numerous applications, ranging from software engineering (software construction and also software verification) to <b>layout</b> <b>algorithms</b> and picture generation.|$|R
