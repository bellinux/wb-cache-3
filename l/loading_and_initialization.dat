4|10000|Public
50|$|The {{implementation}} of the idiom relies on the initialization phase of execution within the Java Virtual Machine (JVM) as specified by the Java Language Specification (JLS). When the class Something is loaded by the JVM, the class goes through initialization. Since the class {{does not have any}} static variables to initialize, the initialization completes trivially. The static class definition LazyHolder within it is not initialized until the JVM determines that LazyHolder must be executed. The static class LazyHolder is only executed when the static method getInstance is invoked on the class Something, and the first time this happens the JVM will load and initialize the LazyHolder class. The initialization of the LazyHolder class results in static variable INSTANCE being initialized by executing the (private) constructor for the outer class Something. Since the class initialization phase is guaranteed by the JLS to be serial, i.e., non-concurrent, no further synchronization is required in the static getInstance method during <b>loading</b> <b>and</b> <b>initialization.</b> And since the initialization phase writes the static variable INSTANCE in a serial operation, all subsequent concurrent invocations of the getInstance will return the same correctly initialized INSTANCE without incurring any additional synchronization overhead.|$|E
40|$|We {{describe}} a static analysis method on Java bytecode to determine class initialization dependencies. This method {{can be used}} for eager class <b>loading</b> <b>and</b> <b>initialization.</b> It catches many initialization circularities that are missed by the standard lazy implementation. Except for contrived examples, the computed initialization order gives the same results as standard lazy initialization...|$|E
40|$|We discuss an axiomatic {{description}} of a simple abstract machine similar to the Java Virtual Machine (JVM). Our model supports classes, with fields and bytecoded methods, and a representative sampling of JVM bytecodes for basic operations for both data and control. The GETFIELD and PUTFIELD instructions accurately model inheritance, as does the INVOKEVIRTUAL instruction. Our model supports multiple threads, synchronized methods, and monitors. Our current model is inadequate or inaccurate in many respects (e. g., we do not formalize the JVM's finite arithmetic nor do we describe class <b>loading</b> <b>and</b> <b>initialization).</b> But the model is {{a useful tool for}} studying the application of formal reasoning to the JVM and to Java programs. We demonstrate two useful aspects of an operational formal semantics. First, the model is executable: bytecoded methods can be run on the model. Second, the model allows us to prove theorems about those methods or, more generally, about the model. Because the [...] ...|$|E
40|$|Component {{developers}} have limited {{knowledge of how}} their components will be aggregated into applications {{and they can not}} control the deployment and execution environment. This makes the development of predictable component-based software a difficult proposition. Adding services to a software container can help remedy this problem. This paper discusses how commercial container technology can be augmented to support more predictable behavior of component compositions. Our approach consists of augmenting an open source Enterprise JavaBeans (EJB) container and server with assertion capabilities. We discuss how these new capabilities can be used at <b>load</b> <b>and</b> <b>initialization</b> time to verify that a composition meets some policy constraints and at runtime to verify that the composition is maintaining critical properties...|$|R
30|$|When {{processing}} begins, the decoder accesses address zero in {{the boot}} <b>loading</b> ROM <b>and</b> reads <b>initialization</b> instructions. These instructions are mainly used for <b>loading</b> data <b>and</b> instructions from flash memory to the corresponding RAM memory in the system. Upon finishing, the decoder jumps to program memory and starts processing.|$|R
40|$|The {{verification}} of {{the interface between}} the preflight prepare-to-launch and flight program, targeting <b>load,</b> <b>and</b> flight program <b>initialization</b> was described. This is done using the digital command system coupled with a flight program patch and a memory dump command, the 6 D/LVDC simulator, and a program trace through phase 1 initialization...|$|R
40|$|The {{verified}} {{code for}} the SIFT Executive {{is not the}} code that executes on the SIFT system as delivered. The running versions of the SIFT Executive contain optimizations and special code relating to the messy interface to the hardware broadcast interface and to packing of data to conserve space in the store of the BDX 930 processors. The running code was in fact developed prior to and without consideration of any mechanical verification. This was regarded as necessary experimentation with the SIFT hardware and special purpose Pascal compiler. The Pascal code sections cover: {{the selection of a}} schedule from the global executive broadcast, scheduling, dispatching, three way voting, and error reporting actions of the SIFT Executive. Not included in these sections of Pascal code are: the global executive, five way voting, clock synchronization, interactive consistency, low level broadcasting, <b>and</b> program <b>loading,</b> <b>initialization,</b> <b>and</b> schedule construction...|$|R
40|$|For several decades, ions {{have been}} trapped by radio {{frequency}} (RF) and neutral particles by optical fields. We implement the experimental proof-of-principle for trapping an ion in an optical dipole trap. While <b>loading,</b> <b>initialization</b> <b>and</b> final detection are {{performed in a}} RF trap, in between, this RF trap is completely disabled and substituted by the optical trap. The measured lifetime of milliseconds allows for hundreds of oscillations within the optical potential. It is mainly limited by heating due to photon scattering. In future experiments the lifetime may be increased by further detuning the laser and cooling the ion. We demonstrate the prerequisite to merge both trapping techniques in hybrid setups {{to the point of}} trapping ions and atoms in the same optical potential. Comment: 5 pages, 3 figure...|$|R
5000|$|... #Subtitle level 2: Key <b>and</b> <b>Initialization</b> Vector for AES-256 {{encoding}} ...|$|R
5000|$|... #Subtitle level 3: Early career {{beginnings}} <b>and</b> <b>initialization</b> of showbiz career ...|$|R
5000|$|Optional concise {{variable}} declaration <b>and</b> <b>initialization</b> through type inference ( [...] not [...] or [...] ).|$|R
5000|$|They permit lazy {{allocation}} <b>and</b> <b>initialization,</b> whereas global {{variables in}} many languages will always consume resources.|$|R
2500|$|Scene Background Modeling <b>and</b> <b>Initialization</b> (SBMI 2015) Workshop in {{conjunction}} with ICIAP 2015. (For more information: http://sbmi2015.na.icar.cnr.it/) ...|$|R
40|$|Abstract. Energy {{functional}} minimization is {{an increasingly}} popular technique for image segmentation. However, {{it is far}} too commonly applied with hand-tuned parameters <b>and</b> <b>initializations</b> that have only been validated for a few images. Fixing these parameters over a set of images assumes the same parameters are ideal for each image. We highlight the effects of varying the parameters <b>and</b> <b>initialization</b> on segmentation accuracy and propose a framework for attaining improved results using image adaptive parameters <b>and</b> <b>initializations.</b> We provide an analytical definition of optimal weights for functional terms through an examination of segmentation {{in the context of}} image manifolds, where nearby images on the manifold require similar parameters <b>and</b> similar <b>initializations.</b> Our results validate that fixed parameters are insufficient in addressing the variability in real clinical data, that similar images require similar parameters, and demonstrate how these parameters correlate with the image manifold. We present significantly improved segmentations for synthetic images and a set of 470 clinical examples. ...|$|R
5000|$|The FluentQueryBuilder is a propriety [...]NET class {{developed}} {{in order to}} help with the construction <b>and</b> <b>initialization</b> of a Query instance.|$|R
5000|$|... {{where the}} {{optional}} [...] parameter specifies a non-default kind, and the [...] notation delimits {{the type and}} attributes from variable name(s) and their optional initial values, allowing full variable specification <b>and</b> <b>initialization</b> to be typed in one statement (in previous standards, attributes and initializers had to be declared in several statements). While it is not required in above examples (as there are no additional attributes <b>and</b> <b>initialization),</b> most Fortran-90 programmers acquire the habit to use it everywhere.|$|R
50|$|Object {{creation}} can {{be broken}} down into two operations: memory allocation <b>and</b> <b>initialization,</b> where initialization both includes assigning values to object fields and possibly running arbitrary other code. These are implementation-level concepts, roughly analogous to the distinction between declaration <b>and</b> <b>initialization</b> (or definition) of a variable, though these later are language-level distinctions. For an object that is tied to a variable, declaration may be compiled to memory allocation (reserving space for the object), <b>and</b> definition to <b>initialization</b> (assigning values), but declarations may also be for compiler use only (such as name resolution), not directly corresponding to compiled code.|$|R
30|$|Algorithm Algorithm 1 EKF-SLAM {{summarizes}} the main tasks of EKF-SLAM. The algorithm {{is composed of}} two process: Prediction and Correction. The correction process implements three tasks: matching, estimation <b>and</b> <b>initialization.</b>|$|R
30|$|In this section, model setup <b>and</b> <b>initialization</b> is {{discussed}} {{followed by the}} details on the sensitivity analysis of the modeling results {{with respect to the}} effect of pore structure and capillary number.|$|R
5000|$|Since {{transient}} {{analysis is}} dependent on time, it uses different analysis algorithms, control options with different convergence-related issues <b>and</b> different <b>initialization</b> parameters than DC analysis. However, since a transient analysis first performs a DC operating point analysis (unless the UIC option is specified in the [...]TRAN statement), most of the DC analysis algorithms, control options, <b>and</b> <b>initialization</b> <b>and</b> convergence issues apply to transient analysis.|$|R
40|$|In {{this paper}} we discuss feature {{parameterization}} <b>and</b> <b>initialization</b> for bearing-only data obtained from vision sensors. The interest of this work refers to the comparison of the bearing-only data representation <b>and</b> <b>initialization</b> techniques. The behavior of the algorithm is analyzed for different robot motions and depth of the features. The results are evaluated {{in terms of the}} sensitivity to step size and performance to ill conditioned situations. The problem studied refers to robots moving on the plane, sensing the environment and extracting bearing-only information from uncalibrated cameras to recover the position of the landmarks and its own localization. ...|$|R
40|$|We {{analyze the}} reading <b>and</b> <b>initialization</b> of a topological qubit encoded by Majorana fermions in {{one-dimensional}} semiconducting nanowires, weakly coupled {{to a single}} level quantum dot (QD). It is shown that when the Majorana fermions are fused by tuning gate voltage, the topological qubit can be read out directly through the occupation of the QD in an energy window. The initialization of the qubit can also be realized via adjusting the gate voltage on the QD, with the total fermion parity conserved. As a result, both reading <b>and</b> <b>initialization</b> processes can be achieved in an all-electrical way...|$|R
30|$|Test method: The {{effect of}} text size on the {{matching}} time <b>and</b> <b>initialization</b> time is tested under {{the condition that}} the pattern strings are constant and the hit number of times is basically unchanged.|$|R
40|$|Radiosonde {{humidity}} {{measurements are}} fundamentally {{important to a}} variety of applications, including radiative transfer calculations, validation of remote-sensor retrievals, parameterization of cloud processes, <b>and</b> <b>initialization</b> of (or assimilation into) numerical models. Vaisala radiosondes, used b...|$|R
50|$|The gimbals, unless locked, are {{stabilized}} {{with three}} individual motors, keeping footage steady and stabilized without editing after. When not in use, the motors lock automatically, {{and can be}} unlocked manually during set-up <b>and</b> <b>initialization.</b>|$|R
30|$|Test method: The {{effect of}} {{the average length of}} the pattern string on the {{matching}} time <b>and</b> <b>initialization</b> time is tested when the number of pattern strings, the text size, and the number of hit times remain unchanged.|$|R
50|$|The {{standard}} defined two interface levels; {{the physical}} level {{that deals with}} electrical signals, connectors, mechanical and thermal conditions and the logical level that describes the address space, data transfer protocols, cache coherence mechanisms, synchronization primitives, control and status registers, <b>and</b> <b>initialization</b> <b>and</b> error recovery facilities. This structure allows new developments in physical interface technology to be easily adapted without any redesign on the logical level.|$|R
5000|$|... "In {{the second}} function, they are: the {{execution}} of the scripts to switch on/off the wireless interface; the creation <b>and</b> <b>initialization</b> of a new eXosip stack (the C-based SIP stack used by UCT IMS client); and the invocation of a new register phase." ...|$|R
5000|$|... /* Since Point is a {{subclass}} of {{the generic}} Object [...] * class, we already gain generic allocation <b>and</b> <b>initialization</b> * methods, +alloc and -init. For our specific constructors * {{we can make}} these from these methods we have * inherited. */@end @implementation Point ...|$|R
40|$|To {{study the}} {{properties}} of the Java Virtual Machine(JVM) and Java programs, our research group has produced a series of JVM models written in a functional subset of Common Lisp. In this paper, we present our most complete JVM model from this series, namely, M 6, which is derived from a careful study of the J 2 ME KVM[16] implementation. On the one hand, our JVM model is a conventional machine emulator. M 6 models accurately almost all aspects of the KVM implementation, including the dynamic class <b>loading,</b> class <b>initialization</b> <b>and</b> synchronization via monitors. It executes most J 2 ME Java programs that do not use any I/O or floating point operations. Engineers may consider M 6 an implementation of the JVM. It is implemented with around 10 K lines in 20 + modules. On the other hand, M 6 is a novel model that allows for analytical reasoning besides conventional testing. M 6 is written in an applicative (side-effect free) subset of Common Lisp, for which we have given precise meaning in terms of axioms and inference rules. A property of M 6 can be expressed as a formula. Rules of interference can be used analytically to derive properties of M 6 and the Java programs that run on the model, using a mechanical theorem prover. We argu...|$|R
40|$|This paper {{presents}} an algorithm ada_elab which determines {{an order of}} elaboration, free of PROGRAM_ERROR, if link-time, static analysis can determine that there is one. Examples are used to illustrate the occurrence of elaboration errors and the inadequacy of pragma ELABORATE to resolve the problem. The paper closes with descriptions of elaboration and elaboration-related problems that cannot be handled by ada_elab, access before <b>initialization</b> <b>and</b> coding practices that should avoid elaboration <b>and</b> <b>initialization</b> error...|$|R
5000|$|Structure constructors with {{component}} names <b>and</b> default <b>initialization</b> ...|$|R
5000|$|Algorithmic: {{searching for}} global minima {{of the factors}} <b>and</b> factor <b>initialization.</b>|$|R
40|$|This paper {{addresses}} {{the problem of}} tracking human body pose in monocular video including automatic pose <b>initialization</b> <b>and</b> re-initialization after tracking failures caused by partial occlusion or unreliable observations. We proposed a method based on data-driven Markov chain Monte Carlo (DD-MCMC) that uses bottom-up techniques to generate state proposals for pose estimation <b>and</b> <b>initialization.</b> This method allows us to exploit different image cues and consolidate the inferences using a representation known as the proposal maps. We present experimental results with an indoor video sequence. ...|$|R
40|$|The STEP {{concept and}} GP-B share a much heritage. The development, {{verification}} and recent launch <b>and</b> <b>initialization</b> of GP-B can therefore {{act as a}} pathfinder for the shared aspects of STEP. This talk describes the common characteristics of STEP and GP-B and discusses potential applications of GP-B lessons-learned to a stronger flight-heritage based concept for STEP...|$|R
40|$|We study {{implicit}} regularization when optimizing an underdetermined quadratic objective over {{a matrix}} $X$ with gradient descent on a factorization of $X$. We conjecture and provide empirical and theoretical evidence that with small enough step sizes <b>and</b> <b>initialization</b> {{close enough to}} the origin, gradient descent on a full dimensional factorization converges to the minimum nuclear norm solution...|$|R
