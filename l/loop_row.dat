0|19|Public
40|$|A large {{fragment}} of woven linen fabric {{with most of}} one selvedge intact. The opposite edge has been cut. A regular pattern of <b>looped</b> <b>rows</b> alternating with several rows of plain weave creates a thick pile. A decorative band 1. 8 cm wide contains fragments of a dark blue/black wool and weft wrapping.; Dirty, stained and worn. A few interior holes. Several large edge tears. The blue/black wool yarn is so deteriorated it has almost disappeared. Much of the looped pile has disappeared, also...|$|R
2500|$|The {{topology}} of a {{knitted fabric}} is relatively complex. [...] Unlike woven fabrics, where strands usually run straight horizontally and vertically, yarn {{that has been}} knitted follows a looped path along its row, as with the red strand in the diagram at left, in which the <b>loops</b> of one <b>row</b> have all been pulled through the <b>loops</b> of the <b>row</b> below it.|$|R
2500|$|... bodice fastens {{with small}} gold buttons and <b>loops.</b> A double <b>row</b> of <b>loops</b> trims the shoulder, 1560–65.|$|R
50|$|During its widest {{circulation}} period, Chicago Journal {{covered the}} South <b>Loop,</b> Printers <b>Row,</b> Motor Row, Chinatown, New East Side, West Loop Gate, West Loop, Near West Side, Greektown, Little Italy, University Village and Pilsen neighborhoods. It {{was the most}} widely circulated Wednesday Journal city newspaper with circulation of 13,000.|$|R
40|$|By the {{integration}} of electro-conductive properties in the fabric structure can be obtained a flexible textile that does not reduce the quality of comfort, maintenance and wearability of clothing. Each type of yarns has its advantages and disadvantages: metal coated polymer multifilament yarns have a lower resistance to heat than metal multifilament yarns, but they are more flexible. For the experiments are chosen more suitable yarns for knitting with a lower resistance: silver coated multifilament polyamide, stainless steel multifilament yarns and polyester/stainless steel spun yarn. For the tensile experiments were knitted patterns of non-conducting yarn and horizontal <b>loop</b> <b>rows</b> of conducting yarn. Experimental results show different behavior of the knitted conductive yarn by stretching: electric resistance declines {{for most of the}} knitted samples; resistance is lower by samples, where are used only conductive yarns; for creating a knitted heating element are suitable yarns, which do not change electrical properties of knitted fabric by stretching...|$|R
50|$|The stunt pilot Paul Mantz {{had been}} asking for less money than AMPP {{standards}} and had been taking work from union pilots. When Mantz decided to join AMPP {{so that he could}} get more money, AMPP required of him more than the usual challenges. Mantz performed 46 outside <b>loops</b> in a <b>row,</b> setting a world record, and was allowed to join.|$|R
50|$|Knitting creates {{multiple}} {{loops of}} yarn, called stitches, {{in a line}} or tube. Knitting has multiple active stitches on the needle at one time. Knitted fabric consists {{of a number of}} consecutive <b>rows</b> of interlocking <b>loops.</b> As each <b>row</b> progresses, a newly created loop is pulled through one or more loops from the prior row, placed on the gaining needle, and the loops from the prior row are then pulled off the other needle.|$|R
5000|$|Stored {{procedures}} {{may return}} result sets, i.e., {{the results of}} a [...] statement. Such result sets can be processed using cursors, by other stored procedures, by associating a result-set locator, or by applications. Stored procedures may also contain declared variables for processing data and cursors that allow it to <b>loop</b> through multiple <b>rows</b> in a table. Stored-procedure flow-control statements typically include , , , , and [...] statements, and more. Stored procedures can receive variables, return results or modify variables and return them, depending on how and where the variable is declared.|$|R
50|$|In the {{construction}} of the 'Coppergate sock', the work began at the toe and worked in circular <b>rows.</b> <b>Looping</b> continued by the passing of the needle {{through the center of the}} first row and then brought back through the next to last loop of the current row. A heavy, thick fabric was created with great elasticity. No loose ends were visible and are thought to be joined by splicing or having been stitched into the fabric. Shaping was achieved by adding an extra loop or leaving a lower loop out of the sequence. The heel had been turned back on itself several times to create the heel shaping.|$|R
40|$|Fragment of woven wool fabric with brown/gold warp {{and brown}} weft with a hem, several rows of sewing and {{two rows of}} weft-twining. The brown twining is 1 cm from the hem edge. A row of red weft twining is {{parallel}} and approximately 1. 5 cm from the brown twining. The twining <b>loops</b> of both <b>rows</b> pass over three warps. Approximately 4 cm {{from the edge of}} the hem the weft color changes to a brown/red. A small piece of fabric is hanging by three warp yarns and has the same reddish brown weft.; Very dirty, encrusted with mud in places. Very worn. Some parts of the fabric attached by only a few yarns. Most of the sewing stitches are broken. Some edge fraying...|$|R
5000|$|In his memoir, Aguilera {{describes}} his three-point {{entry into the}} electronic dance music world at around 12 years of age in 1985 via 1) listening to DJ mix radio programs at home presented by WBMX radio station; 2) frequenting Chicago's now defunct record stores: Loop Records and Importes Etc. in the city's South <b>Loop</b> and Printer's <b>Row</b> area {{at the time to}} purchase Disco, House music, Hi-NRG, New Wave, and Industrial music in vinyl format; and 3) the favorable associations made when traveling to the Original Maxwell Street Market and watching breakdancers perform to the sounds of Newcleus' [...] "Jam on It" [...] (1984) with his father at his side. The memoir goes on to explain Aguilera's bedroom DJ status as a teen while a member of an all-male teen Latino youth club, the Ultimate Party Crew.|$|R
40|$|Magnetic nano-elements {{made from}} NiFe and Co have been {{investigated}} using magnetic imaging in the transmission electron microscope. Nano-elements like these have possible uses for in-plane patterned media or solid state memory. In both cases the elements {{will need to be}} patterned into closely spaced arrays and magnetostatic interactions between the elements will begin to become significant. Arrays must therefore be designed so that an element's interactions with its neighbors will be small compared to its coercivity. Arrays of NiFe elements 300 nm long, 50 - 100 nm wide, and 26 nm thick, were fabricated by electron beam lithography and lift-off patterning. Their switching behavior and the interactions between them were studied in detail. Magnetization sequences were recorded and hysteresis <b>loops</b> constructed. For <b>rows</b> of NiFe elements with the gap between elements the same as the element width or larger, the interactions turn out to be small, suggesting that denser arrays would be possible...|$|R
40|$|In {{this paper}} we propose an {{algorithm}} {{for the formation of}} matrices of isogeometric Galerkin methods. The algorithm is based on three ideas. The first is that we perform the external <b>loop</b> over the <b>rows</b> of the matrix. The second is that we calculate the row entries by weighted quadrature. The third is that we exploit the (local) tensor product structure of the basis functions. While all ingredients have a fundamental role for computational efficiency, the major conceptual change of paradigm with respect to the standard implementation is the idea of using weighted quadrature: the test function is incorporated in the integration weight while the trial function, the geometry parametrization and the PDEs coefficients form the integrand function. This approach is very effective in reducing the computational cost, while maintaining the optimal order of approximation of the method. Analysis of the cost is confirmed by numerical testing, where we show that, for $p$ large enough, the time required by the floating point operations is less than the time spent in unavoidable memory operations (the sparse matrix allocation and memory write). The proposed algorithm allows significant time saving when assembling isogeometric Galerkin matrices for all the degrees of the test spline space and paves the way for a use of high-degree $k$-refinement in isogeometric analysis...|$|R
5000|$|He tried {{making a}} living demonstrating loops on {{exhibition}} grounds, but soon found that people would not pay to see a stunt they could see easily outside the gates. He retired for a third time, but returned when his manager had an idea that he depicted in a poster: the [...] "Demon of the Sky" [...] against the [...] "Daredevil of the Ground". Beachey was to race his plane against a racing car driven by the popular driver Barney Oldfield. The manager made sure there was a high fence around the exhibition grounds, forcing people to pay {{if they wanted to}} see the race. Beachey's plane was faster than Oldfield's car, but they took turns [...] "winning", and crowds flocked to see their daily competitions. With the money he earned by racing, Beachey designed and built a new plane, the [...] "Little Looper". He had his name painted in three-foot-high letters across the top wing. Soon he was flying multiple loops. Whenever he heard about another pilot setting a record for flying continuous loops, Beachey would promptly break it, flying as many as eighty <b>loops</b> in a <b>row.</b> Beachey and Oldfield toured the country, staging races everywhere they went. In Dayton, Ohio, home of the Wright Brothers, they performed to a crowd of 30,000.|$|R
30|$|The second {{approach}} {{uses the}} CPU for uploading/downloading data to/from the GPU, {{and there is}} only one CUDA kernel that is called by the CPU. The kernel for this purpose is loaded to the GPU, providing the size of a thread block that equals width of an image and the size of a grid that equals height of the image. An array of shared memory is then allocated dynamically, based {{on the size of the}} thread block. Inside the CUDA kernel, before doing any computation, images are loaded from the global GPU memory to the shared memory. It is done by reading individual pixels from the global memory and assigning them to the array of the shared memory. The procedure is followed by the synchronisation of the threads within a block since the following steps require the intensities (of a single image row) to be known. Then, each thread performs a <b>loop,</b> shifting a <b>row</b> of the right image with respect to the left one. For each shift and point (y, x), the value of weight function is calculated. The main difference compared with the previous approach is the fact that the height of a kernel is limited to 1  pixel and the width of the image is limited to 1024  pixels. It leads to a less favourable image quality, but the number of times the global GPU memory needs to be accessed is reduced.|$|R
40|$|An {{increasing}} number of database queries are executed by interactive users and applications. Since theuser {{is waiting for the}} database to respond with an answer, the initial response time of producing thefirst results is very important. The user can process the first results while the database system efficiently completes the entire query. The state-of-art join algorithms are not ideal for this setting. Adaptive join algorithms have recently attracted a lot of attention in emerging applications where data is provided by autonomous data sources through heterogeneous network environments. The main advantage of adaptive join techniques is that they can start producing join results as soon as the first input tuples are available, thus improving pipelining by smoothing join result production and by masking source or network delays. Since the response time of the queries places a vital role in adaptive join, the join techniques like Hash Join, Sort Merge Join cannot be used because they require some prework before producing the join result. The only possible join technique {{that can be used in}} adaptive join is Nested Loop Join. In Nested <b>Loop</b> Join each <b>row</b> of the outer relation is compared with each row of the inner relation. The no. of comparisons done by the nested loop join can be reduced by using a technique called trace backing. In trace backing technique whenever a miss match occurs, the next tuple of the outer relation is comparedwith the mismatched inner relation tuple, instead of looping all the tuples of the inner relation. Finally a new circular linked list join method is discussed which may be a better option to perform streaming data Join...|$|R
40|$|You are {{encouraged}} to update to this release which introduces many performance improvements and bug-fixes. 	 	Fixed reading _hr. dat from Wannier 90, now the band-structure of SrTiO 3 (Junquera's test example) is correct. 	 	 	Speeded up tbtrans. py analyzing methods enourmously by introducing faster sparse iterators. Now one can easily perform data-analysis on systems in excess of 10. 000 atoms very fast. 	 	 	Added the TBT. AV. nc file which {{is meant to be}} created by sisl from the TBT. nc files (i. e. create the k-averaged output). This enables users to run tbtrans, create the k-averaged output, and then delete the old file to heavily reduce disk-usage. 	An example: 	tbtrans RUN. fdf > TBT. out sdata siesta. TBT. nc [...] tbt-av rm siesta. TBT. nc 	after this siesta. TBT. AV. nc exists will all k-averaged quantites. If one is not interested in k-resolved quantities this may be very interesting. 	 	 	Updated the TBT. nc sile for improved readability. 	 	 	Easier script data-extraction from TBT. nc files due to easier conversion between atomic indices and pivoting orbitals. 	For this: 	 		a 2 p returns the pivoting indices for the given atoms (complete set) 		 		o 2 p returns the pivoting indices for the given orbitals 		 		 		Added atom keyword for retrieving DOS for a given set of atoms 		 		 		sdata and TBT. nc files now enable the creation of the TBT. AV. nc file which is the k-averaged file of TBT. nc 		 	 	 	 	Faster bond-current algorithms (faster iterator) 	 	 	Initial template for TBT. Proj files for sdata processing 	 	 	Geometry: 	 		 		Enabled multiplying geometries with integers to emulate repeat or tile functions: 		>>> geometry * 2 == geometry. tile(2, 0). tile(2, 1). tile(2, 2) >>> geometry * [2, 1, 2] == geometry. tile(2, 0). tile(2, 2) >>> geometry * [2, 2] == geometry. tile(2, 2) >>> geometry * ([2, 1, 2], 'repeat') == geometry. repeat(2, 0). repeat(2, 2) >>> geometry * ([2, 1, 2], 'r') == geometry. repeat(2, 0). repeat(2, 2) >>> geometry * ([2, 0], 'r') == geometry. repeat(2, 0) >>> geometry * ([2, 2], 'r') == geometry. repeat(2, 2) 		This may be considered an advanced feature but useful nonetheless. 		 		 		Enabled "adding" geometries in a similar way as multiplication I. e. the following applies: 		>>> A + B == A. add(B) >>> A + (B, 1) == A. append(B, 1) >>> A + (B, 2) == A. append(B, 2) >>> (A, 1) + B == A. prepend(B, 1) 		 		Added origo and atom argument to rotation functions. Previously this could be accomblished by: 		rotated = geometry. move(-origo). rotate( [...] .). move(origo) 		while now it is: 		rotated = geometry. rotate( [...] ., origo=origo) 		The origo argument may also be a single integer in which case the rotation is around atom origo. 		Lastly the atom argument enables only rotating a sub-set of atoms. 		 		 		Geometry[ [...] ] is now calling axyz if [...] is pure indices, if it is a slice it does not work with super-cell indices 		 		 		Added rij functions to the Geometry for retrieving distances between two atoms (orij for orbitals) 		 		 		Renamed iter_linear to iter 		 		 		Added argument to iter_species for only looping certain atomic indices 		 		 		Added iter_orbitals which returns an iterator with atomic and associated orbitals. The orbitals are with respect to the local orbital indices on the given atom 		>>> for ia, io in Geometry. iter_orbitals() : >>> Geometry. atom[ia]. R[io] 		works, while 		>>> for ia, io in Geometry. iter_orbitals(local=False) : >>> Geometry. atom[ia]. R[io] 		does not work because io is globally defined. 		 		 		Changed argument name for coords, atom instead of the old idx. 		 		 		Renamed function axyzsc to axyz 		 	 	 	 	SparseCSR: 	 		 		Added iter_nnz(i=None) which loops on sparse elements connecting to row i (or default to <b>loop</b> on all <b>rows</b> and columns). 		 		 		ispmatrix to iterate through a scipy. sparse. *_matrix (and the SparseCSR matrix). 		 	 	 	 	Hamiltonian: 	 		 		Added iter_nnz which is the Hamiltonian equivalent of SparseCSR. iter_nnz. It enables explicit looping on atomic couplings, or orbital couplings. I. e. one may specify a subset of atoms or orbitals to loop over. 		 		 		Preliminary implementation of the non-collinear spin-case. Needs testing...|$|R

