14|10000|Public
50|$|Currently Chinese, French, German, Italian, Latin, and Spanish {{are offered}} as world {{languages}} {{to take as}} electives. Chinese (Simplified) only has one course compared {{to the rest of}} the <b>languages</b> <b>that</b> <b>offer</b> upwards of three language levels worth of classes.|$|E
5000|$|Property setting. Each {{attribute}} of the XML element corresponds to setting a {{property of the}} object instance. This property can be handled by a setter in CookXml. For <b>languages</b> <b>that</b> <b>offer</b> reflection, such as Java and C#, such property setting can be automatically detected using reflection. In these cases, to match the string attribute value to the target property class type, a converter is necessary.|$|E
40|$|Students {{often have}} {{difficulty}} with the minutiae of program construction. We introduce the idea of `Programming by Numbers', which breaks some of the programming process down into smaller steps, giving such students a way into the process of Programming in the Small. Programming by Numbers does not add intellectual difficulty to learning programming, as {{it does not require}} the student to learn additional tools or theory. In fact it can be done with pencil and paper or the normal editor, and only requires the student to remember (and understand) seven simple steps. Programming by Numbers works best with <b>languages</b> <b>that</b> <b>offer</b> pattern matching, such as ML, or data directed dispatching, such as Jav...|$|E
5000|$|IPython is {{a command}} shell for {{interactive}} computing in multiple programming languages, originally {{developed for the}} Python programming <b>language,</b> <b>that</b> <b>offers</b> introspection, rich media, shell syntax, tab completion, and history. IPython provides the following features: ...|$|R
40|$|International audienceWikipedia is a {{well known}} free content, {{multilingual}} encyclopedia written collaboratively by contributors around the world. Anybody can edit an article using a wiki markup <b>language</b> <b>that</b> <b>offers</b> a simplified alternative to HTML. This encyclopedia is composed of millions of articles in different languages...|$|R
5000|$|TestU01 is a {{software}} library, {{implemented in the}} ANSI C <b>language,</b> <b>that</b> <b>offers</b> a collection of utilities for the empirical randomness testing of random number generators (RNGs). [...] The library was first introduced in 2007 by Pierre L’Ecuyer and Richard Simard of the Université de Montréal.|$|R
40|$|Design {{contracts}} {{can be used}} {{in software}} development to ensure the preservation of assertions for program correctness. This can increase reliability in software design. Design by ContractTM (DBC) was developed by Bertrand Meyer and is supported by the Eiffel programming language. Eiffel provides support for checking preconditions, postconditions, and class invariants automatically at runtime. Even though DBC has been supported by Eiffel since 1985, other programming <b>languages</b> <b>that</b> <b>offer</b> built-in DBC support are still rare. Redundant efforts have taken place to implement the support of DBC for different object-oriented programming languages. This paper presents the design and implementation of a framework for extending object-oriented programming languages to support DBC. The framework can eliminate the redundant effort for various languages by simplifying the addition of DBC mechanisms for programming language developers. ...|$|E
40|$|Binary {{methods are}} one of the {{challenges}} for designers of object-oriented programming languages. In this paper we discuss binary class methods (class methods that receive parameters of their own class type) as an alternative for typical uses of binary instances methods and show that they are often less troublesome, more symmetrical and more expressive. However, the main drawback of class methods as they are defined in languages like C++ and Java is that their static binding excludes them from being used in certain codereuse scenarios that need late-bound selfreference. We propose a small and surprisingly simple language mechanism to overcome this drawback. This mechanism can easily be adopted by <b>languages</b> <b>that</b> <b>offer</b> statically bound class methods. We further give the semantics of this extension as a mapping onto an object model without class methods. 1 Introduction A binary method, as defined in [Bru 95], is an instance method of some object of type t that has a parameter of the same [...] ...|$|E
40|$|In practice, the {{development}} of process-aware information systems suffers from a gap between conceptual business process models and executable workflow specifications. Because of this gap, conceptual models are hardly reused as execution templates. In this paper, we address the notorious “OR-join problem ” that is partly responsible for this gap. At the conceptual level people frequently use OR-joins. However, given their non-local semantics, OR-joins cannot be mapped easily onto executable languages. In particular, we present {{a new approach to}} map a conceptual process model with OR-joins (expressed in terms of an EPC) onto an executable model without OR-joins (expressed in terms of a Petri net). Although we used an EPC process model as a running example, the approach is equally applicable to other process modeling <b>languages</b> <b>that</b> <b>offer</b> OR-joins as (e. g. BPMN). Moreover, the resulting Petri net can be mapped onto other execution languages such as BPEL. All of this has been implemented {{in the context of the}} ProM framework...|$|E
5000|$|Pro*Ada {{was officially}} desupported by Oracle in version 7.3. Starting with Oracle8, Pro*Ada was {{replaced}} by SQL*Module but appears to have not been updated since. SQL*Module is a module <b>language</b> <b>that</b> <b>offers</b> a different programming method from embedded SQL. SQL*Module supports the Ada83 language standard for Ada.|$|R
50|$|The {{target is}} to {{overcome}} several of SystemC's limitations {{that arise from}} the usage of C++ by porting the framework to a <b>language</b> <b>that</b> <b>offers</b> features <b>that</b> make subsequent tasks easier to accomplish. These features, such as reflection / introspection, the translation to an intermediate representation instead of machine code (the CIL) that still contains information about user-defined classes, platform independence and extensive thread management functionality, are supposed to allow for faster development and easier debugging of systems.|$|R
2500|$|In linguistics, an A-not-A {{question}} is a polar question <b>that</b> <b>offers</b> two opposite possibilities for the answer. This disjunctive {{question is}} predominantly found in Sinitic and some Altaic <b>languages</b> <b>that</b> <b>offers</b> a choice between an affirmative predicate and its negative counterpart. They are functionally regarded {{as a type of}} [...] "yes/no" [...] question, since they are very similar to a large extent. [...] "A-not-A" [...] questions are often interpreted as having a 'neutral' presupposition or is used in a neutral context. This means that the person asking the A-not-A question does not assume the truth value of the proposition expressed by the question.|$|R
40|$|Computational {{scientists}} often prototype software using productivity <b>languages</b> <b>that</b> <b>offer</b> high-level programming abstractions. When higher {{performance is}} needed, they {{are obliged to}} rewrite their code in a lower-level efficiency language. Different solutions have been proposed to address this trade-off between productivity and efficiency. One promising approach is to create embedded domain-specific languages that sacrifice generality for productivity and performance, but practical experience with DSLs points to some road blocks preventing widespread adoption. This paper proposes a non-invasive domain-specific language that makes as few visible changes to the host programming model as possible. We present ParallelAccelerator, a library and compiler for high-level, high-performance scientific computing in Julia. ParallelAccelerator 2 ̆ 7 s programming model is aligned with existing Julia programming idioms. Our compiler exposes the implicit parallelism in high-level array-style programs and compiles them to fast, parallel native code. Programs can also run in "library-only" mode, letting users benefit from the full Julia environment and libraries. Our results show encouraging performance improvements with very few changes to source code required. In particular, few to no additional type annotations are necessary...|$|E
40|$|Babel is an {{open-source}} language interoperability framework {{tailored to}} the needs of high-performance scientific computing. As an integral element of the Common Component Architecture (CCA) it is used {{in a wide range of}} research projects. In this paper we describe how we extended Babel to support interoperable tuple data types (structs). Structs are a common idiom in scientific APIs; they are an efficient way to pass tuples of nonuniform data between functions, and are supported natively by most programming languages. Using our extended version of Babel, developers of scientific code can now pass structs as arguments between functions implemented in any of the supported languages. In C, C++ and Fortran 2003, structs can be passed without the overhead of data marshaling or copying, providing language interoperability at minimal cost. Other supported languages are Fortran 77, Fortran 90, Java and Python. We will show how we designed a struct implementation that is interoperable with all of the supported languages and present benchmark data compare the performance of all language bindings, highlighting the differences between <b>languages</b> <b>that</b> <b>offer</b> native struct support and an object-oriented interface with getter/setter methods...|$|E
40|$|Despite {{the rising}} {{popularity}} and usefulness of events, or implicit invocation, in software design, {{the availability of}} general-purpose event mechanisms are rare. Further, most event mechanisms available for software design are implemented as libraries or sets of macros that are constrained by the language {{in which they are}} used; making such mechanisms inconvenient to use as well as error-prone. Event mechanisms that are part of a programming language can do away with such constraints; thus making events easier to use. However, there a few <b>languages</b> <b>that</b> <b>offer</b> built-in the events and even fewer languages that have a built-in general-purpose event mechanism. In order to promote the study of implicit invocation programming languages, this thesis presents a formal programming language foundation for events. This thesis expands the, object based, imps-caluculus to create a calculus for objects and events, the rws-calculus. The rws-calculus has a formal syntax, semantics, and a sound type system that is useful for defining practical programming languages that include built-in events. This, along with the ability of the calculus to easily simulate many different event mechanisms makes it a good start toward a formal understanding of implicit invocation...|$|E
50|$|The {{town has}} many small <b>language</b> schools <b>that</b> <b>offer</b> classes for travelers. On a {{hillside}} just outside town is the bilingual (English/Arabic) Mayatan School, {{which was founded}} in 1991 to educate local children.|$|R
40|$|Groupware is a {{technology}} that facilitates teamwork. Developing groupware is a difficult and time-consuming task. To enable collaboration, groupware applications have to share data. Sharing data is among the main obstacles during groupware development. There exist many groupware platforms which offer programming abstractions to relieve developers from recurring issues. However, these platforms have one problem. They are too prescriptive. To assist developers in the development process of groupware applications, we provide a pattern <b>language</b> <b>that</b> <b>offers</b> proven solutions for recurring issues and allow developers to reuse them in the intended context...|$|R
40|$|This thesis {{describes}} a library called rbClips that makes CLIPS functionality available from Ruby. CLIPS {{is a public}} domain tool for building expert systems that was originally developed in NASA in 90 's. The tool itself is written in C but its user interface {{is very similar to}} the Lisp language. Ruby is a modern dynamic scripting <b>language</b> <b>that</b> <b>offers</b> programmer flexible syntax, purely object environment, openness of objects and other interesting features. The library is ment to be used to build expert system for detection of a possibly malicious code in an antivirus software...|$|R
40|$|Randomized {{algorithms}} {{are often}} enjoyed for their simplicity, but the hash functions used to yield the desired theoretical guarantees are often neither simple nor practical. Here {{we show that}} the simplest possible tabulation hashing provides unexpectedly strong guarantees. The scheme itself dates back to Carter and Wegman (STOC’ 77). Keys are viewed as consisting of c characters. We initialize c tables T 1, [...] ., Tc mapping characters to random hash code. A key x = (x 1, [...] ., xq) is hashed to T 1 [x 1] ⊕ · · · ⊕ Tc[xc], where ⊕ denotes xor. While this scheme is not even 4 -independent, we show that it provides many of the guarantees that are normally obtained via higher independence, e. g., Chernoff-type concentration, min-wise hashing for estimating set intersection, and cuckoo hashing. Hashing and hash tables {{are one of the}} most common inner loops in real-world computation, and are even built-in “unit cost ” operations in high level programming <b>languages</b> <b>that</b> <b>offer</b> associative arrays. Often, these inner loops dominate the overall computation time. An important target of the analysis of algorithms is to determine whether there exist practical schemes, which enjoy mathematical guarantees on performance. For example, Knuth gave birth to the analysis of algorithms in 1963 [Knu 63] when he analysed linear probing, the most popular practical implementation of hash tables. Assuming a perfectly random has...|$|E
40|$|Las campa??as de {{marketing}} tur??stico contribuyen a modelar y difundir una imagen concreta de los destinos tur??sticos. En el estudio se analiza la evoluci??n de los discursos promocionales sobre Andaluc??a como destino tur??stico desde 1928, a??o de a??o de creaci??n del Patronato Nacional de Turismo, hasta la actualidad, con el enfoque aplicado por {{el gobierno}} auton??mico andaluz. En el art??culo se constata que los contenidos publicitarios han ido reflejando la propia evoluci??n del sector tur??stico. En nuestros d??as la promoci??n tur??stica institucional adopta nuevos lenguajes que ofrecen una representaci??n de Andaluc??a que se acomoda a las expectativas de una demanda tur??stica diversificada. Estos discursos conviven con visiones que coinciden con la imagen hist??rica y universal de esta tierra que persisten porque son del gusto del turista global. Tourism marketing campaigns help to shape and publicize a specific image of tourist destinations. The study analyses {{the development of}} promotional speeches about Andalusia as a tourist destination since 1928, {{the year of the}} creation of the National Tourist Board, to the present, with the approach of the Andalusian regional government. The article notes that the advertising contents have been reflecting the development of the tourism sector. Today the tourism-promotion institution adopts new <b>languages</b> <b>that</b> <b>offer</b> a representation of Andalusia that will accommodate the expectations of a diversified tourist demand. These statements coexist with views that match the historic and universal image of this land that persist because they appeal to the taste of the global tourist...|$|E
40|$|Everyday {{experience}} {{tells us}} that some errors are transient, but also that some can be handled simply by “retrying ” the failed operation. For instance, a glitch on the network might turn a resource unreachable {{for a short period}} of time; or a sudden peak of work on a server can cause a momentary denial of service. In many occasions, without other kind of specialized recovery code, it is possible to keep a program running only by retrying a failed operation. Unfortunately, retry is not explicitly available on many platforms or programming languages and, even if it were, it could not be blindly used for dealing with every abnormal situation. On languages like C # or Java, or even on <b>languages</b> <b>that</b> <b>offer</b> the retry construct such as Smalltalk and Eiffel, where errors are represented and communicated through exceptions, there is no simple way to clear the effects of a failed operation and, thus, re-attempt its execution. Programmers have to explicitly write sometimes complex and error-prone code to repair the state of a program and the execution context. In this paper, we propose an AOP technique for implementing “retry ” on systems lacking such a feature without using any language extensions for AOP or imposing modifications to the development language. Our approach eliminates the need for programmers to write “state-cleaning ” code for normal objects by means of a transparent transactional mechanism and provides the means to identify non-idempotent operations on the code. In our evaluation we show that a relevant number of application failures can be masked using this approach. 1...|$|E
50|$|The Sejong Institute at the Korean Cultural Centre UK is the Korean <b>language</b> course <b>that</b> <b>offers</b> {{a social}} {{education}} programme.Upon completing the course {{students are able}} to express themselves in Korean on a vast range of topics.|$|R
5000|$|... 2006. Completion of DukSung <b>Language</b> Center <b>that</b> <b>offers</b> {{multi-media}} <b>language</b> {{education and}} humanity education (6,307.49㎡, six story above ground, one underground). Selected by University News Network {{as the winner}} of prize in educational innovation division for 2006 ...|$|R
5000|$|It has a {{flexible}} macro-programming <b>language</b> (XPL) <b>that</b> <b>offers</b> many advantages for quick search and replace, copy-editing and reformatting of raw text. Users continue {{to write and}} share macros extending XyWrite features (printing to USB devices, for example).|$|R
40|$|A domain-specific {{embedded}} language (DSEL) is a domain-specific {{programming language}} with no concrete syntax of its own. Defined {{as a set}} of combinators encapsulated in a module, it borrows the syntax and tools (such as type-checkers and compilers) of its host language; hence it is economical to design, introduce, and maintain. Unfortunately, this economy is counterbalanced by a lack of room for growth. DSELs cannot match sophisticated domain-specific <b>languages</b> <b>that</b> <b>offer</b> tools for domainspecific error-checking and optimisation. These tools are usually based on syntactic analyses, so they do not work on DSELs. Abstract interpretation is a technique ideally suited to the analysis of DSELs, due to its semantic, rather than syntactic, approach. It is based upon the observation that analysing a program is equivalent to evaluating it over an abstract semantic domain. The mathematical properties of the abstract domain are such that evaluation reduces to solving a mutually recursive set of equations. This dissertation shows how abstract interpretation can be applied to a DSEL by replacing it with an abstract implementation of the same interface; evaluating a program with the abstract implementation yields an analysis result, rather than an executable. The abstract interpretation of DSELs provides a foundation upon which to build sophisticated error-checking and optimisation tools. This is illustrated with three examples: an alphabet analyser for CSP, an ambiguity test for parser combinators, and a definedness test for attribute grammars. Of these, the ambiguity test for parser combinators is probably the most important example, due to the prominence of parser combinators and their rather conspicuous lack of support for the well-known LL(k) test. In this dissertation, DSELs and their signatures are encoded using the polymorphic lambda calculus. This allows the correctness of the abstract interpretation of DSELs to be proved using the parametricity theorem: safety is derived for free from the polymorphic type of a program. Crucially, parametricity also solves a problem commonly encountered by other analysis methods: it ensures the correctness of the approach in the presence of higher-order functions. </p...|$|E
40|$|Computer-based {{simulations}} {{become more}} and more important, e. g., to imitate real-world experiments such as crash tests, which would otherwise be too expensive or not feasible at all. Thereby, simulation workflows may be used to control the interaction with simulation tools performing necessary numerical calculations. The input data needed by these tools often come from diverse data sources that manage their data in a multiplicity of proprietary formats. Hence, simulation workflows additionally have to carry out many complex data provisioning tasks. These tasks filter and transform heterogeneous input data {{in such a way that}} underlying simulation tools can properly ingest them. Furthermore, some simulations use different tools that need to exchange data between each other. Here, even more complex data transformations are needed to cope with the differences in data formats and data granularity as they are expected by involved tools. Nowadays, scientists conducting simulations typically have to design their simulation workflows on their own. So, they have to implement many low-level data transformations that realize the data provisioning for and the data exchange between simulation tools. In doing so, they waste time for workflow design, which hinders them to concentrate on their core issue, i. e., the simulation itself. This thesis introduces several novel concepts and methods that significantly alleviate the design of the complex data provisioning in simulation workflows. Firstly, it addresses the issue that most existing workflow systems offer multiple and diverse data provisioning techniques. So, scientists are frequently overwhelmed with selecting certain techniques that are appropriate for their workflows. This thesis discusses how to conquer the multiplicity and diversity of available techniques by their systematic classification. The resulting classes of techniques are then compared with each other considering relevant functional and non-functional requirements for data provisioning in simulation workflows. The major outcome of this classification and comparison is a set of guidelines that assist scientists in choosing proper data provisioning techniques. Another problem with existing workflow systems is that they often do not support all kinds of data resources or data management operations required by concrete computer-based simulations. So, this thesis proposes extensions of conventional workflow <b>languages</b> <b>that</b> <b>offer</b> a generic solution to data provisioning in arbitrary simulation workflows. These extensions allow for specifying any data management operation that may be described via the query or command languages of involved data resources, e. g., arbitrary SQL statements or shell commands. The proposed extensions of workflow languages still do not remove the burden from scientists to specify many complex data management operations using low-level query and command languages. Hence, this thesis introduces a novel pattern-based approach that even further enhances the abstraction support for simulation workflow design. Instead of specifying many workflow tasks, scientists only need to select a small number of abstract patterns to describe the high-level simulation process they have in mind. Furthermore, scientists are familiar with the parameters to be specified for the patterns, because these parameters correspond to terms or concepts that are related to their domain-specific simulation methodology. A rule-based transformation approach offers flexible means to finally map high-level patterns onto executable simulation workflows. Another major contribution is a pattern hierarchy arranging different kinds of patterns according to clearly distinguished abstraction levels. This facilitates a holistic separation of concerns and provides a systematic framework to incorporate different kinds of persons and their various skills into workflow design, e. g., not only scientists, but also data engineers. Altogether, the pattern-based approach conquers the data complexity associated with simulation workflows, which allows scientists to concentrate on their core issue again, namely on the simulation itself. The last contribution is a complementary optimization method to increase the performance of local data processing in simulation workflows. This method introduces various techniques that partition relevant local data processing tasks between the components of a workflow system in a smart way. Thereby, such tasks are either assigned to the workflow execution engine or to a tightly integrated local database system. Corresponding experiments revealed that, even for a moderate data size of about 0. 5 MB, this method is able to reduce workflow duration by nearly a factor of 9...|$|E
50|$|The International Language Academy of Canada ("ILAC") is {{a private}} English <b>language</b> school <b>that</b> <b>offers</b> short and {{long-term}} English language courses for international students. ILAC currently operates campuses in downtown Toronto, Ontario and Vancouver, British Columbia in Canada.|$|R
40|$|For most {{practitioners}} it {{is problematic}} to design an online or blended problem-based learning (PBL) unit within an increasingly complex learning context. This paper presents {{the development and}} application of a PBL authoring tool. It {{was based on a}} PBL-specific modeling <b>language</b> <b>that</b> <b>offers</b> expressive power through appropriate notations and abstractions focused on and restricted to PBL. In comparison with IMS-LD authoring tools, it provides more specific support for the design of online or blended PBL units. NPRP grant # NPRP 5 - 051 - 1 - 015 from the Qatar National Research Fund (a member of Qatar Foundation). Scopu...|$|R
50|$|The Hen House in 2013 is {{the most}} recent body of work by Jonathan Ellery. The notion of {{sequence}} and unfolding narrative {{is at the core}} of his art, enforcing a distinctive Ellery <b>language</b> <b>that</b> <b>offers</b> each work as one part of a continuous and burgeoning series, strengthened by its succession. The deceptive simplicity of the work is informed by Ellery’s awareness of the absurd, a delight in constructing certain orders and exploring the tensions between them. The Hen House includes works in cast iron, aluminium, brass as well as photography. It is accompanied by a limited edition catalogue published by Browns Editions.|$|R
40|$|Nowadays, a {{large number}} of {{extraction}} tools are available. However, using them, {{it is often difficult to}} gather and incorporate new metrics. On the other hand, the metric specifications often lack precision and therefore lead to multiple implementation patterns. In this paper, we propose a new approach of metric gathering. This approach, which is at the same time generic and practical, is based on a metric description mechanism. It uses a <b>language</b> <b>that</b> makes it possible to manipulate data from the source code representation model. In a first phase, we have defined a generic model for object oriented code representation. A second phase defines a description <b>language</b> <b>that</b> <b>offers</b> the syntactic constructions necessary for data manipulation of the generic mode...|$|R
40|$|Abstract — To {{cope with}} the {{increasing}} complexity of today’s circuits and systems new design methodologies are needed. Modeling at higher levels of abstraction and hardware/software integration {{become more and more}} important. A <b>language</b> <b>that</b> <b>offers</b> this features is SystemC. But besides efficient modeling, the correct functional behavior has to be ensured. In this paper we present the property checker CheckSyC for SystemC descriptions on the Resigter Transfer Level (RTL). A SystemC design and a temporal property are converted into a satisfiability (SAT) problem. If the SAT problem is unsatisfiable the property holds. To demonstrate the efficiency of CheckSyC different designs are studied. I...|$|R
40|$|With the {{increased}} globalization {{of business and}} economy, organizations find themselves having to choose from alternative languages to find a working <b>language</b> <b>that</b> <b>offers</b> the most effective economic means of knowledge creation and management {{within the context of}} the strategic environment in which they exist and operate. Linguists have long attempted to assess the economic value of language as a commodity, but with little success. This paper introduces the social-judgment theory to linguists, economists, and strategic planners as a potentially useful theoretical and methodological tool for assessing the value of a working language. A case study is provided as an illustration of how the judgment paradigm can be used for both research and decision-making purposes...|$|R
40|$|We {{introduce}} a measurement system architecture, which has three main qualities: secure two-way transfer of measurement data, quick adaptability to {{different kinds of}} measurement tasks and strong data presentation capabilities through XML techniques. In the architecture, we take advantage of well-tried technologies, like a commonly used visual programming <b>language</b> <b>that</b> <b>offers</b> predefined and adaptive measuring tools for managing measurement devices and tasks. XML is a widely adopted standard for a flexible text format and data exchange. It brings along a vast selection of ready made facilities for processing and transforming the content into any format desired. We also propose a secure environment into the architecture, which can be accessed on demand using {{a wide range of}} terminal devices...|$|R
50|$|Wordster is {{an online}} <b>language</b> resource, <b>that</b> <b>offers</b> through its website dictionary, thesaurus, and other {{services}} for anyone learning about the English language. Much of the content in Wordster is automatically generated, and it applies a number of automated language processing and scalable data retrieval technologies in producing user output.|$|R
40|$|Driven by {{the ever}} {{increasing}} algorithm complexity {{on the field}} of mobile communications systems, SIMD DSP architectures have emerged as an approach <b>that</b> <b>offers</b> the necessary processing power at reasonable levels of die size and power consumption. However, this kind of DSP architectures imposes new challenges for programmers, since algorithms have to be designed to exploit the available parallelism on the processor. Taking as a starting point an algebraic framework that captures the SIMD computational model, we report in this paper about our efforts to design and automatically generate object code for our family of DSP architectures independent of the available SIMD parallelism. We show how these algebraic structures {{can be used as a}} high level programming <b>language</b> <b>that</b> <b>offers</b> a unified approach to design and describe algorithms using SIMD parallelism. Moreover, we show how these algebraic structures offer concise rules for the automatic code generation...|$|R
5000|$|... java.nio (NIO {{stands for}} {{non-blocking}} I/O) {{is a collection}} of Java programming <b>language</b> APIs <b>that</b> <b>offer</b> features for intensive I/O operations. It was introduced with the J2SE 1.4 release of Java by Sun Microsystems to complement an existing standard I/O. NIO was developed under the Java Community Process as JSR 51. An extension to NIO <b>that</b> <b>offers</b> a new file system API, called NIO.2, was released with Java SE 7 ("Dolphin").|$|R
