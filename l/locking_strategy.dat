30|49|Public
50|$|Versant {{by default}} uses a pessimistic <b>locking</b> <b>strategy</b> {{to ensure that}} objects in the {{database}} server are in sync with client access in an ACID way. This is done by {{using a combination of}} locks against both schema and instance objects.|$|E
50|$|Other ways {{of keeping}} client caches in sync are, for example, an optimistic <b>locking</b> <b>strategy,</b> using a classic {{timestamp}} mechanism. VOD also provides forms of client cache synchronization using multi-cast. Additionally {{it provides an}} event mechanism where clients can register for triggering events within the database server {{to be used for}} synchronization or for business logic work flow.|$|E
50|$|When {{a message}} {{is sent to}} an object VOD looks into {{internal}} structures {{to see if the}} object is already in client memory. If not, VOS does an RPC to load the object. At the time VOD loads the object, it will also look at the connections <b>locking</b> <b>strategy</b> to decide how to deal with locking the object on load. VOD supports both global locking strategies that can be applied to a connection and extremely fine grained control to override behavior for a particular use case.|$|E
25|$|Jet 3.0 was {{replaced}} by Jet 3.5, which uses the same database structure, but different <b>locking</b> <b>strategies,</b> making it incompatible with Jet 3.0.|$|R
40|$|International audienceObjectives: Candida infections {{associated}} with catheters remain difficult to manage. Antifungal <b>lock</b> <b>strategies</b> {{could be a}} therapeutic option when the device is difficult to remove or in combination with systemic treatment to increase efficacy. This study deals with the antibiofilm potential of liposomal amphotericin B (L-AMB) used as a lock solution to inhibit Candida albicans, Candida glabrata and Candida parapsilosis biofilms in vitro...|$|R
50|$|When {{employing}} {{the left wing}} <b>lock</b> <b>strategy,</b> the centre's role is typically to shadow the puck carrier or provide token pressure in the opposing team's zone {{to force them to}} try to pass the puck up ice into the lock. This is a much older strategy and is less commonly employed at elite levels, however it was most recently used extensively by the 2006 Carolina Hurricanes on their way to their first Stanley Cup.|$|R
5000|$|A {{consequence}} of the file <b>locking</b> <b>strategy</b> is that AFS does not support large shared databases or record updating within files shared between client systems. This was a deliberate design decision based on the perceived needs of the university computing environment. It leads, for example, {{to the use of}} a single file per message in the original email system for the Andrew Project, the Andrew Message System, rather than a single file per mailbox (i.e., maildir instead of mbox). See AFS and buffered I/O Problems for handling shared databases ...|$|E
40|$|We {{describe}} the locking architecture {{of a new}} operating system, HURRICANE, designed for large scale shared-memory multiprocessors. Many papers already describe kernel locking techniques, andsome of the techniques we use have been previously described by others. However, our work is novel in the particular combination of techniques used, {{as well as several}} of the individual techniques themselves. Moreover, it is the way the techniques work together that is the source of our performance advantages and scalability. Briefly, we use: ffl a hybrid coarse-grain/fine-grain <b>locking</b> <b>strategy</b> that has the low latency and space overhead of a coarsegrain <b>locking</b> <b>strategy</b> while having the high concurrency of a fine-grain locking strategy; ffl replication of data structures to increase access bandwidth and improve concurrency; ffl a clustered kernel that bounds the number of processors that can compete for a lock so as to reduce second order effects such as memory and interconnect contention; ff [...] ...|$|E
40|$|AbstractWe {{discuss a}} Krylov–Schur like {{restarting}} technique applied within the symplectic Lanczos algorithm for the Hamiltonian eigenvalue problem. This {{allows us to}} easily implement a purging and <b>locking</b> <b>strategy</b> {{in order to improve}} the convergence properties of the symplectic Lanczos algorithm. The Krylov–Schur-like restarting is based on the SR algorithm. Some ingredients of the latter need to be adapted to the structure of the symplectic Lanczos recursion. We demonstrate the efficiency of the new method for several Hamiltonian eigenproblems...|$|E
40|$|The {{widespread}} {{popularity of}} Cloud computing as a preferred {{platform for the}} deployment of web applications has resulted in {{an enormous number of}} applications moving to the cloud, and the huge success of cloud service providers. Due to the increasing number of web applications being hosted in the cloud, and the growing scale of data which these applications store, process, and serve – scalable data management systems form a critical part of cloud infrastructures. There are issues related to the database security while database is on cloud. The major challenging issues are multi-tenancy, scalability and the privacy. This paper focuses on the problems faced in the data security of Relational Cloud. The problems faced by various types of tenants and the type of access into the database makes a rework on the security of data, by analyzing proper <b>locking</b> <b>strategies</b> on the records accessed from the database. Data security in cloud computing addresses the type of access mode by the users (for analytical or transaction purpose) and the frequency of data access from the physical location (in shared or no-shared disk mode). Accordingly, the various data <b>locking</b> <b>strategies</b> are studied and appropriate locking mechanism will be implemented for real-time applications as in e-commerce...|$|R
50|$|The {{most common}} event, the current {{transaction}} ends with commit. In the default case, this will release {{the lock and}} object from memory. However, note that there are forms of commit that will do combinations of things like, keep the cache and the locks and start a new transaction, keep the cache, but release the locks and start a new transaction. These forms and others are used to optimize cache effectiveness when using non-default <b>locking</b> <b>strategies</b> like optimistic <b>locking</b> or {{when you have a}} series of transactions that form a task and operate on the same set of objects.|$|R
50|$|Another way to {{classify}} locks is by {{what happens when}} the <b>lock</b> <b>strategy</b> prevents progress of a thread. Most locking designs block the execution of the thread requesting the lock until it is allowed to access the locked resource. With a spinlock, the thread simply waits ("spins") until the lock becomes available. This is efficient if threads are blocked for a short time, because it avoids the overhead of operating system process re-scheduling. It is inefficient if the lock is held for a long time, or if the progress of the thread that is holding the lock depends on preemption of the locked thread.|$|R
40|$|We {{discuss a}} Krylov-Schur like {{restarting}} technique applied within the symplec-tic Lanczos algorithm for the Hamiltonian eigenvalue problem. This allows to easily implement a purging and <b>locking</b> <b>strategy</b> {{in order to}} improve the con-vergence properties of the symplectic Lanczos algorithm. The Krylov-Schur-like restarting is based on the SR algorithm. Some ingredients of the latter need to be adapted to the structure of the symplectic Lanczos recursion. We demon-strate the efficiency of the new method for several Hamiltonian eigenproblems. Key words: Hamiltonian eigenproblem, symplectic Lanczos method, Krylov-Schur method, implicit restarting, SR algorithm...|$|E
40|$|This paper {{explores the}} dynamic {{behaviour}} of loads and tap changers {{during the process}} of voltage collapse in power systems. Using an exponential recovery load model representing the dynamic behaviour of aggregate loads, the mechanism of voltage collapse is illustrated. Dynamic interaction between loads and transformers is investigated. Based on such dynamic considerations, a tap <b>locking</b> <b>strategy</b> is proposed which ensures that voltage collapse does not occur. Investigations focus on determining a critical value of tap position such that locking at a smaller value of tap results in stable behaviour, but locking at a larger value results in voltage collapse. link_to_subscribed_fulltex...|$|E
40|$|We {{describe}} {{and analyze the}} operation and stabilization of a Mach–Zehnder interferometer, which separates the carrier and the first-order sidebands of a phase-modulated laser field, and which is locked using the Hänsch–Couillaud method. In addition to the necessary attenuation, our interferometer introduces, via total internal reflection, a significant polarization-dependent phase delay. We employ a general treatment to describe an interferometer with an object that affects the field along one path, and we examine how this phase delay affects the error signal. We discuss the requirements necessary to ensure the lock point remains unchanged when phase modulation is introduced, and we demonstrate and characterize this locking experimentally. Finally, we suggest an extension to this <b>locking</b> <b>strategy</b> using heterodyne detectio...|$|E
40|$|Phan~oma ” are records {{inserted}} into a concurrently aelected set of records specified by a predicate such that Ihe selection does not eee a transaction conaie-tent result. The usual locking slrategy is lo lock only czisling records. However, records that satisfy the ee-leclion predicate muat be locked {{even when they}} are nol present in the database to prevent their insertion. One way to cope with phantoms is through range lock-ing, 4 limited form of predicate locking. We inves-tigate lock modes for ranges and describe new lock modes lhal greatly increase concurrency. We explore <b>locking</b> <b>strategies</b> involving range, key, and record re-sources that permit trade-offs between concurrency and lock overhead...|$|R
5000|$|The DataBlitz Relational Manager is a C++ {{class library}} {{interface}} to a relational system with SQL support limited to definition statements. Schema information {{is stored in}} tables, and can be queried using the relational API itself. Indices may be created on arbitrary subsets of the attributes in a table. Referential integrity is supported (foreign key constraints), as are null values, date and time attribute types, and variable length fields. Navigation is supported throughiterators over a single table. A conjunctive query may be specified for the iterator, and automatic index selection is performed. Both fine-grained and multi-granularity <b>locking</b> <b>strategies</b> are used for high concurrency without incurring too much overhead. Also, locks obtained by iterators avoid the [...] "phantom" [...] anomaly...|$|R
40|$|Patients on home {{parenteral}} nutrition (HPN) {{are at risk}} for catheter-related complications; mainly infections and occlusions. We have previously shown in HPN patients presenting with catheter sepsis that catheter locking with taurolidine dramatically reduced re-infections when compared with heparin. Our HPN population therefore switched from heparin to taurolidine in 2008. The aim {{of the present study was}} to compare long-term effects of this catheter <b>lock</b> <b>strategy</b> on the occurrence of catheter-related bloodstream infections and occlusions in HPN patients. Data of catheter-related complications were retrospectively collected from 212 patients who received HPN between January 2000 and November 2011, comprising 545 and 200 catheters during catheter lock therapy with heparin and taurolidine, respectively. We evaluated catheter-related bloodstream infection and occlusion incidence rates using Poisson-normal regression analysis. Incidence rate ratios were calculated by dividing incidence rates of heparin by those of taurolidine, adjusting for underlying disease, use of anticoagulants or immune suppressives, frequency of HPN/fluid administration, composition of infusion fluids, and duration of HPN/fluid use before catheter creation. Bloodstream infection incidence rates were 1. 1 /year for heparin and 0. 2 /year for taurolidine locked catheters. Occlusion incidence rates were 0. 2 /year for heparin and 0. 1 /year for taurolidine locked catheters. Adjusted incidence ratios of heparin compared to taurolidine were 5. 9 (95 % confidence interval, 3. 9 - 8. 7) for bloodstream infections and 1. 9 (95 % confidence interval, 1. 1 - 3. 1) for occlusions. Given that no other procedural changes than the catheter <b>lock</b> <b>strategy</b> were implemented during the observation period, these data strongly suggest that taurolidine decreases catheter-related bloodstream infections and occlusions in HPN patients compared with heparin...|$|R
40|$|Abstract. We {{present the}} first {{non-blocking}} hashtable based on open addressing {{that provides the}} following benefits: it combines good cache locality, accessing a single cacheline {{if there are no}} collisions, with short straight-line code; it needs no storage overhead for pointers and memory allocator schemes, having instead an overhead of two words per bucket; it does not need to periodically reorganise or replicate the table; and it does not need garbage collection, even with arbitrary-sized keys. Open problems include resizing the table and replacing, rather than erasing, entries. The result is a highly-concurrent set algorithm that approaches or outperforms the best externally-chained implementations we tested, with fixed memory costs and no need to select or fine-tune a garbage collector or <b>locking</b> <b>strategy.</b> ...|$|E
40|$|We {{describe}} and analyse {{the operation and}} stabilization of a Mach [...] Zehnder interferometer, which separates the carrier and the first-order sidebands of a phase-modulated laser field, and which is locked using the Hänsch [...] Couillaud method. In addition to the necessary attenuation, our interferometer introduces, via total internal reflection, a significant polarization-dependent phase delay. We employ a general treatment to describe an interferometer with an object which affects the field along one path, and we examine how this phase delay affects the error signal. We discuss the requirements necessary to ensure the lock point remains unchanged when phase modulation is introduced, and we demonstrate and characterize this locking experimentally. Finally, we suggest an extension to this <b>locking</b> <b>strategy</b> using heterodyne detection. Comment: 4 pages, 5 figure...|$|E
40|$|International audienceThis paper {{presents}} the locomotion approach {{of a novel}} quadruped robot which is able to carry various effectors for achieving manufacturing tasks in large workspaces. Equipped with lockers {{on some of the}} passive joints and clamping devices {{at the end of its}} limbs, this quadruped uses eight actuators for achieving manufacturing tasks as well as locomotion tasks. In the following sections, we ﬁrst present the proposed robot and its two working modes. Then, the <b>locking</b> <b>strategy</b> of the robot is formulated as an optimization problem. Also, a practical method for managing the limbs swinging movement is addressed. At last, the presented approach is applied on two concrete examples. Possessing a low degree of kinematic redundancy, the proposed quadruped shows a reasonable locomotion capacity which allows it to achieve locomotion with respect to some extra constrains in its workspaces...|$|E
40|$|BACKGROUND AND AIMS: Patients on home {{parenteral}} nutrition (HPN) {{are at risk}} for catheter-related complications; mainly infections and occlusions. We have previously shown in HPN patients presenting with catheter sepsis that catheter locking with taurolidine dramatically reduced re-infections when compared with heparin. Our HPN population therefore switched from heparin to taurolidine in 2008. The aim {{of the present study was}} to compare long-term effects of this catheter <b>lock</b> <b>strategy</b> on the occurrence of catheter-related bloodstream infections and occlusions in HPN patients. METHODS: Data of catheter-related complications were retrospectively collected from 212 patients who received HPN between January 2000 and November 2011, comprising 545 and 200 catheters during catheter lock therapy with heparin and taurolidine, respectively. We evaluated catheter-related bloodstream infection and occlusion incidence rates using Poisson-normal regression analysis. Incidence rate ratios were calculated by dividing incidence rates of heparin by those of taurolidine, adjusting for underlying disease, use of anticoagulants or immune suppressives, frequency of HPN/fluid administration, composition of infusion fluids, and duration of HPN/fluid use before catheter creation. RESULTS: Bloodstream infection incidence rates were 1. 1 /year for heparin and 0. 2 /year for taurolidine locked catheters. Occlusion incidence rates were 0. 2 /year for heparin and 0. 1 /year for taurolidine locked catheters. Adjusted incidence ratios of heparin compared to taurolidine were 5. 9 (95 % confidence interval, 3. 9 - 8. 7) for bloodstream infections and 1. 9 (95 % confidence interval, 1. 1 - 3. 1) for occlusions. CONCLUSIONS: Given that no other procedural changes than the catheter <b>lock</b> <b>strategy</b> were implemented during the observation period, these data strongly suggest that taurolidine decreases catheter-related bloodstream infections and occlusions in HPN patients compared with heparin...|$|R
40|$|We {{describe}} an approach for synthesizing data representations for concurrent programs. Our compiler takes as input a program written using concurrent relations and synthesizes {{a representation of}} the relations as sets of cooperating data structures as well as the placement and acquisition of locks to synchronize concurrent access to those data structures. The resulting code is correct by construction: individual relational operations are implemented correctly and the aggregate set of operations is serializable and deadlock free. The relational specification also permits a high-level optimizer to choose the best performing of many possible legal data representations and <b>locking</b> <b>strategies,</b> which we demonstrate with an experiment autotuning a graph benchmark. Categories and Subject Descriptors D. 3. 3 [Programming Languages]: Language Constructs and Features—Abstract data types...|$|R
40|$|This paper {{addresses}} {{the problem of}} coordinating a team of software developers concurrently working on a common software system. The standard approach to coordinate concurrent activities on {{a common set of}} data is locking. Any part of data used by one person is locked against concurrent use by another person. The second person has to wait until the first person has finished his or her task and releases the lock. In databases, sophisticated locking and transaction concepts minimize the waiting times for concurrent users by offering different lock granularities and different locking levels (e. g. multiple read locks vs. single write locks). However, these <b>locking</b> <b>strategies</b> assume that <b>locks</b> are hold for relatively short times (some seconds), only. In software development [...] ...|$|R
40|$|Atomic {{sections}} are {{a technique}} used {{to simplify the}} writing of parallel programs. Actions performed during the execution of an atomic section should not be visible to other components in the program until after the section completes. Usually the atomicity requirement is enforced through optimistic transactional memory. However, transactional memories have the drawback that not every action is allowed to occur inside of an atomic section. In particular, I/O actions cannot be rolled back on most systems, and so they may not appear within transactions. This paper examines supporting atomic sections that can contain arbitrary actions, {{using a combination of}} locks and transactions. We present a system that infers a <b>locking</b> <b>strategy,</b> identifies problematic atomic sections and creates a hybrid solution. This paper presents the algorithm, argues the process is sound and reports experimental results. 1...|$|E
40|$|Abstract—This paper {{presents}} the locomotion approach {{of a novel}} quadruped robot which is able to carry various effectors for achieving manufacturing tasks in large workspaces. Equipped with lockers {{on some of the}} passive joints and clamping devices {{at the end of its}} limbs, this quadruped uses eight actuators for achieving manufacturing tasks as well as locomotion tasks. In the following sections, we first present the proposed robot and its two working modes. Then, the <b>locking</b> <b>strategy</b> of the robot is formulated as an optimization problem. Also, a practical method for managing the limbs swinging movement is addressed. At last, the presented approach is applied on two concrete examples. Possessing a low degree of kinematic redundancy, the proposed quadruped shows a reason-able locomotion capacity which allows it to achieve locomotion with respect to some extra constrains in its workspaces. I...|$|E
40|$|In recent years, the {{research}} on spatial indexing is arousing more and more interests and attentions. A number of spatial indexing structures based on secondary memory have been proposed for handling the massive spatial data stored in the spatial database rapidly and efficiently. R-tree, proposed by Guttman in 1984, {{is the most popular}} dynamic spatial access method and has been widely used in many prototype researches and commercial applications. During the last two decades, more and more R-tree variations have come into being a prosperous R-tree family. In this paper, authors recall the R-tree and its main variations, study the bulk operation, spatial query processing, cost model and query optimizing technique based on R-tree, present the progress about the parallelism, concurrency control and <b>locking</b> <b>strategy</b> based on R-tree, and point out the directions for future work...|$|E
40|$|An {{essential}} motivation behind concurrent object-oriented {{systems is}} {{to exploit the}} software modularity and reuse potential of object-oriented features {{in the development of}} concurrent systems. However, the marriage between the two disciplines has not been a happy one. In this work we propose a model that reduces the problems associated with introducing concurrency into object-oriented languages. We explore techniques for reasoning about synchronisation requirements in composite object systems operating in a concurrent environment. Furthermore we investigate safe <b>locking</b> <b>strategies,</b> where the <b>locks</b> may be distributed over the components of the system and identify conditions for such locks to be non-redundant. Through the recognition of a Galois connection, we achieve an elegant mathematical characterisation of the lock-distribution problem, which allows us to identify efficient strategies and tools for assisting developers with lock selection...|$|R
40|$|An {{important}} {{class of}} concurrent objects {{are those that}} are non-blocking, that is, whose operations are not contained within mutually exclusive critical sections. A non-blocking object can be accessed by many threads at a time, yet update protocols based on atomic Compare-And-Swap operations can be used to guarantee the object's consistency. In this paper we take a practical look at the Compare-And-Swap operation in the context of contemporary bus-based shared memory multiprocessors, although our results generalize to distributed shared memory multiprocessors. We first describe an operating system-based solution that permits the construction of a non-blocking Compare-And-Swap function on architectures that only support more primitive atomic primitives such as Test-And-Set or Atomic Exchange. We then evaluate several <b>locking</b> <b>strategies</b> {{that can be used to}} synthesize a Compare-And-Swap operation, and show that the common techniques for reducing synchronization overhead in the presence o [...] ...|$|R
30|$|The aim of {{this study}} was to compare the {{efficacy}} of external fixation with volar <b>locked</b> plating treatment <b>strategies</b> in displaced intra-articular (Cooney’s type IV) distal radius fractures.|$|R
40|$|Significant {{performance}} advantages can {{be realized}} by implementing a database system on a shared memory multiprocessor. An efficient implementation of a lock manager {{is a prerequisite for}} efficient transaction processing in multiprocessor database systems. To this end, we advocate adopting an autonomous <b>locking</b> <b>strategy.</b> In autonomous locking, transactions acquire and release locks via operations on shared memory, in contrast to conventional locking where communication with a lock manager is involved. We demonstrate the superior performance and scalability of autonomous locking through benchmarks of a prototype lock manager implemented on a large scale shared memory multiprocessor. For instance, when contention is high (i. e., for hot lock operations), the performance of autonomous locking is nearly an order of magnitude better than conventional locking. The paper also addresses issues related to recovery (assuming independent node failures). 1 Partially supported by the National Scie [...] ...|$|E
40|$|Abstract — This paper {{builds on}} earlier work that used a spatial grid for locking to provide {{physically}} accurate parallel collision handling. Instead {{of using a}} grid, this work uses a spatial tree. The tree is better able to handle heterogeneous particle populations. The method was specifically developed to handle a granular flow impact simulation where one large body impacts a population of smaller bodies. The large size of the impactor leads to a breakdown in the grid based <b>locking</b> <b>strategy</b> because grid cells are uniformly sized and must {{be large enough to}} enclose the largest particle in the population plus the relative velocity distribution multipled by a time step. The tree allows the regions that get locked to scale in size based on local characteristics, making it possible to handle dramatic size differences. Unfortunately, it also has more overhead than the grid so using it when it is not needed can slow simulations down...|$|E
40|$|Abstract. In {{this paper}} {{we present a}} {{complete}} Java STM framework, called Deuce, intended as a platform for developing scalable concurrent applications and as a research tool for designing new STM algorithms. It was not clear if one could build an e cient Java STM without compiler support. Deuce provides several bene ts over existing Java STM frameworks: it avoids any changes or additions to the JVM, {{it does not require}} language extensions or intrusive APIs, and it does not impose any memory footprint or GC overhead. To support legacy libraries, Deuce dynamically instruments classes at load time and uses an original eld-based <b>locking</b> <b>strategy</b> to improve concurrency. Deuce also provides a simple internal API allowing di erent STMs algorithms to be plugged in. We show empirical results that highlight the scalability of our framework running benchmarks with hundreds of concurrent threads. This paper shows for the rst time that one can actually design a Java STM with reasonable performance without compiler support. ...|$|E
40|$|With {{the promise}} of machine {{independence}} and efficient portability, JAVA has gained widespread popularity in the industry. Along with this promise comes the need for designing an efficient runtime environment that can provide high-end performance for Java-based applications. In other words, the performance of Java applications depends heavily on the design and optimization of the Java Virtual Machine (JVM). In this paper, we start by evaluating {{the performance of a}} Java server application (SPECjbb 2000) on an Intel platform running a rudimentary JVM. We present a measurement-based methodology for identifying areas of potential improvement and subsequently evaluating the effect of JVM optimizations and other platform optimizations. The compiler optimizations presented and discussed in this paper include peephole optimizations and Java specific optimizations. In addition, we also study the effect of optimizing the garbage collection mechanism and the effect of improved <b>locking</b> <b>strategies.</b> The identification and analysis of these optimizations are guided by the detailed knowledge of the micro-architecture and the use of performance measurement and profiling tools (EMON and VTune) on Intel platforms...|$|R
40|$|Abstract: 2 ̆ 2 An {{important}} {{class of}} concurrent objects {{are those that}} are lock-free, that is, whose operations are not contained within mutually exclusive critical sections. A lock-free object can be accessed by many threads at a time, yet clever update protocols based on atomic Compare-And-Swap operations guarantee the object 2 ̆ 7 s consistency. In this paper we take a practical look at the Compare-And-Swap operation in the context of contemporary shared memory multiprocessors. We first describe an operating system-based solution that permits the construction of a non- blocking Compare-And-Swap function on processor architectures that only support lock-oriented atomic primitives. We then evaluate several <b>locking</b> <b>strategies</b> {{that can be used to}} synthesize a Compare-And-Swap operation. We show that the common techniques for reducing the overhead of lock-oriented synchronization in the presence of contention are inappropriate when used as the basis for lock-free synchronization. We then describe a simple modification to an existing synchronization protocol which allows us to avoid much of the overhead normally associated with contention. 2 ̆...|$|R
40|$|AbstractConcurrent {{object-oriented}} systems must {{prevent the}} interference that may arise when multiple threads simultaneously access shared components. We present a simple approach for implementing flexible <b>locking</b> <b>strategies</b> in an object-oriented system, {{in which the}} components themselves may be composite objects. We express exclusion requirements as sets of conflict pairs on component interfaces. Given knowledge of the dependency between the interface of a composite object and its internal components, we show how external exclusion requirements can be calculated from internal requirements, and further, how any potential concurrent activity outside an object can be projected into potential concurrency for the internal components. With our approach we can defer the distribution of locks in the system until deployment: the placement of locks and choice of lock type for a component can depend on its operating environment. A Galois connection between the outward mapping of exclusion requirements, and the inward mapping of potential concurrency, limits how many locks are worth considering. In this paper we only deal with exclusion control, including mutexes, read–write locks and read–write sets, and do not cover state-dependent locking or transaction-based approaches...|$|R
