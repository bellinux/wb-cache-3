190|67|Public
50|$|Separation logic {{supports}} the developing {{field of research}} described by Peter O'Hearn and others as <b>local</b> <b>reasoning,</b> whereby specifications and proofs of a program component mention only the portion of memory used by the component, and not the entire global state of the system. Applications include automated program verification (where an algorithm checks the validity of another algorithm) and automated parallelization of software.|$|E
5000|$|This {{is known}} as the frame rule (named after the frame problem) and enables <b>local</b> <b>reasoning.</b> It says that a program that executes safely in a small state (satisfying [...] ), can also execute in any bigger state (satisfying [...] ) and that its {{execution}} will not affect the additional part of the state (and so [...] will remain true in the postcondition). The side condition enforces this by specifying that none of the variables modified by [...] occur free in , i.e. none of them are in the 'free variable' set [...] of [...]|$|E
40|$|Abstract. Separation {{logic is}} an {{extension}} of Hoare logic that allows <b>local</b> <b>reasoning.</b> <b>Local</b> <b>reasoning</b> is a powerful feature that often allows simpler specifications and proofs. However, this power is not used to reason about while-loops. In this paper an inference rule is presented that allows using <b>local</b> <b>reasoning</b> to verify the partial correctness of while-loops. Instead of loop invariants this inference rule uses pre- and post-conditions for loops. This provides a different view of while-loops that is even without <b>local</b> <b>reasoning</b> often beneficial. ...|$|E
40|$|We present <b>local</b> Hoare <b>reasoning</b> about data update, {{introducing}} Context Logic for analysing structured data. We apply our reasoning to tree update, heap update, and term rewriting. Our reasoning about heap update {{is exactly}} {{analogous to the}} <b>local</b> Hoare <b>reasoning</b> of Separation Logic. Our reasoning about tree update and term rewriting can only be done with Context Logic...|$|R
40|$|Ontology {{languages}} like OWL {{allow for}} semantically rich annotation of resources (e. g., products advertised at on-line electronic marketplaces). The description logic (DL) formalism underlying OWL provides reasoning techniques that perform match-making on such annotations. This paper identifies peculiarities {{in the use}} of DL inferences for matchmaking that derive from OWL 2 ̆ 7 s open-world semantics, analyzes <b>local</b> closed-world <b>reasoning</b> for its applicability to matchmaking, and investigates the suitability of two nonmonotonic extensions to DL, autoepistemic DLs and DLs with circumscription, for <b>local</b> closed-world <b>reasoning</b> in the matchmaking context. An elaborate example of an electronic marketplace for PC product catalogs from the e-commerce domain demonstrates how these formalisms can be used to realize such scenarios...|$|R
40|$|This report {{documents}} the Bachelor’s End Project of Jon Mediero Iturrioz for the Bachelor in Informatics Engineering of the UPV/EHU. The project was made {{under the supervision}} of Francisca Lucio Carrasco. The project belongs to the domain of formal methods. In the project a methodology to prove the correctness of concurrent programs called <b>Local</b> Rely-Guarantee <b>reasoning</b> is analyzed. Afterwards, the methodology is implemented over Dagny automatic program verification tool, which was introduced to me in the Formal Methods for Software Developments optional course of the fourth year of the bachelor. In addition to <b>Local</b> Rely-Guarantee <b>reasoning,</b> in the report Hoare logic, Separation logic and Variables as Resource logic are explained, {{in order to have a}} good foundation to understand the new methodology. Finally, the Dafny implementation is explained, and some examples are presented...|$|R
40|$|<b>Local</b> <b>reasoning</b> {{has become}} a {{well-established}} technique in program verification, which {{has been shown to}} be useful at many different levels of abstraction. In separation logic, we use a low-level abstraction that is close to how the machine sees the program state. In context logic, we work with high-level abstractions that are close to how the clients of modules see the program state. We apply program refinement to <b>local</b> <b>reasoning,</b> demonstrating that high-level, abstract <b>local</b> <b>reasoning</b> is sound for module implementations. We consider two approaches: one that preserves the high-level locality at the low level; and one that breaks the high-level ‘fiction’ of locality...|$|E
40|$|Abstract. This paper {{develops}} a <b>local</b> <b>reasoning</b> method to check lineartime temporal properties of concurrent programs. In practice, {{it is often}} infeasible to model check over the product state space of a concurrent program. The method developed in this paper replaces such global reasoning with checks of (abstracted) individual processes. An automatic refinement step gradually exposes local state if necessary, ensuring that the method is complete. Experiments with a prototype implementation show that <b>local</b> <b>reasoning</b> can hold a significant advantage over global reasoning. ...|$|E
40|$|Abstract. Separation Logic is a widely-used {{tool that}} allows for <b>local</b> <b>reasoning</b> about {{imperative}} programs with pointers. A straightforward definition of this “local reasoning ” is that, whenever a program runs safely on some state, adding more state would {{have no effect on}} the program’s behavior. However, for a mix of technical and historical reasons, <b>local</b> <b>reasoning</b> is defined in a more subtle way, allowing a program to lose some behaviors when extra state is added. In this paper, we propose strengthening <b>local</b> <b>reasoning</b> to match the straightforward definition mentioned above. We argue that such a strengthening does not have any negative effect on the usability of Separation Logic, and we present four examples that illustrate how this strengthening simplifies some of the metatheoretical reasoning regarding Separation Logic. In one example, our change even results in a more powerful metatheory. ...|$|E
40|$|TheW 3 CDocument Object Model (DOM) {{specifies}} an XML update library. DOM {{is written}} in English, and is therefore not compositional and not complete. We provide a first step towards a compositional specification of DOM. Unlike DOM, {{we are able to}} work with a minimal set of commands and obtain a complete reasoning for straight-line code. Our work transfers O’Hearn, Reynolds and Yang’s <b>local</b> Hoare <b>reasoning</b> for analysing heaps to XML, viewing XML as an in-place memory store as does DOM. In particular, we ap-ply recent work by Calcagno, Gardner and Zarfaty on <b>local</b> Hoare <b>reasoning</b> about simple tree update to this real-world DOM application. Our reasoning not only formally specifies a significant subset of DOM Core Level 1, but {{can also be used to}} verify, for example, invariant properties of simple Javascript programs...|$|R
40|$|Ontology {{languages}} like OWL {{allow for}} semantically rich annotation of resources, such as products advertised at an electronic online marketplace, while the Description Logic (DL) formalism underlying OWL provides reasoning techniques to perform matchmaking on such annotations. We identify peculiarities {{in the use}} of DL inferences for matchmaking which are due to the open-world semantics of OWL, and we analyse the use of <b>local</b> closed-world <b>reasoning</b> for its applicability to matchmaking. In particular, we investigate two nonmonotonic extensions to DL, namely autoepistemic DLs and DLs with circumscription, for their suitability of realising <b>local</b> closed-world <b>reasoning</b> in the matchmaking context to overcome these problems. We discuss their different characteristics by means of an elaborate example of an electronic marketplace for PC product catalogues from the eCommerce domain and demonstrate how these formalisms can be used to realise such scenarios. ...|$|R
40|$|The W 3 C Document Object Model (DOM) {{specifies}} an XML update library. DOM {{is written}} in English, and is therefore not compositional and not complete. We provide a first step towards a compositional specification of DOM. Unlike DOM, {{we are able to}} work with a minimal set of commands and obtain a complete reasoning for straight-line code. Our work transfers O’Hearn, Reynolds and Yang’s <b>local</b> Hoare <b>reasoning</b> for analysing heaps to XML, viewing XML as an in-place memory store as does DOM. In particular, we apply recent work by Calcagno, Gardner and Zarfaty on <b>local</b> Hoare <b>reasoning</b> about a simple tree-update language to DOM, showing that our reasoning scales to DOM. Our reasoning not only formally specifies a significant subset of DOM Core Level 1, but {{can also be used to}} verify e. g. invariant properties of simple Javascript programs...|$|R
40|$|<b>Local</b> <b>reasoning</b> allows {{to handle}} SMT {{problems}} involving a certain class of universally quantified formulas {{in a complete}} way by instantiation to a finite set of ground formulas. We present a method to generate this set incrementally, {{in order to provide}} a more efficient way of solving these satisfiability problems. The incremental instantiation is guided semantically, inspired by the instance generation approach to first-order theorem proving. Our method is sound and complete, and terminates on both satisfiable and unsatisfiable input after generating a subset of the instances needed in standard <b>local</b> <b>reasoning...</b>|$|E
40|$|In this paper, {{we present}} {{techniques}} for a network forensics analysis mechanism that includes effective evidence presentation, manipulation and automated reasoning. We propose the evidence graph as a novel graph model {{to facilitate the}} presentation and manipulation of intrusion evidence. For automated evidence analysis, we develop a hierarchical reasoning framework that includes <b>local</b> <b>reasoning</b> and global reasoning. <b>Local</b> <b>reasoning</b> aims to infer the roles of suspicious hosts from local observations. Global reasoning aims to identify group of strongly correlated hosts in the attack and derive their relationships. By using the evidence graph model, we effectively integrate analyst feedback into the automated reasoning process. Experimental results demonstrate the potential and effectiveness of our proposed approaches. ...|$|E
40|$|We {{develop a}} {{prototype}} network forensics analysis tool that integrates presentation, manipulation and automated reasoning of intrusion evidence. We propose the evidence graph as a novel graph model {{to facilitate the}} presentation and manipulation of intrusion evidence. For automated evidence analysis, we develop a hierarchical reasoning framework that includes <b>local</b> <b>reasoning</b> and global reasoning. In <b>local</b> <b>reasoning,</b> we apply Rule-based Fuzzy Cognitive Maps (RBFCM) to model the state evolution of suspicious hosts. In global reasoning, we aim to identify group of strongly correlated hosts in the attack and derive their relationships in the attack scenario. Our analysis mechanism effectively integrates analyst feedbacks into the automated reasoning process. Experimental results demonstrate the potential of our proposed techniques...|$|E
40|$|Abstract. The paper {{addresses}} {{the problem of}} reasoning with multiple ontologies interrelated with semantic mappings. This problem {{is becoming more and}} more relevant due to the necessity of building a scalable ontological reasoning tools for the Semantic Web. In contrast to the so called global approach, in which reasoning with multiple semantically related ontologies is performed in a global knowledge base that encodes both ontologies and semantic mappings, we propose a distributed reasoning approach in which reasoning is the result of combination via semantic mappings of <b>local</b> <b>reasonings</b> chunks performed in single ontologies. The paper presents a tableau-based distributed reasoning procedure which is sound and complete w. r. t. Distributed Description Logics, the formal framework used to represent multiple semantically connected ontologies. The paper also describes the design and implementation principles of a distributed reasoning system, called DRAGO (Distributed Reasoning Architecture for a Galaxy of Ontology), that implements such distributed decision procedure. ...|$|R
40|$|Abstract. A {{distributed}} reasoning {{platform is}} presented to reduce the energy consumption of Wireless Sensor Networks (WSNs) offering geospatial services by minimizing the amount of wireless communication. It combines <b>local,</b> rule-based <b>reasoning</b> on the sensors and gateways with global, ontology-based reasoning on the back-end servers. The Semantic Sensor Network (SNN) Ontology was extended to model the WSN energy consumption. One exemplary prototype is presented, namely the Garbage Bin Tampering Monitor (GBTM). ...|$|R
40|$|We {{define a}} {{compositional}} program logic {{in the style}} of Floyd and Hoare for a simple, typed, stack-based abstract machine with unstructured control flow, global variables and mutually recursive procedure calls. Notable features of the logic include a careful treatment of auxiliary variables and quantification and the use of substructural typing to permit <b>local,</b> modular <b>reasoning</b> about program fragments. Semantic soundness is established using an interpretation of types and assertions defined by orthogonality with respect to sets of contexts...|$|R
40|$|This paper {{proposes a}} novel {{approach}} to shape analysis: using <b>local</b> <b>reasoning</b> about individual heap locations instead of global reasoning about entire heap abstractions. We present an inter-procedural shape analysis algorithm for languages with destructive updates and formulate it as a dataflow analysis. The key feature is a novel memory abstraction that differs from traditional abstractions in two ways. First, we build the shape abstraction and analysis {{on top of a}} pointer analysis. Second, we decompose the shape abstraction into a set of independent configurations, each of which characterizes one single heap location. Our approach: 1) leads to simpler algorithm specifications, because of <b>local</b> <b>reasoning</b> about the single location; 2) leads to efficient algorithms, because of the abstraction decomposition; and 3) makes it easier to develop context-sensitive, demand-driven, and incremental shape analyses. We have developed simple extensions that use the analysis results to find memory errors in programs with explicit deallocation, including memory leaks and accesses through dangling pointers. We have built a prototype system that implements the ideas in this paper and is designed to analyze C programs. Our experimental results support the intuition that <b>local</b> <b>reasoning</b> leads to more scalable analyses. ...|$|E
40|$|We {{propose a}} sound and {{complete}} satisfiability algorithm for propositional multi-context systems. In essence, the algorithm is a distribution policy built {{on top of}} <b>local</b> <b>reasoning</b> procedures, one for each context, which can be implemented by (a diversity of) customized state-of-the-art SAT solvers...|$|E
40|$|Abstract Using Fagin’s and Halpern’s <b>local</b> <b>reasoning</b> {{models and}} an epistemic variant of Jennings’s and Schotch’s {{semantics}} of weakly aggregative modal logic, {{we argue that}} the hypothesis that split-brain patients have two coherent minds is preferable to the hypothesis that they have one incoherent mind. ...|$|E
40|$|Abstract. Web mashups {{are complex}} {{programs}} that dynamically compose data and code from many sources. Whereas data is sometimes formally specified by XML schema, code never is. This {{makes it difficult}} to construct reliable software. Using <b>local</b> Hoare <b>reasoning,</b> introduced in separation logic to reason about e. g. C programs and extended in context logic to reason about e. g. the DOM library, we are able to reason about mashup programs, proving that they are fault-free and providing specifications for code that are analogous to XML schema for data. ...|$|R
40|$|We {{describe}} Razor, a planning-based information-gathering {{agent that}} assists users by automatically determining which Internet information sites {{are relevant to}} their query, accessing those sites in parallel, and integrating the results. Razor uses a disjunctive graphbased plan representation. It then uses a novel and powerful form of <b>local</b> completeness <b>reasoning</b> in order to transform those plans into contingent plans of high quality. These contingent plans can be efficiently executed, obtaining more answers at less cost than the original plans. We focus in this paper on the algorithms underlying the plan transformation process...|$|R
40|$|Abstract: Although {{contract}} reparations {{have been}} extensively {{studied in the}} context of deontic logics, there is not much literature using reparations in automata-based deontic approaches. Contract automata are a recent approach to modelling the notion of contract-based interaction between different parties using synchronous com-position. However, it lacks the notion of reparations for contract violations. In this article we look into different ways reparation can be added to an automaton-based contract approach, extended contract automata with three forms of such clauses: (i) catch-all reparations for violation; (ii) reparations for specific violations; and (iii) hierar-chical contracts for <b>local</b> reparation <b>reasoning...</b>|$|R
40|$|Abstract. This paper {{explores the}} concept of {{locality}} in proofs of global safety properties of asynchronously composed, multi-process programs. Model checking on the full state space is often infeasible due to state explosion. A local proof, in contrast, {{is a collection of}} per-process invariants, which together imply the global safety property. Local proofs can be compact: but a central problem is that <b>local</b> <b>reasoning</b> is incomplete. In this paper, we present a “completion ” algorithm, which gradually exposes facts about the internal state of components, until either a local proof or a real error is discovered. Experiments show that <b>local</b> <b>reasoning</b> can have significantly better performance over a reachability computation. Moreover, for some parameterized protocols, a local proof can be used to show correctness for all instances. ...|$|E
40|$|Researchers {{building}} multi-agent algorithms typically {{work with}} problems abstracted away from real applications. The abstracted problem instances allow systematic and detailed investigations of new algorithms. However, {{a key question}} is how to apply algorithm, developed on an abstract problem, in a real application. In this paper, we report on what was required to apply a particular distributed resource allocation algorithm developed for an abstract coordination problem in a real hardware application. A probabilistic representation of resources and tasks was used to deal with uncertainty and dynamics and <b>local</b> <b>reasoning</b> was used to deal with delays in the distributed resource allocation algorithm. The probabilistic representation and <b>local</b> <b>reasoning</b> enabled the use of the multi-agent algorithm which, in turn, improved the overall performance of the system...|$|E
40|$|Abstract. Separation Logic is a widely-used {{tool that}} allows for <b>local</b> <b>reasoning</b> about {{imperative}} programs with pointers. A straightforward definition of this “local reasoning ” is that, whenever a program runs safely on some state, any additional state {{has no effect on}} the program’s behavior. In the presence of nondeterminism, however, <b>local</b> <b>reasoning</b> must be defined as something more subtle; specifically, additional state is allowed to decrease the amount of nondeterminism of the program. This subtlety causes difficulty in proving various metatheoretical facts about Separation Logic and its variants. Four specific examples are: (1) specifying the behavior of a program on its minimal footprint does not provide a complete specification; (2) data refinement requires a rather unintuitive restriction that the memory used by an abstract module be one; (3) Relational Separation Logic requires quite a bit of additional work to prove the frame rule sound; and (4) it is quite tricky to define a model of Separation Logic in which the total domain of memory is finite. In this paper, we show how to cleanly resolve all of these issues by strengthening the definition of <b>local</b> <b>reasoning</b> to eliminate the subtlety mentioned above. We contend that this solution will also similarly solve many future metatheoretical issues. ...|$|E
30|$|Per-Region/Frame Processing. Region-based {{algorithms}} {{relax the}} per-pixel independency assumption, thus permitting <b>local</b> spatial <b>reasoning</b> {{in order to}} minimize false positive alarms. The underlying motivations are mainly twofold. First, pixels may model parts of the background scene which are locally oscillating or moving slightly, like leafs or flags. Therefore, the information needed to capture these BG phenomena has not to be collected and evaluated over a single pixel location, but on a larger support. Second, considering the neighborhood of a pixel permits to assess useful analysis, such as edge extraction or histogram computation. This provides a more robust description of the visual appearance of the observed scene.|$|R
40|$|The {{proposed}} {{analysis of}} the currently available experimental results concerning the neural cell activity in the brain area known as hippocampus suggests a particular mechanism of spatial information and memory processing. Below {{it is argued that}} the spatial information available through the {{analysis of the}} hippocampal cell activity is predominantly of topological nature. It is pointed out that a direct topological analysis can produce a topological invariant based classification of the cell activity patterns and a complete topological description of animal's current environment. It also provides a full first order logical system for <b>local</b> topological <b>reasoning</b> about spatial structure and animal's navigational strategies. Comment: 53 pages, 12 figure...|$|R
40|$|Abstract. Nonmonotonic {{extensions}} of description logics (DLs) allow for default and <b>local</b> closed-world <b>reasoning</b> and are an acknowledged desired feature for applications, e. g. in the Semantic Web. A recent ap-proach {{to such an}} extension is based on McCarthy’s circumscription, which rests {{on the principle of}} minimising the extension of selected pred-icates to close off dedicated parts of a domain model. While decidabil-ity and complexity results have been established in the literature, no practical algorithmisation for circumscriptive DLs has been proposed so far. In this paper, we present a tableaux calculus that {{can be used as a}} decision procedure for concept satisfiability with respect to concept-circumscribed ALCO knowledge bases. The calculus builds on existing tableaux for classical DLs, extended by the notion of a preference clash to detect the non-minimality of constructed models. ...|$|R
40|$|This survey brings {{together}} {{a collection of}} epistemic logics and discusses their approaches in alleviating the logical omniscience problem. Of particular note is the logic of implicit and explicit belief. Explicit belief refers to information actively held by an agent, while implicit belief refers to the logical consequence of explicit belief. Rami®cations of Lev-esque's logic include nonstandard epistemic logic and the logics of awareness and <b>local</b> <b>reasoning.</b> Models of nonstandard epistemic logic are de®ned with respect to nonstandard proportional logic to weaken its semantics. In the logic of awareness, an agent can only believe a concept that it is aware of. Closely related to awareness are S- 1 and S- 3 epistemic operators {{which can be used}} to model skeptical and credulous agents. The logic of <b>local</b> <b>reasoning</b> provides a semantics for representing the fact that agents can have different clusters of beliefs which may contradict each other. Other variations include epistemic structures which are generalizations of the logic of <b>local</b> <b>reasoning</b> and fusion epistemic models which provide an account that agents can combine information conjunctively or disjunctively. Another closely related approach is the logic of explicit propostions which captures the insight that agents can hold beliefs independently without putting them together. 1997 John Wiley & Sons, Inc. I...|$|E
40|$|Many {{verification}} approaches use SMT solvers in some form, and {{are limited}} by their incomplete handling of quantified formulas. <b>Local</b> <b>reasoning</b> allows to handle SMT problems involving a certain class of universally quantified formulas in a complete way by instantiation to a finite set of ground formulas. We present a method to generate these instances incrementally, {{in order to provide}} a more efficient way of solving these satisfiability problems. The incremental instantiation is guided semantically, inspired by the instance generation approach to first-order theorem proving. Our method is sound and complete, and terminates on both satisfiable and unsatisfiable input after generating a subset of the instances needed in standard <b>local</b> <b>reasoning.</b> Experimental results show that for a large class of examples the incremental approach is substantially more efficient than eager generation of all instances...|$|E
40|$|<b>Local</b> <b>reasoning</b> about {{programs}} exploits {{the natural}} local behaviour common in programs by focussing on the footprint- {{that part of}} the resource accessed by the program. We address the problem of formally characterising and analysing the footprint notion for abstract local functions introduced by Calcagno, O’Hearn and Yang. With our definition, we prove that the footprints are the only essential elements required for a complete specification of a local function. We also show that, for well-founded models (which is usually the case in practice), a smallest specification always exists that only includes the footprints, thus formalising the notion of small axioms in <b>local</b> <b>reasoning.</b> We also present results for the non-well-founded case, and introduce the natural class of one-step local functions for which the footprints are the smallest safe states...|$|E
40|$|Probability Bracket Notation (PBN) {{is applied}} to systems of {{multiple}} random variables for preliminary study of static Bayesian Networks (BN) and Probabilistic Graphic Models (PGM). The famous Student BN Example is explored to show the <b>local</b> independences and <b>reasoning</b> power of a BN. Software package Elvira is used to graphically display the student BN. Our investigation shows that PBN provides a consistent and convenient alternative to manipulate many expressions related to joint, marginal and conditional probability distributions in static BN...|$|R
40|$|Labelled sequent calculi are {{provided}} {{for a wide}} class of normal modal systems using truth values as labels. The rules for formula constructors are common to all modal systems. For each modal system, specific rules for truth values {{are provided}} that reflect the envisaged properties of the accessibility relation. Both <b>local</b> and global <b>reasoning</b> are supported. Strong completeness is proved for a natural two-sorted algebraic semantics. As a corollary, strong completeness is also obtained over general Kripke semantics. A duality resul...|$|R
40|$|Nonmonotonic {{extensions}} of description logics (DLs) allow for default and <b>local</b> closed-world <b>reasoning</b> and are an acknowledged desired feature for applications, e. g. in the Semantic Web. A recent approach {{to such an}} extension is based on McCarthy 2 ̆ 7 s circumscription, which rests {{on the principle of}} minimising the extension of selected predicates to close off dedicated parts of a domain model. While decidability and complexity results have been established in the literature, no practical algorithmisation for circumscriptive DLs has been proposed so far. In this paper, we present a tableaux calculus that {{can be used as a}} decision procedure for concept satisfiability with respect to concept circumscribed ALCO knowledge bases. The calculus builds on existing tableaux for classical DLs, extended by the notion of a preference clash to detect the non-minimality of constructed models...|$|R
