1|1696|Public
5000|$|The {{simplest}} checksum {{algorithm is}} the so-called <b>longitudinal</b> <b>parity</b> <b>check,</b> which breaks the data into [...] "words" [...] with a fixed number n of bits, and then computes the exclusive or (XOR) of all those words. The result is appended to the message as an extra word. To check the integrity of a message, the receiver computes the exclusive or of all its words, including the checksum; if the result is not a word with n zeros, the receiver knows a transmission error occurred.|$|E
5000|$|The rows of a <b>parity</b> <b>check</b> matrix are the {{coefficients}} of the <b>parity</b> <b>check</b> equations. That is, they show how linear combinations of certain digits (components) of each codeword equal zero. For example, the <b>parity</b> <b>check</b> matrix ...|$|R
3000|$|The {{processing}} time per iteration {{can be reduced}} substantially if some means is employed to eliminate the inter-lane communications associated with performing <b>parity</b> <b>checks.</b> Consider an alternative approach to testing the correctness of code-symbol polarities in which the <b>parity</b> <b>checks</b> for a given block of rows are incorporated within the corresponding message-passing subiterations. At {{the end of each}} subiteration of the message-passing phase, the posteriors updated during the subiteration are used to determine if the corresponding subset of <b>parity</b> <b>checks</b> are satisfied. The current posterior values required for each <b>parity</b> <b>check</b> are already located in the stream-processor lane in which the <b>parity</b> <b>check</b> is performed since the updates of the same values have just been completed in the same lane. Thus the need for separate inter-lane communications for <b>parity</b> <b>checks</b> is eliminated. We refer to this non-standard schedule of <b>parity</b> <b>checks</b> as the integrated <b>parity</b> <b>check</b> (IPC). The decoding time for the IPC is shown in the second-row entry in Table 1. The {{processing time}} for the integrated message-passing-and-parity-check phase of an iteration is only [...]. 08 μ s greater than the message-passing phase alone in the standard schedule.|$|R
40|$|International audienceWe {{investigate}} {{the use of}} Low Rank <b>Parity</b> <b>Check</b> Codes, originally designed for cryptography applications {{in the context of}} Power Line Communication. Particularly, we propose a new code design and an efficient probabilistic decoding algorithm. The main idea of decoding Low Rank <b>Parity</b> <b>Check</b> Codes is based on calculations of vector spaces over a finite field math formula. Low Rank <b>Parity</b> <b>Check</b> Codes {{can be seen as the}} identical of Low Density <b>Parity</b> <b>check</b> codes. We compare the performance of this code against the Reed-Solomon Code through a Power Line Communication channel...|$|R
40|$|We propose several {{improvements}} for Linear Programming (LP) decoding algorithms for High Density <b>Parity</b> <b>Check</b> (HDPC) codes. First, {{we use the}} automorphism {{groups of}} a code to create <b>parity</b> <b>check</b> matrix diversity and to generate valid cuts from redundant <b>parity</b> <b>checks.</b> Second, we propose an efficient mixed integer decoder utilizing the branch and bound method. We further enhance the proposed decoders by removing inactive constraints and by adapting the <b>parity</b> <b>check</b> matrix prior to decoding according to the channel observations. Based on simulation results the proposed decoders achieve near-ML performance with reasonable complexity. Comment: Submitted to the IEEE Transactions on Communications, November 200...|$|R
5000|$|A {{generator}} matrix {{can be used}} {{to construct}} the <b>parity</b> <b>check</b> matrix for a code (and vice versa). If the generator matrix G is in standard form, [...] , then the <b>parity</b> <b>check</b> matrix for C is ...|$|R
5000|$|B1: Bit Error Monitoring. The B1 Byte {{contains}} {{the result of}} the <b>parity</b> <b>check</b> of the previous STM frame, after scrambling of the actual STM frame. This check is carried out with a Bit Interleaved <b>Parity</b> <b>check</b> (BIP-8).|$|R
5000|$|Static RAM {{consists}} of 16 / 24 / 32 / 40 KB general purpose with hardware <b>parity</b> <b>check,</b> 0 / 8 KB core coupled memory (CCM) with hardware <b>parity</b> <b>check,</b> 64 / 128 bytes battery-backed with tamper-detection erase.|$|R
3000|$|... of the <b>parity</b> <b>check</b> matrix is non-null. Decoding {{algorithms}} {{based on}} Tanner graphs are iterative, based on exchanging information between <b>parity</b> <b>check</b> nodes and variable nodes. Belief propagation {{is applied to}} Tanner graphs to efficiently decode LDPC codes [20, 21].|$|R
50|$|A {{fixed rate}} erasure code, usually {{with a fairly}} high rate, is applied as a 'pre-code' or 'outer code'. This pre-code may itself be a {{concatenation}} of multiple codes, for example in the code standardized by 3GPP a high density <b>parity</b> <b>check</b> code derived from the binary Gray sequence is concatenated with a simple regular low density <b>parity</b> <b>check</b> code. Another possibility would be a concatenation of a Hamming code with a low density <b>parity</b> <b>check</b> code.|$|R
5000|$|B2 : Bit Error Monitoring. The B2 Bytes {{contains}} {{the result of}} the <b>parity</b> <b>check</b> of the previous STM frame, except the RSOH, before scrambling of the actual STM frame. This check is carried out with a Bit Interleaved <b>Parity</b> <b>check</b> (BIP24) ...|$|R
40|$|In this paper, we {{investigate}} an efficient encoding approach for generalized low-density (GLD) <b>parity</b> <b>check</b> codes, a generalization of Gallager's low-density <b>parity</b> <b>check</b> (LDPC) codes. We propose a systematic approach to construct approximate upper triangular GLD <b>parity</b> <b>check</b> matrix which defines {{a class of}} efficientencoding GLD codes. It's shown that such GLD codes have equally good performance. By effectively exploiting the structure sharing in the encoding process, we also present a hardware/software codesign for the practical encoder implementation of these efficientencoding GLD codes...|$|R
40|$|A {{class of}} codes {{defined by the}} <b>parity</b> <b>check</b> matrix of a linear code of minimum {{distance}} at least t + 1 is examined {{and the number of}} <b>parity</b> <b>check</b> symbols is discussed. Determinants of this type are known as alternants (Muir and Metzler, 1930); codes corresponding to such a matrix are termed alternant codes. The <b>parity</b> <b>check</b> matrix is obtained by restricting some of its elements to subfields of GF(q to the m-th power). Minimum distance and redundancy bounds are established for these codes, and some interesting equivalence and invariance properties are derived...|$|R
3000|$|... {{and each}} {{independent}} <b>parity</b> <b>check</b> is tested. If all the <b>parity</b> <b>checks</b> are satisfied, decoding is terminated with a valid decoded code word, {{and the information}} bits are recovered by inverse mapping. If not, but {{the maximum number of}} iterations has been executed, a known decoding failure occurs. Otherwise, another iteration of the algorithm is performed. We use this schedule of updates and <b>parity</b> <b>checks</b> for the TDMP algorithm (with alternating message-passing and parity-check phases) as a benchmark in the article and refer to it as the TDMP algorithm with the standard schedule.|$|R
40|$|Simple {{arguments}} {{suggest that}} shortened codes must have distance properties {{equal to or}} better than those of their parent codes, {{and that they should}} be equally practical to decode. This relationship holds true in the case of low density generator codes and low density <b>parity</b> <b>check</b> codes. We investigate the properties of shortened turbo codes. I. Motivation for Shortening In our previous work on codes based on very sparse matrices we have observed that while codes with a low density generator matrix [1] are asymptotically bad, codes with a low density <b>parity</b> <b>check</b> matrix [2] are asymptotically good [3, 4, 5]. One way of viewing the relationship between low density generator matrix codes and low density <b>parity</b> <b>check</b> matrix codes is that one obtains a low density <b>parity</b> <b>check</b> matrix by taking the M Θ N <b>parity</b> <b>check</b> matrix [P IM] of a (N; K) low density generator matrix code and chopping off its right-most M columns (where M = N Γ K), to yield an M Θ K matrix [P], which [...] ...|$|R
40|$|Recently {{there has}} been {{interest}} {{in the construction of}} small <b>parity</b> <b>check</b> sets for iterative decoding of the Hamming code with the property that each uncorrectable (or stopping) set of size three is the support of a codeword and hence uncorrectable anyway. Here we reformulate and generalise the problem, and improve on this construction. First we show that a <b>parity</b> <b>check</b> collection that corrects all correctable erasure patterns of size m for the r-th order Hamming code (i. e, the Hamming code with codimension r) provides for all codes of codimension $r$ a corresponding ``generic'' <b>parity</b> <b>check</b> collection with this property. This leads naturally to a necessary and sufficient condition on such generic <b>parity</b> <b>check</b> collections. We use this condition to construct a generic <b>parity</b> <b>check</b> collection for codes of codimension r correcting all correctable erasure patterns of size at most m, for all r and m = 3 and r large enough. Finally we discuss some directions for further research. Comment: 13 pages, no figures. Submitted to IEEE Transactions on Information Theory, July 28, 200...|$|R
40|$|Error {{correcting}} codes prevent loss {{of integrity}} in data transmission. Low Density <b>Parity</b> <b>Check</b> codes are {{a family of}} codes that are specified by sparse matrices. Using the Nelder-Mead Downhill Simplex Evolution to design an irregular Low Density <b>Parity</b> <b>Check</b> code, we hope to improve upon the accuracy of decoding...|$|R
5000|$|... 4532624 <b>Parity</b> <b>checking</b> {{arrangement}} for a {{remote switching unit}} network ...|$|R
40|$|It is {{proposed}} {{a method for}} dynamically changing the low-density <b>parity</b> <b>check</b> code parameters in accordance with communication channel qualit y monitoring and device for storing, dynamic selection of <b>parity</b> <b>check</b> matrices and error-correcting encoding. Finally, results of the simulation codes characteristics and performance, which prove the effectiveness of proposed method, are presented...|$|R
40|$|A {{simple but}} {{effective}} decoding procedure, applicable to any (n,k) linear block code with symbols from GF(q), is described. The technique involves {{a transformation of}} the <b>parity</b> <b>check</b> equations which focuses the code's correction power on the soft symbol set while still retaining the capability to correct one symbol error from outside this set. The soft symbol set is defined to be the n-k least reliably detected code symbol positions whose <b>parity</b> <b>check</b> row-spaces are linearly independent. The process generates a number of error vector screening candidates, each {{a solution to the}} <b>parity</b> <b>check</b> equations, and the maximum-likelihood candidate is accepted...|$|R
40|$|The {{information}} hiding deals with distortion reduction using steganography and security enhancement using cryptography. Distortion reduction is done using Tree Based <b>Parity</b> <b>Check</b> which uses Majority vote strategy. The Tree Based <b>Parity</b> <b>Check</b> is very optimal for cloaking {{a message on}} image. The proposed majority vote strategy results in least distortion. The SHA- 1 algorithm is implemented for security enhancement. The result obtained in proposed method works effectively even with large payload. Codes to improve the computational complexity of wet paper codes derive d a hash function to efficiently obtain the stego object. Proposed a scheme called tree-based <b>parity</b> <b>check...</b>|$|R
30|$|To {{make the}} {{encoding}} and decoding of LDPC codes in DVB-T 2 more efficient, the sparse {{part of the}} <b>parity</b> <b>check</b> matrix {{is designed to be}} in a quasi-cyclic form [25, 26]. Thus, further efficient manipulation {{of the structure of the}} <b>parity</b> <b>check</b> matrix can make it suitable for layered decoding [27 – 29].|$|R
40|$|Abstract—Foward error {{correction}} (FEC) {{scheme based on}} low density <b>parity</b> <b>check</b> codes (LDPC) codes is presented in this paper. We show that LDPC codes provide a significant system performance enhancement {{with respect to the}} state-of-the-art FEC schemes employed in optical communication systems. Index Terms—Forward {{error correction}}, long-haul transmis-sion, low-density <b>parity</b> <b>check</b> codes, optical communications. I...|$|R
40|$|Till now {{communication}} is possible of 7 bit information data string by transmitting 11 bit data string in single frame {{due to this}} speed of communication system is very slow. And we can transmit very minimum number of configuration of data string. To increase the speed of communication system and increase the numbers of configuration data string author design some communication system by different methodologies of Hamming code. About all these communication systems all methodologies are discuss here. First, author design communication system to make communication by even <b>parity</b> <b>check</b> method for 25 bit information data string. In second paper, author design communication system to make communication by odd <b>parity</b> <b>check</b> method for 25 bit information data. In third paper, author again design communication system for 25 bit information data string by even parity and odd <b>parity</b> <b>check</b> method by using VHDL by single system. Till now, for 25 bit information data string {{communication is}} possible only in simplex mode. So that now author, design 25 bit hamming code transceiver to make communication possible in full duplex mode. Key word Hamming code, VHDL code, Xilinx ISE 10. 1 simulator, even <b>parity</b> <b>check,</b> odd <b>parity</b> <b>check,</b> transmitter, receiver, transceiver...|$|R
5000|$|... #Subtitle level 3: <b>Parity</b> <b>checking</b> {{limited to}} only 6 of 10 bits ...|$|R
50|$|In the Hagelbarger code, {{inserted}} <b>parity</b> <b>check</b> bits {{are spread}} out in time so that an error burst {{is not likely to}} affect more than one of the groups in which <b>parity</b> is <b>checked.</b>|$|R
50|$|Each packet {{consisted}} of a 32-bit header and a 16-bit header <b>parity</b> <b>check</b> word, followed by up to 80 bytes of data and a 16-bit <b>parity</b> <b>check</b> word for the data. The header contained address information identifying a particular user {{so that when the}} Menehune broadcast a packet, only the intended user's node would accept it.|$|R
5000|$|Any [...] {{columns of}} a <b>parity</b> <b>check</b> matrix for [...] are linearly independent.|$|R
40|$|Abstract — To achieve high throughput, {{parallel}} decoding of low density <b>parity</b> <b>check</b> (LDPC) codes is required, but needs a large set of registers {{and complex}} interconnection due to randomly located 1 ’s in a sparse <b>parity</b> <b>check</b> matrix of large block size. This paper proposes a memory-based decoding architecture for low density <b>parity</b> <b>check</b> codes using loosely coupled two data flows. Instead of register, intermediate values are optimally grouped and scheduled to store into the segmented memory, which reduces large area and enables a scalable architecture. The {{performance of the}} proposed decoder architecture is demonstrated by implementing a 1024 bit, rate- 1 / 2 LDPC codes decoder. I...|$|R
40|$|This paper {{presents}} high-performance encoder and decoder architectures for a {{class of}} Low Density <b>Parity</b> <b>Check</b> (LDPC) codes. The codes considered here {{are based on the}} Parallelly Concatenated <b>Parity</b> <b>Check</b> encoder structure. A major advantage of these codes is that the generator matrix and the <b>parity</b> <b>check</b> matrix are both sparse, which leads to efficient VLSI implementations for the encoder and the decoder. Our designs use 6 -bit quantization with a code rate of 8 / 9 and a block size of 576 bits. An evaluation of the speed and hardware complexity is given, and simulation results for the bit error rate are obtained...|$|R
40|$|To achieve high throughput, {{parallel}} decoding of low density <b>parity</b> <b>check</b> (LDPC) codes is required, but needs a large set of registers {{and complex}} interconnection due to randomly located 1 ’s in a sparse <b>parity</b> <b>check</b> matrix of large block size. This paper proposes a memory-based decoding architecture for low density <b>parity</b> <b>check</b> codes using loosely coupled two data flows. Instead of register, intermediate values are optimally grouped and scheduled to store into the segmented memory, which reduces large area and enables a scalable architecture. The {{performance of the}} proposed decoder architecture is demonstrated by implementing a 1024 bit, rate- 1 / 2 LDPC codes decoder. 1...|$|R
5000|$|Inner encoding: a Low Density <b>Parity</b> <b>Check</b> (LDPC) code is {{cascaded}} to the BCH ...|$|R
40|$|An {{algorithm}} for encoding low-density <b>parity</b> <b>check</b> (LDPC) codes is investigated. The algorithm computes <b>parity</b> <b>check</b> symbols by {{solving a}} set of sparse equations, and the triangular factorization is employed to solve the equations efficiently. It is shown analytically and experimentally that the proposed algorithm is more efficient than the Richardson's encoding algorithm if the code has a small gap...|$|R
40|$|International audienceWe {{consider}} {{in this paper}} the problem of blind frame synchronization of systems using reed-Solomon (RS) codes and other related families. We present first of all three techniques of blind frame synchronization based on the non-binary <b>parity</b> <b>check</b> matrix of RS codes. While the first two techniques involve the calculation of hard and soft values of the syndrome elements respectively, the third one perform an adaptation step of the <b>parity</b> <b>check</b> matrix before applying the soft criterion. Although RS codes are constructed from non-binary symbols, we show in this paper that {{it is also possible}} to synchronize them using the binary image expansion of their <b>parity</b> <b>check</b> matrix. Simulation results show that the synchronization algorithm based on the adaptation of the binary <b>parity</b> <b>check</b> matrix of RS codes has the best synchronization performance among all other techniques. Furthermore, the Frame Error Rate (FER) curves obtained after synchronization and decoding are very close to the perfect synchronization curves...|$|R
40|$|In {{this thesis}} {{properties}} of two-dimensional arrayed circulant <b>parity</b> <b>check</b> matrix {{are used in}} order to determine a good estimation for determining burst error correcting capability of cyclic codes. The Thesis Project will highlight the computation of burst error correcting codes of code rates that are higher than (2 / 7) and possessing relatively higher minimum weights as compared to legacy burst error correcting codes such as the Reed Solomon (RS) codes and Bose, Ray-Chaudhuri and Hocquenghem (BCH). Thesis project starts by developing a circulant <b>parity</b> <b>check</b> matrix. For instance, for an (n, k) cyclic code, an (n x n) circulant <b>parity</b> <b>check</b> matrix, corrects burst errors of lengths up to the error-bust correcting limit of the circulant cyclic code. This {{is due to the fact}} that circulant <b>parity</b> <b>check</b> matrices are a class of linear block codes. The code will have maximum burst error correcting capability because the code specification regulates the maximum burst error correction capacity...|$|R
40|$|We {{consider}} {{in this paper}} the problem of blind frame synchronization of systems using Reed-Solomon (RS) codes and other related families. We present first of all three techniques of blind frame synchronization based on the non-binary <b>parity</b> <b>check</b> matrix of RS codes. While the first two techniques involve the calculation of hard and soft values of the syndrome elements respectively, the third one perform an adaptation step of the <b>parity</b> <b>check</b> matrix before applying the soft criterion. Although RS codes are constructed from non-binary symbols, we show in this paper that {{it is also possible}} to synchronize them using the binary image expansion of their <b>parity</b> <b>check</b> matrix. Simulation results show that the synchronization algorithm based on the adaptation of the binary <b>parity</b> <b>check</b> matrix of RS codes has the best synchronization performance among all other techniques. Furthermore, the Frame Error Rate (FER) curves obtained after synchronization and decoding are very close to the perfect synchronization curves. 1...|$|R
