4|4|Public
50|$|Among {{other things}} the <b>Language-Sensitive</b> <b>Editor</b> and EVE (Extensible Versatile Editor) are {{implemented}} using DECTPU.|$|E
50|$|<b>Language-Sensitive</b> <b>Editor</b> (LSE) is a full-screen visual {{editor for}} the VAX/VMS and OpenVMS Operating systems. LSE is {{implemented}} by using the Text Processing Utility (TPU) language. It {{is part of the}} DECset programming tool set, which also contains a test manager, the performance and coverage analyzer (PCA), a code management system (CMS), and a module management mystem (MMS).|$|E
50|$|In linguistics, syntax is {{the study}} of the {{structure}} of grammatical utterances, and accordingly syntax-directed editor is a synonym for structure editor. Language-based editor and <b>language-sensitive</b> <b>editor</b> are also synonyms. A language-based editor’s features may be implemented by ad hoc code or by a formal grammar. For example, language sensitivity in Emacs is implemented in the Lisp definition of the edit mode for the given language. In contrast, language sensitivity in an XML editor is driven by a formal DTD schema for the given language.|$|E
50|$|It {{is common}} for a {{language}} sensitive editor to represent a document as a parse tree with respect to language’s grammar, or as an abstract syntax tree (AST). For example, a DOM tree is essentially an AST {{with respect to a}} given DTD. Frequently, the textual view of that underlying tree is generated by prettyprinting the underlying tree. Editors associated with intentional programming and language-oriented programming for general-purpose languages and domain-specific languages share many of the features of <b>language-sensitive</b> <b>editors,</b> but aim for greater separation between the underlying representation (the intention) and the surface representation (text in a programming language).|$|R
40|$|This thesis {{deals with}} {{techniques}} for raising the programming level {{for a particular}} kind of computations, namely those on abstract syntax trees. Such computations are central in tools that manipulate programs, e. g., compilers, smart <b>language-sensitive</b> <b>editors,</b> software metric tools, etc. Our work is based on Reference Attributed Grammars (RAGs) which combines object-oriented features with declarative programming to specify computations on abstract syntax trees. RAGs have proven useful, e. g., for performing static-semantic analysis of object-oriented languages. We investigate new applications of RAGs, extensions of RAGs in order to cover yet more applications, modularization issues for RAGs, and implementation of RAG evaluators. The thesis consists of an introduction and three papers. The first paper deals with the application of RAGs to a new problem area: program visualization. The second paper describes JastAdd, a practical system fo...|$|R
50|$|A syntax-directed editor may treat grammar {{rules as}} {{generative}} (e.g., offering the user templates {{that correspond to}} one or more steps in a formal derivation of program text) or proscriptive (e.g., preventing a phrase of a given part of speech from being moved to a context where another part of speech is required) or analytic (e.g., parsing textual edits to create a structured representation). Structure editing features in source code editors make it harder to write programs with invalid syntax. <b>Language-sensitive</b> <b>editors</b> may impose syntactic correctness as an absolute requirement (e.g., as did Mentor), or may tolerate syntax errors after issuing a warning (e.g., as did the Cornell Program Synthesizer). Strict structured editors often make it difficult to perform edits that are easy to perform with plain text editors, {{which is one of the}} factors contributing to the lack of adoption of structured editing in some domains, such as source code editing.|$|R
40|$|We {{introduce}} a tool we are developing {{that will allow}} designers of trusted applications to isolate those portions of a system where an information flow policy is being violated. The tool is a <b>language-sensitive</b> <b>editor</b> that checks a program for policy violations incrementally as the program is developed. What is novel about our approach is that the checking occurs {{as a form of}} type checking. 1...|$|E
40|$|This paper {{presents}} an algorithm for incremental chart parsing, outlines {{how this could}} be embedded in an interactive parsing system, and discusses why this might be useful. Incremental parsing here means that input is analysed in a piecemeal fashion, in particular allowing arbitrary changes of previous input without exhaustive reanalysis. Interactive parsing means that the analysis process is prompted immediately {{at the onset of}} new input, and possibly that the system then may interact with the user in order to resolve problems that occur. The combination of these techniques {{could be used as a}} parsing kernel for highly interactive and 'reactive naturallanguage processors, such as parsers for dialogue systems, interactive computer-aided translation systems, and <b>language-sensitive</b> text <b>editors.</b> An incremental chart parser embodying the ideas put forward in this paper has been implemented, and an embedding of this in an interactive parsing system is near completion...|$|R

