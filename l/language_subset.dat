38|279|Public
50|$|G95 is a free, portable, {{open source}} Fortran 95 compiler. It {{implements}} the Fortran 95 standard, {{part of the}} Fortran 2003 standard, {{as well as some}} old and new extensions including features for the Fortran 2008 standard like coarray Fortran. When invoked with the -std=F source code is limited to the F programming <b>language</b> <b>subset.</b>|$|E
50|$|In {{the design}} {{synthesis}} role (transformation of a hardware-design description into a gate-netlist), SystemVerilog adoption has been slow. Many design teams use design flows which involve multiple tools from different vendors. Most design teams cannot migrate to SystemVerilog RTL-design until their entire front-end tool suite (linters, formal verification and automated test structure generators) support a common <b>language</b> <b>subset.</b>|$|E
50|$|The first Intel 8008 {{assembly}} language {{was based on}} a very simple (but systematic) syntax inherited from the Datapoint 2200 design. This original syntax was later transformed into a new, somewhat more traditional, {{assembly language}} form for this same original 8008 chip. At about the same time, the new assembly language was also extended to accommodate the added addressing possibilities in the more advanced Intel 8080 chip (the 8008 and 8080 shared a <b>language</b> <b>subset</b> without being binary compatible; however, the 8008 was binary compatible with the Datapoint 2200).|$|E
40|$|Abstract. Different design {{languages}} {{are used for}} hardware and software domains. The most popular ones are VHDL and C++. Recently, SystemC language was developed aiming to bridge both domains. In this paper, we compare these {{design languages}} by separating and analysing {{the capabilities of the}} different <b>language</b> <b>subsets</b> with respect to the implementation of the different programming paradigms. Our analysis illustrates that the considered design languages show a great deal of similarity, despite different domains of application. We demonstrate the usage of the <b>language</b> <b>subsets</b> in a case study (design of a generic calculator model) ...|$|R
50|$|The {{language}} is notable {{for being an}} early object-capability <b>subset</b> <b>language.</b> It has influenced later <b>subset</b> <b>languages,</b> such as ADsafe and Caja/Cajita, subsets of Javascript.|$|R
5000|$|Gallo-Romance <b>{{languages}},</b> a <b>subset</b> of the Romance languages (e.g. French, Occitan, Lombard) ...|$|R
50|$|Libraries unify {{access to}} {{databases}} {{by providing a}} single low-level programming interface to the application developer. Their advantages are most often speed and flexibility {{because they are not}} tied to a specific query <b>language</b> (<b>subset)</b> and only have to implement a thin layer to reach their goal. As all SQL dialects are similar to one another, application developers can use all the language features, possibly providing configurable elements for a database-specific cases, such as, typically, user-IDs and credentials. A thin-layer allows the same queries and statements to run on a variety of database products with a negligible overhead.|$|E
5000|$|Bellard's entries won the International Obfuscated C Code Contest twice. In 2000, he {{won in the}} {{category}} [...] "Most Specific Output" [...] for a program that implemented the modular Fast Fourier Transform {{and used it to}} compute the then biggest known prime number, 26972593−1; and in 2001, he won in {{the category}} [...] "Best Abuse of the Rules" [...] for a tiny compiler (the source code being only 3 kB in size) of a strict subset of the C language for i386 Linux. The program itself is written in this <b>language</b> <b>subset,</b> i.e. it is self-hosting.|$|E
40|$|Ergodic, continuous-observation, hidden Markov models (HMMs) {{were used}} to perform {{automatic}} language classification and detection of speech messages. State observation probability densities were modeled as tied Gaussian mixtures. The algorithm was evaluated on four multilanguage speech databases: a three <b>language</b> <b>subset</b> of the Spoken Language Library, a three <b>language</b> <b>subset</b> of a five language Rome Laboratory database, the 20 language CCITT database, and the ten language OGI telephone speech database. Generally, performance of a single state HMM (i. e, a static Gaussian mixture classifier comparable to the multistate HMMs, indicating that th;: quential modeling capabilities of HMMs were not exploited. 1...|$|E
40|$|This paper {{presents}} a genetic algorithm based {{approach to the}} automatic discovery of finite-state automata (FSAs) from positive data. FSAs are commonly used in computational phonology, but - given the limited learnability of FSAs from arbitrary <b>language</b> <b>subsets</b> - are usually constructed manually. The approach presented here offers a practical automatic method that helps {{reduce the cost of}} manual FSA construction...|$|R
50|$|SP/k is {{actually}} a sequence of <b>language</b> <b>subsets</b> called SP/1, SP/2, … SP/8. Each subset introduces new programming language constructs while retaining all the constructs of preceding subsets, forming a stepwise system for teaching computer programming. Each subset is precisely defined and self-contained, and can be learned or implemented without the following subsets. This allows for various levels of programming education. The design and philosophy of SP/k was a strong influence on the Turing programming language.|$|R
40|$|Recent {{developments}} in game semantics {{have led to}} fully abstract models {{for a variety of}} theoretically important programming languages. While the full-blown game models tend to be complex and unwieldy for practical purposes, <b>language</b> <b>subsets</b> without higher-order and recursive functions allow greatly simplied models. Two previous papers of the author show how imperative languages with rst order functions, local variables and arrays can be modeled using regular languages only. This paper examines the possibility of using these theoretical developments as a basis for model-checking Hoare-style partial correctness statements for such languages. The model-checking problem is shown to be decidable. ...|$|R
40|$|This {{research}} {{investigates the}} combination of task and data parallel language constructs within a single programming language. There are an number of applications that exhibit properties which would be well served by such an integrated language. Examples include global climate models, aircraft design problems, and multidisciplinary design optimization problems. Our approach incorporates data parallel language constructs into an existing, object oriented, task parallel language. The language will support creation and manipulation of parallel classes and objects of both types (task parallel and data parallel). Ultimately, the language will allow data parallel and task parallel classes to be used either as building blocks or managers of parallel objects of either type, thus allowing the development of single and multi-paradigm parallel applications. 1995 Research Accomplishments In February I presented a paper at Frontiers 1995 describing {{the design of the}} data parallel <b>language</b> <b>subset.</b> During the spring I wrote and defended my dissertation proposal. Since that time I have developed a runtime model for the <b>language</b> <b>subset.</b> I have begun implementing the model and hand-coding simple examples which demonstrate the <b>language</b> <b>subset.</b> I have identified an astrophysical fluid flow application which will validate the data parallel <b>language</b> <b>subset.</b> 1996 Research Agenda Milestones for the coming year include implementing {{a significant portion of the}} data parallel <b>language</b> <b>subset</b> over the Legion system. Using simple hand-coded methods, I plan to demonstrate (1) concurrent task and data parallel objects and (2) task parallel objects managing both task and data parallel objects. My next steps will focus on constructing a compiler and implementing the fluid flow application with the language. Concurrently, I will conduct a search for a real-world application exhibiting both task and data parallelism within the same program. Additional 1995 Activities During the fall I collaborated with Andrew Grimshaw and Adam Ferrari to write a book chapter which will be included in Parallel Processing in C++ edited by Gregory Wilson. I also finished two courses, Compilers and Advanced Compilers, in 1995. These courses complete my class requirements at the University of Virginia. I have only my dissertation research and defense to complete...|$|E
40|$|This paper {{gives an}} {{overview}} of safer language subsets in general and considers one widely-used one, MISRA C, in particular. The rationale, specification, implementation and enforcement of a safer <b>language</b> <b>subset</b> each introduce particular problems {{which has led to}} their inconsistent take-up over the years even in applications which may be safety-related and definitely need subset restrictions. Each of these areas will be discussed illustrating practical problems which may be encountered with standards in general before focussing on the widely used MISRA C standard, MISRA (1998). The approach taken is necessarily empirical and where it is able quotes measurements. The real objective {{of this paper is to}} produce an empirically based taxonomy of programming <b>language</b> <b>subset</b> rules to bring all these issues together and promote the concept that a safer subset must be based on measurement principles however crudely they are practised currently in software development. The concept of signal to noise ratio of a programming standard is also introduced...|$|E
40|$|The {{purpose of}} this paper is (1) to make an {{extensive}} overview of the field of diacritics restoration in Romanian texts, (2) to present our own experiments and results and to promote the use of the word-based Viterbi algorithm as a better accuracy solution used already in a free web-based TTS implementation, (3) to announce the production of a new, high-quality, high-volume corpus of Romanian texts, twice the size of the Romanian <b>language</b> <b>subset</b> of the JRC-Acquis...|$|E
40|$|Abstract. Grace is a {{gradually}} typed, {{object-oriented language}} {{for use in}} ed-ucation; consonant with that use, {{we have tried to}} keep Grace as simple and straightforward as possible. Grace needs a module system for several reasons: to teach students about modular program design, to organise large programs, es-pecially its self-hosted implementation, to provide access to resources defined in other languages, and to support different “dialects ” — <b>language</b> <b>subsets,</b> or do-main specific languages, for particular parts of the curriculum. Grace already has several organising constructs; this paper describes how Grace uses two of them, objects and lexical scope, to provide modules and dialects. ...|$|R
40|$|State Machine (ASM) rules {{reflecting}} the specification {{given in the}} SpecC Language Reference Manual [5]. We mainly see our formal semantics in three application areas. First, it can {{be taken as a}} high [...] level, pseudo code [...] oriented specification for the implementation of a SpecC simulator which is outlined in a separate section. Second, it is a concise, unambiguous description for documentation and standardization. Finally, it is a first step for SpecC synthesis in order to identify similar concepts with other languages like VHDL and SystemC for the definition of common patterns and <b>language</b> <b>subsets...</b>|$|R
40|$|International audienceThe aim of {{this paper}} is the study of {{asynchronous}} automata, a special kind of automata which encode the independency relation between actions and which enable their concurrent execution. These automata, introduced by Zielonka, constitute a natural extension of finite automata to the case of asynchronous parallelism. Their behaviour is described by trace <b>languages,</b> <b>subsets</b> of partially commutative monoids. The main result concerning this class of automata states that they accept exactly all recognizable trace languages. In this paper we give new improved constructions of asynchronous automata. In the final part of the paper we present a distributed system of messages with bounded time-stamps based on asynchronous automata...|$|R
40|$|Presented {{contribution}} {{is dedicated to}} discussion of two different approaches into increase of programming language safety. They are <b>language</b> <b>subset</b> and extension of original safety mechanisms. As examples we used MISRA C/C++ subset and SPARK language builded {{on the base of}} ADA language. In the last chapters we discuss novel approaches based on application of programmable hardware which is described in VHDL language, which is also modification of ADA language. Especially SPARK and VHDL languages represents novel approaches to safe system development which are now discussed in relation to new Railway SW projects...|$|E
40|$|This is {{a conference}} paperA list of {{requirements}} for a genetic programming representation is put forward and a representation separating the genotype and phenotype with a linear genome is presented. The target language for the genetic program is Perl. The mapping process, between the genotype and phenotype, converts blocks of four genes into program statements. This process is context-free and therefore provides inheritable characteristics. The representation is tested by evolving {{a selection of}} list evaluation and manipulation functions which are all evolved from the same <b>language</b> <b>subset,</b> with good results...|$|E
40|$|The current {{model for}} the predicates, or “Assertions”, used in a WS-Policy {{instance}} is for each policy domain to design new schema elements for that domain's Assertions. Their semantics are defined in an associated specification and are domain-specific. This model leads to interoperability and maintenance problems and hinders dynamic service composition. WS-PolicyConstraints is a domain-independent language for writing Assertions {{that is based on}} the Web Services Policy <b>Language</b> <b>subset</b> of XACML; it differs in addressing only the Assertion layer. This paper describes problems with domain-specific Assertions, the WS-PolicyConstraints alternative, and problems encountered in the development of this language. 1...|$|E
40|$|Good error {{messages}} {{are critical for}} novice programmers. Recognizing this, the DrRacket programming environment provides a series of pedagogically-inspired <b>language</b> <b>subsets</b> with {{error messages}} customized to each subset. We apply human-factors research methods to explore {{the effectiveness of these}} messages. Unlike existing work in this area, we study messages at a finegrained level by analyzing the edits students make in response to various classes of errors. We present a rubric (which is not language specific) to evaluate student responses, apply it to a courseworth of student lab work, and describe what we have learned about using the rubric effectively. We also discuss some concrete observations on the effectiveness of these messages...|$|R
5000|$|The code is {{also often}} {{examined}} by special programs that analyze correctness (Static code analysis), such as SPARK examiner for the SPARK (a {{subset of the}} Ada programming language) or lint for the C-family of programming languages (primarily C, though).The compilers or special checking programs like [...] "lint" [...] {{check to see if}} types of data are compatible with the operations on them, also such tools are regularly used to enforce strict usage of valid programming <b>language</b> <b>subsets</b> and programming styles.Another set of programs measure software metrics, to look for parts of the code that are likely to have mistakes.All the problems are fixed, or at least understood and double-checked.|$|R
40|$|AbstractThe aim of {{this paper}} is the study of {{asynchronous}} automata, a special kind of automata which encode the independency relation between actions and which enable their concurrent execution. These automata, introduced by Zielonka (RAIRO Inform. Theor. Appl. 21, 99 - 135 (1987)), constitute a natural extension of finite automata to the case of asynchronous parallelism. Their behaviour is described by trace <b>languages,</b> <b>subsets</b> of partially commutative monoids. The main result concerning this class of automata states that they accept exactly all recognizable trace languages. In this paper we give new improved constructions of asynchronous automata. In the final part of the paper we present a distributed system of messages with bounded time-stamps based on asynchronous automata...|$|R
40|$|Abstract. A lot {{of recent}} {{linguistic}} theories are feature-based and heavely rely upon {{the concept of}} constraint. Several authors have pointed out the similitude existing between {{the representation of the}} features on featurebased theories and the notions of objects or frames. Oriented object configuration allows us to deal with these modern grammars. We propose here a systematic translation of the concepts and constraints introduced by two linguistic formalisms: the very useful HPSG and the recent property grammars to configuration problems representing specific target languages. We assess the usefulness of these translations by studying first a part of the grammar for english proposed by the HPSG’s authors then a natural <b>language</b> <b>subset</b> with lexical ambiguities, using property grammars. ...|$|E
40|$|We {{present a}} {{comparison}} between speaker verification systems based on factor analysis modeling and support vector machines using GMM supervectors as features. All systems used the same acoustic features and they were trained and tested on the same data sets. We test two types of kernel (one linear, the other non-linear) for the GMM support vector machines. The results show that factor analysis using speaker factors gives the best results on the core condition of the NIST 2006 speaker recognition evaluation. The difference is particularly marked on the English <b>language</b> <b>subset.</b> Fusion of all systems gave an equal error rate of 4. 2 % (all trials) and 3. 2 % (English trials only), 1...|$|E
40|$|The DEVS {{formalism}} supports {{modeling of}} discrete event systems in a hierarchical, modular manner {{based on the}} ob-ject-oriented world view. System modeling requires not only understanding of modeling framework but also domain kno-wledge of the system. Therefore, successful modeling may need a means to represent a system which is understandable to both domain experts and M&S experts. This paper propo-ses an employment of a UML(Unified Modeling <b>Language)</b> <b>subset</b> as such a means at a {{front end of the}} DEVS modeling process. Thus, the UML subset specifies behavior of objects in general; DEVS refines such behavior with additional info-rmation which is required for discrete event models. A case study demonstrates effectiveness of the proposed methodol-ogy [...] 1...|$|E
5000|$|Although {{originally}} a geophysicist {{during which time}} {{he was awarded the}} 1987 Conrad Schlumberger Award for his work in computational geophysics, he switched careers in the early 1990s to study software and systems failure. He has published 4 books and over 100 refereed journal publications and his theoretical and experimental work on software systems failure can be found in IEEE Transactions on Software Engineering, IEEE Computer, IEEE Software, Nature, and IEEE Computational Science and Engineering. [...] His book Safer C [...] pioneered the use of safer <b>language</b> <b>subsets</b> in commercial embedded control systems. He was also cited amongst the leading scholars of systems and software engineering by the Journal of Systems and Software for the period 1997-2001.|$|R
40|$|Licensing {{constraints}} play {{an important}} role in the characterisation of phonological inventories within Government Phonology. They regulate the combinatory possibility of phonological elements available in a given language and thus derive <b>language</b> specific <b>subsets</b> out of all theoretically possible phonological expressions. While th...|$|R
5000|$|Kawi (from Sanskrit: kavi, [...] "poet") is a {{literary}} and prose language {{on the islands}} of Java, Bali, and Lombok, based on Old Javanese, a language with a sizable vocabulary of Sanskrit loanwords. Kawi is the ancestor language of modern Javanese. The name [...] "kawi" [...] {{is derived from the}} root ku, which in Sanskrit means “poet”, and, in derived forms, a “wise, educated man”. The syllabic meter of Kawi poetry is sekar kawi, which means “flowers of the language”, sekar itself deriving from the Sanskrit [...] "sekhara" [...] (“garland”). All Javanese languages are hierarchical and stratified, with strict social conventions for appropriate <b>language</b> <b>subsets</b> to be used for one's superiors or social and cultural functions. Kawi is commonly considered the pinnacle language.|$|R
40|$|Abstract-This {{case study}} {{examines}} {{the application of}} Grammatical Swarm to classification problems, and illustrates the Particle Swarm algorithms ’ ability to spify the construction of programs. Each individual particle represents choices of program construction rules, where these rules are specified using a Backus-Naur Form grammar. Two problem instances are tackled, the first a mushroom classification problem, the second a bioinformalics problem that involves the detection of eukaryotic DNA promoter sequences. For the first problem we generate solutions that {{take the form of}} conditional statements in a C-like <b>language</b> <b>subset,</b> and for the second problem we generate simple regular expressions. The results demonstrate {{that it is possible to}} generate programs using the Grammatical Swarm technique with a performance similar to the Grammatical Evolution evolutionary automatic programming approach. I...|$|E
40|$|The paper {{presents}} a FrameNet-based information extraction and knowledge representation framework, called FrameNet-CNL. The framework {{is used on}} natural language documents and represents the extracted knowledge in a tailor-made Frame-ontology from which unambiguous FrameNet-CNL paraphrase text can be generated automatically in multiple languages. This approach brings together the fields of information extraction and CNL, because a source text can be considered belonging to FrameNet-CNL, if information extraction parser produces the correct knowledge representation as a result. We describe a state-of-the-art information extraction parser used by a national news agency and speculate that FrameNet-CNL eventually could shape the natural <b>language</b> <b>subset</b> used for writing the newswire articles. Comment: CNL- 2014 camera-ready version. The final publication is available at link. springer. co...|$|E
40|$|The paper {{presents}} the EU funded MADES FP 7 project, {{that aims to}} develop an effective model driven methodology to evolve current practices {{for the development of}} real time embedded systems for avionics and surveillance industries. In MADES, we propose an effective SysML/MARTE <b>language</b> <b>subset</b> and have developed new tools and technologies that support high level design specifications, validation, simulation and automatic code generation, while integrating aspects such as component re-use. The paper first illustrates the MADES methodology by means of a car collision avoidance system case study, followed by the underlying MADES language design phases and tool set which enable verification and automatic code generation aspects, hence enabling implementation in execution platforms such as state of the art FPGAs...|$|E
50|$|The set of {{languages}} recognized by probabilistic automata are called stochastic languages. They include the regular <b>languages</b> as a <b>subset.</b>|$|R
50|$|Judgmental <b>{{language}}</b> is a <b>subset</b> of {{red herring}} fallacies. It employs insulting, compromising or pejorative language {{to influence the}} recipient's judgment.|$|R
50|$|Assertions {{are useful}} for verifying {{properties}} of a design that manifest themselves after a specific condition or state is reached. SystemVerilog has its own assertion specification language, similar to Property Specification <b>Language.</b> The <b>subset</b> of SystemVerilog <b>language</b> constructs that serves assertion is commonly called SystemVerilog Assertion or SVA.|$|R
