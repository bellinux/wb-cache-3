2|24|Public
5000|$|... Returns an {{iterator}} {{over all}} the triples (within the conjunctive graph or just the given context) matching the given pattern. The pattern is specified by providing explicit statement terms (which are used to match against nodes in the underlying store), or None - which indicates a wildcard. NOTE: This interface is expected to return an iterator of tuples of length 3, corresponding to the 3 terms of matching statements, which can be either of : URIRef, Blank Node, <b>Literal,</b> <b>Formula,</b> Variable, or (perhaps) a Context.|$|E
40|$|Elizabeth Johnson probes the {{theological}} implications of God symbolism, {{as well as}} the effect that symbolism has on conceptions of women 2 ̆ 7 s dignity and humanity. In the Boardman lecture, she argues that 2 ̆ 2 how a group names its God has critical consequences, for the symbol of the divine organizes every other aspect of a religious system. 2 ̆ 2 Professor Johnson engages the work of other Christian and Jewish scholars who have addressed this issue to illustrate how far we have come, and perhaps, how far we still have to go. She is careful to acknowledge the dangers of naming God 2 ̆ 2 She. 2 ̆ 2 One such danger is the possibility of losing the Christian heritage of the Trinity, which is based on the image of the Father, Son and Holy Spirit, all of whom have been imagined as male. However, Professor Johnson argues that the Trinity is not a 2 ̆ 2 <b>literal</b> <b>formula,</b> 2 ̆ 2 and that the gendered terms were never intended to be the only permissible images of God for Christians. She concluded that only when the full mystery of the living God who is so complex and powerful as to be beyond gender is understood, can we move past the 2 ̆ 2 idolatrous fixation on one image of God 2 ̆ 2 that has dominated Christian thinking...|$|E
5000|$|To each of {{the eight}} <b>literals</b> in this <b>formula</b> we assign one real {{variable}} in an eight-dimensional Euclidean space. The structure of the 2-SAT formula can be recovered when these variables are arranged in a table: ...|$|R
25|$|The {{method of}} tableaux works by {{starting}} with the initial set of formulae and then adding to the tableau simpler and simpler formulae until contradiction {{is shown in the}} simple form of opposite <b>literals.</b> Since the <b>formula</b> represented by a tableau is the disjunction of the formulae represented by its branches, contradiction is obtained when every branch contains a pair of opposite literals.|$|R
40|$|We {{introduce}} {{a family of}} matrices that define logics in which paraconsistency and/or paracompleteness occurs only {{at the level of}} <b>literals,</b> that is, <b>formulas</b> that are propositional letters or their iterated negations. We give a sound and complete axiomatization for the logic defined by the class of all these matrices, we give conditions for the maximality of these logics and we study in detail several relevant examples...|$|R
5000|$|A {{logical formula}} is {{considered}} to be in DNF if and only if it is a disjunction of one or more conjunctions of one or more <b>literals.</b> A DNF <b>formula</b> is in full disjunctive normal form if each of its variables appears exactly once in every clause. As in conjunctive normal form (CNF), the only propositional operators in DNF are and, or, and not. The not operator can only be used as part of a literal, which means that it can only precede a propositional variable.|$|R
40|$|In {{this work}} we {{investigate}} {{the behavior of}} the main existing fluent-indexed approaches to reasoning about actions in dealing with domains that have actions with both indeterminate and indirect effects. As they all fail in solving this kind of scenarios, we argue for an action-indexed causal notion {{in order to deal with}} the frame and ramification problems. This is achieved by defining a weak form of causality in terms of a dependence relation involving actions, <b>literals</b> and <b>formulae.</b> This relation allows the literals to change their truth value without forcing or causing it. Once integrated in the framework of a propositional logic close to PDL, it gives us a simple and powerful formalism to reasoning about actions and a decision procedure in terms of tableau methods. We also show how our approach can deal with scenarios involving indeterminate and indirect effects without being subjected to the same problems of other formalisms. In order to help the knowledge engineer in describing domains, we give an interactive algorithm for generating the required dependence information...|$|R
40|$|The {{topic of}} this chapter {{is the study}} of certain forms of “redundancies ” in propositional conjunctive normal forms and generalisations. In Sections 11. 1 - 11. 7 we study “minimally unsatisfiable conjunctive normal forms ” (and generalisations), unsatisfiable {{formulas}} which are irredundant in a strong sense, and in Sections 11. 8 - 11. 13 we study “autarkies”, which represent a general framework for considering redundancies. Finally in Section 11. 14 we collect some main open problems. A literal is a variable or a negated variable. Let X be a set of variables, then lit(X) is the set of literals over the variables in X. Clauses are disjunctions of literals. Clauses are also considered as sets of <b>literals.</b> A propositional <b>formula</b> in conjunctive normal form (CNF) is a conjunction of clauses. CNF formulas will b...|$|R
40|$|International audienceWater {{management}} {{is one of}} the most crucial issues to drive PEM fuel cells. The challenge is enhanced in the case of micro air-breathing proton exchange membrane fuel cells (ABFC) : their thinness and their reduced surface indeed make their hydration state fast changing and very sensitive to the experimental conditions (temperature and relative humidity ()). It can lead to strong flooding or drying out issues. Firstly, this study highlights this sensitivity by various measurements. Then a steady state macroscopic model for the ABFC is proposed, focusing on the cathode, using a rather original approach for diffusion in porous media. Finally, a <b>literal</b> steady state <b>formula</b> for the water content is provided, and its influences on the performances of the ABFC are explicitly proposed. The model is parameterized and compared to measures in several atmospheric conditions...|$|R
40|$|This paper {{addresses}} complexity {{issues for}} important problems arising with disjunctive databases. In particular, {{the complexity of}} inference of a <b>literal</b> and a <b>formula</b> from a propositional disjunctive database {{under a variety of}} wellknown disjunctive database semantics is investigated, as well deciding whether a disjunctive database has as model under a particular semantics. The problems are located in appropriate slots of the polynomial hierarchy. 1 Introduction Allowing to store disjunctions in a logical database is indispensable for dealing with disjunctive information. Accordingly, the meaning of a disjunctive database is expressed by a set of models instead of a single model as in case of nondisjunctive databases. A variety of different semantics for disjunctive databases has been proposed in the literature; see [9] for a comprehensive overview. We will deal with the following ones. ffl The Generalized Closed World Assumption (GCWA) by Minker [16]. ffl The Extended Generalized [...] ...|$|R
5000|$|SAT is trivial if the {{formulas}} {{are restricted}} to those in disjunctive normal form, that is, they are disjunction of conjunctions of <b>literals.</b> Such a <b>formula</b> is indeed satisfiable {{if and only if}} at least one of its conjunctions is satisfiable, and a conjunction is satisfiable if and only if it does not contain both x and NOT x for some variable x. This can be checked in linear time. Furthermore, if they {{are restricted to}} being in full disjunctive normal form, in which every variable appears exactly once in every conjunction, they can be checked in constant time (each conjunction represents one satisfying assignment). But it can take exponential time and space to convert a general SAT problem to disjunctive normal form; for an example exchange [...] "∧" [...] and [...] "∨" [...] in the above exponential blow-up example for conjunctive normal forms.|$|R
40|$|In many {{real-world}} domains {{the task}} of machine learning algorithms is to learn a theory predicting numerical values. In particular several standard test domains used in Inductive Logic Programming (ILP) are concerned with predicting numerical values from examples and relational and mostly non-determinate background knowledge. However, so far no ILP algorithm except one can predict numbers and cope with non-determinate background knowledge. (The only exception is a covering algorithm called FORS.) In this paper we present Structural Regression Trees (SRT), a new algorithm which {{can be applied to}} the above class of problems by integrating the statistical method of regression trees into ILP. SRT constructs a tree containing a <b>literal</b> (an atomic <b>formula</b> or its negation) or a conjunction of literals in each node, and assigns a numerical value to each leaf. SRT provides more comprehensible results than purely statistical methods, and can be applied to a class of problems most other ILP syste [...] ...|$|R
40|$|The {{concept of}} anti-link is defined (an anti-link {{consists}} of two occurrences of the same <b>literal</b> in a <b>formula),</b> and useful equivalence-preserving operations based on anti-links are introduced. These operations eliminate a potentially large number of subsumed paths in a negation normal form formula. Those anti-links that directly indicate the presence of subsumed paths are characterized. The operations have linear time complexity {{in the size of}} that part of the formula containing the anti-link. The problem of removing all subsumed paths in an NNF formula is shown to be NP-hard, even though such formulas may be small relative to the size of their path sets. The general problem of determining whether there exists a pair of subsumed paths associated with an arbitrary anti-link is shown to be NP-complete. Additional techniques that generalize the concept of pure literals are introduced and are also shown to eliminate redundant subsumption checks. The effectiveness of these techniques is [...] ...|$|R
40|$|Propositional satisfiability (SAT) is {{a success}} story in Computer Science and Artificial Intelligence: SAT solvers are {{currently}} used to solve problems in many different application domains, including planning and formal verification. The main reason for this success is that modern SAT solvers can successfully deal with problems having millions of variables. All these solvers {{are based on the}} Davis– Logemann–Loveland procedure (dll). In its original version, dll is a decision procedure, but it can be very easily modified in order to return one or all assignments satisfying the input set of clauses, assuming at least one exists. However, in many cases {{it is not enough to}} compute assignments satisfying all the input clauses: Indeed, the returned assignments have also to be “optimal” in some sense, e. g., they have to satisfy as many other constraints—expressed as preferences—as possible. In this paper we start with qualitative preferences on literals, defined as a partially ordered set (poset) of literals. Such a poset induces a poset on total assignments and leads to the definition of optimal model for a formula ψ as a minimal element of the poset on the models of ψ. We show (i) how dll can be extended in order to return one or all optimal models of ψ (once converted in clauses and assuming ψ is satisfiable), and (ii) how the same procedures can be used to compute optimal models wrt a qualitative preference on formulas and/or wrt a quantitative preference on <b>literals</b> or <b>formulas.</b> We implemented our ideas and we tested the resulting system on a variety of very challenging structured benchmarks. The results indicate that our This work extends the results presented in [19, 24]...|$|R
40|$|To {{be able to}} {{appreciate}} the power of Lovász Local Lemma (LLL), {{let us look at}} the following example problem: Consider a boolean formula in CNF such that each clause contains exactly k <b>literals</b> (a k-CNF <b>formula)</b> and that the frequency of each variable is ≤ 2 k e·k. Show that any such formula is satisfiable. (The frequency of a variable is the number of occurrences of the variable or its negation in the formula.) To see that the frequency bound influences the satisfiability of a boolean formula, consider the following simple exercise suggested by Chris. Exercise 1 : Show that a 3 -CNF formula with a frequency bound of 3 is satisfiable. (Hint: Use Hall’s theorem to show that each clause has a unique variable that can be set to make the clause true) Let ϕ denote such a boolean formula with n variables and m clauses. Let us analyze the simple randomized algorithm which assigns each variable 0 or 1 with equal probability. Let Ei be the event that the i th clause is not satisfied. Then we kno...|$|R
40|$|The Davis-Putnam-Logemann-Loveland {{algorithm}} {{is one of}} the most popular algorithms for solving the satisfiability problem. Its efficiency depends on its choice of a branching rule. We construct a sequence of instances of the satisfiability problem that fools a variety of "sensible" branching rules in the following sense: when the instance has n variables, each of the "sensible" branching rules brings about Ω n= 5) recursive calls of the Davis-PutnamLogemann -Loveland algorithm, even though only O(1) such calls are necessary. 1 The SAT problem A truth assignment is a mapping f that assigns 0 or 1 to each variable in its domain; we shall enumerate all the variables in this domain as x 1; : : :; x n. The complement x i of each such variable x i is defined by f(x i) = 1 Γ f(x i) for all truth assignments f; both x i and x i are called literals; if u = x i then u = x i. A clause is a set of (distinct) <b>literals</b> and a <b>formula</b> is a family of (not necessarily dist [...] ...|$|R
40|$|Propositional satisfiability (SAT) is {{a success}} story in Computer Science and Artificial Intelligence: SAT solvers are {{currently}} used to solve problems in many different application domains, including planning and formal verification. The main reason for this success is that modern SAT solvers can successfully deal with problems having millions of variables. All these solvers {{are based on the}} Davis-Logemann-Loveland procedure (DLL). In its original version, DLL is a decision procedure, but it can be very easily modified in order to return one or all assignments satisfying the input set of clauses, assuming at least one exists. However, in many cases {{it is not enough to}} compute assignments satisfying all the input clauses: Indeed, the returned assignments have also to be “optimal” in some sense, e. g., they have to satisfy as many other constraints –expressed as preferences – as possible. In this paper we start with qualitative preferences on literals, defined as a partially ordered set (poset) of literals. Such a poset induces a poset on total assignments and leads to the definition of optimal model for a formula ψ as a minimal element of the poset on the models of ψ. We show (i) how DLL can be extended in order to return one or all optimal models of ψ (once converted in clauses and assuming ψ is satisfiable), and (ii) how the same procedures can be used to compute optimal models wrt a qualitative preference on formulas and/or wrt a quantitative preference on <b>literals</b> or <b>formulas.</b> We implemented our ideas and we tested the resulting system on a variety of very challenging structured benchmarks. The results indicate that our implementation has comparable performances with other state-of-the-art systems, tailored for the specific problems we consider...|$|R
40|$|The SAT {{problem is}} the problem of finding a model for a formula in conjunctive normal form. We {{developed}} two algorithms based on hyper-unit propagation, which solve the SAT problem. Hyper-unit propagation is unit propagation simultaneously by literals, as unit clauses, of an assignment. The first method, called Unicorn-SAT algorithm, solves the resolution-free SAT problem in linear time. A formula is resolution-free if and only if there are no two clauses, which differ only in one variable. For such a restricted formula we can find a model in linear time by hyper-unit propagation. We obtain a submodel, i. e., a part of the model, by negation of a resolution-mate of a minimal clause, which is a clause with the smallest number of <b>literals</b> in the <b>formula.</b> We obtain a resolution-mate of a clause by negating one literal in it. By hyper-unit propagation by a sub-model we obtain a formula, which has fewer variables and clauses and remains resolution-free. Therefore, we can obtain a model by joining the sub-models while we perform hyper-unit propagation by a sub-model recursively until the formula becomes empty. The second method, called General-Unicorn-SAT algorithm, solves the genera...|$|R
40|$|A truth {{assignment}} is a mapping f that assigns 0 (interpreted as “false”) or 1 (interpreted as “true”) to each variable in its domain; we shall enumerate all the variables in this domain as x 1, [...] ., xn. The complement xi of each such variable xi {{is defined by}} f(xi) = 1 − f(xi) for all truth assignments f; both xi and xi are called literals; if u = xi then u = xi. A clause {{is a set of}} (distinct) <b>literals</b> and a <b>formula</b> (in a conjunctive normal form) is a family of (not necessarily distinct) clauses. A truth assignment satisfies a clause if it maps at least one of its literals to 1; the assignment satisfies a formula if and only if it satisfies each of its clauses. A formula is called satisfiable if it is satisfied by at least one truth assignment; otherwise it is called unsatisfiable. The problem of recognizing satisfiable formulas is known as the satisfiability problem, or SAT for short. Solving SAT by implicit enumeration Given a formula F and a literal v in F, we let F|v denote the “residual formula ” arising from F when f(v) is set at 1 : explicitly, this formula i...|$|R
40|$|We can {{associate}} an incidence graph {{with any}} CNF formula. It's a bipartite graph, {{in which he}} first part corresponds to variables and the second one to clauses. We can define matched formulas and biclique satisfiable formulas, based on this incidence graph. Both of these classes share an interesting property: Given a formula F which is matched or biclique satisfiable, F remains satisfiable even after we switch polarity of any occurrence of any <b>literal.</b> Class of <b>formulas</b> with this property is called var-satisfiable. In this thesis, we consider a parameterized algorithm introduced by Stefan Szeider for deciding satisfiability of formulas with small deficiency. Here deficiency of a formula {{is defined as a}} difference between the number of clauses and the number of variables in the formula. We explain why this algorithm cannot be simply generalized for the case of biclique satisfiable formulas. Since the problem of determining whether a formula is biclique satisfiable is NP-complete, we introduce a heuristic, which tries to find some biclique cover in time O(n 2 e), where n denotes the number of variables and e denotes the length of the input formula. We performed experiments testing this heuristic on random formulas. The results of these experiments suggest, that there is a phase transition in the behaviour of the heuristic [...] . ...|$|R
5000|$|The {{method of}} tableaux works by {{starting}} with the initial set of formulae and then adding to the tableau simpler and simpler formulae until contradiction {{is shown in the}} simple form of opposite <b>literals.</b> Since the <b>formula</b> represented by a tableau is the disjunction of the formulae represented by its branches, contradiction is obtained when every branch contains a pair of opposite literals. Once a branch contains a literal and its negation, its corresponding formula is unsatisfiable. As a result, this branch can be now [...] "closed", as {{there is no need to}} further expand it. If all branches of a tableau are closed, the formula represented by the tableau is unsatisfiable; therefore, the original set is unsatisfiable as well. Obtaining a tableau where all branches are closed is a way for proving the unsatisfiability of the original set. In the propositional case, one can also prove that satisfiability is proved by the impossibility of finding a closed tableau, provided that every expansion rule has been applied everywhere it could be applied. In particular, if a tableau contains some open (non-closed) branches and every formula that is not a literal has been used by a rule to generate a new node on every branch the formula is in, the set is satisfiable.|$|R
3000|$|We briefly {{present the}} {{fundamentals}} of the connection calculus. In this description we use a standard FOL syntax and semantics {{as well as some}} elements of logic programming theory [5]. In particular, the alphabet encompasses constants a, b, c, variables x, y, z, functors f, g, h and predicates p, q, r. The symbol L denotes a literal, namely an atomic formula (i.e. a positive literal) or a negated atomic formula, i.e. a negative <b>literal.</b> An atomic <b>formula</b> is called in short an atom. All mentioned symbols can possibly be subscripted. The symbol θ stands for a substitution{x_ 1 /t_ 1, [...]..., x_n/t_n}, where x_i is a variable and t_i is a term for i= 1,n. An application of the substitutionθ to the expression E (namely, to a term or to a formula) results in the expression Eθ, which is obtained from E by replacing every occurrence of the variable x_i by the term t_i. The expression Eθ is called an instance of the expression E. Moreover, a copy of the expression E is an instance of E with all variables renamed to new, unique identifiers. If the given expression does not contain variables then it is called ground. Two expressions E and E^' are unifiable if there exists a unifier for them, that is to say, a substitution θ, such that Eθ = E^'θ.|$|R
40|$|We {{present a}} sound, {{complete}} and terminating tableau {{system for the}} propositional logic of linear time with 2, 3, fl, W and U and the past operators 2 -, 3 -, flΓ, e flΓ, B and S. ffl Comments: To expand. 1 Introduction Studied in [SC 85]. We adopt the notations of [MP 91]. ffl Comments: To expand. 2 Linear Temporal Logic Formulas F, G, H, : : :, of linear temporal logic are built from variables A, B, C, : : : by the following grammar: F ::= A j :F j F F j F F j 2 F j 3 F j flF j F W F j F U F j flΓ F j e flΓ F j 3 - F j 2 - F j F B G j F S F F !G is taken to be an abbreviation for :F G, and F G for (F !G) (G!F). We write fl k F as an abbreviation of fl : : : fl [...] - [...] z k times F, for every k 2 IN. We adopt the convention that fl 0 F denotes F. We call <b>literals</b> L any <b>formula</b> of the form fl k A or : fl k A, where k 2 IN and A is a variable. The semantics is as follows. A structure S = (s; ¸) where s = (s 0; s 1; : : :) is an !-sequence [...] ...|$|R
40|$|To each of n Boolean variables, {{associate}} {{a positive}} literal x and a negative literal x. The literal x has the opposite truth value as the literal x. A k-clause {{is a set}} of k literals associated with different variables and a k-SAT formula {{is a set of}} k-clauses. An assignment of true or false to each variable is a satisfying assignment for a k-SAT formula if each clause in the formula contains at least one true <b>literal.</b> A k-SAT <b>formula</b> gives rise to a Boolean function which evaluates to 1 whenever the input forms a satisfying assignment. Let Gk(n) denote the number of Boolean functions arising from k-SAT formulae. Bollobás, Brightwell, and Leader prove that G 2 (n) = 2 (1 +o(1)) n 2 / 2 n(n+ 1) / 2. They conjecture that the number of 2 -SAT functions is actually (1 + o(1)) 2. A lower bound for G 2 (n) is given by 2 (n 2) since each monotone formula (a formula which contains only positive literals) gives rise to a unique 2 -SAT function. To obtain an upper bound, the authors translate the problem of enumerating 2 -SAT Boolean functions into one of enumerating graphs on n vertices whose edges are colored red or blue and in which every triangle has an even number of blue edges. While their technique does not extend to k-SAT functions for k> 2, Bollobás, Brightwell, and Leader do provide an upper bound for Gk(n). Upon proving that log (Gk(n)) / () n is a decreasing function, they show that for n ≥ 2 k, Gk(n) ≤ 2 Gk(n) = 2 (1 +o(1)) (n k) ...|$|R
40|$|Usage of SAT {{methods in}} Formal Verification is {{increasing}} [1]. Recently several preprocessors for SAT instances {{have been proposed}} [2], [3], [4]. Few of them have shown successes in some Formal Verification problems like Bounded Model Checking (BMC) and Equivalence Checking. As far as we know, {{none of them have}} been successful in reducing the complexity of microprocessor verification SAT instances. In [5, 6], Velev and Bryant have concluded that applying a preprocessor (simplifier) to the CNF formulas resulting from realistic microprocessors is impractical, due to the large number of clauses-hundreds of thousands. In contrast, we show that a recent preprocessor, NiVER [7], results in solving SAT instances from Velev's microprocessor benchmark suite [8] in less time and space. We also explain the reason for the success of NiVER, while other preprocessors fail. We use the average number of implications by unit propagation of <b>literals</b> in the <b>formula</b> to estimate the cost of preprocessing. As far as we know, this paper is the first to estimate the cost of preprocessors and predict the usefulness of them. We also introduce and study a variant of NiVER, LiVER, that allows a limited increase in the formula size. Experimental results show that without NiVER preprocessing, some of the Velev's microprocessor verification SAT instances may not be solved due to huge memory or time requirements. On the experiments conducted so far, in unsatisfiable instances preprocessing resulted in upto 3 &times; speed-up in time and solving few instances, which are otherwise aborted due to huge memory requirements. We also show the effect of preprocessing on SAT instances from UCLID [9] -a verification tool for infinite state systems...|$|R

