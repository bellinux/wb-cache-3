5|72|Public
50|$|When {{employing}} {{the left wing}} <b>lock</b> <b>strategy,</b> the centre's role is typically to shadow the puck carrier or provide token pressure in the opposing team's zone {{to force them to}} try to pass the puck up ice into the lock. This is a much older strategy and is less commonly employed at elite levels, however it was most recently used extensively by the 2006 Carolina Hurricanes on their way to their first Stanley Cup.|$|E
50|$|Another way to {{classify}} locks is by {{what happens when}} the <b>lock</b> <b>strategy</b> prevents progress of a thread. Most locking designs block the execution of the thread requesting the lock until it is allowed to access the locked resource. With a spinlock, the thread simply waits ("spins") until the lock becomes available. This is efficient if threads are blocked for a short time, because it avoids the overhead of operating system process re-scheduling. It is inefficient if the lock is held for a long time, or if the progress of the thread that is holding the lock depends on preemption of the locked thread.|$|E
40|$|Patients on home {{parenteral}} nutrition (HPN) {{are at risk}} for catheter-related complications; mainly infections and occlusions. We have previously shown in HPN patients presenting with catheter sepsis that catheter locking with taurolidine dramatically reduced re-infections when compared with heparin. Our HPN population therefore switched from heparin to taurolidine in 2008. The aim {{of the present study was}} to compare long-term effects of this catheter <b>lock</b> <b>strategy</b> on the occurrence of catheter-related bloodstream infections and occlusions in HPN patients. Data of catheter-related complications were retrospectively collected from 212 patients who received HPN between January 2000 and November 2011, comprising 545 and 200 catheters during catheter lock therapy with heparin and taurolidine, respectively. We evaluated catheter-related bloodstream infection and occlusion incidence rates using Poisson-normal regression analysis. Incidence rate ratios were calculated by dividing incidence rates of heparin by those of taurolidine, adjusting for underlying disease, use of anticoagulants or immune suppressives, frequency of HPN/fluid administration, composition of infusion fluids, and duration of HPN/fluid use before catheter creation. Bloodstream infection incidence rates were 1. 1 /year for heparin and 0. 2 /year for taurolidine locked catheters. Occlusion incidence rates were 0. 2 /year for heparin and 0. 1 /year for taurolidine locked catheters. Adjusted incidence ratios of heparin compared to taurolidine were 5. 9 (95 % confidence interval, 3. 9 - 8. 7) for bloodstream infections and 1. 9 (95 % confidence interval, 1. 1 - 3. 1) for occlusions. Given that no other procedural changes than the catheter <b>lock</b> <b>strategy</b> were implemented during the observation period, these data strongly suggest that taurolidine decreases catheter-related bloodstream infections and occlusions in HPN patients compared with heparin...|$|E
25|$|Jet 3.0 was {{replaced}} by Jet 3.5, which uses the same database structure, but different <b>locking</b> <b>strategies,</b> making it incompatible with Jet 3.0.|$|R
50|$|When {{a message}} {{is sent to}} an object VOD looks into {{internal}} structures {{to see if the}} object is already in client memory. If not, VOS does an RPC to load the object. At the time VOD loads the object, it will also look at the connections <b>locking</b> <b>strategy</b> to decide how to deal with locking the object on load. VOD supports both global <b>locking</b> <b>strategies</b> that can be applied to a connection and extremely fine grained control to override behavior for a particular use case.|$|R
50|$|Versant {{by default}} uses a pessimistic <b>locking</b> <b>strategy</b> {{to ensure that}} objects in the {{database}} server are in sync with client access in an ACID way. This is done by {{using a combination of}} locks against both schema and instance objects.|$|R
40|$|BACKGROUND AND AIMS: Patients on home {{parenteral}} nutrition (HPN) {{are at risk}} for catheter-related complications; mainly infections and occlusions. We have previously shown in HPN patients presenting with catheter sepsis that catheter locking with taurolidine dramatically reduced re-infections when compared with heparin. Our HPN population therefore switched from heparin to taurolidine in 2008. The aim {{of the present study was}} to compare long-term effects of this catheter <b>lock</b> <b>strategy</b> on the occurrence of catheter-related bloodstream infections and occlusions in HPN patients. METHODS: Data of catheter-related complications were retrospectively collected from 212 patients who received HPN between January 2000 and November 2011, comprising 545 and 200 catheters during catheter lock therapy with heparin and taurolidine, respectively. We evaluated catheter-related bloodstream infection and occlusion incidence rates using Poisson-normal regression analysis. Incidence rate ratios were calculated by dividing incidence rates of heparin by those of taurolidine, adjusting for underlying disease, use of anticoagulants or immune suppressives, frequency of HPN/fluid administration, composition of infusion fluids, and duration of HPN/fluid use before catheter creation. RESULTS: Bloodstream infection incidence rates were 1. 1 /year for heparin and 0. 2 /year for taurolidine locked catheters. Occlusion incidence rates were 0. 2 /year for heparin and 0. 1 /year for taurolidine locked catheters. Adjusted incidence ratios of heparin compared to taurolidine were 5. 9 (95 % confidence interval, 3. 9 - 8. 7) for bloodstream infections and 1. 9 (95 % confidence interval, 1. 1 - 3. 1) for occlusions. CONCLUSIONS: Given that no other procedural changes than the catheter <b>lock</b> <b>strategy</b> were implemented during the observation period, these data strongly suggest that taurolidine decreases catheter-related bloodstream infections and occlusions in HPN patients compared with heparin...|$|E
40|$|This paper extends pin-tool {{research}} by investigating a new method to accurately position high-fidelity pins in an array, with each pin uniquely positioned under computer control. The resultant tool is a reusable prototyping {{system for the}} rapid generation of three-dimension (3 -D) profiles using CAD extracted data, with application potential {{in a variety of}} manufacturing processes. A control assessment identifies a combination of array-addressing, latching positioning hardware, and a combined "setting platen" pin-position feedback and drive as an appropriate technique for pin control. The novel platen motion strategy is capable of moving thousands of pins with a single drive motor. The system incorporates latching "locks" that operate on the "tail" of a new two-part "header and tail" pin design. Key to the <b>lock</b> <b>strategy</b> is the application of shape memory alloy actuators in a back-to-back configuration; the response of this material to electrical input is quantified and applied to achieve the unique lock design. Multiple locks combined into a demonstrator position headers to an accuracy of + 0. 09 - 0. 05 mm. The mounting pitch of the prototype system permits the use of 1. 0 mm section pins. An extension to the design ultimately allows a 15 000 pin-array to be positioned in similar to 3 min. Note to Practitioners-This research was motivated by the apparent lack of a technique to uniquely position small section pins in an array, without a bulky control system, power limitations, or motion system restrictions. Prior approaches to positioning pins in an array have used multiplexed or sequential control on pins of 6 mm section or larger. This research investigates a combined control system/hardware approach applied to pins of 1 mm square section, scalable to move thousands of pins uniquely. The presented novel solutions generate a higher fidelity surface definition than previous systems. Extending existing research on surface-smoothing interpolators that reduce the "staircase" effect generated by discrete pins would be beneficial. ...|$|E
50|$|Other ways {{of keeping}} client caches in sync are, for example, an optimistic <b>locking</b> <b>strategy,</b> using a classic {{timestamp}} mechanism. VOD also provides forms of client cache synchronization using multi-cast. Additionally {{it provides an}} event mechanism where clients can register for triggering events within the database server {{to be used for}} synchronization or for business logic work flow.|$|R
40|$|We {{describe}} the locking architecture {{of a new}} operating system, HURRICANE, designed for large scale shared-memory multiprocessors. Many papers already describe kernel locking techniques, andsome of the techniques we use have been previously described by others. However, our work is novel in the particular combination of techniques used, {{as well as several}} of the individual techniques themselves. Moreover, it is the way the techniques work together that is the source of our performance advantages and scalability. Briefly, we use: ffl a hybrid coarse-grain/fine-grain <b>locking</b> <b>strategy</b> that has the low latency and space overhead of a coarsegrain <b>locking</b> <b>strategy</b> while having the high concurrency of a fine-grain locking strategy; ffl replication of data structures to increase access bandwidth and improve concurrency; ffl a clustered kernel that bounds the number of processors that can compete for a lock so as to reduce second order effects such as memory and interconnect contention; ff [...] ...|$|R
40|$|International audienceObjectives: Candida infections {{associated}} with catheters remain difficult to manage. Antifungal <b>lock</b> <b>strategies</b> {{could be a}} therapeutic option when the device is difficult to remove or in combination with systemic treatment to increase efficacy. This study deals with the antibiofilm potential of liposomal amphotericin B (L-AMB) used as a lock solution to inhibit Candida albicans, Candida glabrata and Candida parapsilosis biofilms in vitro...|$|R
40|$|Click on the DOI link {{to access}} the article (may not be free). Multiple caches in {{multicore}} architecture increase power consumption and timing unpredictability. Although cache locking in single-core systems shows improvement for large multithreaded applications, {{there is no such}} effective strategy for multicore systems. In this work, we propose three level- 1 cache <b>locking</b> <b>strategies</b> for multicore systems – static, random, and dynamic. In the random strategy, blocks are randomly selected for locking. The static and dynamic schemes are based on the analysis of applications’ worst case execution time (WCET). The static scheme does not allow unlocking blocks during runtime, but the dynamic scheme does. Using VisualSim and Heptane tools, we simulate a system with four cores and two levels of caches. According to the simulation results, the dynamic cache <b>locking</b> <b>strategy</b> outperforms the static and random strategies by up to 35 % in mean delay per task and up to 22 % in total power consumption for the workloads used (e. g., MPEG 3 and MPEG 4). Peer reviewe...|$|R
40|$|AbstractWe {{discuss a}} Krylov–Schur like {{restarting}} technique applied within the symplectic Lanczos algorithm for the Hamiltonian eigenvalue problem. This {{allows us to}} easily implement a purging and <b>locking</b> <b>strategy</b> {{in order to improve}} the convergence properties of the symplectic Lanczos algorithm. The Krylov–Schur-like restarting is based on the SR algorithm. Some ingredients of the latter need to be adapted to the structure of the symplectic Lanczos recursion. We demonstrate the efficiency of the new method for several Hamiltonian eigenproblems...|$|R
40|$|The {{widespread}} {{popularity of}} Cloud computing as a preferred {{platform for the}} deployment of web applications has resulted in {{an enormous number of}} applications moving to the cloud, and the huge success of cloud service providers. Due to the increasing number of web applications being hosted in the cloud, and the growing scale of data which these applications store, process, and serve – scalable data management systems form a critical part of cloud infrastructures. There are issues related to the database security while database is on cloud. The major challenging issues are multi-tenancy, scalability and the privacy. This paper focuses on the problems faced in the data security of Relational Cloud. The problems faced by various types of tenants and the type of access into the database makes a rework on the security of data, by analyzing proper <b>locking</b> <b>strategies</b> on the records accessed from the database. Data security in cloud computing addresses the type of access mode by the users (for analytical or transaction purpose) and the frequency of data access from the physical location (in shared or no-shared disk mode). Accordingly, the various data <b>locking</b> <b>strategies</b> are studied and appropriate locking mechanism will be implemented for real-time applications as in e-commerce...|$|R
40|$|We {{discuss a}} Krylov-Schur like {{restarting}} technique applied within the symplec-tic Lanczos algorithm for the Hamiltonian eigenvalue problem. This allows to easily implement a purging and <b>locking</b> <b>strategy</b> {{in order to}} improve the con-vergence properties of the symplectic Lanczos algorithm. The Krylov-Schur-like restarting is based on the SR algorithm. Some ingredients of the latter need to be adapted to the structure of the symplectic Lanczos recursion. We demon-strate the efficiency of the new method for several Hamiltonian eigenproblems. Key words: Hamiltonian eigenproblem, symplectic Lanczos method, Krylov-Schur method, implicit restarting, SR algorithm...|$|R
5000|$|A {{consequence}} of the file <b>locking</b> <b>strategy</b> is that AFS does not support large shared databases or record updating within files shared between client systems. This was a deliberate design decision based on the perceived needs of the university computing environment. It leads, for example, {{to the use of}} a single file per message in the original email system for the Andrew Project, the Andrew Message System, rather than a single file per mailbox (i.e., maildir instead of mbox). See AFS and buffered I/O Problems for handling shared databases ...|$|R
40|$|This paper {{explores the}} dynamic {{behaviour}} of loads and tap changers {{during the process}} of voltage collapse in power systems. Using an exponential recovery load model representing the dynamic behaviour of aggregate loads, the mechanism of voltage collapse is illustrated. Dynamic interaction between loads and transformers is investigated. Based on such dynamic considerations, a tap <b>locking</b> <b>strategy</b> is proposed which ensures that voltage collapse does not occur. Investigations focus on determining a critical value of tap position such that locking at a smaller value of tap results in stable behaviour, but locking at a larger value results in voltage collapse. link_to_subscribed_fulltex...|$|R
50|$|The {{most common}} event, the current {{transaction}} ends with commit. In the default case, this will release {{the lock and}} object from memory. However, note that there are forms of commit that will do combinations of things like, keep the cache and the locks and start a new transaction, keep the cache, but release the locks and start a new transaction. These forms and others are used to optimize cache effectiveness when using non-default <b>locking</b> <b>strategies</b> like optimistic <b>locking</b> or {{when you have a}} series of transactions that form a task and operate on the same set of objects.|$|R
40|$|Phan~oma ” are records {{inserted}} into a concurrently aelected set of records specified by a predicate such that Ihe selection does not eee a transaction conaie-tent result. The usual locking slrategy is lo lock only czisling records. However, records that satisfy the ee-leclion predicate muat be locked {{even when they}} are nol present in the database to prevent their insertion. One way to cope with phantoms is through range lock-ing, 4 limited form of predicate locking. We inves-tigate lock modes for ranges and describe new lock modes lhal greatly increase concurrency. We explore <b>locking</b> <b>strategies</b> involving range, key, and record re-sources that permit trade-offs between concurrency and lock overhead...|$|R
40|$|We {{describe}} {{and analyze the}} operation and stabilization of a Mach–Zehnder interferometer, which separates the carrier and the first-order sidebands of a phase-modulated laser field, and which is locked using the Hänsch–Couillaud method. In addition to the necessary attenuation, our interferometer introduces, via total internal reflection, a significant polarization-dependent phase delay. We employ a general treatment to describe an interferometer with an object that affects the field along one path, and we examine how this phase delay affects the error signal. We discuss the requirements necessary to ensure the lock point remains unchanged when phase modulation is introduced, and we demonstrate and characterize this locking experimentally. Finally, we suggest an extension to this <b>locking</b> <b>strategy</b> using heterodyne detectio...|$|R
5000|$|The DataBlitz Relational Manager is a C++ {{class library}} {{interface}} to a relational system with SQL support limited to definition statements. Schema information {{is stored in}} tables, and can be queried using the relational API itself. Indices may be created on arbitrary subsets of the attributes in a table. Referential integrity is supported (foreign key constraints), as are null values, date and time attribute types, and variable length fields. Navigation is supported throughiterators over a single table. A conjunctive query may be specified for the iterator, and automatic index selection is performed. Both fine-grained and multi-granularity <b>locking</b> <b>strategies</b> are used for high concurrency without incurring too much overhead. Also, locks obtained by iterators avoid the [...] "phantom" [...] anomaly...|$|R
40|$|We {{describe}} an approach for synthesizing data representations for concurrent programs. Our compiler takes as input a program written using concurrent relations and synthesizes {{a representation of}} the relations as sets of cooperating data structures as well as the placement and acquisition of locks to synchronize concurrent access to those data structures. The resulting code is correct by construction: individual relational operations are implemented correctly and the aggregate set of operations is serializable and deadlock free. The relational specification also permits a high-level optimizer to choose the best performing of many possible legal data representations and <b>locking</b> <b>strategies,</b> which we demonstrate with an experiment autotuning a graph benchmark. Categories and Subject Descriptors D. 3. 3 [Programming Languages]: Language Constructs and Features—Abstract data types...|$|R
40|$|Abstract. We {{present the}} first {{non-blocking}} hashtable based on open addressing {{that provides the}} following benefits: it combines good cache locality, accessing a single cacheline {{if there are no}} collisions, with short straight-line code; it needs no storage overhead for pointers and memory allocator schemes, having instead an overhead of two words per bucket; it does not need to periodically reorganise or replicate the table; and it does not need garbage collection, even with arbitrary-sized keys. Open problems include resizing the table and replacing, rather than erasing, entries. The result is a highly-concurrent set algorithm that approaches or outperforms the best externally-chained implementations we tested, with fixed memory costs and no need to select or fine-tune a garbage collector or <b>locking</b> <b>strategy.</b> ...|$|R
40|$|This paper {{addresses}} {{the problem of}} coordinating a team of software developers concurrently working on a common software system. The standard approach to coordinate concurrent activities on {{a common set of}} data is locking. Any part of data used by one person is locked against concurrent use by another person. The second person has to wait until the first person has finished his or her task and releases the lock. In databases, sophisticated locking and transaction concepts minimize the waiting times for concurrent users by offering different lock granularities and different locking levels (e. g. multiple read locks vs. single write locks). However, these <b>locking</b> <b>strategies</b> assume that <b>locks</b> are hold for relatively short times (some seconds), only. In software development [...] ...|$|R
40|$|We {{describe}} and analyse {{the operation and}} stabilization of a Mach [...] Zehnder interferometer, which separates the carrier and the first-order sidebands of a phase-modulated laser field, and which is locked using the Hänsch [...] Couillaud method. In addition to the necessary attenuation, our interferometer introduces, via total internal reflection, a significant polarization-dependent phase delay. We employ a general treatment to describe an interferometer with an object which affects the field along one path, and we examine how this phase delay affects the error signal. We discuss the requirements necessary to ensure the lock point remains unchanged when phase modulation is introduced, and we demonstrate and characterize this locking experimentally. Finally, we suggest an extension to this <b>locking</b> <b>strategy</b> using heterodyne detection. Comment: 4 pages, 5 figure...|$|R
40|$|An {{essential}} motivation behind concurrent object-oriented {{systems is}} {{to exploit the}} software modularity and reuse potential of object-oriented features {{in the development of}} concurrent systems. However, the marriage between the two disciplines has not been a happy one. In this work we propose a model that reduces the problems associated with introducing concurrency into object-oriented languages. We explore techniques for reasoning about synchronisation requirements in composite object systems operating in a concurrent environment. Furthermore we investigate safe <b>locking</b> <b>strategies,</b> where the <b>locks</b> may be distributed over the components of the system and identify conditions for such locks to be non-redundant. Through the recognition of a Galois connection, we achieve an elegant mathematical characterisation of the lock-distribution problem, which allows us to identify efficient strategies and tools for assisting developers with lock selection...|$|R
40|$|International audienceThis paper {{presents}} the locomotion approach {{of a novel}} quadruped robot which is able to carry various effectors for achieving manufacturing tasks in large workspaces. Equipped with lockers {{on some of the}} passive joints and clamping devices {{at the end of its}} limbs, this quadruped uses eight actuators for achieving manufacturing tasks as well as locomotion tasks. In the following sections, we ﬁrst present the proposed robot and its two working modes. Then, the <b>locking</b> <b>strategy</b> of the robot is formulated as an optimization problem. Also, a practical method for managing the limbs swinging movement is addressed. At last, the presented approach is applied on two concrete examples. Possessing a low degree of kinematic redundancy, the proposed quadruped shows a reasonable locomotion capacity which allows it to achieve locomotion with respect to some extra constrains in its workspaces...|$|R
40|$|Atomic {{sections}} are {{a technique}} used {{to simplify the}} writing of parallel programs. Actions performed during the execution of an atomic section should not be visible to other components in the program until after the section completes. Usually the atomicity requirement is enforced through optimistic transactional memory. However, transactional memories have the drawback that not every action is allowed to occur inside of an atomic section. In particular, I/O actions cannot be rolled back on most systems, and so they may not appear within transactions. This paper examines supporting atomic sections that can contain arbitrary actions, {{using a combination of}} locks and transactions. We present a system that infers a <b>locking</b> <b>strategy,</b> identifies problematic atomic sections and creates a hybrid solution. This paper presents the algorithm, argues the process is sound and reports experimental results. 1...|$|R
40|$|Abstract—This paper {{presents}} the locomotion approach {{of a novel}} quadruped robot which is able to carry various effectors for achieving manufacturing tasks in large workspaces. Equipped with lockers {{on some of the}} passive joints and clamping devices {{at the end of its}} limbs, this quadruped uses eight actuators for achieving manufacturing tasks as well as locomotion tasks. In the following sections, we first present the proposed robot and its two working modes. Then, the <b>locking</b> <b>strategy</b> of the robot is formulated as an optimization problem. Also, a practical method for managing the limbs swinging movement is addressed. At last, the presented approach is applied on two concrete examples. Possessing a low degree of kinematic redundancy, the proposed quadruped shows a reason-able locomotion capacity which allows it to achieve locomotion with respect to some extra constrains in its workspaces. I...|$|R
40|$|An {{important}} {{class of}} concurrent objects {{are those that}} are non-blocking, that is, whose operations are not contained within mutually exclusive critical sections. A non-blocking object can be accessed by many threads at a time, yet update protocols based on atomic Compare-And-Swap operations can be used to guarantee the object's consistency. In this paper we take a practical look at the Compare-And-Swap operation in the context of contemporary bus-based shared memory multiprocessors, although our results generalize to distributed shared memory multiprocessors. We first describe an operating system-based solution that permits the construction of a non-blocking Compare-And-Swap function on architectures that only support more primitive atomic primitives such as Test-And-Set or Atomic Exchange. We then evaluate several <b>locking</b> <b>strategies</b> {{that can be used to}} synthesize a Compare-And-Swap operation, and show that the common techniques for reducing synchronization overhead in the presence o [...] ...|$|R
40|$|In recent years, the {{research}} on spatial indexing is arousing more and more interests and attentions. A number of spatial indexing structures based on secondary memory have been proposed for handling the massive spatial data stored in the spatial database rapidly and efficiently. R-tree, proposed by Guttman in 1984, {{is the most popular}} dynamic spatial access method and has been widely used in many prototype researches and commercial applications. During the last two decades, more and more R-tree variations have come into being a prosperous R-tree family. In this paper, authors recall the R-tree and its main variations, study the bulk operation, spatial query processing, cost model and query optimizing technique based on R-tree, present the progress about the parallelism, concurrency control and <b>locking</b> <b>strategy</b> based on R-tree, and point out the directions for future work...|$|R
40|$|Significant {{performance}} advantages can {{be realized}} by implementing a database system on a shared memory multiprocessor. An efficient implementation of a lock manager {{is a prerequisite for}} efficient transaction processing in multiprocessor database systems. To this end, we advocate adopting an autonomous <b>locking</b> <b>strategy.</b> In autonomous <b>locking,</b> transactions acquire and release locks via operations on shared memory, in contrast to conventional locking where communication with a lock manager is involved. We demonstrate the superior performance and scalability of autonomous locking through benchmarks of a prototype lock manager implemented on a large scale shared memory multiprocessor. For instance, when contention is high (i. e., for hot lock operations), the performance of autonomous locking is nearly an order of magnitude better than conventional locking. The paper also addresses issues related to recovery (assuming independent node failures). 1 Partially supported by the National Scie [...] ...|$|R
30|$|The aim of {{this study}} was to compare the {{efficacy}} of external fixation with volar <b>locked</b> plating treatment <b>strategies</b> in displaced intra-articular (Cooney’s type IV) distal radius fractures.|$|R
40|$|Abstract — This paper {{builds on}} earlier work that used a spatial grid for locking to provide {{physically}} accurate parallel collision handling. Instead {{of using a}} grid, this work uses a spatial tree. The tree is better able to handle heterogeneous particle populations. The method was specifically developed to handle a granular flow impact simulation where one large body impacts a population of smaller bodies. The large size of the impactor leads to a breakdown in the grid based <b>locking</b> <b>strategy</b> because grid cells are uniformly sized and must {{be large enough to}} enclose the largest particle in the population plus the relative velocity distribution multipled by a time step. The tree allows the regions that get locked to scale in size based on local characteristics, making it possible to handle dramatic size differences. Unfortunately, it also has more overhead than the grid so using it when it is not needed can slow simulations down...|$|R
40|$|Abstract. In {{this paper}} {{we present a}} {{complete}} Java STM framework, called Deuce, intended as a platform for developing scalable concurrent applications and as a research tool for designing new STM algorithms. It was not clear if one could build an e cient Java STM without compiler support. Deuce provides several bene ts over existing Java STM frameworks: it avoids any changes or additions to the JVM, {{it does not require}} language extensions or intrusive APIs, and it does not impose any memory footprint or GC overhead. To support legacy libraries, Deuce dynamically instruments classes at load time and uses an original eld-based <b>locking</b> <b>strategy</b> to improve concurrency. Deuce also provides a simple internal API allowing di erent STMs algorithms to be plugged in. We show empirical results that highlight the scalability of our framework running benchmarks with hundreds of concurrent threads. This paper shows for the rst time that one can actually design a Java STM with reasonable performance without compiler support. ...|$|R
40|$|Certain {{off-road}} vehicles {{are equipped with}} a type of clutches referred to as differential locks. A driver may engage/disengage these locks to switch between two distinct operating modes: the closed mode is charac- terized by greater off-road traversability, while the open mode allows better manueverability. Many drivers lack the education and experience required to correctly judge the terrain ahead of the vehicle and therefore engage/disengage the locks in a suboptimal fashion. An automatic differential <b>locking</b> <b>strategy</b> is hence desired. This paper compares three such traction control algorithms of the on/off variety, all derived from the same underlying kinematic vehicle model but each relying {{on the availability of}} different output signals. The validity of the kinematic model and the algorithms’ sensitivity to the values assumed by a couple of unobservable states, the wheel slip angles, is in- vestigated by comparison to an existing articulated hauler model in ADAMS— an environment for simulation of multibody dynamics. Godkänd; 2010; 20110628 (ysko) Optimerad framkomlighet för tunga terrängfordo...|$|R
