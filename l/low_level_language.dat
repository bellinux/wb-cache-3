47|10000|Public
5000|$|Parrot Assembly Language (PASM) is the <b>low</b> <b>level</b> <b>language</b> that compiles down to bytecode. PASM code {{is usually}} stored in files with the {{filename}} extension [...] ".pasm".|$|E
50|$|The main {{advantage}} of programming in 1GL {{is that the}} code can run very fast and very efficiently, precisely because the instructions are executed directly by the central processing unit (CPU). One of the main disadvantages of programming in a <b>low</b> <b>level</b> <b>language</b> is that when an error occurs, the code is not as easy to fix.|$|E
50|$|Instruction List (IL) {{is one of}} the 5 {{languages}} {{supported by}} the IEC 61131-3 standard. It is designed for programmable logic controllers (PLCs). It is a <b>low</b> <b>level</b> <b>language</b> and resembles assembly. All of the languages share IEC61131 Common Elements. The variables and function call are defined by the common elements so different languages can be used in the same program.|$|E
40|$|AbstractIt {{is widely}} {{recognized}} that formulating program analysis by a type {{system is a}} promising approach because of its clarity and rigidity. However, there remains {{much to be done}} for applying them to practical use. One of the problems {{is that it is not}} trivial what kind of type systems is appropriate for <b>low</b> <b>level</b> <b>languages.</b> To solve the problem, the type systems must be closely related to data flow analysis because it has been the major method for analyzing <b>low</b> <b>level</b> <b>languages.</b> In this paper, taking array bound checks as an example, first we propose a framework for type systems for <b>low</b> <b>level</b> <b>languages</b> derived from data flow analysis. Second, we propose a type system for analyzing programs as a network of blocks (especially loops), dealing with SSA form and induction variables...|$|R
5000|$|Lines of Code (LOC) {{measures}} reward <b>low</b> <b>level</b> <b>languages</b> {{because more}} {{lines of code}} are needed to deliver a similar amount of functionality to a higher <b>level</b> <b>language.</b> [...] C. Jones offers a method of correcting this in his work.|$|R
40|$|Compiler and {{programming}} language implementation courses are integral parts of many computer science curricula. However, {{the range of}} topics necessary to teach in such a course are difficult for students to understand and time consuming to cover. In particular, code generation is a confusing topic for students unfamiliar with <b>low</b> <b>level</b> target <b>languages.</b> We present Frances, a tool for helping students understand code generation and <b>low</b> <b>level</b> <b>languages.</b> The key idea is to graphically illustrate the relationships between high <b>level</b> <b>language</b> constructs and <b>low</b> <b>level</b> (assembly) <b>language</b> code. By illustrating these relationships, we {{take advantage of the}} students existing understanding of some high <b>level</b> <b>language.</b> We have used Frances in a compiler design course and received highly positive feedback. Students conveyed to us that Frances significantly helped them to understand the concepts necessary to implement code generation in a compiler project...|$|R
50|$|A simple {{interpreter}} {{written in}} a <b>low</b> <b>level</b> <b>language</b> (e.g. assembly) may have similar machine code blocks implementing functions of the high level language stored, and executed when a function's entry in a look up table points to that code. However, an interpreter {{written in a}} high level language typically uses another approach, such as generating and then walking a parse tree, or by generating and executing intermediate software-defined instructions, or both.|$|E
40|$|A {{system for}} proving that {{programs}} {{written in a}} high level language are correctly translated to a <b>low</b> <b>level</b> <b>language</b> is described. A primary use {{of the system is}} as a postoptimization step in code generation. The <b>low</b> <b>level</b> <b>language</b> programs need not be generated by a compiler and in fact could be hand coded. Examples of the usefulness of such a system are given. Some interesting results are the ability to handle programs that implement recursion by bypassing the start of the program, and the detection and pinpointing of a wide class of errors in the <b>low</b> <b>level</b> <b>language</b> programs. The examples demonstrate that optimization of the genre of this paper can result in substantially faster operation and the saving of memory in terms of program and stack sizes...|$|E
40|$|Most of the {{software}} were developed using high level languages such as Java, C#. NET,VB. NET etc. The main advantages of these languages are object oriented features. Which helps to developer to develop software with graphical user interface, portable, ease of use,efficient and secure. <b>Low</b> <b>level</b> <b>language</b> like assembly language,machine languages are not user friendly,hard to program but faster in execution than high level languages [...] In this paper we have done comparative study between two <b>low</b> <b>level</b> <b>language</b> MSIL(Micro Soft Intermediate language) or CIL and Java Byte Code. Both of these languages have object oriented features. This paper also includes brief introduction about programming languages, and translators...|$|E
40|$|This article {{presents}} a process modeling language consisting of high level UML-based diagrams and a <b>low</b> <b>level</b> process <b>language.</b> The high <b>level</b> diagrams facilitate process program development, while the <b>low</b> <b>level</b> process <b>language</b> models processes as process programs. Between {{them is a}} mapping to further facilitate program development. ...|$|R
5000|$|... Design of PIC {{control systems}} using <b>low</b> <b>level</b> {{assembly}} <b>language,</b> interfacing.|$|R
5000|$|These {{programs}} could run on different machines {{so they were}} machine-independent. As new, more abstract languages have been developed, however, the concept of high and <b>low</b> <b>level</b> <b>languages</b> have become rather relative. Many of the early [...] "high level" [...] languages are now considered relatively <b>low</b> <b>level</b> in comparison to languages such as Python, Ruby, and Common Lisp.|$|R
40|$|Undergraduate {{students}} often experience difficulty {{in understanding the}} basic principles of low level computer operations in introductory courses to computer architectures when these are taught using actual low level programming languages. This is not due to any inherent complexity of the concepts but rather a consequence of assembly language specific details and the need to introduce many concepts simultaneously, such as, for example, data representation, addressing modes and primitive I/O. This paper describes the Postroom Computer, a <b>low</b> <b>level</b> <b>language</b> simulator that not only provides a simple <b>low</b> <b>level</b> <b>language,</b> suitable as an introduction to assembly language programming, but also allows computer architecture concepts to be introduced in an incremental fashion...|$|E
40|$|Definition: a {{means for}} proving for a given {{compiler}} (or any program translation procedure) for a high level language H and a <b>low</b> <b>level</b> <b>language</b> L that a program written in H is successfully translated to L Motivation is desire to prove that optimizations performed during the translation process are correct 1. Often, optimizations are heuristics 2. Optimizations could be performed by simply peering over the code Proof procedure should be independent of the translation process (e. g., compiler) Notion of correctness must be defined carefully Need a representation that reflects properties of both the high and <b>low</b> <b>level</b> <b>language</b> programs 1. Critical semantic properties of high level language must be identified 2. Identify their interrelationship to instruction set of computer executing the resulting translatio...|$|E
40|$|We define an {{information}} flow type {{system for a}} sequential JVM-like language that includes classes, objects, and exceptions. Furthermore, we show that it enforces noninterference. Our work provides, to our best knowledge, the first analysis that {{has been shown to}} guarantee noninterference for a realistic <b>low</b> <b>level</b> <b>language...</b>|$|E
50|$|PASM is the <b>lowest</b> <b>level</b> {{assembly}} <b>language</b> in the Parrot stack. The Parrot intermediate representation (PIR) is PASM {{extended to}} simplify development of compilers.|$|R
5000|$|... #Subtitle level 2: Application in <b>low</b> {{and high}} <b>level</b> <b>languages</b> ...|$|R
5000|$|Service Creation Environment (SCE) is the {{development}} environment used to create the services present on the SCP. Although the standards permit any type of environment, it is fairly rare to see <b>low</b> <b>level</b> <b>languages</b> like C used. Instead, proprietary graphical languages are used to enable telecom engineers to create services directly. The languages are usually of the fourth-generation type, and the engineer may use a graphical interface to build or change a service.|$|R
40|$|A {{method for}} {{compiler}} testing using symbolic interpretation is presented. This method is {{a cross between}} program proving and program testing. It is useful in demonstrating that programs are correctly translated from a hzgh level language to a <b>low</b> <b>level</b> <b>language</b> thereby improving {{the reliability of the}} compiler. The term symbolic interpretation is used to describe the process of obtaining an intermediate form of the <b>low</b> <b>level</b> <b>language</b> program that is suitable for further processing by a proof system. Symbolic interpretation {{is the heart of the}} system and enables the recordlng of a transcript of all computations in the program. This process interprets a set of procedures which describe the effects of machine language instructions corresponding to the target machine on a suitable computation model. The highlights and limitations of the process as well as future work are discussed in a framework of a specific LISP implementation on a PDP-IO computer...|$|E
40|$|The {{thesis of}} this {{extended}} abstract is simple. High productivity comes from high level infrastructures. To measure this, we introduce a methodology {{that goes beyond}} the tradition of timing software in serial and tuned parallel modes. We perform a classroom productivity study involving 29 students who have written a homework exercise in a <b>low</b> <b>level</b> <b>language</b> (MPI message passing) and a high level language (Star-P with MATLAB client). Our conclusions indicate what perhaps should be of little surprise: (1) the high level language is always far easier on the students than the <b>low</b> <b>level</b> <b>language.</b> (2) The early versions of the high level language perform inadequately compared to the tuned <b>low</b> <b>level</b> <b>language,</b> but later versions substantially catch up. Asymptotically, the analogy must hold that message passing is to high level language parallel programming as assembler is to high level environments such as MATLAB, Mathematica, Maple, or even Python. We follow the Kepner method that correctly realizes that traditional speedup numbers without some discussion of the human cost of reaching these numbers can fail to reflect the true human productivity cost of high performance computing. Traditional data compares low level message passing with serial computation. With the benefit of a high level language system in place, in our case Star-P running with MATLAB client, and with the benefit of a large data pool: 29 students, each running the same code ten times on three evolutions of the same platform, we can methodically demonstrate the productivity gains. To date we are not aware of any high level system as extensive and interoperable as Star-P, nor are we aware of an experiment of this kind performed with this volume of data...|$|E
40|$|Abstract. GiNaC {{is a free}} {{framework}} that embeds symbolic manipulation consistently into the C++ programming language. It deliberately neglects the split-up into a <b>low</b> <b>level</b> <b>language</b> and a high level language, traditional {{in the design of}} computer algebra systems. The user usually interacts with GiNaC directly in C++. GiNaC was designed to provide efficient handling of multivariate polynomials, algebras and some special functions that are needed for loop calculations in HEP. But it also bears some potential to become a more general purpose symbolic system...|$|E
50|$|The Push {{programming}} {{language is a}} genetic programming system that is explicitly designed for creating self-modifying programs. While not a high <b>level</b> <b>language,</b> {{it is not as}} <b>low</b> <b>level</b> as assembly <b>language.</b>|$|R
40|$|We propose an {{effective}} and flexible way to assemble finite element stiffness and mass matrices in MATLAB. The major loops in the code have been vectorized using the so called array operation in MATLAB, and no <b>low</b> <b>level</b> <b>languages</b> like the C or Fortran {{has been used for}} the purpose. The implementation is based on having the vectorization part separated, in other words hidden, from the original code thereby preserving its original structure, and its flexibility as a finite element code. The code is fast and scalable with respect to time. Web of Science 219137158715...|$|R
40|$|Real-time {{software}} is commonly written in <b>low</b> <b>level</b> <b>languages</b> such as C and assembler. Such {{software is}} often hard to test, maintain, and port to other platforms. To improve this situation, high <b>level</b> <b>languages</b> are {{introduced in the}} real-time domain. The Java programming language has many properties that are appealing to real-time system development, e. g. robustness and portability. However, {{it is difficult to}} estimate the worst-case execution time of Java code using current implementations. This is due to several properties of Java, e. g. dynamic binding of method calls and automatic memory management. This paper discusses the problems of introducing automatic memory management in hard real-time environments and proposes a technique called RT-Reference Counting to solve the problems...|$|R
40|$|We {{present a}} {{technique}} for the automated verification of abstract models of multithreaded programs providing fresh name generation, name mobility, and unbounded control. As high level specification language we adopt here {{an extension of}} communication finite-state machines with local variables ranging over an infinite name domain, called TDL programs. Communication machines have been proved very effective for representing communication protocols {{as well as for}} representing abstractions of multithreaded software. The verification method that we propose is based on the encoding of TDL programs into a <b>low</b> <b>level</b> <b>language</b> based on multiset rewriting and constraints that can be viewed as an extension of Petri Nets. By means of this encoding, the symbolic verification procedure developed for the <b>low</b> <b>level</b> <b>language</b> in our previous work can now be applied to TDL programs. Furthermore, the encoding allows us to isolate a decidable class of verification problems for TDL programs that still provide fresh name generation, name mobility, and unbounded control. Our syntactic restrictions are in fact defined on the internal structure of threads: In order to obtain a complete and terminating method, threads are only allowed to have at most one local variable (ranging over an infinite domain of names). Comment: To appear in Theory and Practice of Logic Programmin...|$|E
30|$|Barthe et al. [4] {{describe}} a security type {{system for a}} <b>low</b> <b>level</b> <b>language</b> with jumps and calls and prove that information flow types are preserved by the compilation from a high level imperative language. A mechanised proof that the type system proposed in Barthe’s work is sound was given in [24], using the Coq proof assistant. Compared to the present work, Kammüler’s formalisation deals {{with the problems of}} the lack of structure present in low level languages which make control flow more intricate than in a pure functional language.|$|E
40|$|We {{describe}} different optimization {{techniques to}} perform the assembly of finite element matrices in Matlab and Octave, from the standard approach to recent vectorized ones, without any <b>low</b> <b>level</b> <b>language</b> used. We finally obtain a simple and efficient vectorized algorithm able to compete in performance with dedicated software such as FreeFEM++. The principle of this assembly algorithm is general, we present it for different matrices in the P 1 finite elements case and in linear elasticity. We present numerical results which illustrate the computational costs of the different approachesComment: Inria: No: RR- 8305 (2013...|$|E
40|$|There {{exists a}} class of {{widespread}} languages that use stack machines for interpretation of programs, the so called stack based languages (Java virtual machine language, Forth, Postscript, several intermediate program representation <b>languages</b> and <b>low</b> <b>level</b> <b>languages</b> in some embedded systems). Semantics of stack operations determines the language of correct programs in sense of parameter passing through the stack. This is one alternative method to de ne the syntax of a stack based language, the so called stack eect calculus. The other method is based on systems of syntactic equations (general rewriting rules for terminal sequences) on sequences of stack operations. Both methods seem to have better expression power for the stack based languages than traditional context free grammars...|$|R
40|$|Fourier {{methods are}} commonplace in the Earth Sciences and have greatly {{enhanced}} our understanding and forecast capabilities for cyclical phenomena that recur on interannual (e. g. El Niño, Pacific Decadal Oscillation) tomillennial scales (e. g. Milankovitch cycles). Nowadays most <b>low</b> <b>level</b> programming <b>languages</b> (C, Fortran) have math libraries {{that include the}} fas...|$|R
40|$|Abstract—Design {{of mobile}} robot control systems {{is a huge}} challenge, which require solving issues related to {{concurrent}} hardware access and providing high availability. Existing solu-tions in the domain are based on technologies using <b>low</b> <b>level</b> <b>languages</b> and shared memory concurrency model, which seems unsuitable for the task. In this paper {{a different approach to}} the problem of building a cyber-physical system for mobile robots control is presented. It is based on Erlang language and technology, which support lightweight processes, fault tolerance mechanisms and uses message passing concurrency model with built-in inter-process communication. Created system used a new, open-source robotic platform, which had been designed for scientific and educational purposes. Integrated system has been tested in several scenarios, proving flexibility, durability and high performance. I...|$|R
40|$|AbstractThe {{traditional}} {{split into}} a <b>low</b> <b>level</b> <b>language</b> {{and a high}} level language {{in the design of}} computer algebra systems may become obsolete with the advent of more versatile computer languages. We describe GiNaC, a special-purpose system that deliberately denies the need for such a distinction. It is entirely written in C++and the user can interact with it directly in that language. It was designed to provide efficient handling of multivariate polynomials, algebras and special functions that are needed for loop calculations in theoretical quantum field theory. It also bears some potential to become a more general purpose symbolic package...|$|E
40|$|Abstract. We {{describe}} different optimization {{techniques to}} perform the assembly of finite element matrices in Matlab and Octave, from the standard approach to recent vectorized ones, without any <b>low</b> <b>level</b> <b>language</b> used. We finally obtain a simple and efficient vectorized algorithm able to compete in performance with dedicated software such as FreeFEM++. The principle of this assembly algorithm is general, we present it for different matrices in the P 1 finite elements case. We present numerical results which illustrate the computational costs of the different approaches. hal- 00785101, version 1 - 5 Feb 2013 1. Introduction. Usuall...|$|E
40|$|The {{traditional}} split-up into a <b>low</b> <b>level</b> <b>language</b> and a {{high level}} language {{in the design of}} computer algebra systems may become obsolete with the advent of more versatile computer languages. We describe GiNaC, a special-purpose system that deliberately denies the need for such a distinction. It is entirely written in C++ and the user can interact with it directly in that language. It was designed to provide efficient handling of multivariate polynomials, algebras and special functions that are needed for loop calculations in theoretical quantum field theory. It also bears some potential to become a more general purpose symbolic package...|$|E
40|$|The PL. 8 {{compiler}} accepts {{multiple source}} languages and produces high quality object code for several different machines. The strategy used is to first do a simple {{translation of the}} source program to a <b>low</b> <b>level</b> intermediate <b>language.</b> Global optimization and register allocation are then used to improve code {{rather than relying on}} special case code selection...|$|R
40|$|Jody R. Threet (Ph. D. in Computer Science) A Formal Process Calculus and Execution Model for Distributed Agent Computing (55 pp. - V Chapters) Directed by Professor Sujeet Shenoi (237 words) Most <b>low</b> <b>level</b> machine <b>languages</b> {{reflect the}} {{hardware}} {{on which they}} execute. Current hardware promotes the development of sequential machine languages. Such languages do not provide atomic forms of communication which is a fundamental operation in distributed computing and severely restricts the expression of fine-grained concurrency. Furthermore, most high and <b>low</b> <b>level</b> programming <b>languages</b> lack formal semantics. This makes the analysis, i. e. the specification and proof of abstract properties, practically impossible. This work involves {{the design of a}} formal concurrent language which is a robust extension of an exiting flawed concurrent language. The fundamental event in the formal concurrent language is communication, so that computation consists of distributed agents communicating values. A co [...] ...|$|R
40|$|Byte-code Genetic Programming {{systems have}} shown their eOEciency with the {{commercial}} package Discipulus, from Nordin et al., proving that linear machine code can be successfully evolved, with a gain in speed {{of at least}} an order of magnitude. This concept has been transposed to several hardwares or <b>low</b> <b>level</b> <b>languages,</b> including byte-code for the Java virtual machine but no such system was widely available up to now. This paper proposes on an open-source Java byte-code extension for the ECJ library, called JEB for Java Evolutionary Byte-code. We detail the implementation choices that were made to deal notably with the stackbased particularities of the virtual machine. We perform some classic benchmarks to demonstrate the capabilities of JEB and we also point at some open questions about stack-based code evolution...|$|R
