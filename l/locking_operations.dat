15|234|Public
25|$|Btrieve for Windows {{was created}} {{before the company}} rewrote the {{codebase}} to use the MKDE. It featured SEFS and MEFS file sharing mechanisms; used shadow-paging and allowed for exclusive and concurrent locks. It handled version 6.x and 6.1 files differently. Version 6.x files could handle operations on part of a record rather than locking the entire record. It handled records larger than 64KB, implemented VATs, ACSs, new data types, allowed for percentage operations (where the record could be located and manipulated by the physical location in the file) and handled duplicate keys. Version 6.x was capable of dropping or adding any index on the fly (version 6.0 and below could drop only supplemental indexes). Version 6.1 files allowed for concurrent and system transactions, the optional renumbering of keys, case insensitive ACS tables, and enhanced <b>locking</b> <b>operations.</b>|$|E
50|$|The above example {{does not}} {{guarantee}} that the task has the lock, since more than one task can be testing the lock at the same time. Since both tasks will detect that the lock is free, both tasks will attempt to set the lock, not knowing that the other task is also setting the lock. Dekker's or Peterson's algorithm are possible substitutes if atomic <b>locking</b> <b>operations</b> are not available.|$|E
50|$|Btrieve for Windows {{was created}} {{before the company}} rewrote the {{codebase}} to use the MKDE. It featured SEFS and MEFS file sharing mechanisms; used shadow-paging and allowed for exclusive and concurrent locks. It handled version 6.x and 6.1 files differently. Version 6.x files could handle operations on part of a record rather than locking the entire record. It handled records larger than 64KB, implemented VATs, ACSs, new data types, allowed for percentage operations (where the record could be located and manipulated by the physical location in the file) and handled duplicate keys. Version 6.x was capable of dropping or adding any index on the fly (version 6.0 and below could drop only supplemental indexes). Version 6.1 files allowed for concurrent and system transactions, the optional renumbering of keys, case insensitive ACS tables, and enhanced <b>locking</b> <b>operations.</b>|$|E
40|$|This paper {{deals with}} the initial {{modeling}} of water salinity and its diffusion into the lakes during <b>lock</b> <b>operation</b> on the Panama Canal. A hybrid operational model was implemented using the AnyLogic software simulation environment. This was accomplished by generating an operational discrete-event simulation model and a continuous simulation model based on differential equations, which modeled the salinity diffusion in the lakes. This paper presents that unique application and includes the effective integration of <b>lock</b> <b>operations</b> {{and its impact on}} the environment...|$|R
40|$|A ship {{colliding with}} a lock gate {{can result in}} severe {{structural}} damage and disrupt the <b>lock</b> <b>operations.</b> For heavily trafficked waterways containing locks such disruption of the <b>lock</b> <b>operation</b> can result in severe economic consequences if the gate has to be repaired, both for the lock operator and for the delayed ships. Consequently, {{the consequences of a}} ship colliding with a lock gate must be assessed. Therefore, this paper will present current regulatory requirements and recommendations including gate protection systems. Furthermore, simulation methods will be presented to allow for a direct assessment of the structural consequences. Thus, these methods will potentially lead to new structural design considerations as well as operational limitations in terms of specific ship approach velocities to remain below critical impact energies and thus allow for an undisrupted <b>lock</b> <b>operation.</b> Peer reviewe...|$|R
25|$|The new locks have water-saving basins {{to reduce}} the volume of water that is needed in <b>lock</b> <b>{{operation}}.</b> The operation of both {{the old and new}} locks uses gravity and valves. There is no pumping involved.|$|R
40|$|This study {{investigates the}} {{complicated}} {{interaction between the}} deployment and locking processes of satellite flexible solar panel with {{the attitude of the}} satellite. Flexible panels have low fundamental vibration modes {{and are more likely to}} deflect and vibrate due to the inertia and external forces. These modes are often excited during normal on-orbit operations. In this study, the application of ADAMS (Automatic Dynamic Analysis of Mechanical Systems) and ANSYS computer programs to the modeling and simulation of the situation during solar panel deployment and <b>locking</b> <b>operations</b> is presented. The simulation result demonstrates how the deployment and <b>locking</b> <b>operations</b> affect the attitude of the satellite. Designers can use this model to decide as to which part they should give emphasis in the design of vibration control of the flexible solar panels...|$|E
40|$|Multithreaded {{programs}} are notoriously prone to synchronization errors. Much prior work has tackled {{the problem of}} detecting such errors. This paper focuses on the subsequent problem of synchronization correction. We present a constraint-based analysis that, given an erroneous program, automatically infers (where possible) what additional <b>locking</b> <b>operations</b> should be inserted in order to yield a correctly-synchronized program. For performance reasons, our algorithm also attempts to minimize the number of additional lock acquires and the duration for which the acquired locks are held. We present experimental results that validate this approach {{on a number of}} standard Java library classes. 1...|$|E
40|$|Memory-mapped {{transactions}} {{combine the}} advantages of both memory mapping and transactions to provide a programming interface for concurrently accessing data on disk without explicit I/O or <b>locking</b> <b>operations.</b> This interface enables a programmer to design a complex serial program that accesses only main memory, and with little to no modification, convert the program into correct code with multiple processes that can simultaneously access disk. I implemented Libxac, a prototype for an efficient and portable system supporting memory-mapped transactions. Libxac is a C library that supports atomic transactions on memory-mapped files. Libxac guarantees that transactions are serializable, and it uses a multiversion concurrency control algorithm {{to ensure that all}} transactions, even aborted transactions, always see a consistent view of a memorymapped file. Libxac was tested on Linux, and it is portable because it is written as a user-space library, and because it does not rely on special operating system support for transactions...|$|E
2500|$|Gatun Lake, an {{artificial}} lake {{formed by the}} building of the Gatun Dam, carries vessels [...] across the isthmus. It is the summit canal stretch, fed by the Gatun River and emptied by basic <b>lock</b> <b>operations.</b>|$|R
50|$|The new locks have water-saving basins {{to reduce}} the volume of water that is needed in <b>lock</b> <b>{{operation}}.</b> The operation of both {{the old and new}} locks uses gravity and valves. There is no pumping involved.|$|R
5000|$|Gatun Lake, an {{artificial}} lake {{formed by the}} building of the Gatun Dam, carries vessels 24.2 km across the isthmus. It is the summit canal stretch, fed by the Gatun River and emptied by basic <b>lock</b> <b>operations.</b>|$|R
40|$|Data sharing among tasks within {{multiprocessor}} real-time {{systems is}} a crucial issue. This report presents a fully asynchronous mechanism of sharing data between a single writer and multiple readers. The writer and all the readers are allowed to access the shared data asynchronously in a loop-free and wait-free manner because neither <b>locking</b> <b>operations</b> nor repeated actions of read-and-check are involved. Its implementation uses only (n + 2) buffer slots for n readers, and employs an atomic `Store-IfZero ' operation which can be easily simulated with the Compare-and-Swap instruction. Since neither writing nor reading the shared data imposes any effect upon other tasks in the system, this mechanism introduces no impact upon the timing behaviour of tasks. When employed by real-time applications, it helps to reduce blocking and priority inversion problems incurred by the commonly used lock-based synchronization mechanisms. 1 Introduction Data sharing is a basic approach to achieving inter [...] ...|$|E
40|$|This report {{presents}} {{an approach to}} implementing fully asynchronous reader/writer mechanisms which addresses the problems of priority inversion and blocking among tasks within multiprocessor real-time systems. The approach is conceived from the concept of process consensus that the writer and the reader {{come to an agreement}} on accessing the shared data before proceeding to carry out their respective data operations. Because neither <b>locking</b> <b>operations</b> nor repeated actions of read-and-check are involved, the shared data can be accessed at any time by the writer and all the readers in a manner not only wait-free but also loop-free. In addition, data sharing through this approach introduces no impact upon either timing behaviour or schedulability of any task in the system. Hence the approach can help to remove priority inversion and blocking incurred by the commonly used lock-based synchronization mechanisms. 1 Introduction The implementation of shared data objects is a very important iss [...] ...|$|E
40|$|The paper {{studies the}} impact of several lock manager designs on the {{overhead}} imposed to a persistent programming language by automated object locking. Our study reveals that a lock management method based on lock state sharing outperforms more traditional lock management designs. Lock state sharing is a novel lock management method that represents all lock data structures with equal values with a single shared data structure. Sharing the value of locks has numerous benefits: (i) it makes the space consumed by the lock manager small and independent {{of the number of}} locks acquired by transactions, (ii) it eliminates the need for expensive book-keeping of locks by transactions, and (iii) it enables the use of memoization techniques for whole <b>locking</b> <b>operations.</b> These advantages add up to make the release of locks practically free, and the processing of over 99 % of lock requests between 8 to 14 RISC instructions. 1...|$|E
40|$|A {{switchable}} mode - locking {{fiber laser}} is proposed {{by means of}} fiber Bragg grating (FBG). The FBG plays two key roles, the switchable wavelength operation and the spectral filtering effect, on the proposed laser. The switchable single-wavelength mode - <b>locking</b> <b>operation,</b> lasing at either 1545. 25 or 1548. 34 nm, corresponding to the central wavelengths of the FBGs, is obtained by appropriately rotating the polarization controllers (PC). In addition, the dual-wavelength mode - <b>locking</b> <b>operation</b> is observed with proper PC state. The switchable mode - <b>locking</b> <b>operation</b> attributes to the wavelength-dependent loss mechanism and the spectral filter formed by PCs and FBGs. A switchable mode-locking fiber laser is proposed by means of fiber Bragg grating (FBG). The FBG plays two key roles, the switchable wavelength operation and the spectral filtering effect, on the proposed laser. The switchable single-wavelength mode-locking operation, lasing at either 1545. 25 or 1548. 34 nm, corresponding to the central wavelengths of the FBGs, is obtained by appropriately rotating the polarization controllers (PC). In addition, the dual-wavelength mode-locking operation is observed with proper PC state. The switchable mode-locking operation attributes to the wavelength-dependent loss mechanism and the spectral filter formed by PCs and FBGs. (C) 2012 Society of Photo-Optical Instrumentation Engineers (SPIE). [DOI: 10. 1117 / 1. OE. 51. 11. 114202...|$|R
40|$|In the {{majority}} of large river systems, flow is regulated and/or otherwise affected by operational and management activities, such as ship locking. The effect of <b>lock</b> <b>operation</b> on sediment-water oxygen fluxes was studied within a 12. 9 km long impoundment at the Saar River (Germany) using eddy-correlation flux measurements. The continuous observations cover a time period of nearly 5 days and 39 individual locking events. Ship locking {{is associated with the}} generation of surges propagating back and forth through the impoundment which causes strong variations of near-bed current velocity and turbulence. These wave-induced flow variations cause variations in sediment-water oxygen fluxes. While the mean flux during time periods without <b>lock</b> <b>operation</b> was 0. 5 ± 0. 1 g m- 2 d- 1, it increased by about a factor of 2 to 1. 0 ± 0. 5 g m- 2 d- 1 within time periods with ship locking. Following the daily schedule of <b>lock</b> <b>operations,</b> fluxes are predominantly enhanced during daytime and follow a pronounced diurnal rhythm. The driving force for the increased flux is the enhancement of diffusive transport across the sediment-water interface by bottom-boundary layer turbulence and perhaps resuspension. Additional means by which the oxygen budget of the impoundment is affected by lock-induced flow variations are discussed...|$|R
50|$|Cons: Mechanically complex {{with more}} parts to fail. Some lockers require vehicle {{to stop for}} engagement. Needs human {{interaction}} and forward-thinking regarding upcoming terrain. Unskilled drivers often put massive stress on driveline components when leaving the differential in <b>locked</b> <b>operation</b> on terrain not requiring a locker.|$|R
40|$|Abstract — Software for {{autonomous}} robots solving challenging {{tasks in}} research or application {{is becoming increasingly}} complex. System integration {{has to deal with}} various different functional components. To decouple those components from each other and to enable a modular and reuseable software architecture a robot middleware is typically used. But this intermediate layer introduces significant additional overhead during run-time. In this work a methodology is described to utilize specific application characteristics to improve communication efficiency between different robot software modules. By composing several components in a single thread memory copying or <b>locking</b> <b>operations</b> can be avoided, when data is exchanged between those parts. The optimization can be achieved without compromising the advantages of a communication layer. Still the modifications are transparent to the maybe already existing components. Experimental results in the scenario of autonomous soccer-playing humanoid robots are presented and exhibit remarkable reduction in communication overhead. Furthermore this approach can be implemented in or on-top of other communication layers. I...|$|E
40|$|Memory-mapped {{transactions}} {{combine the}} advantages of both memory mapping and transactions to provide a programming interface for concurrently accessing data on disk without explicit I/O or <b>locking</b> <b>operations.</b> This interface enables a programmer to design a complex serial program that accesses only main memory, and with little to no modification, convert the program into correct code with multiple processes that can simultaneously access disk. I implemented Libxac, a prototype for an efficient and portable system supporting memory-mapped transactions. Libxac is a C library that supports atomic transactions on memory-mapped files. Libxac guarantees that transactions are serializable, and it uses a multiversion concurrency control algorithm {{to ensure that all}} transactions, even aborted transactions, always see a consistent view of a memorymapped file. Libxac was tested on Linux, and it is portable because it is written as a user-space library, and because it does not rely on special operating system support for transactions. Wit...|$|E
40|$|Safe {{programming}} languages {{encourage the}} development of dynamically extensible systems, such as extensible Web servers and mobile agent platforms. Although protection is of utmost importance in these settings, current solutions do not adequately address fault containment. This paper advocates an approach to protection where transactions act as protection domains. This enables direct sharing of objects while protecting against unauthorized accesses and failures of authorized components. The main questions about this approach are what transaction models translate best into protection mechanisms suited for extensible language-based systems {{and what is the}} impact of transaction-based protection on performance. A programmable isolation engine has been integrated with the runtime of a safe programming language in order to allow quick experimentation with a variety of isolation models and to answer both questions. This paper reports on the techniques for flexible finegrained locking and undo devised to meet the functional and performance requirements of transaction-based protection. Performance analysis of a prototype implementation shows that (i) sophisticated concurrency controls do not translate into higher overheads, and (ii) the ability to memoize <b>locking</b> <b>operations</b> is crucial to performance...|$|E
40|$|Abstract. This paper {{presents}} an expressive specification and verifica-tion framework for ensuring deadlock freedom of shared-memory con-current programs that manipulate locks. We introduce a novel delayed lockset checking technique to guarantee deadlock freedom of programs with interactions between thread and <b>lock</b> <b>operations.</b> With disjunctive formulae, we highlight how an abstraction based on precise lockset can be supported in our framework. By combining our technique with locklevels, we form a unified formalism for ensuring deadlock freedom from (1) dou-ble lock acquisition, (2) interactions between thread and <b>lock</b> <b>operations,</b> and (3) unordered locking. The proposed framework is general, {{and can be}} integrated with existing specification logics such as separation logic. Specifically, we have implemented this framework into a prototype tool, called ParaHIP, to automatically verify deadlock freedom and correct-ness of concurrent programs against user-supplied specifications...|$|R
40|$|Navigation canals {{are used}} for {{transport}} purposes. In order to allow safe navigation the water level {{should be kept in}} a certain range around the Normal Navigation Level (NNL). The water level is disturbed by known and unknown inputs, like tributaries, municipal water flows, rain, etc. Some of these inputs can be used to control the water level. If the geometry requires it, canal reaches are connected by <b>locks.</b> The <b>operation</b> of these <b>locks</b> sometimes can disturb the water level, if the difference between the upstream and downstream water level is large. The objective is to minimize the disturbances caused by these <b>lock</b> <b>operations</b> on the water level {{in order to maintain the}} NNL. In this work the global management of the canal reach is discussed and an option to maintain the NNL by active control is introduced. Some inputs to the system, such as other confluences or gates on the side of the locks, can be controlled automatically to react to the disturbances caused by the <b>lock</b> <b>operations</b> using model predictive control to maintain the desired water level. Postprint (published version...|$|R
5000|$|... #Caption: A release {{consistency}} example {{implemented by}} <b>lock</b> release <b>operation.</b>|$|R
40|$|Motivated {{by the way}} R-trees are {{implemented}} in commercial databases systems, {{in this paper we}} examine several deletion techniques for R-trees. In particular, in commercial systems R-tree entries are mapped onto relational tables, which implement their own concurrency protocols on top of existing table-level concurrency mechanisms. In analogy, the actual industrial implementations of B-trees do not apply the well-known merging procedure from textbooks in case of node underflows, but rather they apply the free-at-empty technique. This way, space is sacrificed for the benefit of faster deletions and less <b>locking</b> <b>operations,</b> whereas the search performance practically remains unaffected. In this context, we examine the efficiency of modifications to the original R-tree deletion algorithm, which relax certain constraints of this algorithm and perform a controlled reorganization procedure according to a specified criterion. We present the modified algorithms and experimental results about the impact of these modifications on the tree quality, the execution time for the deletion operation and the processing time of search queries, considering several parameters. The experimental results indicate that the modified algorithms improve the efficiency of the deletion operation, while they do not affect the quality of the R-tree and its performance with respect to search operations...|$|E
40|$|Abstract—Locking is a {{standard}} technique in distributed computing and database systems used to ensure data integrity by prohibiting concurrent conflicting updates on shared data objects. Internet-based collaborative systems are a special class of distributed applications which support human-to-human interaction and collaboration over the Internet. In this paper, a novel optional and responsive fine-grain locking scheme is proposed for consistency maintenance in Internet-based collaborative editors. In the proposed scheme, locking is made optional {{in the sense that}} a user may update any part of the document without necessarily requesting a lock, thus saving the users the burden of having to use locks while editing and the system the overhead of executing <b>locking</b> <b>operations</b> most of the time in a collaborative editing session. In the face of high communication latency in the Internet environment, responsive locking is achieved by granting the permit to the user for updating the data region immediately after issuing a locking request. Moreover, multiple fine-grain locks can be placed on different regions inside a document to allow concurrent and mutually exclusive editing on the same document. Protocols and algorithms for locking conflict resolution and consistency maintenance are devised to address special technical issues involved in optional and responsive fine-grain locking. The proposed locking scheme and supporting techniques have been implemented in an Internet-based collaborative editor to demonstrate its feasibility and usability. Index Terms—Consistency maintenance, optional locking, responsiveness, operational transformation, collaborative editors, distributed systems, Internet computing. ...|$|E
40|$|Memory-mapped {{transactions}} {{combine the}} advantages of both memory mapping and transactions to provide a programming interface for concurrently accessing data on disk without explicit I/O or <b>locking</b> <b>operations.</b> This interface enables a programmer to design a complex serial program that accesses only main memory, and with little to no modification, convert the program into correct code with multiple processes that can simultaneously access disk. I implemented LIBXAC, a prototype for an efficient and portable system supporting memory-mapped transactions. LIBXAC is a C library that supports atomic transactions on memory-mapped files. LIBXAC guarantees that transactions are serializable, and it uses a multiversion concurrency control algorithm {{to ensure that all}} transactions, even aborted transactions, always see a consistent view of a memory-mapped file. LIBXAC was tested on Linux, and it is portable because it is written as a user-space library, and because it does not rely on special operating system support for transactions. With LIBXAC, I was easily able to convert existing serial, memory-mapped implementations of a B+-tree and a cache-oblivious B-tree into parallel versions that support concurrent searches and insertions. (cont.) To test the performance of memory-mapped transactions, I ran several experiments inserting elements with random keys into the LIBXAC B+-tree and LIBXAC cache-oblivious B-tree. When a single process performed each insertion as a durable transaction, the LIBXAC search trees ran between 4 % slower and 67 % faster than the B-tree for Berkeley DB, a high-quality transaction system. Memory-mapped transactions have the potential to greatly simplify the programming of concurrent data structures for databases. by Jim Sukha. Thesis (M. Eng.) [...] Massachusetts Institute of Technology, Dept. of Electrical Engineering and Computer Science, 2005. Includes bibliographical references (p. 149 - 154) ...|$|E
40|$|National High Technology Research and Development Program of China [2014 AA 041901]; NSAF Foundation of National Natural Science Foundation of China [U 1330134]; National Natural Science Foundation of China [61308024]We {{present a}} widely tunable all-fiber mode-locked laser based on {{semiconductor}} saturable absorber mirror (SESAM) with a linear cavity design. An easy-to-use {{tunable bandpass filter}} based on thin film cavity technology is employed to tune the wavelength. By tuning the filter and adjusting the polarization controller, shade-locked operation can be achieved over the range of 1023 nm- 1060 nm. With the polarization controller settled, mode <b>locked</b> <b>operation</b> can be preserved and the wavelength can be continuously tuned from 1030 nm to 1053 nm. At 1030 nm, the laser delivers 9. 6 mw average output power with 15. 4 ps 10. 96 MHz pulses at fundamental mode <b>locked</b> <b>operation...</b>|$|R
40|$|The real <b>lock</b> <b>operations</b> with {{ships and}} barge convoys areconsidered {{dependent}} on the transport technologies applied, ormore precisely, the kinds of ships/convoys requiring thelockage. The fleet can be divided as follows: (1) groups of singleships, (2) pushed and pulled tows of barges and (3) differentcombinations of previous systems (1) and (2). The groups ofships and tows passing through the lock have extremely stochasticcharacteristics thus forming various arrivals and setvicetime patterns. It means that uniform navigation or strongscheduling between <b>locks</b> and <b>lock</b> <b>operations</b> are not possibleeven though highly sophisticated equipment is at disposal. Therefore, in this paper an analytical method was developedusing bulk queuing systems for the analysis and planning oflock requirements supporting it with numerical example. Thedeveloped methodology {{can be applied to}} determine the meanqueue length of ships - convoys at lock anchorage, withoutblocking behaviour between upstream and downstream navigationfor single-lane traffic...|$|R
50|$|All locks of the Tennessee-Tombigbee Waterway operate 24 hours a day, 7 days a week. For large vessels, <b>lock</b> <b>operation</b> is made on demand. For {{pleasure}} boats using the Amory Lock, the lock operates {{in the morning}} at 5, 7, 9, and 11 A.M., and in the afternoon at 1, 3, 5, and 7 P.M.|$|R
5000|$|... #Caption: The <b>locks</b> in <b>operation,</b> as {{imagined}} by {{a sketch}} artist in 1900.|$|R
40|$|Synchronization {{overhead}} {{may limit}} the number of applications that can take advantage of a shared-memory abstraction on top of emerging network of workstation organizations. While the programmer could spend additional efforts into getting rid of such overhead by restructuring the computation, this paper focuses on a simpler approach where the overhead of <b>lock</b> <b>operations</b> is hidden through lock prefetch annotations...|$|R
40|$|Two-dimensional (2 D) nanomaterials, {{especially}} the transition metal sulfide semiconductors, have drawn great interests {{due to their}} potential applications in viable photonic and optoelectronic devices, such as saturable absorbers (SAs) and optical switches, etc. In this work, tungsten disulfide (WS 2) based SA for ultrafast photonic applications was demonstrated. WS 2 nanosheets were prepared using liquid-phase exfoliation method and embedded in polyvinyl alcohol (PVA) thin film for the practical usage. Saturable absorption was observed in the WS 2 -PVA SA at the telecommunication waveband near 1550 nm. By incorporating WS 2 -PVA SA into a fiber laser cavity, both stable mode <b>locking</b> <b>operation</b> and Q-switching operation were achieved. In the mode <b>locking</b> <b>operation,</b> the laser obtained femtosecond output pulse width and high spectral purity in the radio frequency spectrum. In the Q-switching operation, the laser had tunable repetition rate and output pulse energy of a few tens of nano joule. Our findings suggest that few-layer WS 2 nanosheets embedded in PVA thin film are promising nonlinear optical materials for ultrafast photonic applications as a mode locker or Q-switcher. Comment: 15 pages, 6 figure...|$|R
40|$|Locks {{are used}} to ensure {{exclusive}} access to shared memory locations. Unfortunately, <b>lock</b> <b>operations</b> are expensive, so much {{work has been done}} on optimizing their performance for common access patterns. One such pattern is found in networking applications, where there is a single thread dominating lock accesses. An important special case arises when a single-threaded program calls a thread-safe library that uses locks. An effective way to optimize the dominant-thread pattern is to "bias" the lock implementation so that accesses by the dominant thread have negligible overhead. We take this approach in this work: we simplify and generalize existing techniques for biased locks, producing a large design space with many trade-offs. For example, if we assume the dominant process acquires the lock infinitely often (a reasonable assumption for packet processing), it is possible to make the dominant process perform a <b>lock</b> <b>operation</b> without expensive fence or compare-and-swap instructions. This gives a very low overhead solution; we confirm its efficacy by experiments. We show how these constructions can be extended for lock reservation, re-reservation, and to reader-writer situations...|$|R
40|$|Composing {{software}} is notoriously difficult, {{especially when it}} is concurrent. Two fine-grained <b>locked</b> <b>operations</b> may for instance easily deadlock upon composition. One of the most appealing features of transactions is, on the other hand, that they compose. Indeed they do so, but only in their original, orthodox, form. As we discuss in the paper, {{as soon as we}} slightly relax the model to enable more concurrency, we incur the risk of breaking encapsulation. ...|$|R
50|$|Skeleton keys {{have often}} been {{associated}} with attempts to defeat locks for illicit purposes, to release handcuffs for example, and standard keys have been filed down for that purpose. Legitimate skeleton or master keys are used in many modern contexts where <b>lock</b> <b>operation</b> is required and the original key has been lost or is not available. In hotels without electronic locks, skeleton keys are used by housekeeping services to enter the rooms.|$|R
