125|394|Public
25|$|Named {{functions}} {{are created by}} storing a <b>lambda</b> <b>expression</b> in a symbol using the defun macro.|$|E
25|$|Given a lambda {{term with}} first {{argument}} representing recursive call (e.g. G here), the fixed-point combinator FIX will return a self-replicating <b>lambda</b> <b>expression</b> representing the recursive function (here, F). The function {{does not need}} to be explicitly passed to itself at any point, for the self-replication is arranged in advance, when it is created, to be done each time it is called. Thus the original <b>lambda</b> <b>expression</b> (FIX G) is re-created inside itself, at call-point, achieving self-reference.|$|E
25|$|Church's proof first {{reduces the}} problem to {{determining}} whether a given <b>lambda</b> <b>expression</b> has a normal form. A normal form is an equivalent expression that cannot be reduced any further under the rules imposed by the form. Then he assumes that this predicate is computable, and can hence be expressed in lambda calculus. Building on earlier work by Kleene and constructing a Gödel numbering for lambda expressions, he constructs a <b>lambda</b> <b>expression</b> e that closely follows the proof of Gödel's first incompleteness theorem. If e is applied to its own Gödel number, a contradiction results.|$|E
40|$|We propose {{extensions}} to <b>lambda</b> <b>expressions</b> {{motivated by}} the general view that <b>lambda</b> <b>expressions</b> should allow for a concise and complete description of a callable unit of computation. In addition to containing those features from document N 3418 : Proposal for Generic (Polymorphic) <b>Lambda</b> <b>Expressions</b> that received against votes in Portland (2012), it also contains other small extensions to lambdas. We also present our experience implementing some of the features using Clang. ...|$|R
2500|$|... by Peter Kelly, Paul Coddington, and Andrew Wendelborn; {{mentions}} {{graph reduction}} {{as a common}} means of evaluating <b>lambda</b> <b>expressions</b> and discusses the applicability of lambda calculus for distributed computing (due to the Church–Rosser property, which enables parallel graph reduction for <b>lambda</b> <b>expressions).</b>|$|R
50|$|See also {{translating}} between let and <b>lambda</b> <b>expressions.</b>|$|R
25|$|The self-application {{achieves}} replication here, {{passing the}} function's <b>lambda</b> <b>expression</b> {{on to the}} next invocation as an argument value, making it available to be referenced and called there.|$|E
25|$|This {{process is}} also known as {{abstraction}} elimination. Note that this definition is exhaustive; any <b>lambda</b> <b>expression</b> will be subject to exactly one of these rules (see Summary of lambda calculus above).|$|E
25|$|Every recursively defined {{function}} {{can be seen}} as a {{fixed point}} of some suitably defined function closing over the recursive call with an extra argument, and therefore, using Y, every recursively defined function can be expressed as a <b>lambda</b> <b>expression.</b> In particular, we can now cleanly define the subtraction, multiplication and comparison predicate of natural numbers recursively.|$|E
5000|$|... #Subtitle level 3: <b>Lambda</b> <b>expressions</b> and {{function}} definition ...|$|R
2500|$|JSR 335, JEP 126: Language-level {{support for}} <b>lambda</b> <b>expressions</b> (officially, <b>lambda</b> expressions; unofficially, closures) under Project Lambda and default methods (virtual {{extension}} methods) which allow {{the addition of}} methods to interfaces without breaking existing implementations. There was an ongoing debate in the Java community on whether to add support for <b>lambda</b> <b>expressions.</b> Sun later declared that <b>lambda</b> <b>expressions</b> would be included in Java and asked for community input to refine the feature. Supporting <b>lambda</b> <b>expressions</b> also allows the performance of [...] functional-style operations on streams of elements, such as MapReduce-inspired transformations on collections. Default methods allow an author of an API to add new methods to an interface without breaking the old code using it. Although it was not their primary intent, default methods also allow multiple inheritance of behavior (but not state).|$|R
40|$|This {{proposal}} {{describes a}} design for direct support for <b>lambda</b> <b>expressions</b> in C++. The design space for <b>lambda</b> <b>expressions</b> is large, and involves many tradeoffs. We include a thorough {{discussion of the}} benefits and the drawbacks of our design. In addition, we describe several other viable alternatives that warrant consideration. ...|$|R
25|$|Recursion is the {{definition}} of a function using the function itself. Lambda calculus cannot express this as directly as some other notations: all functions are anonymous in lambda calculus, so we can't refer to a value which is yet to be defined, inside the lambda term defining that same value. However, recursion can still be achieved by arranging for a <b>lambda</b> <b>expression</b> to receive itself as its argument value, for example in (λx.x x) E.|$|E
25|$|A {{function}} F: N → N {{of natural}} numbers is a computable function if {{and only if}} there exists a <b>lambda</b> <b>expression</b> f such that for every pair of x, y in N, F(x)=y {{if and only if}} f x=βy, where x and y are the Church numerals corresponding to x and y, respectively and =β meaning equivalence with beta reduction. This {{is one of the many}} ways to define computability; see the Church–Turing thesis for a discussion of other approaches and their equivalence.|$|E
2500|$|For example, in Lisp the 'square' {{function}} can {{be expressed}} as a <b>lambda</b> <b>expression</b> as follows: ...|$|E
2500|$|The set of <b>lambda</b> <b>expressions,</b> Λ, can {{be defined}} inductively: ...|$|R
50|$|Haskell uses a concise syntax for {{anonymous}} functions (<b>lambda</b> <b>expressions).</b>|$|R
5000|$|The set of <b>lambda</b> <b>expressions,</b> Λ, can {{be defined}} inductively: ...|$|R
2500|$|In the <b>lambda</b> <b>expression</b> {{which is}} to {{represent}} this function, a parameter (typically the first one) will be assumed to receive the <b>lambda</b> <b>expression</b> itself as its value, so that calling it [...] applying it to an argument [...] will amount to recursion. Thus to achieve recursion, the intended-as-self-referencing argument (called r here) must always be passed to itself within the function body, at a call point: ...|$|E
2500|$|The set of free {{variables}} of a <b>lambda</b> <b>expression,</b> M, is denoted as FV(M) and {{is defined by}} recursion {{on the structure of}} the terms, as follows: ...|$|E
2500|$|In formal {{contexts}} such as Scheme standards, {{the word}} [...] "procedure" [...] {{is used in}} preference to [...] "function" [...] {{to refer to a}} <b>lambda</b> <b>expression</b> or primitive procedure. [...] In normal usage, the words [...] "procedure" [...] and [...] "function" [...] are used interchangeably. [...] Procedure application is sometimes referred to formally as combination.|$|E
50|$|Java {{supports}} anonymous functions, named <b>Lambda</b> <b>Expressions,</b> {{starting with}} JDK 8.|$|R
50|$|Visual Basic and C#, {{by using}} {{anonymous}} methods or <b>lambda</b> <b>expressions.</b>|$|R
5000|$|... since C++11: {{by using}} <b>lambda</b> <b>expressions</b> as the {{quicksort}} example above.|$|R
2500|$|Expressions {{are written}} as lists, using prefix notation. The first {{element in the}} list {{is the name of}} a function, the name of a macro, a <b>lambda</b> <b>expression</b> or the name of a [...] "special operator" [...] (see below). The {{remainder}} of the list are the arguments. For example, the function [...] returns its arguments as a list, so the expression ...|$|E
2500|$|Scheme is a {{very simple}} language, much easier to {{implement}} than many other languages of comparable expressive power. [...] This ease is attributable {{to the use of}} lambda calculus to derive much of the syntax of the language from more primitive forms. [...] For instance of the 23 s-expression-based syntactic constructs defined in the R5RS Scheme standard, 11 are classed as derived or library forms, which can be written as macros involving more fundamental forms, principally lambda. [...] As R5RS says (R5RS sec. 3.1): [...] "The most fundamental of the variable binding constructs is the <b>lambda</b> <b>expression,</b> because all other variable binding constructs can be explained in terms of lambda expressions." ...|$|E
2500|$|A Church numeral is a higher-order {{function}}—it takes a single-argument function f, {{and returns}} another single-argument function. The Church numeral n {{is a function}} that takes a function f as argument and returns the n-th composition of f, i.e. the function f composed with itself n times. This is denoted f(n) and {{is in fact the}} n-th power of f (considered as an operator); f(0) is defined to be the identity function. Such repeated compositions (of a single function f) obey the laws of exponents, which is why these numerals can be used for arithmetic. (In Church's original lambda calculus, the formal parameter of a <b>lambda</b> <b>expression</b> was required to occur at least once in the function body, which made the above definition of 0 impossible.) ...|$|E
5000|$|... (E E&prime;), an application, where E and E&prime; are any <b>lambda</b> <b>expressions.</b>|$|R
25|$|The {{meaning of}} <b>lambda</b> <b>{{expressions}}</b> {{is defined by}} how expressions can be reduced.|$|R
50|$|C# {{supports}} closures as anonymous methods or <b>lambda</b> <b>expressions</b> with full-featured closure semantics.|$|R
5000|$|In this example, the <b>lambda</b> <b>expression</b> [...] appears {{within the}} {{function}} [...] When the <b>lambda</b> <b>expression</b> is evaluated, Scheme creates a closure {{consisting of the}} code for the <b>lambda</b> <b>expression</b> and {{a reference to the}} [...] variable, which is a free variable inside the <b>lambda</b> <b>expression.</b>|$|E
5000|$|Substitution Operator, [...] is the {{substitution}} of the name [...] by the <b>lambda</b> <b>expression</b> [...] in <b>lambda</b> <b>expression</b> [...]|$|E
50|$|The set of free {{variables}} of a <b>lambda</b> <b>expression,</b> M, is denoted as FV(M). This is {{the set of}} variable names that have instances not bound (used) in a lambda abstraction, within the <b>lambda</b> <b>expression.</b> They are the variable names that may be bound to formal parameter variables from outside the <b>lambda</b> <b>expression.</b>|$|E
50|$|The {{meaning of}} <b>lambda</b> <b>{{expressions}}</b> {{is defined by}} how expressions can be reduced.|$|R
2500|$|To {{keep the}} {{notation}} of <b>lambda</b> <b>expressions</b> uncluttered, the following conventions are usually applied: ...|$|R
50|$|To {{keep the}} {{notation}} of <b>lambda</b> <b>expressions</b> uncluttered, the following conventions are usually applied.|$|R
