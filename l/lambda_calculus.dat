2190|10|Public
5|$|His {{question}} was answered by Gödel's incompleteness proof, Turing's machine and Church's <b>Lambda</b> <b>calculus.</b>|$|E
25|$|<b>Lambda</b> <b>calculus</b> has {{applications}} {{in many different}} areas in mathematics, philosophy, linguistics, and computer science. <b>Lambda</b> <b>calculus</b> has {{played an important role}} in the development of the theory of programming languages. Functional programming languages implement the <b>lambda</b> <b>calculus.</b> <b>Lambda</b> <b>calculus</b> also is a current research topic in Category theory.|$|E
25|$|<b>Lambda</b> <b>calculus</b> {{definition}} - Formal {{definition of}} the <b>lambda</b> <b>calculus.</b>|$|E
25|$|Deductive <b>lambda</b> <b>calculus</b> – The {{consideration}} of {{the problems associated with}} considering <b>lambda</b> <b>calculus</b> as a Deductive system.|$|E
25|$|There is a {{considerable}} body of programming idioms for <b>lambda</b> <b>calculus.</b> Many of these were originally developed {{in the context of}} using <b>lambda</b> <b>calculus</b> as a foundation for programming language semantics, effectively using <b>lambda</b> <b>calculus</b> as a low-level programming language. Because several programming languages include the <b>lambda</b> <b>calculus</b> (or something very similar) as a fragment, these techniques also see use in practical programming, but may then be perceived as obscure or foreign.|$|E
25|$|Binary <b>lambda</b> <b>calculus</b> – A {{version of}} <b>lambda</b> <b>calculus</b> with binary I/O, a binary {{encoding}} of terms, and a designated universal machine.|$|E
25|$|The {{fact that}} <b>lambda</b> <b>calculus</b> terms act as {{functions}} on other <b>lambda</b> <b>calculus</b> terms, {{and even on}} themselves, led to questions about the semantics of the <b>lambda</b> <b>calculus.</b> Could a sensible meaning be assigned to <b>lambda</b> <b>calculus</b> terms? The natural semantics {{was to find a}} set D isomorphic to the function space D → D, of functions on itself. However, no nontrivial such D can exist, by cardinality constraints because the set of all functions from D to D has greater cardinality than D, unless D is a singleton set.|$|E
25|$|The Church–Rosser {{property}} of the <b>lambda</b> <b>calculus</b> means that evaluation (β-reduction) {{can be carried out}} in any order, even in parallel. This means that various nondeterministic evaluation strategies are relevant. However, the <b>lambda</b> <b>calculus</b> does not offer any explicit constructs for parallelism. One can add constructs such as Futures to the <b>lambda</b> <b>calculus.</b> Other process calculi have been developed for describing communication and concurrency.|$|E
25|$|Subsequently, in 1936 Church {{isolated}} and published just the portion relevant to computation, {{what is now}} called the untyped <b>lambda</b> <b>calculus.</b> In 1940, he also introduced a computationally weaker, but logically consistent system, known as the simply typed <b>lambda</b> <b>calculus.</b>|$|E
25|$|Using a <b>lambda</b> <b>calculus</b> calculator, {{the above}} {{expression}} reduces to 3, using normal order.|$|E
25|$|The {{expressions}} to be typed {{are exactly}} {{those of the}} <b>lambda</b> <b>calculus,</b> enhanced by a let-expression.|$|E
25|$|Another {{aspect of}} the untyped <b>lambda</b> <b>calculus</b> {{is that it does}} not {{distinguish}} between different kinds of data.|$|E
25|$|For the untyped <b>lambda</b> <b>calculus,</b> β-reduction as a {{rewriting}} rule is neither strongly normalising nor weakly normalising.|$|E
25|$|The <b>lambda</b> <b>calculus</b> {{may be seen}} as an {{idealised}} {{version of}} a functional programming language, like Haskell or Standard ML.|$|E
25|$|In {{mathematical}} logic and computer science, lambda {{is used to}} introduce anonymous functions expressed with the concepts of <b>lambda</b> <b>calculus.</b>|$|E
25|$|Recursion is the {{definition}} of a function using the function itself. <b>Lambda</b> <b>calculus</b> cannot express this as directly as some other notations: all functions are anonymous in <b>lambda</b> <b>calculus,</b> so we can't refer to a value which is yet to be defined, inside the lambda term defining that same value. However, recursion can still be achieved by arranging for a lambda expression to receive itself as its argument value, for example in (λx.x x) E.|$|E
25|$|The basic <b>lambda</b> <b>calculus</b> {{may be used}} {{to model}} booleans, arithmetic, data {{structures}} and recursion, as illustrated in the following sub-sections.|$|E
25|$|A central {{property}} of the <b>lambda</b> <b>calculus</b> is, that recursive definitions are non-elemental, but can instead be expressed by a fixed point combinator.|$|E
25|$|In <b>lambda</b> <b>calculus,</b> {{functions}} {{are taken to}} be 'first class values', so functions {{may be used as}} the inputs, or be returned as outputs from other functions.|$|E
25|$|Kleene, Stephen, A {{theory of}} {{positive}} integers in formal logic, American Journal of Mathematics, 57 (1935), pp.153173 and 219244. Contains the <b>lambda</b> <b>calculus</b> definitions of several familiar functions.|$|E
25|$|As {{described}} above, all {{functions in}} the <b>lambda</b> <b>calculus</b> are anonymous functions, having no names. They only accept one input variable, with currying used to implement functions with several variables.|$|E
25|$|This {{process is}} also known as {{abstraction}} elimination. Note that this definition is exhaustive; any lambda expression will be subject to exactly one of these rules (see Summary of <b>lambda</b> <b>calculus</b> above).|$|E
25|$|In the 1970s, Dana Scott showed that, if only {{continuous}} functions were considered, a set or domain D {{with the}} required property could be found, thus providing {{a model for}} the <b>lambda</b> <b>calculus.</b>|$|E
25|$|The use of {{mathematical}} logic to represent and execute computer programs {{is also a}} feature of the <b>lambda</b> <b>calculus,</b> developed by Alonzo Church in the 1930s. However, the first proposal to use the clausal form of logic for representing computer programs was made by Cordell Green. This used an axiomatization of a subset of LISP, together with a representation of an input-output relation, to compute the relation by simulating the execution of the program in LISP. Foster and Elcock's Absys, on the other hand, employed a combination of equations and <b>lambda</b> <b>calculus</b> in an assertional programming language which places no constraints on the order in which operations are performed.|$|E
25|$|For instance, {{it may be}} {{desirable}} to write a function that only operates on numbers. However, in the untyped <b>lambda</b> <b>calculus,</b> {{there is no way}} to prevent a function from being applied to truth values, strings, or other non-number objects.|$|E
25|$|Typed lambda calculi {{are closely}} related to {{mathematical}} logic and proof theory via the CurryHoward isomorphism and they can be considered as the internal language of classes of categories, e.g. the simply typed <b>lambda</b> <b>calculus</b> is the language of Cartesian closed categories (CCCs).|$|E
25|$|Under this view, beta {{reduction}} {{corresponds to}} a computational step. This step can be repeated by additional beta conversions until {{there are no more}} applications left to reduce. In the untyped <b>lambda</b> <b>calculus,</b> as presented here, this reduction process may not terminate.|$|E
25|$|Alpha-conversion, {{sometimes}} {{known as}} alpha-renaming, allows bound variable names to be changed. For example, alpha-conversion of λx.x might yield λy.y. Terms that differ only by alpha-conversion are called α-equivalent. Frequently, in uses of <b>lambda</b> <b>calculus,</b> α-equivalent terms {{are considered to}} be equivalent.|$|E
25|$|The <b>lambda</b> <b>calculus</b> was {{introduced}} by mathematician Alonzo Church in the 1930s {{as part of an}} investigation into the foundations of mathematics. The original system was shown to be logically inconsistent in 1935 when Stephen Kleene and J. B. Rosser developed the KleeneRosser paradox.|$|E
25|$|These {{concepts}} {{are discussed in}} a more precise way in functional programming and its foundational disciplines, <b>lambda</b> <b>calculus</b> and combinatory logic. Terminology varies between languages; some computer languages such as C define parameter and argument as given here, while Eiffel uses an alternative convention.|$|E
25|$|Most {{real-world}} languages have {{support for}} machine-native integers; {{the church and}} unchurch functions convert between nonnegative integers and their corresponding Church numerals. The functions are given here in Haskell, where the \ corresponds to the λ of <b>Lambda</b> <b>calculus.</b> Implementations in other languages are similar.|$|E
25|$|The <b>lambda</b> <b>calculus</b> {{consists}} of a language of lambda terms, which is defined by a certain formal syntax, {{and a set of}} transformation rules, which allow manipulation of the lambda terms. These transformation rules can be viewed as an equational theory or as an operational definition.|$|E
25|$|<b>Lambda</b> <b>calculus</b> is Turing complete, that is, it is a {{universal}} model of computation {{that can be used}} to simulate any Turing machine. Its namesake, the Greek letter lambda (λ), is used in lambda expressions and lambda terms to denote binding a variable in a function.|$|E
25|$|Internal Homs, when chained together, form a language, {{called the}} {{internal}} {{language of the}} category. The most famous of these are simply typed <b>lambda</b> <b>calculus,</b> which is the internal language of Cartesian closed categories, and the linear type system, which is the internal language of closed symmetric monoidal categories.|$|E
25|$|The {{theory of}} {{semantics}} of programming languages {{is related to}} model theory, as is program verification (in particular, model checking). The CurryHoward isomorphism between proofs and programs relates to proof theory, especially intuitionistic logic. Formal calculi such as the <b>lambda</b> <b>calculus</b> and combinatory logic are now studied as idealized programming languages.|$|E
25|$|Combinatory {{logic is}} a {{notation}} {{to eliminate the}} need for quantified variables in mathematical logic. It was introduced by Moses Schönfinkel In the latter 1930s, Alonzo Church and his students at Princeton invented a rival formalism for functional abstraction, the <b>lambda</b> <b>calculus,</b> which proved more popular than combinatory logic. The upshot of these historical contingencies was that until theoretical computer science began taking an interest in combinatory logic in the 1960s and 1970s, nearly all work on the subject was by Haskell Curry and his students, or by Robert Feys in Belgium. Curry and Feys (1958), and Curry et al. (1972) survey the early history of combinatory logic. For a more modern treatment of combinatory logic and the <b>lambda</b> <b>calculus</b> together, see the book by Barendregt, which reviews the models Dana Scott devised for combinatory logic in the 1960s and 1970s.|$|E
