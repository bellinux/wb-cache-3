37|31|Public
25|$|Panels: {{drag and}} drop <b>layout</b> <b>manager</b> that allows site administrators to {{visually}} design their site.|$|E
5000|$|... text system features: {{rich text}} format, text attachments, <b>layout</b> <b>manager,</b> typesetter, rules, {{paragraph}} styles, font management, spelling ...|$|E
5000|$|Layout Manager: The <b>Layout</b> <b>Manager</b> {{allows the}} user to {{automatically}} create localised layouts by resizing controls, dialogs and buttons ensuring that any text that has expanded during the translation process will fit appropriately on the user interface.|$|E
5000|$|IFC already {{provided}} two <b>Layout</b> <b>managers,</b> {{that would}} be later included in the standard JDK ...|$|R
50|$|Contrary to Swing where <b>layout</b> <b>managers</b> can {{be applied}} to any {{container}} widget, Android layout behavior is encoded in the containers.|$|R
50|$|Those {{where the}} layout {{behavior}} is coded in <b>layout</b> <b>managers,</b> {{that can be}} applied to any graphic container. This is the case in the Swing widget toolkit {{that is part of the}} Java API.|$|R
5000|$|Tk: The {{most popular}} Tcl {{extension}} is the Tk toolkit, {{which provides a}} graphical user interface library {{for a variety of}} operating systems. Each GUI consists of one or more frames. Each frame has a <b>layout</b> <b>manager.</b>|$|E
5000|$|Trying {{to provide}} [...] "the minimal set of data-structuring (models and collections) and user {{interface}} (views and URLs)", leaves to the developer {{the choice of}} extensions for enhanced functionality. For example, one can use nested views with Backbone <b>Layout</b> <b>Manager</b> or model-view binding with ReSTbasis.|$|E
50|$|The {{framework}} supports data binding, event handling, validation {{and includes}} a NetBeans plug-in for interactive creation of the user interface. The project also features some innovative features such as an implementation of the new synth Look and Feel using SVG plus an interactive <b>layout</b> <b>manager</b> using guidelines.|$|E
5000|$|... LWUIT is very {{different}} from Swing and has taken on features unavailable in Swing such as theming, painters, animations, etc. However features such as MVC, <b>layout</b> <b>managers,</b> renders and the EDT are directly related to Swing.|$|R
5000|$|A general {{interface}} between Java {{and the native}} system, used for windowing, events, and <b>layout</b> <b>managers.</b> This API {{is at the core}} of Java GUI programming and is also used by Swing and Java 2D. It contains: ...|$|R
50|$|Another form {{of layout}} {{is found in}} <b>layout</b> <b>managers.</b> They are part of widget toolkits and {{have the ability to}} {{automatically}} calculate a widget's position based on alignment constraints without the need for the programmer to specify absolute coordinates.|$|R
5000|$|Text can be {{rendered}} using standard Java text functions. These text-rendering functions are extended {{with a more}} advanced text <b>layout</b> <b>manager</b> that integrates with the BD-J UI framework. The text is rendered using a vector-based font either coming from the disc, the player (default font) or downloaded from the network.|$|E
50|$|The {{web page}} is created as RIA. The content is loaded in the background, JavaScript methods are {{changing}} the DOM of the main page, which acts like a <b>layout</b> <b>manager</b> with so called floating windows. Different applications run concurrently in {{the environment of the}} web page and communicate among each other. The applications are built as pure JavaScript, Java applets and flash applets.|$|E
50|$|The {{rules for}} {{performing}} contextual substitutions are implemented as state machines {{built into the}} font, and interpreted by the LLM Line <b>Layout</b> <b>Manager,</b> the counterpart of the CMM Color Management Module for ColorSync services. Text management in the operating system allowed QuickDraw GX to accept character strings with any mix of writing systems and scripts, and compose the strings automatically, whether the encoding was Unicode 1.0 or 8 bit and 8/16 bit encodings.|$|E
40|$|EiffelVision 2 is an {{object-oriented}} {{library for}} developing graphical user in-terfaces in Eiffel. It offers several strategies to organise widgets in windows, and each strategy {{has its own}} specific language and features. language to develop user interfaces {{that is based on}} the mathematical model of linear programming. The resulting framework is seamlessly integrated in Eif-felVision 2 and offers developers a valid alternative to existing <b>layout</b> <b>managers.</b> Acknowledgments I would like to express my sincere gratitude to my mentor, Prof. Bertrand Meyer, for giving me the opportunity of dedicating my master thesis to the topic of constraint-based <b>layout</b> <b>managers</b> and for letting me work at Eiffel Software in Santa Barbara, California. I would like to thank my supervisor-Durica Nikolic ́ for his valuable feedback and continuous guidance during the whole duration of this thesis. I would als...|$|R
50|$|Lightweight User Interface Toolkit (LWUIT) is a Widget toolkit {{developed}} by Sun Microsystems to enable easier Java ME user interface development for existing devices, including not only traditional Java ME environments like mobile phones, but also TVs and set top boxes. LWUIT {{is inspired by}} Swing and supports many of its features including pluggable look and feel, <b>layout</b> <b>managers,</b> etc.|$|R
40|$|Abstract. <b>Layout</b> <b>managers</b> {{are used}} to control the {{placement}} of widgets in graphical user interfaces (GUIs). Constraint-based <b>layout</b> <b>managers</b> are more powerful than other ones. However, they are also more complex and their layouts are prone to problems that usually require direct editing of constraints. Today, designers commonly use GUI builders to specify GUIs. The complexities of traditional approaches to constraint-based layouts pose challenges for GUI builders. We evaluate a novel GUI builder, the Auckland Layout Editor (ALE), which addresses these challenges by enabling GUI designers to specify constraintbased layouts via direct manipulation using simple, mouse-based operations. These operations hide {{the complexity of the}} constraint-based layout model, while giving designers access to its benefits. In a user evaluation we compared ALE with two other mainstream layout builders, a grid-based and a constraint-based one. The time taken to create realistic sample layouts with our builder was significantly shorter, and most participants preferred ALE’s approach. The evaluation demonstrates that good usability for authoring constraint-based layouts is possible...|$|R
5000|$|Some Widget toolkits or User {{interface}} markup languages {{have the}} ability to lay out widgets automatically in a container (see for example the box model in XUL, or the layouts in Java Swing). Widgets position and size in their container must always be defined exactly in an ARINC 661 definition. However, the supplement 3 of the standard has added a limited sort of [...] "relative" [...] layout capability between widgets (see <b>Layout</b> <b>manager).</b>|$|E
5000|$|Apple {{extended}} TrueType {{with the}} launch of TrueType GX in 1994, with additional tables in the sfnt which formed part of QuickDraw GX. This offered powerful extensions in two main areas. First was font axes (morphing), for example allowing fonts to be smoothly adjusted from light to bold or from narrow to extended — competition for Adobe's [...] "multiple master" [...] technology. Second was Line <b>Layout</b> <b>Manager,</b> where particular sequences of characters can be coded to flip to different designs in certain circumstances, useful for example to offer ligatures for [...] "fi", [...] "ffi", [...] "ct", etc. while maintaining the backing store of characters necessary for spell-checkers and text searching. However, the lack of user-friendly tools for making TrueType GX fonts meant {{there were no more}} than a handful of GX fonts.|$|E
5000|$|The [...] <b>layout</b> <b>manager</b> {{arranges}} {{components in}} a directional flow, much like lines of text in a paragraph. It arranges components horizontally until no more components {{fit on the}} same line, then it places them on another line. Other layout managers are GridLayout managers which arrange the components in grid form and BorderLayout managers which also arranges the component in five parts of the frame,thus: south,north, west,east and center.import javax.swing.JFrame;import javax.swing.JButton;import java.awt.FlowLayout;import java.awt.Container;public class Example { private JFrame frame; public Example (...) { frame = new JFrame("FlowLayout Demo"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setLayout(new FlowLayout (...) [...] ); frame.add((new JButton("Button 1"))); frame.add((new JButton("Button 2"))); frame.add((new JButton("Button 3"))); frame.add((new JButton("Long-Named Button 4"))); frame.add((new JButton("5"))); frame.pack (...) frame.setVisible(true); } public static void main(String args) { Example ex = new Example (...) }}This code shows 5 buttons alongside {{each other on the}} same line: ...|$|E
40|$|COMAIDE is a toolkit for user-system {{cooperation}} through joint multi-focal graph browsing. It supports cooperative force-directed layout management, concurrent with dialogue handling, for heterogeneous multi-layered 3 D interactive diagrams. The <b>layout</b> <b>manager's</b> intuitively 'natural' animations of multi-layered 3 D graph drawings support: 1. Cooperative tidying of user-manipulable 3 D layout; 2. Optional 'lucid' 3 D layout {{optimized for}} a favoured viewpoint; 3. Layout annealing for good initial 3 D diagram topologies...|$|R
5000|$|<b>Layout</b> <b>managers</b> are {{software}} components used in widget toolkits {{which have the}} ability to lay out graphical control elements by their relative positions without using distance units. It is often more natural to define component layouts in this manner than to define their position in pixels or common distance units, so a number of popular widget toolkits include this ability by default. Widget toolkits that provide this function can generally be classified into two groups: ...|$|R
40|$|<b>Layout</b> <b>managers</b> {{are used}} to control the {{placement}} of widgets in graphical user interfaces (GUIs). Constraint-based <b>layout</b> <b>managers</b> {{are among the most}} powerful. However, they are also more complex and their layouts are prone to problems such as over-constrained specifications and widget overlap. This poses challenges for GUI builder tools, which ideally should address these issues automatically. We present a new GUI builder – the Auckland Layout Edi-tor (ALE) – that addresses these challenges by enabling GUI designers to specify constraint-based layouts using simple, mouse-based operations. We give a detailed description of ALE’s edit operations, which do not require direct constraint editing. ALE guarantees that all edit operations lead to sound specifications, ensuring solvable and non-overlapping lay-outs. To achieve that, we present a new algorithm that auto-matically generates the constraints necessary to keep a layout non-overlapping. Furthermore, we discuss how our innova-tions can be combined with manual constraint editing in a sound way. Finally, to aid designers in creating layouts with good resize behavior, we propose a novel automatic layout preview. This displays the layout at its minimum and in an enlarged size, which allows visualizing potential resize issues directly. All these features permit GUI developers to focus more on the overall UI design...|$|R
5000|$|Saunders {{has over}} 10 years of {{experience}} researching claims of the paranormal. [...] As a teenager he was inspired by Channel 7's Great Mysteries of the World with Scott Lambert; he was surprised at just how easily people could fool themselves, even after being shown evidence {{that they may be}} wrong. He joined the committee of the Australian Skeptics in 2001 and has been President and Vice President of the organization. He was granted a Life Membership in the organization in recognition of his work on The Great Skeptic CD. He went on to create the Great Water Divining DVD and the [...] "card carrying skeptic card." [...] He founded Sydney Skeptics in the Pub, initiated [...] "The Skeptic Tank" [...] radio show on Net.FM with Stefan Sojka, produced The Australian Skeptics collection on [...] "Theories of Everything" [...] for TVS local Sydney TV, and created several of the Australians Skeptics convention DVDs. He was the acting artistic director and <b>layout</b> <b>manager</b> for The Skeptic Magazine from Australian Skeptics until Tim Mendham was appointed the new editor in June 2009.|$|E
5000|$|... import java.awt.FlowLayout;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.WindowConstants;import javax.swing.SwingUtilities; public class SwingExample {{implements}} Runnable { @Override public void run (...) { // Create {{the window}} JFrame f = new JFrame("Hello, !"); // Sets the behavior {{for when the}} window is closed f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); // Add a <b>layout</b> <b>manager</b> so that the button is not placed {{on top of the}} label f.setLayout(new FlowLayout (...) [...] ); // Add a label and a button f.add(new JLabel("Hello, world!")); f.add(new JButton("Press me!")); // Arrange the components inside the window f.pack (...) // By default, the window is not visible. Make it visible. f.setVisible(true); } [...] public static void main(String args) { SwingExample se = new SwingExample (...) // Schedules the application to be run at the correct time in the event queue. SwingUtilities.invokeLater(se); }}Notice how all instantiation and handling of Swing components are done by creating an instance of the class, which implements the Runnable interface. This is then run on the Event Dispatch Thread by use of the method [...] ), created in the main method (see Swing and thread safety). Although Swing code can be run without using this technique (for instance, by not implementing Runnable and moving all commands from the run method to the main method), it is considered to be good form, as Swing is not thread-safe, meaning that invoking resources from multiple threads can result in thread interference and memory consistency errors.|$|E
40|$|This thesis aims {{to analyse}} the Google Gadgets {{platform}} and an existing system of a page <b>layout</b> <b>manager</b> of the KiWi project. It provides {{a brief description}} of both platforms and focuses on a design and an implementation of the Google Gadgets support inside the page <b>layout</b> <b>manager.</b> Finally it compares the original with the modified solution in terms of page loading speed...|$|E
40|$|This thesis report {{describes}} {{the implementation of}} a chart library for use in client-sidebrowser visualizations. The library is completely written in the JavaScriptprogramming language and supports five chart types: bar or column charts, line charts,histograms, scatter plots, and function plots. Function plotting is performed usinginterval arithmetic resulting in accurate and guaranteed correct function plots withone or two variables. Other charts are drawn according to the guidelines set out inStephen Few's "Show Me the Numbers: Designing Tables and Graphs to Enlighten"book in order to create clear and consistent visualizations of data. The design of the library is based on the concept of components and containerswhich are laid out using <b>layout</b> <b>managers.</b> Three <b>layout</b> <b>managers</b> are included bydefault: border, grid, and a flexible grid. The charts are drawn using the HTML 5 Canvas element and maintain their own transformation stack in order to create crisplines and shapes. The design of the library also contains several extension mechanismwhich enables the creation of custom components and chart plug-ins as well ascustomization of the colours and fonts used in the charts. The library also extends the JavaScript language by adding support for severalfunctional programming constructs. Examples of these constructs are: functionalpattern matching, iterators such as map and reduce, mixins, getter and setterproperties, function currying, and others...|$|R
50|$|Despite being a pure JavaScript framework, qooxdoo {{is quite}} {{on par with}} GUI toolkits like Qt, Standard Widget Toolkit (SWT) and others with respect to {{implementing}} user interfaces. It offers a rich set of widgets that resemble elements of native desktop applications. Built-in support for keyboard navigation, focus and tab handling and drag & drop is provided. Dimensions can be specified as static, auto-sizing, stretching, percentage, weighted flex or min/max or even as combinations of these. All widgets are based on flexible <b>layout</b> <b>managers,</b> which are instrumental to many advanced layout abilities. Interface description is done programmatically in JavaScript for enhanced performance.|$|R
5000|$|The , or Abstract Window Toolkit, {{provides}} {{access to}} a basic set of GUI widgets based on the underlying native platform's widget set, {{the core of the}} GUI event subsystem, and the interface between the native windowing system and the Java application. It also provides several basic <b>layout</b> <b>managers,</b> a datatransfer package for use with the Clipboard and Drag and Drop, the interface to input devices such as mice and keyboards, as well as access to the system tray on supporting systems. This package, along with [...] contains the largest number of enums (7 in all) in JDK 6.|$|R
30|$|The <b>layout</b> <b>manager</b> is {{responsible}} for setting the app up according to its layout JSON file {{and is one of}} the first objects to be created during the app’s startup procedure. It parses the JSON to get the information about the basic app structure – i.e. colors of UI elements, icons and names of tabs, menus, menu items and background pictures. When a user selects a menu item, the <b>layout</b> <b>manager</b> creates the corresponding object in an “get instance by name style”. Consequently, the different event apps are always compiled with all modules “on board” – only at runtime it is decided which objects are actually needed and which ones aren’t.|$|E
40|$|Now we {{can extend}} our {{discussion}} of the design of classes and objects •  Chapter 7 focuses on: –  software development activities –  determining the classes and objects that are needed for a program –  the relationships that can exist among classes –  the static modifier –  writing interfaces –  the design of enumerated type classes –  method design and method overloading –  GUI design and <b>layout</b> <b>manager...</b>|$|E
40|$|This thesis {{deals with}} the design and {{implementation}} of the page <b>layout</b> <b>manager</b> for a web user interface composed of components. A part of solution is also a new XML format for configuring of the manager of page layout and composition and a new application interface for components. The created system has met the requirements of the European project KiWi and has passed the acceptance tests of its project team...|$|E
40|$|DJ (Declarative Java) is an {{extension}} of Java that supports constraint programming. With DJ, users do not need to learn the complicated class hierarchy of the AWT package or Java's <b>layout</b> <b>managers.</b> To construct a GUI, users only need to specify the components that compose the GUI and the relationship among the components by using constraints. As a constraint language, DJ can be used not only to solve Constraint Satisfaction Problems (CSPs) but also to specify how solutions are displayed graphically. DJ is a compiling language that uses Java as the object language. Because of this, solutions of CSPs can be disseminated on the Internet easily...|$|R
40|$|BuildByWire is a direct-manipulation meta-editor for {{composing}} sophisticated visual notations {{and their}} editors from JavaBean components. It in turn generates JavaBeans, {{which can be}} plugged into other tools. BuildByWire {{has been used to}} generate editors for a variety of visual languages and notations. We describe new features that eliminate several previous limitations of BuildByWire and its generated editors. The designer of a notation now has more control over the tools that are provided in the generated editor. Composition of notational elements using <b>layout</b> <b>managers</b> has been improved. Connectors between notational elements have been made more general and flexible. Key words: user-interface, visual notation, metaeditor, JavaBeans 1. Introduction Visual notations are important in many domains, including software development, architectural design and business process reengineering. Many software applications require editors for visual notations that provide appropriate editing mecha [...] ...|$|R
40|$|COMAIDE is a toolkit for user-system {{cooperation}} through joint multi-focal graph browsing. It supports cooperative force-directed layout management, concurrent with dialogue handling, for heterogeneous multi-layered 3 D interactive diagrams. The <b>layout</b> <b>manager's</b> intuitively `natural' animations of multi-layered 3 D graph drawings support: 1. Cooperative tidying of user-manipulable 3 D layout; 2. Optional `lucid' 3 D layout {{optimized for}} a favoured viewpoint; 3. Layout annealing for good initial 3 D diagram topologies; 1 Introduction COMAIDE (Co-Operative Multilayer Application-Independent Diagram Environment) is a toolkit for cooperative Diagrammatic User Interfaces (DUIs) [15] to applications written in Prolog. It presents a simple artificial reality of 3 D multi-layer node-and-link diagrams supporting multi-focal graph browsing. The nodes of the diagram occupy {{a set of}} parallel layers, each node's centre being constrained to lie in the plane of a layer. COMAIDE diagrams are animated by [...] ...|$|R
