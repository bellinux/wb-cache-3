46|529|Public
2500|$|Note: The inverse tangent (tan1) can be {{computed}} using {{a common}} <b>library</b> <b>routine</b> atan2(b, a) which usually has a range from [...] to [...] radians; color specifications {{are given in}} 0 to 360 degrees, so some adjustment is needed. The inverse tangent is indeterminate if both a and b are zero (which also means that the corresponding C is zero); in that case, set the hue angle to zero. See [...]|$|E
5000|$|This program {{contains}} the class [...] The constructor (create routine) for the class, named , invokes the [...] system <b>library</b> <b>routine</b> {{to write a}} [...] message to the output.|$|E
50|$|Modern Unix {{implementations}} of {{the crypt}} <b>library</b> <b>routine</b> support {{a variety of}} different hash schemes. The particular hash algorithm used can be identified by a unique code prefix in the resulting hashtext, following a de facto standard called Modular Crypt Format.|$|E
25|$|Commercial interpreters {{delivered}} {{highly tuned}} linear algebra <b>library</b> <b>routines.</b>|$|R
5000|$|Fast scalar, vector, and array math {{transcendental}} <b>library</b> <b>routines</b> ...|$|R
5000|$|Command Language Interface (CLI) - <b>library</b> <b>routines</b> for parsing VMS {{command line}} {{parameters}} ...|$|R
5000|$|Historically CGI scripts {{were often}} written using the C language. RFC 3875 [...] "The Common Gateway Interface (CGI)" [...] {{partially}} defines CGI using C, as {{in saying that}} environment variables [...] "are accessed by the C <b>library</b> <b>routine</b> getenv (...) or variable environ".|$|E
50|$|Studio {{maintenance}} tasks include {{updating the}} station's digital record library {{and taking care}} of any problems with the broadcasting facilities. Volunteers can use specialist programmes installed on the station's computers to import music from CDs or to download it from the internet and then add it to the existing record <b>library.</b> <b>Routine</b> maintenance usually involves replacing blown bulbs, debugging networking, configuring wiring etc.|$|E
50|$|Systematic use of {{this method}} allows {{arbitrary}} computations on given quantities {{to be replaced by}} equivalent computations on their affine forms, while preserving first-order correlations between the input and output and guaranteeing the complete enclosure of the joint range. One simply replaces each arithmetic operation or elementary function call in the formula by a call to the corresponding AA <b>library</b> <b>routine.</b>|$|E
40|$|We {{demonstrate}} how a new data structure for sparse distributed polynomials in the Maple 17 kernel significantly accelerates several key Maple <b>library</b> <b>routines.</b> The POLY data structure {{and its associated}} kernel operations are programmed for compactness, scalability, and low overhead. This allows polynomials to have {{tens of millions of}} terms, increases parallel speedup, and improves the performance of Maple <b>library</b> <b>routines.</b> ...|$|R
50|$|User {{programs}} {{written in}} C, C++, or Fortran can access PVM through provided <b>library</b> <b>routines.</b>|$|R
5000|$|Additional <b>library</b> <b>routines</b> - {{including}} environmental inquiry, parallel prefix/suffix (e.g., 'scan'), data scattering, and sorting operations ...|$|R
5000|$|Note: The inverse tangent (tan&minus;1) can be {{computed}} using {{a common}} <b>library</b> <b>routine</b> [...] which usually has a range from &minus;&pi; to &pi; radians; color specifications {{are given in}} 0 to 360 degrees, so some adjustment is needed. The inverse tangent is indeterminate if both a&prime; and b are zero (which also means that the corresponding C&prime; is zero); in that case, set the hue angle to zero. See [...]|$|E
5000|$|In some cases, {{this message}} will occur even when no ioctl has been {{issued by the}} program. This {{is due to the}} way the isatty (...) <b>library</b> <b>routine</b> works. The error code errno is only set when a system call fails. One of the first system calls made by the C {{standard}} I/O library is in an isatty (...) call used to determine if the program is being run interactively by a human (in which case isatty (...) will succeed and the library will write its output a line at a time so the user sees a regular flow of text) or as part of a pipeline (in which case it writes a block at a time for efficiency). If a <b>library</b> <b>routine</b> fails for some reason unrelated to a system call (for example, because a user name wasn't found in the password file) and a naïve programmer blindly calls the normal error reporting routine perror (...) on every failure, the leftover ENOTTY will result in an utterly inappropriate [...] "Not a typewriter" [...] (or [...] "Not a teletype", or [...] "Inappropriate ioctl for device") being delivered to the user.|$|E
50|$|Thomas Earnest Gay {{was born}} on 22 January 1884, the eldest child of Thomas Patrick Gay and Catherine Coleman. He lived much of his teenage years in a two-room {{tenement}} at Little Strand Street, Dublin with his parents and five siblings. Prior to that, the family lived in Eustace Street. He was educated at James Street, Christian Brothers School where he attained all Grades, except Senior, with Honours. During his library service {{he was awarded the}} Classification and <b>Library</b> <b>Routine</b> Examinations of the Library Association of England.|$|E
5000|$|Complex {{functionality}} such as I/O, string manipulation, {{and mathematical}} functions are consistently delegated to <b>library</b> <b>routines.</b>|$|R
50|$|Null-termination must be {{manually}} {{maintained for}} string variables stored in arrays (this is often partly handled by <b>library</b> <b>routines).</b>|$|R
50|$|Later {{versions}} {{have included}} upgraded and enhanced runtime <b>library</b> <b>routines</b> {{provided by the}} community group FastCode, established in 2003.|$|R
50|$|Some file systems accept {{data for}} storage as {{a stream of}} bytes which are {{collected}} and stored in a manner efficient for the media. When a program retrieves the data, it specifies {{the size of a}} memory buffer and the file system transfers data from the media to the buffer. A runtime <b>library</b> <b>routine</b> may sometimes allow the user program to define a record based on a library call specifying a length. When the user program reads the data, the library retrieves data via the file system and returns a record.|$|E
5000|$|Library {{routines}} {{were addressed}} through index register XR3. (Fortran subprograms would use index register XR1 for the addresses of parameters {{and the return}} address, but register XR2 was unused.) XR3 would be pointed to a sequence of three-word transfer vectors such that the first entry would be -128 words from XR3's value. The programmer would call the <b>library</b> <b>routine</b> using the [...] pseudo-operation, which assembled not a direct [...] to the routine but a one-word indexed branch instruction (...) whose displacement (-128, -125, and so on) identified {{the start of the}} routine's transfer vector.|$|E
50|$|In Eiffel, the tilde is {{used for}} object comparison. If a and b denote objects, the boolean {{expression}} a ~ b has value true {{if and only if}} these objects are equal, as defined by the applicable version of the <b>library</b> <b>routine</b> is_equal, which by default denotes field-by-field object equality but can be redefined in any class to support a specific notion of equality. If a and b are references, the object equality expression a ~ b is to be contrasted with a = b which denotes reference equality. Unlike the call a.is_equal (b), the expression a ~ b is type-safe even in the presence of covariance.|$|E
40|$|We {{demonstrate}} how a new data structure for sparse distributed polynomials in the Maple kernel significantly accelerates a large subset of Maple <b>library</b> <b>routines.</b> The POLY data structure {{and its associated}} kernel operations (degree, coeff, subs, has, diff, eval, [...] .) are programmed for high scalability, allowing polynomials to have {{hundreds of millions of}} terms, and very low overhead, increasing parallel speedup in existing routines and improving the performance of high level Maple <b>library</b> <b>routines.</b> ...|$|R
50|$|Its <b>library</b> <b>routines</b> mirror {{those of}} ISO C, though the current {{implementation}} {{is not easily}} extensible with functions written in C.|$|R
40|$|In {{general the}} users of {{personal}} computers {{are unable to}} call <b>library</b> <b>routines</b> - as available on mainframes - from their application programs. Therefore {{it is necessary to}} integrate the personal computers into a heterogeneous network with mainframes and to make communication software available to the users of personal computers. This software has to provide a transparent interface, thus allowing conveniently the remote execution of <b>library</b> <b>routines.</b> The subject of this paper is how to design such software for a distributed syste...|$|R
5000|$|The printer routine, however, {{works with}} text in 8-bit EBCDIC with two {{characters}} per word, requiring a 40-word buffer. The program uses <b>library</b> <b>routine</b> ZIPCO {{to perform the}} conversion. The [...] is not executed because HLEBC is not a subroutine but an IBM-supplied Hollerith-to-EBCDIC conversion table. The CALL statement provides {{the address of the}} table to ZIPCO and ensures that the linking loader includes the table in the program, thus it is the fifth parameter to ZIPCO. After the conversion, the program sends the converted output, now in buffer PBUFF, to the printer through driver PRNT1. Again, the program loops until the printer driver reports completion, then the program reads the next card.|$|E
5000|$|Initially, these subroutines used {{hard-coded}} loops {{for their}} low-level operations. For example, if a subroutine need {{to perform a}} matrix multiplication, then the subroutine would have three nested loops. Linear algebra programs have many common low-level operations (the so-called [...] "kernel" [...] operations, not related to operating systems). Between 1973 and 1977, several of these kernel operations were identified. These kernel operations became defined subroutines that math libraries could call. The kernel calls had advantages over hard-coded loops: the <b>library</b> <b>routine</b> would be more readable, there were fewer chances for bugs, and the kernel implementation could be optimized for speed. A specification for these kernel operations using scalars and vectors, the level-1 Basic Linear Algebra Subroutines (BLAS), was published in 1979. BLAS was used to implement the linear algebra subroutine library LINPACK.|$|E
50|$|If {{this was}} the first {{invocation}} of the library the library would run its main program (outer block in an ALGOL program) to initialize its global environment. Once initialization was complete, it would execute a freeze, at which point all exported entry points would be made available to clients. At this point, the library's stack was said to be frozen since nothing more would be run on this stack until the library became unfrozen, in which case clean-up and termination code would be run. When a client calls a routine in a library, that routine runs on top of the client stack, storing its locals and temporary variables there. This allows many clients to be running the same routine at the same time, being synchronized by the <b>library</b> <b>routine,</b> which accesses the data in the global environment of the library stack.|$|E
40|$|Acquiring {{knowledge}} about <b>library</b> <b>routines</b> {{is necessary for}} a programmer to effectively use most programming languages. Support for this learning activity is rare while the learning effort required is huge. This paper proposes a conceptual framework of a new documentation system that supports programmers to incrementally learn the use of <b>library</b> <b>routines.</b> The system draws on active information delivery where information relevant to programmers' work is volunteered by the system, accumulative information space where the system mediates peer-to-peer learning, and adaptable information space where information is displayed according to the increasing skill level of programmers. KEYWORDS Documentation system, software reuse library, learning on demand 1. INTRODUCTION As one proverb in Bell Labs going as "library design is language design" [1] indicates, learning how to use <b>library</b> <b>routines</b> is a necessity for programmers to fully master most programming language {{in the sense of}} using it [...] ...|$|R
50|$|Most {{computer}} programming languages include functions or <b>library</b> <b>routines</b> that provide random number generators. They are often {{designed to provide}} a random byte or word, or a floating point number uniformly distributed between 0 and 1.|$|R
40|$|Parallel eigensolver {{operations}} {{are at the}} computational core of many large-scale scientific and engineering application codes. This project analyses parallel performance of established and newly developed parallel dense symmetric eigensolver numerical <b>library</b> <b>routines</b> on PRACE Tier- 0 systems using real datasets from large-scale application codes. This whitepaper builds upon the research report ‘Dense Linear Algebra Performance Analysis on the Fujitsu BX 900 OPL Machine†’ (from the same author) {{which can be found}} at: [URL] / 2011 _Dense_Linear_Algebra_Performance_Analysis_on_the_Fujitsu_BX 900 _OPL_Machine. pdf. This version of the report is updated with results from ScaLAPACK and with the recently released ELPA <b>library</b> <b>routines</b> on the PRACE Tier- 0 machines CURIE and JUGENE...|$|R
40|$|New {{technologies}} library provides {{several new}} materials, media and mode of storing and communicating the information. Library Automation reduces the drudgery of repeated manual efforts in <b>library</b> <b>routine.</b> By use of library automation collection, Storage, Administration, Processing, Preservation and communication etc...|$|E
40|$|Note: Before {{using this}} routine, please read the Users ’ Note for your {{implementation}} {{to check for}} implementation-dependent details. You are advised to enclose any calls to NAG Parallel Library routines between calls to Z 01 AAFP and Z 01 ABFP. 1 Description Warning: This routine is implementation specific. Unless your implementation of the NAG Parallel Library utilises MPI for message passing you must not reference this routine. Z 01 AEFP is called in more sophisticated applications where the user is not relying on the NAG Parallel Library mechanism to claim processes. If the user {{does not wish to}} make a direct call to Z 01 AAFP to create the Library Grid and wishes to use BLACS routines (e. g., BLACS GRIDINIT and BLACS GRIDMAP), then a call to Z 01 AEFP must be made prior to a call to the first NAG Parallel <b>Library</b> <b>routine.</b> This feature allows multigridding and is particularly useful when the user-generated context needs to be passed to the NAG Parallel Library routines. This routine need be called only once and if not called prior to the first to a <b>Library</b> <b>routine,</b> the <b>Library</b> <b>routine</b> exits with an error condition. 2 Specificatio...|$|E
40|$|Techniques are {{described}} for computing matrix inverses by algorithms {{that are highly}} suited to massively parallel computation. The techniques are based on an algorithm suggested by Strassen (1969). Variations of this scheme use matrix Newton iterations and other methods to improve the numerical stability {{while at the same}} time preserving a very high level of parallelism. One-processor Cray- 2 implementations of these schemes range from one that is up to 55 percent faster than a conventional <b>library</b> <b>routine</b> to one that is slower than a <b>library</b> <b>routine</b> but achieves excellent numerical stability. The problem of computing the solution to a single set of linear equations is discussed, and it is shown that this problem can also be solved efficiently using these techniques...|$|E
40|$|New NAG Fortran <b>Library</b> <b>routines</b> are {{described}} for {{the solution of}} systems of nonlinear, first-order, time-dependent partial differential equations in one space dimension, with scope for coupled ordinary differential or algebraic equations. The method-of-lines is used with spatial discretization by either the central-difference Keller box scheme or an upwind scheme for hyperbolic systems of conservation laws. The new routines have the same structure as existing <b>library</b> <b>routines</b> for the solution of second-order partial differential equations, {{and much of the}} existing library software is reused. Results are presented for several computational examples to show that the software provides physically realistic numerical solutions to a challenging class of problems...|$|R
5000|$|Because garbage-collection is only done on {{built-in}} types, reference counting can be efficiently {{integrated into}} the <b>library</b> <b>routines</b> used to manipulate each datatype, keeping the overhead needed for updating of reference counts low. Moreover, {{a lot of the}} runtime library is in hand-optimized assembler.|$|R
5000|$|With {{the advent}} of {{numerical}} programming, sophisticated subroutine libraries became useful. These libraries would contain subroutines for common high-level mathematical operations such as root finding, matrix inversion, and solving systems of equations. The language of choice was FORTRAN. The most prominent numerical programming library was IBM's Scientific Subroutine Package (SSP). [...] These subroutine libraries allowed programmers to concentrate on their specific problems and avoid re-implementing well-known algorithms. The <b>library</b> <b>routines</b> would also be better than average implementations; matrix algorithms, for example, might use full pivoting to get better numerical accuracy. The <b>library</b> <b>routines</b> would also have more efficient routines. For example, a library may include a program to solve a matrix that is upper triangular. The libraries would include single-precision and double-precision versions of some algorithms.|$|R
