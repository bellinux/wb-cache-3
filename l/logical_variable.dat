32|240|Public
5000|$|Above, the <b>logical</b> <b>variable</b> y {{represents}} the initial value of variable x.Hence, ...|$|E
5000|$|... y is a fresh <b>logical</b> <b>variable,</b> {{bound in}} Q, that {{represents}} the new value of x non-deterministically chosen by the statement, ...|$|E
50|$|The {{temporal}} {{relation between}} a <b>logical</b> <b>variable</b> x which {{is associated with}} the level of an element and a logical function X which is associated with its evolution can be explained as follows.|$|E
5000|$|... #Subtitle level 3: Koopman and Sportiche's (1989) <b>logical</b> <b>variables</b> ...|$|R
5000|$|Janus—features {{distinct}} askers and tellers to <b>logical</b> <b>variables,</b> bag channels; {{is purely}} declarative ...|$|R
30|$|Denoting 1 ∼δ _ 2 ^ 1 and 0 ∼δ _ 2 ^ 2, we have Δ∼D, where ‘∼’ denotes two {{different}} forms of the same object. In most places of this paper, we use δ _ 2 ^ 1 and δ _ 2 ^ 2 to express <b>logical</b> <b>variables</b> and call them the vector form of <b>logical</b> <b>variables.</b> The following lemma is fundamental for the matrix expression of logical functions.|$|R
50|$|The aim of {{aggregate}} {{behavior is}} to consolidate individual's economical behavior into a simple <b>logical</b> <b>variable,</b> so as allow an economical analyst to analyse the data. Furthermore, the consumption function arguments allow {{the assumption that}} all individual consumers are similar in their economical behavior, thus allowing the economical analyst to create a macroeconomic model.|$|E
5000|$|One of {{the major}} {{difference}} between the two classes of pronouns in Abe is that o-pronouns cannot be coindexed with a c-commanding antecedent that is a n-pronoun, regardless of the degree of embedding. This can be accounted for if n-pronoun is not a referential element, but instead is a <b>logical</b> <b>variable</b> Ā-bounded by an operator at Comp [...] Another generalization found is that n-anaphors cannot have an o-pronoun antecedent, and vice versa [...] This can be captured by distinguishing the two pronouns by some feature like +/-n, and binding would require the anaphor and the antecedent to be matching in feature (a parallel analogy would be the feature gender).|$|E
5000|$|Polychotomous key {{refers to}} the number of {{alternatives}} which a decision point may have in a non-temporal hierarchy of independent variables. The number of alternatives are equivalent to the root or nth root of a mathematical or <b>logical</b> <b>variable.</b> Decision points or independent variables with two states have a binary root that is referred to as a dichotomous key whereas, the term polychotomous key refers to roots which are greater than one or unitary and usually greater than two or binary. Polychotomous keys are used in troubleshooting to build troubleshooting charts and in classification/identification schemes with characteristics that have more than one attribute and the order of characteristics is not inherently based on the progression of time.|$|E
40|$|This {{document}} {{describes the}} TasteCurry system, a prototypical {{implementation of the}} multiparadigm Curry. Curry is a universal programming language aiming at the amalgamation {{of the most important}} declarative programming paradigms, namely functional programming and logic programming. Curry combines in a seamless way features from functional programming (nested expressions, lazy evaluation, higher-order functions), logic programming (<b>logical</b> <b>variables,</b> partial data structures, built-in search), and concurrent programming (concurrent evaluation of constraints with synchronization on <b>logical</b> <b>variables)</b> ...|$|R
5000|$|A {{sentence}} is either {{true or false}} under an interpretation which assigns values to the <b>logical</b> <b>variables.</b> We might for example make the following assignments: ...|$|R
40|$|AbstractA new {{programming}} language called MLOG is introduced. MLOG {{is a conservative}} extensions of ML with <b>logical</b> <b>variables.</b> To validate our concepts, a complier named CAML Light FLUO was implemented. Numerous examples are presented to illustrate the possibilities of MLOG. The pattern matching of ML is kept for λ-calculus bindings and an unification primitive is introduced for the <b>logical</b> <b>variables</b> bindings. A suspension mechanism allows cohabitation of pattern-matching and <b>logical</b> <b>variables.</b> Although the evaluation strategy for the application is fixed, the order {{for the evaluation of}} the parts of pairs and application remains free. MLOG programs can be evaluated in parallel with the same result obtained irrespective of the particular order of evaluation. This is guaranteed by the Church-Rosser property observed by the evaluation rules. As a corollary, a strict λ-calculus with explicit substitution on named variables is shown to be confluent. A completely formal operational semantics of MLOG is given in this paper...|$|R
5000|$|Janus, the {{programming}} language, {{is named after}} Janus, the two-faced Roman god, because every <b>logical</b> <b>variable</b> in Janus has as its two [...] "faces", two aspects that can be passed as arguments. These are called the asker and the teller. These represent, respectively, the right to ask {{the value of the}} variable (or some characteristic of the value) and the right to tell the value (or to tell some constraint on what the value can be). The asker and teller aspects can be passed around as arguments independently of each other. Neither right implies the other right. The syntax of the language prevents copying a teller or exercising it more than once. Logical contradiction is statically prevented, according to Kahn and Saraswat.|$|E
40|$|There were {{implemented}} samples of asymmetric Hopfield neural networks which have finite time of transition from one state to another. It was shown that in such systems, various oscillation modes could occur. It {{was revealed that}} the oscillation of the output signal of certain neuron could be treated as extra <b>logical</b> <b>variable,</b> which describes {{the state of the}} neuron. Asymmetric Hopfield neural networks are described in terms of ternary logic. Such logic may be employed in image recognition procedure...|$|E
40|$|We {{present an}} {{implementation}} of miniKanren, an embedding of logic programming in R 5 RS Scheme that comprises three logic operators. We describe these operators, {{and use them}} to define plus o, a relation that adds two numbers. We then define plus ∗o, which adds zero or more numbers; plus ∗o takes exactly two arguments, the first of which is a list of numbers to be added or a <b>logical</b> <b>variable</b> representing such a list. We call such a relation pseudo-variadic. Combining Scheme’s var-args facility with pseudo-variadic helper relations leads to variadic relations, which take a variable number of arguments. We focus on pseudo-variadic relations, which we demonstrate are more flexible than their variadic equivalents. We show how to define plus ∗o in terms of plus o using foldr o and foldl o, higher-order relational abstractions derived from Haskell’s foldr and foldl functions. These higherorder abstractions demonstrate the benefit of embedding relational operators in a functional language. We define many other pseudo-variadic relations using foldr o and foldl o, consider the limitations of these abstractions, and explore their effect on the divergence behavior of the relations they define. We also consider double-pseudo-variadic relations, a generalization of pseudo-variadic relations that take as their first argument a list of lists or a <b>logical</b> <b>variable</b> representing a list of lists...|$|E
5000|$|Logic {{programming}} languages such as Prolog don't {{even have}} return values. Instead, unbound <b>logical</b> <b>variables</b> {{are used as}} output parameters, to be unified with values constructed in a predicate call.|$|R
40|$|The article {{analyses}} {{the use of}} <b>logical</b> <b>variables</b> {{in economic}} models solved by linear programming. Focus {{is given to the}} presentation of the way logical constraints are obtained and of the definition rules based on predicate logic. Emphasis is also put on the possibility to use <b>logical</b> <b>variables</b> in constructing a linear objective function on intervals. Such functions are encountered when costs or unitary receipts are different on disjunct intervals of production volumes achieved or sold. Other uses of Boolean variables are connected to constraint systems with conditions and the case of a variable which takes values from a finite set of integers...|$|R
40|$|This paper {{describes}} {{a proposal to}} incorporate finite domain constraints in a functional logic system. The proposal integrates functions, higher-order patterns, partial applications, non-determinism, <b>logical</b> <b>variables,</b> currying, types, lazyness, domain variables, constraints and finite domain propagators...|$|R
40|$|In this paper, {{we propose}} a {{completion}} procedure (called MKBpo) for term rewriting systems. Based {{on the existing}} procedure MKB which works with multiple reduction orderings and the ATMS nodes, the MKBpo improves its performance by restricting the class of reduction orderings to precedence-based path orderings, representing them by logical functions in which a <b>logical</b> <b>variable</b> xfg represents the precedence f ≻ g. By using BDD (binary decision diagrams) as a representation of logical functions, the procedure can be implemented efficiently. This {{makes it possible to}} save the number of quasi-parallel processes effectively and suppress the rapid increase in the amount of computation time asymptotically...|$|E
40|$|AbstractPEPSys (Parallel ECRC PROLOG System) is a {{research}} project started in 1984 in the Computer Architecture Group of the European Computer-Industry Research Centre (ECRC). Its general goals are to study and evaluate new and practicable {{solutions to the problems}} of parallel logic programming. The PEPSys Abstract Machine described in this paper was designed to allow an efficient implementation of the PEPSys computational model. Based on the WAM, it incorporates a number of novel features to support the management of the <b>logical</b> <b>variable</b> and the control of the search space of the PEPSys computational model. Both a parallel implementation on a multiprocessor and a simulation system of scalable multiprocessor architectures implement the PEPSys Abstract Machine and yield effective speedups in parallel computations...|$|E
40|$|In {{this paper}} we study biased random K-SAT {{problems}} {{in which each}} <b>logical</b> <b>variable</b> is negated with probability p. This generalization provides us a crossover from easy to hard problems and would help us in {{a better understanding of}} the typical complexity of random K-SAT problems. The exact solution of 1 -SAT case is given. The critical point of K-SAT problems and results of replica method are derived in the replica symmetry framework. It is found that in this approximation α_c ∝ p^-(K- 1) for p→ 0. Solving numerically the survey propagation equations for K= 3 we find that for p<p^* ∼ 0. 17 there is no replica symmetry breaking and still the SAT-UNSAT transition is discontinuous. Comment: 17 pages, 8 figure...|$|E
40|$|Logic {{elements}} are provided that permit reductions in layout size and avoidance of hazards. Such logic elements may {{be included in}} libraries of logic cells. A logical function to be implemented by the logic element is decomposed about <b>logical</b> <b>variables</b> to identify factors corresponding to combinations of the <b>logical</b> <b>variables</b> and their complements. A pass transistor network is provided for implementing the pass network function in accordance with this decomposition. The pass transistor network includes ordered arrangements of pass transistors that correspond to the combinations of variables and complements resulting from the logical decomposition. The logic elements may act as selection circuits and be integrated with memory and buffer elements...|$|R
5000|$|... {{proposes that}} logophoric pronouns are pronouns treated as <b>logical</b> <b>variables</b> and yields logophoric effects in certain {{syntactic}} contexts. This analysis {{is based on}} Abe which, like many West African languages, has verbal complementizers that introduce certain types of clauses.|$|R
40|$|A {{lightweight}} {{approach to}} debugging functional logic programs by observations is presented, implemented for the language Curry. The Curry Object Observation System (COOSy) comprises a portable library plus a viewing tool. A programmer can observe data structures and functions by annotating expressions in his program. The possibly partial values of observed expressions that are computed during program execution are recorded in a trace file, including information on non-deterministic choices and <b>logical</b> <b>variables.</b> A separate viewing tool displays the trace content. COOSy covers {{all aspects of}} modern functional logic multiparadigm languages such as lazy evaluation, higher order functions, non-deterministic search, <b>logical</b> <b>variables,</b> concurrency and constraints. Both use and implementation of COOSy are described...|$|R
40|$|Various {{encodings}} {{have been}} proposed to convert Constraint Satisfaction Problems (CSP) into Boolean Satisfiability problems (SAT). Some of them use a <b>logical</b> <b>variable</b> for each element in each domain: among these very successful are the direct and the support encodings. Other methods, such as the log-encoding, use a logarithmic number of logical variables to encode domains. However, they lack the propagation power of the direct and support encodings, so many SAT solvers perform poorly on log-encoded CSPs. In this paper, we propose a new encoding, called log-support, that combines the log and support encodings. It has a logarithmic number of variables, and uses support clauses to improve propagation. We also extend the encoding using a Gray code. We provide experimental results on Job-Shop scheduling and randomly-generated problems...|$|E
40|$|Techniques {{to reduce}} the memory {{footprint}} of an application include representation sharing between multiple copies of some data. Representation sharing has been implemented through hash-consing in functional languages. Representation sharing for Prolog was not given that much attention in the past. Here, representation sharing is defined for Prolog implementations in a structure copying environment (basically the WAM), and the specific issues arising from the <b>logical</b> <b>variable</b> and backtracking are analyzed. A high-level algorithm is described, and its properties are derived. An implementation in hProlog is evaluated. The impact of representation sharing depends {{very much on the}} application. The cost seems acceptable and the memory gains can be large. Issues related to the representation sharing policy are discussed. nrpages: 31 status: publishe...|$|E
30|$|For {{modelling}} a State we {{can start}} by including the aspects that are of interest for the situation under study. Aspects could be modelled as <b>logical</b> <b>variable</b> that are true or false in some state, because they are either considered or not considered (i.e., observable/salient or not). The expressiveness of the logic to be used would be dependent on what aspects we are interested in; but {{we can start}} by working with predicate logic. Depending on the system being developed, we encourage to choose the most suited logic, e.g.: the SAL languages and tools which have been nicely {{used to describe the}} cognitive architecture of [10], Sec. 2]; or one can use higher-order dynamic logic [59], Chap. 3] and the tools around it like the KeY system [60].|$|E
30|$|The {{principle}} of fuzzy approaches {{in the sense}} that the variables are not treated as <b>logical</b> <b>variables</b> but as linguistic variables close to human language. Furthermore, these linguistic variables are processed using rules that refer to some knowledge of the system behavior [18].|$|R
5000|$|For example, substituting propositions {{in natural}} {{language}} for <b>logical</b> <b>variables,</b> the inverse of the conditional proposition, [...] "If it's raining, then Sam will meet Jack at the movies" [...] is [...] "If it's not raining, then Sam will not meet Jack at the movies." ...|$|R
40|$|The idea of {{introducing}} <b>logical</b> <b>variables</b> into functional programming languages {{has been proposed}} for some years, and many concrete languages with this feature have been developed. Recently the semantic features of the languages in this paradigm have been uniformly modelled using the constraint computation formalism [RJK 92]. However, the operational behaviour of these languages has not been studied systematically. In this paper, we propose a linear logic formalization of the the computational behaviour of functional programming languages with <b>logical</b> <b>variables.</b> It is shown that, with the resource-consciousness of linear logic, the computation of the paradigm can be uniformly modelled as deduction in the logic. Therefore, the model provides the logical meaning for the computation {{as well as a}} general abstract machine for the implementation of these languages...|$|R
40|$|Abstract. Various {{encodings}} {{have been}} proposed to convert Constraint Satisfaction Problems (CSP) into Boolean Satisfiability problems (SAT). Some of them use a <b>logical</b> <b>variable</b> for each element in each domain: among these very successful are the direct and the support encodings. Other methods, such as the log-encoding, use a logarithmic number of logical variables to encode domains. However, they lack the propagation power of the direct and support encodings, so many SAT solvers perform poorly on log-encoded CSPs. In this paper, we propose a new encoding, called log-support, that combines the log and support encodings. It has a logarithmic number of variables, and uses support clauses to improve propagation. We also extend the encoding using a Gray code. We provide experimental results on Job-Shop scheduling and randomly-generated problems. ...|$|E
40|$|International audienceThis paper {{presents}} {{an extension of}} a decidable fragment of Separation Logic for singly-linked lists, defined by Berdine, Calcagno and O'Hearn [8]. Our main extension consists in introducing atomic formulae of the form ls k (x, y) describing a list segment of length k, stretching from x to y, where k is a <b>logical</b> <b>variable</b> interpreted over positive natural numbers, that may occur further inside Presburger constraints. We study the decidability of the full first-order logic combining unrestricted quan-tification of arithmetic and location variables. Although the full logic {{is found to be}} undecidable, validity of entailments between formulae with the quantifier prefix in the language ∃ * {∃ N, ∀ N } * is decidable. We provide here a model theoretic method, based on a parametric notion of shape graphs. We have implemented our decision technique, providing a fully automated framework for the verification of quantitative properties expressed as pre-and post-conditions on programs working on lists and integer counters...|$|E
40|$|Submitted in partial {{fulfillment}} of the requirements for the Degree of Actuarial Science at Strathmore UniversityBased on Generalized Linear Models, {{we are able to}} establish the key parameters to be used for determining the future claim frequency through the adoption of appropriate <b>logical</b> <b>variable</b> selection method given various variable interactions in the model. With ample calibration, we prove the robustness of the model by analyzing its predictability power through evaluation of the dispersion parameters. This facilitates the efficiency in claim reserving given the scarcity of resources and time to run the saturated models. We adopt the statistical based variable selection method for the model as opposed to experience selection. The general insurance industry could embrace the study to economically maintain and improve the certainty in their claim reserving. Relying on the sample analysis, general insurers and particularly motor vehicle insurers could estimate their future claim frequency at about 85 % confidence interval basing on the model of the car and the age bracket of the policyholder...|$|E
40|$|As exact {{inference}} for first-order probabilistic graphical models at the propositional level can be formidably expensive, {{there is}} an ongoing effort to design efficient lifted inference algorithms for such models. This paper discusses directed first-order models that require an aggregation operator when a parent random variable is parameterized by <b>logical</b> <b>variables</b> that are not present in a child random variable. We introduce a new data structure, aggregation parfactors, to describe aggregation in directed first-order models. We show how to extend Milch et al. ’s C-FOVE algorithm to perform lifted inference {{in the presence of}} aggregation parfactors. We also show that there are cases where the polynomial time complexity (in the domain size of <b>logical</b> <b>variables)</b> of the C-FOVE algorithm can be reduced to logarithmic time complexity using aggregation parfactors. ...|$|R
40|$|In {{this short}} {{position}} paper, we consider MaxWalkSAT, a local search algorithm for MAP inference in probabilistic graphical models, and lift {{it to the}} first-order level, yielding a powerful algorithm for MAP inference in Markov logic networks (MLNs). Lifted MaxWalkSAT {{is based on the}} observation that if the MLN is monadic, namely if each predicate is unary then MaxWalkSAT is completely liftable in the sense that no grounding is required at inference time. We propose to utilize this observation in a straight-forward manner: convert the MLN to an equivalent monadic MLN by grounding a subset of its <b>logical</b> <b>variables</b> and then apply lifted MaxWalk-SAT on it. It turns out however that the problem of finding the smallest subset of <b>logical</b> <b>variables</b> which when grounded will yield a monadic MLN is NP-hard in general and therefore we propose an approximation algorithm for solving it...|$|R
2500|$|A {{fuzzy control}} {{system is a}} control system based on fuzzy logic—a {{mathematical}} system that analyzes analog input values in terms of [...] <b>logical</b> <b>variables</b> that take on continuous values between 0 and 1, in contrast to classical or digital logic, which operates on discrete values of either 1 or 0 (true or false, respectively).|$|R
