24|620|Public
25|$|A commit object links tree objects {{together}} into a history. It contains {{the name of a}} tree object (of the top-level source directory), a time stamp, a <b>log</b> <b>message,</b> and the names of zero or more parent commit objects.|$|E
2500|$|Many wiki implementations, such as MediaWiki, allow {{users to}} supply an edit summary when they edit a page. This {{is a short}} piece of text {{summarizing}} the changes they have made (e.g., [...] "Corrected grammar," [...] or [...] "Fixed formatting in table."). It is not inserted into the article's main text, but is stored along with that revision of the page, allowing users to explain {{what has been done}} and why, similar to a <b>log</b> <b>message</b> when making changes in a revision-control system. This enables other users to see which changes have been made by whom and why, often in a list of summaries, dates and other short, relevant content, a list which is called a [...] "log" [...] or [...] "history." ...|$|E
5000|$|... <b>log</b> <b>message</b> traffic {{during the}} {{simulation}} run, for post-processing analysis (including test data verification, response time calculation and screen image comparison across repeated simulations {{of the same}} scripts); ...|$|E
5000|$|... allows {{collection}} of <b>log</b> <b>messages</b> generated by iptables; based on ...|$|R
5000|$|A web-interface {{for viewing}} current devices status, alerts, <b>log</b> <b>messages,</b> etc.|$|R
5000|$|Also - {{as it can}} <b>log</b> the <b>messages</b> - {{it helps}} testers/developers in troubleshooting, since the <b>logged</b> <b>messages</b> can be {{analysed}} - also such recorded messages can be used later as base of stub responses ...|$|R
50|$|Since each process, {{application}} and operating system, was written independently, {{there is little}} uniformity {{to the content of}} the <b>log</b> <b>message.</b> For this reason, no assumption is made about its formatting or contents.|$|E
5000|$|A commit object links tree objects {{together}} into a history. It contains {{the name of a}} tree object (of the top-level source directory), a time stamp, a <b>log</b> <b>message,</b> and the names of zero or more parent commit objects.|$|E
50|$|<b>Log</b> <b>message</b> format or content may {{not always}} be fully documented. A task of the log analyst is to induce the system to emit the full range of {{messages}} {{in order to understand the}} complete domain from which the messages must be interpreted.|$|E
5000|$|Log management: Focus on simple {{collection}} and storage of <b>log</b> <b>messages</b> and audit trails ...|$|R
5000|$|Error {{handling}} and <b>logging.</b> <b>Log</b> <b>messages</b> can be categorized, filtered and routed to different destinations.|$|R
5000|$|The {{ability to}} format <b>log</b> <b>messages</b> using Unix shell-like {{variable}} expansion (can break cross-platform log format compatibility) ...|$|R
50|$|Loggers {{are named}} <b>log</b> <b>message</b> destinations. They are the names {{that are known}} to the Java application. Each logger is {{independently}} configurable as to what level of logging (FATAL, ERROR, etc.) it currently logs. In early versions of Log4j, these were called category and priority, but now they're called logger and level, respectively. A Logger can send log messages to multiple Appenders.|$|E
5000|$|Many wiki implementations, such as MediaWiki, allow {{users to}} supply an edit summary when they edit a page. This {{is a short}} piece of text {{summarizing}} the changes they have made (e.g., [...] "Corrected grammar," [...] or [...] "Fixed formatting in table."). It is not inserted into the article's main text, but is stored along with that revision of the page, allowing users to explain {{what has been done}} and why, similar to a <b>log</b> <b>message</b> when making changes in a revision-control system. This enables other users to see which changes have been made by whom and why, often in a list of summaries, dates and other short, relevant content, a list which is called a [...] "log" [...] or [...] "history." ...|$|E
5000|$|In Logger, {{the logging}} methods are {{overloaded}} with forms that accept one, {{two or more}} values. Occurrences of the simple pattern [...] in the <b>log</b> <b>message</b> are replaced in turn with the values. This is simple to use yet provides a performance benefit when the values have expensive [...] methods. When logging is disabled at the DEBUG level, the logging framework {{does not need to}} evaluate the string representation of the values. In the following example, the values [...] or [...] only need to be evaluated when DEBUG is enabled; otherwise the overhead of the debug call is trivial. LOG.debug("There are now [...] " [...] + count + [...] " [...] user accounts: [...] " [...] + userAccountList); // slow LOG.debug("There are now {} user accounts: {}", count, userAccountList); // faster ...|$|E
5000|$|Error {{handling}} and logging, with errors handled and presented, and <b>log</b> <b>messages</b> optionally categorized, filtered and routed to different destinations ...|$|R
5000|$|Classify {{incoming}} <b>log</b> <b>messages</b> and at {{the same}} time extract structured information from the unstructured syslog message (since syslog-ng OSE 3.0) ...|$|R
40|$|Abstract: Sender-based <b>message</b> <b>logging</b> allows each <b>message</b> to be <b>logged</b> in the {{volatile}} storage of its corre-sponding sender. This behavior avoids <b>logging</b> <b>messages</b> on the stable storage synchronously {{and results in}} lower failure-free overhead than receiver-based <b>message</b> <b>logging.</b> However, in the first approach, each process should keep in its limited volatile storage the log information of its sent messages for recovering their receivers. In this paper, we propose a 2 -step algorithm to efficiently remove <b>logged</b> <b>messages</b> from {{the volatile}} storage while en-suring the consistent recovery of the system in case of process failures. As the first step, the algorithm eliminates useless log information in the volatile storage with no extra message and forced checkpoint. But, even if the step has been performed, the more empty buffer space for <b>logging</b> <b>messages</b> in future may be required. In this case, the second step forces the useful log information to become useless by maintaining a vector to record {{the size of the}} information for every other process. This behavior incurs fewer additional messages and forced checkpoints than existing algorithms. Experimental results verify that our algorithm significantly performs better than the traditional one with respect to the garbage collection overhead...|$|R
3000|$|Non-durability The Follower {{responses}} the Leader immediately when {{it receives}} the <b>log</b> <b>message</b> and buffers the log record in memory.|$|E
3000|$|Non-repudiation for payment: A vehicle cannot deny {{of using}} the {{services}} because a <b>log</b> <b>message</b> is attached {{to ensure that the}} vehicle transactions are saved. Moreover, though the RSC does not control the electronic spending of v [...]...|$|E
40|$|This {{maintenance}} release includes, {{but is not}} limited to: adding more <b>log</b> <b>message</b> to GitHub Checker tool to enable for more detailed troubleshooting of datasets / parsers. ensuring that GitHub Checker Tool restricts the number of info, warning and error message to 500 to avoid flooding of travis log files...|$|E
5000|$|A Log4J-based {{technology}} for logging (called Logdoc), offering a specification format, internationalization of <b>log</b> <b>messages,</b> generation of HTML documentation and generation of code.|$|R
50|$|The {{commands}} <b>log</b> <b>messages</b> to {{an administrative}} area, {{which can be}} useful for diagnosing installation issues or just tracking what software is loaded or removed.|$|R
5000|$|Provides a {{quick and}} easy way to write <b>log</b> <b>messages</b> to an {{on-screen}} console, the Firebug extension for Mozilla Firefox, or the Safari JavaScript console.|$|R
40|$|Abstract—Handling log {{messages}} securely, for example, on servers or embedded devices, {{has often}} relied on cryptographic messages authentication codes (MACs) to ensure log file integrity: Any modification or deletion of a log entry will invalidate the MAC, making the tampering evident. However, organizational se-curity requirements regarding log files have changed significantly over the decades. For example, European privacy and {{personal data protection}} laws mandate that certain information, such as IP (internet protocol) addresses, must only be stored for a certain retention period, typically seven days. Traditional log file security measures, however, {{do not support the}} delayed deletion of partial <b>log</b> <b>message</b> information for such compliance reasons. This article presents SLOPPI (secure logging with privacy protection and integrity), a three-tiered log management framework with focus on integrity management and compliance as well as optional support for encryption-based confidentiality of log messages. Keywords-log file management; secure logging; compliance; <b>log</b> <b>message</b> encryption; privacy by design. I...|$|E
40|$|Detecting {{execution}} anomalies is {{very important}} to the maintenance and monitoring of large-scale distributed systems. People often use console logs that are produced by distributed systems for troubleshooting and problem diagnosis. However, manually inspecting console logs for the detection of anomalies is unfeasible due to the increasing scale and complexity of distributed systems. Therefore, there is great demand for automatic anomaly detection techniques based on log analysis. In this paper, we propose an unstructured log analysis technique for anomaly detection, with a novel algorithm to automatically discover program invariants in logs. At first, a log parser is used to convert the unstructured logs to structured logs. Then, the structured log messages are further grouped to <b>log</b> <b>message</b> groups according to the relationship among log parameters. After that, the program invariants are automatically mined from the <b>log</b> <b>message</b> groups. The mined invariants can reveal the inherent linear characteristics of program work flows. With these learned invariants, our technique can automatically detect anomalies in logs. Experiments on Hadoop show that the technique can effectively detect execution anomalies. Compared with the state of art, our approach can not only detect numerous real problems with high accuracy but also provide intuitive insight into the problems. ...|$|E
30|$|When a Follower {{receives}} a <b>log</b> <b>message</b> from the Leader, it would extract the committed LSN from the received log record {{and compare it}} with the local cached committed LSN. If the local value {{is less than the}} new committed LSN, it should be updated with the new one; otherwise, the value is not refreshed. Then the Follower appends the commit log {{to the end of the}} log file in local disk. Once the appending operation has finished or overrun a certain period of time, the Follower would get the maximum flushed LSN, which represents the latest state of commit log in local disk. Then it sends the response message containing the maximum flushed LSN to the Leader.|$|E
40|$|Source code {{modifications}} {{are often}} documented with <b>log</b> <b>messages.</b> Such messages {{are a key}} component of software maintenance: they can help developers validate changes, locate and triage defects, and understand modifications. However, this documentation can be burdensome to create and can be incomplete or inaccurate. We present an automatic technique for synthesizing succinct human-readable documentation for arbitrary program differences. Our algorithm is based on a combination of symbolic execution and a novel approach to code summarization. The documentation it produces describes the effect of a change on the runtime behavior of a program, including the conditions under which program behavior changes and what the new behavior is. We compare our documentation to 250 human-written <b>log</b> <b>messages</b> from 5 popular open source projects. Employing a human study, we find that our generated documentation is suitable for supplementing or replacing 89 % of existing <b>log</b> <b>messages</b> that directly describe a code change...|$|R
5000|$|Log {{management}} (LM) comprises {{an approach}} to dealing with large volumes of computer-generated <b>log</b> <b>messages</b> (also known as audit records, audit trails, event-logs, etc.). Log Management generally covers: ...|$|R
5000|$|Version 5.0.2.6 of 4. November 2016 {{enhanced}} <b>log</b> <b>messages,</b> updated some external {{packages and}} adapted the backup configuration file format {{in order to}} be compatible with commercial edition.|$|R
40|$|Dependencies among system {{components}} {{are crucial to}} locating root errors in a distributed system. In this paper, we propose an approach to mine inter-component dependencies from unstructured logs. The technique requires neither additional system instru-mentation nor any application specific knowledge. In the approach, we first parse each <b>log</b> <b>message</b> into its log key and parameters. Then, we find dependent log key pairs belong to different components by leveraging co-occurrence analysis and parameter correspondence. After that, we use Bayesian decision theory to estimate the dependency direction of each dependent log key pair. We further apply time delay consistency to re-move false positive detections. Case studies on Ha-doop show that the technique successfully identifies the dependencies among the distributed system com-ponents...|$|E
40|$|This master's thesis in {{the first}} part {{describes}} the AS/ 400 and its message system and concentrates especially on the following areas: predefinition of messages and their storing, types of messages and levels of their importance, work with variables included in message text and ways of sending messages. On the basis of AS/ 400 message system is designed and implemented message log system for the application loggin for Aegis. s. r. o. The analysis of the message log systems is also a part of the work. The syslog and syslog-ngused in UNIX systems are described, concerning types of messages, importance of messages and filtering and storing of messages. It further describes possibilities of application logging based on Java in the specific case of the Log 4 jutility. In the second part thesis describes own <b>log</b> <b>message</b> systems design and implementation...|$|E
40|$|As a {{software}} system evolves, developers make changes to add new features ot fix {{different kinds of}} bugs reported by testers and end users. The efficiency and effectiveness of changing and fixing have huge impact on {{the reliability of the}} software system. After studying a large number of changes in major open source projects, I found that developers often make similar changes. There are some common change types that are frequently used. It would be helpful if we can reuse these common changes. These common changes can be used in documenting changes, automatic patch generation, and patch identification. I proposed a graph-based approach to mine change patterns from software changes. Mining from over 100, 00 changes, I found that a few frequent top change patterns covers large proportion of all changes and the rest change patterns distribute as a long tail. To show the usefulness of our approach, I applied it to change documentation and evaluation on one of the potential applications - automatic change documentation. To evaluate the coverage and quality of our change documentation, I conducted several evaluation experiments: coverage experiment, score metric systematic evaluation, ranking survey, and email survey. According to the evaluation experiments results, the change documentation approach can generate better change documentation than the existing approach. The coverage experiment measure the coverage of the change documentation approach, which indicate the effectiveness of our approach. The result shows that this approach can reach high percentage with a certain number of change patterns. In the score metric systematic evaluation experiment and ranking survey, I compared the quality of the original <b>log</b> <b>message,</b> the change documentation of existing approach, and the change documentation. The results indicate that the change documentation can generate better change documentation than existing tool, and the change documentation can complement the <b>log</b> <b>message.</b> To evaluate the accuracy of the change documentation, we conducted email survey by sending survey forms to the developers of the projects we used in evaluation. According to their feedbacks, the change documentation is accurate...|$|E
50|$|<b>Log</b> <b>messages</b> must {{usually be}} {{interpreted}} {{with respect to the}} internal state of its source (e.g., application) and announce security-relevant or operations-relevant events (e.g., a user login, or a systems error).|$|R
50|$|Unlike log4j, SLF4J offers logging {{methods that}} accept markers. These are special objects that enrich the <b>log</b> <b>messages.</b> At present time, logback {{is the only}} {{framework}} which makes use of markers.|$|R
40|$|We {{present a}} number of {{experiments}} showing that for compute-intensive applications executing in parallel on clusters of workstations, <b>message</b> <b>logging</b> has higher failure-free overhead than coordinated checkpointing. <b>Message</b> <b>logging</b> protocols, however, result in much shorter output latency than coordinated checkpointing. Therefore, <b>message</b> <b>logging</b> {{should be used for}} applications involving substantial interactions with the outside world, while coordinated checkpointing should be used otherwise. We also present an unorthodox <b>message</b> <b>logging</b> design that uses coordinated checkpointing with <b>message</b> <b>logging,</b> departing from the conventional approaches that use independent checkpointing. This combination of <b>message</b> <b>logging</b> and coordinated checkpointing offers several advantages, including improved failure-free performance, bounded recovery time, simplified garbage collection, and reduced complexity. Meanwhile, the new protocols retain the advantages of the conventional <b>message</b> <b>logging</b> protocols with respect to output commit. Finally, we discuss three “lessons learned” from an implementation of various <b>message</b> <b>logging</b> protocol...|$|R
