15|10000|Public
25|$|A microassembler is {{a program}} that helps prepare a microprogram, called firmware, to control the <b>low</b> <b>level</b> <b>operation</b> of a computer.|$|E
25|$|The BSh-2 was {{overweight}} and underpowered, {{with the original}} Mikulin AM-35 1,022kW (1,370hp) engine designed to give its greatest power outputs at high altitude. Because of this it was redesigned as the TsKB-57, a lighter single-seat design, with the more powerful 1,254kW (1,680hp) Mikulin AM-38 engine, a development of the AM-35 optimised for <b>low</b> <b>level</b> <b>operation.</b> The TsKB-57 first flew on 12 October 1940. The production aircraft passed State Acceptance Trials in March 1941, and was redesignated Il-2 in April. Deliveries to operational units commenced in May 1941.|$|E
5000|$|A microassembler is {{a program}} that helps prepare a microprogram, called firmware, to control the <b>low</b> <b>level</b> <b>operation</b> of a computer.|$|E
5000|$|... #Caption: OP-2E Neptune BuNo 131478, {{formerly}} of VO-67, in AMARC storage at Davis-Monthan AFB, c. 1971. The camouflage is green for <b>low</b> <b>level</b> <b>operations</b> over Vietnam.|$|R
50|$|Earlier emulators had {{concentrated}} on accurately emulating {{all of the}} <b>low</b> <b>level</b> <b>operations</b> of the target machine. This worked well enough for older consoles such as the Super NES (although truly hardware-accurate emulation wouldn't appear until bsnes) and Genesis.|$|R
50|$|The wing team {{deployed}} to Green Flag '93 at Nellis AFB, Nevada from 2 March - 2 April 1993. The first day-night Green Flag incorporated night <b>low</b> <b>level</b> <b>operations</b> and live weapons delivery. The 79th Fighter Squadron inactivated on 23 April 1993, {{with the last}} aircraft departing RAF Upper Heyford on 10 May.|$|R
50|$|The BSh-2 was {{overweight}} and underpowered, {{with the original}} Mikulin AM-35 1,022 kW (1,370 hp) engine designed to give its greatest power outputs at high altitude. Because of this it was redesigned as the TsKB-57, a lighter single-seat design, with the more powerful 1,254 kW (1,680 hp) Mikulin AM-38 engine, a development of the AM-35 optimised for <b>low</b> <b>level</b> <b>operation.</b> The TsKB-57 first flew on 12 October 1940. The production aircraft passed State Acceptance Trials in March 1941, and was redesignated Il-2 in April. Deliveries to operational units commenced in May 1941.|$|E
50|$|In January 1942 Pickard and his {{squadron}} began {{training for}} a <b>low</b> <b>level</b> <b>operation</b> over occupied France. Their Whitely bombers were modified by havning holes cut in the fuselage to allow paratroopers to jump directly out of {{the bottom of the}} aircraft. Pickard led a group of 12 Whitleys on the mission, leaving on the evening of 27 February and transporting the paratroopers from RAF Thruxton over the channel to France. The aircraft crossed the English Channel without incident, but as they reached the French coast they came under heavy anti-aircraft fire. None of the aircraft were hit, and they successfully delivered C Company to the designated drop zone near the installation. The mission was a success. Back in England, Pickard was first to greet the British paratroops at Portsmouth.|$|E
50|$|The {{propulsion}} systems were significant upgrades featuring camshaft driven motor controllers that offered both higher and smoother acceleration. The air compressors and motor gear train were far quieter; {{that along with}} the sealed windows and fluorescent lighting provided an isolated and relaxing environment for the passengers. Seating consisted of reversible 3-2 bench seats with a synthetic canvas covering with a total capacity of 130 persons per car, {{far more than the}} cars they replaced. The cars were built with manually operated doors that contained convertible traps for <b>low</b> <b>level</b> <b>operation.</b> After the electrified lines were converted to all high level operation {{with the arrival of the}} M1A cars, the ACMUs were left in their high level configuration full-time. The manual side doors were never automated resulting in the frequent practice of doors being left open over the entire duration of a trip.|$|E
25|$|The Sopwith TF.2 Salamander was a British ground-attack {{aircraft}} of the First World War {{designed by}} the Sopwith Aviation Company which first flew in April 1918. It was a single-engined, single-seat biplane based on the Sopwith Snipe fighter but with an armoured forward fuselage to protect the pilot and fuel system from ground fire during <b>low</b> <b>level</b> <b>operations.</b>|$|R
50|$|As far as legacy BIOS concerned, {{the context}} {{is placed in}} the x86 20bit Real Mode (8086 16bit CPU limitation, {{inherited}} from PC XT DOS design) of operation (below/up to first 1MB (20bit) address space). VBT is used with the legacy Video BIOS (vBIOS), which is placed as Option ROM at the address 0xC0000 (till maximal address 0xCFFFF), thus maximum size of 64KB. vBIOS is using legacy INT 10H for GFX <b>low</b> <b>level</b> <b>operations.</b>|$|R
50|$|The {{fuselage}} of the Buccaneer {{was designed}} using the area rule technique, {{which had the}} effect of reducing aerodynamic drag while travelling at high subsonic and transonic speeds, and gave rise to the characteristic curvy 'Coke bottle' shape of the fuselage. The majority of the airframe and fuselage was machined from solid casting; to give great strength to endure the stress of <b>low</b> <b>level</b> <b>operations.</b> Considerable effort went into ensuring that metal fatigue would not be a limiting factor of the Buccaneer's operational life, even under the formidable conditions imposed of continuous <b>low</b> <b>level</b> flight.|$|R
50|$|A microassembler is a {{computer}} program that helps prepare a microprogram, called firmware, to control the <b>low</b> <b>level</b> <b>operation</b> of {{a computer}} {{in much the same}} way an assembler helps prepare higher level code for a processor. The difference is that the microprogram is usually only developed by the processor manufacturer and works intimately with the computer hardware. On a microprogrammed computer the microprogram implements the operations of the instruction set in which any normal program (including both application programs and operating systems) is written. The use of a microprogram allows the manufacturer to fix certain mistakes, including working around hardware design errors, without modifying the hardware. Another means of employing microassembler-generated microprograms is in allowing the same hardware to run different instruction sets. After it is assembled, the microprogram is then loaded to a control store to become part of the logic of a CPU's control unit.|$|E
50|$|Faced {{with far}} greater {{difficulty}} of operating aircraft from small British farms, the British Government assumed topdressing aircraft {{would need to}} operate from an ordinary runway. Economies of scale then dictated using large aircraft, which would in turn have to fly higher. Accordingly, in 1950 the RAF conducted trials over Scottish farm land with Avro Lincoln and Avro Lancaster bombers carrying canvas trays with 5 tons of superphosphate in 14 lb and 28 lb paper bags designed to burst on impact. These trials were a failure due to poor spread achieved from the bags. The Bristol Aeroplane Company conducted private trials on hill country {{in the same year}} with scaled-up versions of the New Zealand hoppers fitted to Bristol Freighters. The success of these trials was widely publicised through Farmers' Weekly magazine. Hopper conversions were marketed for the Freighter and the even larger Handley Page Hastings. However low capitalisation for start up costs and the difficulties of <b>low</b> <b>level</b> <b>operation</b> in large transports led British private industry to use smaller machines, even though they could not operate directly from farms.|$|E
30|$|The wmdl_browse (Algorithm 3) and (Algorithm 4) is an {{operation}} which updates the file list available in all pGrid nodes {{in the network}} and displays it in the browse list with pGrid node name. The operation wmdl_cp is also a <b>low</b> <b>level</b> <b>operation,</b> which just simply copies a data between two remote nodes. This operation is done only by the administrator and is triggered when a pGrid Node is removed permanently from the group.|$|E
50|$|In {{telecommunication}} {{and information}} theory, broadcasting {{is a method}} of transferring a message to all recipients simultaneously. Broadcasting can be performed as a high <b>level</b> <b>operation</b> in a program, for example broadcasting Message Passing Interface, {{or it may be}} a <b>low</b> <b>level</b> networking <b>operation,</b> for example broadcasting on Ethernet.|$|R
2500|$|The {{fuselage}} of the Buccaneer {{was designed}} using the area rule technique, {{which had the}} effect of reducing aerodynamic drag while travelling at high subsonic and transonic speeds, and gave rise to the characteristic curvy 'Coke bottle' shape of the fuselage. [...] The majority of the airframe and fuselage was machined from solid casting; to give great strength to endure the stress of <b>low</b> <b>level</b> <b>operations.</b> [...] Considerable effort went into ensuring that metal fatigue would not be a limiting factor of the Buccaneer's operational life, even under the formidable conditions imposed of continuous <b>low</b> <b>level</b> flight.|$|R
25|$|The {{military}} {{review their}} need for airspace for <b>low</b> <b>level</b> high speed <b>operations</b> and withdraw any areas not needed.|$|R
40|$|Abstract — While {{there is}} much {{research}} in human-robot interaction on the personal, or one-to-one level, there is little on the large scale, or many-to-many. We propose an interaction infrastructure for many human operators to utilize {{a large number of}} robots. The infrastructure operates in two phases allowing the tasks and services offered by many robots to be exposed to many users, as well as the personal interaction between a user and a robot. We assume that each robot has some degree of autonomy and that the humans assume a supervisory role. The approach is analyzed in detail on a single robot system with many users to establish it's <b>low</b> <b>level</b> <b>operation</b> and then on a large-scale experiment involving several robot systems offering many tasks and services to many users. In the latter experiment, the infrastructure managed the interaction between hundreds of users and several robot and embedded systems...|$|E
40|$|Segmentation is an {{important}} step in the image analysis and image understanding. In this <b>low</b> <b>level</b> <b>operation,</b> an image is partitioned into homogeneous and disjoint regions. In image processing, these homogeneous regions (edges) are assumed to correspond to actual objects in an image. So image segmentation plays a vital role as fundamental process. In computer vision and image processing, edge detection refers to identify the points (pixels) in a digital image at which there is a discontinuity or the brightness changes sharply. Edge detection finds applications in discontinuities or variations in illumination. Edge detection is widely in used in image processing applications because this initial operation that plays {{an important}} role in the image processing tasks such as object recognition, image segmentation, classification and boundary detection etc. In this paper, the detection of edges in color images can be tested with traditional edge detectors: Robert, sobel, prewitt, laplacian and canny...|$|E
40|$|Abstract—segmentation is a <b>low</b> <b>level</b> <b>operation</b> {{concerned}} with partitioning of images by determining similarity or discontinuity, or equivalently, by finding edges or boundaries’. image segmentation {{is the process}} of partitioning an image into multiple partitions, so as to change the epitomization of an image into something that is more meaningful and easier to analyze. Several general-purpose algorithms and techniques have been developed for image segmentation. This paper trace the different segmentation techniques used for multichannel images. Firstly this paper investigates and compiles some of the technologies used for image segmentation, which are well suited for gray scale images as well as multichannel images. Afterwards a bibliographical survey of currently utilizing color models for segmentation of multichannel images techniques is given in this paper then a comparative analysis of different methods is done and finally general tendencies in image segmentation are presented. Index Terms — segmentation, color model, fuzzy c means clustering, I...|$|E
40|$|This thesis {{presents}} the framework {{used in our}} research group [...] -the Shared Reality Environment Lab [...] -for use in our spatially immersive setups. Our main interest is the application of virtual reality techniques {{in the context of}} computer-mediated human to human communication and collaboration. The purpose of this architecture is to allow users to quickly develop remote collaborative applications without the need to manage <b>low</b> <b>level</b> <b>operations.</b> The framework is comprised of multiple independent components: the Qave graphics engine, user trackers, sound spatializer, coherence server, communication library and overlapping projectors interface. Some components were already implemented when this work started and the contributions of this thesis are the graphics engine, the coherence server as well as the integration of the other components in that framework...|$|R
40|$|The Solenodon {{research}} robot is a six legged mechanical {{walking platform}} designed at Ryerson Polytechnic University’s School of Computer Science. It was our goal {{to develop a}} platform that would facilitate the examination of issues involving stability in walking robots. The vehicle is available in several configurations ranging from fully teleoperated to <b>low</b> <b>level</b> autonomous <b>operation...</b>|$|R
40|$|Abstract: This paper reports ongoing work {{towards a}} {{dynamically}} reconfigurable System-on-Chip (SoC) platform for video signal processing. It consists of dedicated, statically and dynamically reconfigurable components, {{as well as}} an embedded RISC core and memory. Application-specific software libraries support control of dynamic reconfiguration of <b>low</b> <b>level</b> <b>operations</b> by high <b>level</b> instructions. Thus programmability is combined with high data throughput and low power consumption of hardwired circuits. Preliminary work presented here is focused on one selected application, video object segmentation. The architecture of a coprocessor for video object segmentation is presented, which exploits the basic concept of the dynamically reconfigurable SoC platform. A library of software functions for image processing was developed, too, which will be used {{as a starting point for}} the application-specific software parts of the platform...|$|R
40|$|This paper uses System Dynamics (SD) {{simulation}} {{to investigate}} the concept green logistics in terms of energy efficiency in automotive industry. The car manufacturing industry {{is considered to be}} one of the highest energy consuming industries. An efficient decision making model is proposed that capture the impacts of strategic decisions on energy consumption and environmental sustainability. The sources of energy considered in this research are electricity and fuel; which are the two main types of energy sources used in a typical vehicle assembly plant. The model depicts the performance measurement for process- specific energy measures of painting, welding, and assembling processes. SD is the chosen simulation method and the main green logistics issues considered are Carbon Dioxide (CO 2) emission and energy utilization. The model will assist decision makers acquire an in-depth understanding of relationship between high level planning and <b>low</b> <b>level</b> <b>operation</b> activities on production, environmental impacts and costs associated. The results of the SD model signify the existence of positive trade-offs between green practices of energy efficiency and the reduction of CO 2 emission...|$|E
40|$|Mobile ad hoc {{networks}}, {{also called}} MANETs, are self-organised networks spontaneously created between neighbouring devices {{that do not}} need any infrastructure. The possibility of deploying a communication network at any moment and at any place opens {{a wide range of}} potential scenarios where the use of an ad hoc network is extremely important and useful. For example, we can imagine an area with no infrastructure, due to a natural disaster (flooding, earthquake, etc.), a war damage or simply a remote location. In such situations, the deployment of an ad hoc network for rescuing or evacuating people is key. %Allowing the communication between groups located in distant areas may be very helpful in critical situations in order to coordinate and reorganise them. However, ad hoc networks are not restricted to safety of disaster situations, they can also be used for gathering sensed data and send it to a remote server, exchanging safety road messages between vehicles or simply for infotainment, etc. Efficient communication protocols are very important for providing good services, but in ad hoc networks is very challenging. It is necessary to deal with packet loss, collisions, mobility, network partitions, fading, energy constraints, obstacles, etc. Due to the intrinsic broadcast nature of wireless medium, dissemination algorithms {{are one of the most}} appropriate protocols for communicating devices. Additionally, broadcasting is one of the main <b>low</b> <b>level</b> <b>operation</b> as many applications and even other protocols rely on its service. Therefore, in this thesis, we are proposing two different broadcasting algorithms for efficiently disseminate messages in the network. The first approach relays on an underlying tree topology, while the second is an energy aware algorithm that tries to reduce the energy consumption. In these unpredictable and changeable networks, protocols need to adapt to the current circumstances and this adaptability is usually obtained using thresholds. The values of these thresholds directly influence the behaviour of the algorithm. Finding them is a complex and critical task as protocols are usually very sensitive. We tackle this problem using approximation algorithms or metaheuristics, more specifically, we use a parallel iterative local search and two evolutionary algorithms. In order to ease this process, we have created a modular experimental framework for evaluating, validating and optimising any algorithm in MANETs...|$|E
40|$|This note {{talks about}} {{hierarchical}} processes in Swift, and compares {{them to the}} proposals for multi-ple and hierarchical accounts in [OPM 1. 01] and [OC]. 1 Notions of hierarchical pro-cesses in Swift Processes that seem straightforwardly representable in Swift fall into two categories: at the highest level, SwiftScript language constructs (procedures, and perhaps foreach, iterate and if statements); below that, the mechanics of Swift’s execution (for example, moving files to, from and between various caches, and interactions with job execution). Swift provenance work so far has concentrated on the former area, treating all of the low-level behaviour as opaque and exposing neither processes nor arti-facts. So (I think) this document will deal with the two fairly separately. The section dealing with low-level processes will need to define not only ways of refinement but also the actual processes and artifacts to be used. 2 Use cases of refinement in Swift A. Distinguishing {{what happened at the}} SwiftScript language level from what happened at the me-chanics level. B. Within the language level, consider a program that consists of nested procedure invocations: outer → inner → helpers → apps, where ’outer’ is a driver loop iterating an algorithm over many data sets, ’inner ’ is the main call to that algorithm, which is partly implemented in SwiftScript using the ’helper ’ procedure, and partly using external application calls. We might be interested in the use of our algo-rithm, which corresponds to being interested {{in the use of the}} ’inner ’ procedure, ignoring who called it (’outer’) and the mechanics of the inner procedure (’helpers’). For example, inner might perform a rescaling of a file in a particular image format by using helpers to convert to a standard format, using a standard tool to rescale, and then converting back to the proprietary format- but what we want to query is ”what was rescaled? ” rather than the nitty gritty. As swiftscript evolves to have more ap-plication functionality inside a swiftsript rather than in external apps, this becomes more rele-vant. C. ”why? provenance ”- why was a particular <b>low</b> <b>level</b> <b>operation</b> done? The answer to this might be something that looks like a stack trace in a conventional programming language...|$|E
40|$|This paper {{describes}} an algorithm for tracking groups {{of objects in}} video sequences. The main difficulties addressed in this work concern total occlusions of the objects to be tracked as well as group merging and splitting. A two layer solution is proposed to overcome these difficulties. The first layer produces a set of spatio temporal strokes based on <b>low</b> <b>level</b> <b>operations</b> which manage to track the active regions most of the time. The second layer performs a consistent labeling of the detected segments using a statistical model based on Bayesian networks. The Bayesian network is recursively computed during the tracking operation and allows the update of the tracker results everytime new information is available. Experimental tests are included to show {{the performance of the}} algorithm in ambiguous situations. ...|$|R
40|$|It {{has been}} shown that the large {{communication}} overhead in current multicomputer systems can be reduced greatly by using proper communication mechanisms [1] and processornetwork interfaces [4]. A good processor-network interface design is highly dependent on application characteristics, programming model, memory interface, and routing characteristics of the network. Unfortunately, these issues are not exploited fully in the previous work. In this paper, we address these issues from the perspective of application performance and propose a processor-network interface architecture that to optimize the system performance. Through such a design, not only the processor and network are tightly coupled, also are memory operation and message passing. As a result, high-level operations such as gather and scatter can be supported easily instead of using <b>low</b> <b>level</b> <b>operations</b> proposed previously. 1 Introduction Distributed-memory multicomputers, with their ability to exploit a massive amount of p [...] ...|$|R
40|$|Computer-aided font {{design is}} still a very tedious and {{repetitive}} task. New font models and new functionalities presented by digital media further require a new method for design of font families and dynamic variable fonts. Current design paradigms are either outline based, offering <b>low</b> <b>level</b> <b>operations,</b> or parametric but non-visual programming. Parametric feature based design helps in creating a design environment for high level parametric font design. However, the approaches suggested so far are too restrictive in their definition of features, and none of them utilises constraints in feature definition and design. We present a new approach for parametric feature based font design. Our approach extends the definition and use of features by defining implicit feature parts using constraints. Furthermore, the visual design system and the use of constraints for preserving designer's intentions create a more natural environment in which high level parametric behaviors can be [...] ...|$|R
40|$|In {{a simple}} client/server {{distributed}} environment, two principals {{are involved in}} most transactions - the initiator and {{the target of the}} operation. The target of the operation can reasonably make authorization decisions based on the identity of the initiator. This model is insufficient, however, when the server performs operations on other components on behalf of the initiator as is common in distributed object oriented environments. This paper will describe the need for a delegation facility in distributed object oriented systems and then present some elements of the delegation system we've proposed for inclusion in OSF's Distributed Computing Environment (DCE). INTRODUCTION The need for a delegation facility In a distributed object oriented environment, intermediate objects hide the details of complex system interactions. These intermediate objects receive high level requests from initiating clients and perform some series of <b>low</b> <b>level</b> <b>operations</b> on a number of other services. Unfo [...] ...|$|R
40|$|Undergraduate {{students}} often experience difficulty {{in understanding the}} basic principles of <b>low</b> <b>level</b> computer <b>operations</b> in introductory courses to computer architectures when these are taught using actual <b>low</b> <b>level</b> programming languages. This is not due to any inherent complexity of the concepts but rather a consequence of assembly language specific details and the need to introduce many concepts simultaneously, such as, for example, data representation, addressing modes and primitive I/O. This paper describes the Postroom Computer, a <b>low</b> <b>level</b> language simulator that not only provides a simple <b>low</b> <b>level</b> language, suitable as an introduction to assembly language programming, but also allows computer architecture concepts to be introduced in an incremental fashion...|$|R
40|$|In {{this paper}} we show how an {{extensive}} library of data parallel <b>low</b> <b>level</b> image processing <b>operations</b> is created with minimal effort. We discuss how many commonly used image processing operations are implemented in parallel by concatenation of communication routines, basic memory operations, and so-called "parallelizable patterns"...|$|R
40|$|International audienceCurrent {{processors}} typically embed many cores {{running at}} high speed. The main {{goal of this}} paper is to assess the efficiency of software parallelism for <b>low</b> <b>level</b> arithmetic <b>operations</b> by providing a thorough comparison of several parallel modular multiplications. Famous methods such as Barrett, Montgomery as well as more recent algorithms are compared together with a novel k-ary multipartite multiplication which allows to split the computations into independent processes. Our experiments show that this new algorithm is well suited to software parallelism...|$|R
40|$|Current {{processors}} typically embeds many cores {{running at}} high speed. We may then ask ourselves whether software parallelism is practical for <b>low</b> <b>level</b> arithmetic <b>operations.</b> In this paper we generalize the bipartite modular multiplication method of Kaihara and Takagi. We present a multipartite multiplication. We carefully analyze its asymptotic complexity and measure its practical {{efficiency and scalability}} for nowadays multi-core architectures. We present several experimental results which illustrate the efficiency of our method and which bring a positive answer to the above question {{for a wide range}} of operand’s sizes. ...|$|R
50|$|The {{scenery and}} level of traffic changes upon leaving the Fallon area. The road narrows from four lanes to two and crosses remote terrain {{characterized}} by Basin and Range topography. The summits start out low and gradually increase in elevation. The features in the first basins include Labou Flat, a dry lake used by the US Navy for <b>low</b> <b>level</b> flight <b>operations,</b> and Dixie Valley, with several visible fault scarps that resulted from the magnitude 7.1 Dixie Valley/Fairview earthquake in 1954. Dixie Valley is now a US Navy Electronic Warfare Range.|$|R
