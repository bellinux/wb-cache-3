24|372|Public
2500|$|A block can be {{continued}} across the bottom, top, left, or {{right of the}} chart. That can even wrap beyond {{the edge of the}} chart for variable minimization. This is because each <b>logic</b> <b>variable</b> corresponds to each vertical column and horizontal row. A visualization of the k-map can be considered cylindrical. The fields at edges on the left and right are adjacent, and the top and bottom are adjacent. K-Maps for 4 variables must be depicted as a donut or torus shape. The four corners of the square drawn by the k-map are adjacent. Still more complex maps are needed for 5 variables and more.|$|E
2500|$|The {{following}} {{are all the}} possible 2-variable, 2×2 Karnaugh maps. Listed with each is the minterms {{as a function of}} [...] and the race hazard free (see previous section) minimum equation. A minterm is defined as an expression that gives the most minimal form of expression of the mapped variables. All possible horizontal and vertical interconnected blocks can be formed. These blocks must be {{of the size of the}} powers of 2 (1, 2, 4, 8, 16, 32, ...). These expressions create a minimal logical mapping of the minimal <b>logic</b> <b>variable</b> expressions for the binary expressions to be mapped. Here are all the blocks with one field.|$|E
5000|$|... 'set' and 'reset' {{respectively}} activate & inactivate a <b>logic</b> <b>variable</b> (here a stage) ...|$|E
40|$|Functional {{languages}} can be enriched with <b>logic</b> <b>variables</b> {{to provide}} new computational {{features such as}} incremental construction of data structures. In this paper, we present a novel application for <b>logic</b> <b>variables</b> that highlights their importance: we argue that they are essential for efficient implementations of pure functional languages. This point is made by demonstrating that <b>logic</b> <b>variables</b> are required for explicating the process of demand propagation in lazy evaluation of functional programs. There are two applications of this result. For dataflow researchers, it offers a simple and efficient implementation of laziness on dataflow machines. For researchers investigating lazy graph reduction, it suggests new strictness analysis algorithms in which <b>logic</b> <b>variables</b> play an important role...|$|R
5000|$|... "Uncertain <b>Logics,</b> <b>Variables</b> and Systems", Springer-Verlag, Berlin, 2002 ...|$|R
40|$|We {{define a}} {{practical}} algorithm for distributed rational tree unification and prove its correctness {{in both the}} off-line and on-line cases. We derive the distributed algorithm from a centralized one, showing clearly the trade-offs between local and distributed execution. The algorithm is used to realize <b>logic</b> <b>variables</b> in the Mozart Programming System, which implements the Oz language (see [URL] Oz appears to the programmer as a concurrent object-oriented language with dataflow synchronization <b>Logic</b> <b>variables</b> implement the dataflow behavior. We show that <b>logic</b> <b>variables</b> can easily {{be added to the}} more restricted models of Java and ML, thus providing an alternative way to do concurrent programming in these languages. We present common distributed programming idioms in a network-transparent way using <b>logic</b> <b>variables.</b> We show that in common cases the algorithm maintains the same message latency as explicit message passing. In addition, it is able to handle uncommon cases that arise from the properties of latency tolerance and third-party independence. This is evidence that using <b>logic</b> <b>variables</b> in distributed computing is beneficial at both the system and language levels. At the system level, they improve latency tolerance and third-party independence. At the language level, they help make network-transparent distribution practical...|$|R
50|$|A {{concurrent}} <b>logic</b> <b>variable</b> {{is similar}} to a future, but is updated by unification, {{in the same way as}} logic variables in logic programming. Thus it can be bound more than once to unifiable values, but cannot be set back to an empty or unresolved state. The dataflow variables of Oz act as concurrent logic variables, and also have blocking semantics as mentioned above.|$|E
50|$|The future and/or promise {{constructs}} {{were first}} implemented in programming languages such as MultiLisp and Act 1. The use of logic variables for communication in concurrent logic programming languages was {{quite similar to}} futures. These began in Prolog with Freeze and IC Prolog, and became a true concurrency primitive with Relational Language, Concurrent Prolog, guarded Horn clauses (GHC), Parlog, Strand, Vulcan, Janus, Oz-Mozart, Flow Java, and Alice ML. The single-assignment I-var from dataflow programming languages, originating in Id and included in Reppy's Concurrent ML, is much like the concurrent <b>logic</b> <b>variable.</b>|$|E
5000|$|A block can be {{continued}} across the bottom, top, left, or {{right of the}} chart. That can even wrap beyond {{the edge of the}} chart for variable minimization. This is because each <b>logic</b> <b>variable</b> corresponds to each vertical column and horizontal row. A visualization of the k-map can be considered cylindrical. The fields at edges on the left and right are adjacent, and the top and bottom are adjacent. K-Maps for 4 variables must be depicted as a donut or torus shape. The four corners of the square drawn by the k-map are adjacent. Still more complex maps are needed for 5 variables and more.|$|E
40|$|We {{define a}} {{practical}} algorithm for distributed rational tree unification and prove its correctness {{in both the}} off-line and on-line cases. We derive the distributed algorithm from a centralized one, showing clearly the trade-offs between local and distributed execution. The algorithm is used to implement <b>logic</b> <b>variables</b> in the Distributed Oz system. Oz has a very general execution model based on concurrent constraints extended with explicit state and higher-orderness. We show that <b>logic</b> <b>variables</b> can easily {{be added to the}} more restricted models of Java and ML. We present common distributed programming idioms in a network-transparent way using <b>logic</b> <b>variables.</b> We show that in common cases the algorithm maintains the same message latency as explicit message passing. In addition, it is able to handle uncommon cases that arise from the properties of latency tolerance and third-party independence. This is evidence that using <b>logic</b> <b>variables</b> in distributed computing is beneficia [...] ...|$|R
40|$|Abstract. Functional logic {{languages}} extend purely functional languages {{with two}} features: operations defined by overlapping rules and <b>logic</b> <b>variables</b> in both defining rules and expressions to evaluate. In this paper, {{we show that}} {{only one of these}} features is sufficient in a core language. On the one hand, overlapping rules can be eliminated by introducing <b>logic</b> <b>variables</b> in rules. On the other hand, <b>logic</b> <b>variables</b> can be eliminated by introducing operations defined by overlapping rules. The proposed transformations between different classes of programs not only give {{a better understanding of the}} features of functional logic programs but also are useful to simplify implementations of functional logic languages. ...|$|R
40|$|In this lecture {{we return}} to the {{treatment}} of <b>logic</b> <b>variables.</b> In Prolog and some extensions we have considered, <b>logic</b> <b>variables</b> are global, and equations involving <b>logic</b> <b>variables</b> are solved by unification. However, when universal goals ∀x. A are allowed in backward chaining, or existential assumptions ∃x. A in forward chaining, new parameters may be introduced into the proof search process. Ordinary unification on <b>logic</b> <b>variables</b> is now unsound, even with the occurs-check. We generalize <b>logic</b> <b>variables</b> to metavariables, a terminology borrowed from proof assistants and logical frameworks, and describe unification in this extended setting. 24. 1 Parameters When proving a universally quantified proposition we demand that proof to be parametric. In the rule this is enforced by requiring that x be new. Γ; ∆ ⊢ A x / ∈ FV(Γ,∆) Γ; ∆ ⊢ ∀x. A The condition on x can always be satisfied by renaming the bound variable. Operationally, this means that we introduce a new parameter into the derivation when solving a goal ∀x. A. We already exploited the parametricity of the derivation for the admissibility of cut by substituting a term t for x in the subderivation. The admissibility of cut, rewritten here for lax linear logic, has the following form, with J standing for either C true or C lax...|$|R
5000|$|The {{following}} {{are all the}} possible 2-variable, 2 × 2 Karnaugh maps. Listed with each is the minterms {{as a function of}} [...] and the race hazard free (see previous section) minimum equation. A minterm is defined as an expression that gives the most minimal form of expression of the mapped variables. All possible horizontal and vertical interconnected blocks can be formed. These blocks must be {{of the size of the}} powers of 2 (1, 2, 4, 8, 16, 32, ...). These expressions create a minimal logical mapping of the minimal <b>logic</b> <b>variable</b> expressions for the binary expressions to be mapped. Here are all the blocks with one field.|$|E
40|$|Abstract This article {{introduces}} a concurrent object oriented language whose underlying operational semantics {{is based on}} the <b>logic</b> <b>variable.</b> The language is designed in reponse to Kahn’s criticisms [Kahn 89] of previous attempts to build concurrent object-oriented languages on top of concurrent logic languages. We believe Aldwych is a language which removes the verbosity of concurrent logic language code, without removing the power for abstract concurrent programming...|$|E
40|$|The {{problem of}} {{partitioning}} grid-based applications for parallel computing {{can be solved}} easily and intuitively in a logic programming language such as Prolog, using only the single assignment property of the <b>logic</b> <b>variable,</b> and not the backtracking. We show that such a logic program can be transformed in a systematic way into a circular functional program, which runs 10 {{times faster than the}} original logic program. The transformation proceeds in a number of steps. The first step is novel, and we give a correctness proof. Our reasoning also uses a novel combination of concepts from both the logical and functional paradigm...|$|E
40|$|When one develops, implements, {{and studies}} type {{theories}} based on linear logic, for example, {{in the context}} of theorem proving, logic programming, and formal reasoning, one is immediately confronted with questions about their equational theory and how to deal with <b>logic</b> <b>variables.</b> In this paper, we propose linear contextual modal type theory that gives a mathematical account of the nature of <b>logic</b> <b>variables.</b> Our type theory is conservative over intuitionistic contextual modal type theory proposed by Nanevski, Pfenning, and Pientka. As a technical contribution we provide a proof of soundness, and, as a justification for its usefulness, we shed some light on the difficulties working with <b>logic</b> <b>variables</b> in linear <b>logics</b> that contain ⊤. ...|$|R
40|$|The {{addition}} of <b>logic</b> <b>variables</b> to functional languages gives the programmer novel and powerful {{tools such as}} incremental definition of data structures through constraint intersection. A number of such "hybrid" languages, like FGL + LV [11], Id [17] and Qute [24], have been implemented and are in active use. Pure functional and logic programming languages can be given elegant abstract semantics as functions and relations over values. The definition of such an abstract semantics for a functional language with <b>logic</b> <b>variables</b> has remained an open problem. In an earlier paper, we gave such a semantics for the special case of a first-order functional languages with <b>logic</b> <b>variables</b> by reducing the problem to that of solving simultaneous fixpoint equations involving closure operators over a Scott domain [9]. In fact, we obtained the rather strong result that the denotational semantics was fully abstract {{with respect to the}} operational semantics. However, the problem for higher-order languages remain open, in part because higher-order functions can interact with <b>logic</b> <b>variables</b> in complicated ways to give rise to behavior reminiscent of own variables in Algol- 60. This problem is solved completely in this paper. We show that in the presence of <b>logic</b> <b>variables,</b> higher-order functions may be modeled extensionally as closure operators on graphs ordered a way reminiscent of the ordering on extensible records in studies of inheritance [1]. We then extend the equation solving semantics of the first-order subset to the full language, and prove the usual soundness and adequacy theorems for this semantics. These results show that a higher-order functional language with <b>logic</b> <b>variables</b> {{can be viewed as a}} language of incremental definition of functions...|$|R
5000|$|Languages {{supporting}} futures, promises, concurrent <b>logic</b> <b>variables,</b> dataflow variables, or I-vars, {{either by}} direct language support {{or in the}} standard library, include: ...|$|R
40|$|Long carrier spin lifetimes are a {{double-edged}} sword for the prospect of constructing "spintronic" logic devices: Preservation of the <b>logic</b> <b>variable</b> within the transport channel or interconnect is essential to successful completion of the logic operation, but any spins remaining past this event will pollute the environment for subsequent clock cycles. Electric fields {{can be used to}} manipulate these spins on a fast timescale by careful interplay of spin-orbit effects, but efficient controlled depolarization can only be completely achieved with amenable materials properties. Taking III-VI monochalcogenide monolayers as an example 2 D semiconductor, we use symmetry analysis, perturbation theory, and ensemble calculation to show how this longstanding problem can be solved by suitable manipulation of conduction electrons...|$|E
40|$|AbstractWe {{develop a}} “complete” {{embedding}} of logic programming into scheme—a lexically scoped lisp dialect with first-class continuations. Logic variables are bound {{in the scheme}} environment, and the success and failure continuations are represented as scheme continuations. To account for the semantics of logic variables and failure continuations, the state-space model of control is modified in a novel way that generalizes the trail mechanism. This ensures that <b>logic</b> <b>variable</b> bindings are properly restored when continuations are invoked to perform “lateral” control transfers that are not possible in a traditional logic programming context. It is thereby possible to obtain greater control flexibility while allowing much of a program to be expressed with logic programming...|$|E
40|$|This article {{proposes a}} completion-detection method for {{efficiently}} implementing Boolean functions as self-timed logic structures. Current-Sensing Completion Detection, CSCD, allows self-timed circuits {{to be designed}} using single-rail variable encoding (one signal wire per <b>logic</b> <b>variable)</b> and implemented in about the same silicon area as an equivalent synchronous implementation. Compared to dual-rail encoding methods, CSCD can {{reduce the number of}} signal wires and transistors used by approximately 50 %. CSCD implementations improved performance over equivalent dual-rail designs because of: (1) reduced parasitic capacitance, (2) removal of spacer tokens in the data stream, and (3) computation state similarity of consecutive data variables. Several CSCD configurations are described and evaluated and transistor-level implementations are provided for comparison...|$|E
40|$|Much {{attention}} has been focused by the declarative languages community on combining the functional and logic programming paradigms. In particular, there are many efforts to incorporate <b>logic</b> <b>variables</b> into functional languages. We propose a generalization of <b>logic</b> <b>variables</b> called accumulators which are eminently suited for incorporation into functional languages. We demonstrate the utility of accumulators by presenting examples which show that accumulators can be used profitably in many scientific applications to enhance storage efficiency and parallelism...|$|R
40|$|Introduction We {{propose a}} {{conservative}} extension of Oz that adds futures and by-need synchronization. Futures are read-only views of <b>logic</b> <b>variables</b> {{that make it}} possible to statically limit the scope in which a variable can be constrained. For instance, one can express with futures safe streams that cannot be assigned by their readers. By-need synchronization makes it possible to synchronize a thread on the event that a thread blocks on a future. It is used to express dynamic linking and lazy functions. We also introduce variable assignment and distinguish between simple and complex variables. The idea is that programs should distinguish between the use of <b>logic</b> <b>variables</b> for concurrency and the use of <b>logic</b> <b>variables</b> for constraint programming. Variable assignment is an asymmetric operation that eliminates a simple variable by binding it to a given unit. SB's version of Mozart will provide for the distribution of ports, futures, and simple variables. All other stateful units cann...|$|R
40|$|Error {{explanation}} [GV 03, GCKS 06] is {{a formal}} approach to automate diagnosis of software programs {{with the aid}} of a Satisfiability (SAT) -based model checker. Firstly, the semantics of the program is modeled as a Finite State Machine (FSM) and is encoded into an instance of the SAT problem [CKL 04]. Given a specification expressed in a formal logic which does not hold on the FSM, error explanation utilizes the model checker to produce a pair of similar failing and successful execution traces and highlights the differences of the execution traces as a possible explanation of the error. Thus, an explanation corresponds to a set of locations of the program source. More precisely, in SAT-based model checking execution traces correspond to assignments of <b>logic</b> <b>variables</b> in the SAT instance. The <b>logic</b> <b>variables</b> are used to capture the possible valuations of the program variables. The domains of the <b>logic</b> <b>variables</b> depend on the logic in use. Similarity of execution traces can then be expressed leveraging a distance metric which counts the number of values for which the two execution traces are different. Suppose (A, B) is a pair of a failing and a successful execution trace which correspond to the sequences a = (a 1, [...] ., an) and b = (b 1, [...] ., bn) of <b>logic</b> <b>variables,</b> respectively. The distance metric is then defined as ∑ n i= 1 (1 − δaibi...|$|R
40|$|In this paper, {{we present}} a new {{coordination}} model and a small set of programming notations for distributed programming that can be integrated in very different programming languages (imperative, declarative or object oriented). Both together, allow the development of distributed programs in a compositional way, by assembling different independent pieces of (possibly preexisting and heterogeneous) code. This approach is {{in the spirit of}} many other similar proposals as Linda, PCN, CC++, etc., but it allows multiparadigm and multilingual integration and provides a powerful set of concurrent programming techniques, inherited from Concurrent Logic Languages (CLLs), that can be efficiently implemented in distributed systems. The coordination model is based on Logic Channels; these are an evolution of the concept of shared <b>logic</b> <b>variable</b> used in CLLs that, with the same expressive power, can be more efficiently implemented in distributed systems. 1...|$|E
40|$|The {{problem of}} {{partitioning}} grid-based applications for parallel computing can be efficiently and intuitively solved in pure Prolog, using only the single assignment {{property of the}} <b>logic</b> <b>variable,</b> and not the backtracking. We show that these pure Prolog solutions can be transformed in a systematic way into cyclic functional programs. These functional programs can be executed more rapidly than the original Prolog programs. 1 Introduction Many processes in nature are modelled by partial differential equations. Examples of such processes are the weather, the tides, fluid currents in general, stress analysis of large constructions, electronics, acoustics, optics etc. In a recent book on solving partial differential equations on parallel computers case studies are presented concerning wave propagation, petrol engineering, aerodynamics, discrete simulation, elasticity and quantum mechanics [19]. Solving sparse symmetric linear systems that arise from discretization of elliptic partial diff [...] ...|$|E
40|$|Abstract. Guarded Definite Clauses is {{a simple}} {{programming}} language which originated from attempts to introduce concurrency into the logic programming paradigm. Moded GDC introduces a new syntax for GDC which ensures all programs are well-moded and makes the moding visually apparent. A well-moded GDC program is one where a <b>logic</b> <b>variable</b> {{can be considered a}} channel with a direction of data flow, ensuring variables are guaranteed a single writer but may have multiple readers. We introduce a type system which guarantees that some variables are linear (single reader as well as single writer), allowing the polarity of data flow to be reversible and thus giving easy process interaction. We then show how certain patterns of communication can be viewed as higher-order functions, and introduce syntactic sugar which enable moded GDC programs to be written in a style which resembles conventional functional programming. Guarded Definite Clause...|$|E
40|$|Unification of <b>logic</b> <b>variables</b> {{instantly}} connects {{present and}} future observations of their value, independently of their location in the data areas of the runtime system. The paper extends this property to "interclausal logic variables", an easy to implement Prolog extension that supports instant global information exchanges without dynamic database updates. We illustrate their usefulness with two of algorithms, graph coloring and minimum spanning tree. Implementations of interclausal variables as source-level transformations and as abstract machine adaptations are given. To address the need for globally visible chained transitions of <b>logic</b> <b>variables</b> we describe a DCG-based program transformation that extends the functionality of interclausal variables. Comment: to appear as a ICLP' 14 technical contributio...|$|R
40|$|Core logic {{programming}} concepts (Prolog-like) <b>Logic</b> <b>variables</b> (arrays and maps are terms) Implicit pattern-matching and explicit unification Explicit non-determinism Language constructs for scripting Functions, loops, and list comprehension Modeling and solving CP, SAT, and MIP for constraint solving Tabling for dynamic programming and plannin...|$|R
40|$|Abstract. KiCS 2 is a {{new system}} to compile {{functional}} logic programs of the source language Curry into purely functional Haskell programs. The implementation {{is based on the}} idea to represent the search space as a data structure and <b>logic</b> <b>variables</b> as operations that generate their values. This has the advantage that one can apply various, and in particular, complete search strategies to compute solutions. However, the generation of all values for <b>logic</b> <b>variables</b> might be inefficient for applications that exploit constraints on partially known values. To overcome this drawback, we propose new techniques to implement equational constraints in this framework. In particular, we show how unification modulo function evaluation and functional patterns can be added without sacrificing the efficiency of the kernel implementation. ...|$|R
40|$|Abstract. Logic Programming {{languages}} and combinational circuit synthesis tools {{share a common}} “combinatorial search over logic formulae” background. This paper attempts to reconnect the two fields with {{a fresh look at}} Prolog encodings for the combinatorial objects involved in circuit synthesis. While benefiting from Prolog’s fast unification algorithm and built-in backtracking mechanism, efficiency of our search algorithm is ensured by using parallel bitstring operations together with <b>logic</b> <b>variable</b> equality propagation, as a mapping mechanism from primary inputs to the leaves of candidate Leaf-DAGs implementing a combinational circuit specification. After an exhaustive expressiveness comparison of various minimal libraries, a surprising first-runner, Strict Boolean Inequality “< ” together with constant function “ 1 ” also turns out to have small transistor-count implementations, competitive to NAND-only or NORonly libraries. As a practical outcome, a more realistic circuit synthesizer is implemented that combines rewriting-based simplification of (<, 1) circuits with exhaustive Leaf-DAG circuit search...|$|E
40|$|This article {{introduces}} a concurrent object oriented language whose underlying operational semantics {{is based on}} the <b>logic</b> <b>variable.</b> The language is designed in reponse to Kahn's criticisms [Kahn 89] of previous attempts to build concurrent object-oriented languages on top of concurrent logic languages. We believe Aldwych is a language which removes the verbosity of concurrent logic language code, without removing the power for abstract concurrent programming. Introduction The Japanese Fifth Generation Project is often considered a failure. Having been launched with ambitious goals of producing intelligent systems, its spokespeople consider its most important product to be a programming language, KL 1 [Sh & Wa 93]. In fact KL 1 is just one example of a family of languages [Shap 89] which originated from attempts to introduce parallelism to the logic programming paradigm, but whose main characteristics stem from pragmatic decisions made in order to map a language with a Prolog-like [...] ...|$|E
40|$|Abstract—This paper {{presents}} a new method {{for the implementation}} of a direct rotor flux control (DRFOC) of induction motor (IM) drives. It is based on the rotor flux components regulation. The d and q axis rotor flux components feed proportional integral (PI) controllers. The outputs of which are the target stator voltages (vdsref and vqsref). While, the synchronous speed is depicted at the output of rotor speed controller. In order to accomplish variable speed operation, conventional PI like controller is commonly used. These controllers provide limited good performances over a wide range of operations even under ideal field oriented conditions. An alternate approach is to use the so called fuzzy logic controller. The overall investigated system is implemented using dSpace system based on digital signal processor (DSP). Simulation and experimental results have been presented for a one kw IM drives to confirm the validity of the proposed algorithms. Keywords—DRFOC, fuzzy <b>logic,</b> <b>variable</b> speed drives, control, IM and real time. I I...|$|E
40|$|Liegt nicht vor. The {{thesis is}} written in German, but will be {{translated}} soon. English title: Functional Computation in a Uniformly Concurrent Calculus with <b>Logic</b> <b>Variables.</b> We present the delta-calculus, a model of uniformly concurrent computation. It integrates eager and lazy functional computation and describes the intended complexity behavior in both cases. We call concurrent computation uniformly concurrent, if result, termination and complexity are independent from the computation order. We establish theses properties for the delta-calculus by proving its uniform confluence. The delta-calculus extends to models of concurrent computation providing for consumable resources and indeterminism. Such are the gamma-calculus, a foundation of concurrent computation with constraints, and the pi-calculus, a successor of CCS based on channel communication. The delta-calculus is a relational calculus with procedural abstraction and application. It provides for communication over <b>logic</b> <b>variables</b> and for suspension on their instantiation. Both mechanisms come naturally with parallel composition and declaration. We embed the eager and the lazy lamda-calculus into the delta-calculus. Using explicit references we guarantee that functional arguments are evaluated at most once. Explicit references are a special form of <b>logic</b> <b>variables.</b> These are needed too for representing lazy functional control. We prove {{the adequacy of the}} embedding of the eager lamda-calculus with respect to termination and complexity. We conjecture that the embedding of the lazy lamda preserves termination and improves complexity...|$|R
2500|$|Combinatory logic – A {{notation}} for mathematical <b>logic</b> without <b>variables</b> ...|$|R
5000|$|Combinatory logic - A {{notation}} for mathematical <b>logic</b> without <b>variables</b> ...|$|R
