8836|5252|Public
5|$|Despite the {{difficulties}} with {{public perception of}} AI in the late 70s, new ideas were explored in <b>logic</b> <b>programming,</b> commonsense reasoning and many other areas.|$|E
5|$|Python is a multi-paradigm {{programming}} language: {{object-oriented programming}} and structured programming are fully supported, and many language features support functional programming and aspect-oriented programming (including by metaprogramming and metaobjects (magic methods)). Many other paradigms are supported via extensions, including design by contract and <b>logic</b> <b>programming.</b>|$|E
5|$|In 1963, J. Alan Robinson had {{discovered}} a simple method to implement deduction on computers, the resolution and unification algorithm. However, straightforward implementations, like those attempted by McCarthy and his students in the late 60s, were especially intractable: the programs required astronomical numbers of steps to prove simple theorems. A more fruitful approach to logic {{was developed in the}} 1970s by Robert Kowalski at the University of Edinburgh, and soon this led to the collaboration with French researchers Alain Colmerauer and Philippe Roussel who created the successful <b>logic</b> <b>programming</b> language Prolog.|$|E
40|$|Abstract. Nested <b>logic</b> <b>programs</b> and epistemic <b>logic</b> <b>programs</b> are two {{important}} extensions of answer set programming. However, {{the relationship between}} these two formalisms is rarely explored. In this paper we first introduce the epistemic HT-logic, and then propose a more general extension of <b>logic</b> <b>programs</b> called nested epistemic <b>logic</b> <b>programs.</b> The semantics of this extension- named equilibrium views- is defined {{on the basis of the}} epistemic HT-logic. We prove that equilibrium view semantics extends both the answer sets of nested <b>logic</b> <b>programs</b> and the world views of epistemic <b>logic</b> <b>programs.</b> Therefore, our work establishes a unifying framework for both nested <b>logic</b> <b>programs</b> and epistemic <b>logic</b> <b>programs.</b> Furthermore, we also provide a characterization of the strong equivalence of two nested epistemic <b>logic</b> <b>programs.</b> ...|$|R
40|$|We {{introduce}} {{the class of}} possibilistic nested <b>logic</b> <b>programs.</b> These possibilistic <b>logic</b> <b>programs</b> allow us to use nested expressions in the bodies and the heads of their rules. By considering a possibilistic nested <b>logic</b> <b>program</b> as a possibilistic theory, a construction of a possibilistic logic programing semantics based on answer sets for nested <b>logic</b> <b>programs</b> and the proof theory of possibilistic logic is defined. We show that this new semantics for possibilistic <b>logic</b> <b>programs</b> is computable by means of transforming possibilistic nested <b>logic</b> <b>programs</b> into possibilistic disjunctive <b>logic</b> <b>programs.</b> The expressiveness of the possibilistic nested <b>logic</b> <b>programs</b> is illustrated by scenarios from the medical domain. In particular, we exemplify how possibilistic nested <b>logic</b> <b>programs</b> are expressive enough for capturing medical guidelines which are pervaded of vagueness and qualitative information...|$|R
40|$|<b>Logic</b> <b>programs</b> with {{abstract}} constraint atoms {{proposed by}} Marek and Truszczynski are very general <b>logic</b> <b>programs.</b> They are general enough to capture aggregate <b>logic</b> <b>programs</b> {{as well as}} recently proposed description <b>logic</b> <b>programs.</b> In this paper, we propose a well-founded semantics for basic <b>logic</b> <b>programs</b> with arbitrary abstract constraint atoms, which are sets of rules whose heads have exactly one atom. We show that similar to the well-founded semantics of normal <b>logic</b> <b>programs,</b> it has many desirable properties such as {{that it can be}} computed in polynomial time, and is always correct with respect to the answer set semantics. This paves the way for using our well-founded semantics to simplify these <b>logic</b> <b>programs.</b> We also show how our semantics can be applied to aggregate <b>logic</b> <b>programs</b> and description <b>logic</b> <b>programs,</b> and compare it to the well-founded semantics already proposed for these <b>logic</b> <b>programs.</b> Copyright © 2012, Association for the Advancement of Artificial Intelligence. All rights reserved...|$|R
25|$|Concurrent {{constraint}} <b>logic</b> <b>programming</b> combines concurrent <b>logic</b> <b>programming</b> and constraint <b>logic</b> <b>programming,</b> using constraints {{to control}} concurrency. A clause can contain a guard, {{which is a}} set of constraints that may block the applicability of the clause. When the guards of several clauses are satisfied, concurrent constraint <b>logic</b> <b>programming</b> makes a committed choice to the use of only one.|$|E
25|$|The Association for <b>Logic</b> <b>Programming</b> {{was founded}} to promote <b>Logic</b> <b>Programming</b> in 1986.|$|E
25|$|Inductive <b>logic</b> <b>programming</b> is {{concerned}} with generalizing positive and negative examples {{in the context of}} background knowledge: machine learning of logic programs. Recent work in this area, combining <b>logic</b> <b>programming,</b> learning and probability, has given rise to the new field of statistical relational learning and probabilistic inductive <b>logic</b> <b>programming.</b>|$|E
40|$|We present several {{representation}} theorems for <b>logic</b> <b>programs</b> {{in terms}} of formal grammatical formulation. First, for a given <b>logic</b> <b>program</b> $ P $ {{the notion of the}} success language of $ P $ is introduced, and based on this language theoretic characterization of a <b>logic</b> <b>program</b> several types of representation theorems for <b>logic</b> <b>programs</b> are provided. Main results include that there effectively exists a fixed <b>logic</b> <b>program</b> with the property that for any <b>logic</b> <b>program</b> one can find an equivalent <b>logic</b> <b>program</b> such that it can be expressed as a con junctive formula of a simple program and the fixed program. Further, by introducing the concept of an extended reverse predicate, it is shown that for any <b>logic</b> <b>program</b> there effectivily exists an equivalent <b>logic</b> <b>program</b> which can be expressed as a conjunctive formula consisting of only extended reverse programs and append programs...|$|R
40|$|AbstractThis paper {{surveys and}} compares {{different}} techniques investigated {{in order to}} integrate negation in rule-based query languages. In the context of deductive databases, a rule-based query is a <b>logic</b> <b>program.</b> The survey focuses {{on the problem of}} defining the declarative semantics of <b>logic</b> <b>programs</b> with negation. The declarative semantics of <b>logic</b> <b>programs</b> with negation based on fixpoint techniques, based on three valued logic and based on non-monotonic logics are presented for positive <b>logic</b> <b>programs,</b> (locally) stratifiable <b>logic</b> <b>programs</b> and unstratifiable <b>logic</b> <b>programs.</b> The expressive power of rule-based query languages is examined...|$|R
40|$|Abstract. In {{very recent}} work, we {{introduced}} a non-termination preserving transformation from <b>logic</b> <b>programs</b> with cut to definite <b>logic</b> <b>programs.</b> While that approach {{allows us to}} prove termination of a large class of <b>logic</b> <b>programs</b> with cut automatically, in several cases the transformation results in a non-terminating definite <b>logic</b> <b>program.</b> In this paper we extend the transformation such that <b>logic</b> <b>programs</b> with cut are no longer transformed into definite <b>logic</b> <b>programs,</b> but into dependency triple problems. By the implementation of our new method and extensive experiments, we empirically evaluate the practical benefit of our contributions. ...|$|R
25|$|Concurrent <b>logic</b> <b>programming</b> {{integrates}} {{concepts of}} <b>logic</b> <b>programming</b> with concurrent programming. Its development {{was given a}} big impetus in the 1980s by its choice for the systems programming language of the Japanese Fifth Generation Project (FGCS).|$|E
25|$|Constraint <b>logic</b> <b>programming</b> {{has been}} used to solve {{problems}} in such fields as civil engineering, mechanical engineering, digital circuit verification, automated timetabling, air traffic control, and finance. It is closely related to abductive <b>logic</b> <b>programming.</b>|$|E
25|$|Answer set programming. A fully {{declarative}} {{approach to}} <b>logic</b> <b>programming.</b>|$|E
40|$|Nested <b>logic</b> <b>programs</b> and epistemic <b>logic</b> <b>programs</b> are two {{important}} extensions of answer set programming. However, {{the relationship between}} these two formalisms is rarely explored. In this paper we first introduce the epistemic HT-logic, and then propose a more general extension of <b>logic</b> <b>programs</b> called {/em nested epistemic logic programs}. The semantics of this extension - named equilibrium views - is defined {{on the basis of the}} epistemic HT-logic. We prove that equilibrium view semantics extends both the answer sets of nested <b>logic</b> <b>programs</b> and the world views of epistemic <b>logic</b> <b>programs.</b> Therefore, our work establishes a unifying framework for both nested <b>logic</b> <b>programs</b> and epistemic <b>logic</b> <b>programs.</b> Furthermore, we also provide a characterization of the strong equivalence of two nested epistemic <b>logic</b> <b>programs.</b> Griffith Sciences, School of Information and Communication TechnologyNo Full Tex...|$|R
40|$|AbstractIn this paper, {{we propose}} a three-valued {{completion}} semantics for abductive <b>logic</b> <b>programs,</b> which solves some {{problems associated with}} the Console et al. two-valued completion semantics. The semantics is a generalization of Kunen's completion semantics for general <b>logic</b> <b>programs,</b> which is known to correspond very well to a class of effective proof procedures for general <b>logic</b> <b>programs.</b> Secondly, we propose a proof procedure for abductive <b>logic</b> <b>programs,</b> which is a generalization of a proof procedure for general <b>logic</b> <b>programs</b> based on constructive negation. This proof procedure is sound and complete with respect to the proposed semantics. By generalizing a number of results on general <b>logic</b> <b>programs</b> to the class of abductive <b>logic</b> <b>programs,</b> we present further evidence for the idea that limited forms of abduction can be added quite naturally to general <b>logic</b> <b>programs...</b>|$|R
40|$|The FLP {{semantics}} {{presented by}} (Faber, Leone, and Pfeifer 2004) {{has been widely}} used to define answer sets, called FLP answer sets, for different types of <b>logic</b> <b>programs</b> such as <b>logic</b> <b>programs</b> with aggregates, description <b>logic</b> <b>programs</b> (dl-programs), Hex <b>programs,</b> and <b>logic</b> <b>programs</b> with first-order formulas (general <b>logic</b> <b>programs).</b> However, it was recently observed that the FLP semantics may produce unintuitive answer sets with circular justifications caused by self-supporting loops. In this paper, we address the circular justification problem for general <b>logic</b> <b>programs</b> by enhancing the FLP semantics with a level mapping formalism. In particular, we extend the Gelfond-Lifschitz three step definition of the standard answer set semantics from normal <b>logic</b> <b>programs</b> to general <b>logic</b> <b>programs</b> and define for general <b>logic</b> <b>programs</b> the first FLP semantics that is free of circular justifications. We call this FLP semantics the well-justified FLP semantics. This method naturally extends to general <b>logic</b> <b>programs</b> with additional constraints like aggregates, thus providing a unifying framework for defining the well-justified FLP semantics for various types of <b>logic</b> <b>programs.</b> When this method is applied to normal <b>logic</b> <b>programs</b> with aggregates, the well-justified FLP semantics agrees with the conditional satisfaction based semantics defined by (Son, Pontelli, and Tu 2007); and when applied to dlprograms, the semantics agrees with the strongly wellsupported semantics defined by (Shen 2011) ...|$|R
25|$|F-logic extends <b>logic</b> <b>programming</b> {{with objects}} and the frame syntax.|$|E
25|$|Arguably, {{concurrent}} <b>logic</b> <b>programming</b> {{is based}} on message passing and consequently {{is subject to the}} same indeterminacy as other concurrent message-passing systems, such as Actors (see Indeterminacy in concurrent computation). Carl Hewitt has argued that, concurrent <b>logic</b> <b>programming</b> is not based on logic in his sense that computational steps cannot be logically deduced. However, in concurrent <b>logic</b> <b>programming,</b> any result of a terminating computation is a logical consequence of the program, and any partial result of a partial computation is a logical consequence of the program and the residual goal (process network). Consequently, the indeterminacy of computations implies that not all logical consequences of the program can be deduced.|$|E
25|$|Prolog is a {{general-purpose}} <b>logic</b> <b>programming</b> language {{associated with}} artificial intelligence and computational linguistics.|$|E
40|$|Attribute grammars and <b>logic</b> <b>programs</b> are two well {{investigated}} formalisms, {{which were}} related in [DM 85] for the restricted class of simple <b>logic</b> <b>programs.</b> In this paper we define the more restricted class of very simple <b>logic</b> <b>programs</b> and we {{prove that the}} problem of deciding, whether a given <b>logic</b> <b>program</b> is (very) simple, is NP [...] complete...|$|R
40|$|Abstract. We {{consider}} {{the problem of}} transformations of <b>logic</b> <b>programs</b> without function symbols (database <b>logic</b> <b>programs)</b> into a special subclass, namely linear <b>logic</b> <b>programs.</b> Linear <b>logic</b> <b>programs</b> are dened to be the programs whose rules have at most one intentional atom in their bodies. a) We investigate linearizability of several syntactically de ned subclasses of programs and present {{both positive and negative}} results (i. e. demonstrate programs that cannot be transformed into a linear program by any transformation technique), and b) We develop an algorithm which transforms any program in a speci c subclass namely the piecewise <b>logic</b> <b>programs</b> into a linear <b>logic</b> <b>program...</b>|$|R
40|$|This paper {{focuses on}} the {{expressive}} power of disjunctive and normal <b>logic</b> <b>programs</b> under the stable model semantics over finite, infinite, or arbitrary structures. A translation from disjunctive <b>logic</b> <b>programs</b> into normal <b>logic</b> <b>programs</b> is proposed and then proved to be sound over infinite structures. The equivalence of expressive power of two kinds of <b>logic</b> <b>programs</b> over arbitrary structures is shown to coincide with that over finite structures, and coincide with whether or not NP is closed under complement. Over finite structures, the intranslatability from disjunctive <b>logic</b> <b>programs</b> to normal <b>logic</b> <b>programs</b> is also proved if arities of auxiliary predicates and functions are bounded in a certain way...|$|R
25|$|For some {{alternate}} {{conceptions of}} what constitutes an algorithm see functional programming and <b>logic</b> <b>programming.</b>|$|E
25|$|Subsequent {{extensions}} of Prolog {{by the original}} team introduced constraint <b>logic</b> <b>programming</b> abilities into the implementations.|$|E
25|$|The Gödel {{language}} is a strongly typed implementation of concurrent constraint <b>logic</b> <b>programming.</b> It is built on SICStus Prolog.|$|E
40|$|Based on {{our earlier}} work on partial logics and {{extended}} <b>logic</b> <b>programs</b> [Wag 91, Wag 94, HJW 96], {{and on the}} possibilistic logic of [DLP 94], we define a compositional possibilistic first-order logic with two kinds of negation as the logical basis of semi-possibilistic and possibilistic <b>logic</b> <b>programs.</b> We show that {{in the same way}} as the minimal model semantics of relational databases can be refined to the stable model semantics for normal <b>logic</b> <b>programs</b> (see [GL 88]), the minimal model semantics of fuzzy databases can be refined to the stable semantics for semi-possibilistic <b>logic</b> <b>programs.</b> We also show that while normal <b>logic</b> <b>programs</b> under the stable model semantics can be embedded in semipossibilistic <b>logic</b> <b>programs</b> under our stable semantics, extended <b>logic</b> <b>programs</b> under the answer set semantics of [GL 90] can be embedded in possibilistic <b>logic</b> <b>programs</b> under our stable semantics. 1 Introduction In this paper, we first define fuzzy and possibilistic Herbrand interpretat [...] ...|$|R
40|$|Based on {{our earlier}} work on partial logics and {{extended}} <b>logic</b> <b>programs</b> [Wag 91, Wag 94, HJW 97], {{and on the}} possibilistic logic of [DLP 94], we define a compositional possibilistic first-order logic with two kinds of negation as the logical basis of fuzzy and possibilistic <b>logic</b> <b>programs.</b> We show that {{in the same way}} as the minimal model semantics of relational databases can be refined to the stable model semantics for normal <b>logic</b> <b>programs</b> (see [GL 88]), the minimal model semantics of fuzzy databases can be refined to the stable semantics for fuzzy <b>logic</b> <b>programs.</b> We also show that normal <b>logic</b> <b>programs</b> under the stable model semantics of [GL 88] can be embedded in fuzzy <b>logic</b> <b>programs</b> under our stable semantics, and extended <b>logic</b> <b>programs</b> under the answer set semantics of [GL 90] can be embedded in possibilistic <b>logic</b> <b>programs</b> under our stable semantics. 1 Introduction In this paper, we first define fuzzy and possibilistic Herbrand interpretations as conservative extensions [...] ...|$|R
2500|$|For most {{practical}} applications, {{as well as}} for applications that require non-monotonic reasoning in artificial intelligence, Horn clause <b>logic</b> <b>programs</b> need to be extended to normal <b>logic</b> <b>programs,</b> with negative conditions. A clause in a normal <b>logic</b> <b>program</b> has the form: ...|$|R
25|$|In the 1950s and 1960s, {{researchers}} {{predicted that}} when human knowledge could be expressed using logic with mathematical notation, {{it would be}} possible to create a machine that reasons, or artificial intelligence. This was more difficult than expected because of the complexity of human reasoning. In <b>logic</b> <b>programming,</b> a program consists of a set of axioms and rules. <b>Logic</b> <b>programming</b> systems such as Prolog compute the consequences of the axioms and rules in order to answer a query.|$|E
25|$|Meld is a {{declarative}} language, a <b>logic</b> <b>programming</b> language {{originally designed}} for programming overlay networks. By using <b>logic</b> <b>programming,</b> the code for an ensemble of robots {{can be written}} from a global perspective, enabling the programmer {{to concentrate on the}} overall performance of the claytronics matrix rather than writing individual instructions for every one of the thousands to millions of catoms in the ensemble. This dramatically simplifies the thought process for programming the movement of a claytronics matrix.|$|E
25|$|In November 1999 {{the entire}} {{editorial}} board (50 persons) of the Journal of <b>Logic</b> <b>Programming</b> (founded in 1984 by Alan Robinson) collectively resigned after 16 months of unsuccessful negotiations with Elsevier Press {{about the price}} of library subscriptions. The personnel created a new journal, Theory and Practice of <b>Logic</b> <b>Programming,</b> with Cambridge University Press at a much lower price, while Elsevier continued publication with a new editorial board and a slightly different name (the Journal of Logic and Algebraic Programming).|$|E
40|$|We define courteous <b>logic</b> <b>programs,</b> {{a variant}} of {{extended}} <b>logic</b> <b>programs.</b> Courteous <b>logic</b> <b>programs</b> constitute a kind of prioritized default reasoning that is computationally tractable, fairly powerful expressively, and commercially applicable {{to the creation of}} rule-based intelligent information agents. Priorities are, in part, specified explicitly: within the locale of each predicate's "definition ", i. e., between rules mentioning the same predicate in their consequent. (Recall that extended <b>logic</b> <b>programs</b> represent classical negation as well as negation-as-failure. Hence a rule having consequent p may conflict with another rule having consequent :p.) In addition, priorities are, in part, specified implicitly: based on inferential dependency depth between the different predicate locales, as in the usual semantics for negation as failure in stratified <b>logic</b> <b>programs.</b> Syntactically, a courteous <b>logic</b> <b>program</b> is an extended <b>logic</b> <b>program</b> augmented with a prioritization sub-program. In th [...] ...|$|R
40|$|AbstractUnlike sets of {{definite}} Horn clauses, <b>logic</b> <b>programs</b> with disjunctions {{of atoms}} in clause heads are often interpreted {{in terms of}} minimal models. It is also well known that the minimal models of <b>logic</b> <b>programs</b> {{are closely related to}} the so-called stable models of <b>logic</b> <b>programs</b> with nonmonotonic negation in clause bodies, as well as to circumscription. Methods to compute minimal models of <b>logic</b> <b>programs</b> are becoming increasingly important as an intermediate step in the computation of structures associated with nonmonotonic <b>logic</b> <b>programs.</b> However, to date, all these techniques have been restricted to the case of propositional <b>logic</b> <b>programs</b> which means that an ordinary disjunctive <b>logic</b> <b>program</b> must be “grounded out” prior to computation. Grounding out in this manner leads to a combinatorial explosion in the number of clauses, and hence, is unacceptable. In this paper, we show how, given any method M which correctly computes the set of minimal models of a propositional <b>logic</b> <b>program,</b> we can develop a strategy to compute truth in a minimal model of a disjunctive <b>logic</b> <b>program</b> P. The novel feature of our method is that it works on an “instantiate-by-need” basis, and thus avoids unnecessary grounding...|$|R
40|$|In {{very recent}} work, we {{introduced}} a non-termination preserving transformation from logic pro-grams with cut to definite <b>logic</b> <b>programs.</b> In this paper we extend the transformation such that <b>logic</b> <b>programs</b> with cut are transformed into dependency triple problems instead of definite <b>logic</b> <b>programs.</b> By {{the implementation of}} our new method and extensive experiments, we show {{that the power of}} automated termination analysis for <b>logic</b> <b>programs</b> with cut is increased substantially. ...|$|R
