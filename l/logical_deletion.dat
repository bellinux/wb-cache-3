2|4|Public
40|$|This paper {{documents}} anti-forensics {{techniques of}} a secure messaging application named “Wickr” on the Android platforms. Advertised as an application that focusses on security, Wickr provides many anti-forensics features, such as ephemeral messaging and end-to-end encryption. This paper analyses Wickr in detail using experimental research methods. The results revealed how Wickr’s file deletion consisted of distinct stages {{beginning with a}} simple <b>logical</b> <b>deletion</b> and progressing to overwriting deleted files as the application operated...|$|E
40|$|Introduction Base tables {{supporting}} transaction {{time are}} ever-growing because all logical updates, including deletions, transform into insertions at the physical level. This contrasts snapshot tables where logical and physical deletion coincide. <b>Logical</b> <b>deletion</b> in TSQL 2 {{was covered in}} 16. As {{there is a need}} for physical deletion capabilities in snapshot tables (and valid-time tables), there is also a need for such capabilities in temporal tables supporting transaction time (i. e., transaction-time tables and bitemporal tables). This chapter is divided into two parts. In the first, the general notion of vacuuming and associated concepts are introduced and motivated. It is shown that straightforward physical deletion may adversely affect the usefulness of query results and that special attention thus should be devoted to the design of appropriate vacuuming facilities. We then give reasons why disciplined vacuuming is a highly desirable capability. Subsequently, the important c...|$|E
40|$|A {{wide range}} of {{real-world}} database applications, including financial and medical applications, are faced with accountability and trace-ability requirements. These requirements lead to {{the replacement of the}} usual update-in-place policy by an append-only policy, yielding so-called transaction-time databases. With <b>logical</b> <b>deletions</b> being implemented as insertions at the physical level, these databases retain all previously current states and are ever-growing. A variety of physical storage structures and indexing techniques as well as query languages have been proposed for transaction-time databases, but the support for physical deletion, termed vacuuming, has received precious little attention. Such vacuuming is called for by, e. g., the laws of many countries. Although necessary, with vacuuming, the database's previously perfect and reliable recollection of the past may be manipulated via, e. g., selective removal of records pertaining to past states. This paper provides a semantic frame [...] ...|$|R
40|$|Updates, {{including}} (<b>logical)</b> <b>deletions,</b> to temporal {{tables that}} support transaction time result in insertions at the physical level. Despite the continuing decrease in cost of data storage, it is still, for various reasons, not always acceptable that all data be retained forever. Therefore, {{there is a}} need for a new mechanism for the vacuuming, i. e., physical deletion, of data when such tables are being managed. We propose syntax and informal semantics for vacuuming of data from temporal tables in TSQL 2 which support transaction time. The mechanism allows—at schema definition time, as well as later, during the life span of a table—for the specification of so-called cut-off points. A cut-off point for a table is a timestamp that evaluates to a time instant. The timestamp may be either absolute or a bound or unbound now-relative timestamp. Conceptually, the cut-off point indicates that all data, current in the table solely before the (current value of the) timestamp, has been physically deleted. Vacuuming based on cut-off points is an example of a more general notion of vacuuming where arbitrary subsets of data may be physically deleted. ...|$|R
40|$|Many {{important}} database applications need {{to access}} previous {{versions of the}} data set, thus requiring that the data are stored in a multiversion database and indexed with a multiversion index, such as the multiversion B+-tree (MVBT) of Becker et al. The MVBT is optimal, so that any version of the database can be accessed as efficiently as with a single-version B+-tree {{that is used to}} index only the data items of that version, but it cannot be used in a full-fledged database system because it follows a single-update model, and the update cannot be rolled back. We have redesigned the MVBT index so that a single multi-action updating transaction can operate on the index structure concurrently with multiple concurrent read-only transactions. Data items created by the transaction become part of the same version, and the transaction can roll back. We call this structure the transactional MVBT (TMVBT). The TMVBT index remains optimal even in the presence of <b>logical</b> key <b>deletions.</b> Even though deletions in a multiversion index must not physically delete the history of the data items, queries and range scans can become more efficient, if the leaf pages of the index structure are merged to retain optimality. For the general transactional setting with multiple updating transactions, we propose a multiversion database structure called the concurrent MVBT (CMVBT), which stores the updates of active transactions in a separate main-memory-resident versioned B+-tree index. A system maintenance transaction is periodically run to apply the updates of committed transactions into the TMVBT index. We show how multiple updating transactions can operate on the CMVBT index concurrently, and our recovery algorithm is based on the standard ARIES recovery algorithm. We prove that the TMVBT index is asymptotically optimal, and show that the performance of the CMVBT index in general transaction processing is on par with the performance of the time-split B+-tree (TSB-tree) of Lomet and Salzberg. The TSB-tree does not merge leaf pages and is therefore not optimal if <b>logical</b> data-item <b>deletions</b> are allowed. Our experiments show that the CMVBT outperforms the TSB-tree with range queries in the presence of deletions...|$|R
40|$|We {{present a}} {{straightforward}} source-to-source transformation that introduces justifications for user-defined constraints into the CHR programming language. Then a scheme of two rules suffices {{to allow for}} <b>logical</b> retraction (<b>deletion,</b> removal) of constraints during computation. Without the need to recompute from scratch, these rules remove not only the constraint but also undo all consequences of the rule applications that involved the constraint. We prove a confluence result concerning the rule scheme and show its correctness. When algorithms are written in CHR, constraints represent both data and operations. CHR is already incremental by nature, i. e. constraints can be added at runtime. Logical retraction adds decrementality. Hence any algorithm written in CHR with justifications will become fully dynamic. Operations can be undone and data can be removed {{at any point in}} the computation without compromising the correctness of the result. We present two classical examples of dynamic algorithms, written in our prototype implementation of CHR with justifications that is available online: maintaining the minimum of a changing set of numbers and shortest paths in a graph whose edges change. Comment: Pre-proceedings paper presented at the 27 th International Symposium on Logic-Based Program Synthesis and Transformation (LOPSTR 2017), Namur, Belgium, 10 - 12 October 2017 (arXiv: 1708. 07854...|$|R

