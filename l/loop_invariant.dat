131|330|Public
25|$|A <b>loop</b> <b>invariant</b> is an {{assertion}} {{which must be}} true before the first loop iteration and remain true after each iteration. This implies that when a loop terminates correctly, both the exit condition and the <b>loop</b> <b>invariant</b> are satisfied. Loop invariants are used to monitor specific properties of a loop during successive iterations.|$|E
5000|$|The above example also {{illustrates}} {{the use of}} an inductive <b>loop</b> <b>invariant.</b> The <b>loop</b> <b>invariant</b> must be shown to hold on entry to the loop, for any given iteration of the loop and when the loop exits. In this case, the <b>loop</b> <b>invariant</b> states what is known about the elements of the [...] examined so far — namely, that none of them matches the given [...] The <b>loop</b> <b>invariant</b> does not affect the meaning of the program and, in some sense, might be considered as unnecessary. However, the <b>loop</b> <b>invariant</b> is required to help the automated verifier using in the Whiley Compiler to prove this function meets its specification.|$|E
5000|$|Strength {{reduction}} {{looks for}} expressions involving a <b>loop</b> <b>invariant</b> and an induction variable. Some of those expressions can be simplified. For example, the multiplication of <b>loop</b> <b>invariant</b> [...] and induction variable c = 7;for (i = 0; i < N; i++){ yi = c * i;} ...|$|E
5000|$|The Whiley {{programming}} language also provides first-class support for <b>loop</b> <b>invariants.</b> <b>Loop</b> <b>invariants</b> are expressed using {{one or more}} [...] clauses, as the following illustrates: ...|$|R
40|$|<b>Loop</b> <b>invariants</b> play {{a pivotal}} role in {{software}} verification. Since not all programs and the loops therein are annotated with their invariants, systems for automatically extracting <b>loop</b> <b>invariants</b> have been developed. In this paper, we will discuss the problem of finding <b>loop</b> <b>invariants</b> and the various methods that have been used for this problem. We will also propose potential avenues for future research in this area. ...|$|R
50|$|In formal program verification, {{particularly}} the Floyd-Hoare approach, <b>loop</b> <b>invariants</b> are expressed by formal predicate logic {{and used to}} prove properties of loops and by extension algorithms that employ loops (usually correctness properties).The <b>loop</b> <b>invariants</b> will be true on entry into a loop and following each iteration, so that on exit from the loop both the <b>loop</b> <b>invariants</b> and the <b>loop</b> termination condition can be guaranteed.|$|R
50|$|A <b>loop</b> <b>invariant</b> is an {{assertion}} {{which must be}} true before the first loop iteration and remain true after each iteration. This implies that when a loop terminates correctly, both the exit condition and the <b>loop</b> <b>invariant</b> are satisfied. Loop invariants are used to monitor specific properties of a loop during successive iterations.|$|E
5000|$|The Eiffel {{programming}} language provides native support for loop invariants. A <b>loop</b> <b>invariant</b> is expressed {{with the same}} syntax used for a class invariant. In the sample below, the <b>loop</b> <b>invariant</b> expression [...] must be true following the loop initialization, and after each execution of the loop body; this is checked at runtime.|$|E
50|$|Usually a {{reaching}} definitions {{analysis is}} used to detect whether a statement or expression is <b>loop</b> <b>invariant.</b>|$|E
40|$|<b>Loop</b> <b>invariants</b> play a {{major role}} in program {{verification}} and drastically speed up processes like automatic test case generation. Though various techniques have been applied to automatic <b>loop</b> <b>invariants</b> generation, most interesting ones often generate only candidate invariants. Thus, a key issue, to take advantage of these invariants in a verification process, is to check that these candidate <b>loop</b> <b>invariants</b> are actual invariants. This paper introduces an original technique based on constraint programming for automatic verification of inductive <b>loop</b> <b>invariants.</b> This new approach is efficient to detect spurious invariants and nicely performs verification of valid invariants under boundedness restrictions. First experiments on classical benchmarks are very promising...|$|R
30|$|A {{histogram}} of comparisons for <b>loop</b> <b>invariants</b> per method.|$|R
25|$|Loop {{variants}} and <b>loop</b> <b>invariants</b> {{are used}} to express correctness of loops.|$|R
50|$|In {{computer}} programming and programming language semantics, these {{are used in}} the form of assertions; one example is a <b>loop</b> <b>invariant.</b>|$|E
5000|$|The <b>loop</b> <b>invariant</b> {{plays an}} {{important}} role in the intuitive argument for soundness of the Floyd-Hoare rule for [...] loops. The <b>loop</b> <b>invariant</b> has to be true before each iteration of the loop body, and also after each iteration of the loop body. Since a [...] loop is precisely the repeated iteration of the loop body, it follows that if the invariant is true before entering the loop, it must also be true after exiting the loop.|$|E
5000|$|The {{condition}} C of the [...] loop is [...] A useful <b>loop</b> <b>invariant</b> I is [...] Under {{these assumptions}} {{it is possible}} to prove the following Hoare triple: ...|$|E
5000|$|We can {{alternately}} {{express the}} <b>loop</b> <b>invariants</b> using {{the order of}} the elements: ...|$|R
40|$|Abstract—Loop invariants play a {{major role}} in program {{verification}} and drastically speed up processes like automatic test case generation. Though various techniques have been applied to automatic <b>loop</b> <b>invariants</b> generation, most interesting ones often generate only candidate invariants. Thus, a key issue, to take advantage of these invariants in a verification process, is to check that these candidate <b>loop</b> <b>invariants</b> are actual invariants. This paper introduces an original technique based on constraint programming for automatic verification of inductive <b>loop</b> <b>invariants.</b> This new approach is efficient to detect spurious invariants and nicely performs verification of valid invariants under boundedness restrictions. First experiments on classical benchmarks are very promising. I...|$|R
40|$|We {{present a}} {{technique}} for refining incorrect or insufficiently strong <b>loop</b> <b>invariants</b> in correctness proofs for imperative programs. We rely on previous work [16] in combining program analysis and Proof Planning, and exploit IsaPlanner’s use of meta-variables and goal-naming to generate correct <b>loop</b> <b>invariants.</b> We present a simple example in detail and discuss how this might scale to more complex problems. ...|$|R
5000|$|The {{technique}} of abstract interpretation {{can be used}} to detect <b>loop</b> <b>invariant</b> of given code automatically. However, this approach is limited to very simple invariants (such as [...] ).|$|E
5000|$|Ignoring {{termination}} for a moment, we {{can define}} the rule for the weakest liberal precondition, denoted wlp, using a predicate I, called the <b>loop</b> <b>invariant,</b> typically {{supplied by the}} programmer: ...|$|E
50|$|Where the <b>loop</b> <b>invariant</b> of fib is that x1 is the (i+2-1)th and x2 is the (i+2)th Fibonacci number, where i is {{the number}} of times fib has been jumped to.|$|E
40|$|We {{describe}} a data-mining approach to creating central parts of <b>loop</b> <b>invariants.</b> The approach {{is based on}} producing a trace table by recording the values of program variables each time the condition of a loop is evaluated. From this trace table, functional dependencies between program variables can be extracted which may {{play a vital role}} in <b>loop</b> <b>invariants.</b> The extraction process is accomplished through the use of genetic programming which performs a symbolic regression on the data contained by the trace table. We illustrate our approach with examples. 1 Introduction A central difficulty encountered by formal methods for program verification is the availability of appropriate <b>loop</b> <b>invariants.</b> The necessity and nature of <b>loop</b> <b>invariants</b> is most clearly visible and understandable in connection with loop constructs as they occur in imperative programming languages. Verifying an (imperative) program P means showing that it is correct with respect to a given pre-condition Φ and [...] ...|$|R
5000|$|... <b>loop</b> <b>invariants.</b> These are {{the values}} that do not change within {{the body of a}} loop.|$|R
40|$|We {{present a}} {{framework}} for automating the discovery of <b>loop</b> <b>invariants</b> based upon failed proof attempts. The discovery of suitable <b>loop</b> <b>invariants</b> is a bottle neck for automatic verification of imperative programs. Using the proof planning framework we reconstruct standard heuristics for developing invariants. We relate these heuristics {{to the analysis of}} failed proof attempts allowing us to discover an invariant through a process of refinement...|$|R
5000|$|The [...] {{function}} {{determines the}} largest element in an integer array. For {{this to be}} defined, the array must contain at least one element. The postconditions of [...] require that the returned value is: (1) not smaller than any element; and, (2) that it matches at least one element. The <b>loop</b> <b>invariant</b> is defined inductively through two [...] clauses, each of which corresponds to a clause in the postcondition. The fundamental difference is that each clause of the <b>loop</b> <b>invariant</b> identifies the result as being correct up to the current element , whilst the postconditions identify the result as being correct for all elements.|$|E
50|$|Here P is the <b>loop</b> <b>invariant,</b> {{which is}} to be {{preserved}} by the loop body S.After the loop is finished, this invariant P still holds, and moreover ¬B must have caused the loop to end.As in the conditional rule, B must not have side effects.|$|E
50|$|Any more {{sophisticated}} invariants {{still have to}} be provided manually.In particular, when verifying an imperative program using the Hoare calculus, a <b>loop</b> <b>invariant</b> has to be provided manually for each loop in the program, {{which is one of the}} reasons for that task being extremely tedious.|$|E
5000|$|We {{can show}} that {{at the start of}} each {{iteration}} of the loop the following <b>loop</b> <b>invariants</b> hold: ...|$|R
40|$|Software {{verification}} is {{an important}} and difficult problem. Many static checking techniques for software require annotations from the programmer {{in the form of}} method specifications and <b>loop</b> <b>invariants.</b> This annotation overhead, particularly of <b>loop</b> <b>invariants,</b> is a significant hurdle in the acceptance of static checking. We reduce the annotation burden by inferring <b>loop</b> <b>invariants</b> automatically. Our method is based on predicate abstraction, an domain is constructed from a given set of predicates over program variables. A novel feature of our approach is that it infers universally-quantified <b>loop</b> <b>invariants,</b> which are crucial for verifying programs that manipulate unbounded data such as arrays. We present heuristics for generating appropriate predicates for each loop automatically; the programmer can specify additional predicates as well. We also present an efficient algorithm for computing the abstraction of a set of states in terms of a collection of predicates. Experiments on a 44 KLOC program show that our approach can automatically infer the necessary predicates and invariants for all but 31 of the 396 routines that contain loops. ...|$|R
5000|$|In addition, the {{language}} supports a [...] "check instruction" [...] (a kind of [...] "assert"), <b>loop</b> <b>invariants,</b> and <b>loop</b> variants (which guarantee loop termination).|$|R
50|$|In general, <b>loop</b> <b>invariant</b> {{dependencies}} and lexically forward dependencies can {{be easily}} vectorized, and lexically backward dependencies can be transformed into lexically forward dependencies. However, these transformations must be done safely, {{in order to ensure}} that the dependence between all statements remain true to the original.|$|E
50|$|In {{computer}} science, a <b>loop</b> <b>invariant</b> is {{a property}} {{of a program}} loop that is true before (and after) each iteration. It is a logical assertion, sometimes checked within the code by an assertion call. Knowing its invariant(s) is essential in understanding {{the effect of a}} loop.|$|E
5000|$|Given the <b>loop</b> <b>invariant</b> P, the {{condition}} B must imply that t {{is not a}} minimal element of D, for otherwise the body S could not decrease t any further, i.e. {{the premise of the}} rule would be false. (This is one of various notations for total correctness.) ...|$|E
40|$|We {{present a}} {{framework}} for automating the discovery of <b>loop</b> <b>invariants</b> based upon failed proof attempts. The discovery of suitable <b>loop</b> <b>invariants</b> represents a bottleneck for automatic verification of imperative programs. Using the proof planning framework we reconstruct standard heuristics for developing invariants. We relate these heuristics {{to the analysis of}} failed proof attempts allowing us to discover invariants through a process of refinement. 1 Introduction <b>Loop</b> <b>invariants</b> are a well understood technique for specifying the behaviour of programs involving loops. The discovery of suitable invariants, however, is a major bottleneck for automatic verification of imperative programs. Early research in this area [18, 24] exploited both theorem proving techniques as well as domain specific heuristics. However, the potential for interaction between these components was not fully exploited. The proof planning framework, in which we reconstruct the standard heuristics, couples [...] ...|$|R
40|$|A general {{framework}} is presented for automating {{the discovery of}} <b>loop</b> <b>invariants</b> for imperative programs. Theoretical results about the correctness and completeness of the proposed method are given. More importantly, it is shown how this abstract approach {{can be used to}} automatically infer polynomial invariants. The method has been implemented in Maple. Evidence of its practical interest is shown by means of several non-trivial examples, for which the polynomial <b>loop</b> <b>invariants</b> generated are directly applicable for proving correctness by means of a simple verifier. Postprint (published version...|$|R
50|$|For 3., some tools {{exist to}} support {{mathematical}} proofs, usually {{based on the}} above-shown Floyd-Hoare rule, that a given loop code in fact satisfies a given (set of) <b>loop</b> <b>invariant(s).</b>|$|R
