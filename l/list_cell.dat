4|198|Public
5000|$|The {{principle}} that the cdr in a <b>list</b> <b>cell</b> must point at another list is just a convention. If both car and cdr point at atoms, that will yield a pair, usually written like [...] "(1 [...] 2)" ...|$|E
40|$|A {{real-time}} {{list processing}} system {{is one in}} which the time required by the elementary list operations (e. g. CONS, CAR, COR, RPLACA, RPLACD, EQ, and ATOM in LISP) is bounded by a (small) constant. Classical implementations of list processing systems lack this property because allocating a <b>list</b> <b>cell</b> from the heap may cause a garbage collection, which process requires time proportional to the heap size to finish. A real-time list processing system is presented which continuously reclaims garbage, including directed cycles, while linearizing and compacting the accessible cells into contiguous locations to avoid fragmenting the free storage pool. The program is small and requires no time-sharing interrupts, making it suitable for microcode. Finally, the system requires the same average time, and not more than twice the space, of a classical implementation, and those space requirements can be reduced to approximately classical proportions by compact list representation. Arrays of different sizes, a program stack, and hash linking are simple extensions to our system, and reference counting is found to be inferior for many applications. Key Words and Phrases: real-time, compacting, garbage collection, list processing, virtual memory, file or database management, storage management, storag...|$|E
40|$|Deforestation optimises a {{functional}} program by transforming it into {{another one that}} does not create certain intermediate data structures. In [Chi 99] we presented a type-inference based deforestation algorithm which performs extensive inlining. However, across module boundaries only limited inlining is practically feasible. Furthermore, inlining is a non-trivial transformation which is therefore best implemented as a separate optimisation pass. To perform short cut deforestation (nearly) without inlining, Gill suggested to split definitions into workers and wrappers and inline only the small wrappers, which transfer the information needed for deforestation. We show that Gill’s use of a function build limits deforestation and note that his reasons for using build do not apply to our approach. Hence we develop a more general worker/wrapper scheme without build. We give a type-inference based algorithm which splits definitions into workers and wrappers. Finally, we show that we can deforest more expressions with the worker/wrapper scheme than the algorithm with inlining. 1 Type-Inference-Based Short Cut Deforestation In lazy functional programs two functions are often glued together by an intermediate data structure that is produced by one function and consumed by the other. For example, the function any, which tests whether any element of a list xs satisfies a given predicate p, may be defined as follows in Haskell [PH + 99]: any p xs = or (map p xs) The function map applies p to all elements of xs yielding a list of boolean values. The function or combines these boolean values with the logical or operation (||). Although lazy evaluation makes this modular programming style practicable [Hug 89], it does not come for free. Each <b>list</b> <b>cell</b> has to be allocated, filled, taken apart and finally garbage collected. The following monolithic definition of any is more efficient. any p [] = False any p (x:xs) = p x | | any p xs It is the aim of deforestation algorithms to automatically transform {{a functional}} program into another {{one that does not}} create such intermediate data structures. We say that the producer and the consumer of the data structure are fused...|$|E
25|$|Checkbox, slider, and {{pulldown}} <b>list</b> <b>cells.</b>|$|R
5000|$|... #Caption: A <b>list</b> of <b>cell</b> {{broadcast}} messages (cell IDs) {{received on}} an Android smartphone.|$|R
40|$|In future, more {{devices such}} as {{wearable}} devices will {{be connected to the}} networks. This will increase simultaneous handovers. The coverage of a cell will be small because a superhigh frequency used in 5 G wireless networks does not propagate very far. This trend will increase the number of neighbour <b>cell</b> <b>lists</b> and it will accelerate the change of neighbour <b>cell</b> <b>lists</b> since the coverage of cells can be altered by the environment. Meanwhile, the ANR technology will be essential in 5 G networks. Since the network environment in the future is not similar to the present, the strategy of ANR should also be different from the present. First, since practical neighbour <b>cell</b> <b>lists</b> in each <b>cell</b> are changed frequently and individually, it is necessary to optimize them frequently and individually. Second, since the neighbour <b>cell</b> <b>lists</b> in each <b>cell</b> are not changed similarly, it is necessary to operate ANR flexibly. To respond to these issues, we propose to use network function virtualization (NFV) for ANR. To evaluate the proposed strategies, we measured additional resource consumption and the latency of handover if neighbour <b>cell</b> <b>lists</b> are not optimized when UEs perform handover simultaneously. These experiments are conducted using Amarisoft LTE- 100 Platform...|$|R
40|$|Cell {{division}} {{is one of}} the most fundamental processes of life whereby one cell replicates itself to produce two. The molecular machinery that drives and regulates this fundamental process has been much studied but much remains unknown. This work describes the use of transcriptomics analyses to identify putative new proteins involved with this process and subsequent attempts to prove their association with this pathway. Using the latest array technology, in Chapter 2 I describe studies that examine the expression of genes regulated during different stages of the human cell cycle. Synchronous populations of neonatal human dermal fibroblasts (NHDFs) were generated by serum starvation and analysed in two separate microarray experiments. For the first set array experiments, samples were taken every 6 hours for 48 hours after serum refeeding, and every 2 hours for 24 hours for the second experiment. Using BioLayout Express 3 D, network structure analyses identified four major clusters of gene expression patterns associated with different stages of the cell cycle: G 0 -, early G 1 -, late G 1 -, and S/G 2 /M-phase. By comparison with datasets of other human cells and tissues, the list of genes in the S/G 2 /M cluster was refined; genes were only kept in the list if they were found to be co-expressed in cells and tissues with high levels of cell proliferation. 706 genes that were co-expressed during S/G 2 /M-phase were selected for further analyses. Manual curation showed that 484 are known cell cycle-associated genes, 78 are genes with putative association to the cell cycle, and 75 have known roles in other biological processes, whilst 69 were entirely uncharacterised genes. In order to investigate the 69 genes with unknown function, in Chapter 3 I describe how RNAi was used to screen 42 of these genes to see if their knockdown resulted in an effect on cell proliferation. After extensive assay optimisation, endoribonuclease-prepared siRNA (esiRNA) was delivered to NHDF cells and the effect of knockdown determined using a real time cell analysis (RTCA) system. This system monitors the change in electrical resistance induced by growing cell populations defined as the cell impedance index (CI). Using a Z-scoring cut-off to determine the hits of the RNAi screening, according to the average value of cell impedance growth rate (CIGR i. e. a value from transformed CI), 19 of 42 genes were found to significantly affect the dynamics of cell proliferation, supporting a potential role in cell division. In order to verify that the unknown proteins localise to structures compatible with a role in the cell cycle, in Chapter 4 I describe protein localisation studies on 11 of 19 genes of ‘hits’ from Chapter 3 (we were unable to obtain clones for the other 8 genes) and other genes of interest. Transfection studies of HEK 293 T cells with expression clones containing more than 11 ORFs with GFP fused to either the N- or C-terminal were performed. FAM 111 B and KIAA 1549 L appeared to be localised to the centrosome. In order to better understand the context in which the novel centrosomal proteins that FAM 111 B might operate, in Chapter 5 I describe the construction of a large-scale pathway model of centrosome life cycle based on an extensive literature review. The model is composed of 117 of the most important centrosome-associated proteins and has been constructed using the modified Edinburgh Notation (mEPN) scheme. This model was used to better annotate the genes in the original S/G 2 /M list and understand which of the genes in the model are regulated during cell division. This regulatory network model of the centrosome life cycle represents an important summary of current knowledge and provides a useful resource for further analyses of the novel centrosomal proteins. In summary, a <b>list</b> <b>cell</b> cycle gene was derived from microarray experiments by using network structure analyses. Subsequent analyses filtered the genes that co-expressed during S/G 2 /M-phase narrowing down into 706 genes. Of this list, 69 genes had not previously been associated with the cell cycle. 42 of these unknown genes were analysed by using real time RNAi screening, 19 of these genes were indeed associated with the cell proliferation, and 2 of these genes with unknown function appear to localise to the centrosome. To predict their involvement in the centrosome life cycle, a pathway map composed of 117 centrosome-associated proteins were formed. Although further research is needed to determine their position in the centrosome life cycle, the pathway can be used for computational modelling testing their putative function in the system...|$|E
5000|$|... <<愛如潮水>>, a {{prominent}} classic hit penned by Roy, catapulted Jeff Chang to instant stardom in 1994. Inevitably, this song managed to top the charts of countless {{radio stations in}} Asia, karaoke play <b>lists,</b> <b>cell</b> phone ringtone downloads charts, etc. In addition to this, <<愛如潮水>> has also garnered the likes of Hong Kong's heavenly king, Andy Lau, as he chose to resing and compile {{it in one of}} his albums.|$|R
50|$|A <b>list</b> of <b>cell</b> {{types in}} the human body may include several hundred {{distinct}} types depending on the source.|$|R
50|$|Hyman {{has worked}} on {{creating}} parts <b>lists</b> for <b>cell</b> division among human cells {{as part of the}} EU funded projects Mitocheck and MitoSys.|$|R
30|$|To conduct cell {{scanning}} [10 – 12], today's cellular networks use {{a neighbor}} <b>cell</b> <b>list.</b> This list contains {{information about the}} pilot signal of selected handover candidates and is sent to mobiles. The mobiles then only need to measure the pilot signal quality of sites included in the neighbor <b>cell</b> <b>list</b> of its serving cell. It is known that the neighbor <b>cell</b> <b>list</b> has {{a significant impact on}} the performance of mobility management, and this has been a concern for many years in practical operations [13, 14] as well as in scientific research [15 – 18]. Using neighbor <b>cell</b> <b>list</b> is not effective for the scanning in small cell networks due to the aforementioned characteristics of high density and randomness.|$|R
40|$|Maximizing the {{performance}} {{potential of the}} modern day GPU architecture requires judicious utilization of available parallel resources. Although dramatic reductions can often be obtained through straightforward mappings, further performance improvements often require algorithmic redesigns to more closely exploit the target architecture. In this paper, we focus on efficient molecular simulations for the GPU and propose a novel <b>cell</b> <b>list</b> algorithm that better utilizes its parallel resources. Our goal is an efficient GPU implementation of large-scale Monte Carlo simulations for the grand canonical ensemble. This is a particularly challenging application because there is inherently less computation and parallelism than in similar applications with molecular dynamics. Consistent {{with the results of}} prior researchers, our simulation results show traditional <b>cell</b> <b>list</b> implementations for Monte Carlo simulations of molecular systems offer effectively no performance improvement for small systems [5, 14], even when porting to the GPU. However for larger systems, the <b>cell</b> <b>list</b> implementation offers significant gains in performance. Furthermore, our novel <b>cell</b> <b>list</b> approach results in better performance for all problem sizes when compared with other GPU implementations with or without <b>cell</b> <b>lists.</b> ...|$|R
50|$|In most cases, {{the cause}} of {{acoustic}} neuromas is unknown. The only statistically significant risk factor for developing an acoustic neuroma is having a rare genetic condition called neurofibromatosis type 2 (NF2). There are no confirmed environmental risk factors for acoustic neuroma. There are conflicting studies on the association between acoustic neuromas and cellular phone use and repeated exposure to loud noise. In 2011, {{an arm of the}} World Health Organization released a statement <b>listing</b> <b>cell</b> phone use as a low grade cancer risk. The Acoustic Neuroma Association recommends that cell phone users use a hands-free device.|$|R
50|$|<b>List</b> of {{neighboring}} <b>cells</b> {{that should be}} monitored by the MS.|$|R
5000|$|Using <b>cell</b> <b>lists</b> to {{identify}} the nearest neighbors in [...] further reduces the computational cost.|$|R
5000|$|... {{a set of}} <b>cells.</b> <b>Lists</b> {{are built}} from several cells holding mutual references. Cells have several fields: ...|$|R
25|$|The main {{causes of}} {{thrombosis}} {{are given in}} Virchow's triad which <b>lists</b> thrombophilia, endothelial <b>cell</b> injury, and disturbed blood flow.|$|R
40|$|We present two {{modifications}} {{of the standard}} <b>cell</b> <b>list</b> algorithm for nonequilibrium molecular dynamics simulations of homogeneous, linear flows. When such a flow is modeled with periodic boundary conditions, the simulation box deforms with the flow, and recent {{progress has been made}} developing boundary conditions suitable for general 3 D flows of this type. For the typical case of short-ranged, pairwise interactions, the <b>cell</b> <b>list</b> algorithm reduces computational complexity of the force computation from O($N^ 2 $) to O($N$), where $N$ is the total number of particles in the simulation box. The new versions of the <b>cell</b> <b>list</b> algorithm handle the dynamic, deforming simulation geometry. We include a comparison of the complexity and efficiency of the two proposed {{modifications of}} the standard algorithm. Comment: 13 pages, 10 figure...|$|R
5000|$|The first American Standards Association (predecessor to ANSI) {{standard}} C18 {{appeared in}} 1928. It <b>listed</b> <b>cell</b> sizes using a letter code, roughly {{in order of}} size from smallest (A) to larger types. The only numerical designation was the 6-inch tall [...] "No. 6" [...] cell. The 1934 edition of the C18 standard expanded the nomenclature system to include series and parallel arrays of cells. In 1954, mercury batteries {{were included in the}} standard. The 1959 edition identified types suitable for use with transistor radios. In 1967, NEMA took over responsibility for development from the National Bureau of Standards. The 12th edition of C18 began to be harmonized with the IEC standard. Rechargeable batteries were introduced in the C18 standard in 1984, and lithium types were standardized in 1991.|$|R
50|$|The first Housemate <b>listed</b> in each <b>cell</b> is {{nominated}} for two points, {{while the second}} Housemate listed is {{nominated for}} one point.|$|R
40|$|We present {{two major}} {{optimizations}} for the kinetic Activation-Relaxation Technique (k-ART), an off-lattice self-learning kinetic Monte Carlo (KMC) algorithm with on-the-fly event search THAT {{has been successfully}} applied to study a number of semiconducting and metallic systems. K-ART is parallelized in a non-trivial way: A master process uses several worker processes to perform independent event searches for possible events, while all bookkeeping and the actual simulation is performed by the master process. Depending on {{the complexity of the}} system studied, the parallelization scales well for tens to more than one hundred processes. For dealing with large systems, we present a near order 1 implementation. Techniques such as Verlet <b>lists,</b> <b>cell</b> decomposition and partial force calculations are implemented, and the CPU time per time step scales sublinearly with the number of particles, providing an efficient use of computational resources...|$|R
40|$|Particle methods {{provide a}} simple yet {{powerful}} framework for simulating both discrete and continuous systems either deterministically or stochastically. The inherent adaptivity of particle methods is particularly appealing when simulating multiscale models or systems that develop {{a wide spectrum}} of length scales. Evaluating particle–particle interactions using neighbor-finding algorithms such as <b>cell</b> <b>lists</b> or Verlet lists, however, quickly becomes inefficient in adaptive-resolution simulations where the interaction cutoff radius is a function of space. We present a novel adaptive-resolution <b>cell</b> <b>list</b> algorithm and the associated data structures that provide efficient access to the interaction partners of a particle, independent of the (potentially continuous) spectrum of cutoff radii present in a simulation. We characterize the computational cost of the proposed algorithm {{for a wide range of}} resolution spans and particle numbers, showing that the present algorithm outperforms conventional uniform-resolution <b>cell</b> <b>lists</b> in most adaptive-resolution settings...|$|R
50|$|In most simulations, {{periodic}} {{boundary conditions}} {{are used to}} avoid imposing artificial boundary conditions. Using <b>cell</b> <b>lists,</b> these boundaries can be implemented in two ways.|$|R
50|$|A OTDOA {{procedure}} {{works as}} follows:The ESMLC requests through the LPP layer an OTDOA measurement: {{a set of}} RSTD (Reference Signal Time Difference) measurements from the UE. Together with this request the UE receives assistance data.This assistance data, provides a <b>list</b> of <b>cells</b> (enodeBs), with their PRS (Positioning Reference Signal) parameters, including BW, periodicity etc.|$|R
50|$|The aim of {{the group}} is to secure {{premises}} {{to enable them to}} provide a resource for visually impaired persons who are seeking training and employment. The premises which they have identified as appropriate to their needs is the <b>Listed</b> B <b>Cell</b> Block adjacent to the Centre for Sensory Impairment in Partick, Glasgow, Scotland.|$|R
5000|$|If {{there is}} an element in the main list with the same {{coordinate}} and a less than or equal counter, remove it from the <b>cells</b> <b>list</b> ...|$|R
3000|$|... {{itself and}} its {{adjacent}} neighbors. The adjacent cells can be defined from the estimated coverage area maps, selecting the BSs whose coverage areas are in contact. cells_i^imp set can also be updated based on the neighbor <b>cell</b> <b>list</b> of each <b>cell,</b> as they are automatically updated during network operation [31]. All the cells in the deployment should have knowledge of the different cells_i^imp sets and their relative position in order {{to participate in the}} detection of problems of those sets where they are part of.|$|R
5000|$|Despite {{reducing}} the computational cost of finding all pairs {{within a given}} cut-off distance from [...] to , the <b>cell</b> <b>list</b> algorithm listed above still has some inefficiencies.|$|R
40|$|INTRODUCTION C programmers deride Lisp programmers as lazy, {{because they}} refuse to specify {{explicitly}} when storage is to be released. Lisp programmers rightly retort that C is unsafe, and curse the crashes of their C-based operating systems. Both camps assume that explicit storage management may be more efficient, but also more dangerous. This trade-off between efficiency and safety is particularly difficult in "production" code, where customers will not abide either inefficient or crash-prone code. Lisp systems currently offer great security, but extreme efficiency is gained only by going outside the language and its type system, where a single misstep may result in disaster. Lisp needs to allow the tuning of programs through additional programmer effort {{in ways that will}} not compromise security. We believe that the linear style of programming offers such a way. Lisp implementors have long known that most <b>list</b> <b>cells</b> have a reference count of 1 [Clark 77] [...] -i. e...|$|R
40|$|Distributed {{reference}} counting is {{a general}} purpose technique, which may be used, e. g., to detect termination of distributed programs or to implement distributed garbage collection. We present a distributed reference counting algorithm and a mechanical proof of correctness carried out using the proof assistant Coq. The algorithm is formalised by an abstract machine, and its correctness has two dierent facets. The safety property ensures that if there exists {{a reference to a}} resource, then its reference counter will be strictly positive. Liveness guarantees that if all references to a resource are deleted, its reference counter will eventually become null. 1 Introduction Reference counting {{is a general}} purpose technique that is able to count the number of references to a given resource. Collins [5] was the rst to use it in order to determine when <b>list</b> <b>cells</b> were no longer needed. Operating systems rely on this technique in order to decide when les may be deleted or when le [...] ...|$|R
40|$|The list marking problem {{involves}} {{marking the}} nodes of an `-node linked list {{stored in the}} memory of a (p; n) -PRAM, when only the position of the head of the list is initially known, while the remaining list nodes are stored in arbitrary memory locations. Under the assumption that <b>cells</b> containing <b>list</b> nodes bear no distinctive tags distinguishing them from other cells, we establish anΩ (minf`; n=pg) randomized lower bound for `-node lists and present a deterministic algorithm whose running time is within a logarithmic additive term of this bound. Such result implies that randomization cannot be exploited in any significant way in this setting. For the case where <b>list</b> <b>cells</b> are tagged in a way that differentiates them from other cells, the above lower bound still applies to deterministic algorithms, while we establish a tight Θ i min n `; `=p + q (n=p) log n oj bound for randomized algorithms. Therefore, in the latter case, randomization yields better performance fo [...] ...|$|R
5000|$|Since many {{cell lines}} used in {{research}} have been misidentified or contaminated,the Cellosaurus {{keeps track of}} problematic cell lines, including all those <b>listed</b> in theInternational <b>Cell</b> Line Authentication Committee (ICLAC) [...] tables.|$|R
40|$|This {{thesis is}} about list structures: {{how they are}} used tn practice, {{how they can be}} moved. and copied efficiently, and howthey can. be {{represented}} by spacesaving encodings. The approach taken to these subjects is mainly empirical. Measurement results are based on five large pl_ograms written in Interlisp, a sophisticated Lisp system that runs on the PDP-l O. Static data were collected at the end of typical runs of the programs, and all list structure used as data by them was measured (about 50, 000 cells each). Strong regularities were discovered. In each program, about one-third of all cars pointed to lists, the rest mainly to literal atoms and small integers; roughly three-fourths of cdrs pointed to lists, the rest mainly to the atom NIL. List pointers generally pointed to a location physically nearby. in memory, a condition that appears to depend only on the sequential allocation of new <b>list</b> <b>cells.</b> Atom pointers were distributed approximately according to Zipf's law, which models word occurrence tn natural]anguage text. Less agreement was found among the programs when dynamic references t...|$|R
50|$|IPython Notebook is {{a web-based}} {{interactive}} computational environment for creating IPython notebooks. An IPython notebook is a JSON document containing an ordered <b>list</b> of input/output <b>cells</b> which can contain code, text, mathematics, plots and rich media.|$|R
40|$|Abstract. Given a <b>list</b> of n <b>cells</b> L = [(p 1, q 1), [...] ., (pn, qn) ] where pi, qi ∈ Z≥ 0, we let ∆L = det ∥ ∥(pj!) − 1 (qj!) − 1 x pj i yqj ∥. i The {{space of}} diagonally {{alternating}} polynomials is spanned by {∆L} where L varies among all <b>lists</b> with n <b>cells.</b> For a> 0, the operators Ea = ∑n i= 1 yi∂a xi act on diagonally alternating polynomials and Haiman {{has shown that}} the space An of diagonally alternating harmonic polynomials is spanned by {Eλ∆n} where λ = (λ 1, [...] ., λℓ) varies among all partitions...|$|R
40|$|A {{system and}} method for {{converting}} bitmapped data, for example, weather data or thermal imaging data, to polygons is disclosed. The {{conversion of the}} data into polygons creates smaller data files. The invention is adaptive in that it allows for a variable degree of fidelity of the polygons. Matrix data is obtained. A color value is obtained. The color value is a variable used {{in the creation of}} the polygons. A <b>list</b> of <b>cells</b> to check is determined based on the color value. The <b>list</b> of <b>cells</b> to check is examined in order to determine a boundary list. The boundary list is then examined to determine vertices. The determination of the vertices is based on a prescribed maximum distance. When drawn, the ordered list of vertices create polygons which depict the cell data. The data files which include the vertices for the polygons are much smaller than the corresponding cell data files. The fidelity of the polygon representation can be adjusted by repeating the logic with varying fidelity values to achieve a given maximum file size or a maximum number of vertices per polygon...|$|R
