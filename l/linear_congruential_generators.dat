63|204|Public
25|$|The linear {{feedback}} {{shift register}} {{has a strong}} relationship to <b>linear</b> <b>congruential</b> <b>generators.</b>|$|E
5000|$|... #Subtitle level 2: Comparisons with <b>linear</b> <b>congruential</b> <b>generators</b> ...|$|E
50|$|The linear {{feedback}} {{shift register}} {{has a strong}} relationship to <b>linear</b> <b>congruential</b> <b>generators.</b>|$|E
5000|$|... #Caption: Hyperplanes of a <b>linear</b> <b>congruential</b> <b>generator</b> {{in three}} {{dimensions}} ...|$|R
40|$|We derive two {{different}} general relationships that exist among {{terms of the}} <b>linear</b> <b>congruential</b> <b>generator</b> xi+ 1 = axi + b mod 2 [beta] that are separated by powers of two. These two relationships are not equivalent except in one special case {{which turns out to}} be Marsaglia's result. Random number <b>generator</b> <b>linear</b> <b>congruential</b> <b>generator</b> Monte Carlo simulation long range corelations...|$|R
5000|$|... where [...] are {{randomly}} chosen integers modulo [...] with [...] (This is {{a single}} iteration of a <b>linear</b> <b>congruential</b> <b>generator.)</b> ...|$|R
5000|$|Equi{{distribution in}} n {{dimensions}} (e.g. <b>linear</b> <b>congruential</b> <b>generators</b> can at best manage reasonable distribution in five dimensions) ...|$|E
5000|$|<b>Linear</b> <b>congruential</b> <b>generators</b> are {{implemented}} asbecause mostarithmetic processors {{are able to}} put the multiplier a andthe current x in 32-bit registers, form the 64-bitproduct in adjoining registers, and take the lower 32 bits as the product, that is,form ...|$|E
50|$|The {{same type}} of {{transformation}} used in affine ciphers is used in <b>linear</b> <b>congruential</b> <b>generators,</b> a type of pseudorandom number generator. This generator is not a cryptographically secure pseudorandom number generator {{for the same reason}} that the affine cipher is not secure.|$|E
5000|$|The {{recurrence}} relation {{above is}} similar to the recurrence relation used by a <b>Linear</b> <b>congruential</b> <b>generator,</b> a poor-quality pseudorandom number generator: ...|$|R
50|$|As an illustration, {{consider}} the widely used programming language Java. , Java still {{relies on a}} <b>linear</b> <b>congruential</b> <b>generator</b> (LCG) for its PRNG; yet LCGs are of low quality—see further below.|$|R
40|$|Image {{encryption}} is {{conversion of}} image to a distorted form {{so that it}} can be secured from unauthorized users. This paper implements and investigates two methods for image encryption. First technique is encryption of image by <b>linear</b> <b>congruential</b> <b>generator.</b> Random numbers are generated by <b>Linear</b> <b>congruential</b> <b>generator.</b> These numbers are used as index for shuffling of rows, columns and pixels of an image. Second technique uses logistic maps to generate random number sequences. These random numbers are used as index for shuffling of rows, columns and pixels of an image. Finally we have analyzed two methods on basis of image quality parameters...|$|R
50|$|<b>Linear</b> <b>congruential</b> <b>generators</b> {{have the}} problem {{that all of the}} bits in each number are usually not equally random. A linear {{feedback}} shift register PRNG produces a stream of pseudo-random bits, each of which are truly pseudo-random, and can be implemented with essentially the same amount of memory as a linear congruential generator, albeit with a bit more computation.|$|E
5000|$|A Combined Linear Congruential Generator (CLCG) is a {{pseudo-random}} number generator algorithm based on combining {{two or more}} <b>linear</b> <b>congruential</b> <b>generators</b> (LCG). A traditional LCG has a period which is inadequate for complex system simulation. By combining two or more LCGs, random numbers with a longer period and better statistical properties can be created.The algorithm is defined as: ...|$|E
50|$|The {{restrictions}} on the parameters of a PRNG for it to possess a full cycle are known only for certain types of PRNGs, such as <b>linear</b> <b>congruential</b> <b>generators</b> and linear feedback shift registers. There is no general method {{to determine whether a}} PRNG algorithm is full-cycle short of exhausting the state space, which may be exponentially large compared {{to the size of the}} algorithm's internal state.|$|E
5000|$|In {{order to}} avoid {{manipulating}} huge [...] values, all math is done modulo [...] The choice of [...] and [...] is critical to get good hashing; see <b>linear</b> <b>congruential</b> <b>generator</b> for more discussion.|$|R
50|$|KISS (Keep it Simple Stupid) is {{a family}} of {{pseudorandom}} number generators introduced by George Marsaglia. Starting from 1998 Marsaglia posted on various newsgroups including sci.math, comp.lang.c, comp.lang.fortran and sci.stat.math several versions of the generators. All KISS generators combine three or four independent random number generators {{with a view to}} improving the quality of randomness. KISS generators produce 32-bit or 64-bit random integers, from which random floating-point numbers can be constructed if desired. The original 1993 generator is based on the combination of a <b>linear</b> <b>congruential</b> <b>generator</b> and of two linear feedback shift-register generators. It has a period 295, good speed and good statistical properties; however, it fails the LinearComplexity test in the Crush and BigCrush tests of the TestU01 suite. A newer version from 1999 is based on a <b>linear</b> <b>congruential</b> <b>generator,</b> a 3-shift <b>linear</b> feedback shift-register and two multiply-with-carry generators. It is 10-20% slower than the 1993 version but has a larger period 2123 and passes all tests in TestU01. In 2009 Marsaglia presented a version based on 64-bit integers (appropriate for 64-bit processors) which combines a multiply-with-carry generator, a Xorshift <b>generator</b> and a <b>linear</b> <b>congruential</b> <b>generator.</b> It has a period of around 2250 (around 1075).|$|R
40|$|Up to now {{all known}} {{efficient}} portable implementations of <b>linear</b> <b>congruential</b> random number <b>generators</b> with modulus 2 ^(31) - 1 are working only with multipliers which are small {{compared with the}} modulus. We show that for non-uniform distributions, the rejection method may generate random numbers of bad quality if combined with a <b>linear</b> <b>congruential</b> <b>generator</b> with small multiplier. Therefore a method is described that works for any multiplier smaller than 2 ^(30). It uses the decomposition of multiplier and seed in high order and low order bits to compute the upper and {{the lower half of}} the product. The sum of the two halfs gives the product of multiplier and seed modulo 2 ^(31) - 1. Coded in ANSI-C and FORTRAN 77 the method results in a portable implementation of the <b>linear</b> <b>congruential</b> <b>generator</b> that is as fast or faster than other portable methods. (author's abstract) Series: Preprint Series / Department of Applied Statistics and Data Processin...|$|R
5000|$|In {{the second}} half of the 20th century, the {{standard}} class of algorithms used for PRNGs comprised <b>linear</b> <b>congruential</b> <b>generators.</b> The quality of LCGs was known to be inadequate, but better methods were unavailable. Press et al. (2007) described the result thus: [...] "If all scientific papers whose results are in doubt because of and related were to disappear from library shelves, there would be a gap on each shelf about as big as your fist".|$|E
50|$|Generators {{based on}} linear recurrences (such as xorshift*) or on good avalanching {{functions}} (such as SplitMix64 http://prng.di.unimi.it/splitmix64.c) outperform <b>linear</b> <b>congruential</b> <b>generators</b> even at small state sizes. Moreover, linear generators can generate very long sequences, and when suitably perturbed at the output, they pass strong statistical tests. Several examples {{can be found}} in the Xorshift family. The Mersenne twister algorithm provides a very long period (219937 − 1) and variate uniformity, but it fails some statistical tests. A common Mersenne twister implementation, interestingly enough, uses an LCG to generate seed data.|$|E
5000|$|The {{spectral}} test is {{a statistical}} {{test for the}} quality of a class of pseudorandom number generators (PRNGs), the <b>linear</b> <b>congruential</b> <b>generators</b> (LCGs). LCGs have a property that when plotted in 2 or more dimensions, lines or hyperplanes will form, on which all possible outputs can be found. The spectral test compares the distance between these planes; the further apart they are, the worse the generator is. As this test is devised to study the lattice structures of LCGs, it can not be applied to other families of PRNGs.|$|E
50|$|A Lagged Fibonacci {{generator}} (LFG {{or sometimes}} LFib) {{is an example}} of a pseudorandom number generator. This class of random number generator is aimed at being an improvement on the 'standard' <b>linear</b> <b>congruential</b> <b>generator.</b> These are based on a generalisation of the Fibonacci sequence.|$|R
5000|$|The Lehmer {{random number}} {{generator}} (named after D. H. Lehmer), sometimes {{also referred to as}} the Park-Miller {{random number generator}} (after Stephen K. Park and Keith W. Miller), is a type of <b>linear</b> <b>congruential</b> <b>generator</b> (LCG) that operates in multiplicative group of integers modulo n. The general formula is: ...|$|R
40|$|AbstractA number-theoretical {{approach}} to the permutation of a sequence of objects performed {{by means of a}} <b>linear</b> <b>congruential</b> <b>generator</b> of pseudorandom numbers is presented. A sufficient condition is found for obtaining permutations with the property that each object definitely abandons its initial position. Since cryptography is among the possible applications, the generator performing the inverse transformation is also given...|$|R
5000|$|George Marsaglia {{established}} the lattice structure of <b>linear</b> <b>congruential</b> <b>generators</b> {{in the paper}} [...] "Random numbers fall mainly in the planes", retroactively termed Marsaglia effect or Marsaglia's theorem. This phenomenon means that n-tuples with coordinates obtained from consecutive use of the generator will lie on {{a small number of}} equally spaced hyperplanes in n-dimensional space. [...] He also developed the diehard tests, a series of tests {{to determine whether or not}} a sequence of numbers have the statistical properties that could be expected from a random sequence. In 1995 he published a CD-ROM of random numbers, which included the diehard tests.|$|E
5000|$|If a PRNG's {{internal}} state contains n bits, its period can be {{no longer}} than 2n results, and may be much shorter. For some PRNGs, the period length can be calculated without walking through the whole period. Linear Feedback Shift Registers (LFSRs) are usually chosen to have periods of exactly 2n−1. <b>Linear</b> <b>congruential</b> <b>generators</b> have periods that can be calculated by factoring. [...] Although PRNGs will repeat their results after they {{reach the end of}} their period, a repeated result does not imply {{that the end of the}} period has been reached, since its internal state may be larger than its output; this is particularly obvious with PRNGs with a one-bit output.|$|E
40|$|AbstractThe {{most common}} {{pseudorandom}} number generators are the <b>linear</b> <b>congruential</b> <b>generators.</b> It {{is well known}} that the set of all vectors of consecutive pseudorandom numbers determines a lattice if the linear congruential generator has maximal period length. Therefore <b>linear</b> <b>congruential</b> <b>generators</b> are often assessed by the ratio between the shortest and the longest vector of the Minkowski reduced basis, the so-called Beyer ratio. Generally the Minkowski reduced basis can only be determined with great computational effort. Therefore bounds for the Beyer ratio are of great interest. For mixed congruential generators a lower bound for the longest vector and an upper bound for the shortest vector of the Minkowski reduced basis are determined. This leads to an upper bound for the Beyer ratio which depends only on the prime factorization of the modulus...|$|E
50|$|In 1940, Lehmer {{accepted}} a position {{back at the}} mathematics department of UC Berkeley. At some point in his career there, he developed the <b>Linear</b> <b>congruential</b> <b>generator</b> (pseudorandom number generator), which is frequently {{referred to as a}} Lehmer random number generator. The Lehmers also assisted Harry Vandiver with his work on Fermat's Last Theorem, computing many Bernoulli numbers required.|$|R
40|$|Monte Carlo is a {{simulation}} method that using random numbers obtained from <b>Linear</b> <b>Congruential</b> <b>Generator</b> (multiplicative generator) as an approximation in estimating {{the number of}} visitors using previous time visitor data. The number of visitors who come to use internet services on internet cafes is often difficult to predict. Apart from some indicators that affect or may be experienced by the cafe owner with the activities of the internet service, it will predicted {{the number of visitors}} using visitor data from 60 days ago with <b>linear</b> method <b>congruential</b> <b>generator</b> as scrambler and monte carlo method as estimator. The results obtained is the estimated number of visitor in uniform distribution [0, 1] for the next 60 days that can be used as information for cafe owner. ...|$|R
40|$|An {{efficient}} {{implementation of}} linear feedback shift register sequences with a given characteristic polynomial is obtained {{by a new}} method. It involves a polynomial <b>linear</b> <b>congruential</b> <b>generator</b> over the finite field with two elements. We obtain maximal equidistribution by constructing a suitable output mapping. Local randomness could be improved by combining the generator's output with that of some other (e. g., nonlinear and efficient) generator...|$|R
40|$|<b>Linear</b> <b>Congruential</b> <b>Generators</b> (LCGs) are {{one model}} of {{pseudorandom}} number generators {{used in a}} great number of applications. They strongly depend on, and are completely characterized by, some critical parameters. The selection of good parameters to define a LCG is a difficult task mainly done, nowadays, by consulting tabulated values [10] or by trial and error. In this work, the authors present a method based on genetic algorithms that can automatically solve the problem of finding good parameters for a LCG. They also show that the selection of an evaluation function for the generated solutions is critical to the problem and how a seemingly good function such as entropy could lead to poor results. Finally, other fitness functions are proposed {{and one of them is}} shown to produce very good results. Some other possibilities and variations that may produce fine <b>linear</b> <b>congruential</b> <b>generators</b> are also mentioned. Publicad...|$|E
40|$|In {{order to}} analyze {{certain types of}} {{combinations}} of multiple recursive <b>linear</b> <b>congruential</b> <b>generators</b> (MRGs), we introduce a generalized spectral test. We show how to apply the test in large dimensions by a recursive procedure {{based on the fact}} that such combinations are subgenerators of other MRGs with composite moduli. We illustrate this with the well-known RANMAR generator. We also design an algorithm generalizing the procedure to arbitrary random number generators...|$|E
40|$|AbstractThe inversive congruential {{method for}} {{generating}} uniform pseudorandom numbers {{is a particularly}} attractive alternative to <b>linear</b> <b>congruential</b> <b>generators</b> with their well-known inherent deficiencies like the unfavourable coarse lattice structure in higher dimensions. In the present paper the modulus in the inversive congruential method is chosen as a power of an arbitrary odd prime. The existence of inversive congruential generators with maximal period length is proved by a new constructive characterization of these generators...|$|E
5000|$|A <b>linear</b> <b>congruential</b> <b>generator</b> (LCG) is an {{algorithm}} {{that yields}} {{a sequence of}} pseudo-randomized numbers calculated with a discontinuous [...] piecewise linear equation. The method {{represents one of the}} oldest and best-known pseudorandom number generator algorithms. [...] The theory behind them is relatively easy to understand, and they are easily implemented and fast, especially on computer hardware which can provide modulo arithmetic by storage-bit truncation.|$|R
5000|$|ADX {{supports}} a simple encryption scheme which XORs values from a <b>linear</b> <b>congruential</b> pseudorandom number <b>generator</b> with the block scale values. This method is computationally inexpensive to decrypt (in keeping with ADX's real-time decoding) yet renders the encrypted files unusable. The encryption is active when the [...] "Flags" [...] {{value in the}} header is 0x08. As XOR is symmetric the same method is used to decrypt as to encrypt. The encryption key {{is a set of}} three 16-bit values: the multiplier, increment, and start values for the <b>linear</b> <b>congruential</b> <b>generator</b> (the modulus is 0x8000 to keep the values in the 15-bit range of valid block scales). Typically all ADX files from a single game will use the same key.|$|R
40|$|We {{analyze the}} Monte Carlo {{algorithm}} for the approximation of multivariate integrals when a pseudo-random generator is used. We establish lower and upper bounds on {{the error of}} such algorithms. We prove {{that as long as}} a pseudo-random generator is capable of producing only finitely many points, the Monte Carlo algorithm with such a pseudo-random generator fails for L 2 or continuous functions. It also fails for Lipschitz functions if the number of points does not depend on the number of variables. This is the case if a <b>linear</b> <b>congruential</b> <b>generator</b> is used with one initial seed. On the other hand, if a <b>linear</b> <b>congruential</b> <b>generator</b> of period m is used for each component with independent uniformly distributed initial seeds, then the Monte Carlo algorithm with such a pseudo-random generator using n function values behaves as for the uniform distribution and its expected error is roughly n Γ 1 = 2 as long as the number n of function values is less than m 2. Typeset by A M S-T E X [...] ...|$|R
