28|319|Public
5000|$|For each <b>live</b> <b>object,</b> {{move its}} data to its {{forwarding}} location.|$|E
5000|$|For each <b>live</b> <b>object,</b> update its {{pointers}} {{according to}} the forwarding pointers of the objects they point to.|$|E
5000|$|If {{the live}} pointer {{points to a}} <b>live</b> <b>object,</b> update that object's {{forwarding}} pointer to the current free pointer and increment the free pointer according to the object's size.|$|E
40|$|A {{system and}} method for {{transferring}} <b>live</b> <b>objects,</b> such as chickens, to a shackle line are presented. The system and method include introducing {{a plurality of}} <b>live</b> <b>objects</b> to a singulator. The singulator isolates the individual <b>live</b> <b>objects</b> and places them in a pallet on a conveyor. The system may detect and remove cadavers from amongst the <b>live</b> <b>objects.</b> The conveyor leads the <b>live</b> <b>objects</b> to a grasper. The grasper positions {{the legs of the}} <b>live</b> <b>objects</b> so that a shackler can secure the legs of the <b>live</b> <b>objects</b> with a shackle. The <b>live</b> <b>objects</b> and the shackle are then inverted and passed on to a shackle line. The shackle line may be a kill line buffer or a kill line. Georgia Tech Research Corporatio...|$|R
5000|$|Musée Réattu, Arles, France,"Still and <b>Living</b> <b>Objects</b> and Women", 2008 ...|$|R
5000|$|Finalizers may {{reference}} and accidentally finalize <b>live</b> <b>objects,</b> violating program invariants.|$|R
5000|$|References. The {{reference}} to a <b>live</b> <b>object</b> is {{a complete set of}} serialized, portable instructions for constructing its proxy. To dereference a reference means to locally parse and follow these instructions on a particular computer, to produce a running proxy of the <b>live</b> <b>object.</b> Defined this way, a <b>live</b> <b>object</b> reference plays the same role as a Java reference, a C/C++ pointer, or a web service's WSDL description; it contains a complete information sufficient to locate the given object and interact with it. Since live distributed objects may not reside in any particular place (but rather span across a dynamically changing set of computers), the information contained in a live distributed object's reference cannot be limited to just an address. If the object is identified by some sort of a globally unique identifier (as might be the case for publish-subscribe topics or multicast groups), the reference must specify how this identifier is resolved, by recursively embedding a {{reference to}} the appropriate name resolution object.|$|E
50|$|Live {{distributed}} object (also abbreviated as <b>live</b> <b>object)</b> {{refers to}} a running instance of a distributed multi-party (or peer-to-peer) protocol, viewed from the object-oriented perspective, as an entity that has a distinct identity, may encapsulate internal state and threads of execution, and that exhibits a well-defined externally visible behavior.|$|E
50|$|In March 2017, Speaking Archaeologically {{documented}} {{sites and}} participated in <b>live</b> <b>object</b> analysis sessions from various archaeological places in England, especially Calleva Atrebatum in Silchester, the Old Winchester Hill, Wolvercote and Avebury Stone Circle. The Members also got to interact with various archaeologists from Butser Ancient Farm, University of Oxford and University of Kent through real time Q&A sessions.|$|E
2500|$|Bioassay: {{when the}} {{response}} is biological activity of <b>live</b> <b>objects.</b> Examples include ...|$|R
50|$|<b>Live</b> {{distributed}} <b>objects</b> (or simply <b>live</b> <b>objects)</b> generalize the replicated {{object concept}} {{to groups of}} replicas that might internally use any distributed protocol, perhaps resulting in only a weak consistency between their local states.|$|R
5000|$|The {{semantics}} {{and behavior}} of <b>live</b> distributed <b>objects</b> can be characterized in terms of distributed data flows; the set of messages or events that appear on the instances of a <b>live</b> <b>object's</b> endpoint forms a distributed data flow ...|$|R
50|$|The genial and timid piglet McDull has cheered up {{the lives}} of kids, professors, housewives and CEOs, because he epitomises the uncontainable and happy-go-lucky spirit of Hong Kong. His no-holds-barred porcobiography is a frame-by-frame account of life {{growing up in the}} slums of Shamshuipo, set against the {{colourful}} campaign of a post-97 Hong Kong trudging along regardless of downturn woes. Pouncing shots of busy Kowloon streets, slimy cafés, plus sights and smells of local flavour fused with animation, <b>live</b> <b>object</b> shooting and 3-D computer graphics define the film.|$|E
5000|$|Interfaces (endpoints). The {{interface}} {{of a live}} distributed {{object is}} defined by the types of interfaces exposed by its proxies; these may include event channels and various types of graphical user interfaces. Interfaces exposed by the proxies are referred to as the live distributed object's endpoints. The term endpoint instance refers to a single specific event channel or user interface exposed by a single specific proxy. To say that a <b>live</b> <b>object</b> exposes a certain endpoint means that each of its proxies exposes an instance of this endpoint to its local environment, and each of the endpoint instances carries events of the same types (or binds to the same type of a graphical display).|$|E
5000|$|Proxies (replicas). The proxy or {{a replica}} of a <b>live</b> <b>object</b> {{is one of the}} {{software}} component instances involved in executing the live object's distributed protocol. The object can thus be alternatively defined as a group of proxies engaged in communication, jointly maintaining some distributed state, and coordinating their operations. The term proxy stresses the fact that a single software component does not in itself constitute an object; rather, it serves as a gateway through which an application can gain access to a certain functionality or behavior that spans across a set of computers. In this sense, the concept of a live distributed object proxy generalizes the notion of a RPC, RMI, or [...]NET remoting client-side proxy stub.|$|E
5000|$|<b>Live</b> {{distributed}} <b>objects</b> (or simply <b>live</b> <b>objects)</b> generalize the replicated {{object concept}} {{to groups of}} replicas that might internally use any distributed protocol, perhaps resulting in only a weak consistency between their local states. <b>Live</b> distributed <b>objects</b> can also be defined as running instances of distributed multi-party protocols, viewed from the object-oriented perspective as entities that have distinct identity, and that can encapsulate distributed state and behavior.|$|R
50|$|After {{marking the}} <b>live</b> <b>objects</b> in the heap {{in the same}} fashion as the mark-sweep algorithm, the heap will often be fragmented. The goal of mark-compact {{algorithms}} is to shift the <b>live</b> <b>objects</b> in memory together so the fragmentation is eliminated. The challenge is to correctly update all pointers to the moved objects, most of which will have new memory addresses after the compaction. The issue of handling pointer updates is handled in different ways.|$|R
40|$|We {{introduce}} the <b>Live</b> <b>Objects</b> framework, which leverages our distributed object-oriented programming model and enables tactical edge mashups for battlefield command and control. Unlike most deployed web services, which are typically limited to client-server interactions, <b>Live</b> <b>Objects</b> can simultaneously support multiple patterns of communication, including direct client-to-client protocols. This {{means that when}} clients are forward deployed or accessible only through disadvantaged links, a <b>Live</b> <b>Objects</b> system can remain highly responsive, whereas more standard solutions might slow down precipitously, become unresponsive, or fail outright. Here, we summarize the approach and then suggest that, when using it, {{a new kind of}} Service-Oriented Collaboration (SOC) application can be created that will combine direct clientto-client sharing of imagery, videos, or other real-time data captured in the field, with service-hosted data, including geographic information systems, weather prediction systems, social networks, and other databases. The client-to-client solutions can include powerful new collaboration features implemented t...|$|R
50|$|Compaction {{proceeds}} {{from the bottom of}} the heap (low addresses) to the top (high addresses). As live (that is, marked) objects are encountered, they are moved to the first available low address, and a record is appended to a break table of relocation information. For each <b>live</b> <b>object,</b> a record in the break table consists of the object's original address before the compaction and the difference between the original address and the new address after compaction. The break table is stored in the heap that is being compacted, but in an area that are marked as unused. To ensure that compaction will always succeed, the minimum object size in the heap must be larger than or the same size as a break table record.|$|E
5000|$|The first {{implementation}} of the live distributed object concept, as defined in the ECOOP paper, was the Live Distributed Objects [...] platform developed by Krzysztof Ostrowski at Cornell University. The platform provided a set of visual, drag and drop tools for composing hierarchical documents resembling web pages, and containing XML-serialized <b>live</b> <b>object</b> references. Visual content such as chat windows, shared desktops, and various sorts of mashups could be composed by dragging and dropping components representing user interfaces and protocol instances onto a design form, and connecting them together. Since the moment of its creation, a number of extension {{have been developed to}} embed live distributed objects in Microsoft Office documents, and to support various types of hosted content such as Google Maps. As of March 2009, the platform is being actively developed by its creators.|$|E
50|$|The term live {{distributed}} {{object was}} first used informally {{in a series of}} presentations given in the fall of 2006 at an ICWS conference, STC conference, and at the MSR labs in Redmond, WA, and then formally defined in 2007, in an IEEE Internet Computing article. Originally, the term was used to refer to the types of dynamic, interactive Web content that is not hosted on servers in data centers, but rather stored on the end-user's client computers, and internally powered by instances of reliable multicast protocols. The word live expressed the fact that the displayed information is dynamic, interactive, and represents current, fresh, live content that reflects recent updates made by the users (as opposed to static, read-only, and archival content that has been pre-assembled). The word distributed expressed the fact that the information is not hosted, stored at a server in a data center, but rather, it is replicated among the end-user computers, and updated in a peer-to-peer fashion through a stream of multicast messages that may be produced directly by the end-users consuming the content; a more comprehensive discussion of the <b>live</b> <b>object</b> concept in the context of Web development can be found in Krzysztof Ostrowski's Ph.D. dissertation.|$|E
5000|$|A table-based {{algorithm}} {{was first}} described by Haddon and Waite in 1967. It preserves the relative {{placement of the}} <b>live</b> <b>objects</b> in the heap, and requires only a constant amount of overhead.|$|R
50|$|The {{more general}} {{definition}} presented above has been first proposed in 2008, {{in a paper}} published at the ECOOP conference. The extension of the term has been motivated {{by the need to}} model <b>live</b> <b>objects</b> as compositions of other objects; in this sense, the concept has been inspired by Smalltalk, which pioneered the uniform perspective that everything is an object, and Jini, which pioneered the idea that services are objects. When applied to <b>live</b> distributed <b>objects,</b> the perspective dictates that their constituent parts, which includes instances of distributed multi-party protocols used internally to replicate state, should also be modeled as <b>live</b> distributed <b>objects.</b> The need for uniformity implies that the definition of a <b>live</b> distributed <b>object</b> must unify concepts such as live Web content, message streams, and instances of distributed multi-party protocols.|$|R
50|$|H. Chen, S. Yang, A. Wortmann, and R. Zenobi, Neutral Desorption Sampling of <b>Living</b> <b>Objects</b> for Rapid Analysis by Extractive Electrospray Ionization Mass Spectrometry, Angew. Chem. 119, 7735-7738 (2007); Angew. Chem. Int. Ed. 46, 7591-7594 (2007).|$|R
40|$|Cache misses are {{currently}} {{a major factor}} in the cost of garbage collection, and we expect them to dominate in the future. Traditional garbage collection algorithms exhibit relatively little temporal locality; each <b>live</b> <b>object</b> in the heap is likely to be touched exactly once during each garbage collection. We measure two techniques for dealing with this issue: prefetch-on-grey, and lazy sweeping. The rst of these is new in this context. Lazy sweeping has been in common use for a decade. It was introduced as a mechanism for reducing paging and pause times; we argue that it is also crucial for eliminating cache misses during the sweep phase...|$|E
40|$|Evaluating {{software}} based constraints at runtime is {{an important}} task for both the validation and verification of software. It {{is not uncommon to}} encounter constraints that require obtaining the set of all active object instances for a given classifier. When the application under test is being executed on a virtual machine or a managed runtime, it is often difficult, if not impossible, to obtain such a set. We will examine Microsoft's. NET common language runtime, and through the use of the profiler API, provide a concrete mechanism for obtaining the set of <b>live</b> <b>object</b> instances for a given classifier. We will then leverage this set to provide an extension to an existing C # and Object Constraint Language compiler to support the OclAny::allInstances operation...|$|E
40|$|In earlier {{languages}} {{the memory}} management is done explicitly by the programmer himself. Now {{with the advent}} of modern object oriented languages like Java and C# the programmer is relived from explicitly managing the memory. A special program thread known as garbage collector takes care of managing the memory implicitly. The process of automatically reclaiming memory from dead objects (the objects that are not referenced from program or any other <b>live</b> <b>object)</b> is known as garbage Collection (GC). There are various metrics that affect the performance of the mutator. In the current research paper we have experimentally tested the four garbage collectors on various benchmarks of SPECjvm 2008 and calculated how much memory is reclaimed after each (minor and major) collection...|$|E
50|$|ConceptDraw PRO {{supports}} its own XML format, and an embedded Basic Script {{language for}} creating complex graphic objects, that change in visual appearance depending on external data received from personal files {{or from the}} Internet (<b>Live</b> <b>Objects).</b>|$|R
50|$|VB Watch Debugger {{monitors}} {{what happens}} inside a running Visual Basic program or library. It displays the call stack, execution trace, global {{variables and the}} number of <b>live</b> <b>objects.</b> The Debugger also allows one to add breakpoints in executable files.|$|R
50|$|Tracing garbage {{collection}} cycles are triggered too often if {{the set of}} <b>live</b> <b>objects</b> fills most of the available memory; it requires extra space to be efficient. Reference counting performance does not deteriorate as {{the total amount of}} free space decreases.|$|R
40|$|The Use of an Object and Relating through Identifications” (1968) {{represents}} Donald Winnicott’s {{theoretical and}} clinical legacy. The author develops this concept from a clinical point of view, through {{the analysis of}} a woman with psychotic functioning. He reflects upon the dramatic quality of risks inherent in the processes linked {{to the use of the}} object with seriously disturbed patients. He explores different meanings of the analyst’s survival, linking it to the analyst’s response. The processes of the use of the object—that is, the encounter between the patient’s potential destructiveness and the analyst’s capacity to respond through his own judicious subjectivity—let the patient experience the analyst’s capacity to keep his own subjectivity, authenticity, and creativity alive. It is starting from the traces of this <b>live</b> <b>object</b> that patients gradually form their own personal sense of being real...|$|E
40|$|Copying-based garbage {{collectors}} {{are currently}} widely employed in JVM systems, as they provide not only cheap allocations but also fast collections. Comparing to their compacting-based counterparts, copying-based collectors trade space for time: they conservatively reserve {{half of the}} available heap {{for the purpose of}} copying live objects. 1 It is a common belief, however, that objects’ survival rates are generally too low to make full use of the reserved memory. We find through experiments that the total <b>live</b> <b>object</b> sizes of Java programs are generally small and remain relatively stable over many collections, which provides a perfect opportunity for optimization. We analyze this phenomenon and propose a “skew-space ” 2 collector that would reserve spaces of dynamically adjusted sizes coming from online predictions. The proposed collector has been realized using MMTk in the JikesRVM, and has shown promising improvements in the total execution time for the SPECjvm 98 and DaCapo benchmarks...|$|E
40|$|We {{present the}} DeAL {{language}} for heap assertions that are efficiently evaluated during garbage collection time. DeAL is a rich, declarative, logic-based language whose programs {{are guaranteed to}} be executable with good whole-heap locality, i. e., within a single traversal over every <b>live</b> <b>object</b> on the heap and a finite neighborhood around each object. As a result, evaluating DeAL programs incurs negligible cost: for simple assertion checking at each garbage collection, the end-to-end execution slowdown is below 2 %. DeAL is integrated into Java as a VM extension and we demonstrate its efficiency and expressiveness with several applications and properties from the past literature. Compared to past systems for heap assertions, DeAL is distinguished by its very attractive expressiveness/efficiency tradeoff: it offers a significantly richer class of assertions than what past systems could check with a single traversal. Conversely, past systems that can express the same (or more) complex assertions as DeAL do so only by suffering ordersof-magnitude higher costs. 1...|$|E
5000|$|To promote Netscape Navigator, Netscape {{developed}} the [...] "Netscape Now" [...] program. The program promoted {{the display of}} the [...] "Netscape Now! 2.0" [...] web badge on websites with newly supported features, including frames, <b>live</b> <b>objects,</b> Java applets, and JavaScript.|$|R
5000|$|... "As a gypsy wagon or a {{poltergeist}} appears {{and disappears}} mysteriously, so does this short <b>lived</b> <b>object.</b> As a consequence the code {{is more difficult}} to maintain and there is unnecessary resource waste. The typical cause for this antipattern is poor object design." ...|$|R
5000|$|Javascript <b>objects</b> {{representing}} the <b>Live</b> Clipboard <b>object</b> model ...|$|R
