9|6|Public
50|$|Univac {{provided}} a batch operating system, EXEC I. Computer Sciences Corporation was contracted {{to provide a}} powerful optimizing Fortran IV compiler, an assembler named SLEUTH with sophisticated macro capabilities, and a very flexible <b>linking</b> <b>loader.</b>|$|E
50|$|In 1968, Barr {{created the}} first non-IBM <b>linking</b> <b>loader</b> for the IBM/360. Named LDR, the loader was {{sponsored}} by American Data Processing Inc. of Raleigh, North Carolina. The Barr Loader cut typical program testing times by twenty-five percent.|$|E
50|$|It is modular in construction, {{with the}} {{operating}} system generation based on a relocating, <b>linking,</b> <b>loader</b> program. This makes the incorporation of different hardware driver modules quite easy, particularly for bus-oriented machines, such as the IEEE-696 (S-100) bus which was commonly used for TurboDOS systems.|$|E
25|$|In computing, rpath designates the {{run-time}} search path hard-coded in an {{executable file}} or library. Dynamic <b>linking</b> <b>loaders</b> use the rpath to find required libraries.|$|R
5000|$|Dynamic <b>linking</b> <b>loaders</b> {{are another}} type of loader that load and link shared {{libraries}} (like [...]so files or [...]dll files) to already loaded running programs.|$|R
5000|$|BCPL handles {{bindings}} spanning separate compilation {{units in}} a unique way. There are no user-declarable global variables; instead there is a global vector, {{which is similar to}} [...] "blank common" [...] in Fortran. All data shared between different compilation units comprises scalars and pointers to vectors stored in a pre-arranged place in the global vector. Thus the header files (files included during compilation using the [...] "GET" [...] directive) become the primary means of synchronizing global data between compilation units, containing [...] "GLOBAL" [...] directives that present lists of symbolic names, each paired with a number that associates the name with the corresponding numerically addressed word in the global vector. As well as variables, the global vector also contains bindings for external procedures. This makes dynamic loading of compilation units very simple to achieve. Instead of relying on the <b>link</b> <b>loader</b> of the underlying implementation, effectively BCPL gives the programmer control of the linking process.|$|R
50|$|Any static library {{function}} {{can call}} a function or procedure in another static library. The linker and loader handle this {{the same way}} as for kinds of other object files. Static library files may be linked at run time by a <b>linking</b> <b>loader</b> (e.g., the X11 module loader). However, whether such a process can be called static linking is controversial.|$|E
5000|$|BlackBox Component Pascal {{uses the}} {{extensions}} [...]odc (= Oberon document) for document files, such as source files for example, and [...]osf (= Oberon symbol file) for symbol files while Gardens Point Component Pascal uses [...]cp for source and [...]cps for symbol files. BlackBox Component Pascal {{has its own}} executable and loadable object format [...]ocf (= Oberon code file); it includes a runtime <b>linking</b> <b>loader</b> for this format. The document format (.odc) is a rich text binary format, which allows nice formatting, supports conditional folding, and allows active content to be embedded in the source text. It also handles user interface elements in editable forms. This is in tradition of the Oberon Text format.|$|E
5000|$|The printer routine, however, {{works with}} text in 8-bit EBCDIC with two {{characters}} per word, requiring a 40-word buffer. The program uses library routine ZIPCO {{to perform the}} conversion. The [...] is not executed because HLEBC is not a subroutine but an IBM-supplied Hollerith-to-EBCDIC conversion table. The CALL statement provides {{the address of the}} table to ZIPCO and ensures that the <b>linking</b> <b>loader</b> includes the table in the program, thus it is the fifth parameter to ZIPCO. After the conversion, the program sends the converted output, now in buffer PBUFF, to the printer through driver PRNT1. Again, the program loops until the printer driver reports completion, then the program reads the next card.|$|E
40|$|Self-modifying code (SMC), in this paper, broadly {{refers to}} any program that loads, generates, or mutates code at runtime. It {{is widely used}} {{in many of the}} world’s {{critical}} software systems to support runtime code generation and optimization, dynamic loading and <b>linking,</b> OS boot <b>loader,</b> just-in-time compilation, binary translation, or dynamic code encryption and obfuscation. Unfortunately, SMC is also extremely di   cult to reason about: existing formal verification techniques—including Hoare logic and type system— consistently assume that program code stored in memory is fixed and immutable; this severely limits their applicability and power. This paper presents a simple but novel Hoare-logic-like framework that supports modular verification of general von-Neumann machine code with runtime code manipulation. By dropping the assumption that code memory is fixed and immutable, we are forced to apply local reasoning and separation logic at the very beginning, and treat program code uniformly as regular data structure. We address the interaction between separation and code memory and show how to establish the frame rules for local reasoning even in the presence of SMC. Our framework is realistic, but designed to be highly generic, so that it can support assembly code under all modern CPUs (including both x 86 and MIPS). Our system is expressive and fully mechanized. We prove its soundness in the Coq proof assistant and demonstrate its power by certifying a series of realistic examples and applications—all of which can directly run on the SPIM simulator or any stock x 86 hardware...|$|R
50|$|Program {{translation}} {{has been}} {{divided into four}} subproblems: compiler, assembler, <b>link</b> editor, and <b>loader.</b> As a result, the translation software is layered as well, allowing the software layers to be designed independently. Noting that the ways to conquer the complexity of program translation could readily be applied to protocols because of the analogy between programming languages and protocols, the designers of the TCP/IP protocol suite were keen on imposing the same layering on the software framework. This {{can be seen in}} the TCP/IP layering by considering the translation of a pascal program (message) that is compiled (function of the application layer) into an assembler program that is assembled (function of the transport layer) to object code (pieces) that is linked (function of the Internet layer) together with library object code (routing table) by the link editor, producing relocatable machine code (datagram) that is passed to the loader which fills in the memory locations (ethernet addresses) to produce executable code (network frame) to be loaded (function of the network interface layer) into physical memory (transmission medium). To show just how closely the analogy fits, the terms between parentheses in the previous sentence denote the relevant analogs and the terms written cursively denote data representations. Program translation forms a linear sequence, because each layer's output is passed as input to the next layer. Furthermore, the translation process involves multiple data representations. We see the same thing happening in protocol software where multiple protocols define the data representations of the data passed between the software modules.|$|R
5000|$|MTS loads {{programs}} using {{a dynamic}} <b>linking</b> <b>loader</b> (UMLOAD) that reads loader records (ESD, TXT, CSI, RDL, LCS, END, ...) from the file or device {{specified by the}} user and will selectively include subroutines from libraries supplied by the user, from system subroutine libraries such as *LIBRARY, and from system subroutines pre-loaded in shared virtual memory. MTS uses standard OS/360 loader records which makes it fairly easy for MTS to use compilers developed for use under other IBM operating systems. When a program starts execution a number of logical I/O units will be set either explicitly on the $RUN or other command or by default. Any text string given following the PAR= keyword is passed to the program as a parameter. By default user programs execute with the program key *EXEC, but a different program key may be set using the $CONTROL command. Programs may call a system subroutine to shorten the program key they are using or switch to the *EXEC program key thus temporary giving themselves less access to files, devices, and other services controlled using program keys. Programs may also call a system subroutine to lengthen or restore their program key according to some pre-established rules.|$|E
40|$|This memo was {{originally}} printed as MAC Memo 268, January 31, 1966. The MIDAS <b>Linking</b> <b>Loader</b> is a PDP- 6 program to load re-locatable format output from the MIDAS assembler, with facilities to handle symbolic cross-reference between independently assembled programs. Although it is arranged primarily to load from DECtape, the loader {{is able to}} load paper-tape re-locatable programs...|$|E
40|$|The MIDAS <b>linking</b> <b>loader</b> is a PDP- 6 {{program to}} load relocatable-format output from the MIDAS assemblers, with {{facilities}} to handle symbolic cross-reference between independently assembled programs. Although it is arranged primarily to load from DECtape, the loader is able also to load paper-tape relocatable programs. To use the loader, load {{it off the}} MACDMOP SYSTEM tape as the file STINK (A file STINK NEW may exist, repairing old bugs or introducing new features.) Then the loader expects commands to be typed in on the on-line Teletype; two successive ALT MODE characters terminate the string of commands. The commands in a string are not performed until the string is thus terminated. While a command in a string has not been terminated, RUBOUT will erase the last typed-in character (and type it out again as a reminder). A command string may contain any number of commands, and the effect is the same whether the commands are together in one string or are in successively typed-in strings each delimited by two ALT MODES...|$|E

