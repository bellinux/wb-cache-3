0|1420|Public
3000|$|... holds. If {{the answer}} is yes, GW accepts this <b>request</b> <b>message</b> and executes the next step. Otherwise, GW rejects the <b>request</b> <b>message.</b>|$|R
3000|$|When {{receiving}} the register <b>request</b> <b>message</b> of U {{at the time}} T′, firstly GW checks whether (T′-T 1)[*]≤[*]∆T holds. If the answer is no, GW rejects the register <b>request</b> <b>message</b> of U. Otherwise, GW selects a random number x∈Z [...]...|$|R
30|$|In our threat model, the attacker’s (i.e., publisher’s) {{goal is to}} {{successfully}} deliver ad <b>request</b> <b>messages</b> to a victim ad network to receive payments for those messages from the ad network. Therefore, we tested whether ad <b>request</b> <b>messages</b> can be successfully delivered without any trouble whenever we had attempted to generate a click event (with a different Device ID) on the victim’s advertisements. Specifically, {{we assume that the}} attack is successful if our bot program generates over 100 ad <b>request</b> <b>messages</b> without any disruption to receive payments for the generated clicks.|$|R
40|$|Abstract—A traceback {{attack was}} {{recently}} developed on Freenet, which {{can identify the}} originating machine of a content <b>request</b> <b>message,</b> even if a single content <b>request</b> <b>message</b> has been issued by a content retriever. The traceback attack exploited a few fine-grained design and development decisions made in Freenet, including the unique identifier (UID) based mechanism to prevent routing loops of content <b>request</b> <b>messages.</b> In this paper we develop a simple yet effective scheme named dynID to thwart the traceback attack on Freenet. In dynID, the UID associated with a content <b>request</b> <b>message</b> is dynamically changed at the beginning portion of the message forwarding path. As a consequence, an attacker can only trace back a content <b>request</b> <b>message</b> to the node where the UID value is last changed; it cannot uniquely determine the originating machine of the message. Importantly, dynID only has negligible impacts {{on the performance of}} Freenet in locating content on the network. For example, our simulation studies based on the original Freenet source code show that, for all content requests, we can successfully locate the corresponding requested content. I...|$|R
50|$|The C-FIND <b>request</b> <b>message</b> {{is sent to}} the server.|$|R
5000|$|... server {{skeleton}} {{receives the}} <b>request</b> <b>message</b> from the network ...|$|R
30|$|BS {{retrieves}} a SS bandwidth {{demand by}} extracting bandwidth <b>request</b> <b>message</b> header that is {{received from the}} SS. This bandwidth <b>request</b> <b>message</b> only informs the BS the needed amount of bandwidth for the next cycle {{even though there are}} proposals to incorporate some extra information in the bandwidth <b>request</b> <b>message,</b> but the problem to assign bandwidth fairly among requests of the same service class still persists. In [3], the bandwidth <b>request</b> <b>message</b> is partitioned into two categories, guaranteed and non-guaranteed; but the effort will be in vain if all the bandwidth requests are from only one category, either guaranteed or non-guaranteed type. The bandwidth request and grant module will still need to face the need to manage bandwidth requests within the guaranteed category itself or within non-guaranteed category internally. Our proposed scheme is designed to look into this issue and offer a solution.|$|R
40|$|The present {{description}} refers {{in particular}} to a computer-implemented method, a computer system, and a computer program product for input validation and output validation to prevent SQL injections. The computer-implemented method may comprise: receiving at a service (122) a <b>request</b> <b>message</b> from a client (110) over a network (130), wherein the service is located on a server; providing a handler (126) at the server; checking the <b>request</b> <b>message</b> at the handler using a first method before sending the <b>request</b> <b>message</b> to the service; and checking a response message at the handler using the first method before sending the response message to the client...|$|R
30|$|Line 2 : PA {{waits to}} receive {{consumer}} <b>request</b> <b>message</b> from BA.|$|R
5000|$|Direct HTTP request data: {{directly}} {{comes from}} HTTP <b>request</b> <b>messages</b> (HTTP <b>request</b> headers).|$|R
5000|$|The network sends RAND to the MS in the MM Authentication <b>Request</b> <b>message.</b>|$|R
5000|$|Sends a {{snapshot}} <b>request</b> <b>message</b> bearing {{a snapshot}} token {{to all other}} processes ...|$|R
5000|$|... stub marshalls call {{type and}} in the input {{arguments}} into a <b>request</b> <b>message</b> ...|$|R
40|$|Cloud {{computing}} systems {{security is}} to improve when end-user communicates with the cloud server. In {{order to make a}} connection between end-user and the Cloud Server, first end-user or Cloud Server make sure that they are communicating with right counterpart. Multi-Key encryption concept is used to encrypt the <b>request</b> <b>message</b> or data which is sent from end-user or also from Cloud Server. <b>Request</b> <b>message</b> sent by end-user to cloud server should matches with the response received from by end-user from cloud server. Multi-key concept takes more number of iteration when compared to single-key concept when trying to validate the <b>requested</b> <b>message.</b> Multi-Key concept is more secured than single-key...|$|R
50|$|The client {{prepares a}} C-FIND <b>request</b> <b>message</b> {{which is a}} list of DICOM attributes.|$|R
5000|$|The MS {{will send}} a Channel <b>Request</b> <b>message</b> to the BSS on the RACH.|$|R
5000|$|... sends a <b>request</b> <b>message</b> {{containing}} new {{sequence number}} to all {{processes in the}} system ...|$|R
30|$|Once the MAG {{receives}} the LSAM message, {{it sends a}} <b>request</b> <b>message</b> to non-overloaded MAGs.|$|R
30|$|The {{resident}} LM in {{that base}} station sends to the MSC a route <b>request</b> <b>message.</b>|$|R
5000|$|Each Data Record Transfer <b>Request</b> <b>message</b> {{can contain}} {{a message of}} one of four types: ...|$|R
3000|$|... {{is given}} a pseudo-identity alias_v_i. Even though the {{attacker}} captures the EVR <b>request</b> <b>message</b> EVR=alias [...]...|$|R
5000|$|Upon {{reception}} of a <b>request</b> <b>message,</b> immediately sending a timestamped reply message if and only if: ...|$|R
30|$|Note {{also that}} each sensor node only needs to {{broadcast}} one network joining message during the key establishment phase with no further message exchange required. Moreover, the network joining message {{may be the}} route <b>request</b> <b>message.</b> The pairwise key and the local cluster key can be established {{at the same time}} when a node forwards a route <b>request</b> <b>message.</b> Thus, the communication overhead can be very low.|$|R
40|$|ACT++ 2. 0 is {{the most}} recent version of a class library for {{concurrent}} programming in C++. Programs in ACT++ consist {{of a collection of}} active objects called actors. Actors execute concurrently and cooperate by sending <b>request</b> and reply <b>messages.</b> An agent, termed the behavior of an actor, is responsible for processing a single <b>request</b> <b>message</b> and for specifying a replacement behavior which processes the next available <b>request</b> <b>message.</b> One of the salient features of ACT++ is its realization of I/O as an actor operation. A special type of actor, called an interface actor, provides a high level interface for a file. Interface actors are sent <b>request</b> <b>messages</b> whenever I/O is necessary and can also transparently perform asynchronous I/O. ACT++ has been implemented on the Sequent Symmetry multiprocessor using the PRESTO threads package...|$|R
3000|$|The {{aggregator}} sends a data <b>request</b> <b>message</b> or, alternatively, {{the producers}} can initiate a transmission periodically; [...]...|$|R
30|$|The route request overhead: sending <b>request</b> <b>messages</b> {{per unit}} time of crowd cloud routing or {{forwarding}} number.|$|R
5000|$|... {{skeleton}} unpacks call type {{from the}} <b>request</b> <b>message</b> {{and looks up}} the procedure on the called object ...|$|R
3000|$|... node sends a <b>request</b> <b>message</b> to its nearest node {{to serve}} as the {{processing}} center for future rounds.|$|R
50|$|Address mask reply is used {{to reply}} to an address mask <b>request</b> <b>message</b> with an {{appropriate}} subnet mask.|$|R
50|$|An {{example of}} a {{stateless}} protocol is HTTP, meaning that each <b>request</b> <b>message</b> can be understood in isolation.|$|R
5000|$|When a RIP router comes online, {{it sends}} a {{broadcast}} <b>Request</b> <b>Message</b> on all of its RIP enabled interfaces. All the neighbouring routers which receive the <b>Request</b> <b>message</b> respond back with the Response Message containing their Routing table. The Response Message is also gratuitously sent when the Update timer expires. On receiving the Routing table, the router processes each entry of the routing table as per the following rules ...|$|R
5|$|The {{problem can}} be fixed by {{ignoring}} Heartbeat <b>Request</b> <b>messages</b> that ask for more data than their payload needs.|$|R
5000|$|... #Caption: An HTTP 1.1 request {{made using}} telnet. The <b>request</b> <b>message,</b> {{response}} header section, and response body are highlighted.|$|R
5000|$|The BSS {{sends the}} MS an Authentication <b>Request</b> <b>message.</b> The only {{parameter}} {{sent in the}} message is the RAND.|$|R
5000|$|The Proposer sends an Accept <b>Request</b> <b>message</b> to a Quorum of Acceptors {{with the}} chosen value for its proposal.|$|R
3000|$|... [...])[*]≤[*]∆T hold. If {{the answer}} is no, GW rejects the <b>request</b> <b>message.</b> Otherwise, GW {{continues}} to perform the next step.|$|R
