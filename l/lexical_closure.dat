7|19|Public
2500|$|The key {{insights}} {{on how to}} introduce lexical scoping into a Lisp dialect were popularized in Sussman and Steele's 1975 Lambda Paper, [...] "Scheme: An Interpreter for Extended Lambda Calculus", where they adopted {{the concept of the}} <b>lexical</b> <b>closure</b> (on page 21), which had been described in an AI Memo in 1970 by Joel Moses, who attributed the idea to Peter J. Landin.|$|E
50|$|Lambda {{expressions}}: Lambda expressions allow predicates {{and other}} projection functions {{to be written}} inline with a concise syntax, and support full <b>lexical</b> <b>closure.</b> They are captured into parameters as delegates or expression trees depending on the Query Provider.|$|E
50|$|Secondly, lexical scope (combined with {{indefinite}} extent) {{gives rise}} to the <b>lexical</b> <b>closure,</b> which in turn creates a whole paradigm of programming centered around the use of functions being first-class objects, which {{is at the root of}} functional programming.|$|E
50|$|Anonymous {{functions}} including <b>lexical</b> <b>closures.</b>|$|R
2500|$|<b>Lexical</b> <b>closures,</b> {{iterators}} and generators, with a block syntax ...|$|R
5000|$|Python has had {{support for}} <b>lexical</b> <b>closures</b> since version 2.2. Here's an example: ...|$|R
5000|$|The key {{insights}} {{on how to}} introduce lexical scoping into a Lisp dialect were popularized in Sussman and Steele's 1975 Lambda Paper, [...] "Scheme: An Interpreter for Extended Lambda Calculus", where they adopted {{the concept of the}} <b>lexical</b> <b>closure</b> (on page 21), which had been described in an AI Memo in 1970 by Joel Moses, who attributed the idea to Peter J. Landin.|$|E
5000|$|The tags in a TAGBODY have lexical scope. The {{expression}} (GO X) is erroneous {{if it is}} {{not actually}} embedded in a TAGBODY which contains a label X. However, the label bindings disappear when the TAGBODY terminates its execution, because they have dynamic extent. If that block of code is re-entered by the invocation of a <b>lexical</b> <b>closure,</b> it is invalid for the body of that closure to try to transfer control to a tag via GO: ...|$|E
40|$|Sublanguages are {{varieties}} of language that form “subsets” {{of the general}} language, typically exhibiting particular types of lexical, semantic, and other restrictions and deviance. SubCAT, the Sublanguage Corpus Analysis Toolkit, assesses the representativeness and closure properties of corpora to analyze {{the extent to which}} they are either sublanguages, or representative samples of the general language. The current version of SubCAT contains scripts and applications for assessing <b>lexical</b> <b>closure,</b> morphological closure, sentence type closure, over-represented words, and syntactic deviance. Its operation is illustrated with three case studies concerning scientific journal articles, patents, and clinical records. Materials from two language families are analyzed―English (Germanic), and Bulgarian (Slavic). The software is available at sublanguage. sourceforge. net under a liberal Open Source license...|$|E
50|$|OCaml features: {{a static}} type system, type inference, {{parametric}} polymorphism, tail recursion, pattern matching, first class <b>lexical</b> <b>closures,</b> functors (parametric modules), exception handling, and incremental generational automatic garbage collection.|$|R
50|$|Some {{programming}} language researchers and academics use the first meaning {{alone or in}} combination with the second as a distinguishing feature of object-oriented programming, while some {{programming language}}s which provide <b>lexical</b> <b>closures</b> view encapsulation as a feature of the language orthogonal to object orientation.|$|R
50|$|Local {{function}} bindings in Lisp have lexical scope, {{and variable}} bindings also have lexical scope by default. By contrast with GO labels, {{both of these}} have indefinite extent. When a lexical function or variable binding is established, that binding continues to exist {{for as long as}} references to it are possible, even after the construct which established that binding has terminated. References to lexical variables and functions after the termination of their establishing construct are possible thanks to <b>lexical</b> <b>closures.</b>|$|R
40|$|In {{this chapter}} I {{would like to}} {{introduce}} Squeak’s syntax to programmers of other languages. Note that Squeak is a Smalltalk, so any book on Smalltalk {{can be used to}} obtain another point of view on the syntax and the model. Smalltalk was influenced by the following languages: Lisp (<b>lexical</b> <b>closure,</b> uniformity, control constructs defined in the language itself), LOGO (a dynamic functional language), and Simula (object-oriented programming). The syntax of Squeak is based on (1) 6 reserved identifiers; (2) constant expressions called literal objects, which includes numbers, characters, strings, symbols, and arrays; (3) identifiers and assignment; (4) messages; and (5) block closures (an anonymous and deferred sequence of expressions). Based on these syntactical elements, conditional expressions and iterations are naturally expressed without requiring any dedicated constructs. Smalltalk is a dynamically typed language, and therefore you never have to specify the type of a variable or method argument. Parts of this chapter are freely adapted from the Squeak Quick Reference Manual, written by Andrew C. Greenberg and Andrew P. Black. I thank them for the work they have done and for granting me permission to make use of it. I will begin by giving you an overview of the syntax and will then go step by step into the details. If you are interested only in the syntax, you skip the firs...|$|E
25|$|Common Lisp is a {{successor}} to MacLisp. The primary influences were Lisp Machine Lisp, MacLisp, NIL, S-1 Lisp, Spice Lisp, and Scheme. It has many {{of the features of}} Lisp Machine Lisp (a large Lisp dialect used to program Lisp Machines), but was designed to be efficiently implementable on any personal computer or workstation. Common Lisp has a large language standard including many built-in data types, functions, macros and other language elements, as well as an object system (Common Lisp Object System). Common Lisp also borrowed certain features from Scheme such as lexical scoping and <b>lexical</b> <b>closures.</b>|$|R
50|$|In {{programming}} languages, <b>closures</b> (also <b>lexical</b> <b>closures</b> {{or function}} closures) are techniques for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure {{is a record}} storing a function together with an environment: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created. A closure—unlike a plain function—allows the function to access those captured variables through the closure's copies of their values or references, even when the function is invoked outside their scope.|$|R
40|$|The Flight {{programming}} language {{is based on}} a small kernel of primitives su cient to linearly allocate memory, compile stack-based machine code, associate a name to a memory address, look up a memory address from its name, and execute the code there. Although self-contained, this kernel lacks useful features such as the freeing of allocated memory, interactive use of the underlying machine, inline compilation of code and strings, string and number output, ow control constructs, elementary multiplication and division, function composition, <b>lexical</b> <b>closures,</b> and higher-order functions. These features are added to Flight without additions the kernel and without the use of software tools other than Flight itself. The code for these features adds up to about 300 lines of sourc...|$|R
5000|$|Racket's core {{language}} includes macros, modules, <b>lexical</b> <b>closures,</b> tail calls, delimited continuations, parameters (fluid variables), software contracts, {{green and}} OS threads, and more. The language {{also comes with}} primitives, such as eventspaces and custodians, which control resource management and enables the language to act like an operating system for loading and managing other programs. [...] Further extensions to the language are created with the powerful macro system, which together with the module system and custom parsers can control all aspects of a language. [...] Unlike programming languages that lack macro systems, most language constructs in Racket are written {{on top of the}} base language using macros. These include a mixin class system, a component (or module) system as expressive as ML's, and pattern matching.|$|R
50|$|Note: Some {{speakers}} call any {{data structure}} that binds a <b>lexical</b> environment a <b>closure,</b> but the term usually refers specifically to functions.|$|R
50|$|The term {{spaghetti}} stack {{is closely}} associated with implementations of programming languages that support continuations. Spaghetti stacks are used to implement the actual run-time stack containing variable bindings and other environmental features. When continuations must be supported, a function's local variables cannot be destroyed when that function returns: a saved continuation may later re-enter into that function, and will expect not only the variables there to be intact, {{but it will also}} expect the entire stack to be present so the function is able to return again. To resolve this problem, stack frames can be dynamically allocated in a spaghetti stack structure, and simply left behind to be garbage collected when no continuations refer to them any longer. This type of structure also solves both the upward and downward funarg problems, as a result first-class <b>lexical</b> <b>closures</b> are readily implemented in that substrate.|$|R
50|$|Thirdly, {{perhaps most}} importantly, even if <b>lexical</b> <b>closures</b> are not exploited, {{the use of}} lexical scope {{isolates}} program modules from unwanted interactions. Due to their restricted visibility, lexical variables are private. If one module A binds a lexical variable X, and calls another module B, references to X in B will not accidentally resolve to the X bound in A. B simply has no access to X. For situations in which disciplined interactions through a variable are desirable, Common Lisp provides special variables. Special variables allow for a module A {{to set up a}} binding for a variable X which is visible to another module B, called from A. Being able to do this is an advantage, and being able to prevent it from happening is also an advantage; consequently, Common Lisp supports both lexical and dynamic scope.|$|R
40|$|We used Common Lisp {{to build}} a complex and {{powerful}} interactive graphics simulation system called "Prism", for planning radiation therapy. Special features of Common Lisp {{that we used to}} advantage include: <b>lexical</b> <b>closures,</b> the Common Lisp Object System (CLOS), and the Common Lisp binding to the X window system (CLX). We use events, indirect invocation and mediators to achieve modularity. Some of the components of Prism are: a contoured volume editor, computed medical images, a rule based function to generate target volumes, andaradiation dose computation function. To achieve fast floating point computation in the latter, we applied both generic and vendor specific optimizations. The result is a system that is routinely used in the University of Washington Cancer Center, by people with no programming expertise. Our experience shows that Lisp is practical, powerful and efficient for interactive graphics, complex modeling and intensive oating point computations such as radiation dose modeling. Additional work in progress includes a medical image server and an interface to an on-line anatomy atlas...|$|R
40|$|This study {{measures}} comparative <b>lexical</b> and syntactic <b>closure</b> {{rates in}} annotated Chinese newspaper corpora from the Academica Sinica Balanced Corpus and the University of Penn- sylvania's Chinese Treebank. It then draws in- ferences {{as to how}} large such corpora need be to be representative models of subject-matterconstrained language domains within the same genre. Future large corpora should be built incrementally only by combining smaller representative sublanguage collections...|$|R
50|$|When a {{reference}} to a method can be passed around for later execution, a problem arises about what to do when the method has references to variables/parameters in its <b>lexical</b> scope. C# <b>closures</b> can access any variable/parameter from its lexical scope. In Java's anonymous inner classes, only references to final members of the lexical scope are allowed, thus requiring the developer to mark which variables to make available, and in what state (possibly requiring boxing).|$|R
40|$|Semantic Web and Linked Open Data {{provide a}} {{potential}} platform for interoperability of scientific data, offering a flexible model for providing machine-readable and queryable metadata. However, RDF and SPARQL gained limited adoption within the scientific community, mainly {{due to the}} lack of support for managing massive numeric data, along with certain other important features – such as extensibility with user-defined functions, query modularity, and integration with existing environments and workflows. We present the design, implementation and evaluation of Scientific SPARQL – a language for querying data and metadata combined, represented using the RDF graph model extended with numeric multidimensional arrays as node values – RDF with Arrays. The techniques used to store RDF with Arrays in a scalable way and process Scientific SPARQL queries and updates are implemented in our prototype software – Scientific SPARQL Database Manager, SSDM, and its integrations with data storage systems and computational frameworks. This includes scalable storage solutions for numeric multidimensional arrays and an efficient implementation of array operations. The arrays can be physically stored in a variety of external storage systems, including files, relational databases, and specialized array data stores, using our Array Storage Extensibility Interface. Whenever possible SSDM accumulates array operations and accesses array contents in a lazy fashion. In scientific applications numeric computations are often used for filtering or post-processing the retrieved data, which can be expressed in a functional way. Scientific SPARQL allows expressing common query sub-tasks with functions defined as parameterized queries. This becomes especially useful along with functional language abstractions such as <b>lexical</b> <b>closures</b> and second-order functions, e. g. array mappers. Existing computational libraries can be interfaced and invoked from Scientific SPARQL queries as foreign functions. Cost estimates and alternative evaluation directions may be specified, aiding the construction of better execution plans. Costly array processing, e. g. filtering and aggregation, is thus preformed on the server, saving the amount of communication. Furthermore, common supported operations are delegated to the array storage back-ends, according to their capabilities. Both expressivity and performance of Scientific SPARQL are evaluated on a real-world example, and further performance tests are run using our mini-benchmark for array queries...|$|R

