3|1|Public
5000|$|A {{validated}} generic type is {{a generic}} type where a condition indicates how the type can be used. Such types {{need not have}} generic parameters. For instance, one can declare that a type is [...] {{if it has a}} <b>less-than</b> <b>operator</b> as follows: ...|$|E
5000|$|The C++'s Standard Template Library has the {{function}} , which merges two sorted ranges of iterators, and , which merges two consecutive sorted ranges in-place. In addition, the [...] (linked list) class {{has its own}} [...] method which merges another list into itself. The type of the elements merged must support the <b>less-than</b> (...) <b>operator,</b> or it must be provided with a custom comparator.|$|E
40|$|Sorting {{is one of}} {{the most}} well studied {{algorithmic}} problems in Computer Science. It is a fundamental building block in many other algorithms. In this dissertation, we consider several variants of the classical sorting problem all motivated by modern challenges or technologies. We present algorithms to solve these problem variants and provide lower bounds when possible. The online list labeling problem attempts to maintain integer labels for a dynamic ordered list. As new elements are inserted, old elements may need to be relabeled to make room in the label space. Previous work has looked at minimizing the total number of relabels that need to be performed. However we analyze the version of the problem where the goal is to minimize the maximum number of times any one element is relabeled. We call this the online house numbering problem. This problem is motivated by the modern solid-state memories which have a limited write life. We provide two solutions to the house numbering problem: one that comes within a logarithmic factor of the optimal label space size with optimal maximum relabelings and one that has optimal label space size, but is a logarithmic factor off of the optimal maximum relabelings. Sorting can also mean to split a set of elements into groups of similar elements. Cryptographic handshakes, where two parties securely identify if they belong to a privileged group, motivate studying this form of sorting that we call equivalence class sorting. Instead of sorting with a <b>less-than</b> <b>operator,</b> our goal is to use an equivalence relation operator to group a set of elements into their equivalence classes. We prove tight lower bounds that match the run time of previously known algorithms as well as provide algorithms for performing equivalence class sorting in several models of parallel computation. Classical sorting algorithms output the sorted order for a given input list. When the data is continually changing or "evolving", the output of a classical algorithm cannot be guaranteed to be accurate. So we consider a new model for algorithms called the evolving data model. In this model, every time a comparison is performed, two elements that are adjacent in the underlying order are swapped. No algorithm can ever compute the exact correct order of the elements in such an evolving list. Instead the goal is to, over time, converge to be as close to the correct order as possible. We show that simply repeatedly running insertion sort achieves the best possible O(n) inversions relative to the underlying order with exponentially high probability...|$|E
40|$|Mathematics in Defence 2011 Abstract. We review transreal {{arithmetic}} {{and present}} transcomplex arithmetic. These arithmetics have no exceptions. This leads to incremental improvements in computer hardware and software. For example, {{the range of}} real numbers, encoded by floating-point bits, is doubled {{when all of the}} Not-a-Number(NaN) states, in IEEE 754 arithmetic, are replaced with real numbers. The task of programming such systems is simplified and made safer by discarding the unordered relational operator,leaving only the <b>operators</b> <b>less-than,</b> equal-to, and greater than. The advantages of using a transarithmetic in a computation, or transcomputation as we prefer to call it, may be had by making small changes to compilers and processor designs. However, radical change is possible by exploiting the reliability of transcomputations to make pipelined dataflow machines with a large number of cores. Our initial designs are for a machine with order one million cores. Such a machine can complete the execution of multiple in-line programs each clock tic...|$|R

