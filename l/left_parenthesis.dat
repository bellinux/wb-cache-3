19|7|Public
5000|$|Ruby: <b>left</b> <b>parenthesis,</b> left square bracket, or left curly bracket ...|$|E
5000|$|... add [...] at the {{beginning}} of each expression and after each <b>left</b> <b>parenthesis</b> in the original expression; and ...|$|E
5000|$|If φ is {{a natural}} number, then the result of concatenating s, <b>left</b> <b>{{parenthesis}},</b> φ, and right parenthesis (in that order, from left to right) denotes the successor of φ.|$|E
50|$|The {{proof that}} the {{language}} of balanced (i.e., properly nested) parentheses is not regular follows the same idea. Given p, there is a string of balanced parentheses that begins with more than p <b>left</b> <b>parentheses,</b> so that y will consist entirely of <b>left</b> <b>parentheses.</b> By repeating y, we can produce a string that does not contain {{the same number of}} <b>left</b> and right <b>parentheses,</b> and so they cannot be balanced.|$|R
40|$|Let T(n) be {{the set of}} all well-formed {{parentheses}} {{strings of}} length 2 n. We show that the elements of T(n) can be listed so that successive strings differ by the transposition of a left and a right parenthesis. Furthermore, between the two parentheses that are transposed, only <b>left</b> <b>parentheses</b> occur. Our listing is a modification of the well-known Eades-McKay [4] algorithm for generating combinations. Like that algorithm, ours generates strings from the lexicographically greatest string to the lexicographically least and can be implemented so that each string is generated in constant time, in an amortized sense. 1 Introduction Among the classes of strings studied by mathematicians and computer scientists, perhaps none has been examined so intensely as the class of well-formed parentheses strings. There is a natural correspondence, right parentheses to internal nodes and <b>left</b> <b>parentheses</b> to leaves, between these strings and extended binary trees. As a consequence, one representation is [...] ...|$|R
5000|$|It can {{be shown}} that any {{expression}} matched by the grammar has a balanced number of <b>left</b> and right <b>parentheses,</b> and any nonempty initial segment of a formula has more <b>left</b> than right <b>parentheses.</b> This fact {{can be used to}} give an algorithm for parsing formulas. For example, suppose that an expression x begins with [...] Starting after the second symbol, match the shortest subexpression y of x that has balanced parentheses. If x is a formula, there is exactly one symbol left after this expression, this symbol is a closing parenthesis, and y itself is a formula. This idea can be used to generate a recursive descent parser for formulas.|$|R
50|$|Thus {{there are}} four {{equivalent}} formulations of BCL, depending on the manner of encoding the triplet (K, S, <b>left</b> <b>parenthesis).</b> These are (00, 01, 1) (as in the present version), (01, 00, 1), (10, 11, 0), and (11, 10, 0).|$|E
5000|$|Conversational Monitor System (CMS) uses {{a single}} <b>left</b> <b>parenthesis</b> to {{separate}} options {{at the end}} of the command from the other arguments. For example, in the following command the options indicate that the target file should be replaced if it exists, and the date and time of the source file should be retained on the copy: ...|$|E
50|$|Whenever the {{identifier}} {{appears in}} the source code it is replaced with the replacement token list, which can be empty. For an identifier declared to be a function-like macro, it is only replaced when the following token is also a <b>left</b> <b>parenthesis</b> that begins the argument list of the macro invocation. The exact procedure followed for expansion of function-like macros with arguments is subtle.|$|E
5000|$|The {{inductive}} definition {{can also}} be rephrased {{in terms of a}} closure operation (Enderton 2002). Let V denote a set of propositional variables and let XV denote the set of all strings from an alphabet including symbols in V, <b>left</b> and right <b>parentheses,</b> and all the logical connectives under consideration. Each logical connective corresponds to a formula building operation, a function from XXV to XXV: ...|$|R
50|$|The {{shunting}} yard algorithm {{can also be}} applied to produce prefix notation (also known as Polish notation). To do this one would simply start {{from the end of}} a string of tokens to be parsed and work backwards, reverse the output queue (therefore making the output queue an output stack), and flip the <b>left</b> and right <b>parenthesis</b> behavior (remembering that the now-left parenthesis behavior should pop until it finds a now-right parenthesis).|$|R
5000|$|Unlike with functions, the {{notational}} ambiguities can {{be overcome}} more or less easily by means of additional definitions, i. e. rules of precedence, and/or associativity of the operators. In the programming language C e. g. the operator [...] for subtraction is left-to-right-associative which means that [...] is defined as [...] and the operator [...] for assignment is right-to-left-associative which means that [...] is defined as [...] In the programming language APL {{there is only one}} rule: from right to <b>left</b> − but <b>parentheses</b> first.|$|R
50|$|The quasi-quotation marks {{here are}} {{interpreted}} just the same. Where φ and ψ denote wffs of L, ⌜(φ v ψ)⌝ denotes {{the result of}} concatenating <b>left</b> <b>parenthesis,</b> the wff denoted by φ, space, v, space, the wff denoted by ψ, and right parenthesis (in that order, from left to right). Just as before, rule 2.5 (unlike rule 2.5) entails, e.g., that if p and q are wffs of L, then (p v q) is a wff of L.|$|E
50|$|The code {{is based}} on five base signs: two triangles (one angled upwards and the other angled downwards), one {{diagonal}} line, one solid square box and one empty square box representing black, white and the primary colors: red (magenta), blue (cyan), and yellow. Colors derived from other colors have the symbols of the combined colors, creating derivative colors (orange, green, purple and brown) and dark or white tones. Metalized colors like silver or gold are shown with a <b>left</b> <b>parenthesis</b> on the symbols.|$|E
5000|$|In English-speaking countries, long {{division}} {{does not}} use the division slash [...] or obelus [...] signs but instead constructs a tableau. The divisor is separated from the dividend by a right parenthesis [...] or vertical bar the dividend is separated from the quotient by a vinculum (i.e., overbar). The combination of these two symbols is sometimes known as a long division symbol or division bracket. It developed in the 18th century from an earlier single-line notation separating the dividend from the quotient by a <b>left</b> <b>parenthesis.</b>|$|E
5000|$|Extensible {{characters}} are {{specified in the}} [...] table, using a series of four-byte words specifying the top, middle, bottom and repeated sections of an extensible character. For instance, the character at left below would be obtained by setting ( [...] , , , [...] ) to the character codes for (/, <, \, |). The first three character codes can be set to zero. For instance, if [...] were set to 0 in the previous example, the result would change from the brace drawn at <b>left</b> to the <b>parenthesis</b> drawn to its right.|$|R
5000|$|In earlier {{versions}} of C, if a function was not previously declared and its name occurred in an expression followed by a <b>left</b> <b>parenthesis,</b> it was implicitly declared as a function that returns an [...] and nothing was assumed about its arguments. In this case the compiler {{would not be able}} to perform compile-time checking of argument types and Syntax arity when the function was applied to some arguments. This can cause problems. The following code illustrates a situation in which the behavior of an implicitly declared function is undefined.|$|E
5000|$|The {{sequence}} of pushes and pops performed by Knuth's sorting algorithm as it sorts a stack-sortable permutation form a Dyck language: reinterpreting a push as a <b>left</b> <b>parenthesis</b> and a pop {{as a right}} parenthesis produces a string of balanced parentheses. Moreover, every Dyck string comes from a stack-sortable permutation in this way, and every two different stack-sortable permutations produce different Dyck strings. For this reason, the number of stack-sortable permutations of length n {{is the same as}} the number of Dyck strings of length 2n, the Catalan number ...|$|E
50|$|Scott Fahlman first {{suggested}} {{the use of}} the colon with the <b>left</b> <b>parenthesis</b> to iconically represent a frowning face on the Internet in what has become a well-known emoticon. In this form the frown is entirely presented as a curve of the lips facing away from the eyes.Specifically, frowns that incorporate the furrowing of the brow are a response to perceived obstacles to the achievement of goals, while frowns that involve movement of the cheeks reflect an unpleasant reaction. Just as smiling alone can make one feel better, frowning can make one feel worse. In a scientific study participants that held their face in a frown ranked images as more unpleasant than participants who viewed the images with a neutral facial expression. In a similar test, participants reported increased anger with the manipulated expression of a frown and they also ranked cartoons they saw as less funny than participants with the manipulated expression of a smile.|$|E
5000|$|Digits were {{represented}} internally using excess-3 ("XS3") {{binary coded decimal}} (BCD) arithmetic with six bits per digit using the same value as the digits of the alphanumeric character set (and one parity bit per digit for error checking), allowing 11-digit signed magnitude numbers. But {{with the exception of}} one or two machine instructions, UNIVAC was considered by programmers to be a decimal machine, not a binary machine, and the binary representation of the characters was irrelevant. If a non-digit character was encountered in a position during an arithmetic operation the machine passed it unchanged to the output, and any carry into the non-digit was lost. (Note, however, that a peculiarity of UNIVAC I's addition/subtraction circuitry was that the [...] "ignore", space, and minus characters were occasionally treated as numeric, with values of -3, -2, and -1 respectively, and the apostrophe, ampersand, and <b>left</b> <b>parenthesis</b> were occasionally treated as numeric, with values 10, 11, and 12.) ...|$|E
5000|$|The 1403 chain or train {{contained}} 240 characters, however numerous duplications {{allowed a}} line to be printed in less than the 0.4 s required for one full rotation. The original standard [...] "A" [...] chain contained 48 different characters, repeated five times each. A [...] "preferred character set" [...] variant used in later models printed the same 48 characters, but varied the number of appearances: 10 digits appeared eight times each, 26 upper-case letters appeared four times each, and 12 special characters [...] appeared eight (first four), four (middle four) or two (last four characters) times each.Special chains or trains could be ordered for other character sets. Scientific users, for example, would use a chain that had the <b>left</b> <b>parenthesis,</b> the right parenthesis, and the plus sign {{in place of the}} per cent sign (%), the lozenge (⌑), and the ampersand (&). The numerics chain had 15 copies each of only 16 characters. The [...] "T" [...] chain for general text had two copies of 120 characters, including upper-and lower-case letters and numerous special symbols.|$|E
5000|$|PM 's dots {{are used}} {{in a manner similar}} to parentheses. Each dot (or {{multiple}} dot) represents either a left or right parenthesis or the logical symbol ∧. More than one dot indicates the [...] "depth" [...] of the parentheses, for example, [...] ".", [...] ":" [...] or [...] ":.", [...] "::". However the position of the matching right or <b>left</b> <b>parenthesis</b> is not indicated explicitly in the notation but has to be deduced from some rules that are complicated, confusing and sometimes ambiguous. Moreover, when the dots stand for a logical symbol ∧ its left and right operands have to be deduced using similar rules. First one has to decide based on context whether the dots stand for a left or right parenthesis or a logical symbol. Then one has to decide how far the other corresponding parenthesis is: here one carries on until one meets either a larger number of dots, or the same number of dots next that have equal or greater [...] "force", or the end of the line. Dots next to the signs ⊃, ≡,∨, =Df have greater force than dots next to (x), (∃x) and so on, which have greater force than dots indicating a logical product ∧.|$|E
5000|$|Encouraged by Julian Tuwim to {{participate}} in the Young Poets Competition (Turniej Młodych Poetów) organized next spring by the Wiadomości Literackie, the most important literary periodical in Poland at the time, she won an honourable mention (third class) with the poem [...] "Gramatyka" [...] (The Grammar), printed in the issue of 15 July 1934 of the weekly that was devoted in part to the results of the competition. She was 17 years old; most if not all of the other 22 finalists (like Tadeusz Hollender, b. 1910, and Anna Świrszczyńska, b. 1909, who won first prizes, or Witold Makowiecki, b. 1903, who won an honourable mention, first class, and Juliusz Żuławski, b. 1910, honourable mention, third class) were her seniors in age. [...] Seven weeks later, in its edition of 2 September 1934, Wiadomości Literackie will revisit its poetry competition by publishing a list of additional book prizes awarded to the winners: for her contribution, Zuzanna Ginczanka will receive a collection of Michelangelos poetry in the translation of Leopold Staff. [...] Ginczankas poem, which opens boldly with a punctuation mark (a <b>left</b> <b>parenthesis),</b> deals with parts of speech, describing each in a poetic way beginning with the adjective, then taking on the adverb, and ending with a philosophico-philological analysis of the personal pronoun ("I without you, you without me, amounts to nought"; line 30) ...|$|E
30|$|Third, {{to speak}} formulas, a simple parser was {{designed}} to convert math formulas into English terms. One complication for this process was that people do not speak formulas precisely, so off-the-shelf libraries produced stilted language, e.g. the formula “z*(x+ 5)” being spoken as “z times <b>left</b> <b>parenthesis</b> x....” To avoid this, our parser did not translate grouping characters to speech. Instead, a plain-English version of the formula was spoken (e.g., “z times x plus 5 ”), while the original exact formula spoken was shown in the chat log so that the precise values were clear (shown in Fig.  4). Another challenge for articulating formulas was the difficulty in disambiguating certain symbols, such as {{the difference between a}} function name and a series of multiplied variables (e.g., “tan(x)” is “tangent of x”, but “an(x)” is typically “a n times x”). This was handled by checking a table of common functions and constants that were handled before breaking groups down into simpler variables and terms.|$|E
30|$|Srndic and Laskov [7] {{introduced}} PJScan, 20 {{a static}} analysis and anomaly detection {{tool for the}} detection of malicious JavaScript code inside a PDF file. After the JavaScript code has been found and extracted, a lexical analysis is applied using a JavaScript interpreter. Lexical analysis represents the JavaScript code as a sequence of tokens. For example, <b>left</b> <b>parenthesis,</b> plus, right parenthesis, etc. By using these tokens PJScan tries to induce learning detection models that differentiate between benign and malicious PDF files. Liu et al. [14] combined both static and dynamic analysis to detect potential infection attempts in the context of JavaScript execution. First, they extract a set of static features, and then they insert context monitoring code into a PDF document, a code that later cooperates with the runtime monitor used for the detection task. Additional work done by Corona et al. [15] in which they presented the Luxor system which applied this combination of static and dynamic analysis as well. Their idea involved translating the JavaScript code into an API reference pattern, and accumulating the times of presences for every API reference. By doing this they tried to find a discriminative set of references that characterizes malware code in order to automatically differentiate this code from benign code within PDF files.|$|E
40|$|Da Costa’s paraconsistent {{systems of}} the series Cm (for finite m) (see [C 1], [C 2], and esp. [C 3], pp. 237 ff.) share {{important}} features with transitive logic, TL (which has been gone into in [P 1] and [P 2]), namely, they all coincide in that: (c 1) they possess a strong negation, ‘¬’, a conditional, ‘⊃’, a conjunction, ‘∧’, and a disjunction, ‘∨’, with respect {{to which they are}} conservative extensions of CL or Classical Logic; (c 2) they possess a non-strong negation, ‘N ’ (notations are different for systems C) which does not possess all properties of classical negation, but for which the following schemata are theorematic (I use the letters ‘p’, ‘q’, etc as schematic letters; my notational conventions are basically Church’s: associativity leftwards; a dot stands for a <b>left</b> <b>parenthesis</b> with its mate as far to the right as posible) : p∨Np, NNp⊃p, p⊃Np⊃Np; (c 3) they possess a monadic functor, ‘#’, for which the following schemata are theorematic: N#p⊃. p∧Np, #p∧#q⊃. #(p∨q) ∧#(p∧q) ∧#(p⊃q) ∧#Np; (c 4) they are almost unique anong paraconsistent logics in their having the three aforementioned features. (In general systems with features of that sort have been called ‘extensional paraconsistent logics ’ by Diderik Batens, who has also proposed systems bearing a kinship of sorts t...|$|E

