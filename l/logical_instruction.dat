5|54|Public
5000|$|Logical {{instructions}} are Move Characters, Move with offset, Move Immediate, Move Numerics, Move Zones, Compare Logical Immediate, Compare Logical Characters, Edit, And immediate, Or immediate, Test under Mask, and Translate. One <b>logical</b> <b>instruction</b> {{unique to the}} Model 20 is [...] "Halt and Proceed" [...] (HPR, operation code X'99') which will quiesce input/output and stop the processor displaying a code to the operator. Operation can be restarted by pressing the [...] "start" [...] button.|$|E
40|$|Parallelism {{suffers from}} a lack of {{programming}} languages both simple to handle and {{able to take advantage of}} present parallel computer power. If parallelism expression is too high level, compilers have to perform complex optimizations leading often to poor performances. One the other hand, too low level parallelism transfers difficulties toward the programmer. In this paper, we propose a new programming language that integrates both a synchronous data-parallel programming model and an asynchronous execution model. The synchronous data-parallel programming model allows a single and safe program designing. The asynchronous execution model yields an efficient execution on present MIMD architectures without any program transformation. Our language relies on a <b>logical</b> <b>instruction</b> ordering exploited by specific send/receive communications. It allows to express only the effective data dependences between processors. This ability is enforced by a possible send/receive unmatching useful for irr [...] ...|$|E
40|$|Several ILP limit studies {{indicate}} the presence of considerable ILP across dynamically far-apart instructions in program execution. This paper proposes a hardware mechanism, dynamic vectorization (DV), {{as a tool for}} quickly building up a large <b>logical</b> <b>instruction</b> window. Dynamic vectorization converts repetitive dynamic instruction sequences into vector form, enabling the processing of instructions from beyond the corresponding program loop to be overlapped with the loop. This enables vector-like execution of programs with relatively complex static control flow that may not be amenable to static, compile time vectorization. Experimental evaluation shows that a large fraction of the dynamic instructions of four of the six SPECInt 92 programs can be captured in vector form. Three of these programs exhibit significant potential for ILP improvements from dynamic vectorization, with speedups of more than a factor of 2 in a scenario of realistic branch prediction and perfect memory disambigua [...] ...|$|E
40|$|This study {{examined}} conditional reasoning with premises referring to associations between professions and traits that were either stereotypical (“Accountants like mathematics”) or counter-stereotypical (“Nurses like mathematics”). In the first study, {{participants were asked}} to rate the degree of certainty of MP and AC inferences based on an individual's profession (“John is an accountant”) or based on an individual trait (“John likes mathematics”), under pragmatic instructions or under strong <b>logical</b> <b>instructions,</b> using a context that required them to put themselves in the position of a fictitious actor. Results showed that both forms of inference were rated as more certain with stereotypical premises than with counter-stereotypical premises and that <b>logical</b> <b>instructions</b> increased the overall strength of inferences without reducing {{the difference between the two}} forms of premise. The second study presented both stereotypical premises and inferences with believable and unbelievable conclusions, with no additional context. Participants were given inferences under pragmatic <b>instructions</b> followed by <b>logical</b> <b>instructions,</b> or only under <b>logical</b> <b>instructions.</b> Results show that ratings for both MP and AC inferences were higher for stereotypical than counter-stereotypical items, with a similar difference for inferences with belief-consistent and belief-inconsistent conclusions. <b>Logical</b> <b>instructions</b> clearly reduce the influence of premise type, on both types of problems. Receiving pragmatic instructions initially reduced overall levels of normative responding for stereotypical, but not for classical belief-bias inferences. Individual differences in responding indicate that the debiasing effect of <b>logical</b> <b>instructions</b> depends on initial level of bias shown under pragmatic instructions. The results are interpreted as supporting dual-process theories of reasoning. [URL] ar. jinfo:eu-repo/semantics/publishe...|$|R
5000|$|The {{processor}} maintains internal flag bits (a status register), which {{indicate the}} results of arithmetic and <b>logical</b> <b>instructions.</b> The flags are: ...|$|R
5000|$|A {{standard}} instruction set, including fixed-point binary arithmetic and <b>logical</b> <b>instructions,</b> present on all System/360 models (except the model 20, see below).|$|R
40|$|VLIW {{architectures}} {{are popular}} in embedded systems because they offer high-performance processing at low cost and energy. The major problem with traditional VLIW designs {{is that they}} do not scale efficiently due to bottlenecks that result from centralized resources and global communication. Multicluster designs have been proposed to solve the scaling problem of VLIW datapaths, while much less work has been done on the control path. In this paper, we propose a distributed control path architecture for VLIW processors (DVLIW) to overcome the scalability problem of VLIW control paths. The architecture simplifies the dispersal of complex VLIW instructions and supports efficient distribution of instructions through a limited bandwidth interconnect, while supporting compressed instruction encodings. DVLIW employs a multicluster design where each cluster contains a local instruction memory that provides all intra-cluster control. All clusters have their own program counter and instruction sequencing capabilities, thus instruction execution is completely decentralized. The architecture executes multiple instruction streams at the same time, but these streams collectively function as a single <b>logical</b> <b>instruction</b> stream. Simulation results show that DVLIW processors reduce the number of cross-chip control signals by approximately two orders of magnitude while incurring a small performance overhead to explicitly manage the instruction streams. 1...|$|E
40|$|Nearly {{four decades}} after its first {{implementation}} in the IBM 360 / 91 floating-point unit, out-of-order execution remains a powerful microarchitectural tool for improving performance by tolerating long execution latencies. Increasing relative memory latency and the relentless quest for deeper pipelining and higher frequency are driving {{the need for}} larger and larger instruction windows. These windows must be large in order to extract enough instruction-level parallelism to fill these deep pipelines and successfully overlap hundreds of cycles of memory latency. Unfortunately, physical constraints and unmanageable design complexity prevent designers from scaling conventional structures like reorder buffers and physical register files to span hundreds of active instructions. This paper proposes a radically different approach that employs multiple small on-chip cores to build a giant <b>logical</b> <b>instruction</b> window that can span thousands of in-flight instructions. We advocate profligate execution, where many [...] sometimes most [...] instructions are executed in each processing element to reduce the need to communicate and synchronize across processing elements, and disjoint execution threads are spawned only when needed to prevent stalling due to a full instruction window. We describe the microarchitectural structures needed to support profligate execution and show that with a 4 -way chip multiprocessor, average speedups of 17 % and 212 % are achievable for integer and floating point benchmarks, respectively. We also show {{that in addition to}} reducing application latency, profligate execution can provide a system throughput benefit as well with speedups that are super-linear with respect to the number of processors in the system. ...|$|E
5000|$|With all {{arithmetic}} and <b>logical</b> <b>instructions</b> using absolute (direct) addressing, bits 14 and 13 of {{the address}} field {{are used to}} indicate the indexing mode as follows: ...|$|R
25|$|The <b>logical</b> <b>instructions</b> {{consist of}} those for {{performing}} bitwise logical operations and conditional moves on the integer registers. The bitwise <b>logical</b> <b>instructions</b> perform AND, NAND, NOR, OR, XNOR, and XOR between two registers or a register and literal. The conditional move instructions test a register as a signed quadword to zero and move if the specified condition is true. The specified conditions are equality, inequality, {{less than or}} equal to, less than, greater than or equal to, and greater than. The shift instructions perform arithmetic right shift, and logical left and right shifts. The shift amount is given by a register or literal. <b>Logical</b> and shift <b>instructions</b> use the integer operate instruction formats.|$|R
50|$|Only the ADD, ADDC and SUBB {{instructions}} set PSW flags. The INC, DEC, and <b>logical</b> <b>instructions</b> do not. The CJNE instructions {{modify the}} C bit only, to the borrow {{that results from}} operand1−operand2.|$|R
40|$|Abstract—In this paper, {{the control}} unit for the 16 -bit CPU of a {{microprocessor}} trainer is designed, implemented, and tested. The {{most important part}} of the control unit is the PIC microcontroller 18 F 452. The microprogram for the PIC was developed to execute the arithmetic and <b>logical</b> <b>instructions.</b> The control unit of this trainer i...|$|R
50|$|The eSi-RISC {{instruction}} set includes arithmetic and <b>logical</b> <b>instructions</b> (including barrel-shift, multiply and divide), comparisons, load and stores, branches and calls {{as well as}} system level instructions to control interrupts and enter lower power states. There are also a number of optional instructions and addressing modes that can be selected, should a specific application require them.|$|R
40|$|Matlab is very {{widely used}} in {{scientific}} computing, but Matlab computational efficiency is lower than C language program. In order to improve the computing speed, some toolbox can use GPU to accelerate the computation. This paper describes GPU working principle, our experiments and results analysis of parallel computing by using GPU based on Matlab. Experimental results show that for parallel operations, GPU computing speed is faster than CPU, for the <b>logical</b> <b>instructions,</b> GPU computing speed is slower than CPU...|$|R
50|$|The Data General Nova, Motorola 6800 family, and MOS Technology 6502 {{family of}} {{processors}} were families of processors {{with very few}} internal registers. Arithmetic and <b>logical</b> <b>instructions</b> were mostly performed against values in memory as opposed to internal registers. As a result, many instructions required a two-byte (16-bit) location to memory. Given that opcodes on these processors were only one byte (8 bits) in length, memory addresses could make up {{a significant part of}} code size.|$|R
50|$|Along with a carry flag, a sign {{flag and}} an {{overflow}} flag, the zero flag {{is used to}} check {{the result of an}} arithmetic operation, including bitwise <b>logical</b> <b>instructions.</b> It is set if an arithmetic result is zero, and reset otherwise. This includes results which are not stored, as most traditional instruction sets implement the compare instruction as a subtract where the result is discarded. It is also common that processors have a bitwise AND-instruction that does not store the result.|$|R
50|$|The {{speed of}} {{arithmetic}} operations {{was about the}} same as the Elliott 402 computer, which could add in 204 microseconds and multiply in 3366 microseconds. The Pegasus basic instruction cycle time for add/subtract/move and <b>logical</b> <b>instructions</b> was 128 microseconds. Multiply, divide, justify and shift instructions took a variable time to complete. Transfers to and from magnetic drum were synchronous and had to be optimised where possible. The layout of blocks on the magnetic drum was interleaved to allow some processing between transfers to/from consecutive blocks.|$|R
50|$|Be able {{to execute}} <b>logical</b> {{functions}} and <b>instructions.</b>|$|R
40|$|International audienceJavaScript (JS) {{engines are}} virtual {{machines}} that execute JavaScript code. These engines find frequent application in web browsers like Google Chrome, Mozilla Firefox, Microsoft Internet Explorer and Apple Safari. Since, {{the purpose of}} a JS engine is to produce executable code, it cannot be run in a non-executable environment, and is susceptible to attacks like Just-in-Time (JIT) Spraying, which embed return-oriented programming (ROP) gadgets in arithmetic or <b>logical</b> <b>instructions</b> as immediate offsets. This paper introduces libmask, a JIT compiler extension to prevent the JIT-spraying attacks as an effective alternative to XOR based constant blinding. libmask transforms constants into global variables and marks the memory area for these global variables as read only. Hence, any constant is referred to by a memory address making exploitation of arithmetic and <b>logical</b> <b>instructions</b> more difficult. Further, these memory addresses are randomized to further harden the security. The scheme has been implemented and evaluated as a librddy extension to Google V 8 scripting engine with optimizations that contain performance overhead and make libmask a feasible approach. We demonstrate that libmask masks all the constants in JITed code, and effectively raise the bar for JIT-spray and JIT-ROP attacks. The average overhead incurred upon memory is less than 300 kilobytes, while in most benchmarks the memory overhead is less than 10 KB. The average performance overhead observed with optimizations measures is 5. 31 %. Further, this new approach shows a modest performance improvement over currently deployed constant blinding technique in Google V 8...|$|R
40|$|Many {{studies have}} shown that {{inferential}} behavior is strongly affected by access to real-life information about premises. However, {{it is also true that}} both children and adults can often make logically appropriate inferences that lead to empirically unbelievable conclusions. One way of reconciling these is to suppose that <b>logical</b> <b>instructions</b> allow inhibition of information about premises that would otherwise be retrieved during reasoning. On the basis of this idea, we hypothesized that it should be easier to endorse an empirically false conclusion on the basis of clearly false premises than on the basis of relatively believable premises. Two studies are presented that support this hypothesis. status: publishe...|$|R
50|$|The computer's machine {{language}} consisted of 34 <b>instructions,</b> including arithmetical, <b>logical</b> and control <b>instructions.</b>|$|R
40|$|Looping {{is one of}} the {{fundamental}} <b>logical</b> <b>instructions</b> used for repeating a block of code. It is used in programs across all programming languages. Traditionally, in languages like C, the for loop is used extensively for repeated execution of a block of code, due to its ease for use and simplified representation. This paper proposes a new way of representing the for loop to improve its runtime efficiency and compares the experimental statistics with the traditional for loop representation. It is found that for small number of iterations, the difference in computational time may not be considerable. But given any large number of iterations, the difference is noticeable. Comment: 3 pages, 2 figures, 2 table...|$|R
40|$|Boolean {{expansion}} of binary functions {{has been used}} in the representation of binary image operators. This representation scheme induced the creation of image processing architectures based on decision diagrams. In some situations, the application of this graph-based operator over the input images is faster than the corresponding conventional approach, in that the operators are constructively described by means of basic operators and set operations. However, when the conventional architecture exploits the bit parallelism of the microprocessor <b>logical</b> <b>instructions,</b> its performance often surpasses that of the graph-based system. This article proposes a novel approach, in which the decision diagrams guide the actions of the underlying conventional architecture, taking advantage of its parallelism, so that faster image processing can be achieved...|$|R
50|$|The out-of-box {{experience}} is typically {{the first impression}} a product creates, such as {{the ease with which}} a buyer can begin using the product. For hardware products, a positive OOBE can be created with <b>logical</b> easy-to-follow <b>instructions</b> and good quality of manufacturing.|$|R
40|$|We {{propose that}} {{processor}} hardware {{can be used}} more effectively if floating-point units are augmented to perform simple integer operations. Existing floating-point registers and datapaths are used to support these integer operations. Some integer instructions, those not used for computing addresses and accessing memory, can then be off-loaded to the floating-point units. Consequently, these integer instructions are decoupled from memory accessing, and additional instruction bandwidth is available for integer programs. This paper reports {{the results of a}} preliminary study of integer benchmark programs compiled for the SPARC architecture. The results indicate that between 10 % and 39 % of the instructions in the integer benchmarks can be executed in the augmented floating-point units. Furthermore, these instructions are all simple add, subtract and <b>logical</b> <b>instructions.</b> ...|$|R
30|$|The bit {{comparison}} operation Cb is implemented with a bitwise <b>logical</b> XOR <b>instruction,</b> assuming that each {{bit of the}} received word has been previously stored in an integer type variable. Table 6 shows {{the details of the}} implementation of this operation. Similarly, three machine cycles are necessary to implement the operation Cb.|$|R
40|$|GPU {{exhibits}} {{the capability}} for applications {{with a high}} level of parallelism despite its low cost. The support of integer and <b>logical</b> <b>instructions</b> by the latest generation of GPUs enables us to implement cipher algorithms more easily. However, decisions such as parallel processing granularity and memory allocation impose a heavy burden on programmers. Therefore, this paper presents results of several experiments that were conducted to elucidate the relation be-tween memory allocation styles of variables of AES and granularity as the parallelism exploited from AES encoding processes using CUDA with an NVIDIA GeForce GTX 285 (Nvidia Corp.). Results of these experiments showed that the 16 bytes/thread granularity had the highest perfor-mance. It achieved approximately 35 Gbps throughput. It also exhibited differences of memory allocation and granularity effects around 2 %– 30 % for performance in standard implementation. It shows that the decision of granularity and memory allocation is the most important factor for effective processing in AES encryption on GPU. Moreover, implementation with overlapping between processing and data transfer yielded 22. 5 Gbps throughput including the data transfer time...|$|R
40|$|This survey manual {{evaluates the}} {{important}} points of functionality of school facilities in <b>logical</b> order. <b>Instructions</b> are {{given for the}} use of the manual, and separate sections present guidelines for evaluation of the following [...] (1) site, (2) building structure, (3) administrative spaces, (4) classrooms, (5) special rooms, (6) general service areas, (7) heating, ventilation, and air conditioning, (8) lighting and electrical equipment, (9) fire protection, and (10) water supply and sanitary facilities. (FS) Do O 0 O mesa...|$|R
40|$|According to dual-process {{accounts}} of thinking, belief-based responses on reasoning tasks are generated as default {{but can be}} intervened upon in favor of logical responding, given sufficient time, effort, or cognitive resource. In this article, we present the results of 5 experiments in which participants were instructed to evaluate the conclusions of logical arguments {{on the basis of}} either their logical validity or their believability. Contrary to the predictions arising from these accounts, the logical status of the presented conclusion had a greater impact on judgments concerning its believability than did the believability of the conclusion on judgments about whether it followed logically. This finding was observed when instructional set was presented as a between-participants factor (Experiment 1), when instruction was indicated prior to problem presentation by a cue (Experiment 2), and when the cue appeared simultaneously with conclusion presentation (Experiments 3 and 4). The finding also extended to a range of simple and more complex argument forms (Experiment 5). In these latter experiments, belief-based judgments took significantly longer than those made under <b>logical</b> <b>instructions.</b> We discuss the implications of these findings for default interventionist {{accounts of}} belief bias. 16 page(s...|$|R
40|$|To include {{interactions}} with human users in simulations {{of the use}} of products, the most common approach is to couple human subjects to the behavioral product model in the simulation loop using interfaces based on VR and haptics. Replacing human subjects by human models with simulation capabilities could offer a cost-saving alternative. Currently available human models have not yet been deployed this way. This paper explores the possibilities to achieve mutual closed-loop coupling between human models and artifact models for enabling fully software-based interaction simulations. We have not only investigated human control in simulations, but also solutions to include embedded control in artifacts. The paper critically reviews existing (partial) solutions to simulate or execute control behaviors, and to close the control loops we identified in human-artifact interaction simulation. We concluded that closed-loop control of interaction simulations can be achieved by selectively combining existing partial solutions. Inclusion of decision-making appears to be the biggest challenge. Promising solutions are (i) cognitive simulation and (ii) execution of conjectured interactions specified as <b>logical</b> <b>instructions,</b> typically in the form of scenarios. Based on scenarios, which we expect to be more intuitive for designers, a new approach is now being developed...|$|R
40|$|To {{enhance the}} {{effectiveness}} of engineering simulations in product development, this thesis presents a new approach that enables designers to include human responses and reactions to artefact behaviour in their investigations. It does so without requiring deployment of real human subjects or investing in interactive virtual environments. The new method introduces scenario bundles, which designers specify as <b>logical</b> <b>instructions</b> that represent their conjectures of how human users react on possible artefact behaviours. During computer simulation, a scenario bundle controls a virtual model of the human user. This control causes intermediate changes in parameters and thus alters {{the course of the}} simulated process. The responses specified in scenario bundles can be condition-dependent, so that different concatenated simulations emerge when variations are applied to the product design, to characteristics of human users, and to the surroundings of use. This makes it possible for designers to explore variations of use processes through simulation. The thesis presents the concept and the fundamentals of the method, as well as the development of a proof-of concept implementation of a design support tool. This proof of concept has been successfully tested on a series of sample products. Design EngineeringIndustrial Design Engineerin...|$|R
40|$|This thesis {{deals with}} {{high-speed}} communication equipment based on Cisco 2821. Includes description of facilities, physical and <b>logical</b> diagrams, <b>instructions</b> for basic orientation {{in the operating}} system Cisco IOS, and the procedure for {{the preparation of the}} workplace. Further in this document, there are three laboratory task on the topic of MPLS IP, Traffic engineering with MPLS and Circuit emulation over IP. Each task includes introduction, instructions for the elaboration, the question of the task, desired outcome and brief guide for teachers...|$|R
5000|$|A single rotate through carry can {{simulate}} a logical or arithmetic shift of one position {{by setting up}} the carry flag beforehand. For example, if the carry flag contains 0, then [...] is a logical right-shift, and if the carry flag contains {{a copy of the}} sign bit, then [...] is an arithmetic right-shift. For this reason, some microcontrollers such as low end PICs just have rotate and rotate through carry, and don't bother with arithmetic or <b>logical</b> shift <b>instructions.</b>|$|R
40|$|Abstract – This paper {{discusses}} analogic {{cellular array}} architectures {{that can also}} be used to approximate partial differential equations (PDEs). Cellular arrays are massively parallel computing structures composed of cells placed on a regular grid. These cells interact locally and the array can have both local and global dynamics. The software of this architecture is an analogic algorithm that builds on analog and <b>logical</b> spatio-temporal <b>instructions</b> of the underlying hardware, that is, a locally connected cellular nonlinear network (CNN, [1]-[5]). Within this framework several classes of “wave-type ” PDEs could be approximated. Examples will be shown for cellular wave-computing phenomena on existing CNN Universal Machine (CNN-UM, [2]) chips (e. g. [3]-[5]). ...|$|R
40|$|Katrina Blannin | Christina France | Hanz Hancock | James Irwin | Patrick Morrissey | Andy Parkinson | Charley Peters | Mary Yacoob Curated by Charley Peters Rules {{and systems}} are a {{hallmark}} of every modernising period since the Enlightenment, presenting an alternative to tradition and intuition. A rule removes the possibility of interpretation and a system is able to create, automatically. Both are objective, counteracting the human tendency to influence or control outcomes. Rules and systems are in many ways opposed to the common notion of art as a field of personal expression. Generator presents a selection of artwork that is by nature ‘generative’, created once an artist cedes control to an external system or set of rules. The artwork thus results not from the wholly instinctive decisions of the artist, but is formed by objective rules or <b>logical</b> <b>instructions</b> that shape its process or material outcome. In popular use today the term ‘generative art’ is often used as {{a reference to a}} form of recent computer art that creates work through a series of algorithms. In From Systems to Software Richard Wright describes systems artists working in the pre-digital age as the ‘last programmers before the computer made that practice synonymous with its own functioning’, making a distinction between systems art’s main concern with process, and computer programming's purpose to control. Generator explores the language of the contemporary analogue ‘programmatic’, in which logic-based systems are employed to define the creation of an art object. A limited edition print by MuirMcNeill with an essay by Laura Davidson accompanied the exhibition...|$|R
40|$|Testing virtual {{use with}} {{scenarios}} To enhance {{the effectiveness of}} engineering simulations in product development, this PhD thesis presents a new approach that enables designers to include human responses and reactions to artefact behaviour in their investigations. It does so without requiring deployment of real human subjects or investments in interactive virtual environments. The new method introduces scenario bundles, which designers specify as <b>logical</b> <b>instructions</b> that represent their conjectures of how human users react on possible artefact behaviours. During computer simulation, a scenario bundle controls a virtual model of the human user. This control causes intermediate changes in parameters and thus alters {{the course of the}} simulated process. The designer can specify responses in a scenario bundles as conditiondependent, so that different concatenated simulations emerge when variations are applied to the product design, to characteristics of human users, and to the surroundings of use. This makes it possible to explore variations of use processes through simulation. The thesis presents the concept and the fundamentals of the method, as well as the development of a proof-of concept implementation of a design support tool, which has been successfully tested on sample products. Wilfred van der Vegte Testing virtual use with scenarios Testing virtual use with scenarios Wilfred van der VegteTesting virtual use with scenarios Proefschrift ter verkrijging van de graad van doctor aan de Technische Universiteit Delft, op gezag van de Rector Magnificus prof. dr. ir. J. T. Fokkema, voorzitter van het college van promoties, op dinsdag 15 december 2009 te 10. 00 uur door Wilhelm Frederik van der VEGTE, werktuigkundig ingenieur...|$|R
