90|428|Public
50|$|For example, the IDEF1 Information Modeling method {{includes}} {{the notion of}} an entity but has no syntactic element for an entity in the graphical language.8. When the <b>language</b> <b>designer</b> decides that a syntactic element should be included for a method concept, candidate symbols are designed and evaluated. Throughout the graphical language design process, the <b>language</b> <b>designer</b> applies a number of guiding principles to assist in developing high quality designs. Among these, the <b>language</b> <b>designer</b> avoids overlapping concept classes or poorly defined ones. They also seek to establish intuitive mechanisms to convey the direction for reading the schematics.|$|E
5000|$|An {{original}} C# <b>language</b> <b>designer,</b> Scott Wiltamuth, {{stated in}} a March 2010 blog that the [...] "most reliable numbers we have... show roughly equal adoption" [...] for VB.NET and C#.|$|E
50|$|Anthony James Barr (born September 24, 1940), aka Tony Barr or Jim Barr, is an American {{programming}} <b>language</b> <b>designer,</b> software engineer, and inventor. Among his notable {{contributions are}} the Statistical Analysis System (SAS), automated lumber yield optimization, and the Automated Classification of Medical Entities (ACME).|$|E
50|$|Java <b>language</b> <b>designers</b> at Sun Microsystems {{chose to}} omit overloading.|$|R
50|$|As the {{languages}} evolved, the <b>language</b> <b>designers</b> for both <b>languages</b> have faced situations where {{they wanted to}} extend {{the languages}} with new keywords or syntax. New keywords in particular may break existing code at source level, i.e. older code may no longer compile, if presented to a compiler for a later version of the <b>language.</b> <b>Language</b> <b>designers</b> are keen to avoid such regressions. The designers of the two languages have been following different paths when addressing this problem.|$|R
50|$|In later interviews, {{all three}} of the <b>language</b> <b>designers</b> cited their shared dislike of C++'s {{complexity}} as a primary motivation for designing a new language.|$|R
50|$|Context-free grammars {{are simple}} {{enough to allow}} the {{construction}} of efficient parsing algorithms which, for a given string, determine whether {{and how it can}} be generated from the grammar. If a programming <b>language</b> <b>designer</b> is willing to work within some limited subsets of context-free grammars, more efficient parsers are possible.|$|E
50|$|Moglen {{started out}} as a {{computer}} programming <b>language</b> <b>designer</b> and then received his bachelor's degree from Swarthmore College in 1980. In 1985, he received a Master of Philosophy in history and a JD from Yale University. He has held visiting appointments at Harvard University, Tel Aviv University and the University of Virginia since 1987.|$|E
5000|$|The {{keyboard}} attracts {{many visitors}} {{to the city and}} is today considered one of its top sights. It is also referred to as [...] "one of the miracles of Russia" [...] by some researchers. Niklaus Wirth, Pascal programming <b>language</b> <b>designer,</b> evaluated the object while it was being constructed and found it to be fascinating.|$|E
40|$|When writing {{computer}} programs, certain patterns arise {{over and}} over again. For example, programs must often loop through the elements of arrays, increment or decrement the values of variables, and perform multi-way conditionals based on numeric or character values. Programming <b>language</b> <b>designers</b> typically acknowledge this fact by including special-purpose syntactic constructs that handle the most common patterns. C, for instance, provides multiple looping constructs, multiple conditional constructs, and multiple constructs for incrementing or otherwise updating {{the value of a}} variable [9]. Some patterns are less common but can occur frequently in a certain class of programs or perhaps just within a single program. These patterns might not even be anticipated by a <b>language’s</b> <b>designers,</b> who in any case would typically choose not to incorporate syntactic constructs to handle such patterns in the language core. Yet, recognizing that such patterns do arise and that specialpurpose syntactic constructs can make programs both simpler and easier to read, <b>language</b> <b>designers</b> sometimes include a mechanism for syntactic abstraction...|$|R
50|$|A <b>language's</b> <b>designers</b> {{and users}} must {{construct}} {{a number of}} artifacts that govern and enable the practice of programming. The {{most important of these}} artifacts are the language specification and implementation.|$|R
50|$|The {{relationships}} are {{specified in the}} science of object oriented design and object interface standards defined by popular use, <b>language</b> <b>designers</b> (Java, C++, Smalltalk, Visual Prolog) and standards committees for software design like the Object Management Group.|$|R
50|$|A {{programming}} <b>language</b> <b>designer</b> {{will consider}} variance when devising typing rules for e.g. arrays, inheritance, and generic datatypes. By making type constructors covariant or contravariant instead of invariant, more {{programs will be}} accepted as well-typed. On the other hand, programmers often find contravariance unintuitive, and accurately tracking variance to avoid runtime type errors can lead to complex typing rules. In {{order to keep the}} type system simple and allow useful programs, a language may treat a type constructor as invariant even if it would be safe to consider it variant, or treat it as covariant even when that can violate type safety.|$|E
50|$|Raj Krishnamurthy (chief {{architect}} at JackBe Corporation) and Deepak Alur (VP {{engineering at}} JackBe Corporation) {{started working on}} EMML in 2006. Their objective was to enable user-oriented and user-enabled mashups by creating {{what was then a}} new type of middleware called an Enterprise Mashup Platform. Raj Krishnamurthy became the chief <b>language</b> <b>designer</b> and implementer of EMML and also led the team to create an Eclipse-based EMML IDE called Mashup Studio. This work evolved into the EMML reference implementation that was donated to the Open Mashup Alliance. Raj Krishnamurthy continues {{to be one of the}} key contributors to EMML through the Open Mashup Alliance.|$|E
5000|$|In {{the essay}} Being Popular Graham {{describes}} {{a few of}} his goals for the language. While many of the goals are very general ("Arc should be hackable," [...] "there should be good libraries"), he did give some specifics. For instance, he believes that it is important for a language to be terse: [...] It would not be far from the truth to say that a hacker about to write a program decides what language to use, at least subconsciously, based on the total number of characters he'll have to type. If this isn't precisely how hackers think, a <b>language</b> <b>designer</b> would do well to act as if it were.|$|E
50|$|Although some {{approaches}} are already used in aspect languages, others are still subject {{of research and}} are not ready for routine industrial application. Nevertheless, awareness of these issues is essential for <b>language</b> <b>designers,</b> and for effective use of aspects, especially in safety-critical contexts.|$|R
50|$|Fortress is a {{discontinued}} experimental {{programming language}} for high-performance computing, created by Sun Microsystems {{with funding from}} DARPA's High Productivity Computing Systems project. One of the <b>language</b> <b>designers</b> was Guy L. Steele Jr., whose previous work includes Scheme, Common Lisp, and Java.|$|R
40|$|The 9 th International Modelica Conference is {{the main}} event for users, library developers, tool vendors and <b>language</b> <b>designers</b> to share their {{knowledge}} and learn about the latest scientific and industrial progress related to Modelica, to the Modelica Association and to the Functional Mockup Interface. ...|$|R
50|$|The C Programming Language (sometimes termed K&R, {{after its}} authors' initials) is a {{computer}} programming book written by Brian Kernighan and Dennis Ritchie, the latter of whom originally designed and implemented the language, as well as co-designed the Unix operating system with which development of the language was closely intertwined. The book was central to the development and popularization of the C programming language and is still widely read and used today. Because the book was co-authored by the original <b>language</b> <b>designer,</b> and because {{the first edition of}} the book served for many years as the de facto standard for the language, the book was regarded {{by many to be the}} authoritative reference on C.|$|E
50|$|Up to {{this point}} in the {{language}} design process, the primary focus has been on the information that should be displayed in a given schematic to achieve the goals of the schematic. This is where the <b>language</b> <b>designer</b> must determine which items identified for possible inclusion in the schematic are amenable to graphical representation and will serve to keep the user focused on the desired information content. With this general understanding, previously developed graphical language structures are explored to identify potential reuse opportunities. While exploring candidate graphical language designs for emerging IDEF methods, a wide range of diagrams were identified and explored. Quite often, even some of the central concepts of a method will have no graphical language element in the method.|$|E
50|$|Thus Burroughs FORTRAN {{was better}} than any other {{implementation}} of FORTRAN. For instance, for subroutines and functions it checked that they were invoked with the correct number of parameters, as is normal for ALGOL-style compilers. On other computers, such mismatches were common causes of crashes. Similarly with the array-bound checking: programs that had been used for years on other systems embarrassingly often would fail when run on a Burroughs system. In fact, Burroughs became known for its superior compilers and implementation of languages, including the object-oriented Simula (a superset of ALGOL), and Iverson, the designer of APL declared that the Burroughs implementation of APL was the best he'd seen. John McCarthy, the <b>language</b> <b>designer</b> of LISP disagreed, since LISP was based on modifiable code, he did not like the unmodifiable code of the B5000, but most LISP implementations would run in an interpretive environment anyway.|$|E
5000|$|Similarly {{recursive}} definitions {{are often}} used to model the structure of expressions and statements in programming <b>languages.</b> <b>Language</b> <b>designers</b> often express grammars in a syntax such as Backus-Naur form; here is such a grammar, for a simple language of arithmetic expressions with multiplication and addition: ...|$|R
40|$|Coordination {{viewed as}} the notion of {{dependencies}} among activities " [8] is the key concept for modelling concurrent systems. In this paper, we investigate coordination {{from the viewpoint of}} programmers and programming <b>language</b> <b>designers</b> with respect to objectoriented programming. Finally, we evaluate existing objectoriented coordination models. ...|$|R
40|$|The {{statements}} `inheritance is not subtyping' and `mainstream OO languages unnecessarily place restrictions over inheritance' have rippled as mantras {{through the}} PL research community for years. Many mainstream OO developers and OO <b>language</b> <b>designers</b> however {{do not accept}} these statements. In nominally-typed OO languages that these developers and <b>language</b> <b>designers</b> are dearly familiar with, inheritance simply is subtyping; and they believe OO type inheritance is an inherently nominal notion not a structural one. Nominally-typed OO languages {{are among the most}} used programming languages today. However, the value of nominal typing to mainstream OO developers, as a means for designing robust OO software, seems to be in wait for full appreciation among PL researchers [...] thereby perpetuating an unnecessary schism between many OO developers and <b>language</b> <b>designers</b> and many OO PL researchers, with each side discounting, if not even disregarding, the views of the other. In this essay we strengthen earlier efforts to demonstrate the semantic value of nominal typing by presenting a technical comparison between nominal OO type systems and structural OO type systems. Recently, a domain-theoretic model of nominally-typed OOP was compared to well-known models of structurally-typed OOP. Combined, these comparisons provide a clear and deep account for the relation between nominal and structural OO type systems that has not been presented before, and they help demonstrate the key value of nominal typing and nominal subtyping to OO developers and <b>language</b> <b>designers.</b> We believe a clearer understanding of the key semantic advantage of pure nominal OO typing over pure structural OO typing can help remedy the existing schism. We believe future foundational OO PL research, to further its relevance to mainstream OOP, should be based less on structural models of OOP and more on nominal ones instead. Comment: 19 pages. arXiv admin note: text overlap with arXiv: 1603. 0864...|$|R
5000|$|XCOM {{originally}} used a now-obsolete bottom-up parse table method called Mixed Strategy Precedence, {{invented by}} the XPL team (although the officially released version retains the MSP parser {{and does not}} include later-released [...] "peephole optimizations" [...] and additional data types which were developed outside of the original implementation team.) MSP is a generalization of the simple precedence parser method invented by Niklaus Wirth for PL360. Simple precedence is itself a generalization of the trivially simple operator precedence methods that work nicely for expressions like A+B*(C+D)-E. MSP tables include a list of expected triplets of language symbols. This list grows larger as the cube of the grammar size, and becomes quite large for typical full programming languages. XPL-derived compilers were difficult to fit onto minicomputers of the 1970s with limited memories. [...] MSP is also not powerful enough to handle all likely grammars. It is applicable only when the <b>language</b> <b>designer</b> can tweak the language definition to fit MSP's restrictions, before the language is widely used.|$|E
50|$|After {{five years}} at the National Bureau of Standards, Huskey joined {{the faculty of the}} University of California, Berkeley in 1954 and then University of California, Santa Cruz from 1966. While at Berkeley, he {{supervised}} the research of pioneering programming <b>language</b> <b>designer</b> Niklaus Wirth, who gained his PhD in 1963.During 1963-1964 Prof. Huskey participated in establishing the Computer Center at IIT Kanpur and convened a meeting there with many pioneers of computing technology. Participants included Forman Acton of Princeton University, Robert Archer of Case Institute of Technology, S. Barton of CDC, Australia, S. Beltran from the Centro de Calculo in Mexico City, John Makepeace Bennett of the University of Sydney, Launor Carter of SDC - author of the subsequent Carter Report on Computer Technology for Schools, David Evans of UC Berkeley, Bruce Gilchrist of IBM-SBC, Clay Perry of UC San Diego, Sigeiti Moriguti of the University of Tokyo, Adriaan van Wijngaarden of the Mathematisch Centrum in Amsterdam, Maurice Wilkes of Cambridge University, and Gio Wiederhold, also of UC Berkeley.|$|E
5000|$|In 2003, Wong hybridized two earlier {{proposals}} for sender authentication, Designated Mailer Protocol (DMP) and Reverse Mail Exchanger (RMX), and devised SPF (Sender Policy Framework, originally Sender Permitted From). [...] In November, he met Mark Lentczner at the Hackers Conference; Lentczner, an experienced protocol and <b>language</b> <b>designer</b> {{in his own}} right, became the primary co-author on the draft specification. SPF quickly caught on among the opensource community, receiving mentions on Slashdot, on Dave Farber's influential Interesting-People mailing list, and elsewhere. During 2004 Wong traveled widely, visiting ISPs in North America, Europe, Singapore, and Japan, and speaking at conferences to explain SPF. He was appointed Senior Technical Advisor to the Messaging Anti-Abuse Working Group. [...] In 2004 Microsoft merged their similar proposal, Caller-ID For Email, with SPF to form Sender ID Framework. In 2005, the Microsoft implementation was rolled out in Hotmail, Exchange, and Outlook. In 2006, RFC4408 was published by the IETF as an Experimental Standard. As of August 2006, between one-third and one-half of legitimate email volume worldwide carries an SPF record.|$|E
40|$|Everything is {{changing}} Old {{conventional wisdom is}} out We DESPERATELY need {{a new approach to}} HW and SW systems based on parallelism Need to create a “watering hole ” to bring everyone together to quickly find that solution architects, <b>language</b> <b>designers,</b> application experts, numerical analysts, algorithm designers, programmers,...|$|R
40|$|Tool {{builders}} {{dealing with}} many di#erent <b>languages,</b> and <b>language</b> <b>designers</b> require sophisticated pretty-print techniques {{to minimize the}} time needed for constructing and adapting pretty-printers. We combined new and existing pretty-print techniques in a generic pretty-printer that satisfies modern pretty-print requirements. Its features include language independence, customization, and incremental pretty-printer generation...|$|R
40|$|Giving types to binary methods causes signi cant {{problems}} for object-oriented <b>language</b> <b>designers</b> and programmers. This paper o ers a comprehensive {{description of the}} problems arising from typing binary methods, and collects and contrasts diverse views and solutions. It summarizes the current debate {{on the problem of}} binary methods for a wide audience. ...|$|R
40|$|We {{describe}} an interpreter for a value-passing version of CCS {{implemented in the}} lazy functional programming language Haskell. Starting from a base interpreter, we then show how to modify the interpreter for CCS extensions including, additional non-primitive combinators, new primitive operators (an interrupt operator), a time domain with a timeout operator useful in describing real-time systems, and higher order CCS where processes may be passed on channels. Keywords: Parallel programming, process algebra, functional programming, executable semantics. 1 Introduction Interpreters for computer languages are useful for many reasons. An interpreter may serve as an initial prototype of an implementation while more sophisticated tools are being developed. An interpreter allows a <b>language</b> <b>designer</b> to experiment with extensions or variations of a language. The ability to write and execute programs early in the language design process provides important feedback to the <b>language</b> <b>designer</b> for [...] ...|$|E
40|$|Abstract. Programming {{languages}} often {{hide their}} implementation {{at a level}} of abstraction that is inaccessible to programmers. Decisions and tradeoffs made by the <b>language</b> <b>designer</b> at this level (single vs. multiple inheritance, mixins vs. Traits, dynamic dispatch vs. static case analysis, etc.) cannot be repaired easily by the programmer when they prove inconvenient or inadequate. The artificial distinction between implementation language and end-user language can be eliminated by implementing the language using only end-user objects and messages, making the implementation accessible for arbitrary modification by programmers. We show that three object types and five methods are sufficient to bootstrap an extensible object model and messaging semantics that are described entirely in terms of those same objects and messages. Raising the implementation to the programmers ’ level lets them design and control their own implementation mechanisms in which to express concise solutions and frees the original <b>language</b> <b>designer</b> from ever having to say “I’m sorry”. ...|$|E
40|$|The {{semantics}} of constraint {{logic programming}} languages with coroutining facilities (e. g., "freeze," suspension, residuation) cannot be fully declarative. Thus, an operational semantics {{has to be}} taken as the defining one. We give a formal operational semantics for a Prolog-like language with cut and entailment-based conditional. Our approach is derived from those used for concurrent calculi. We use congruence laws and tree-rewriting rules to define the semantics. We model the execution of a program by a sequence of abstract-tree rewriting steps. This semantics serves as a defining tool for the <b>language</b> <b>designer</b> and as the interface between the <b>language</b> <b>designer</b> and implementor; it allows the programmer to check his intuition with a formal execution model and it gives him a performance measure for the execution of programs. We have used the semantics to make precise, for the first time, the critical interaction between sequential execution (including backtracking and cut pruning) and c [...] ...|$|E
40|$|Giving types to binary methods causes {{significant}} problems for object-oriented <b>language</b> <b>designers</b> and programmers. This paper offers a comprehensive {{description of the}} problems arising from typing binary methods, and collects and contrasts diverse views and solutions. It is intended to expose a wide audience of readers to the current debate on this question...|$|R
50|$|ANDF was {{intended}} to benefit both software developers and users. Software developers could release a single binary for all platforms, and software users would have freedom to procure multiple vendors' hardware competitively. Programming <b>language</b> <b>designers</b> and implementors were also interested because standard installers would mean that only a single language front end {{would need to be}} developed.|$|R
40|$|The FlatCAD system {{lets you}} create {{physical}} construc-tion kits by coding in the LOGO-like FlatLang <b>language.</b> <b>Designers</b> often use structured CAD tools to specify physi-cal form. Programming offers an alternative and powerful method for designing shapes. This paper describes our ex-perimental domain-specific language used to program and manufacture physical {{shape in the}} domain of construction kits. ...|$|R
