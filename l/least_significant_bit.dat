750|3578|Public
25|$|The bits are indexed {{with the}} <b>least</b> <b>significant</b> <b>bit</b> (LSB) as 0.|$|E
25|$|When using Bit-Encoded-Notation, {{quantities}} like C4 means bit 4 {{from data}} byte C. Each bit is numerated from 0 to 7, so 7 {{is the most}} significant bit and 0 is the <b>least</b> <b>significant</b> <b>bit.</b>|$|E
25|$|The Unicode {{standard}} encodes 8-dot braille glyphs {{according to}} their binary appearance, rather than following their assigned numeric order. Dot 1 corresponds to the <b>least</b> <b>significant</b> <b>bit</b> of the low byte of the Unicode scalar value, and dot 8 to the high bit of that byte.|$|E
50|$|The <b>least</b> <b>significant</b> <b>bits</b> {{have the}} useful {{property}} of changing rapidly {{if the number}} changes even slightly. For example, if 1 (binary 00000001) is added to 3 (binary 00000011), {{the result will be}} 4 (binary 00000100) and three of the <b>least</b> <b>significant</b> <b>bits</b> will change (011 to 100). By contrast, the three most <b>significant</b> <b>bits</b> (MSBs) stay unchanged (000 to 000).|$|R
50|$|The xy2d {{function}} works top down, {{starting with}} the most <b>significant</b> <b>bits</b> of x and y, and building up the most <b>significant</b> <b>bits</b> of d first. The d2xy function works in the opposite order, {{starting with the}} <b>least</b> <b>significant</b> <b>bits</b> of d, and building up x and y starting with the <b>least</b> <b>significant</b> <b>bits.</b> Both functions use the rotation function to rotate and flip the (x,y) coordinate system appropriately.|$|R
5000|$|... #Caption: A diagram {{showing how}} {{manipulating}} the <b>least</b> <b>significant</b> <b>bits</b> of a color {{can have a}} very subtle and generally unnoticeable affect on the color. In this diagram, green is represented by its RGB value, both in decimal and in binary. The red box surrounding the last two <b>bits</b> illustrates the <b>least</b> <b>significant</b> <b>bits</b> changed in the binary representation.|$|R
25|$|Jonathan Swift's 1726 satire, , {{in which}} civil war erupts {{over whether the}} big end or the little end of a boiled egg is the proper end to crack open (analogous to {{counting}} from the end that contains the most significant bit or the <b>least</b> <b>significant</b> <b>bit).</b>|$|E
25|$|In analog-to-digital {{conversion}} a quantization error occurs. This error is either due to rounding or truncation. When the original signal {{is much larger}} than one <b>least</b> <b>significant</b> <b>bit</b> (LSB), the quantization error is not significantly correlated with the signal, and has an approximately uniform distribution. The RMS error therefore follows from the variance of this distribution.|$|E
25|$|The data is a 32 bit (DWORD) bitmapped value, {{of which}} the lower 26 bits are used to {{represent}} each of the 26 drive letters from A to Z. Thus the valid data range is from 0x0 to 0x03FFFFFF. The <b>least</b> <b>significant</b> <b>bit</b> (the right most bit) represents drive A, and the 26th bit from the right represents drive Z.|$|E
50|$|<b>Least</b> <b>significant</b> <b>bits</b> are {{frequently}} employed in pseudorandom number generators, steganographic tools, hash functions and checksums.|$|R
50|$|By extension, the <b>least</b> <b>significant</b> <b>bits</b> (plural) are {{the bits}} of the number closest to, and including, the LSB.|$|R
5000|$|On louder samples {{some of the}} <b>least</b> <b>significant</b> <b>bits</b> are truncated, {{with the}} hope that they will be inaudible.|$|R
25|$|The SPI bus is a {{de facto}} {{standard}}. However, {{the lack of a}} formal standard is reflected {{in a wide variety of}} protocol options. Different word sizes are common. Every device defines its own protocol, including whether it supports commands at all. Some devices are transmit-only; others are receive-only. Chip selects are sometimes active-high rather than active-low. Some protocols send the <b>least</b> <b>significant</b> <b>bit</b> first.|$|E
25|$|To convert from a base-10 integer to its base-2 (binary) equivalent, {{the number}} is divided by two. The {{remainder}} is the least-significant bit. The quotient is again divided by two; its remainder becomes the next <b>least</b> <b>significant</b> <b>bit.</b> This process repeats until a quotient of one is reached. The sequence of remainders (including the final quotient of one) forms the binary value, as each remainder must be either zero or one when dividing by two. For example, (357)10 is expressed as (101100101)2.|$|E
25|$|Conditional {{branches}} {{test whether}} the <b>least</b> <b>significant</b> <b>bit</b> of a register is set or clear, or compare a register as a signed quadword to zero, and branch if the specified condition is true. The conditions available for comparing a register to zero are equality, inequality, less than, {{less than or}} equal to, greater than or equal to, and greater than. The new address is computed by longword aligning and sign extending the 21-bit displacement and adding it to the address of the instruction following the conditional branch.|$|E
5000|$|... 8) Since RFC 3168, the {{remaining}} two <b>bits</b> (the two <b>least</b> <b>significant</b> <b>bits)</b> are used for Explicit Congestion Notification ...|$|R
3000|$|... −  1 cover pixels by {{modifying the}} <b>least</b> <b>significant</b> <b>bits</b> (LSBs) of one pixel. The {{embedding}} capacity reached k/(2 [...]...|$|R
50|$|Accessing an {{individual}} byte frequently requires reading or writing the full bus width (a word) at once. In these instances the <b>least</b> <b>significant</b> <b>bits</b> of the address bus {{may not even}} be implemented - it is instead the responsibility of the controlling device to isolate the individual byte required from the complete word transmitted. This is the case, for instance, with the VESA Local Bus which lacks the two <b>least</b> <b>significant</b> <b>bits,</b> limiting this bus to aligned 32-bit transfers.|$|R
25|$|The Alpha {{does not}} have {{condition}} codes for integer instructions to remove a potential bottleneck at the condition status register. Instructions resulting in an overflow, such as adding two numbers whose result does not fit in 64 bits, write the 32 or 64 least significant bits to the destination register. The carry is generated by performing an unsigned compare on the result with either operand {{to see if the}} result is smaller than either operand. If the test was true, the value one is written to the <b>least</b> <b>significant</b> <b>bit</b> of the destination register to indicate the condition.|$|E
25|$|In some algorithms, an {{intermediate}} result is computed {{in a larger}} precision, then must be rounded to the final precision. Double rounding can be avoided by choosing an adequate rounding for the intermediate computation. This consists in avoiding to round to midpoints for the final rounding (except when the midpoint is exact). In binary arithmetic, {{the idea is to}} round the result toward zero, and set the <b>least</b> <b>significant</b> <b>bit</b> to 1 if the rounded result is inexact; this rounding is called sticky rounding. Equivalently, it consists in returning the intermediate result when it is exactly representable, and the nearest floating-point number with an odd significand otherwise; this is why it is also known as rounding to odd.|$|E
25|$|Bit {{numbering}} is {{a concept}} similar to endianness, but on a level of bits, not bytes. Bit endianness or bit-level endianness refers to the transmission order of bits over a serial medium. The bit-level analogue of little-endian (<b>least</b> <b>significant</b> <b>bit</b> goes first) is used in RS-232, Ethernet, and USB. Some protocols use the opposite ordering (e.g. Teletext, I²C, SMBus, PMBus, and SONET and SDH). Usually, there exists a consistent view to the bits irrespective of their order in the byte, such that the latter becomes relevant only on a very low level. One exception {{is caused by the}} feature of some cyclic redundancy checks to detect all burst errors up to a known length, which would be spoiled if the bit order is different from the byte order on serial transmission.|$|E
5000|$|In rANS variant [...] is {{for example}} 32 bit. For 16 bit renormalization, , decoder refills the <b>least</b> <b>significant</b> <b>bits</b> from the {{bitstream}} when needed: ...|$|R
50|$|The pos_state and literal_pos_state values {{consist of}} {{respectively}} the pb and lp (up to 4, from the LZMA header or LZMA2 properties packet) <b>least</b> <b>significant</b> <b>bits</b> of the dictionary position (the {{number of bytes}} coded since the last dictionary reset modulo the dictionary size). Note that the dictionary size is normally the multiple of a large power of 2, so these values are equivalently described as the <b>least</b> <b>significant</b> <b>bits</b> {{of the number of}} uncompressed bytes seen since the last dictionary reset.|$|R
5000|$|And {{when the}} last input group {{contains}} two octets, the two <b>least</b> <b>significant</b> <b>bits</b> of the last content-bearing 6-bit block {{will turn out to}} be zero: ...|$|R
25|$|Little-endian {{representation}} simplifies hardware in processors {{that add}} multi-byte integral values a byte at a time, such as small-scale byte-addressable processors and microcontrollers. As carry propagation must {{start at the}} <b>least</b> <b>significant</b> <b>bit</b> (and thus byte), multi-byte addition can then be carried out with a monotonically-incrementing address sequence, a simple operation already present in hardware. On a big-endian processor, its addressing unit has to be told how big the addition {{is going to be}} so that it can hop forward to the least significant byte, then count back down towards the most significant byte (MSB). On the other hand, arithmetic division is done starting from the MSB, so it is more natural for big-endian processors. However, high-performance processors usually fetch typical multi-byte operands from memory in {{the same amount of time}} they would have fetched a single byte, so the complexity of the hardware is not affected by the byte ordering.|$|E
500|$|This code {{is similar}} to, {{and has the}} same {{framework}} as, the IRIG H time code and the time code that WWVB transmits, except the individual fields of the code are rearranged and are transmitted with the <b>least</b> <b>significant</b> <b>bit</b> sent first.|$|E
500|$|An integer sorting {{algorithm}} {{is said to}} be non-conservative if it requires a word size [...] that is significantly larger than [...] As an extreme instance, if , and all keys are distinct, then the set of keys may be sorted in linear time by representing it as a bitvector, with a 1 bit in position [...] when [...] is one of the input keys, and then repeatedly removing the <b>least</b> <b>significant</b> <b>bit.</b>|$|E
50|$|Fourteen bit point codes can {{be written}} {{in a number of}} formats. The most common formats are decimal number, {{hexadecimal}} number, or 3-8-3 format (3 most <b>significant</b> <b>bits,</b> 8 middle <b>bits,</b> 3 <b>least</b> <b>significant</b> <b>bits).</b>|$|R
50|$|The final {{field is}} the checksum, {{calculated}} simply by summing all bytes in the packet (including slashes) {{and taking the}} 8 <b>least</b> <b>significant</b> <b>bits</b> from the result.|$|R
5000|$|The code {{uses the}} <b>least</b> <b>significant</b> <b>bits,</b> {{which makes it}} more {{efficient}} to expand the table, as the entire directory can be copied as one block (...) [...]|$|R
2500|$|The msbit-first {{representation}} is a hexadecimal number with [...] bits, the <b>least</b> <b>significant</b> <b>bit</b> {{of which is}} always 1. [...] The most significant bit represents the coefficient of [...] and the <b>least</b> <b>significant</b> <b>bit</b> represents the coefficient of [...]|$|E
2500|$|The image pixel data, scanned {{horizontally}} {{from top}} left, are converted by LZW encoding to codes that are then mapped into bytes for storing in the file. The pixel codes typically don't match the 8-bit {{size of the}} bytes, so the codes are packed into bytes by a [...] "little-Endian" [...] scheme: [...] the <b>least</b> <b>significant</b> <b>bit</b> of the first code is stored in the <b>least</b> <b>significant</b> <b>bit</b> of the first byte, higher order bits of the code into higher order bits of the byte, spilling over into the low order bits of the next byte as necessary. [...] Each subsequent code is stored starting at the <b>least</b> <b>significant</b> <b>bit</b> not already used.|$|E
2500|$|The lsbit-first {{representation}} is a hexadecimal number with [...] bits, {{the most significant}} bit of which is always 1. [...] The most significant bit represents the coefficient of [...] and the <b>least</b> <b>significant</b> <b>bit</b> represents the coefficient of [...]|$|E
50|$|In digital steganography, {{sensitive}} messages may be concealed {{by manipulating}} and storing {{information in the}} <b>least</b> <b>significant</b> <b>bits</b> of an image or a sound file. In {{the context of an}} image, if a user were to manipulate the last two bits of a color in a pixel, the value of the color would change at most +/- 3 value places, which is likely to be indistinguishable by the human eye. The user may later recover this information by extracting the <b>least</b> <b>significant</b> <b>bits</b> of the manipulated pixels to recover the original message.|$|R
5000|$|GSM 03.40 defines 6 {{types of}} messages, which are {{distinguished}} by the message direction and the 2 <b>least</b> <b>significant</b> <b>bits</b> {{in the first}} octet of SM-TP message (the TP-MTI field): ...|$|R
5000|$|Once in 4-bit mode, {{character}} and control data are transferred as pairs of 4-bit [...] "nibbles" [...] {{on the upper}} data pins, D7-D4. The four most <b>significant</b> <b>bits</b> (7-4) must be written first, followed by the four <b>least</b> <b>significant</b> <b>bits</b> (3-0).|$|R
