442|891|Public
25|$|Internal Homs, when chained together, form a language, {{called the}} {{internal}} {{language of the}} category. The most famous of these are simply typed lambda calculus, which is the internal language of Cartesian closed categories, and the <b>linear</b> <b>type</b> system, which is the internal language of closed symmetric monoidal categories.|$|E
25|$|The Erie County Holding Center (ECHC), {{located in}} Buffalo, New York, is a pretrial, maximum {{security}} detention facility. It {{is the second}} largest detention facility in New York State, outside of New York City. The Erie County Holding Center has a capacity of housing 598 inmates remanded to {{the custody of the}} Sheriff of Erie County. It processes more than 20,000 inmates annually. The facility is a combination of pods and open bay construction and traditional <b>linear</b> <b>type</b> cells. Overflow inmates are housed at the Holding Center Annex at the Erie County Correctional Facility (ECCF).|$|E
500|$|There {{were two}} wounds {{to his right}} side, and two {{to the top of}} his head, which would {{probably}} have resulted in unconsciousness. The left side of his lip was wounded, his jaw was fractured, and his teeth, neck and larynx were damaged. The pathologist said he [...] "would {{not have been able to}} engage in purposeful talk", according to the Court of Appeal. There were gunshot wounds to his left shoulder and left elbow. The court heard that he had [...] "black eyes and a broken nose, linear bruising to the cheeks, lacerations to the head, <b>linear</b> <b>type</b> bruising to the right forearm, bruising to the left wrist and forearm and three circular burn type marks to the back. The linear marks were consistent with Mr Bamber having been struck with a long blunt object, possibly a gun." [...] One of the pillars of the prosecution case was that Sheila would not have been strong enough to inflict this beating on Nevill, who was 6ft 4in (1.93 m) tall and by all accounts in good health.|$|E
5000|$|Symmetric closed monoidal {{categories}} {{are used in}} denotational models of linear logic and <b>linear</b> <b>types.</b>|$|R
40|$|There {{are several}} kinds of <b>linear</b> <b>typed</b> {{calculus}} in the literature, some with their associated notion of categorical model. Our aim in {{this paper is to}} systematise the relationship between three of these <b>linear</b> <b>typed</b> calculi and their models. We point out that mere soundness and completeness of a <b>linear</b> <b>typed</b> calculus with respect to a class of categorical models are not sufficient to identify the most appropriate class uniquely. We recommend instead to use the notion of internal language when relating a typed calculus to a class of models. After clarifying the internal languages of the categories of models in the literature we relate these models via reflections and coreflections. Key words: intuitionistic <b>linear</b> logic, <b>typed</b> lambda calculus, symmetric monoidal closed categories, symmetric monoidal adjunctions. AMS classifications: 03 G 30 03 B 15 18 C 50 03 B 20...|$|R
50|$|The Clean {{programming}} language {{makes use of}} uniqueness types (a variant of <b>linear</b> <b>types)</b> to help support concurrency, input/output, and in-place update of arrays.|$|R
2500|$|Nitric oxide {{reacts with}} all {{transition}} metals to give complexes called metal nitrosyls. The most common bonding mode of nitric oxide is the terminal <b>linear</b> <b>type</b> (M−NO). The {{angle of the}} M−N−O group varies from 160° to 180° but is still termed [...] "linear". In this case, the nitric oxide group is considered a 3-electron donor under the covalent (neutral) method of electron counting, or a 2-electron donor under the ionic method. One can view such complexes as derived from NO+, which is isoelectronic with carbon monoxide (CO).|$|E
50|$|<b>Linear</b> <b>type</b> {{systems are}} the {{internal}} language of closed symmetric monoidal categories, {{much in the}} same way that simply typed lambda calculus is the language of Cartesian closed categories. More precisely, one may construct functors between the category of <b>linear</b> <b>type</b> systems and the category of closed symmetric monoidal categories.|$|E
5000|$|<b>Linear</b> <b>type</b> systems (allow exchange, not {{weakening}} or contraction): Every {{variable is}} used exactly once.|$|E
50|$|<b>Linear</b> <b>types</b> {{corresponds}} to <b>linear</b> logic and ensures that objects are used exactly once, allowing {{the system to}} safely deallocate an object after its use.|$|R
40|$|Suenaga et al. have {{developed}} a type-based framework for automatically translating tree-processing programs into streamprocessing ones. The key ingredient of the framework {{was the use of}} ordered <b>linear</b> <b>types</b> to guarantee that a treeprocessing program traverses an input tree just once in the depth-first, left-to-right order (so that the input tree can be read from a stream). Their translation, however, sometimes introduces redundant buffering of input data. This paper extends their framework by introducing ordered, non-linear types in addition to ordered <b>linear</b> <b>types.</b> The resulting transformation framework reduces the redundant buffering, generating more efficient stream-processing programs. 1...|$|R
40|$|As an {{abstraction}} of functional programming languages in which certain runtime entities {{are required to}} be uniquely referenced, we define a λ-calculus with both linear and standard data types and consequently both linear and standard function types. We use a single syntax for both linear and standard functions, and rely on the typechecker to produce a <b>linear</b> function <b>type</b> only when necessary. To compensate for the typechecker’s preference for standard function types, we include a subtyping relation in which the standard function type is a subtype of the <b>linear</b> function <b>type.</b> We prove that typing guarantees unique references to values of <b>linear</b> data <b>types,</b> that typing is preserved by the operational semantics, and that the typechecking algorithm is sound and complete {{with respect to the}} declarative typing rules. Key words: functional programming, <b>linear</b> <b>types,</b> subtyping...|$|R
5000|$|By contrast, {{the product}} for monoidal {{categories}} (such as Hilbert {{space and the}} vector spaces of functional analysis) is the tensor product. The internal language of such categories is linear logic, a form of quantum logic; the corresponding type system is the <b>linear</b> <b>type</b> system. Such categories are suitable for describing entangled quantum states, and, more generally, allow a vast generalization of the Curry-Howard correspondence to quantum mechanics, to cobordisms in algebraic topology, and to string theory. [...] The <b>linear</b> <b>type</b> system, and linear logic are useful for describing synchronization primitives, such as mutual exclusion locks, and the operation of vending machines.|$|E
50|$|A <b>linear</b> <b>type</b> {{system is}} similar to C++'s unique_ptr class, which behaves like a pointer but can only be moved (i.e. not copied) in an assignment. Although the {{linearity}} constraint is checked at compile time, dereferencing an invalidated unique_ptr causes undefined behavior at run-time.|$|E
50|$|The polar {{planimeter}} is restricted by design to measuring areas within limits determined by {{its size and}} geometry. However, the <b>linear</b> <b>type</b> has no restriction in one dimension, because it can roll. Its wheels must not slip, because the movement must be constrained to a straight line.|$|E
50|$|Affine {{types are}} {{a version of}} <b>linear</b> <b>types</b> {{allowing}} to discard (i.e. not use) a resource, corresponding to affine logic. An affine resource can only be used once, while a linear one must be used once.|$|R
40|$|This thesis investigates {{aspects of}} the general {{relationship}} between simply typed lambda-calculus and a linear term calculus based on Intuitionistic Linear Logic. It introduces a notion of minimization on linear lambda-terms that removes super ous nonlinear operations (storage). Two different embeddings of the simply typed lambda-calculus into the linear term calculus are studied {{with respect to their}} properties under minimization. We define operational semantics for both term calculi. In support of Abramsky's thesis, that <b>linear</b> <b>types</b> are useful in doing abstract interpretation of functional programs, we demonstrate - using translation together with minimization - a syntactic method to do strictness analysis on lambda-terms, via the <b>linear</b> <b>typing</b> calculus. This leads to useful optimizations of call-by-name reduction on lambda-terms...|$|R
30|$|Further {{evidence}} that SPM works better for <b>linear</b> <b>types</b> of networks {{is the result}} of the equality of electricity and telecommunications of the poor groups (Table  9, poor section). Here SPM reduced the poor inequality in a place where incomplete network of linear infrastructure found in the cluster of poverty.|$|R
50|$|Internal Homs, when chained together, form a language, {{called the}} {{internal}} {{language of the}} category. The most famous of these are simply typed lambda calculus, which is the internal language of Cartesian closed categories, and the <b>linear</b> <b>type</b> system, which is the internal language of closed symmetric monoidal categories.|$|E
5000|$|... and [...] {{independently}} {{showed that}} {{it is enough to}} prove the Jacobian Conjecture for complex maps of cubic homogeneous type with a symmetric Jacobian matrix, and further showed that the conjecture holds for maps of cubic <b>linear</b> <b>type</b> with a symmetric Jacobian matrix, over any field of characteristic 0.|$|E
50|$|It {{is common}} to extend this case to closed {{symmetric}} monoidal categories by using a <b>linear</b> <b>type</b> system. The {{reason for this is}} that the CCC is a special case of the closed symmetric monoidal category, which is typically taken to be the category of sets. This is fine for laying the foundations of set theory, but the more general topos seems to provide a superior foundation.|$|E
40|$|A syntactical {{proof is}} given that all {{functions}} definable {{in a certain}} affine <b>linear</b> <b>typed</b> lambda-calculus with iteration in all types are polynomial time computable. The proof provides explicit polynomial bounds that can easily be calculated. Comment: 20 pages (latex), revised submission (expanded proofs, extended references, new section on tree iteration...|$|R
40|$|We {{present a}} first-order linearly typed {{assembly}} language, HBAL, {{that allows the}} safe reuse of heap space for elements of di#erent <b>types.</b> The <b>linear</b> <b>types</b> discipline ensures a single pointer property, but disallows aliasing. Since HBAL does not assume an external memory management system, programs run in a bounded amount of heap space...|$|R
40|$|Abstract. Bounded <b>linear</b> <b>types</b> {{have proved}} to be useful for {{automated}} resource analysis and control in functional programming languages. In this paper we introduce a bounded <b>linear</b> <b>typing</b> discipline on a general notion of resource which can be modeled in a semiring. For this type system we provide both a general type-inference procedure, parameter-ized by the decision procedure of the semiring equational theory, and a (coherent) categorical semantics. This could be a useful type-theoretic and denotational framework for resource-sensitive compilation, and it represents a generalization of several existing type systems. As a non-trivial instance, motivated by hardware compilation, we present a com-plex new application to calculating and controlling timing of execution in a (recursion-free) higher-order functional programming language with local store. 1 Resource-aware types and semantics The two important things about a computer program are what it computes an...|$|R
50|$|The correspondences {{listed here}} go much farther and deeper. For example, {{cartesian}} closed categories are generalized by closed monoidal categories. The internal language {{of these categories}} is the <b>linear</b> <b>type</b> system (corresponding to linear logic), which generalizes simply-typed lambda calculus as the internal language of cartesian closed categories. What's more, these can be shown to correspond to cobordisms, which {{play a vital role}} in string theory.|$|E
50|$|The 'mapping object' {{referred}} to above is also called the 'internal Hom'. The internal language of closed symmetric monoidal categories is linear logic and the type system is the <b>linear</b> <b>type</b> system. Many examples of closed monoidal categories are symmetric. However, this need not always be the case, as non-symmetric monoidal categories can be encountered in category-theoretic formulations of linguistics; roughly speaking, this is because word-order in natural language matters.|$|E
50|$|A unique type is {{very similar}} to a <b>linear</b> <b>type,</b> {{to the point that the}} terms are often used interchangeably, but there is in fact a distinction: actual linear typing allows a {{non-linear}} value to be typecast to a linear form, while still retaining multiple references to it. Uniqueness guarantees that a value has no other references to it, while linearity guarantees that no more references can be made to a value.|$|E
40|$|Limel is a {{new systems}} {{programming}} language for constructing efficient, scalable data processing pipelines. Code is written {{in the style of}} ML, and the compiler statically specialises the output for execution on either multi-core systems (with call-by-reference semantics) or distributed clusters (with call-by-value semantics), or a combination of both. No modification to the source code is required to swap between calling conventions. <b>Linear</b> <b>typing</b> eliminates the need for a garbage collector, and whole-program monomorphisation means that memory values are not tagged, making the foreign function interface trivial. The big challenge with integrating <b>linear</b> <b>types</b> in day-to-day programming languages is one of usability and expressivity. In this work-in-progress paper, we describe the Limel type system and semantics, and discuss the lessons learnt so far from applying it to various problems such as functional data structures and protocol parsing. ...|$|R
40|$|The {{potential}} of linear logic in facilitating reasoning on resource usage {{has long been}} recognized. However, convincing uses of <b>linear</b> <b>types</b> in practical programming are still rather rare. In this paper, we present a general design to effectively support practical programming with <b>linear</b> <b>types.</b> In particular, we introduce and then formalize a modality, which we {{refer to as the}} sharing modality, in support of sharing of linear resources (with no use of locks). We develop the underlying type theory for the sharing modality and establish its soundness based on a notion of types with effects. We also point out an intimate relation between this modality and the issue of code reentrancy. In addition, we present realistic examples to illustrate the use of sharing modality, which are verified in the programming language ATS and thus provide a solid proof of concept...|$|R
40|$|Abstract. This article {{describes}} a one-sided variant of system l whose <b>typing</b> corresponds to <b>linear</b> sequent calculus and its application. A polarised {{version of the}} system is introduced to control the reduction strategy. The polarised type system is then extended to dependent <b>linear</b> <b>types.</b> The system with dependent type supports dependent elimination of positive connectives...|$|R
50|$|In {{category}} theory, {{a category}} is considered Cartesian closed if, roughly speaking, any morphism defined on {{a product of}} two objects can be naturally identified with a morphism defined {{on one of the}} factors. These categories are particularly important in mathematical logic and the theory of programming, in that their internal language is the simply typed lambda calculus. They are generalized by closed monoidal categories, whose internal language, <b>linear</b> <b>type</b> systems, are suitable for both quantum and classical computation.|$|E
50|$|The single-reference {{property}} makes <b>linear</b> <b>type</b> systems {{suitable as}} programming languages for quantum computation, as {{it reflects the}} no-cloning theorem of quantum states. From the category theory point of view, no-cloning is a statement {{that there is no}} diagonal functor which could duplicate states; similarly, from the combinator point of view, there is no K-combinator which can destroy states. From the lambda calculus point of view, a variable x can appear exactly once in a term.|$|E
50|$|<b>Linear</b> <b>type</b> systems allow {{references}} but not aliases. To enforce this, {{a reference}} {{goes out of}} scope after appearing {{on the right-hand side}} of an assignment, thus ensuring that only one reference to any object exists at once. Note that passing a reference as an argument to a function is a form of assignment, as the function parameter will be assigned the value inside the function, and therefore such use of a reference also causes it to go out of scope.|$|E
5000|$|Embedding between {{countable}} scattered <b>linear</b> order <b>types</b> is a well-quasi-order (Laver's theorem).|$|R
40|$|An arithmetical {{system is}} {{presented}} {{in such a way}} that from every proof a realizing term can be extracted that is definable in a certain affine <b>linear</b> <b>typed</b> variant of Gödel's T and therefore is a non-size-increasing polynomial time computable function with time complexity O(X^n) if the proof contains at most n nested uses of induction...|$|R
40|$|We {{present a}} small {{programming}} language for distributed systems based on message passing processes. In contrast to similar languages, channels are one-to-one connections between a unique sender and a unique receiver process. Process definitions and channels are first class {{values and the}} topology of process systems can change dynamically. The operational semantics of the language is defined by means of graph rewriting rules. A static type system based {{on the notion of}} <b>linear</b> <b>types</b> ensures that channels are always used as one-to-one connections. Keywords: distributed programming, process algebras, <b>linear</b> <b>types,</b> operational semantics, graph rewriting 1 Introduction Since the beginning of the eighties, process algebras have been successfully used for specifying and verifying concurrent systems. In the past years, there have been several attempts to integrate the concepts of process algebras into programming languages, mostly extending functional languages, e. g. Facile [3, 11], CML [8] or [...] ...|$|R
