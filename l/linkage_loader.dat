7|2|Public
5000|$|The {{transfer}} vector {{was prepared}} by the <b>linkage</b> <b>loader</b> when it put together the program. A transfer vector to a library function named SIMPL took this form: ...|$|E
5000|$|SIMPL STX 1 RCVR1+1 Save the caller's {{value of}} XR1 {{at a nearby}} location. LDX I1 *-* The <b>linkage</b> <b>loader</b> changes the address word {{to point to the}} {{transfer}} vector.|$|E
50|$|The {{long jump}} {{transfers}} control to SIMPL. After the instruction at 300 stores XR1, the instruction at 301 is , the <b>linkage</b> <b>loader</b> having placed 2000 at location 302. This does not load 2000 into XR1; {{it is an}} indirect instruction, and loads the contents of 2000, which is 101, the return address for that call to SIMPL.|$|E
5000|$|RLD {{records are}} used to {{relocate}} addresses. For example, a program referencing an address located 500 bytes inside the module, will internally store the address as 500, but when the module is loaded into memory it's bound to be located someplace else, so an RLD record informs the <b>linkage</b> editor or <b>loader</b> what addresses to change. Also, when a module references an external symbol, it will usually set {{the value of the}} symbol to zero, then include an RLD entry for that symbol to allow the <b>loader</b> or <b>linkage</b> editor to alter the address to the correct value.|$|R
50|$|The {{first major}} design change to tracked loaders {{came with the}} {{integration}} of hydraulic systems. Using hydraulics to power the <b>loader</b> <b>linkages</b> increased {{the power of the}} loader. More importantly, the loaders could apply downpressure to the bucket, vastly increasing their ability to dig unworked ground. Most of the tracked loaders were still based on a bulldozer equivalent. The weight of the engine was still on the front half of the tracks along with the heavy loader components. This caused many problems with heavy wear of the front idler wheels and the undercarriage in general. The Caterpillar 983 tracked loader, the second largest tracked loader ever built, was notorious for heavy undercarriage wear.|$|R
5000|$|The way SIMPL {{knew where}} its return address was is that, if SIMPL were {{declared}} a LIBF routine, the <b>linkage</b> <b>loader</b> would modify {{the code of}} SIMPL, placing the address of SIMPL's transfer vector entry at SIMPL+2. LIBF routines, unlike CALL subprograms, do not start with a DC directive to hold the return address (it is in the transfer vector) but with actual code, as follows: ...|$|E
5000|$|Suppose a LIBF-style call to SIMPL were at address 100. Then {{the return}} address would be 101, because [...] is a one-word instruction. XR3 will point into {{the group of}} {{transfer}} vectors. If the transfer vector for SIMPL started at address 2000, then the BSI would be assembled with a [...] so that XR3+disp = 2000. Executing the BSI stores 101 at location 2000 and jumps to location 2001. At 2001 would be a two-word long jump to the entry point of SIMPL, which the <b>linkage</b> <b>loader</b> might have placed at address 300.|$|E
40|$|An Interpretive Computer Simulator (ICS) for the NASA Standard Spacecraft Computer-II (NSSC-II) was {{developed}} as a code verification and testing tool for the Annular Suspension and Pointing System (ASPS) project. The simulator is written in the higher level language PASCAL and implented on the CDC CYBER series computer system. It {{is supported by a}} metal assembler, a <b>linkage</b> <b>loader</b> for the NSSC-II, and a utility library to meet the application requirements. The architectural design of the NSSC-II is that of an IBM System/ 360 (S/ 360) and supports all but four instructions of the S/ 360 standard instruction set. The structural design of the ICS is described with emphasis on the design differences between it and the NSSC-II hardware. The program flow is diagrammed, with the function of each procedure being defined; the instruction implementation is discussed in broad terms; and the instruction timings used in the ICS are listed. An example of the steps required to process an assembly level language program on the ICS is included. The example illustrates the control cards necessary to assemble, load, and execute assembly language code; the sample program to to be executed; the executable load module produced by the loader; and the resulting output produced by the ICS...|$|E
40|$|There {{are many}} {{instruction}} sequences {{that correspond to}} a program, any of which serves equally for users {{as long as they}} are functionally equivalent. In other words, there is redundancy in constructing instruction sequence of a program. Such redundancy can be utilized for watermarking or information hiding [1]. The purpose of this study is to evaluate the redundancy in instruction sequences, particularly in the order of variables and instructions. However, it is very difficult to count all redundancy, because there are many options. Thus, in this paper, only four options are examined; (1) reordering global variables, (2) reordering local variables, (3) reordering basic blocks, and (4) reordering instructions in each basic block. The performance and object size of benchmark programs are also examined before and after the reordering. All measurements were made with ELF object files for Intel x 86 architecture, which were generated by GCC 2. 95. 3 and binutils 2. 13. 2 Reordering of variables Generally, users are unaware of the addresses of variables. Therefore, we can construct functionally equivalent programs by reordering variables on main memory. Since there are n! options to arrange n elements, we can generate n! functionally equivalent instruction sequences with n variables. There are global and local variables in C language. Global variables are categorized into three types; external variables, static variables, and initialized variables. It is possible to reorder external variables by adding a feature to a <b>linkage</b> <b>loader</b> (ld), which arranges the addresses of external variables. Static variables and initialized variables are registered in. bss and. data sections, respectively, and thus can be reordered by changing the order of definition in assembly files after compilation. Local variables are allocated on stack or on registers. Local variables on stack are accessed via EBP register with the offset values that are assigned by compiler. Therefore, it is possible to reorder local variables on stack by adding a feature to C compiler. There is also certain redundancy in register allocation, which could be also utilized by enhancing C compiler. However, this redundancy is not examined in this work, leaving it for future works. 3 Reordering o...|$|E

