27|25|Public
25|$|The Unicode {{standard}} encodes 8-dot braille glyphs {{according to}} their binary appearance, rather than following their assigned numeric order. Dot 1 corresponds to the least significant bit of the <b>low</b> <b>byte</b> of the Unicode scalar value, and dot 8 to the high bit of that byte.|$|E
50|$|For example, if {{you have}} the GB2312 code point 4566 ("外", which means foreign), the high byte will be 4566/94+158=206=0xCE, and the <b>low</b> <b>byte</b> will come from 4566%94+158=212=0xD4. So, the full {{encoding}} is 0xCED4=52948.|$|E
50|$|A {{software}} {{technique was}} later developed which can play back 14-bit audio by combining two channels set at different volumes. This results in two 14-bit channels instead of four 8-bit channels. This {{is achieved by}} playing the high byte of a 16-bit sample at maximum volume, and the <b>low</b> <b>byte</b> at minimum volume (both ranges overlap, so the <b>low</b> <b>byte</b> needs to be shifted right two bits). The bit shift operation requires {{a small amount of}} CPU or blitter overhead, whereas conventional 8-bit playback is almost entirely DMA driven. This technique was incorporated into the retargetable audio subsystem AHI, allowing compatible applications to use this mode transparently.|$|E
5000|$|Handling: If it is {{anticipated}} that overflow may occur and when it happens detected and other processing done. Example: {{it is possible to}} add two numbers each two bytes wide using just a byte addition in steps: first add the <b>low</b> <b>bytes</b> then add the high bytes, but if it is necessary to carry out of the <b>low</b> <b>bytes</b> this is arithmetic overflow of the byte addition and it necessary to detect and increment the sum of the high bytes. CPUs generally have a way of detecting this to support addition of numbers larger than their register size, typically using a status bit.|$|R
50|$|Some {{architectures}} like MIPS {{have special}} unaligned load and store instructions. One unaligned load instruction gets the bytes from the memory word with the <b>lowest</b> <b>byte</b> address and another gets the bytes from the memory word {{with the highest}} byte address. Similarly, store-high and store-low instructions store the appropriate bytes in the higher and lower memory words respectively.|$|R
40|$|Method for {{conversion}} of data formats between incompatible computers reduces conversion time by 80 percent. Transposes high and <b>low</b> <b>bytes</b> of word so data from computer A match storage format of computer B. Two interface circuit boards convert data. Such boards ordinarily used for communication between computers. In format-conversion application, cable connecting boards modified so high- 8 -bit and low- 8 -bit data lines interchanged with result data words in proper format for computer B...|$|R
50|$|The 10-bit {{program counter}} is {{accessible}} as R2. Reads access only the low bits, and writes clear the high bits. An {{exception is the}} TBL instruction, which modifies the <b>low</b> <b>byte</b> while preserving bits 8 and 9.|$|E
5000|$|MUL ($62) - Multiply 8-bit x 8-bit - Multiplies {{accumulator}} {{with the}} memory specified by the zero page X addressing mode and stores the high byte of the result on the stack and the <b>low</b> <b>byte</b> in the accumulator.|$|E
5000|$|LDA #25: JSR OSWRCH \ begin PLOT LDA #1: JSR OSWRCH \ k=1 - draw {{relative}} LDA #0: JSR OSWRCH: JSR OSWRCH \ x = 0 LDA #100: JSR OSWRCH \ y = 100 (<b>low</b> <b>byte)</b> LDA #0: JSR OSWRCH \ {{high byte}} ...|$|E
50|$|If {{the highest}} and <b>lowest</b> <b>bytes</b> in a datum are not within the same memory word the {{computer}} must split the datum access into multiple memory accesses. This {{requires a lot of}} complex circuitry to generate the memory accesses and coordinate them. To handle the case where the memory words are in different memory pages the processor must either verify that both pages are present before executing the instruction or be able to handle a TLB miss or a page fault on any memory access during the instruction execution.|$|R
5000|$|The 1802 is a [...] "byte machine", but has 16 16-bit registers, R0-RF (sometimes {{referred}} to as 0-F without the 'R' prefix). To deal with 16-bit register data, the programmer must Get and Put the Hi or Lo values of the registers using the D accumulator as the go-between. These high and <b>low</b> <b>bytes</b> of the registers are sometimes {{referred to}} as Rn.0 (lo) and Rn.1 (hi). Short Branches are 2-byte opcodes with page-absolute addressing, and a 256-byte address boundary. Long Branches are 3-byte opcodes with full 16-bit address branching.|$|R
50|$|More significantly, GBK {{extended}} {{the range of}} the bytes. Having two-byte characters in the ISO-2022 GR range gives a limit of 94²=8,836 possibilities. Abandoning the ISO-2022 model of strict regions for graphics and control characters, but retaining the feature of <b>low</b> <b>bytes</b> being 1-byte characters and pairs of high bytes denoting a character, you could potentially have 128²=16,384 positions. GBK takes part of that, extending the range from - (94 choices for each byte) to - (126 choices) for the first byte and - (191 choices) for the second byte, for a total of 24,066 positions.|$|R
50|$|The Unicode {{standard}} encodes 8-dot braille glyphs {{according to}} their binary appearance, rather than following their assigned numeric order. Dot 1 corresponds to the least significant bit of the <b>low</b> <b>byte</b> of the Unicode scalar value, and dot 8 to the high bit of that byte.|$|E
50|$|STRUCLEV {{contains}} the current structure level (in the high byte) and version (in the <b>low</b> <b>byte)</b> of the file system; ODS-2 being structure level 2. An {{increase in the}} version number indicates a backwards-compatible change that older software may ignore; changes in the structure level itself are incompatible.|$|E
5000|$|DIV ($E2) - Divide 16-bit / 8-bit - Divides by {{accumulator}} the 16-bit {{data that}} is the contents of M(zz+x+1) for high byte and {{the contents of the}} next address memory for <b>low</b> <b>byte,</b> and stores the quotient in the accumulator and the remainder on the stack as one's complement.|$|E
5000|$|LDA #25: JSR OSWRCH \ begin [...] "PLOT" [...] (ASCII 25) command LDA #4: JSR OSWRCH \ command k=4, or move {{absolute}} LDA #0: JSR OSWRCH: JSR OSWRCH: JSR OSWRCH: JSR OSWRCH \ send (0, 0) as <b>low,</b> high <b>byte</b> pairs ...|$|R
50|$|String {{values are}} {{enclosed}} in 'and '' characters {{and may be}} pushed on the stack and stored in registers. The 'a' command will convert the <b>low</b> order <b>byte</b> of the numeric value into an ASCII character, or if {{the top of the}} stack is a string it will replace it with the first character of the string. There are no ways to build up strings or perform string manipulation other than executing it with the 'x' command, or printing it with the 'P' command.|$|R
50|$|Memory (storage) in System/360 is {{addressed}} {{in terms of}} 8-bit bytes. Various instructions operate on larger units called halfword (2 bytes), fullword (4 bytes), doubleword (8 bytes), quad word (16 bytes) and 2048 byte storage block, specifying the leftmost (lowest address) of the unit. Within a halfword, fullword, doubleword or quadword, <b>low</b> numbered <b>bytes</b> are more significant than high numbered bytes; this is {{sometimes referred to as}} big-endian. Many uses for these units require aligning them on the corresponding boundaries. Within this article the unqualified term word refers to a fullword.|$|R
5000|$|The 16 virtual registers, 32 bytes in total, {{are located}} in the zero page of the Apple II's real, {{physical}} memory map (at -), with values stored as <b>low</b> <b>byte</b> followed by high byte. [...] The SWEET16 interpreter itself is located from [...] to [...] in the Integer BASIC ROM.|$|E
50|$|The Chinese Foundation for Digitization Technology(中文數位化技術推廣委員會) {{introduced}} Big5+ in 1997, {{which used}} over 20000 code points to incorporate all CJK logograms in Unicode 1.1. However, the extra code points exceeded the original Big-5 definition (Big5+ uses high byte values 81-FE and <b>low</b> <b>byte</b> values 40-7E and 80-FE), preventing {{it from being}} installed on Microsoft Windows.|$|E
50|$|To map {{the code}} points to bytes, add 158 (0x98) to the row {{number of the}} code point to form the high byte, and add 158 column number of the code point to form the <b>low</b> <b>byte.</b> The row number is the code point integer divided by 94, and the column the code point modulo 94.|$|E
5000|$|The Model 20 was {{available}} with six memory sizes: 4, 8, 12, 16, 24 and 32 KB. As in other models of System/360 memory is byte-addressable. It has eight 16 bit general purpose registers numbered R8 through R15 {{which can be}} used in computations as base registers. All of memory is also directly addressable through a feature, called direct addressing, that combines the twelve bit displacement and the low-order bits of what would normally be the base register field of the instruction (R0-R7) to form a combined fifteen bit address. No storage protection is provided, except for the <b>low</b> 144 <b>bytes</b> of [...] "protected area".|$|R
5000|$|Rambo: The Video Game has {{received}} overwhelmingly negative reviews. Aggregate websites GameRankings and Metacritic gave the Xbox 360 version 40.00% and 28/100. and the PC version 32.93% and 34/100 the PlayStation 3 version 22.50% and 23/100. Reviews criticized {{the game for}} its outdated graphics, rail-shooter gameplay, dialogue that {{is made up of}} <b>low</b> quality audio <b>bytes</b> taken from the movie series, innaccurate aiming, overuse of quick-time events, frequent crashing/freezing, poor enemy A.I, and very short length (the main story can be completed in 3 1/2 hours [...] ).|$|R
40|$|This paper {{explores the}} {{possibilities}} for using the Java Modeling Language (JML) to specify Java Card applets that use Remote Method Invocation (JCRMI). The JCRMI framework {{makes it possible to}} call methods directly on a Java Card smart card without the (explicit) use of <b>low</b> level <b>byte</b> sequences, called APDUs. We introduce a new way of designing JCRMI applets, using the Java Modeling Language (JML) to formally specify (part of) its code. It turns out that some advanced JML speci cation features, such as model variables, are necessary to specify JCRMI applets. Two JML tools, the JML runtime assertion checker and the LOOP tool, are subsequently used to verify that the implementation satis es the JML speci cations. We conclude that the JML speci cations are simpler and easier to write, understand and verify when using JCRMI. Ideally this should lead to more trustworthy and error free code...|$|R
5000|$|To {{set a new}} jump {{target for}} VVBLKD (Deferred) set the Y {{register}} to the <b>low</b> <b>byte</b> of the target address, the X register to the high byte of the target address, and the Accumulator to 7, then JSR SETVBV.. The user code called through VVBLKD must exit by jumping to the OS Vertical Blank exit routine with a JMP XITVBV ($E462hex/58466dec).|$|E
5000|$|To {{set a new}} jump {{target for}} VVBLKI (Immediate) set the Y {{register}} to the <b>low</b> <b>byte</b> of the target address, the X register to the high byte of the target address, and the Accumulator to 6, then JSR SETVBV. The user code called through VVBLKI simply needs to exit by jumping to the OS Vertical Blank with a JMP SYSVBV ($E45Fhex/58463dec).|$|E
50|$|As a timer counts down, {{its value}} {{can also be}} read {{directly}} by reading its I/O port twice, first for the <b>low</b> <b>byte,</b> and then for the high byte. However, in free-running counter applications {{such as in the}} x86 PC, it is necessary to first write a latch command for the desired channel to the control register, so that both bytes read will belong to one and the same value.|$|E
50|$|The SIC {{machine has}} basic addressing, storing most memory {{addresses}} hexadecimal integer format. Similar to most modern computing systems, the SIC architecture stores all data in binary {{and uses the}} two's complement to represent negative values at the machine level. Memory storage in SIC consists of 8-bit bytes, and all memory addresses in SIC are byte addresses. Any three consecutive bytes form a 24-bit 'word' value, addressed by {{the location of the}} <b>lowest</b> numbered <b>byte</b> in the word value. Numeric values are stored as word values, and character values use the 8-bit ASCII system. The SIC machine does not support floating-point hardware and have at most 32,768 bytes of memory. There is also a more complicated machine built on top of SIC called the Simplified Instruction Computer with Extra Equipment (SIC/XE). The XE expansion of SIC adds a 48-bit floating point data type, an additional memory addressing mode, and extra memory (1 megabyte instead of 32,768 bytes) to the original machine. All SIC assembly code is upwards compatible with SIC/XE.|$|R
40|$|This paper {{presents}} {{an evaluation of}} three software implementations of release consistency. Release consistent protocols allow data communication to be aggregated, and multiple writers to simultaneously modify a single page. We evaluated an eager invalidate protocol that enforces consistency when synchronization variables are released, a lazy invalidate protocol that enforces consistency when synchronization variables are acquired, and a lazy hybrid protocol that selectively uses update to reduce access misses. Our evaluation is based on implementations running on DECstation- 5000 / 240 s connected by an ATM LAN, and an execution	driven simulator {{that allows us to}} vary network parameters. Our results show that the lazy protocols consistently outperform the eager protocol for all but one application, and that the lazy hybrid performs the best overall. However, the relative performance of the implementations is highly dependent on the relative speeds of the network, processor, and communication software. Lower bandwidths and high per byte software communication costs favor the lazy invalidate protocol, while high bandwidths and <b>low</b> per <b>byte</b> costs favor the hybrid. Performance of the eager protocol approaches that of the lazy protocols only when communication becomes essentially free...|$|R
40|$|Robotic {{storage devices}} offer huge storage {{capacity}} at a <b>low</b> cost per <b>byte,</b> but with large access times. Integrating these devices into the storage hierarchy presents {{a challenge to}} file system designers. Log-structured file systems (LFSs) were developed to reduce latencies involved in accessing disk devices, but their sequential write patterns match well with tertiary storage characteristics. Unfortunately, existing versions only manage memory caches and disks, and do not support a broader storage hierarchy. HighLight extends 4. 4 BSD LFS to incorporate both secondary storage devices (disks) and tertiary storage devices (such as robotic tape jukeboxes), providing a hierarchy within the file system that does not require any application support. This paper presents the design of HighLight, proposes various policies for automatic migration of file data between the hierarchy levels, and presents initial migration mechanism performance figures. 1...|$|R
5000|$|The {{format of}} data on the tape is: 100 bytes with the value 0x16 (SYN, Synchronous Idle), one byte with the value 0x2A (*), the record {{identification}} number, the start address (two characters for the <b>low</b> <b>byte</b> of address, two characters for the high byte), the end address (in the same format), the actual data, one byte with the value 0x2F ("/" [...] character [...] ), a two-byte checksum, and two bytes with the value 0x04 (EOT, End Of Transmission).|$|E
5000|$|Parameters {{are pushed}} onto the {{hardware}} stack as 16-bit integers {{in the order}} specified in the [...] function in <b>low</b> <b>byte,</b> high byte order. The last value pushed to the stack is a byte indicating the number of arguments. The machine language code must remove all of these vaues before returning via the [...] instruction. A value can {{be returned to the}} BASIC program by placing it in addresses 21210 and 21310 (D416 and D516) as a 16-bit integer.|$|E
5000|$|... "Mode Q" [...] ("Q" [...] being {{short for}} [...] "cube") is {{sometimes}} {{used to refer}} to Chain-4 256x256 256 colour mode. This mode's advantage is the simplistic and fast method for addressing pixels in memory based on the X and Y coordinates. The Y coordinate can simply be put in the high byte of the address, and the X coordinate in the <b>low</b> <b>byte,</b> forming the address of the pixel without a multiply, shift or lookup being needed like other video modes.|$|E
40|$|Log-structured file systems (LFSs) were {{developed}} to eliminate latencies involved in accessing disk devices, but their sequential write patterns also match well with tertiary storage characteristics. Unfortunately, existing versions only manage memory caches and disks, and do not support a broader storage hierarchy. Robotic storage devices offer huge storage capacity at a <b>low</b> cost per <b>byte,</b> but with large access times. Integrating these devices into the storage hierarchy presents a challenge to file system designers. HighLight extends 4. 4 BSD LFS to incorporate both secondary storage devices (disks) and tertiary storage devices (such as robotic tape jukeboxes), providing a hierarchy within the file system that does not require any application support. This report presents the design of HighLight, proposes various policies for automatic migration of file data between the hierarchy levels, and presents initial migration mechanism performance figures. Log-structured file systems, with thei [...] ...|$|R
40|$|High {{performance}} SIMD {{text processing}} {{using the method}} of paral-lel bit streams is introduced with {{a case study of}} UTF- 8 to UTF- 16 transcoding. A forward transform converts byte-oriented character stream data into eight parallel bit streams. Decoding, validation and computation of UTF- 8 indexed UTF- 16 bit streams are performed using bit-parallel logic and shifting operations. Conversion from UTF- 8 indexing to UTF- 16 indexing is performed using parallel bit deletion. The inverse transform is applied to yield high and <b>low</b> UTF- 16 <b>byte</b> streams which are then merged. Combined with op-timization techniques for blocks of ASCII data, speed-ups of 3 to 25 times are achieved on commodity processors compared with op-timized byte-at-a-time code. Further applications of the method of parallel bit streams to bulk text processing applications are briefly discussed along with future prospects for the combination of in-traregister and intrachip parallelism on multicore processors...|$|R
50|$|Shift JIS {{requires}} an 8-bit clean medium for transmission. It is fully backwards {{compatible with the}} legacy JIS X 0201 single-byte encoding, meaning it supports half-width katakana and that any valid JIS X 0201 string is also a valid Shift JIS string. For two-byte characters, however, Shift JIS only guarantees that the first byte will be high bit set (0x80-0xFF); {{the value of the}} second byte can be either high or <b>low.</b> Appearance of <b>byte</b> values 0x40-0x7E as second bytes of code words makes reliable Shift JIS detection difficult, because same codes are used for ASCII characters. Since the same byte value can be either first or second byte, string searches are difficult, since simple searches can match the second byte of a character and the first byte of the next, which is not a real character. String search algorithms must be tailor made for Shift JIS.|$|R
