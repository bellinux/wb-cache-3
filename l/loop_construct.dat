38|621|Public
25|$|Note {{that in the}} {{original}} Oberon language the for-loop was omitted {{in favor of the}} more general Oberon <b>loop</b> <b>construct.</b> The for-loop was reintroduced in Oberon-2.|$|E
25|$|In Ada, {{the above}} <b>loop</b> <b>construct</b> (loop-while-repeat) can be {{represented}} using a standard infinite loop (loop - end loop) that has an exit when clause in the middle (not {{to be confused with}} the exitwhen statement in the following section).|$|E
2500|$|C's for (init; test; increment) loop is {{a general}} <b>loop</b> <b>construct,</b> not {{specifically}} a counting one, although it is often used for that.|$|E
40|$|This thesis {{shows that}} the Zorn vector matrix {{construction}} which Paige used to construct simple nonassociative Moufang loops over finite fields can, in fact, be done over any commutative ring with the proper adjustments. The resulting loops are still Moufang, but no longer simple in general. Given a commutative ring and an ideal of that ring, the <b>loop</b> <b>constructed</b> over that ring can be decomposed into two pieces. In this way, it is shown that the <b>loop</b> <b>constructed</b> over Z/ 4 Z shares some structure with the Paige <b>loop</b> <b>constructed</b> over the finite field Z/ 2 Z. An in depth study of the <b>loop</b> <b>constructed</b> over Z/ 4 Z follows including significant portions of the subloop lattice {{and a variety of}} structural results...|$|R
5000|$|... new control {{structures}} (example: <b>looping</b> <b>constructs,</b> branching constructs) ...|$|R
5000|$|It uses {{recursion}} {{and logical}} quantifiers instead of traditional <b>loop</b> <b>constructs.</b>|$|R
2500|$|This {{translation}} is slightly complicated by languages which allow {{a statement to}} jump to the next iteration of the loop (such as the [...] "continue" [...] statement in C). These statements will typically implicitly increment the counter of a for-loop, but not the equivalent while-loop (since {{in the latter case}} the counter is not {{an integral part of the}} <b>loop</b> <b>construct).</b> Any translation will have to place all such statements within a block that increments the explicit counter before running the statement.|$|E
5000|$|The {{iteration}} (foreach) {{form of the}} Eiffel <b>loop</b> <b>construct</b> {{is introduced}} by the keyword [...]|$|E
5000|$|C's [...] loop is {{a general}} <b>loop</b> <b>construct,</b> not {{specifically}} a counting one, although it is often used for that.|$|E
5000|$|Perl {{also has}} two {{implicit}} <b>looping</b> <b>constructs,</b> {{each of which}} has two forms: ...|$|R
40|$|We {{show how}} to formalise {{different}} kinds of <b>loop</b> <b>constructs</b> within the refinement calculus, {{and how to use}} this formalisation to derive general transformation rules for <b>loop</b> <b>constructs.</b> The emphasis is on using algebraic methods for reasoning about equivalence and refinement of <b>loop</b> <b>constructs,</b> rather than operational ways of reasoning about loops in terms of their execution sequences. We apply the algebraic reasoning techniques to derive a collection of transformation rules for action systems an for guarded loops. These include transformation rules that have been found important in practical program derivations: data refinement and atomicity refinement of action systems; and merging, reordering, and data refinement of loops with stuttering transitions...|$|R
40|$|Assessing {{security}} threats of <b>looping</b> <b>constructs</b> There {{is a clear}} intuitive connection between the notion of leakage of information in a program and concepts from information theory. This intuition has not been satisfactorily pinned down, until now. In particular, previous informationtheoretic models of programs are imprecise, due to their overly conservative treatment of <b>looping</b> <b>constructs.</b> In this paper we provide the first precise information-theoretic semantics of <b>looping</b> <b>constructs.</b> Our semantics describes both the amount and rate of leakage; if either is small enough, then a program might be deemed “secure”. Using the semantics we provide an investigation and classification of bounded and unbounded covert channels. 1...|$|R
50|$|Note {{that in the}} {{original}} Oberon language the for-loop was omitted {{in favor of the}} more general Oberon <b>loop</b> <b>construct.</b> The for-loop was reintroduced in Oberon-2.|$|E
50|$|In Ada, {{the above}} <b>loop</b> <b>construct</b> (loop-while-repeat) can be {{represented}} using a standard infinite loop (loop - end loop) that has an exit when clause in the middle (not {{to be confused with}} the exitwhen statement in the following section).|$|E
50|$|Content {{that falls}} inside a split block of Java code (spanning {{multiple}} scriptlets) {{is subject to}} that code. Content inside an if block will only appear in the output when the if condition evaluates to true. Likewise, content inside a <b>loop</b> <b>construct</b> may appear multiple times in the output, depending upon how many times the loop body runs.|$|E
5000|$|Functional {{programming}} languages tend {{to rely on}} tail call optimization and higher-order functions {{instead of}} imperative <b>looping</b> <b>constructs.</b>|$|R
5000|$|... omp for or omp do: used {{to split}} up loop {{iterations}} among the threads, also called <b>loop</b> <b>constructs.</b>|$|R
5000|$|Most <b>looping</b> <b>constructs</b> in urbiscript come {{in several}} [...] "flavors", {{which are based}} on the four {{statement}} separators: , , , and [...]|$|R
5000|$|Fortress {{was also}} {{designed}} to be both highly parallel and have rich functionality contained within libraries, drawing from Java. For example, the [...] <b>loop</b> <b>construct</b> was a parallel operation, which would not necessarily iterate in a strictly linear manner, depending on the underlying implementation. However, the [...] construct was a library function and could be replaced by another version of the programmer's liking rather than being built into the language.|$|E
5000|$|Imperative {{programming}} in D is {{almost identical to}} that in C. Functions, data, statements, declarations and expressions work {{just as they do}} in C, and the C runtime library may be accessed directly. On the other hand, some notable differences between D and C in the area of imperative {{programming in}}clude D's [...] <b>loop</b> <b>construct,</b> which allows looping over a collection, and nested functions, which are functions that are declared inside of another and may access the enclosing function's local variables.|$|E
5000|$|This {{translation}} is slightly complicated by languages which allow {{a statement to}} jump to the next iteration of the loop (such as the [...] "continue" [...] statement in C). These statements will typically implicitly increment the counter of a for-loop, but not the equivalent while-loop (since {{in the latter case}} the counter is not {{an integral part of the}} <b>loop</b> <b>construct).</b> Any translation will have to place all such statements within a block that increments the explicit counter before running the statement.|$|E
5000|$|The <b>loop</b> <b>constructs</b> {{considerably}} {{enhance the}} modeling power of CLP(FD). The following gives {{a program for}} the N-queens problem in B-Prolog: ...|$|R
5000|$|This {{factorial}} function {{can also be}} described without using recursion by making use of the typical <b>looping</b> <b>constructs</b> found in imperative programming languages: ...|$|R
5000|$|In the {{presence}} of generators, <b>loop</b> <b>constructs</b> of a language - such as for and while - can be reduced into a single loop ... end loop construct; all the usual <b>loop</b> <b>constructs</b> can then be comfortably simulated by using suitable generators in the right way. For example, a ranged loop like [...] can be implemented as iteration through a generator, as in Python's [...] Further, [...] can be implemented as sending finish to the generator and then using [...] in the loop.|$|R
40|$|While {{programming}} {{using the}} WHILE and REPEAT constructs, as in Pascal, {{is well established}} and taught regularly, programming using a <b>LOOP</b> <b>construct</b> with multiple exits is not. I feel that this much more general construct is a more useful programming construct and {{that it should be}} taught in introductory programming courses...|$|E
40|$|Abstract. This paper {{introduces}} a new compiler optimization called with-loop-folding. It {{is based on}} a special <b>loop</b> <b>construct,</b> the withloop, which in the functional language Sac (for Single Assignment C) serves as a versatile vehicle to describe array operations on an elementwise basis. A general mechanism for combining two of these with-loops into a single <b>loop</b> <b>construct</b> is presented. This mechanism constitutes a powerful tool when it comes to generate efficiently executable code from high-level array specifications. By means of a few examples it is shown that even complex nestings of array operations similar to those available in Apl can be transformed into single loop operations which are similar to hand-optimized with-loop specifications. As a consequence, the way a complex array operation is combined from primitive array operations does not affect the runtime performance of the compiled code, i. e., the programmer is liberated from the burden to take performance considerations into account when specifying complex array operations. ...|$|E
40|$|We outline an {{extension}} of Java for programming with distributed arrays. The basic programming style is Single Program Multiple Data (SPMD), but parallel arrays are provided as new language primitives. Further extensions include three distributed control constructs, the most important being a data-parallel <b>loop</b> <b>construct.</b> Communications involving distributed arrays are handled through a standard library of collective operations. Because the underlying programming model is SPMD programming, direct calls to MPI or other communication packages are also allowed in an HPJava program...|$|E
5000|$|Structured <b>looping</b> <b>constructs,</b> with an END DO {{statement}} for loop termination, and [...] and [...] statements for terminating normal [...] loop iterations {{in an orderly}} way ...|$|R
5000|$|The {{language}} had {{relatively few}} statements {{by comparison with}} modern programming languages:Note in particular {{the lack of a}} -like statement; [...] was the only <b>looping</b> <b>construct</b> available to programmers.|$|R
5000|$|Macros allow Lisp programmers {{to create}} new {{syntactic}} forms in the language. One typical use is {{to create new}} control structures. The example macro provides an [...] <b>looping</b> <b>construct.</b> The syntax is: ...|$|R
40|$|The {{purpose of}} this chapter is to help OpenACC {{developer}} who is already familiar with the basic and essential directives to further improve his code performance by adding more descriptive clauses to OpenACC loop constructs. At {{the end of this}} chapter the reader will: • Have {{a better understanding of the}} purpose of the OpenACC <b>loop</b> <b>construct</b> and its associated clauses illustrated with use cases • Use the acquired knowledge in practice to further improve the performance of OpenACC accelerated code...|$|E
40|$|International audiencePredicate {{abstraction}} {{is a major}} abstraction {{technique for}} the verification of software. Data is abstracted by means of Boolean variables, which keep track of predicates over the data. In many cases, predicate abstraction suffers from the need {{for at least one}} predicate for each iteration of a <b>loop</b> <b>construct</b> in the program. We propose to extract from the abstract model, and to parametrise the simulation instance in the number of loop iterations. We present a novel technique that speeds up the detection of long counterexamples as well as the verification of programs with loops...|$|E
40|$|Vienna Fortran, a machine-independent {{language}} extension to Fortran {{which allows the}} user to write programs for distributed-memory systems using global addresses, provides the forall <b>loop</b> <b>construct</b> for specifying irregular computations that do not cause inter-iteration dependences. Compilers for distributed-memory systems cannot generate efficient code for such loops using compile-time techniques only. This paper presents the runtime message passing implementation and the SVM implementation. We compare both approaches and present first performance results for a realistic loop. Keywords: distributed-memory systems, shared virtual memory systems, compile-time optimization, runtime analysis, Fortran {{language extension}}s 1 Introduction Massively parallel computers (MPP) offer an immense peak performance. Current architectures consist of hundreds of nodes with physically distributed memory and are either pure distributed memory systems (Paragon), hardware-supported shared memory systems (K [...] ...|$|E
50|$|Under the Rail Clearways Project, {{the line}} {{was to have a}} {{crossing}} <b>loop</b> <b>constructed</b> at Dundas station and thus increase train frequency to half-hourly throughout the day, however this project was cancelled in November 2008.|$|R
50|$|Since the {{introduction}} of the System 38 in 1979 most RPG programmers discontinued use of the cycle in favor of controlling program flow with standard <b>looping</b> <b>constructs,</b> although IBM has continued to provide backward compatibility for the cycle.|$|R
5000|$|The {{following}} example {{creates a}} [...]bmp file with graphics and a map file in a custom text format. Notice the <b>looping</b> <b>constructs</b> and the placeholders, e.g. #tileset iterates over tilesets and populates TileSetIdentifier {{with the name}} of each tileset.|$|R
