71|63|Public
25|$|The {{original}} Unix time datatype (time_t) stores a {{date and}} time as a signed <b>long</b> <b>integer</b> (on 32 bit systems a 32-bit integer) representing the number of seconds since 1 January 1970. During and after 2038, this number will exceed 2−1, the largest number representable by a signed <b>long</b> <b>integer</b> on 32 bit systems, causing the Year 2038 problem (also known as the Unix Millennium bug or Y2K38). As a <b>long</b> <b>integer</b> in 64 bit systems uses 64 bits, the problem does not realistically exist on 64 bit systems that use the LP64 model.|$|E
500|$|Microsoft also marketed {{through an}} Apple dealer in West Palm Beach, Florida two {{products}} for the Radio-Shack TRS-80. One was [...] "Typing Tutor" [...] which led the user through learning to use a keyboard. The other was authored by {{a professor at the}} University of Hawaii called [...] "MuMATH" [...] and had the ability to do mathematics in <b>long</b> <b>integer</b> math to avoid floating point numbers. In this sense it was similar to the early ARPANET.|$|E
50|$|You can use Real, Integer, and <b>Long</b> <b>Integer</b> {{variables}} {{as well as}} inter-process, process, and local variable counters. For lengthy repetitive loops, especially in compiled mode, use local <b>Long</b> <b>Integer</b> variables.|$|E
50|$|In 2016 Covanov and Thomé {{proposed}} an original multiplication algorithm of <b>long</b> <b>integers</b> {{based on the}} generalization of Fermat primes.|$|R
5000|$|... random: AutoNumbers {{generated}} by this mechanism are assigned using a pseudo-random number generator that generates <b>long</b> <b>integers</b> and checks for collisions with existing table rows.|$|R
50|$|It is {{particularly}} important to recognize the compiler idioms for subroutine calls, exception handling, and switch statements. Some languages also have extensive support for strings or <b>long</b> <b>integers.</b>|$|R
5000|$|The default {{size of an}} AutoNumber is a 4-byte (<b>long)</b> <b>integer.</b> This is {{the size}} used for start+increment and random AutoNumbers. For {{replication}} ID AutoNumbers, the [...] property of the field is changed from <b>long</b> <b>integer</b> to [...]|$|E
5000|$|The {{original}} Unix time datatype (...) stores a {{date and}} time as a signed <b>long</b> <b>integer</b> (on 32 bit systems a 32-bit integer) representing the number of seconds since 1 January 1970. During and after 2038, this number will exceed 2 − 1, the largest number representable by a signed <b>long</b> <b>integer</b> on 32 bit systems, causing the Year 2038 problem (also known as the Unix Millennium bug or Y2K38). As a <b>long</b> <b>integer</b> in 64 bit systems uses 64 bits, the problem does not realistically exist on 64 bit systems that use the LP64 model.|$|E
50|$|In Pascal, copying a real to {{an integer}} {{converts}} {{it to the}} truncated value. This method would translate the binary value of the floating-point number into whatever it is as a <b>long</b> <b>integer</b> (32 bit), which {{will not be the}} same and may be incompatible with the <b>long</b> <b>integer</b> value on some systems.|$|E
40|$|AbstractCurrent {{computer}} algebra systems use the quotient-remainder algorithm for {{division of}} <b>long</b> <b>integers</b> {{even when it}} is known in advance that the remainder is zero. We propose an algorithm which computes the quotient of two <b>long</b> <b>integers</b> in this particular situation, starting from the least-significant digits of the operands. This algorithm is particularly efficient when the radix is a prime number or a power of 2. The computing time of this new algorithm is smaller than the computing time of the classical division algorithm. If the length of the result is much smaller than the lengths of the inputs, then the speed-up may be quite significant, as it is confirmed by practical experiments. Most importantly, however, the new algorithm is better suited for systolic parallelization in a "least-significant digit first" pipelined manner, and therefore it is suitable for aggregation with other systolic algorithms for the arithmetic of <b>long</b> <b>integers</b> and <b>long</b> rationals. We also present applications of this algorithm in integer GCD computation and in division modulo a power of 2...|$|R
50|$|Java {{does not}} support C/C++ style pointer arithmetic, where object {{addresses}} and unsigned <b>integers</b> (usually <b>long</b> <b>integers)</b> can be used interchangeably. This allows the garbage collector to relocate referenced objects and ensures type safety and security.|$|R
40|$|We provide two {{complexity}} {{measures that}} can be used to measure the running time of algorithms to compute multiplications of <b>long</b> <b>integers.</b> The random access machine with unit or logarithmic cost is not adequate for measuring the complexity of a task like multiplication of <b>long</b> <b>integers.</b> The Turing machine is more useful here, but fails to take into account the multiplication instruction for short integers, which is available on physical computing devices. An interesting outcome is that the proposed refined complexity measures do not rank the well known multiplication algorithms the same way as the Turing machine model. Comment: To appear in the proceedings of Latin 2014. Springer LNCS 839...|$|R
5000|$|The minimum {{range of}} a <b>long</b> <b>integer</b> {{variable}} in the C and C++ programming languages.|$|E
50|$|For GOM six {{additional}} modes are added: CHARACTER, SHORT INTEGER, BYTE INTEGER, <b>LONG</b> <b>INTEGER,</b> POINTER, and DYNAMIC RECORD.|$|E
50|$|A <b>long</b> <b>integer</b> can {{represent}} a whole integer whose range {{is greater than}} or equal to that of a standard integer on the same machine.|$|E
40|$|Abstract. A new {{approach}} to the computation of <b>long</b> <b>integers</b> cube- third power- computation based on a splitting in two divide et impera approach and on a modified Toom-Cook unbalanced method is presented. A detailed description of its practical implementation by using the GMP library and performance comparison are also described...|$|R
5000|$|Set a to aA + bB and b to Ca + Db (again simultaneously). This {{applies the}} steps of the {{euclidean}} algorithm that were performed on the leading digits in compressed form to the <b>long</b> <b>integers</b> a and b. If b ≠ 0 go {{to the start of the}} outer loop.|$|R
40|$|We {{address to}} the problem to factor a large {{composite}} number by lattice reduction algorithms. Schnorr [Sc 93] has shown that under a reasonable number theoretic assumptions this problem {{can be reduced to}} a simultaneous diophantine approximation problem. The latter in turn can be solved by finding sufficiently many ` 1 [...] short vectors in a suitably defined lattice. Using lattice basis reduction algorithms Schnorr and Euchner applied the reduction technique of [Sc 93] to 40 [...] bit <b>long</b> <b>integers.</b> Their implementation needed several hours to compute a 5 % fraction of the solution, i. e., 6 out of 125 congruences which are necessary to factorize the composite. In this report we describe a more efficient implementation using stronger lattice basis reduction techniques incorporating ideas of [SH 95] and [R 97]. For 60 [...] bit <b>long</b> <b>integers</b> our algorithm yields a complete factorization in less than 3 hours. 1 Introduction The security of many public key cryptosystems relies on the hardness of factoring [...] ...|$|R
5000|$|Integer literals {{frequently}} have prefixes indicating base, and less frequently suffixes indicating type. For example, [...] indicates the value 16 (because hexadecimal) as an unsigned long <b>long</b> <b>integer</b> in C++.|$|E
5000|$|If an AutoNumber is a <b>long</b> <b>integer,</b> the [...] {{property}} {{determines whether}} it is of the start+increment or random form. The values that this property can take are [...] "Increment" [...] and [...] "Random".|$|E
5000|$|CPU core: MIPS R5900 (COP0), 64-bit, little endian (mipsel). CPU is a superscalar, in-order 2-issue {{design with}} 6-stage <b>long</b> <b>integer</b> pipelines, four 32 bit GPR registers, 32 128-bit SIMD linear scalar registers, two 64-bit integer ALUs, 128-bit load-store unit (LSU) and a branch {{execution}} unit (BXU).|$|E
50|$|Addition of <b>long</b> <b>integers</b> {{suffers from}} the problem that carries have to be {{propagated}} {{from right to left}} and the final result is not known until this process has been completed. Carry propagation can be speeded up with carry look-ahead logic, but this still makes addition very much slower than it needs to be (for 512-bit addition, addition with carry look-ahead is 32 times slower than addition without carries at all).|$|R
50|$|Some {{languages}} {{provide more}} than one kind of literal, which have different behavior. This is particularly used to indicate raw strings (no escaping), or to disable or enable variable interpolation, but has other uses, such as distinguishing character sets. Most often this is done by changing the quoting character or adding a prefix. This is comparable to prefixes and suffixes to integer literals, such as to indicate hexadecimal numbers or <b>long</b> <b>integers.</b>|$|R
40|$|Karatsuba and Toom-Cook are {{well-known}} {{methods used}} to efficiently multiply univariate polynomials and <b>long</b> <b>integers.</b> For multivariate polynomials, asymptotically good approaches like Kronecker’s trick combined with FFT become truly effective only when the degree is above some threshold. In this paper we analyze Karatsuba and some of Toom-Cook methods for multivariate polynomials, considering density {{in a different way}} with respect to Kronecker, and present some algorithms for fast multivariate polynomial multiplication in practical cases, when degrees are not huge. A fast sparse polynomial multiplication algorithm is also proposed...|$|R
5000|$|SA1 X [...] "SET" [...] REGISTER A1 TO THE ADDRESS OF X (30 bits) SA2 Y [...] "SET" [...] REGISTER A2 TO THE ADDRESS OF Y (30 bits) IX6 X1+X2 <b>LONG</b> <b>INTEGER</b> ADD X AND Y, RESULT INTO X6 (15 bits) SA6 Z [...] "SET" [...] REGISTER A6 TO THE ADDRESS OF Z (30 bits) ...|$|E
5000|$|The number 9,223,372,036,854,775,807, {{equivalent}} to the hexadecimal value 7FFF,FFFF,FFFF,FFFF, is the maximum value for a 64-bit signed integer in computing. It is therefore the maximum value for a variable declared as a <b>long</b> <b>integer</b> ( [...] , , or [...] ) in many programming languages running on modern computers. The presence of the value may reflect an error, overflow condition, or missing value.|$|E
50|$|Among {{dynamically}} typed languages, Python is moderately type-checked. Implicit conversion {{is defined}} for numeric types (as well as booleans), so one may validly multiply a complex number by a <b>long</b> <b>integer</b> (for instance) without explicit casting. However, {{there is no}} implicit conversion between (e.g.) numbers and strings; a string is an invalid argument to a mathematical function expecting a number.|$|E
5000|$|... {{implicit}} narrowing conversions - requiring all conversions to narrower types (e.g. from <b>Long</b> to <b>Integer,</b> Object to String, Control to TextBox) be {{explicit in}} code using conversion operators (e.g. CInt, DirectCast, CType).|$|R
40|$|Work is {{partially}} {{supported by the}} Lithuanian State Science and Studies Foundation. The key agreement protocol (KAP) is constructed using matrix power functions. These functions are based on matrix ring action on some matrix set. Matrix power functions have some indications as being a one- way function since they are linked with certain generalized satisfiability problems which are potentially NP- Complete. A working example of KAP with guaranteed brute force attack prevention is presented for certain algebraic structures. The main advantage of proposed KAP is considerable fast computations and avoidance of arithmetic operations with <b>long</b> <b>integers...</b>|$|R
40|$|Many Internet {{applications}} require intensive cryptographic calculation such as public-key encryptions {{and digital}} signatures. These schemes require a computation of large integer multiplications. Those cryptographic schemes {{are vulnerable to}} a brute-force attack, and the large key is the countermeasure. In practice, the key size that makes brute-force attack impractical will slows down the speed of encryption and decryption. Multiplication of two very <b>long</b> <b>integers</b> usually takes time to compute. Distributed Karatsuba algorithm is proposed to reduce the time of multiplication of two very long digits. The proposed architecture that makes use of Karatsuba algorithm achieves faster multiplication...|$|R
5000|$|A {{union is}} a data {{structure}} that specifies which {{of a number}} of permitted primitive types may be stored in its instances, e.g. float or <b>long</b> <b>integer.</b> Contrast with a record, which could be defined to contain a float and an integer; whereas in a union, there is only one value at a time. Enough space is allocated to contain the widest member datatype.|$|E
5000|$|In {{the mapping}} file example, [...] {{refers to the}} <b>long</b> <b>integer</b> value passed into the query. If the {{parameter}} is a Java object, then values from properties on that object can be inserted into the query using a similar [...] notation. For example, if the parameter class is a [...] which has a property called , then [...] can be replaced with [...] The [...] object is an instance of class [...]|$|E
5000|$|Microsoft also marketed {{through an}} Apple dealer in West Palm Beach, Florida two {{products}} for the Radio-Shack TRS-80. One was [...] "Typing Tutor" [...] which led the user through learning to use a keyboard. The other was authored by {{a professor at the}} University of Hawaii called [...] "MuMATH" [...] and had the ability to do mathematics in <b>long</b> <b>integer</b> math to avoid floating point numbers. In this sense it was similar to the early ARPANET.|$|E
40|$|Abstract. Karatsuba and Toom-Cook are {{well-known}} {{methods used}} to multiply efficiently two <b>long</b> <b>integers.</b> There have been different proposal about the interpolating values {{used to determine the}} matrix to be inverted and the sequence of operations to invert it. A definitive word about which is the optimal matrix (values) and the (number of) basic operations to invert it seems still not to have been said. In this paper we present some particular examples of useful matrices and a method to generate automatically, by means of optimised exhaustive searches on a graph, the best sequence of basic operations to invert them...|$|R
5000|$|Concurrent Euclid (ConEuc) is a {{concurrent}} {{descendant of}} the Euclid programming language designed by James Cordy and Ric Holt, then at the University of Toronto, in 1980. ConEuc was designed for concurrent, high performance, highly reliable system software, such as operating systems, compilers and embedded microprocessor systems. The TUNIS operating system, a Unix variant, was implemented entirely in Concurrent Euclid. ConEuc extends a core subset of Euclid with processes and monitors (as specified by C.A.R. Hoare) as well as language constructs needed for systems programming including separate compilation, variables at absolute addresses, type converters, <b>long</b> <b>integers</b> and other features.|$|R
5000|$|It {{follows that}} an object {{definition}} {{can be extended}} by imposing data typing: a representation format, a default value, and legal operations (rules) and restrictions ("Division by zero {{is not to be}} tolerated!") are all potentially involved in defining an attribute, or conversely, may be spoken of as attributes of that object's type. A JPEG file is not decoded by the same operations (however similar they may be - these are all graphics data formats) as a PNG or BMP file, nor is a floating point typed number operated upon by the rules applied to typed <b>long</b> <b>integers.</b>|$|R
