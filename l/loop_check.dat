13|80|Public
5000|$|Thus {{an obvious}} {{way to handle}} signals is for signal {{handlers}} to set a global flag and have the event <b>loop</b> <b>check</b> for the flag immediately {{before and after the}} select (...) call; if it is set, handle the signal {{in the same manner as}} with events on file descriptors. Unfortunately, this gives rise to a race condition: if a signal arrives immediately between checking the flag and calling select (...) , it will not be handled until select (...) returns for some other reason (for example, being interrupted by a frustrated user).|$|E
50|$|In {{computer}} telecommunications, echo is {{the display}} or return of sent data at {{or to the}} sending end of a transmission. Echo can be either local echo, where the sending device itself displays the sent data, or remote echo, where the receiving device returns the sent data that it receives to the sender (which is of course simply no local echo {{from the point of}} view of the sending device itself). That latter, when used as a form of error detection to determine that data received at the remote end of a communications line are the same as data sent, is also known as echoplex, echo check, or <b>loop</b> <b>check.</b> When two modems are communicating in echoplex mode, for example, the remote modem echoes whatever it receives from the local modem.|$|E
5000|$|The visitor for {{the classic}} Spaceship example {{also has a}} double-dispatch mechanism.make -- Allow SPACESHIP objects to visit and move about in a universe. local l_universe: ARRAYED_LIST SPACE_OBJECT l_enterprise, l_excelsior: SPACESHIP do create l_enterprise.make_with_name ("Enterprise", [...] "A-001") create l_excelsior.make_with_name ("Excelsior", [...] "A-003") create l_universe.make (0) l_universe.force (l_enterprise) l_universe.force (create {ASTEROID}.make_with_name ("Rogue 1", [...] "A-002")) l_universe.force (create {ASTEROID}.make_with_name ("Rogue 2", [...] "A-003")) l_universe.force (l_excelsior) l_universe.force (create {ASTEROID}.make_with_name ("Rogue 3", [...] "A-004")) l_universe.force (create {SPACESTATION}.make_with_name ("Deep Space 9", [...] "A-005")) visit (l_enterprise, l_universe) l_enterprise.set_position ("A-002") visit (l_enterprise, l_universe) l_enterprise.set_position ("A-003") visit (l_enterprise, l_universe) l_enterprise.set_position ("A-004") l_excelsior.set_position ("A-005") visit (l_enterprise, l_universe) visit (l_excelsior, l_universe) l_enterprise.set_position ("A-005") visit (l_enterprise, l_universe) endfeature {NONE} -- Implementationvisit (a_object: SPACE_OBJECT; a_universe: ARRAYED_LIST SPACE_OBJECT) -- `a_object' visits `a_universe'. do across a_universe as ic_universe <b>loop</b> <b>check</b> {{attached}} {SPACE_OBJECT} ic_universe.item as al_universe_object then a_object.encounter_agent.call (al_universe_object.sensor_data_agent) end end endThe double-dispatch can be see in line #35, where two indirect agents are working together to provide two co-variant calls working in perfect polymorphic concert with each other. The `a_object' of the `visit' feature has an `encounter_agent' which is called with the sensor data of the `sensor_data_agent' coming from the `al_universe_object'.The other interesting part of this particular example is the SPACE_OBJECT class and its `encounter' feature: ...|$|E
40|$|Description Logic (DL) formalisms {{have gained}} success in many {{application}} areas such as knowledge representation, database reasoning, multi-agent systems, semantic web, and ontology reasoning. The most explored reasoning approach for DLs is the tableau approach. Existing tableau-based DL systems essentially exploit the various kinds of the tree-model properties of DLs. It is known that the (standard) <b>loop</b> <b>checking</b> procedure is avoidable only in tableau algorithms for inexpressive DLs. <b>Loop</b> <b>checking</b> mechanisms are vital for logics with universal modalities, TBox reasoning, and/or transitive roles. However, the standard <b>loop</b> <b>checking</b> rule has various disadvantages. From a practical perspective implementation in a DL prover usually requires quite considerable effort. The standard <b>loop</b> <b>checking</b> mechanism is very sensitive to a notion of a finite type in a particular DL. Since {{the notion of a}} type varies from one logic to another, small changes {{in the language of the}} underlying DL and/or in the tableau procedure can force considerable redesign and refactoring of the code related to the <b>loop</b> <b>checking.</b> In this paper we propose and study alternative <b>loop</b> <b>checking</b> mechanisms. Our facilitation of <b>loop</b> <b>checking</b> uses inference rules which while being simple are also more general than standard <b>loop</b> <b>checking</b> mechanisms implemented in DL systems and remedy the mentioned problems. We focus on the description logic ALCIO(U). This is an extension of the basic DL ALC with inverse operator on roles, nominals (or objects/ABox elements) and the top role. As the language includes nominals and the universal modality, concept satisfiability with respect to (non-empty) TBox and (non-empty) ABox can be reduced to plain concep...|$|R
40|$|Two {{complete}} <b>loop</b> <b>checking</b> mechanisms {{have been}} presented in the literature for logic programs with functions: OS-check and EVA-check. OS-check is computationally ecient but quite unreliable in that it often mis-identies innite loops, whereas EVA-check is reliable {{for a majority of}} cases but quite expensive. In this paper, we develop a series of new complete <b>loop</b> <b>checking</b> mechanisms, called VAF-checks. The key technique we introduce is the notion of expanded variants, which captures a key structural characteristic of innite loops. We show that our approach is superior to both OS-check and EVA-check in that it is as ecient as OS-check and as reliable as EVA-check. Keywords: <b>Loop</b> <b>checking,</b> logic programming. ...|$|R
40|$|Most of the sequent/tableau based proof {{systems for}} the modal logic S 4 need to {{duplicate}} formulas and thus are required to adopt some method of <b>loop</b> <b>checking</b> [7, 13, 10]. In what follows we present a tableau-like proof system for S 4, based on D’Agostino and Mondadori’s classical KE [3], which is free of duplication and <b>loop</b> <b>checking.</b> The ke...|$|R
30|$|While CEP {{provides}} several {{benefits for}} data stream processing, such as continuous query, pattern detection, and temporal windows, {{it is difficult}} to express iterative controls, e.g., while and for repetition structures, using its primitives. Typically, CEP-based applications follow a pipeline stage topology, with data flow in a given direction from one stage to one or more stages, but without returning to previous stages. This can be troublesome when describing iterative algorithms, such as K-means, which require iterations to converge. To overcome this problem, we simulated the <b>loop</b> <b>check</b> by using two EPL rules. If the <b>loop</b> <b>check</b> is false, i.e., if evidence has not change its centroid, we push the event to the next processing stages. However, if the <b>loop</b> <b>check</b> is true, i.e., evidence has changed its centroid, we reinsert these events into the initial loop stage, which recomputes the centroid distance. We do so by translating the events to EvidenceStreamEvents, the event type that the initial loop phase (distance computation) expects.|$|E
40|$|AbstractLoop {{checking}} is {{a mechanism}} for pruning infinite SLD-derivations. In (Bol, Apt and Klop, 1991) simple loop checks were introduced and their soundness, completeness and relative strength was studied. Since no sound and complete simple <b>loop</b> <b>check</b> exists {{even in the absence}} of function symbols, subclasses of programs were determined for which the (sound) loop checks introduced by Bol are complete. In this paper, the Generalization Theorem is proved. This theorem presents a method to extend (under certain conditions) a class of programs for which a given <b>loop</b> <b>check</b> is complete to a larger class, for which the <b>loop</b> <b>check</b> is still complete. Then this theorem is applied to the results of Bol, giving rise to stronger completeness theorems. It appears that unnecessary complications in the proof of the theorem can be avoided by introducing a normal form for SLD-derivations, allowing only certain most general unifiers. This normal form might have other applications than those in the area of loop checking...|$|E
40|$|AbstractWe {{systematically}} study {{loop checking}} mechanisms for logic programs by considering their soundness, completeness, relative strength and related concepts. We introduce a natural {{concept of a}} simple <b>loop</b> <b>check</b> and prove that no sound and complete simple <b>loop</b> <b>check</b> exists, even for programs without function symbols. Then we introduce a number of sound simple loop checks and identify natural classes of Prolog programs without function symbols {{for which they are}} complete. In these classes a limited form of recursion is allowed. As a by-product we obtain an implementation of the closed world assumption of Reiter (1978) and a query evaluation algorithm for these classes of logic programs...|$|E
40|$|AbstractIn a {{communication}} system, we consider two models of error control policies to transmit data more accurately: Model 1 {{is a double}} transfer checking policy which sends two data, and Model 2 is a <b>loop</b> <b>checking</b> policy which sends back data. For two models, the transmission fails with probability qj at its number j and stops at a maximum number N. The expected cost rates are derived and optimal numbers N∗ to minimize them are discussed. We compare two costs and show that a double transfer checking {{is better than a}} <b>loop</b> <b>checking</b> under some reasonable conditions...|$|R
40|$|AbstractTwo {{complete}} <b>loop</b> <b>checking</b> mechanisms {{have been}} presented in the literature for logic programs with functions: OS-check and EVA-check. OS-check is computationally efficient but quite unreliable in that it often mis-identifies infinite loops, whereas EVA-check is reliable {{for a majority of}} cases but quite expensive. In this paper, we develop a series of new complete <b>loop</b> <b>checking</b> mechanisms, called VAF-checks. The key technique we introduce is the notion of expanded variants, which captures a key structural characteristic of infinite loops. We show that our approach is superior to both OS-check and EVA-check in that it is as efficient as OS-check and as reliable as EVA-check...|$|R
5000|$|The inner <b>loop</b> <b>checks</b> {{every point}} in the set S, and the outer loop repeats for each point on the hull. Hence the total run time is [...] The run time depends {{on the size of}} the output, so Jarvis's march is an output-sensitive algorithm.|$|R
40|$|We {{develop a}} general {{technique}} for computing functional integrals with fixed area and boundary length constraints. The correct quantum dimensions for the vertex functions are recovered by properly regularizing the Green function. Explicit computation is {{given for the}} one point function providing the first one <b>loop</b> <b>check</b> of the bootstrap formula. Comment: LaTeX 26 page...|$|E
40|$|AbstractLoop {{checking}} {{mechanisms are}} used to detect and prune infinite SLD derivations, through run time checks which are introduced in logic program interpreters. Simple loop checks, i. e. checks which do {{not depend on the}} specific logic program, have been widely studied in literature. Since no sound and complete <b>loop</b> <b>check</b> exists even in the case of function-free programs, several subclasses have been characterized for which sound and complete loop checks can be determined. In this paper a theoretical framework for analysing properties of <b>loop</b> <b>check</b> mechanisms for logic programs is proposed, which exploits general mathematical results about well-quasi-ordered (wqo) sets. In a way, the method {{can be viewed as a}} counterpart of well known techniques based on well-founded partial-ordering, used in termination proofs for rewriting systems and for logic programs. The main results are obtained on the basis of a combinatorial analysis of properties of wqo sets of goals. As shown in the paper, subclasses of programs, for which sound and complete simple loop checks exist, can be easily framed in the wqo approach. Reasons for the different behaviours of subsumption loop checks based on list and multiset goal comparisons are also plainly highlighted...|$|E
40|$|In {{this paper}} we present two {{terminating}} tableau calculi for propositional Dummett logic obeying the subformula property. The ideas of our calculi {{rely on the}} linearly ordered Kripke semantics of Dummett logic. The first calculus works on two semantical levels: {{the present and the}} next possible world. The second calculus employs the usual object language of tableau systems and exploits a property of the construction of the completeness theorem to introduce a check which is an alternative to <b>loop</b> <b>check</b> mechanisms. Comment: 21 pages, rejected at CSL 201...|$|E
40|$|AbstractIn {{this paper}} we extend {{the concept of}} <b>loop</b> <b>checking</b> from {{positive}} programs (as described in [1]) to locally stratified programs. Such an extension is not straightforward: the introduction of negation requires a (re) consideration of the choice of semantics, the description of a related search space, and new soundness and completeness results handling floundering in a satisfactory way. Nevertheless, an extension is achieved {{that allows us to}} generalize the <b>loop</b> <b>checking</b> mechanisms from positive programs to locally stratified programs, while preserving most soundness and completeness results. The conclusion is that negative literals cannot give rise to loops, and must be simply ignored. Note: the material presented in this paper is contained in [5, ch. 5], in which also [1, 4] can be found...|$|R
40|$|In nite {{loops and}} {{redundant}} computations are long recognized open problems in Prolog. Two ways have been explored {{to resolve these}} problems: <b>loop</b> <b>checking</b> and tabling. <b>Loop</b> <b>checking</b> can cut innite loops, but it cannot be both sound and complete even for function-free logic programs. Tabling {{seems to be an}} eective way to resolve in-nite loops and redundant computations. However, existing tabulated resolutions, such as OLDT-resolution, SLG-resolution, and Tabulated SLS-resolution, are non-linear because they rely on the solution-lookup mode in formulating tabling. The principal disadvantage of non-linear resolutions is that they cannot be implemented using a simple stack-based memory structure like that in Prolog. Moreover, some strictly sequential operators such as cuts may not be handled as easily as in Prolog. In this paper, we propose a hybrid method to resolve innite loops and redundant computations. We combine the ideas of <b>loop</b> <b>checking</b> and tabling to establish a linear tabulated resolution called TP-resolution. TP-resolution has two distinctive features: (1) It makes linear tabulated derivations {{in the same way as}} Prolog except that innite loops are broken and redundant computations are reduced. It handles cuts as eectively as Prolog. (2) It is sound and complete for positive logic programs with the bounded-term-size property. The underlying algorithm can be implemented by an extension to any existing Prolog abstract machines such as WAM or ATOAM...|$|R
40|$|Most of the sequent/tableau based proof {{systems for}} the modal logic S 4 need to {{duplicate}} formulas and thus are required to adopt some method of <b>loop</b> <b>checking.</b> In what follows we present a tableau-like proof system for S 4, based on D 2 ̆ 7 Agostino and Mondadori 2 ̆ 7 s classical KE, which is free of duplication and <b>loop</b> <b>checking.</b> The key feature of this system (let us call it KES 4) consists in its use of (i) a label formalism which models the semantics of the modal operators according to the usual conditions for S 4; and (ii) a label unification scheme which tells us when two labels "denote" the same world in the S 4 -model(s) generated {{in the course of}} proof search. Moreover, it uses special closure conditions to check models for putative contradictions...|$|R
40|$|AbstractIn the {{framework}} of Lloyd and Shepherdson [16], partial deduction involves the creation of SLDNF-trees for a given program and some goals up to certain halting points. This paper identifies the relation between halting criteria for partial deduction and loop checking (as formalized in [1]). For simplicity, we consider only positive programs and SLD-resolution here. It appears that loop checks for partial deduction must be complete, whereas traditionally, the soundness of a <b>loop</b> <b>check</b> is more important. However, it is also shown that sound loop checks can contribute to improve partial deduction. Finally, a class of complete loop checks suitable for partial deduction is identified...|$|E
40|$|AbstractA simple {{analysis}} of the arguments developed by Bol et al. (Theoret. Comput. Sci. 86, 35 - 79 (1991)) shows that an actual reason for the nonexistence of a complete sound simple check for all function-free programs is the presence in the resolvents of potentially unlimited sequences of atoms chained by common variables. This hints that a limitation {{of the number of}} variables generating this kind of chain could guarantee the applicability of complete simple loop checks. This line is followed in the paper, and quite general classes of logic programs are characterized, without any direct imposition on the structures of the rules. This objective is accomplished by exploiting a variant of SLD-resolution, which is able to perform a systematic elimination of redundant atoms from resolvents. As a notable result, {{it turns out that the}} equality <b>loop</b> <b>check</b> is complete for our class of logic programs. This seems to suggest that the necessity of using subsumption loop checks instead of equality checks is essentially due to the presence of redundant atoms in resolvents...|$|E
40|$|Using a {{calculus}} of goals, {{we define}} the {{success and failure}} of a goal for propositional programs {{in the presence of}} loop checking. The calculus is sound with respect to the well-founded semantics; for finite programs, it is also complete. A Prolog-style proof search strategy for a modification of this calculus provides a query evaluation algorithm for finite propositional programs under the well-founded semantics. This algorithm is implemented as a meta-interpreter. 1 Introduction A "loop check" in a logic programming system is a mechanism that allows the system to avoid some infinite loops. For instance, the execution of the program p / not q; not r; q / r; p; r / q; p (1) under Prolog would lead to an infinite loop, because Prolog would attempt to "derive" q from r and then r from q. A system with a <b>loop</b> <b>check</b> may be able to recognize this fact and to conclude that the goals q and r fail, and, accordingly, the goal p succeeds. In this paper, we make the idea of loop ch [...] ...|$|E
40|$|This work {{provides}} the full proofs {{of the properties}} of the tableaux calculus for hybrid logic with the global and converse modalities presented in [3], which focuses on the HL(@) fragment of the calculus. While such a fragment terminates without <b>loop</b> <b>checks,</b> when the converse and global modalities are added to the language, and the corresponding rules to the system, termination is achieved by means of a <b>loop</b> <b>checking</b> mechanism. The peculiarity of the system is the treatment of nominal equalities by means of a substitution rule. The main advantage of such a rule, compared with other approaches, is its efficiency, that has been experimentally verified for the HL(@) fragment. Such an advantage should persist in the extended calculus. In this work we give the detailed termination and completeness proofs for the entire calculus. Although the main guidelines are the same as the corresponding proofs fo...|$|R
40|$|Infinite {{loops and}} {{redundant}} computations are long recognized open problems in Prolog. Two ways have been explored {{to resolve these}} problems: <b>loop</b> <b>checking</b> and tabling. <b>Loop</b> <b>checking</b> can cut infinite loops, but it cannot be both sound and complete even for function-free logic programs. Tabling {{seems to be an}} effective way to resolve infinite loops and redundant computations. However, existing tabulated resolutions, such as OLDT-resolution, SLG- resolution, and Tabulated SLS-resolution, are non-linear because they rely on the solution-lookup mode in formulating tabling. The principal disadvantage of non-linear resolutions is that they cannot be implemented using a simple stack-based memory structure like that in Prolog. Moreover, some strictly sequential operators such as cuts may not be handled as easily as in Prolog. In this paper, we propose a hybrid method to resolve infinite loops and redundant computations. We combine the ideas of <b>loop</b> <b>checking</b> and tabling to establish a linear tabulated resolution called TP-resolution. TP-resolution has two distinctive features: (1) It makes linear tabulated derivations {{in the same way as}} Prolog except that infinite loops are broken and redundant computations are reduced. It handles cuts as effectively as Prolog. (2) It is sound and complete for positive logic programs with the bounded-term-size property. The underlying algorithm can be implemented by an extension to any existing Prolog abstract machines such as WAM or ATOAM. Comment: To appear as the first accepted paper in Theory and Practice of Logic Programming ([URL]...|$|R
40|$|The {{termination}} {{problem of}} a logic program can be addressed in either a static or a dynamic way. A static approach performs termination analysis at compile time, while a dynamic approach characterizes and tests termination of a logic program by applying a <b>loop</b> <b>checking</b> technique. In this paper, we present a novel dynamic approach to termination analysis for general logic programs with moded queries. We address several interesting questions, including how to formulate an SLDNF-derivation for a moded query, how to characterize an infinite SLDNF-derivation with a moded query, and how to apply a <b>loop</b> <b>checking</b> mechanism to cut infinite SLDNF-derivations {{for the purpose of}} termination analysis. The proposed approach is very powerful and useful. It can be used (1) to test if a logic program terminates for a given concrete or moded query, (2) to test if a logic program terminates for all concrete or moded queries, and (3) to find all (most general) concrete/moded queries that are most likely terminating (or non-terminating) ...|$|R
40|$|Using a {{calculus}} of goals, {{we define}} the {{success and failure}} of a goal for propositional programs {{in the presence of}} <b>loop</b> <b>checking.</b> The calculus is sound with respect to the well-founded semantics; for finite programs, it is also complete. A Prolog-style proof search strategy for a modification of this calculus provides a query evaluation algorithm for finite propositional programs under the well-founded semantics. This algorithm is implemented as a meta-interpreter. ...|$|R
40|$|Introduction Most of the sequent/tableau based proof {{systems for}} the modal logic S 4 need to {{duplicate}} formulas and thus are required to adopt some method of <b>loop</b> <b>checking</b> [7, 13, 10]. In what follows we present a tableau-like proof system for S 4, based on D'Agostino and Mondadori's classical KE [3], which is free of duplication and <b>loop</b> <b>checking.</b> The key feature of this system (let us call it KES 4) consists in its use of (i) a label formalism which models the semantics of the modal operators according to the usual conditions for S 4; and (ii) a label unification scheme which tells us when two labels "denote" the same world in the S 4 -model(s) generated {{in the course of}} proof search. Moreover, it uses special closure conditions to check models for putative contradictions. 2 Label Formalism Let #C = 1, w 2,... be a non empty set of constant world symbols, and let # V = {W 1, W 2,... be a non empty set of variable world symbols. The set is now defined as follows...|$|R
50|$|The while {{construct}} {{consists of}} a block of code and a condition/expression. The condition/expression is evaluated, and if the condition/expression is true, the code within the block is executed. This repeats until the condition/expression becomes false. Because the while <b>loop</b> <b>checks</b> the condition/expression before the block is executed, the control structure is often {{also known as a}} pre-test loop. Compare this with the do while loop, which tests the condition/expression after the loop has executed.|$|R
40|$|In {{recent years}} {{techniques}} and {{systems have been}} developed to prove non-termination of logic programs for certain classes of queries. In previous work, we developed such a system based on mode-information and a form of <b>loop</b> <b>checking</b> performed at compile time. In the current paper we improve this technique by integrating type information in the analysis and by applying non-failure analysis and program specialization. It turns out that there are several classes of programs for which existing non-termination analyzers fail and for which our extended technique succeeds in proving non-termination. status: publishe...|$|R
30|$|Small-world {{networks}} {{are not always}} connected. Their connectivity depends on the average degree and the rewiring probability p. Therefore, {{we need to add}} a <b>loop</b> to <b>check</b> connectivity each time a small-world network is generated.|$|R
40|$|Tool) is a {{verification}} {{system for}} checking safety properties of C programs using automatic property-driven construction and model checking of software abstractions. Blast implements an abstract-model check-refine <b>loop</b> to <b>check</b> for reachability of a specified label in the program. The abstract model is built o...|$|R
40|$|This paper {{represents}} {{a continuation of}} a previous work, where a practical approach {{to the treatment of}} nominal equalities in tableaux for basic Hybrid Logic HL(@) was proposed. Its peculiarity is a substitution rule accompanied by nominal deletion. The main advantage of such a rule, compared with other approaches, is its efficiency, that has been experimentally verified for the HL(@) fragment. The integration of substitution and nominal deletion with more expressive languages is not a trivial task. In this work the previously proposed tableaux calculus for HL(@) is extended to hybrid logic with the global and converse modalities, taking into account also practical considerations. Though termination, in this case, relies on <b>loop</b> <b>checks,</b> the computational advantages of the substitution rule persist in this richer framework...|$|R
40|$|We {{introduce}} {{a method of}} verifying termination of logic programs with respect to concrete queries (instead of abstract query patterns). A necessary and sufficient condition is established and an algorithm for automatic verification is developed. In contrast to existing query pattern-based approaches, our method has the following features: (1) It applies to all general logic programs with non-floundering queries. (2) It {{is very easy to}} automate because it does not need to search for a level mapping or a model, nor does it need to compute an interargument relation based on additional mode or type information. (3) It bridges termination analysis with <b>loop</b> <b>checking,</b> the two problems that have been studied separately in the past despite their close technical relation with each other. Comment: 28 pages, 8 figure...|$|R
40|$|International audienceThis paper {{represents}} {{a continuation of}} a previous work, where a practical approach {{to the treatment of}} nominal equalities in tableaux for basic Hybrid Logic HL(@) was proposed. Its peculiarity is a substitution rule accompanied by nominal deletion. The main advantage of such a rule, compared with other approaches, is its e ciency, that has been experimentally veri ed for the HL(@) fragment. The integration of substitution and nominal deletion with more expressive languages is not a trivial task. In this work the previously proposed tableaux calculus for HL(@) is extended to hybrid logic with the global and converse modalities, taking into account also practical considerations. Though termination, in this case, relies on <b>loop</b> <b>checks,</b> the computational advantages of the substitution rule persist in this richer framework...|$|R
25|$|Better quality {{general purpose}} {{oscilloscopes}} include a calibration signal {{for setting up}} the compensation of test probes; this is (often) a 1kHz square-wave signal of a definite peak-to-peak voltage available at a test terminal on the front panel. Some better oscilloscopes also have a squared-off <b>loop</b> for <b>checking</b> and adjusting current probes.|$|R
40|$|With the {{increasing}} exposure of critical infrastructures to external factors, critical infrastructure protection gained attention within security research. To develop protection methods {{the effect of}} external factors on critical infrastructures has to be known. In this paper we present an event-based, dynamic modeling approach using power flow analysis and network flow analysis to simulate this effect on the critical airport infrastructure airport with object-based programming. Network component objectification is used to treat the highly interconnected cyberphysical system as a two-layered system with separated cyber and physical properties. Network stability and cyber infection status is checked with two control feedback <b>loops</b> <b>checking</b> grid stability and infection status. Therefore with given object load powers and network interconnections the working capability of infrastructure parts can be predicted for various scenarios and used as input for passenger flow simulations or economical prognosis...|$|R
40|$|Abstract. This paper {{presents}} a tableau approach for deciding description logics outside {{the scope of}} OWL DL and current state-of-the-art tableau-based description logic systems. In particular, we de ne a sound and complete tableau calculus for the description logic ALBO and show that it provides a basis for decision procedures for this logic and numerous other description logics. ALBO is the extension of ALC with the Boolean role operators, inverse of roles, domain and range restriction operators and it includes full support for objects (nominals). ALBO is a very expressive description logic which is NExpTime complete and subsumes Boolean modal logic and the two-variable fragment of rstorder logic. An important novelty is the use of a versatile, unrestricted blocking rule as a replacement for standard <b>loop</b> <b>checking</b> mechanisms implemented in description logic systems. Our decision procedure is implemented in the MetTeL system. ...|$|R
