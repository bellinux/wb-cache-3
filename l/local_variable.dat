294|2486|Public
5|$|The for statement, which iterates over an iterable object, {{capturing}} {{each element}} to a <b>local</b> <b>variable</b> {{for use by}} the attached block.|$|E
25|$|By {{overwriting}} a <b>local</b> <b>variable</b> (or pointer) of {{a different}} stack frame, which will {{be used by the}} function which owns that frame later.|$|E
2500|$|When declaring a <b>local</b> <b>variable</b> or a {{field with}} the [...] keyword as a prefix the value {{must be given}} when it is {{declared}}. After that it is locked and cannot change. They can either be declared in the context as a field or a <b>local</b> <b>variable.</b> Constants are implicitly static.|$|E
5000|$|<b>Local</b> <b>variables</b> {{were added}} to TUTOR some time around 1980. Lesson authors wishing to use <b>local</b> <b>variables</b> were {{required}} to use the [...] command to declare {{the size of the}} buffer used for <b>local</b> <b>variables,</b> up to 128 words. [...] Having done so, a unit using <b>local</b> <b>variables</b> could begin as follows (from Page C2 of Summary of TUTOR Commands and System Variables, Avner, 1981): ...|$|R
50|$|There {{are both}} global and <b>local</b> <b>variables,</b> {{and they are}} {{referred}} to with a dollar sign {{in front of the}} variable name, for example $myvar. Global variables are available system-wide; <b>local</b> <b>variables</b> are only valid in the current shell. In case of name collision, <b>local</b> <b>variables</b> have precedence over global variables. Global variables can be set using the command SetEnv, while <b>local</b> <b>variables</b> can be set using the command Set. There are also the commands GetEnv and Get {{that can be used to}} print out global and <b>local</b> <b>variables.</b>|$|R
3000|$|... couples two <b>local</b> <b>variables</b> {{that are}} {{associated}} with the adjacent BSs (see, consistency constraint of problem (8))h. Thus, step (19) requires to gather the updated <b>local</b> <b>variables</b> [...]...|$|R
2500|$|... co m is a {{newly created}} <b>local</b> <b>variable</b> whose value is {{initially}} set to 3. co ...|$|E
2500|$|By {{overwriting}} a <b>local</b> <b>variable</b> that {{is located}} near the vulnerable buffer on the stack, in order to change {{the behavior of the}} program ...|$|E
2500|$|A {{function}} is first-class; a {{function is}} considered to be an object. As such, a function may have properties and methods, such as [...]call (...) and [...]bind (...) [...] A nested function is a function defined within another function. It is created each time the outer function is invoked. In addition, each nested function forms a lexical closure: The lexical scope of the outer function (including any constant, <b>local</b> <b>variable,</b> or argument value) becomes part of the internal state of each inner function object, even after execution of the outer function concludes. JavaScript also supports anonymous functions.|$|E
5000|$|Up to 9 <b>local</b> <b>variables</b> {{for each}} mode of {{operation}} and equation, solver or program file, with user defined names. Unlike the 28 global ones, using these <b>local</b> <b>variables</b> consumes user RAM.|$|R
50|$|Functions can be {{declared}} inside other functions, and access the outer function's <b>local</b> <b>variables.</b> Furthermore, they implement full closures by remembering the outer function's <b>local</b> <b>variables</b> {{even after the}} outer function has exited.|$|R
40|$|The weakest {{precondition}} semantics of recursive procedures with <b>local</b> <b>variables</b> {{are developed}} for an imperative language with demonic and angelic operators for unbounded nondeterminate choice. This {{does not require}} stacking of <b>local</b> <b>variables.</b> The formalism serves {{as a foundation for}} a proof rule for total correctness of (mutually) recursive procedures with <b>local</b> <b>variables.</b> This rule is illustrated by a simple example. Its soundness is proved for arbitrary well-founded variant functions. ...|$|R
5000|$|... {{variable}} name: The string {{name of a}} <b>local</b> <b>variable.</b> Compiled to a 1-byte value, indicating an offset {{into the}} <b>local</b> <b>variable</b> frame.|$|E
50|$|Generally a default {{argument}} will behave identically to {{an argument}} passed by parameter or a <b>local</b> <b>variable</b> declared {{at the start}} of the function, and have the same scope and extent (lifetime) as a parameter or other <b>local</b> <b>variable,</b> namely an automatic variable which is deallocated on function termination.|$|E
50|$|In {{terms of}} scope and extent, static {{variables}} have extent the entire {{run of the}} program, but may have more limited scope. A basic distinction is between a static global variable, which has global scope and thus is in context throughout the program, and a static <b>local</b> <b>variable,</b> which has local scope. A static <b>local</b> <b>variable</b> is different from a <b>local</b> <b>variable</b> as a static <b>local</b> <b>variable</b> is initialized only once {{no matter how many}} times the function in which it resides is called and its value is retained and accessible through many calls to the function in which it is declared, e.g. to be used as a count variable. A static variable may also have module scope or some variant, such as internal linkage in C, which is a form of file scope or module scope.|$|E
5000|$|... for <b>local</b> <b>variables</b> {{within a}} {{subroutine}} or function. The SAVE attribute causes <b>local</b> <b>variables</b> {{to retain their}} value after a procedure call and then to initialize the variable to the saved value upon returning to the procedure.|$|R
40|$|The weakest {{precondition}} semantics of recursive procedures with <b>local</b> <b>variables</b> {{are developed}} for an imperative language with demonic and angelic operators for unbounded nondeterminate choice. This {{does not require}} stacking of <b>local</b> <b>variables.</b> The formalism serves {{as a foundation for}} a proof rule for total correctness of (mutually) recursive procedures with <b>local</b> <b>variables.</b> This rule is illustrated by a simple example. Its soundness is proved for arbitrary well-founded variant functions. Keywords: predicate transformers, frames, recursive procedures, proof rule 1 Introduction Formalisms for weakest preconditions for imperative programs usually treat predicates as boolean functions on a single state space, cf. [BvW 90, DiS 90, Hes 92, Nel 89]. It follows that procedures cannot have <b>local</b> <b>variables.</b> For nonrecursive procedures, <b>local</b> <b>variables</b> can be made global by careful renaming. Actually, this is also possible for recursive procedures by means of methods analogous to those developed be [...] ...|$|R
5000|$|<b>Local</b> <b>variables</b> are {{set with}} the [...] command and only {{exist in the}} context of the routine that created them. They are deleted when the routine ends. Some <b>local</b> <b>variables</b> are predefined, such as $C for the current channel's name.|$|R
5000|$|When declaring a <b>local</b> <b>variable</b> or a {{field with}} the [...] keyword as a prefix the value {{must be given}} when it is {{declared}}. After that it is locked and cannot change. They can either be declared in the context as a field or a <b>local</b> <b>variable.</b> Constants are implicitly static.const double PI = 3.14; ...|$|E
5000|$|... irb(main):001:0> y = xNameError: {{undefined}} <b>local</b> <b>variable</b> or method `x' for main:Object from (irb):1 ...|$|E
5000|$|... int shared; /* <b>local</b> <b>variable</b> {{that will}} hide [...] * the global {{of the same}} name */ ...|$|E
25|$|<b>Local</b> <b>variables</b> {{are created}} {{as the point}} of {{execution}} passes the declaration point. If the variable has a constructor or initializer this is used to define the initial state of the object. <b>Local</b> <b>variables</b> are destroyed when the local block or function that they are declared in is closed. C++ destructors for <b>local</b> <b>variables</b> are called {{at the end of}} the object lifetime, allowing a discipline for automatic resource management termed RAII, which is widely used in C++.|$|R
50|$|<b>Local</b> <b>variables</b> {{are defined}} inside a method, or a {{particular}} block. These <b>variables</b> are <b>local</b> {{to where they were}} defined and lower levels. For example, a loop inside a method can use that method's <b>local</b> <b>variables,</b> but not the other way around. The loop's <b>variables</b> (<b>local</b> to that loop) are destroyed as soon as the loop ends.|$|R
5000|$|Dead code—Unused <b>local</b> <b>variables,</b> {{parameters}} and private methods.|$|R
5000|$|One use of [...] in C# is {{to allow}} {{reference}} to an outer field variable within a method that contains a <b>local</b> <b>variable</b> that has the same name. In such a situation, for example, the statement [...] within the method will assign the type and value of the <b>local</b> <b>variable</b> [...] to , whereas the statement [...] will assign the type and value of the outer field variable to [...]|$|E
5000|$|The [...] {{instructions}} push a {{value of}} the specified type onto the stack. For example, [...] will push an integer (32 bit value) with the value 5 onto the stack, while [...] will push a double (64 bit floating point value) with the value 1 onto the stack. There is also an , which pushes a [...] reference. The n for the [...] and [...] instructions specifies the index in the <b>local</b> <b>variable</b> array to load from or store to. The [...] instruction pushes the object in <b>local</b> <b>variable</b> 0 onto the stack (this is usually the [...] object). [...] stores the integer {{on the top of}} the stack into <b>local</b> <b>variable</b> 1. For local variables beyond 3 the suffix is dropped and operands must be used.|$|E
50|$|The term <b>local</b> <b>variable</b> {{is usually}} synonymous with {{automatic}} variable, since {{these are the}} same thing in many programming languages, but local is more general - most local variables are automatic local variables, but static local variables also exist, notably in C. For a static <b>local</b> <b>variable,</b> the allocation is static (the lifetime is the entire program execution), not automatic, but it is only in scope during the execution of the function.|$|E
50|$|When {{programming}} AmigaDOS scripts, {{one must}} {{keep in mind}} that global variables are system-wide. All script-internal variables shall be set using <b>local</b> <b>variables,</b> or one risks conflicts over global variables between scripts. Also, global variables require filesystem access, which typically makes them slower to access than <b>local</b> <b>variables.</b>|$|R
5000|$|In many {{programming}} language implementations, all variables declared within a procedure (subroutine, or function) are local to that function; the runtime {{environment for the}} program automatically allocates memory for these variables on program execution entry to the procedure, and automatically releases that memory when the procedure is exited. Special declarations may allow <b>local</b> <b>variables</b> to retain values between invocations of the procedure, or may allow <b>local</b> <b>variables</b> to be access by other procedures. The automatic allocation of <b>local</b> <b>variables</b> makes recursion possible, to a depth limited by available memory.|$|R
5000|$|... {{semantic}} analysis with highlighting of parameters and unused <b>local</b> <b>variables</b> ...|$|R
5000|$|... on the [...] "myClass" [...] {{variable}} {{to allow the}} developer to rename the <b>local</b> <b>variable,</b> after he pressed the tab key, ...|$|E
5000|$|Another [...] statement, which iterates over an iterable object, {{capturing}} {{each element}} to a <b>local</b> <b>variable</b> {{for use by}} the attached block.|$|E
50|$|Unlike the {{database}} where global variable nodes must fit {{within a database}} block, <b>local</b> <b>variable</b> strings can grow to 1MB. The GT.M run-time provides dynamic storage allocation with garbage collection. The number of local variables {{and the number of}} nodes in local variables are limited only by storage available to the process. The default scope of a <b>local</b> <b>variable</b> is the lifetime of a process. Local variables created within routines using the New command have more limited scope.|$|E
40|$|Abstract. A <b>variable</b> is <b>local</b> if {{it occurs}} in a clause body but not in its head. <b>Local</b> <b>variables</b> appear {{naturally}} in practical logic programming, but they complicate several aspects such as negation, compilation, memoization, static analysis, program approximation by neural networks etc. As a consequence, the absence of <b>local</b> <b>variables</b> yields better performance of several tools and {{is a prerequisite for}} many technical results. In this paper, we introduce an algorithm that eliminates <b>local</b> <b>variables</b> from a wide proper subclass of normal logic programs. The proposed transformation preserves the Clark-Kunen semantics for normal logic programs. ...|$|R
5000|$|Perl {{supports}} both {{dynamic and}} lexically-scoped <b>local</b> <b>variables.</b> The keyword [...] {{is used to}} define <b>local</b> dynamically-scoped <b>variables,</b> while [...] is used for <b>local</b> lexically-scoped <b>variables.</b> Since dynamic scoping is less common today, the Perl documentation warns that [...] " [...] isn't what {{most people think of}} as “local”.". [...] Instead, the [...] keyword gives a temporary, dynamically-scoped value to a global (package) variable, which lasts {{until the end of the}} enclosing block. However, the variable is visible to any function called from within the block. [...] To create lexically-scoped <b>local</b> <b>variables,</b> use the [...] operator instead.|$|R
5000|$|Initializing <b>local</b> <b>variables</b> at {{the start}} of a program or {{function}} ...|$|R
