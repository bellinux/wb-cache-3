132|267|Public
25|$|PC-relative <b>load</b> <b>instructions,</b> {{as well as}} address {{generation}} {{with large}} (PC-relative) offsets.|$|E
2500|$|... unaligned <b>load</b> <b>instructions</b> (LWL & LWR), (requiring {{that most}} {{ordinary}} loads & stores support misaligned access, possibly via trapping {{and with the}} addition of a new instruction (BALIGN)) ...|$|E
2500|$|MIPS I has {{instructions}} that load and store 8-bit bytes, 16-bit halfwords, and 32-bit words. Only one addressing mode is supported: base + displacement. Since MIPS I is a 32-bit architecture, loading quantities fewer than 32 bits requires the datum {{to be either}} signed- or zero-extended to 32 bits. The <b>load</b> <b>instructions</b> suffixed by [...] "unsigned" [...] perform zero extension; otherwise sign extension is performed. <b>Load</b> <b>instructions</b> source the base from {{the contents of a}} GPR (rs) and write the result to another GPR (rt). Store instructions source the base from the contents of a GPR (rs) and the store data from another GPR (rt). All load and store instructions compute the memory address by summing the base with the sign-extended 16-bit immediate. MIPS I requires all memory accesses to be aligned to their natural word boundaries, otherwise an exception is signaled. To support efficient unaligned memory accesses, there are load/store word instructions suffixed by [...] "left" [...] or [...] "right". All <b>load</b> <b>instructions</b> are followed by a load delay slot. The instruction in the load delay slot cannot use the data loaded by the load instruction. The load delay slot can be filled with an instruction that is not dependent on the load; a nop is substituted if such an instruction cannot be found.|$|E
50|$|Quad-word storage <b>instructions.</b> The quad-word <b>load</b> <b>instruction</b> moves two {{adjacent}} double-precision values {{into two}} adjacent floating-point registers.|$|R
5000|$|Cycle : {{instruction}} [...] from thread [...] is issued, {{which is}} a <b>load</b> <b>instruction</b> that misses in all caches.|$|R
5000|$|A check <b>load</b> <b>instruction</b> aids {{speculative}} <b>loads</b> {{by checking}} whether a speculative load {{was dependent on}} a later store, and thus must be reloaded.|$|R
5000|$|PC-relative <b>load</b> <b>instructions,</b> {{as well as}} address {{generation}} {{with large}} (PC-relative) offsets.|$|E
50|$|The Z80 has six new LD {{instructions}} that can load the DE, BC, and SP register pairs from memory, and load memory from these three register pairs -- unlike the 8080. As on the 8080, <b>load</b> <b>instructions</b> do {{not affect the}} flags (except for the special purpose I and R register loads). A quirk (common with the 8080) of the register-to-register <b>load</b> <b>instructions</b> is {{that each of the}} 8-bit registers can be loaded from themselves (e.g. LD A,A). This is effectively a NOP.|$|E
5000|$|... unaligned <b>load</b> <b>instructions</b> (LWL & LWR), (requiring {{that most}} {{ordinary}} loads & stores support misaligned access, possibly via trapping {{and with the}} addition of a new instruction (BALIGN)) ...|$|E
50|$|PSoC resembles an FPGA in that at {{power up}} {{it must be}} configured, but this {{configuration}} occurs by <b>loading</b> <b>instructions</b> from the built-in Flash memory.|$|R
50|$|Some {{architectures}} like MIPS {{have special}} unaligned <b>load</b> and store <b>instructions.</b> One unaligned <b>load</b> <b>instruction</b> gets the bytes from the memory word {{with the lowest}} byte address and another gets the bytes from the memory word with the highest byte address. Similarly, store-high and store-low instructions store the appropriate bytes in the higher and lower memory words respectively.|$|R
5000|$|A {{speculative}} <b>load</b> <b>instruction</b> {{is used to}} speculatively {{load data}} before it is known {{whether it will be}} used (bypassing control dependencies), or whether it will be modified before it is used (bypassing data dependencies).|$|R
5000|$|Load {{responses}} from a memory hierarchy which includes CPU caches and DRAM {{do not have}} a deterministic delay. This makes static scheduling of <b>load</b> <b>instructions</b> by the compiler very difficult.|$|E
50|$|The {{advanced}} {{load address}} table (ALAT) is a functional {{unit in the}} Intel Itanium processor architecture. It is implemented with an associative memory. The ALAT is used to store information related to advance <b>load</b> <b>instructions,</b> {{as part of the}} speculative execution process.|$|E
5000|$|MIPS I has {{instructions}} that load and store 8-bit bytes, 16-bit halfwords, and 32-bit words. Only one addressing mode is supported: base + displacement. Since MIPS I is a 32-bit architecture, loading quantities fewer than 32 bits requires the datum {{to be either}} signed- or zero-extended to 32 bits. The <b>load</b> <b>instructions</b> suffixed by [...] "unsigned" [...] perform zero extension; otherwise sign extension is performed. <b>Load</b> <b>instructions</b> source the base from {{the contents of a}} GPR (rs) and write the result to another GPR (rt). Store instructions source the base from the contents of a GPR (rs) and the store data from another GPR (rt). All load and store instructions compute the memory address by summing the base with the sign-extended 16-bit immediate. MIPS I requires all memory accesses to be aligned to their natural word boundaries, otherwise an exception is signaled. To support efficient unaligned memory accesses, there are load/store word instructions suffixed by [...] "left" [...] or [...] "right". All <b>load</b> <b>instructions</b> are followed by a load delay slot. The instruction in the load delay slot cannot use the data loaded by the load instruction. The load delay slot can be filled with an instruction that is not dependent on the load; a nop is substituted if such an instruction cannot be found.|$|E
40|$|This thesis compares two {{different}} aproaches in creating <b>loading</b> <b>instructions,</b> loadsheets and trimsheets. Practical examples are also given and described for better understanding. We {{become acquainted with}} centralised load control centres and the principles of their functioning. Centralised load control centres will be compared with conventional workplaces at the airports...|$|R
5000|$|The {{bottom of}} the camera {{contains}} the rewind knob release lever, the rewind release button [...] and the rewind knob, which {{is also used to}} open the back. Printing on the bottom includes <b>loading</b> <b>instructions,</b> daylight exposure table, flash exposure table, (both based on ASA 10 film) and suggestions for common focus settings.|$|R
5000|$|... #Caption: Bottom view of VM personal, note film <b>loading,</b> {{advancing}} <b>instructions</b> ...|$|R
50|$|The {{instructions}} LD A,R and LD A,I {{affect the}} Z80 flags register, unlike {{all the other}} LD (<b>load)</b> <b>instructions.</b> The Sign (bit 7) and Zero (bit 6) flags are set {{according to the data}} loaded from the Refresh or Interrupt source registers. For both instructions, the Parity/Overflow flag (bit 2) is set according to {{the current state of the}} IFF2 flip-flop.|$|E
50|$|Instructions were of 1, 2 or 3 syllables. Most {{arithmetic}} {{took place}} {{at the top of the}} Nest and used zero-address, 1-syllable instructions, although address arithmetic and index updating were handled separately in the Q store. Q Store handling, and some memory reference instructions, used 2 syllables. Memory reference instructions with a 16-bit address offset, most jump instructions, and 16-bit literal <b>load</b> <b>instructions,</b> all used 3 syllables.|$|E
5000|$|The [...] {{instruction}} on line 3 has a RAW {{dependence on the}} [...] {{instruction on}} line 2, and the [...] instruction on line 5 has a RAW dependence on the [...] instruction on line 4. Both <b>load</b> <b>instructions</b> read the memory address that the preceding stores wrote. The stores were the most recent producers to that memory address, and the loads are reading that memory address's value.|$|E
5000|$|RISC â€” Requiring {{explicit}} memory <b>loads,</b> the <b>instructions</b> would be: [...]|$|R
50|$|Complications {{arise when}} the {{dependence}} is not statically determinable. Such non-static dependencies arise with memory <b>instructions</b> (<b>loads</b> and stores) because {{the location of}} the operand may be indirectly specified as a register operand rather than directly specified in the instruction encoding itself. 1: store $1, 2($2) # MemR2+2 <= R1 2: load $3, 4($4) # R3 <= MemR4+4 (possibly dependent on 1, possible same address as above)Here, the store instruction writes a value to the memory location specified by the value in the address (R2+2), and the <b>load</b> <b>instruction</b> reads the value at the memory location specified by the value in address (R4+4). The microprocessor cannot statically determine, prior to execution, if the memory locations specified in these two instructions are different, or are the same location, because the locations depend on the values in R2 and R4. If the locations are different, the instructions are independent and can be successfully executed out of order. However, if the locations are the same, then the <b>load</b> <b>instruction</b> is dependent on the store to produce its value. This is known as an ambiguous dependence.|$|R
30|$|The {{instrumentation}} {{adds the}} primitives after each identified access to function pointers. As the instrumented primitive after a store instruction records the stored function pointer value, {{once it gets}} corrupted, the primitive after the corresponding <b>load</b> <b>instruction</b> will record the corrupted loaded value. Finally, when DTrace performs the checks before a security-sensitive system call, the corrupted loaded value will be identified.|$|R
50|$|Some {{computer}} architectures have conditional instructions (such as ARM, {{but no longer}} for all instructions in 64-bit mode) or conditional <b>load</b> <b>instructions</b> (such as x86) which can in some cases make conditional branches unnecessary and avoid flushing the instruction pipeline. An instruction such as a 'compare' is used to set a condition code, and subsequent instructions include a test on that condition code {{to see whether they}} are obeyed or ignored.|$|E
5000|$|Following {{the older}} approach, the earlier PDP-1 has a {{hardware}} loader, such that an operator need only push the [...] "load" [...] switch to instruct the paper tape reader to load a program directly into core memory. The Data General Supernova used front panel switches {{to cause the}} computer to automatically <b>load</b> <b>instructions</b> into memory from a device specified by the front panel's data switches, and then jump to loaded code; the Nova 800 and 1200 had a switch that loaded a program into main memory from a special read-only memory and jumped to it.|$|E
50|$|Starting with Barcelona-based processors, AMD {{introduced}} the SSE4a instruction set, which has 4 SSE4 instructions and 4 new SSE instructions. These instructions are {{not found in}} Intel's processors supporting SSE4.1 and AMD processors only started supporting Intel's SSE4.1 and SSE4.2 (the full SSE4 instruction set) in the Bulldozer-based FX processors. With SSE4a the misaligned SSE feature was also introduced which meant unaligned <b>load</b> <b>instructions</b> were as fast as aligned versions on aligned addresses. It also allowed disabling the alignment check on non-load SSE operations accessing memory. Intel later introduced similar speed improvements to unaligned SSE in their Nehalem processors, but did not introduce misaligned access by non-load SSE instructions until AVX.|$|E
50|$|A {{program has}} to execute more {{instructions}} when compiled to a stack machine than when compiled to a register machine or memory-to-memory machine. Every variable load or constant requires its own separate <b>Load</b> <b>instruction,</b> {{instead of being}} bundled within the instruction which uses that value. The separated instructions may be simple and faster running, but the total instruction count is still higher.|$|R
5000|$|Because {{the value}} {{returned}} from a cache miss cannot be known ahead of time, {{it is possible for}} pre-processed instructions to be dependent upon invalid data. These are denoted by adding an [...] "invalid" [...] or INV bit to every register in the register file. If runahead was initiated by a <b>load</b> <b>instruction,</b> the <b>load's</b> destination register is marked INV.|$|R
40|$|As {{multicore}} architectures {{have hit}} the mainstream, {{one of the challenges}} for future multicore designs is to maintain a high memory bandwidth. To this end, we introduce the concept of silent loads to improve the execution efficiency of memory instructions. We define a <b>load</b> <b>instruction</b> as a silent load (SLD) if there is a value-based association of the requested memory location with a set of registers in the physical register file (RF). If such an association exists, the <b>load</b> <b>instruction</b> can be cancelled, i. e., it is silent. We establish that as many as 32 % of all dynamic loads are silent across a set of applications in the desktop domain. We propose a novel micro-architectural scheme to capitalize on SLDs. Our scheme maintains an explicit relation between a set of registers in the physical RF with a set of memory addresses at run-time without compiler support and ISA extension. We show that our scheme improves both performance and performance per watt...|$|R
50|$|The belt {{is fixed}} length {{and may be}} too short to hold all live {{transient}} operands before they are pushed off the end. If an operand is needed for longer than its belt lifetime, it must be saved while still on the belt (spill) and later restored to the belt when needed again (fill). This situation {{is equivalent to the}} need to spill registers to memory when a program runs out of registers in a general-register machine. Spilled operands may be written to memory using normal store instructions, and restored using normal <b>load</b> <b>instructions,</b> or spill and fill may use special-purpose storage and associated operations that are faster or offer other advantages over load and store.|$|E
50|$|The PPU is an In-Order processor, but it {{has some}} unique traits which allow it to achieve some {{benefits}} of Out-of-Order execution without expensive re-ordering hardware. Upon reaching an L1 cache miss - it can execute past the cache miss, stopping only when an instruction is actually dependent on a load. It can send up to 8 <b>load</b> <b>instructions</b> to the L2 cache out-of-order. It has an instruction delay pipe - a side path that allows it to execute instructions that would normally cause pipeline stalls without holding {{up the rest of}} the pipeline. The instruction delay pipeline is used for the Out-Of-Order Load/Stores: cache misses are put there while it moves on.|$|E
50|$|With this technique, <b>load</b> <b>instructions</b> {{that have}} {{executed}} out-of-order are re-executed (they access the memory system {{and read the}} value from their address a second time) when they reach the retirement point. Since the load is now the retiring instruction, it has no dependencies on any instruction still in-flight; all stores ahead of it have committed their values to the memory system, and so any value read from the memory system is guaranteed to be correct. The value read from memory at re-execution time is compared to the value obtained when the load first executed. If the values are the same, the original value was correct and no violation has occurred. If the re-execution value differs from the original value, a RAW violation has occurred and the pipeline must be flushed because instructions dependent on the load have used an incorrect value.|$|E
3000|$|The current drop-landing task {{creates an}} {{increase}} in knee compression <b>loading</b> with <b>instruction</b> to land stiffly.|$|R
50|$|Dual issue mode, {{available}} on XS2, enables one short load, store, or brancg instruction to be paired with one short resource instruction. Short arithmetic instructions can be paired with any instruction. This enables inner-loops that, for example, transfer data from memory to IO to be halved in length by issuing the <b>LOAD</b> <b>instruction</b> {{together with the}} ADD instruction, and the change to the counter together with the branch instruction.|$|R
30|$|A 3 -stage {{day-ahead}} TCL scheduling {{model is}} proposed. In the first stage, the TCL aggregator solve a capacity estimation model to estimate their maximum interruptible TCL capacities. In the second stage, the system operator solves a day-ahead dispatch model {{to determine the}} <b>load</b> shedding <b>instructions</b> for TCL aggregators. In the third stage, based on the <b>load</b> shedding <b>instructions,</b> the TCL aggregators schedule the ON/OFF states of the TCLs to follow the instructions.|$|R
