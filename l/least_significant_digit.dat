71|4166|Public
500|$|... {{according}} to some chosen radix; then, {{the part of the}} key used for the th pass of the algorithm is the th digit in the positional notation for the full key, starting from the <b>least</b> <b>significant</b> <b>digit</b> and progressing to the most significant. For this algorithm to work correctly, the sorting algorithm used in each pass over the data must be stable: items with equal digits should not change positions with each other. For greatest efficiency, the radix should be chosen to be near the number of data items, [...] Additionally, using a power of two near [...] as the radix allows the keys for each pass to be computed quickly using only fast binary shift and mask operations. With these choices, [...] and with pigeonhole sort or counting sort as the base algorithm, the radix sorting algorithm can sort [...] data items having keys in the range from [...] to [...] in time [...]|$|E
2500|$|Decimal {{counting}} {{uses the}} ten symbols 0 through 9. [...] Counting {{begins with the}} incremental substitution of the <b>least</b> <b>significant</b> <b>digit</b> (rightmost digit) which is often called the first digit. When the available symbols for this position are exhausted, the <b>least</b> <b>significant</b> <b>digit</b> is reset to 0, and the next digit of higher significance (one position to the left) is incremented (overflow), and incremental substitution of the low-order digit resumes. This method of reset and overflow is repeated for each digit of significance. Counting progresses as follows: ...|$|E
2500|$|Both {{these methods}} {{break up the}} {{subtraction}} {{as a process of}} one digit subtractions by place value. Starting with a <b>least</b> <b>significant</b> <b>digit,</b> a subtraction of subtrahend: ...|$|E
50|$|In base 10 one can {{notice that}} the {{hexagonal}} numbers' rightmost (<b>least</b> <b>significant)</b> <b>digits</b> follow the pattern 1-7-9-7-1.|$|R
50|$|For stated {{problems}} that use inexact numbers, correct answers require {{the method of}} <b>least</b> <b>significant</b> <b>digits,</b> with allowable error of plus or minus one in the last <b>significant</b> <b>digit.</b>|$|R
50|$|While the PiHex project {{calculated}} the <b>least</b> <b>significant</b> <b>digits</b> of pi ever attempted in any base, {{the second place}} is held by houkouonchi who derived the 13.3 trillionth digit in base 10.|$|R
2500|$|Radix sort is an {{algorithm}} that sorts numbers by processing individual digits. n numbers {{consisting of}} k digits each are sorted in O(n · k) time. [...] Radix sort can process digits of each number either {{starting from the}} <b>least</b> <b>significant</b> <b>digit</b> (LSD) or starting from the most significant digit (MSD). [...] The LSD algorithm first sorts the list by the <b>least</b> <b>significant</b> <b>digit</b> while preserving their relative order using a stable sort. Then it sorts them by the next digit, and so on from the least significant to the most significant, ending up with a sorted list. While the LSD radix sort {{requires the use of}} a stable sort, the MSD radix sort algorithm does not (unless stable sorting is desired). [...] In-place MSD radix sort is not stable. [...] It is common for the counting sort algorithm to be used internally by the radix sort. [...] A hybrid sorting approach, such as using insertion sort for small bins improves performance of radix sort significantly.|$|E
2500|$|A signed (meaning {{negative}} or non-negative) digit string {{of a given}} length in a given base (or radix). This digit string {{is referred to as}} the significand, mantissa, or coefficient. The length of the significand determines the precision to which numbers can be represented. [...] The radix point position is assumed always to be somewhere within the significand—often just after or just before the most significant digit, or to the right of the rightmost (<b>least</b> <b>significant)</b> <b>digit.</b> [...] This article generally follows the convention that the radix point is set just after the most significant (leftmost) digit.|$|E
2500|$|There {{are several}} {{mechanisms}} by which strings of digits can represent numbers. In common mathematical notation, the digit string can be of any length, {{and the location of}} the radix point is indicated by placing an explicit [...] "point" [...] character (dot or comma) there. If the radix point is not specified, then the string implicitly represents an integer and the unstated radix point would be off the right-hand end of the string, next to the <b>least</b> <b>significant</b> <b>digit.</b> In fixed-point systems, a position in the string is specified for the radix point. So a fixed-point scheme might be to use a string of 8 decimal digits with the decimal point in the middle, whereby [...] "00012345" [...] would represent 0001.2345.|$|E
50|$|For a {{question}} to score as correct, the student must answer it to the third significant digit—with allowable error in the third digit of plus or minus one, except for integer, dollar sign, and certain stated problems that require <b>least</b> <b>significant</b> <b>digits.</b>|$|R
40|$|A random {{variable}} X is digit-regular (respectively, significant-digit-regular) if {{the probability that}} every block of k given consecutive <b>digits</b> (<b>significant</b> <b>digits)</b> appears in the b-adic expansion of X approaches b &supk; as the block moves to the right, for all integers b > 1 and k ? 1. Necessary and sufficient conditions are established, in terms of convergence of Fourier coefficients, {{and in terms of}} convergence in distribution modulo 1, for a {{random variable}} to be digit-regular (significant-digit regular), and basic relationships between digit-regularity and various classical classes of probability measures and normal numbers are given. These results provide a theoretical basis for analyses of roundoff errors in numerical algorithms which use floating-point arithmetic, and for detection of fraud in numerical data via using goodness-of-fit of the <b>least</b> <b>significant</b> <b>digits</b> to uniform, complementing recent tests for leading <b>significant</b> <b>digits</b> based on Benford's law. normal numbers, <b>significant</b> <b>digits,</b> Benford's law, digit-regular random variable, significant-digit-regular random variable, law of <b>least</b> <b>significant</b> <b>digits,</b> floating-point numbers, nonleading digits, trailing digits...|$|R
500|$|The SSEM's three bit {{instruction}} set allowed {{a maximum of}} eight (23) different instructions. In contrast to the modern convention, the machine's storage was arranged with the <b>least</b> <b>significant</b> <b>digits</b> to the left; thus a one was represented in three bits as [...] "100", rather than the more conventional [...] "001".|$|R
5000|$|The above {{property}} can be informally {{observed by}} considering the primes of a chain in base 2. (Note that, as with all bases, multiplying {{by the number of}} the base [...] "shifts" [...] the digits to the left.) When we consider [...] in base 2, we see that, by multiplying [...] by 2, the <b>least</b> <b>significant</b> <b>digit</b> of [...] becomes the secondmost <b>least</b> <b>significant</b> <b>digit</b> of [...] Because [...] is odd—that is, the <b>least</b> <b>significant</b> <b>digit</b> is 1 in base 2--we know that the secondmost <b>least</b> <b>significant</b> <b>digit</b> of [...] is also 1. And, finally, we can see that [...] will be odd due to the addition of 1 to [...] In this way, successive primes in a Cunningham chain are essentially shifted left in binary with ones filling in the least significant digits. For example, here is a complete length 6 chain which starts at 141361469: ...|$|E
50|$|In the <b>least</b> <b>significant</b> <b>digit</b> {{it was set}} to {{indicate}} a negative number (signed magnitude).|$|E
50|$|Take the <b>least</b> <b>significant</b> <b>digit</b> (or {{group of}} bits, both being {{examples}} of radices) of each key.|$|E
40|$|AbstractLet z be a {{positive}} integer which is obtained {{as the product of}} several large integers each with a periodic digit behavior. We investigate the periodic behavior for the leading digits of z and for the <b>least</b> <b>significant</b> <b>digits</b> of z and further study the relations between the two periodic behaviors...|$|R
5000|$|The SSEM's three bit {{instruction}} set allowed {{a maximum of}} eight (23) different instructions. In contrast to the modern convention, the machine's storage was arranged with the <b>least</b> <b>significant</b> <b>digits</b> to the left; thus a one was represented in three bits as [...] "100", rather than the more conventional [...] "001".|$|R
5|$|In the {{following}} sections, wherever numeric equalities {{are shown in}} 'concise form'—such as —the two digits between the parentheses denote the uncertainty at 1σ standard deviation (68% confidence level) in the two <b>least</b> <b>significant</b> <b>digits</b> of the significand. A final X in a proposed definition denotes digits yet to be agreed on.|$|R
5000|$|The first {{counting}} pass {{starts on}} the <b>least</b> <b>significant</b> <b>digit</b> of each key, producing {{an array of}} bucket sizes: ...|$|E
5000|$|Decimal {{counting}} {{uses the}} ten symbols 0 through 9. Counting {{begins with the}} incremental substitution of the <b>least</b> <b>significant</b> <b>digit</b> (rightmost digit) which is often called the first digit. When the available symbols for this position are exhausted, the <b>least</b> <b>significant</b> <b>digit</b> is reset to 0, and the next digit of higher significance (one position to the left) is incremented (overflow), and incremental substitution of the low-order digit resumes. This method of reset and overflow is repeated for each digit of significance. Counting progresses as follows: ...|$|E
5000|$|Montgomery {{multiplication}} is {{an alternative}} algorithm that processed the multiplier [...] "backwards" [...] (<b>least</b> <b>significant</b> <b>digit</b> first) and uses the <b>least</b> <b>significant</b> <b>digit</b> of the accumulator to control {{whether or not the}} modulus should be added/subtracted. This avoids the need for carries to propagate. However, the algorithm is impractical for single modular multiplications, since two or three additional Montgomery steps have to be performed to convert the operands into a special form before processing and to convert the result back into conventional binary at the end.|$|E
25|$|Consumers {{ignore the}} <b>least</b> <b>significant</b> <b>digits</b> rather {{than do the}} proper rounding. Even though the cents are seen and not totally ignored, they may subconsciously be {{partially}} ignored. Keith Coulter, Associate Professor of Marketing at the Graduate School of Management, Clark University, suggests that this effect may be enhanced when the cents are printed smaller (for example, $1999).|$|R
5000|$|In {{a trivial}} sense, all {{positive}} integers are pandigital in unary (or tallying). In binary, all integers are pandigital except for 0 {{and numbers of}} the form [...] (the Mersenne numbers). The larger the base, the rarer pandigital numbers become, though one can always find runs of [...] consecutive pandigital numbers with redundant digits by writing all the digits of the base together (but not putting the zero first as the most <b>significant</b> <b>digit)</b> and adding x + 1 zeroes at the end as <b>least</b> <b>significant</b> <b>digits.</b>|$|R
50|$|Unlike histograms, stem-and-leaf {{displays}} {{retain the}} original data to at <b>least</b> two <b>significant</b> <b>digits,</b> {{and put the}} data in order, thereby easing the move to order-based inference and non-parametric statistics.|$|R
50|$|A most {{significant}} digit (MSD) radix sort {{can be used to}} sort keys in lexicographic order. Unlike a <b>least</b> <b>significant</b> <b>digit</b> (LSD) radix sort, a {{most significant}} digit radix sort does not necessarily preserve the original order of duplicate keys. An MSD radix sort starts processing the keys from the {{most significant digit}}, leftmost digit, to the <b>least</b> <b>significant</b> <b>digit,</b> rightmost digit. This sequence is opposite that of <b>least</b> <b>significant</b> <b>digit</b> (LSD) radix sorts. An MSD radix sort stops rearranging the position of a key when the processing reaches a unique prefix of the key. Some MSD radix sorts use one level of buckets in which to group the keys. See the counting sort and pigeonhole sort articles. Other MSD radix sorts use multiple levels of buckets, which form a trie or a path in a trie. A postman's sort / postal sort is a kind of MSD radix sort.|$|E
5000|$|Both {{these methods}} {{break up the}} {{subtraction}} {{as a process of}} one digit subtractions by place value. Starting with a <b>least</b> <b>significant</b> <b>digit,</b> a subtraction of subtrahend: ...|$|E
50|$|A <b>Least</b> <b>significant</b> <b>digit</b> (LSD) Radix sort is a fast stable sorting {{algorithm}} {{which can}} be used to sort keys in integer representation order. Keys may be a string of characters, or numerical digits in a given 'radix'. The processing of the keys begins at the <b>least</b> <b>significant</b> <b>digit</b> (i.e., the rightmost digit), and proceeds to the most significant digit (i.e., the leftmost digit). The sequence in which digits are processed by an LSD radix sort is the opposite of the sequence in which digits are processed by a most significant digit (MSD) radix sort.|$|E
40|$|Consider nondeterministic finite automata {{recognizing}} base-k {{positional notation}} of numbers. Assume that numbers are read starting from their <b>least</b> <b>significant</b> <b>digits.</b> It is proved that if {{two sets of}} numbers S and T are represented by nondeterministic automata of m and n states, respectively, then their sum {s + t | s ∈ S, t ∈ T} is represented by a nondeterministic automaton with 2 mn+ 2 m+ 2 n+ 1 states. Moreover, this number of states is necessary in the worst case for all k � 9. ...|$|R
40|$|In most {{published}} chaos-based communication schemes, the system’s parameters {{used as a}} key {{could be}} intelligently estimated by a cracker {{based on the fact}} that information about the key is contained in the chaotic carrier. In this paper, we will show that the <b>least</b> <b>significant</b> <b>digits</b> (LSDs) of a signal from a chaotic system can be so highly random that the system can be used as a random number generator. Secure communication could be built between the synchronized generators nonetheless. The Lorenz system is used as an illustration...|$|R
50|$|One way to {{consider}} {{this is that the}} real value often has the characteristics of an irrational number. In real-world measuring situations, improving the measurement technique will eventually begin yielding unpredictable <b>least</b> <b>significant</b> <b>digits.</b> For example, a 1-inch long gauge block will measure to be exactly 1 inch long until the measuring techniques reach a certain degree of precision. As techniques improve beyond this threshold, it will become clear that 1 inch is not the real value of the gauge block length, but some other number approximates it.|$|R
50|$|The answer must {{be found}} one digit at a time {{starting}} at the <b>least</b> <b>significant</b> <b>digit</b> and moving left. The last calculation is on the leading zero of the multiplicand.|$|E
50|$|Multiple column sorting was {{commonly}} done {{by first}} sorting the least significant column, then proceeding, column by column, {{to the most}} significant column. This is called a <b>least</b> <b>significant</b> <b>digit</b> radix sort.|$|E
5000|$|Fixed-point data [...] "words" [...] {{could be}} any size from one decimal digit up to 100 decimal digits, with the X bit of the <b>least</b> <b>significant</b> <b>digit</b> storing the sign (signed magnitude).|$|E
5000|$|... 14 {{hexadecimal}} digits {{of precision}} is {{roughly equivalent to}} 17 decimal digits. A conversion of double precision hexadecimal float to decimal string would require at <b>least</b> 18 <b>significant</b> <b>digits</b> in order to convert {{back to the same}} hexadecimal float value.|$|R
25|$|The fully {{polynomial}} time approximation scheme (FPTAS) for the knapsack problem {{takes advantage of}} the fact that the reason the problem has no known {{polynomial time}} solutions is because the profits associated with the items are not restricted. If one rounds off some of the <b>least</b> <b>significant</b> <b>digits</b> of the profit values then they will be bounded by a polynomial and 1/ε where ε is a bound on the correctness of the solution. This restriction then means that an algorithm can find a solution in polynomial time that is correct within a factor of (1-ε) of the optimal solution.|$|R
40|$|A {{hardware}} {{method for}} functional unit assignment is presented, {{based on the}} principle that a functional unit's power consumption is approximated by the switching activity of its inputs. Since computing the Hamming distance of the inputs in hardware is expensive, only a portion of the inputs are examined. Integers often have many identical top bits, due to sign extension, and floating points often have many zeros in the <b>least</b> <b>significant</b> <b>digits,</b> due to the casting of integer values into floating point. The accuracy of these approximations is studied and the results are used to develop a simple, but effective, hardware scheme...|$|R
