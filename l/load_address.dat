39|405|Public
25|$|An unusual {{aspect of}} drivers and TSRs, {{is that they}} would use {{different}} amounts of conventional and/or upper memory, based on the order they were loaded. This {{could be used to}} advantage if the programs were repeatedly loaded in different orders, and checking to see how much memory was free after each permutation. For example, if there was a 50 KB UMB and a 10 KB UMB, and programs needing 8 KB and 45 KB were loaded, the 8 KB might go into the 50 KB UMB, preventing the second from loading. Later versions of DOS allowed the use of a specific <b>load</b> <b>address</b> for a driver or TSR, to fit drivers/TSRs more tightly together.|$|E
25|$|Since shared {{libraries}} on most {{systems do}} not change often, systems can compute a likely <b>load</b> <b>address</b> for each shared library on the system before it is needed, and store that information in the libraries and executables. If every shared library that is loaded has undergone this process, then each will load at its predetermined address, which speeds up the process of dynamic linking. This optimization is known as prebinding in macOS and prelinking in Linux. Disadvantages of this technique include {{the time required to}} precompute these addresses every time the shared libraries change, the inability to use address space layout randomization, and the requirement of sufficient virtual address space for use (a problem that will be alleviated by the adoption of 64-bit architectures, {{at least for the time}} being).|$|E
2500|$|ESI = @.someString [...] // <b>load</b> <b>address</b> of someString to ESI ...|$|E
5000|$|LA 1,ARGS <b>Load</b> {{argument}} list <b>address</b> L 15,=A(SUB) <b>Load</b> subroutine <b>address</b> BALR 14,15 Branch to called routine1 ... ARGS DC A(FIRST) Address of 1st argument DC A(SECOND) ... DC A(THIRD)+X'80000000' Last argument2 ...|$|R
50|$|Relocation is {{the process}} of {{assigning}} <b>load</b> <b>addresses</b> to position-dependent code of a program and adjusting the code and data in the program to reflect the assigned addresses.A linker usually performs relocation in conjunction with symbol resolution, the process of searching files and libraries to replace symbolic references or names of libraries with actual usable addresses in memory before running a program.|$|R
5000|$|Three new supervisor-state {{instructions:}} Load Multiple Control (LMC), Store Multiple Control (SMC), <b>Load</b> Real <b>Address</b> (LRA) ...|$|R
5000|$|Set the {{switches}} to 0030 (Octal address 30), depress the <b>Load</b> <b>Address</b> switch. The address lights will change back to [...] "0030".|$|E
50|$|The <b>load</b> <b>address</b> in the 2 {{files of}} $2000 for bitmap and $400 for videoram {{respectively}} {{are in the}} file headers and are used by the LOAD command to read the files directly into the C64's RAM.|$|E
50|$|Modern {{operating}} systems also come with position-independent executables (PIE) for security. Together with ASLR, the binaries are loaded {{to a different}} virtual memory address each code execution. This makes the reliable modification of static memory values more complex. The <b>load</b> <b>address</b> has to be determined and subtracted from a found memory address to obtain a static memory offset. This offset is often exactly {{the address of the}} static variable within the PIE binary. E.g. the Linux tool scanmem supports PIE this way. For the configured memory offset the game trainer determines the <b>load</b> <b>address</b> as well and adds it back during run-time. The same method can be used for dynamic libraries as well.|$|E
50|$|NAMC simply <b>loads</b> the <b>address</b> couple {{onto the}} top of the stack as an IRW (with the tag {{automatically}} set to 1).|$|R
50|$|A minor {{benefit of}} this scheme (compared to a load-queue search) {{is that it}} will not flag a RAW {{dependence}} violation and trigger a pipeline flush if a store that would have caused a RAW dependence violation (the store's address matches an in-flight <b>load's</b> <b>address)</b> has a data value that matches the data value already in the cache. In the load-queue search scheme, an additional data comparison would need {{to be added to the}} load-queue search hardware to prevent such a pipeline flush.|$|R
5000|$|... load address: this command parallel-loads 4 bits {{from the}} data bus. to fully <b>load</b> an <b>address,</b> this command must be {{executed}} 5 times in sequence, for a load of a 20 bit block (LSB-first 14 bit address, 4 CE bits, and two unused bits, effectively 18 address bits) into the internal address pointer. On the TMS6125 the command must be executed 4 times instead, and only a 16 bit block is <b>loaded</b> (12 <b>address</b> bits, two unused bits, and two CE bits).|$|R
50|$|The {{advanced}} <b>load</b> <b>address</b> table (ALAT) is {{a functional}} {{unit in the}} Intel Itanium processor architecture. It is implemented with an associative memory. The ALAT is used to store information related to advance load instructions, {{as part of the}} speculative execution process.|$|E
5000|$|... files {{normally}} contain {{executable program}} code, although {{they can also}} be used for data files. The first two bytes of the [...] are read by the kernal [...] "load file" [...] routine and used to determine the <b>load</b> <b>address</b> (they are stored in a little endian format).|$|E
50|$|ADFS {{provides}} hierarchical directory structure, {{rather than}} the flat model of DFS. ADFS also stores some metadata about each file, notably a <b>load</b> <b>address,</b> an execution address, owner and public privileges, and a lock bit. Even on the eight-bit machines, load addresses are stored in 32-bit format, since those machines support 16- and 32-bit coprocessors.|$|E
5000|$|In early {{computers}} {{such as the}} IBM System/360 (1965), {{code was}} position-dependent: each program was built to be loaded into, and run from, a particular address. Where a multitasking operating system allowed multiple jobs to be run using separate programs at the same time, operations had to be scheduled such that no two concurrent jobs would run programs that required the same <b>load</b> <b>addresses.</b> For example, both a payroll program and an accounts receivable program built to run at address 32K could not both be run at the same time.|$|R
40|$|This paper {{presents}} a flexural-torsional analysis of composite box beams. A general analytical model applicable to thin-walled box section composite beams subjected to vertical and torsional load is developed. This model {{is based on}} the classical lamination theory, and accounts for the coupling of flexural and torsional responses for arbitrary laminate stacking sequence configuration, i. e. unsymmetric as well as symmetric. Governing equations are derived from the principle of the stationary value of total potential energy. Numerical results are obtained for thin-walled composites beams under vertical and torsional <b>loading,</b> <b>addressing</b> the effects of fiber angle and laminate stacking sequence...|$|R
5000|$|Some {{instruction}} set architectures, such as Intel x86 and IBM/360 and its successors, have a <b>Load</b> effective <b>address</b> instruction.This performs a {{calculation of the}} effective operand address, but instead of acting on that memory location, it <b>loads</b> the <b>address</b> {{that would have been}} accessed into a register. This can be useful when passing the address of an array element to a subroutine. It may also be a slightly sneaky way of doing more calculations than normal in one instruction; for example, using such an instruction with the addressing mode [...] "base+index+offset" [...] (detailed below) allows one to add two registers and a constant together in one instruction.|$|R
50|$|Like all BIN (Binary) {{files on}} the C64 and C128, the files had a binary header of 2 bytes (1 integer). The header gave the <b>load</b> <b>address</b> for the file, {{and the length}} was already known to BASIC 7. The default load {{addresses}} on the C128 were $2000, $1C00, and $D800 for bitmap, videoram, and colorram respectively.|$|E
50|$|The {{following}} Commodore BASIC 7 program loads a BSAVED HIRES Monochrome Graphics Screen on the C128 then sets each of {{the colors}} for the 1000 pixel blocks to black and white, waits for a keypress and ends. No colors are stored in the image. The <b>load</b> <b>address</b> in the image is {{at the start of}} display memory at $2000.|$|E
5000|$|The Commodore 64 {{version of}} Koala Painter used a fairly simple file format {{corresponding}} {{directly to the}} way bitmapped graphics are handled on the computer: A two-byte <b>load</b> <b>address,</b> followed immediately by 8000 bytes of raw bitmap data, 1000 bytes of raw [...] "Video Matrix" [...] data, 1000 bytes of raw [...] "Color RAM" [...] data, and a one-byte Background Color field.|$|E
5000|$|... {{read and}} branch: this reads 16 bits {{of data from}} the current address(and bit?) pointed to, and loads the value read into the address pointer, leaving the high bits of the address pointer alone. (This was {{intended}} for making VSMs with multiple languages available, where the initial <b>load</b> <b>addresses</b> could remain static, so for example they would not require changes to code in a microcontroller, and only the values pointed to in the VSM needed changing. In practice it doesn't seem to have ever been used, as it doesn't work when more than one VSM chip shares a bus, which is what was done in most cases.) ...|$|R
5000|$|The servlet is {{dynamically}} retrieved and <b>loaded</b> {{into the}} <b>address</b> {{space of the}} container.|$|R
50|$|Opcode 0F07. The {{instruction}} <b>loads</b> {{data from}} <b>address</b> ES:EDI. It actually uses ES, not the ES descriptor.|$|R
50|$|The {{following}} Commodore BASIC 7 program loads a BSAVED HIRES Colored Graphics Screen in DOODLE uncompressed format on the C128, {{waits for}} a keypress and ends. The <b>load</b> <b>address</b> in the image is {{at the start of}} C128 videoram at $1C00 directly before screen memory at $2000. No color setting is required since the colors are stored in the image and are loaded directly into the C128's HIRES color memory (videoram).|$|E
5000|$|On the Commodore 64, {{entering}} [...] will {{flood the}} screen with garbage instead of loading the directory into BASIC RAM. This is because the drive assigns the directory a <b>load</b> <b>address</b> of $0401 (1025), which {{is equivalent to the}} start of BASIC for the Commodore PET, but corresponds to the default screen memory in the C64 (starting with the second character on the first line of the screen).|$|E
50|$|IBM DOS/360 (1966) did {{not have}} the ability to {{relocate}} programs during loading. Sometimes multiple versions of a program were maintained, each built for a different <b>load</b> <b>address.</b> A special class of programs, called self-relocating programs, were coded to relocate themselves after loading. IBM OS/360 (1966) relocated executable programs when they were loaded into memory. Only one copy of the program was required, but once loaded the program could not be moved.|$|E
30|$|Suitable {{metadata}} for DR methods must {{be identified}} {{in terms of its}} classification and characteristics. DR methods can be classified by two dimensions: Place of decision-making and used communication (Kosek et al. 2013). The <b>loads</b> <b>addressed</b> and constraints met must also be determined, as, for example, methods that do not consider the same constraints cannot be compared (c.f., (Behrens et al. 2017)). Every method must be comparable with other methods from the same “class” and suitable for the scenario. Therefore, we add additional data (metadata) based on the DR method’s classification (Kosek et al. 2013), the compliances addressed and the constraints considered (Behrens et al. 2017). The methods themselves must be available in a repository, either locally on the HEMS or in the cloud.|$|R
40|$|In modern architectures, {{memory access}} latency is an {{increasingly}} performance-limiting factor. To reduce this latency, we propose concepts {{and implementation of}} a new technique that uses an inmemory processor to precompute future, critical <b>load</b> <b>addresses</b> and forward the computed values to the main processor. The acronym for this technique is IMPT for In-Memory Precomputation-based forwarding Threads. IMPT combines the advantages of precomputation-based techniques with the low memory access latency of processing-in-memory. To evaluate IMPT, we use a cycle-accurate simulation of an aggressive out-oforder processor with accurate simulation of bus and memory contention. The results show a performance gain of up to 1. 47 (1. 21 on average) over an aggressive superscalar processor. The average load access latency decreases by up to 55 % (32 % on average) ...|$|R
5000|$|... read bit: this reads {{a single}} bit at the <b>loaded</b> <b>address,</b> and {{advances}} the 3 bit 'bit pointer' {{to point to}} the next bit within the address; if the bit pointer overflows, the address pointer is incremented. If the address pointed to on a specific chip is outside of the mask-programmed range of said VSM, the VSM will leave the data bus 'open' in a high impedance state, so another chip wired in parallel (which has the address within its mask-programmed range) can supply the data instead. A rarely used mask option made the read bit command read 4 bits at once; this was used on a few non-speech products, and could not be used with the TI-manufactured LPC speech ICs.|$|R
50|$|The {{following}} Commodore BASIC 7 program loads a BSAVED Multi-Colored 4 Color Graphics Screen in 3 separate BSaved Files (a split image) on the C128, {{waits for}} a keypress and ends. The <b>load</b> <b>address</b> in the 3 files are $2000 for bitmap, $1C00 for videoram, and $D800 for colorram respectively. No color setting is required since the colors are stored in the videoram and colorram and are loaded directly into the C128's RAM.|$|E
5000|$|The {{bootstrap}} loader on PC-compatible computers (MBR or boot sector) {{is located at}} track zero, the first sector on a disk. The ROM BIOS will load this sector into memory at address :, and typically check for a signature [...] "" [...] at offset [...] If the sector is {{not considered to be}} valid, the ROM BIOS will try the next physical disk in the row, otherwise it will jump to the <b>load</b> <b>address</b> with certain registers set up.|$|E
50|$|Like the {{cassette}} filing system, the Acorn DFS supports the BBC Micro's standard file metadata: <b>load</b> <b>address</b> and execution address, required because Acorn MOS (the operating system {{used by the}} BBC Micro) does not support relocation of binary code. A file should be loaded to the address the programmer intended, as the contents may refer to internal locations by absolute addresses. An execution address is also recorded as the entry point is not necessarily at the beginning, or even within the file.|$|E
50|$|Bit6: {{position}} value $40, <b>loads</b> a new <b>address</b> for {{the start}} of screen memory for the current Playfield mode line.|$|R
50|$|OSWORD handles many {{functions}} {{other than}} sound, {{many of which}} do not have direct support in BASIC. They may be accessed from BASIC by setting up the parameter block, <b>loading</b> its <b>address</b> into X% and Y% and the task code into A%, and then calling the routine.|$|R
40|$|ABSTRACT 1 In modern architectures, {{memory access}} latency is an {{increasingly}} performance-limiting factor. To reduce this latency, we propose concepts {{and implementation of}} a new technique that uses an inmemory processor to precompute future, critical <b>load</b> <b>addresses</b> and forward the computed values to the main processor. The acronym for this technique is IMPT for In-Memory Precomputation-based forwarding Threads. IMPT combines the advantages of precomputation-based techniques with the low memory access latency of processing-in-memory. To evaluate IMPT, we use a cycle-accurate simulation of an aggressive out-oforder processor with accurate simulation of bus and memory contention. The results show a performance gain of up to 1. 47 (1. 21 on average) over an aggressive superscalar processor. The average load access latency decreases by up to 55 % (32 % on average) ...|$|R
