82|108|Public
2500|$|The same trick {{can be used}} {{to simplify}} the {{handling}} of a doubly linked <b>linear</b> <b>list,</b> by turning it into a circular doubly linked list with a single sentinel node. [...] However, in this case, the handle should be a single pointer to the dummy node itself.|$|E
2500|$|The {{advantages}} of the fancy variants are often limited {{to the complexity of}} the algorithms, not in their efficiency. [...] A circular list, in particular, can usually be emulated by a <b>linear</b> <b>list</b> together with two variables that point to the first and last nodes, at no extra cost.|$|E
2500|$|The {{simplest}} representation for {{an empty}} circular list (when {{such a thing}} makes sense) is a null pointer, indicating that the list has no nodes. [...] Without this choice, many algorithms have to test for this special case, and handle it separately. [...] By contrast, the use of null to denote an empty <b>linear</b> <b>list</b> is more natural and often creates fewer special cases.|$|E
25|$|While doubly linked and {{circular}} lists have {{advantages over}} singly linked <b>linear</b> <b>lists,</b> <b>linear</b> <b>lists</b> offer some advantages {{that make them}} preferable in some situations.|$|R
40|$|The {{essential}} {{problem of}} hashing is a solving of collisions of elements. One of possible solutions {{of this problem}} is chaining of colliding elements. The chains are stored inside or outside the table and they are usually represented as unsorted <b>linear</b> <b>lists.</b> The aim of this thesis is to design some alternative structures (sorted <b>linear</b> <b>lists,</b> self-organizing <b>linear</b> <b>lists,</b> etc.) for representation of colliding elements, to implement them into known algorithms and experimentally evaluate their effect on efficiency of dictionary operations (Insert, Member, Delete) ...|$|R
5000|$|... #Subtitle level 3: Singly linked <b>linear</b> <b>lists</b> vs. other lists ...|$|R
2500|$|A singly linked <b>linear</b> <b>list</b> is a {{recursive}} data structure, {{because it}} contains a pointer to a smaller object of the same type. [...] For that reason, many operations on singly linked linear lists (such as merging two lists, or enumerating the elements in reverse order) often have very simple recursive algorithms, much simpler than any solution using iterative commands. [...] While those recursive solutions can be adapted for doubly linked and circularly linked lists, the procedures generally need extra arguments and more complicated base cases.|$|E
2500|$|However, if the {{circular}} list is used merely to simulate a <b>linear</b> <b>list,</b> one may avoid {{some of this}} complexity by adding a single sentinel node to every list, between the last and the first data nodes. [...] With this convention, an empty list consists of the sentinel node alone, pointing to itself via the next-node link. [...] The list handle should then be a pointer to the last data node, before the sentinel, if the list is not empty; or to the sentinel itself, if the list is empty.|$|E
5000|$|This {{method of}} {{implementing}} indexing is detailed in Section 3.4 <b>Linear</b> <b>List</b> Operations in [...] "A skip list cookbook" [...] by William Pugh.|$|E
40|$|In multi-objective {{evolutionary}} algorithms (MOEAs) with elitism, {{the data}} structures for storing and updating archives {{may have a}} great impact on the required computational (CPU) time, especially when optimizing higherdimensional problems with large Pareto-sets. In this chapter, we introduce Quad-trees as an alternative data structure to <b>linear</b> <b>lists</b> for storing Paretosets. In particular, we investigate several variants of Quad-trees and compare them with conventional <b>linear</b> <b>lists.</b> We also study the influence of population size and number of objectives on the required CPU time. These data structures are evaluated and compared on several multi-objective example problems. The results presented show that typically, <b>linear</b> <b>lists</b> perform better for small population sizes and higher-dimensional Pareto-fronts (large archives) whereas Quad-trees perform better for larger population sizes and Pareto-sets of small cardinality...|$|R
30|$|In this work, {{we take a}} {{different}} direction. We keep the simplicity of <b>linear</b> <b>lists,</b> but we exploit the cooperative nature of mesh networks to reduce the overhead for each single node.|$|R
40|$|Abstract- In MOEAs with elitism, {{the data}} {{structures}} and algorithms for storing and updating archives {{may have a}} great impact on the CPU time, especially when optimizing continuous problems with larger population sizes. In this paper, we introduce Quad-trees as an efficient data structure for storing Pareto-points. Apart from conventional <b>linear</b> <b>lists,</b> we have implemented three kinds of Quad-trees for the archives. These data structures were examined for different examples. The results presented show that <b>linear</b> <b>lists</b> perform better in terms of CPU time for small population sizes whereas tree structures perform better for large population sizes. I...|$|R
50|$|The same trick {{can be used}} {{to simplify}} the {{handling}} of a doubly linked <b>linear</b> <b>list,</b> by turning it into a circular doubly linked list with a single sentinel node. However, in this case, the handle should be a single pointer to the dummy node itself.|$|E
50|$|The {{advantages}} of the fancy variants are often limited {{to the complexity of}} the algorithms, not in their efficiency. A circular list, in particular, can usually be emulated by a <b>linear</b> <b>list</b> together with two variables that point to the first and last nodes, at no extra cost.|$|E
50|$|The {{simplest}} representation for {{an empty}} circular list (when {{such a thing}} makes sense) is a null pointer, indicating that the list has no nodes. Without this choice, many algorithms have to test for this special case, and handle it separately. By contrast, the use of null to denote an empty <b>linear</b> <b>list</b> is more natural and often creates fewer special cases.|$|E
40|$|This paper {{introduces}} a general technique for speeding up unsuccessful search using very little extra space (two bits per key). This technique is applicable to many data structures including <b>linear</b> <b>lists</b> and search trees. For <b>linear</b> <b>lists</b> we obtain on-line algorithms for processing {{a sequence of}} successful and unsuccessful searches which are competitive with strong off-line algorithms. In a virtual memory environment our self-adjusting algorithm for multiway search trees is competitive with an optimal static multiway tree and will often outperform the static tree. We are also able to extend several other results for successful search to include both successful and unsuccessful searches. © 1993 Academic Press. All rights reserved. link_to_subscribed_fulltex...|$|R
40|$|Self-organizing <b>linear</b> <b>lists</b> Self-organizing <b>linear</b> <b>lists</b> are data {{structures}} for fast search, provided that certain elements stored in them are searched {{more frequently than}} others, while the probability of access to individual elements is generally not known in advance. Efficient search is achieved using different permutation rules that keep changing the list structure so that the more frequently searched elements are closer to the beginning. This thesis gives an overview of known algorithms for solving this problem (with the theoretical results about their complexity, if they are known), and experimental study of their behavior (using its own or freely available implementations and software for generating input data, testing algorithms and processing the results of experiments) ...|$|R
50|$|Numerous data {{structures}} {{are available for}} implementing tables. Trees, <b>linear</b> <b>lists</b> and self-organizing lists can all be used to implement a symbol table. The symbol table is accessed by most phases of a compiler, beginning with lexical analysis, and continuing through optimization.|$|R
50|$|For separate-chaining, the {{worst-case}} scenario is when all entries are inserted into the same bucket, {{in which case the}} hash table is ineffective and the cost is that of searching the bucket data structure. If the latter is a <b>linear</b> <b>list,</b> the lookup procedure may have to scan all its entries, so {{the worst-case}} cost is proportional to the number n of entries in the table.|$|E
50|$|Another {{useful and}} user-driven node concept is the layer. A layer {{acts like a}} {{transparent}} sheet upon which any number of shapes and shape groups can be placed. The document then becomes a set of layers, any {{of which can be}} conveniently made invisible, dimmed, or locked (made read-only). Some applications place all layers in a <b>linear</b> <b>list,</b> while others support sublayers (i.e., layers within layers to any desired depth).|$|E
50|$|For example, {{one could}} define an {{abstract}} data type called lookup table which uniquely associates keys with values, and in which values may be retrieved by specifying their corresponding keys. Such a lookup table may be implemented in various ways: as a hash table, a binary search tree, or even a simple <b>linear</b> <b>list</b> of (key:value) pairs. As far as client code is concerned, the abstract properties of the type are the same in each case.|$|E
40|$|We {{consider}} {{policies that}} manage fixed-size dynamic <b>linear</b> <b>lists,</b> when the references follow the independent reference model. Wedefine the counter scheme, apolicy {{that keeps the}} records sorted by their access frequencies, and prove that among all deterministic policies it produces the least expected cost of access, at any time. 1...|$|R
2500|$|The energy {{sequence}} of the first 35subshells (e.g., 1s, 2p, 3d, etc.) is given in the following table. Each cell represents a subshell with [...] and [...] given by its row and column indices, respectively. The number in the cell is the subshell's position in the sequence. For a <b>linear</b> <b>listing</b> of the subshells in terms of increasing energies in multielectron atoms, see the section below.|$|R
40|$|Abstract. Faceted {{navigation}} is {{a proven}} technique for exploration and {{discovery of a}} resource collection. In this paper, we report on a visual support toward the exploration {{of a collection of}} documents based on a set of entities of interest to users, in which faceted navigation is employed for the filtering process. Our approach can be used when metadata is not available and unlike other faceted browsing work, it treats documents as content-bearing items. We propose using a multidimensional visualization {{as an alternative to the}} <b>linear</b> <b>listing</b> of focus items. We describe how visual abstractions based on a combination of structural equivalence and conceptual structure can be used simultaneously to deal with a large number of items, as well as visual ordering based on the importance of facet values to support prioritized, cross-facet comparison of focus items. A user study was conducted and it showed that interfaces using the proposed approach can better support users in exploratory tasks and were also well-liked by the participants of the study, with the hybrid interface combining the multi-dimensional visualization with the <b>linear</b> <b>listing</b> receiving the mos...|$|R
50|$|The {{basic data}} {{structure}} of Lisp and Prolog is a <b>linear</b> <b>list</b> consed {{up from the}} beginning. Refal lists are built and scanned from both ends, and pattern matching allows to match against nested lists {{as well as the}} top-level one. (In effect, the basic data structure of Refal is a tree rather than a list). According to the authors, this gives freedom and convenience in creating data structures while using only mathematically simple control mechanisms of pattern matching and substitution.|$|E
50|$|A singly linked <b>linear</b> <b>list</b> is a {{recursive}} data structure, {{because it}} contains a pointer to a smaller object of the same type. For that reason, many operations on singly linked linear lists (such as merging two lists, or enumerating the elements in reverse order) often have very simple recursive algorithms, much simpler than any solution using iterative commands. While those recursive solutions can be adapted for doubly linked and circularly linked lists, the procedures generally need extra arguments and more complicated base cases.|$|E
50|$|However, if the {{circular}} list is used merely to simulate a <b>linear</b> <b>list,</b> one may avoid {{some of this}} complexity by adding a single sentinel node to every list, between the last and the first data nodes. With this convention, an empty list consists of the sentinel node alone, pointing to itself via the next-node link. The list handle should then be a pointer to the last data node, before the sentinel, if the list is not empty; or to the sentinel itself, if the list is empty.|$|E
40|$|The {{transposition}} rule is an algorithm for self-organizing <b>linear</b> <b>lists.</b> Upon {{a request for}} a given item, the item is transposed with the preceding one. The cost of a request is the distance of the requested item {{from the beginning of the}} list. An asymptotic optimality of the rule with the respect to the optimal static arrangement is demonstrated for two families of request distributions. The result is established by considering an associated constrained asymmetric exclusion process...|$|R
40|$|International audienceWe {{present a}} (non-standard) {{probabilistic}} analysis of dynamic data structures whose sizes are considered dynamic random walks. The basic operations (insertion, deletion, {{positive and negative}} queries, batched insertion, lazy deletion, etc.) are time-dependent random variables. This model is a (small) step toward the analysis of these structures when {{the distribution of the}} set of histories is not uniform. As an illustration, we focus on <b>list</b> structures (<b>linear</b> <b>lists,</b> priority queues, and dictionaries) but the technique is applicable as well to more advanced data structures...|$|R
40|$|AbstractGiven an n-edge convex {{subdivision}} of the plane, is {{it possible}} to report its k intersections with a query line segment in O(k+polylog(n)) time, using subquadratic storage? If the query is a plane and the input is a polytope with n vertices, can one achieve O(k+polylog(n)) time with subcubic storage? Does any convex polytope have a boundary dominant Dobkin–Kirkpatrick hierarchy? Can fractional cascading be generalized to planar maps instead of <b>linear</b> <b>lists?</b> We prove that the answer to all of these questions is no, and we derive near-optimal solutions to these classical problems...|$|R
50|$|As {{with most}} other {{calculator}} programming languages of the 1980s, a FOCAL {{program is a}} <b>linear</b> <b>list</b> of instructions. Each instruction (or step) roughly correspond to a key (or key combination) press, and thus correspond to what the user would do if he was to perform the computation himself on the calculator. This paradigm made FOCAL programming relatively easy for the newcomer, but program maintenance could be a nightmare.Besides that, the use of GOTO instructions - including going to a program step based on a value in a data register ("GTO IND"), a technique known as computed goto - , easily led to spaghetti code.|$|E
5000|$|Modern design closure {{has grown}} orders of {{magnitude}} more complex. Modern logic chips can have tens to {{hundreds of millions of}} logic elements switching at speeds of severalGHz. This improvement has been driven by Moore’s law of scaling of technology, and has introduced many new design considerations. As a result, a modern VLSI designer must consider the performance of a chip against a list of dozens of design constraints and objectives including performance, power, signal integrity, reliability, and yield. In response to this growing list of constraints, the design closure flow has evolved from a simple <b>linear</b> <b>list</b> of tasks to a very complex, highly iterative flow such as the following simplified ASIC design flow: ...|$|E
5000|$|Objects {{included}} Activities (now {{more commonly}} known as tasks or processes), Segments (of memory), Files, Semaphores and Clocks. Another object type, the Sphere, was a run-time protection domain within which all other object types (including other Spheres) existed. Objects could be created in arbitrary quantities, and were each referenced through a Run Time Name, or RTN. Since an object could be referenced by several RTNs belonging to different spheres, they could easily be shared between programs, and were deleted only when the object's reference count of RTNs fell to zero. Linked lists were used very extensively within E4 to manage data structures, in fact the RTN list was about the only <b>linear</b> <b>list</b> there was. (The system generation process included a phase prosaically called [...] "knitting" [...] comprising a combination of macro expansion and procedural elements, by which the initial data structures were dynamically [...] "knitted" [...] together to create an input file for the assembler.) ...|$|E
40|$|The Oxford Surgical Data System (OSDS) allows {{accurate}} and comprehensive storage and retrieval of data, including personal information, operation details, complications and diagnoses of both inpatients and outpatients. The system {{is based on}} the MEDUS/A medical data management package and its database is practice-based, the operator being the medical secretary. To avoid long <b>linear</b> <b>lists</b> of diagnoses (based on ICD- 9) or operations (based on OPSC) a successful alphabetical code has been developed. The code can be readily extended to accommodate research requirements, or data collection in other medical specialities...|$|R
40|$|Given an n-edge convex {{subdivision}} of the plane, is {{it possible}} to report its k intersections with a query line segment in Oðk þ polylogðnÞÞ time, using subquadratic storage? If the query is a plane and the input is a polytope with n vertices, can one achieve Oðk þ polylogðnÞÞ time with subcubic storage? Does any convex polytope have a boundary dominant Dobkin–Kirkpatrick hierarchy? Can fractional cascading be generalized to planar maps instead of <b>linear</b> <b>lists?</b> We prove that the answer to all of these questions is no, and we derive near-optimal solutions to these classical problems...|$|R
40|$|Conditional expressions, {{composition}} and recursion {{are the basic}} operations used in LISP to define functions on list structures. Any computable function of arbitrarily complex list structures may be described using these operations, but certain simple transformations of <b>linear</b> <b>lists</b> (strings) are awkward to define in this notation. Such transformations may be characterized (and caricaturized) by the following instructions for a transformation: "Take that substring there, and that other one starting with "Black", which has the substring mentioned third as the first; then inserts the second substring mentioned; omit the first and leave the unmentioned parts of the original string unchanged. ...|$|R
