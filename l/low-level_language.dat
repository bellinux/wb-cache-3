154|437|Public
25|$|Because X# is a <b>low-level</b> <b>language,</b> {{there are}} no stack frames inserted, so by default, there should be the return EIP address {{on the top of}} the stack.|$|E
50|$|Quantum Macro Assembler (QMASM) is a <b>low-level</b> <b>language</b> {{specific}} to quantum annealers {{such as the}} D-Wave.|$|E
5000|$|A {{program that}} {{translates}} from a <b>low-level</b> <b>language</b> {{to a higher}} level one is a decompiler.|$|E
40|$|Abstract—Formalizing the {{semantics}} {{of programming}} languages like C or C++ for bounded model checking can be cumbersome if complete coverage of all language features {{is to be}} achieved. On the other hand, <b>low-level</b> <b>languages</b> that occur during translation (compilation) have a much simpler semantics since they are closer to the machine level. It thus makes sense to use these <b>low-level</b> <b>languages</b> for bounded model checking. In this paper we present a highly precise memory model suitable for bounded model checking of such <b>low-level</b> <b>languages.</b> Our method also takes memory protection (malloc/free) into account. I...|$|R
50|$|Assembly <b>languages</b> and <b>low-level</b> <b>languages</b> like BCPL {{generally}} have no syntactic support for arrays.|$|R
5000|$|In {{computer}} science, a <b>low-level</b> programming <b>language</b> is a {{programming language}} that provides little or no abstraction from a computer's instruction set architecture—commands or functions in the language map closely to processor instructions. Generally this refers to either machine code or assembly language. The word [...] "low" [...] refers to the small or nonexistent amount of abstraction between the language and machine language; because of this, <b>low-level</b> <b>languages</b> are sometimes described as being [...] "close to the hardware". Programs written in <b>low-level</b> <b>languages</b> tend to be relatively non-portable, {{mainly because of the}} close relationship between the language and the hardware architecture.|$|R
5000|$|Assembly {{language}} {{is a type of}} <b>low-level</b> <b>language</b> and a program that compiles it is an assembler, with the inverse program known as a disassembler.|$|E
50|$|The term {{is mostly}} {{used as a}} pejorative to imply poor hygiene, <b>low-level</b> <b>language</b> skills, limited education, slovenly or sexual style of dress, sexual flirtation and promiscuity, and {{aggressive}} social behavior associated with {{people who live in}} trailers.|$|E
50|$|Beyond yoUrself In Language Development (BUILD) is a student-run {{organization}} that provides free <b>low-level</b> <b>language</b> classes in thirteen languages to the Middlebury Institute of International Studies (MIIS) community. Classes are taught by {{students enrolled in}} the TESOL and Teaching Foreign Language programs at MIIS.|$|E
50|$|The {{advantage}} of a single language rather than separate specification, high-level, and <b>low-level</b> <b>languages</b> is that the program can be incrementally refined, with intermediate versions retaining some higher-level and some lower-level constructs.|$|R
50|$|The main {{advantage}} of high-level <b>languages</b> over <b>low-level</b> <b>languages</b> {{is that they}} are easier to read, write, and maintain. Ultimately, programs written in a high-level language must be translated into machine language by a compiler or interpreter.|$|R
50|$|There {{are also}} <b>low-level</b> <b>languages</b> {{such as the}} Lx family {{implemented}} by the bootstrapping method. The L0 language may be considered as assembler for transformation languages. There is also a high-level graphical language built on upon Lx called MOLA.|$|R
50|$|The {{goal of the}} Tkabber {{project is}} to create a {{cross-platform}} XMPP client which is feature-rich and is easy to hack. Tkabber is written in Tcl allowing it can be customized without knowledge of a <b>low-level</b> <b>language</b> such as C++ and its build system.|$|E
50|$|Adobe {{introduced}} a new, low-level 3D API in version 11 of the Flash Player. Initially codenamed Molehill, the official name given to this API was ultimately Stage3D. It {{was intended to}} be an equivalent of OpenGL or Direct3D. In Stage3D shaders are expressed in a <b>low-level</b> <b>language</b> called Adobe Graphics Assembly Language (AGAL).|$|E
50|$|This change {{also makes}} it {{possible}} to simplify the implementation of the receiving end (often, a bootstrap program written in a <b>low-level</b> <b>language)</b> by omitting the retransmission timer, as any lost packet would cause retransmission of the last packet sent by the sender. However, keeping the timer has its benefits, such as dealing with lost ACKs more efficiently.|$|E
40|$|Providing type {{structure}} for extremely <b>low-level</b> programming <b>languages,</b> such as assembly language, yields {{a number of}} important benefits for compiler and systems projects, where reliability and security are crucial concerns. We discuss some of the issues involved in designing type systems for <b>low-level</b> <b>languages,</b> and identify some general principles that simplify constructing a proof of soundness. 1 Introduction Over the past twenty years, there has been tremendous progress in the design and foundations of type systems for high-level programming languages culminating in the design of such languages as Modula- 3, Standard ML, Haskell, and Java. The goal of much of the research was to strengthen the logic of a type system so that a richer class of abstractions and invariants could be stated and yet enforced automatically. Recently, we (and others) have been exploring the design, applications, and foundations of type systems for extremely <b>low-level</b> <b>languages.</b> In particular, we have conc [...] ...|$|R
5000|$|TGSI, a <b>low-level</b> {{intermediate}} <b>language</b> {{introduced by}} Gallium3D ...|$|R
2500|$|ARB {{assembly}} language – OpenGL's legacy <b>low-level</b> shading <b>language</b> ...|$|R
5000|$|FBP {{has much}} in common with the Linda {{language}} in that it is, in Gelernter and Carriero's terminology, a [...] "coordination language": it is essentially language-independent. Indeed, given a scheduler written in a sufficiently <b>low-level</b> <b>language,</b> components written in different languages can be linked together in a single network. FBP thus lends itself to the concept of domain-specific languages or [...] "mini-languages".|$|E
50|$|Because X# is a <b>low-level</b> <b>language,</b> {{there are}} no stack frames inserted, so by default, there should be the return EIP address {{on the top of}} the stack.X# {{function}} calls do contain arguments enclosed in parentheses, unlike in function headers. Arguments passed to functions can be registers, addresses, or constants. These arguments are pushed onto the stack in reverse order. Note that the stack on x86 platforms cannot push or pop one-byte registers.|$|E
5000|$|MySQL {{was created}} by a Swedish company, MySQL AB, founded by David Axmark, Allan Larsson and Michael [...] "Monty" [...] Widenius. Original {{development}} of MySQL by Widenius and Axmark began in 1994. The first version of MySQL appeared on 23 May 1995. It was initially created for personal usage from mSQL based on the <b>low-level</b> <b>language</b> ISAM, which the creators considered too slow and inflexible. They created a new SQL interface, while keeping the same API as mSQL. By keeping the API consistent with the mSQL system, many developers {{were able to use}} MySQL instead of the (proprietarily licensed) mSQL antecedent.|$|E
5000|$|AMDIL, a <b>low-level</b> {{intermediate}} <b>language</b> used internally at AMD ...|$|R
5000|$|ARB {{assembly}} language - OpenGL's legacy <b>low-level</b> shading <b>language</b> ...|$|R
5000|$|Second generation: <b>Low-level</b> {{programming}} <b>languages</b> such as Assembly language.|$|R
50|$|However, {{there are}} many {{different}} types of compiler. If the compiled program can run on a computer whose CPU or operating system is different from the one on which the compiler runs, the compiler is a cross-compiler. A bootstrap compiler is written in the language that is compiled. A program that translates from a <b>low-level</b> <b>language</b> to a higher level one is a decompiler. A program that translates between high-level languages is usually called a source-to-source compiler or transpiler. A language rewriter is usually a program that translates the form of expressions without a change of language. The term compiler-compiler refers to tools used to create parsers that perform syntax analysis.|$|E
5000|$|Low-level {{languages}} {{can convert}} to machine code without a compiler or interpreter— second-generation programming languages use a simpler processor called an assembler— {{and the resulting}} code runs directly on the processor. A program written in a <b>low-level</b> <b>language</b> {{can be made to}} run very quickly, with a small memory footprint. An equivalent program in a high-level language can be less efficient and use more memory. Low-level languages are simple, but considered difficult to use, due to numerous technical details that the programmer must remember. By comparison, a high-level programming language isolates execution semantics of a computer architecture from the specification of the program, which simplifies development.|$|E
5000|$|David DeWitt and Michael Stonebraker, {{computer}} scientists specializing in parallel databases and shared-nothing architectures, {{have been critical}} of the breadth of problems that MapReduce can be used for. They called its interface too low-level and questioned whether it really represents the paradigm shift its proponents have claimed it is. They challenged the MapReduce proponents' claims of novelty, citing Teradata as an example of prior art that has existed for over two decades. They also compared MapReduce programmers to CODASYL programmers, noting both are [...] "writing in a <b>low-level</b> <b>language</b> performing low-level record manipulation." [...] MapReduce's use of input files and lack of schema support prevents the performance improvements enabled by common database system features such as B-trees and hash partitioning, though projects such as Pig (or PigLatin), Sawzall, Apache Hive, YSmart, HBase and BigTable are addressing some of these problems.|$|E
25|$|Some compilers for {{relatively}} <b>low-level</b> <b>languages,</b> such as Pascal or C, allow the programmer to embed assembly language {{directly in the}} source code. Programs using such facilities can then construct abstractions using different assembly language on each hardware platform. The system's portable code can then use these processor-specific components through a uniform interface.|$|R
5000|$|Lx family (see http://lx.mii.lu.lv/) : {{a set of}} <b>low-level</b> {{transformation}} <b>languages</b> ...|$|R
40|$|User {{interfaces}} {{determine the}} process support {{that is really}} delivered to the user. In order to support a process effectively, individually tailored user interfaces have to be provided. Most process centered software engineering environments (PSEEs) provide predefined user interfaces, but only <b>low-level</b> <b>languages</b> {{which can be used}} by customers to build process-specific user interfaces...|$|R
40|$|In {{this paper}} a concept for the {{integration}} of complex modelling techniques like e. g. UML is proposed. The integration is done by translating complex models consisting of parts following different modelling paradigms into a common <b>low-level</b> <b>language,</b> {{which is designed to}} be minimalistic enough to serve as a source for code generation and verification. On the other hand the <b>low-level</b> <b>language</b> should be expressive enough to allow {{the integration of}} the most common structural, behavioural, and constraint modelling languages. As an example for a complex modelling technique a derivation of the UML, which focuses on a small subset of the UML diagrams, but also adds some additional techniques, is considered. Moreover, a <b>low-level</b> <b>language</b> for object-oriented modelling techniques is sketched...|$|E
40|$|Petri nets were devised {{for use in}} the {{modelling}} of {{a specific}} class of problems. Typical situations that can be modelled by Petri nets are synchronization, sequentiality, concurrency and conflict. This paper focuses on a <b>low-level</b> <b>language</b> program representation by means of Petri nets. In particular, Petri net formalisms were explored with emphasis on the application of the methodology in the modelling of a sequential <b>low-level</b> <b>language</b> program using a Motorola MC 68000 assembly language program as an example. In the Petri net representation of the sequential <b>low-level</b> <b>language</b> program under consideration, tokens denote the values of immediate data as well as availability of the data. Thus, the developed petri net model shows that Petri net formalism can be conveniently used to represent flows of control and not flows of data...|$|E
40|$|Abstract: In {{the area}} of language-based {{security}} programs written in typed high-level languages need to be translated into those written in typed low-level languages. This work is not trivial when type dispatch constructs are involved which are implemented with tag mechanism. This paper proposes a new type that can deal with a special type dispatch construct occurring in interface invokation of Java. A <b>low-level</b> <b>language</b> with this type is able to efficiently implement interface invokation in Java. This implementation approach is adopted in a Just-In-Time compiler with a typed <b>low-level</b> <b>language</b> as certifying language...|$|E
5000|$|Static assertions are {{particularly}} useful in compile time template metaprogramming, {{but can also}} be used in <b>low-level</b> <b>languages</b> like C by introducing illegal code if (and only if) the assertion fails. C11 and C++11 support static assertions directly through [...] In earlier C versions, a static assertion can be implemented, for example, like this: ...|$|R
40|$|Self-adjusting {{computation}} {{offers a}} language-based approach to writing programs that automatically respond to dynamically changing data. Recent work made {{significant progress in}} developing sound semantics and associated implementations of self-adjusting computation for high-level, functional languages. These techniques, however, do not address issues that arise for <b>low-level</b> <b>languages,</b> i. e., stack-based imperative languages that lack strong type systems and automatic memory management. In this paper, we describe techniques for self-adjusting computation which are suitable for <b>low-level</b> <b>languages.</b> Necessarily, we take a different approach than previous work: instead of starting with a high-level language with additional primitives to support self-adjusting computation, we start with a <b>low-level</b> intermediate <b>language,</b> whose semantics is given by a stack-based abstract machine. We prove that this semantics is sound: it always updates computations {{in a way that}} is consistent with full reevaluation. We give a compiler and runtime system for the intermediate language used by our abstract machine. We present an empirical evaluation that shows that our approach is efficient in practice, and performs favorably compared to prior proposals. Comment: Full version of our OOPLSA 2011 paper. Contains a couple of additional sections as well as an appendix with our proof...|$|R
40|$|Monte Carlo {{particle}} transport {{applications are}} often written in <b>low-level</b> <b>languages</b> (C/C++) for optimal performance on clusters and supercomputers. However, this development approach often sacrifices straightforward usability and {{testing in the}} interest of fast application performance. To improve usability, some high-performance computing applications employ mixed-language programming with high-level and <b>low-level</b> <b>languages.</b> In this study, we consider the benefits of incorporating an interactive Python interface into a Monte Carlo application. With PyMercury, a new Python extension to the Mercury general-purpose Monte Carlo particle transport code, we improve application usability without diminishing performance. In two case studies, we illustrate how PyMercury improves usability and simplifies testing and validation in a Monte Carlo application. In short, PyMercury demonstrates the value of interactive Python for Monte Carlo particle transport applications. In the future, we expect interactive Python to play an increasingly significant role in Monte Carlo usage and testing...|$|R
