9|13|Public
25|$|ISO/IEC 6937:2001, Information {{technology}} — Coded {{graphic character}} set for text communication — Latin alphabet, is a multibyte extension of ASCII, or rather of ISO/IEC 646-IRV. It {{was developed in}} common with ITU-T (then CCITT) for telematic services {{under the name of}} T.51, and first became an ISO standard in 1983. Certain byte codes are used as lead bytes for letters with diacritics (accents). The value of the <b>lead</b> <b>byte</b> often indicates which diacritic that the letter has, and the follow byte then has the ASCII-value for the letter that the diacritic is on. Only certain combinations of <b>lead</b> <b>byte</b> and follow byte are allowed, and there are some exceptions to the <b>lead</b> <b>byte</b> interpretation for some follow bytes. However, that no combining characters at all are encoded in ISO/IEC 6937. But one can represent some free-standing diacritics, often by letting the follow byte have the code for ASCII space.|$|E
25|$|The {{reference}} to combining {{characters in the}} U+0300—U+036F range for the codes in the range 0xC1—0xCF below are only indicative of which “accent” is usually intended by that <b>lead</b> <b>byte.</b> ISO/IEC 6937 does not encode any combining characters whatsoever. Instead, there is an explicit list of precomposed characters that are encoded.|$|E
2500|$|A little anomaly is that Latin Small Letter G with Cedilla is {{coded as}} if it were with an acute accent, that is, with a 0xC2 <b>lead</b> <b>byte,</b> since due to its {{descender}} interfering with a cedilla, the lowercase letter is usually with turned comma above: [...]|$|E
50|$|Secondly, Shift JIS {{has more}} {{encoding}} space than is needed, for JIS X 0201 and JIS X 0208 and this space can {{and is used}} for yet more characters. The space, with <b>lead</b> <b>bytes</b> 0xF5 to 0xF9, is used by Japanese mobile phone operators for pictographs for use in E-mail, for example. (KDDI goes further and defines hundreds more in the space with <b>lead</b> <b>bytes</b> 0xF3 and 0xF4).|$|R
50|$|In most implementations, {{the file}} command uses a {{database}} {{to drive the}} probing of the <b>lead</b> <b>bytes.</b> That database is implemented in a file called magic, whose location is usually in /etc/magic, /usr/share/file/magic or a similar location.|$|R
50|$|Code points 01hex to 1Fhex, {{which serve}} as control codes in ASCII, {{are used as}} <b>lead</b> <b>bytes</b> to switch the {{definition}} of code points above 7Fhex between several code groups (similar to code pages) {{and at the same}} time determine either a single- or multi-byte nature for the corresponding code group.|$|R
50|$|ISO/IEC 6937:2001, Information {{technology}} — Coded {{graphic character}} set for text communication — Latin alphabet, is a multibyte extension of ASCII, or rather of ISO/IEC 646-IRV. It {{was developed in}} common with ITU-T (then CCITT) for telematic services {{under the name of}} T.51, and first became an ISO standard in 1983. Certain byte codes are used as lead bytes for letters with diacritics (accents). The value of the <b>lead</b> <b>byte</b> often indicates which diacritic that the letter has, and the follow byte then has the ASCII-value for the letter that the diacritic is on. Only certain combinations of <b>lead</b> <b>byte</b> and follow byte are allowed, and there are some exceptions to the <b>lead</b> <b>byte</b> interpretation for some follow bytes. However, that no combining characters at all are encoded in ISO/IEC 6937. But one can represent some free-standing diacritics, often by letting the follow byte have the code for ASCII space.|$|E
50|$|Certain {{variants}} of the Big5 character set, {{for example the}} HKSCS, use an expanded range for the <b>lead</b> <b>byte</b> including values in the 0x81 to 0xA0 range (similar to Shift JIS).|$|E
5000|$|In theory UTF-1 and UTF-8 could encode the {{original}} UCS-4 set with 31 bits up to [...] BOCU-1 and UTF-16 can encodethe modern Unicode set from [...] to [...] Excluding the thirteen protected code points encoded as single octets BOCU-1 can use [...] octets in multi-byte encodings. BOCU-1 needs at most four bytes {{consisting of a}} <b>lead</b> <b>byte</b> and one to three trail bytes. The trail bytes encode a remaining [...] "modulo 243" [...] (base 243) difference, the <b>lead</b> <b>byte</b> determines the number of trail bytes and an initial difference.Note that the reset byte [...] is not protected and can occur as trail byte.|$|E
50|$|The term DBCS {{traditionally}} {{refers to}} a character encoding where each graphic character is encoded in two bytes. The DBCS always has <b>lead</b> <b>bytes</b> with the most significant bit set (i.e., being greater than 7 bits), and is always paired up with a single-byte character-set (SBCS). Furthermore, for the practical reason of maintaining compatibility with unmodified, off-the-shelf software, the SBCS is associated with half-width characters and the DBCS with full-width characters.|$|R
25|$|Self-synchronization: The leading bytes and the {{continuation}} bytes {{do not share}} values (continuation bytes start with 10 while single bytes start with 0 and longer <b>lead</b> <b>bytes</b> start with 11). This means a search will not accidentally find the sequence for one character starting {{in the middle of}} another character. It also means the start of a character can be found from a random position by backing up at most 3 bytes to find the leading byte. An incorrect character will not be decoded if a stream starts mid-sequence, and a shorter sequence will never appear inside a longer one.|$|R
5000|$|Shift JIS {{is based}} on {{character}} sets defined within JIS standards JIS X 0201:1997 (for the single-byte characters) and JIS X 0208:1997 (for the double-byte characters). The <b>lead</b> <b>bytes</b> for the double-byte characters are [...] "shifted" [...] around the 64 halfwidth katakana characters in the single-byte range 0xA1 to 0xDF. The single-byte characters 0x00 to 0x7F match the ASCII encoding, except for a yen sign (U+00A5) at 0x5C and an overline (U+203E) at 0x7E {{in place of the}} ASCII character set's backslash and tilde respectively. The single-byte characters from 0xA1 to 0xDF map to the half-width katakana characters found in JIS X 0201.|$|R
5000|$|A little anomaly is that Latin Small Letter G with Cedilla is {{coded as}} if it were with an acute accent, that is, with a 0xC2 <b>lead</b> <b>byte,</b> since due to its {{descender}} interfering with a cedilla, the lowercase letter is usually with turned comma above: [...]|$|E
50|$|The {{reference}} to combining {{characters in the}} U+0300—U+036F range for the codes in the range 0xC1—0xCF below are only indicative of which “accent” is usually intended by that <b>lead</b> <b>byte.</b> ISO/IEC 6937 does not encode any combining characters whatsoever. Instead, there is an explicit list of precomposed characters that are encoded.|$|E
5000|$|An {{encoding}} {{related to}} EUC-CN is the [...] "748" [...] code {{used in the}} WITS typesetting system developed by Beijing's Founder Technology (now obsoleted by its newer FITS typesetting system). The 748 code contains all of GB2312, but is not ISO 2022 - compliant and therefore not a true EUC code. (It uses an 8-bit <b>lead</b> <b>byte</b> but distinguishes between a second byte with its most significant bit set and one with its most significant bit cleared, and is therefore more similar in structure to Big5 and other non - ISO 2022 - compliant DBCS encoding systems.) The non-GB2312 portion of the 748 code contains traditional and Hong Kong characters and other glyphs used in newspaper typesetting.|$|E
5000|$|Self-synchronization: The leading bytes and the {{continuation}} bytes {{do not share}} values (continuation bytes start with [...] while single bytes start with [...] and longer <b>lead</b> <b>bytes</b> start with [...] ). This means a search will not accidentally find the sequence for one character starting {{in the middle of}} another character. It also means the start of a character can be found from a random position by backing up at most 3 bytes to find the leading byte. An incorrect character will not be decoded if a stream starts mid-sequence, and a shorter sequence will never appear inside a longer one.|$|R
5000|$|Extending the {{outbound}} phase so that {{it begins}} and ends with 8 active <b>bytes</b> <b>leads</b> to a near-collision in 52 bytes on Whirlpool reduced to 7.5 rounds with a complexity of 2192.|$|R
5000|$|... is the bitwise {{complement}} of x. This {{means that the}} work factor for a brute force attack is reduced {{by a factor of}} 2. Eli Biham also noticed that changing a full byte in all the key and data <b>bytes</b> <b>leads</b> to another complementation property. This reduces the work factor by 28.|$|R
30|$|Previous work provide evidences {{that it is}} {{possible}} to achieve high byte hit rate when caching BitTorrent traffic [2, 3, 26]. Ager et al. examined the effect of a cache with infinite size on a trace of user behavior in an ISP and suggest that caching BitTorrent traffic can yield high byte hit rates [2, 3]. They also find that the performance of a cache improves with the number of clients using it. Likewise, Karagiannis et al. employ a cache with infinite storage on a different trace, and comment on the cacheability of this traffic, reporting that such a cache can <b>lead</b> to a <b>byte</b> hit rate higher than 0.9 [26]. Our work complements these efforts by (i) going one step further and examining how cache size and object replacement policies affect cache performance, and (ii) performing our analyses on multiple traces of BitTorrent usage that include different types of content and user bases. To the best of our knowledge, this is the first study that focuses on analyzing BitTorrent caching design considering finite cache size and object replacement policies that leverages a wide range of traffic characteristics.|$|R
40|$|In {{wireless}} {{networks that}} operate in those bands where spectrum sharing occurs across {{a variety of}} wireless technologies, such as the license-free Industrial Scientific and Medical (ISM) bands, mitigating interference becomes challenging. Addressing interference is an important aspect for the design and development of solutions intended to satisfy the demands of applications requiring QoS guarantees. In this paper, we investigate dynamic radio resource adaptation techniques based on instantaneous spectrum usage. Using a novel metric to quantify the spectrum usage, we address packet size and error correction code overhead optimisations. On one hand, large payloads lead to energy and throughput gains due to the amortisation of the transmission overheads, but on the other hand, larger payloads imply larger resource wastage in the event of packet collisions. Using real-world data, we found that payload size inthe neighbourhood of 100 <b>bytes</b> <b>leads</b> to near-optimal performance in general in the IEEE 802. 15. 4 networks. Our data also shows that for very high interference scenarios, erasure codes capable of correcting 10 % of the packet payload can provide an equivalent Signal to Interference plus Noise Ratio (SINR) gain of 25 dB with probability greater than 0. 6. This is significant for interferencemanagement and for increasing spatial re-use by employing lower transmission power. We show that erasure codes drastically improve energy-efficiency and throughput of low-power wireless links. In the heavy interference regime, even thoug...|$|R
40|$|Abstract—In {{wireless}} {{networks that}} operate in those bands where spectrum sharing occurs across {{a variety of}} wireless technologies, such as the license-free Industrial Scientific and Medical (ISM) bands, mitigating interference becomes challeng-ing. Addressing interference is an important aspect for the design and development of solutions intended to satisfy the demands of applications requiring QoS guarantees. In this paper, we investigate dynamic radio resource adaptation techniques based on instantaneous spectrum usage. Using a novel metric to quantify the spectrum usage, we address packet size and error correc-tion code overhead optimisations. On one hand, large payloads lead to energy and throughput gains due to the amortisation of the transmission overheads, but on the other hand, larger payloads imply larger resource wastage in the event of packet collisions. Using real-world data, we found that payload size in the neighbourhood of 100 <b>bytes</b> <b>leads</b> to near-optimal performance in general in the IEEE 802. 15. 4 networks. Our data also shows that for very high interference scenarios, erasure codes capable of correcting 10 % of the packet payload can provide an equivalent Signal to Interference plus Noise Ratio (SINR) gain of 25 dB with probability greater than 0. 6. This is significant for interference management and for increasing spatial re-use by employing lower transmission power. We show that erasure codes drastically improve energy-efficiency and throughput of low-power wireless links. In the heavy interference regime, even though interference doubles the energy-per-usable-bit cost, erasure codes remain cost-effective for very large payload sizes, up-to 1500 bytes. Finally, we discuss interference-dependent dynamic adjustment of the correction capacity of erasure codes...|$|R
40|$|The 3 GPP Multimedia Broadcast and Multicast Service (MBMS) {{provides}} new bearer {{services and}} procedures for efficient transmissions to large user groups. When the group is large, MBMS distributes content by using broadcast on the air-interface. This thesis evaluates the use of MBMS for reliable file distribution services. One important requirement for file distribution is that the files contain no transmission errors. The MBMS file distribution process is subdivided into two phases in this thesis: During the first phase, the radio access network sends the IP packets in each cell either using one broadcast channel or several ptp channels depending {{on the number of}} receivers. During the second phase, the file repair service is executed when needed. The file repair service uses either HSPA bearers or MBMS bearers. It is mandatory when minimizing the needed resources for reliable file transmission. In order to understand the transmission characteristics of the first phase, we analyze the packet transmission over the MBMS traffic channel (MTCH). The use of shorter IP packets leads to a lower IP packet error probability on the MTCH. When using shorter IP packets, a larger share of bits is spent on packet headers. To evaluate the information throughput over MTCH, we define the goodput as the fraction between received information bits and sent data bits. IP packets smaller than 500 <b>Byte</b> <b>lead</b> in case of block error rates larger than 10 % to a higher goodput. We evaluate different optimization targets for MBMS file delivery. The most important evaluation target is to balance both transmission phases. The resource usage for the MBMS transmission is balanced with the resource needs for the file repair in order to increase the system efficiency of the file distribution of a certain size to all receivers. It is possible to trade the transmit power with the amount of application layer FEC redundancy at same load for the file repair service. The Raptor FEC is used for MBMS. Additional FEC redundancy increases the needed transmission energy, since the system resources are used for a longer time. The point-to-point file repair uses unicast HTTP connections and spreads the repair requests in a time window. The receivers draw randomly a start time out of a given wait-time window. The link between the file repair server and the system limits significantly the serving time and may even lead to an under utilization of the radio resources. The PTP file repair is well dimensioned when the radio links of all active file repair receivers and the link to the file repair server are just fully utilized. The smallest file repair service duration takes approximately 1. 2 times the Sequential Delivery Time of all missing data over the link between the file repair server and the system...|$|R

