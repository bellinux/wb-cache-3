37|204|Public
25|$|Bugs usually appear {{when the}} {{programmer}} makes a <b>logic</b> <b>error.</b> Various innovations in programming style and defensive programming {{are designed to}} make these bugs less likely, or easier to spot. Some typos, especially of symbols or logical/mathematical operators, allow the program to operate incorrectly, while others such as a missing symbol or misspelled name may prevent the program from operating. Compiled languages can reveal some typos when the source code is compiled.|$|E
50|$|In {{computer}} programming, a <b>logic</b> <b>error</b> is a bug in {{a program}} that causes it to operate incorrectly, but not to terminate abnormally (or crash). A <b>logic</b> <b>error</b> produces unintended or undesired output or other behavior, although it may not immediately be recognized as such.|$|E
50|$|Logic errors {{occur in}} both {{compiled}} and interpreted languages. Unlike a {{program with a}} syntax error, a program with a <b>logic</b> <b>error</b> is a valid program in the language, though it does not behave as intended. The only clue {{to the existence of}} logic errors is the production of wrong solutions.|$|E
50|$|Perform a risk based {{analysis}} to identify spreadsheet <b>logic</b> <b>errors.</b> Automated tools exist for this purpose.|$|R
40|$|<b>Logic</b> soft <b>errors</b> are {{radiation}} induced transient {{errors in}} sequential elements (flip-flops and latches) and combinational logic. Robust enterprise platforms in sub- 65 nm technologies require designs with built-in <b>logic</b> soft <b>error</b> protection. Effective <b>logic</b> soft <b>error</b> protection requires {{solutions to the}} following three problems: (1) Accurate soft error rate estimation for combinational logic networks; (2) Automated estimation of system effects of <b>logic</b> soft <b>errors,</b> and identification of regions in a design that must be protected; and, (3) New cost-effective techniques for <b>logic</b> soft <b>error</b> protection, because classical fault-tolerance techniques are very expensive...|$|R
5000|$|<b>Logic</b> <b>errors</b> {{originating}} in the semantics of different types. For instance, inches and millimeters may both be stored as integers, but should not be substituted for each other or added. A type system can enforce {{two different types of}} integer for them.|$|R
5000|$|This example {{function}} in C {{to calculate the}} average of two numbers contains a <b>logic</b> <b>error.</b> It is missing parentheses in the calculation, so it compiles and runs but does not give the expected answer due to operator precedence (division is evaluated before addition).float average(int a, int b){ return a + b / 2; /* should be (a + b) / 2 */} ...|$|E
50|$|Bugs usually appear {{when the}} {{programmer}} makes a <b>logic</b> <b>error.</b> Various innovations in programming style and defensive programming {{are designed to}} make these bugs less likely, or easier to spot. Some typos, especially of symbols or logical/mathematical operators, allow the program to operate incorrectly, while others such as a missing symbol or misspelled name may prevent the program from operating. Compiled languages can reveal some typos when the source code is compiled.|$|E
5000|$|Early {{production}} TI-30 units (c. 1976) {{contained a}} <b>logic</b> <b>error</b> in their calculation of inverse tangents. On these early models, pressing [...] "0 INV TAN" [...] {{would cause the}} calculator to go into an infinite loop until it was powered off with the OFF button. The [...] "0" [...] had {{to be pressed on}} the keyboard; the calculator produced a correct answer if the [...] "0" [...] {{was the result of a}} previous calculation.|$|E
50|$|Reliability: {{how often}} {{the results of a}} program are correct. This depends on {{conceptual}} correctness of algorithms, and minimization of programming mistakes, such as mistakes in resource management (e.g., buffer overflows and race conditions) and <b>logic</b> <b>errors</b> (such as division by zero or off-by-one errors).|$|R
40|$|Analyzing the executions of a buggy {{program is}} {{essentially}} a data mining process: Tracing the data generated during program executions may disclose important patterns and outliers that could eventually reveal the location of software errors. In this paper, we investigate program <b>logic</b> <b>errors,</b> which rarely incur memory access violations but generate incorrect outputs. We show that through mining program control flow abnormality, we could isolate many <b>logic</b> <b>errors</b> without knowing the program semantics. In order to detect the control abnormality, we propose a hypothesis testing-like approach that statistically contrasts the evaluation probability of condition statements between correct and incorrect executions. Based on this contrast, we develop two algorithms that effectively rank functions {{with respect to their}} likelihood of containing the hidden error. We evaluated these two algorithms on a set of standard test programs, and the result clearly indicates their effectiveness...|$|R
40|$|In the {{emerging}} nano-scale era, electronic devices are increasing susceptible to <b>logic</b> <b>errors</b> that can degrade the reliability. Fault-Tolerant solution {{needs to be}} tolerant of internal errors. Proposed embedded fault-masking solution: LDPC code Referred to as LDPC Stochastic Decoding (LSD) Method Resilient against internal transient gate errors Asynchronous Implementation of the iterative decoder I. Muller C-element [1] References...|$|R
50|$|A hang may be {{temporary}} if {{caused by a}} condition that resolves itself, such as slow hardware, {{or it may be}} permanent and require manual intervention, {{as in the case of}} a hardware or software <b>logic</b> <b>error.</b> Many modern operating systems provide the user with a means to forcibly terminate a hung program without rebooting or logging out; some operating systems, such as those designed for mobile devices, may even do this automatically. In more severe hangs affecting the whole system, the only solution might be to reboot the machine, usually by power cycling with an on/off or reset button.|$|E
5000|$|In the C {{programming}} language, each thread {{has its own}} stack. However, {{a static}} variable is not kept on the stack; all threads share simultaneous access to it. If multiple threads overlap while running the same function, {{it is possible that}} a static variable might be changed by one thread while another is midway through checking it. This difficult-to-diagnose <b>logic</b> <b>error,</b> which may compile and run properly most of the time, is called a race condition. One common way to avoid this is to use another shared variable as a [...] "lock" [...] or [...] "mutex" [...] (from mutual exclusion).|$|E
50|$|Mode B is {{the second}} mode, which devolved from a <b>logic</b> <b>error</b> in an early iambic keyer. In mode B, dots and dashes are {{produced}} as long as both paddles are depressed. When the paddles are released, the keying continues by sending one more element, i.e., a dot if the paddles were released during a dash, or a dash if the paddles were released during a dot. Users accustomed to one mode usually {{find it difficult to}} use the other, so all competently designed keyers allow for selection of the desired keyer mode. If forced to use a keyer with an unaccustomed mode, the user must revert to single paddle mode in which both paddles are never depressed simultaneously.|$|E
40|$|Auditors may review {{information}} systems and application documentation {{for a variety}} of reasons (Wilkinson et al., 2000; Weber, 1999). Internal and external auditors may review documentation for evidence of errors or irregularities. For example, internal auditors may review internally developed application documentation for syntax <b>errors,</b> <b>logic</b> <b>errors,</b> and fraudulent code. External auditors sometimes carry out the same type of review of clien...|$|R
40|$|Concolic {{testing is}} a {{technique}} that combines concrete and symbolic execution in order to generate inputs that explore different execution paths leading to better testing coverage. Concolic testing tools can find runtime errors fully automatically using available type specifications. The type specifications in a function define the type of each input. However, most specification languages are never expressive enough, {{which can lead to}} runtime errors caused by malformed inputs (i. e. irrelevant <b>errors).</b> Moreover, <b>logic</b> <b>errors</b> causing a program to operate incorrectly without crashing cannot be reported automatically. A universal methodology for any programming language is proposed. Preconditions force the concolic execution to generate well formed inputs before testing a function. On the other hand, postconditions lead to a runtime error when a program operates incorrectly, helping to find <b>logic</b> <b>errors.</b> The results obtained using the concolic testing tool CutEr, in the functional programming language Erlang, show how a program is only tested using well formed inputs specially generated to try to violate the defined postconditions...|$|R
25|$|Sometimes, a bug {{is not an}} {{isolated}} flaw, but represents an error of thinking or planning {{on the part of the}} programmer. Such <b>logic</b> <b>errors</b> require a section of the program to be overhauled or rewritten. As a part of code review, stepping through the code and imagining or transcribing the execution process may often find errors without ever reproducing the bug as such.|$|R
5000|$|An off-by-one error (OBOE), also {{commonly}} known as an OBOB (off-by-one bug), OB1 error, or [...] "that extra inch you didn't really want", is a <b>logic</b> <b>error</b> involving the discrete equivalent of a boundary condition. It often occurs in computer programming when an iterative loop iterates one time too many or too few. This problem could arise when a programmer makes mistakes such as using [...] "is {{less than or equal}} to" [...] where [...] "is less than" [...] should have been used in a comparison, or fails to take into account that a sequence starts at zero rather than one (as with array indices in many languages). This can also occur in a mathematical context.|$|E
5000|$|Rivest later {{acknowledged}} this <b>logic</b> <b>error</b> in {{the original}} concept, and revised the RFC schema in his final publication to require tearing off each row (each yes/no) individually (destroying the correlation of the questions) and also having unique tracking numbers on each mark on each ballot (not just one ID for each column ballot). While this did restore the unbreakable aspect of the scheme, the proliferation of receipts (one per row) and chopped ballots rendered the mechanics of processing the votes or for a voter reviewing a receipt, significantly complex, thus undermining its intended simplicity. [...] An electronic version addressing the paper-ballot implementation and usability problems was proposed by Costa, et al.|$|E
50|$|The lack of Congress, the {{arbitrary}} {{nature of the}} Emperor {{and the absence of}} solutions to the serious problems that the country was facing increased conspiracies to change the imperial system. Antonio López de Santa Anna proclaimed the Plan of Casa Mata which was later joined by Vicente Guerrero and Nicolás Bravo. Iturbide then was forced to reestablish the Congress and in a vain attempt to save the order and keep the situation favorable to his supporters, he abdicated to the crown of the Empire on March 19, 1823. However, the Congress nullified the designation of Iturbide and therefore the recognition of the abdication and made seem the coronation of Iturbide as a <b>logic</b> <b>error</b> in the consummation of Independence.|$|E
5000|$|Some program {{debugging}} {{can only}} be performed (or is more efficient or accurate when performed) at runtime. <b>Logic</b> <b>errors</b> and array bounds checking are examples. For this reason, some programming bugs are not discovered until the program is tested in a production environment with real data, despite sophisticated compile-time checking and pre-release testing. In this case, the end user may encounter a runtime error message.|$|R
5000|$|When two {{identical}} identifiers are {{in context}} {{at the same}} time, referring to different entities, one says that name masking is occurring, where the higher-priority name (usually innermost) is [...] "masking" [...] the lower-priority name. At the level of variables, {{this is known as}} variable shadowing. Due to the potential for <b>logic</b> <b>errors</b> from masking, some languages disallow or discourage masking, raising an error or warning at compile time or run time.|$|R
40|$|A {{simulation}} {{study is}} described which predicts the susceptibility of an advanced control system to electrical transients resulting in <b>logic</b> <b>errors,</b> latched errors, error propagation, and digital upset. The system {{is based on}} a custom-designed microprocessor and it incorporates fault-tolerant techniques. The system under test and the method to perform the transient injection experiment are described. Results for 2100 transient injections are analyzed and classified according to charge level, type of error, and location of injection...|$|R
5000|$|Ivo {{combines}} {{parts of}} the current Amazo with human ova and DNA to create the android's [...] "son". Awakened prematurely by an earthquake, the junior version of Amazo believes itself to be a philosophy student called Frank Halloran and dates a girl called Sara. Amazo reveals the truth to his progeny, who attempts to resist his programming by becoming a hero called [...] "Kid Amazo". Slowly becoming insane, Kid Amazo confronts Ivo and discovers Sara is Ivo's daughter and was placed to monitor the android. Batman deduces Kid Amazo has both the powers and the personalities of the JLA, and, during a battle with the League, creates dissension in the team that the android mimics, causing an internal <b>logic</b> <b>error</b> that destroys it.|$|E
40|$|The ACL {{model is}} unable to make correct access {{decisions}} for interactions involving more than two principals, since required information is not retained across message sends. Though this deficiency has long been documented in the published literature, it is not widely understood. This <b>logic</b> <b>error</b> in the ACL model is exploited by both the clickjacking and Cross-Site Request Forgery attacks that affect many Web applications. 1...|$|E
40|$|A {{level shifter}} circuit capable of {{handling}} extremely low voltage input. The circuit has a distinctive current generation scheme using a <b>logic</b> <b>error</b> correction circuit that work by detecting the input and output level and it dissipate operating current only when the input signal changes. This proposed circuit shows better performance in term of power consumption. Output level of 3 V has been obtained with input pulse of 0. 4 V, 1 kHz. Here we discuss the comparison of the two various level shifter using Logical error correction circuit...|$|E
40|$|Currently PHP is {{the most}} widely used web {{programming}} language for websites [1]; however {{there seems to be a}} limited availability of debugging tools that a novice programmer can use. In this work, we propose a framework to identify <b>logic</b> <b>errors</b> committed by novice PHP programmers and prototype application to automate the process of detecting such errors. The aim is to develop a tool that may be used to assist novice programmers in their learning process, and contribute to computer science education researc...|$|R
50|$|Running a SoC {{design on}} FPGA {{prototype}} is a reliable {{way to ensure}} that it is functionally correct. This is compared to designers only relying on software simulations to verify that their hardware design is sound. About a third of all current SoC designs are fault-free during first silicon pass, with nearly half of all re-spins caused by functional <b>logic</b> <b>errors.</b> A single prototyping platform can provide verification for hardware, firmware, and application software design functionality before the first silicon pass.|$|R
5000|$|For example, some {{language}} {{features that}} can be performed only (or are more efficient or accurate) at runtime are implemented in the runtime environment and may be invoked via the runtime library API, e.g. some <b>logic</b> <b>errors,</b> array bounds checking, dynamic type checking, exception handling, and possibly debugging functionality. For this reason, some programming bugs are not discovered until the program is tested in a [...] "live" [...] environment with real data, despite sophisticated compile-time checking and testing performed during development.|$|R
40|$|Debugging on {{computer}} {{program is a}} complex cognitive activity. Although it is complex, it’s {{still one of the}} popular issues in computer programming task. It is a difficult task, which is to understand what the error is and how to solve such error? In computer programming the difficulty is to understand the Object-Oriented programming concept together with the programming logic. If the programming logic is incorrect, the program codes will have such error named as <b>logic</b> <b>error</b> and can caused highly maintenance cost. <b>Logic</b> <b>error</b> is a bug in a program that causes it to operate incorrectly, without terminating or crashing the program. It will produce unintended output or other behavior than what we are expecting. Method that use to develop a propose model Object Oriented Debugger is Unified Modeling Language (UML). It is the best choice model and suitable to design the Object Oriented Debugger which will be developed in an object oriented programming environment. The model will provide an ability to capture the characteristics of a system by using notations in the process of designing and implementing the system. The model of Object Oriented Debugger has been successfully implemented. This model has been developed using Unified Approach methodology, which consists of two methods such as Object-Oriented Analysis (OOA) and Object-Oriented Design (OOD). The model developed is to capture the structure and behavior of the Object Oriente...|$|E
40|$|A 5 th {{generation}} SPARC 64 processor is fabricated in 130 nm SOI CMOS {{process with}} 8 layers of Cu metallization. It runs at 1. 3 GHz with 34. 7 W power dissipation in the laboratory. The chip contains over 190 M transistors with 19 M in logic circuits. The chip size is 18. 14 mm x 15. 99 mm. The error detection and recovery mechanism is implemented for execution units and data path logic circuits {{in addition to}} on-chip arrays to detect and recover from data <b>logic</b> <b>error.</b> This processor is developed by using mostly in-house CAD tools...|$|E
40|$|International audienceSimultaneous {{switching}} noise (SSN) is {{an important}} issue for the design and test and actual ICs. In particular, SSN that originates from the internal logic circuitry becomes a serious problem as the speed and density of the internal circuit increase. In this paper, an on-chip monitor is proposed to detect potential logic errors in digital circuits due to the presence of SSN. This monitor checks the variations of power/ground lines at the interface between noncoherent logic blocks in order to warn that a <b>logic</b> <b>error</b> is likely to occur. This information can then be used for any scheme that takes corrective actions...|$|E
40|$|Graduation date: 1988 Debugging, {{the process}} of {{locating}} and correcting errors in a computer program, is a common programming task that is not well understood. Of the several debugging studies reported in the literature, most compared the performance differences between expert and novice programmers by measuring their debug time {{and the number of}} errors found and corrected; a few provided information about their debugging process. This dissertation investigates the on-line debugging process of expert and novice student programmers by means of protocol analysis. This dissertation describes three debugging experimentations that were conducted to understand the debugging process and were used as the basis for a cognitive model of subjects' on-line debugging behavior. In the three experiments subjects debugged a defective Pascal program seeded with several errors on a Apple Macintosh computer. Some of the major results obtained through this research work are summarized below: Experts employed a comprehension approach in which they first attempted to understand the program and then used this knowledge for finding the bugs. Intermediates and novices employed an isolation approach in which they immediately attempted to identify candidate bug locations by searching the output for clues, recalling similar bugs, and testing program states. Experts corrected multiple errors before verifying the corrections while novices corrected and verified single errors. Novices corrected the semantic errors first and then the <b>logic</b> <b>errors</b> while experts corrected both semantic and <b>logic</b> <b>errors</b> at the same time. Experts were more efficient in correcting all of the errors, modified fewer statements, and did not introduce more errors. Novices did not correct all of the errors, made very extensive modifications and introduced many new errors. Program understanding {{played a key role in}} locating and correcting <b>logic</b> <b>errors.</b> Experts' superiority in locating and correcting errors was due to their better (a) overall understanding of the program, (b) ability to identify program segment containing the error, and (c) ability to select a correct error hypothesis...|$|R
5000|$|EULB Extension Program - A {{program that}} simulates a 2004-era iBook <b>logic</b> board <b>error</b> {{that results in}} screen {{flashing}} on Macs that don't have that issue.|$|R
5000|$|In {{addition}} to the aforementioned alarm clock interrupt bug, many CIAs exhibited a defect in which the part would fail to generate a timer B hardware interrupt if the interrupt control register (ICR) was read one or two clock cycles before {{the time when the}} interrupt should have actually occurred. This defect, as well as <b>logic</b> <b>errors</b> in the Commodore provided (8 bit [...] ) operating system, caused frequent pseudo-RS-232 errors in the Commodore 64 and Commodore 128 computers when running at higher baud rates.|$|R
