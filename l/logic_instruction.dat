11|61|Public
5000|$|It is {{designed}} to run as a co-processor with another controller (such as a CPU or an Tensilica/ARM core). It was developed as the culmination of DARPA's Analog Logic program [...] (although the GP5 chip architecture is digital, it could contemplate an entirely analog implementation of its Bayesian <b>logic</b> <b>instruction</b> set).|$|E
50|$|Around 1955, {{computer}} scientist Edmund Berkeley designed the computational toy Geniac, and in 1958 a similar toy called Brainiac. The rotary switch construction sets used combinational logic {{but had no}} memory and could not solve problems using sequential <b>logic.</b> <b>Instruction</b> booklets gave series of instructions for creating complex machines which could solve specific Boolean equations. Specific machines could play simple games like tic-tac-toe, or solve arithmetic puzzles, but the output resulted directly from the input given.|$|E
50|$|In CPUs with flag registers, {{an earlier}} {{instruction}} sets {{a condition in}} the flag register. The earlier instruction may be arithmetic, or a <b>logic</b> <b>instruction.</b> It is often close to the branch, though not necessarily the instruction immediately before the branch. The stored condition is then used in a branch such as jump if overflow-flag set. This temporary information is often stored in a flag register but may also be located elsewhere. A flag register design is simple in slower, simple computers. In fast computers a flag register can place a bottleneck on speed, because instructions that could otherwise operate in parallel (in several execution units) need to set the flag bits in a particular sequence.|$|E
50|$|In {{more recent}} times, the term bit-slicing was re-coined by Matthew Kwan {{to refer to}} the {{technique}} of using a general purpose CPU to implement multiple parallel simple virtual machines using general <b>logic</b> <b>instructions</b> to perform Single Instruction Multiple Data (SIMD) operations. This technique is also known as SIMD Within A Register (SWAR).|$|R
50|$|The load store {{units are}} simple {{arithmetic}} logic units {{used to calculate}} virtual addresses for memory access. They are also capable of executing simple arithmetic and <b>logic</b> <b>instructions.</b> The Alpha 21264 <b>instruction</b> issue <b>logic</b> utilized this capability, issuing instructions to these units when they were available for use (not performing address arithmetic).|$|R
5000|$|By using PLC simulation, PLC programmers {{have the}} freedom to try all the [...] "what-if" [...] {{scenarios}} changing ladder <b>logic</b> <b>instructions</b> and programs, then re-running the simulation to see how changes affect the PLC's operation and performance. This type of testing is often not feasible using hardwired operating PLCs that control processes often worth hundreds of thousands - or millions of dollars.|$|R
50|$|Digital {{organisms in}} Avida are {{self-replicating}} computer programs with a genome composed of assembly-like instructions. The genetic programing language in Avida contains instructions for manipulating values in registers and stacks {{as well as}} for control flow and mathematical operations. Each digital organism contains virtual hardware on which its genome is executed. To reproduce, digital organisms must copy their genome instruction by instruction into a new region of memory through a potentially noisy channel that may lead to errors (i.e., mutations). While most mutations are detrimental, mutants will occasionally have higher fitness than their parents, thereby providing the basis for natural selection with all of the necessary components for Darwinian evolution. Digital organisms can acquire random binary numbers from the environment and are able to manipulate them using their genetic instructions, including the <b>logic</b> <b>instruction</b> NAND. With only this instruction, digital organisms can compute any other task by stringing together various operations because NAND is a universal logic function. If the output of processing random numbers from the environment corresponds to the result of a particular logic task, then that task is incorporated into the set of tasks the organism performs, which in turn, defines part of its phenotype.|$|E
40|$|People {{manifest}} formally incorrect either-or, polarizing re-sponse tendencies {{when asked}} to negate quantified state-ments. Our study focuses on students ’ error patterns when ne-gating quantified sentences, which are the single most impor-tant cause for their difficulties with indirect proofs and proofs by contradiction. We found that, contrary to our expectations, the effect of content is relatively small on their negation be-havior; that of the four quantifier categories used, students have {{by far the most}} difficulties in negating universally quan-tified sentences; and that the effect of formal <b>logic</b> <b>instruction</b> wears off relatively fast. The significance of our study reaches beyond the classroom: logically literate reasoners are less prone to be manipulated by either-or rhetoric of politicians, and are more conscious of their own limiting beliefs...|$|E
40|$|Fuzzy Logic {{implementation}} {{is becoming}} increasingly important, and finding applications in diverse areas of current interest, such as control, pattern recognition, robotics, and other decision making applications. Fuzzy decision process offer a significant advantage over crisp decision process which {{is the ability to}} process different levels of truth instead of only 1 or 0 levels. Fuzzy Logic does not require precise inputs, it is inherently robust, and can process any reasonable number of inputs but system complexity increases rapidly with more inputs and outputs. Distributed processors would probably be easier to implement. Simple, plain-language IF X AND Y THEN Z rules are used to describe the desired system response in terms of linguistic variables rather than mathematical formulas. The number of these is dependent on the number of inputs, outputs, and the designer 2 ̆ 7 s control response goals. The new Motorola 68 HC 12 MCU has an embedded fuzzy <b>logic</b> <b>instruction</b> set. Using this instruction set, we can implement complex fuzzy logic systems using only a few hundred bytes of ROM that cycle compute in less than a millisecond. Considering the fact that the fuzzy <b>logic</b> <b>instruction</b> set of the 68 HC 12, enables the use of fuzzy logic in mass-market high-speed applications, such as car engine control, anti-skid brakes, traction control, inter-vehicle dynamics control, hard disk drive control, servo motor control, and cellular phones. This thesis deals with the design of Automotive Airbag Control System a using Fuzzy Logic based decision structure and implementation using the 68 HC 12 microcontroller. Dept. of Electrical and Computer Engineering. Paper copy at Leddy Library: Theses 2 ̆ 6 Major Papers - Basement, West Bldg. / Call Number: Thesis 1999. M 52. Source: Masters Abstracts International, Volume: 39 - 02, page: 0566. Adviser: J. J. Soltis. Thesis (M. A. Sc.) [...] University of Windsor (Canada), 2000...|$|E
50|$|Most Branch {{instructions}} take conditional effect {{based on}} the state of the condition codes in the PSW. A Branch instruction was typically preceded by a two-operand CMP (compare) or BIT (bit test) or a one-operand TST (test) <b>instruction.</b> Arithmetic and <b>logic</b> <b>instructions</b> also set the condition codes. In contrast to Intel processors in the x86 architecture, MOV instructions set them too, so a Branch instruction could be used to branch depending on whether the value moved was zero or negative.|$|R
40|$|The minor {{loop and}} minor loop support modules which {{maintain}} correct vehicle attitude control by generating vehicle attitude error signals were verified. The logic is checked during boost and orbit (unusual timing situations necessitate the additional orbit checks) and the constants used by these modules checked at every {{point during the}} flight. Since the same <b>logic</b> <b>instructions</b> are used throughout the flight with only the constants changing, verification of the logic at two points and the constants at all points verify the logic throughout the flight...|$|R
50|$|The E-Box {{consists}} of a register file, a 32-bit program counter, a constant generator, a shifter and an arithmetic logic unit (ALU). The register file contains 31 single-read-port/single-write-port registers and eight dual-read-port/single-write port registers. The ALU is 32-bit and is capable of executing addition, subtraction and <b>logic</b> <b>instructions.</b> Although the E-Box contains a dedicated shifter, the ALU also features a shifter, a less powerful one, {{for the purpose of}} executing integer multiply and divide instructions. The design of the register file permits these execution units to achieve higher performance by permitting more instances of simultaneous access to the registers.|$|R
40|$|This {{essay on}} the social history of <b>logic</b> <b>instruction</b> {{considers}} the programmatic writings of Carnap/Neurath, but especially in the widely read book by Lillian Lieber, Mits, Wits and Logic (1947), where Mits is {{the man in the}} street and Wits the woman in the street. In the ‘pre-Toulmin’ days it was seriously argued that the intense study of formal logic would create a more rational frame of mind and have many beneficial effects upon the social and political life. It arose from the conviction that most metaphysical conundrums, religious and political problems and even fanaticism had their root in the irrationality of ordinary discourse, which had to be replaced by the more logical ‘ideal language’ of Principia Mathematica. The enthusiastic promotion of formal logic occurred {{at a time when it}} was widely thought that minds could be ‘made over’, ‘reprogrammed’ by proper intervention. This stands in stark contrast to the motivation for teaching informal logic and critical thinking, as it becomes apparent in a 1981 exchange between Ralph Johnson and Gerald Massey in Teaching Philosophy. Most of this essay focuses on Lillian Lieber, an earnest and enthusiastic advocate of the cause of formal logic, and on the reasons for the widespread conviction that, for the sake of peace and social harmony, formal logic should, if possible, be taught to every man, woman and chil...|$|E
40|$|This study {{investigated}} {{the extent to which}} pro and antireligious individuals responded objectively and critically to religious and nonreligious material. Proreligious (n= 72) and antireligious (n= 72) individuals, as determined by Fullerton and Hunsberger’s (1982) Christian Orthodoxy Scale, were selected from 507 introductory psychology students. They judged the logical soundness of 30 syllogisms (10 proreligious, 10 antireligious, and 10 neutral) following a priming task (critical, religious, or neutral). Prior to the analysis of the syllogisms, half of the subjects were given logic training, while the other half did not receive any instruction in logic. Dependent variables included critical ability (i. e., the number of neutral syllogisms correctly answered), number of pro and antireligious syllogism answered correctly, and religious bias scores (the number of proreligious syllogisms marked sound plus number of antireligious syllogisms marked unsound). Results indicated that there was no substantial link between religiosity and logic analyses. There was some evidence that <b>logic</b> <b>instruction</b> did aid in improving subjects’ critical ability scores, and decreasing the effect of religious bias. Unexpectedly, the critical priming questionnaire was not related to improved performance on syllogistic judgements. There were indications that the religious priming questionnaire did bias subjects’ responses, but respondents receiving neutral questionnaire performed better than the other two priming conditions. It is suggested that the relationship between religious attitudes and logical syllogistic analysis is a complex interactive one, rather than a simple linear relationship...|$|E
40|$|The frontomedian cortex (FMC) {{has been}} shown to be {{important}} for coherence processes in language comprehension, i. e., for establishing the pragmatic connection between successively presented sentences. The same brain region has a role during theory-of-mind processes, i. e., during the attribution of other people's actions to their motivations, beliefs, or emotions. In this study, we used event-related functional magnetic resonance imaging at 3 T to disentangle the relative contributions of the FMC to theory-of-mind (ToM) and coherence processes, respectively. The BOLD response of nine participants was recorded while they listened to pragmatically coherent or unrelated sentence pairs. Using a <b>logic</b> <b>instruction</b> for inanimate sentence pairs, ToM processing was discouraged during the first part of the experiment. Using explicit ToM instructions for sentence pairs mentioning human protagonists, ToM processing was induced during the second part. In three of the resulting four conditions a significant increase in the BOLD response was observed in FMC: when ToM instructions were given, both coherent and incoherent trials elicited frontomedian activation, in replication of previous results showing involvement of the FMC during ToM tasks. When logic instructions were given, the coherent trials, but not the incoherent trials, activated the FMC. These results clearly show that the FMC plays a role in coherence processes even in the absence of concomitant ToM processes. The findings support the view of this cortex having a domain-independent functionality related to volitional aspects of the initiation and maintenance of nonautomatic cognitive processes...|$|E
50|$|There are ten 60-bit read {{registers}} and ten 60-bit write registers, {{each with}} an address register. Moving {{an address to}} an address register starts a small core memory read or write. Arithmetic and <b>logic</b> <b>instructions</b> have these registers as sources and destinations. The programmer or compiler tries to fetch data in time to be used and store data before more data needs the same register, {{but if it is}} not ready the processor goes into a wait state until it is. It also waits if one of the four floating-point arithmetic units is not ready when requested, but due to pipelining, this does not usually happen.|$|R
5000|$|The 3D {{interactive}} animations in PLCLogix allow programmers, electricians, engineering technicians, {{and engineers}} to test and troubleshoot ladder logic programs in a realistic simulated 3D environment, {{without worrying about}} incorrect I/O connections and programming errors {{that could result in}} damage to the equipment. Using simulation tools like PLCLogix, PLC programmers have the freedom to try all the [...] "what-if" [...] scenarios changing ladder <b>logic</b> <b>instructions</b> and programs, then re-running the simulation to see how changes affect the PLC's operation and performance. This type of testing is often not feasible using hardwired operating PLCs that control processes often worth hundreds of thousands - or millions of dollars.|$|R
5000|$|The {{instruction}} set is strongly orthogonal: all <b>logic</b> and arithmetic <b>instructions</b> can use all nine addressing modes: ...|$|R
40|$|From {{the past}} until today logic {{has always been}} {{affiliated}} with religious education in institutes of higher learning. In the history of Islamic thought, education in logic has at times held an important place in the curriculum, while at other times it has only been represented symbolically. Throughout the history of thought, religious sciences have not only possessed a hierarchical structure based on classification, but have also been institutionalized {{in order to protect}} the accumulation of the knowledge that has been attained. As a result, in order to function as a vehicle in the structuring of this knowledge, logic has become what is known as an introductory science. Over time, as a vehicle of religious sciences and an introductory science, logic has become a productive method by which different academic disciplines can attain information. Thus, until today in religious sciences education, logic has been used as a method both in the higher religious education provided in faculties of theology and in the madrasas which continue this education. In this paper, the education of logic that is given in faculties of theology, including how much of the curriculum is devoted to this subject, the quality of instruction, the integration of this subject with other lessons, the interest of students in this subject and whether or not the necessary productivity in <b>logic</b> <b>instruction</b> is being attained will be examined. In addition, to what extent logic can make new contributions to new thought and comprehension techniques for solving the theological problems of today will be investigated. An additional research question asked here is the extent to which students enrolled in theology faculties in formal and informal education, the very people who will later act as instructors in religious sciences, are aware of the importance of being familiar and skilled in “correct reasoning techniques”...|$|E
40|$|The overall {{objective}} of this thesis was to test the Default Interventionist (DI) account of belief-bias in human reasoning using the novel methodology introduced by Handley, Newstead & Trippas (2011). DI accounts focus on how our prior beliefs are the intuitive output that bias our reasoning process (Evans, 2006), whilst judgments based on logical validity require effortful processing. However, recent {{research has suggested that}} reasoning on the basis of beliefs may not be as fast and automatic as previous accounts claim. In order to investigate whether belief based judgments are resource demanding we instructed participants to reason on the basis of both the validity and believability of a conclusion whilst simultaneously engaging in a secondary task (Experiment 1 - 5). We used both a within and between subjects design (Experiment 5) examining both simple and complex arguments (Experiment 4 – 9). We also analysed the effect of incorporating additional instructional conditions (Experiment 7 – 9) and tested the relationships between various individual differences (ID) measures under belief and <b>logic</b> <b>instruction</b> (Experiment 4, 5, 7, 8, & 9). In line with Handley et al. ’s findings we found that belief based judgments were more prone to error and that the logical structure of a problem interfered with judging the believability of its conclusion, contrary to the DI account of reasoning. However, logical outputs sometimes took longer to complete and were more affected by random number generation (RNG) (Experiment 5). To reconcile these findings we examined the role of Working Memory (WM) and Inhibition in Experiments 7 – 9 and found, contrary to Experiment 5, belief judgments were more demanding of executive resources and correlated with ID measures of WM and inhibition. Given that belief based judgments resulted in more errors and were more impacted on by the validity of an argument the behavioural data does not fit with the DI account of reasoning. Consequently, we propose that there are two routes to a logical solution and present an alternative Parallel Competitive model to explain the data. We conjecture that when instructed to reason on the basis of belief an automatic logical output completes and provides the reasoner with an intuitive logical cue which requires inhibiting in order for the belief based response to be generated. This creates a Type 1 /Type 2 conflict, explaining the impact of logic on belief based judgments. When explicitly instructed to reason logically, it takes deliberate Type 2 processing to arrive at the logical solution. The engagement in Type 2 processing in order to produce an explicit logical output is impacted on by demanding secondary tasks (RNG) and any task that interferes with the integration of premise information (Experiments 8 and 9) leading to increased latencies. However the relatively simple nature of the problems means that accuracy is less affected. We conclude that the type of instructions provided along with the complexity of the problem and the inhibitory demands of the task all play key roles in determining the difficulty and time course of logical and belief based responses...|$|E
5000|$|... Number of {{the series}} (2 digits): The numbers {{of the series}} are {{assigned}} sequentially and have no further meaning. Devices in a series have some characteristic in common although it varies from one series to another which characteristic that is (e.g. logic family for <b>logic</b> gates, <b>instruction</b> set for microprocessors).|$|R
5000|$|Statically-scheduled superscalar {{architectures}} execute {{instructions in}} the order presented; the hardware <b>logic</b> determines which <b>instructions</b> are ready and safe to dispatch on each clock cycle.|$|R
5000|$|Most {{processors}} {{include a}} number of separate [...] "subprocessors" [...] known as functional units that are tuned to operating on {{a particular type of}} data. For instance, a modern CPU typically has two or three functional units dedicated to processing integer data and <b>logic</b> <b>instructions,</b> known as ALUs, while other units handle floating-point numbers, the FPUs, or multimedia data, SIMD. MAJC instead used a single multi-purpose functional unit which could process any sort of data. In theory this approach meant that processing any one type of data would take longer, perhaps much longer, than processing the same data in a unit dedicated to that type of data. But on the other hand, these general-purpose units also meant that you did not end up with large portions of the CPU being unused because the program just happened to be doing lots of (for example) floating point calculations at that particular point in time.|$|R
50|$|Glue semantics, {{or simply}} Glue (Dalrymple et al. 1993; Dalrymple 1999, 2001), is a {{linguistic}} theory of semantic composition and the syntax-semantics interface which assumes that meaning composition is constrained {{by a set}} of instructions stated within a formal logic (linear <b>logic).</b> These <b>instructions,</b> called meaning constructors, state how the meanings of the parts of a sentence can be combined to provide the meaning of the sentence.|$|R
5000|$|Multi-cycle Instructions (Many cycle latency). Integer {{multiply}} {{and divide}} and all floating-point operations. During the execute stage, the operands to these operations were fed to the multi-cycle multiply/divide unit. The {{rest of the}} pipeline was free to continue execution while the multiply/divide unit did its work. To avoid complicating the writeback stage and issue <b>logic,</b> multicycle <b>instruction</b> wrote their results to a separate set of registers.|$|R
5000|$|Dynamically-scheduled superscalar {{architectures}} execute {{instructions in}} {{an order that}} gives the same result as the order presented; the hardware <b>logic</b> determines which <b>instructions</b> are ready and safe to dispatch on each clock cycle.|$|R
40|$|Topics covered are: Micro{{computer}}s, {{the basic}} of computer logic, register structure, clocked sequential <b>logic,</b> microcomputer structure, <b>instruction</b> sequencing, the arithmetic logic unit, addressing and general registers, instruction sets, input/output system, software and architectural features applicable {{to a wide}} variety of microcomputer...|$|R
40|$|In {{this present}} study {{includes}} the Very Large Scale Integration (VLSI) system implementation of 200 MHz, 8 -bit, 90 nm Complementary Metal Oxide Semiconductor (CMOS) Arithmetic and Logic Unit (ALU) processor control with logic gate design style and 0. 12 µm six metal 90 nm CMOS fabrication technology. The system blocks and the behaviour are defined and the logical design is implemented in gate {{level in the}} design phase. Then, the logic circuits are simulated and the subunits are converted in to 90 nm CMOS layout. Finally, in order to construct the VLSI system these units are placed in the floor plan and simulated with analog and digital, logic and switch level simulators. The results of the simulations indicates that the VLSI system can control different instructions which can divided into sub groups: transfer <b>instructions,</b> arithmetic and <b>logic</b> <b>instructions,</b> rotate and shift instructions, branch instructions, input/output instructions, control instructions. The data bus {{of the system is}} 16 -bit. It runs at 200 MHz, and operating power is 1. 2 V. In this paper, the parametric analysis of the system, the design steps and obtained results are explained...|$|R
40|$|A digital <b>logic</b> {{controller}} provides <b>instruction</b> execution {{times on}} the order of 50 nanoseconds and employing read-only memory outputting instructions to a pipeline register, a portion of each instruction providing a status-select control signal and address signals for controlling selection of the next instruction from the read-only memory...|$|R
50|$|A minimal {{hypothetical}} microprocessor {{might only}} include an {{arithmetic logic unit}} (ALU) and a control logic section. The ALU performs operations such as addition, subtraction, and operations such as AND or OR. Each operation of the ALU sets one or more flags in a status register, which indicate {{the results of the}} last operation (zero value, negative number, overflow, or others). The control <b>logic</b> retrieves <b>instruction</b> codes from memory and initiates the sequence of operations required for the ALU to carry out the instruction. A single operation code might affect many individual data paths, registers, and other elements of the processor.|$|R
40|$|Reconfigurable {{instruction}} set processors {{have the capability}} to adapt their {{instruction set}}s to the application being executed through a reconfiguration in their hardware. Through this adaptation, they are expected to achieve a great improvement in performance compared to fixed instruction set processors. In this paper, we discuss the different hardware aspects that have to be considered during the design of such a reconfigurable processor. The topics discussed include the coupling of the processor and the reconfigurable <b>logic,</b> configuration, <b>instruction</b> coding and scheduling, granularity, hardware cache and reconfigurability. A classification of current reconfigurable processors is done according to the discussed topics. ...|$|R
40|$|This paper {{analyzes}} a fuzzy <b>logic</b> (FL) oriented <b>instruction</b> set (micro) controller {{and their}} implementations on FIPSOC 1. VHDL code is synthesized {{using a small}} portion of FIPSOC FPGA 2. This circuits are used from the mP 8051 FIPSOC built-in microcontroller to provide efficient arithmetic operations such as multipliers, dividers, minimums and maximums. Eje: Sistemas de Tiempo Rea...|$|R
40|$|Programmable Logic Controllers (PLCs) have {{traditionally}} been programmed in ladder <b>logic,</b> or <b>instruction</b> step list. Each PLC manufacturer had is own programming language, incompatible with all others. Anyone able to program a PLC in a structured high-level language such as Forth, clearly had a huge advantage in terms of program development time, debugging and maintenance. Now there is considerable industry pressure to adopt a common PLC programming language as defined by IEC 61131. This paper will compare {{the relative merits of}} programming PLCs in Forth and IEC 61131. It will also look at the possibility of using Forth to generate intermediate IEC 61131 source code...|$|R
5000|$|The 8088 is also (like the 8086) slow at {{accessing}} memory. The same ALU {{that is used}} {{to execute}} arithmetic and <b>logic</b> <b>instructions</b> is also used to calculate effective addresses. (There is a separate adder for adding a shifted segment register to the offset address, but the offset EA itself is always calculated entirely in the main ALU.) Furthermore, the loose coupling of the EU and BIU (bus unit) inserts communication overhead between the units, and the four-clock period bus transfer cycle is not particularly streamlined. (Contrast the two-clock period bus cycle of the 6502 CPU and the 80286's three-clock period bus cycle with pipelining down to two cycles for most transfers.) Most 8088 instructions that can operate on either registers or memory, including common ALU and data-movement operations, are at least four times slower for memory operands than for only register operands. Therefore, efficient 8088 (and 8086) programs avoid repeated access of memory operands when possible, loading operands from memory into registers to work with them there and storing back only the finished results. The relatively large general register set of the 8088 compared to its contemporaries assists this strategy. When there are not enough registers for all variables that are needed at once, saving registers by pushing them onto the stack and popping them back to restore them is the fastest way to use memory to augment the registers, as the stack PUSH and POP instructions are the fastest memory operations. (The same is probably not true on the 80286 and later; they have dedicated address ALUs and perform memory accesses much faster than the 8088 and 8086.) ...|$|R
50|$|The integer {{register}} file has 32 64-bit entries. As the SPARC ISA uses register windows, {{of which}} the UltraSPARC has eight, {{the actual number of}} registers is 144. The register file has seven read and three write ports. The integer register file provides registers to two arithmetic logic units and the load/store unit. The two ALUs can both execute arithmetic, <b>logic</b> and shift <b>instructions</b> but only one can execute multiply and divide instructions.|$|R
40|$|Knowledge, experience, and intuition are {{integral}} parts of decision making. However, these alone {{are not sufficient}} to manage today’s industrial systems. Often predictive models are required to weigh options and determine potential changes which provide the best outcome for a system. In this respect, the dissertation develops approximate models, metamodels, of industrial systems to facilitate a means to quantify system performance when the trade-off between approximation error and efficiency (time and effort spent on model development, validation, maintenance and execution) is appropriate. Discrete-event simulation (DES) is widely used to assist decision makers {{in the management of}} systems. DES facilitates analysis with high fidelity models as a consequence of its flexibility. However, this descriptiveness introduces an overhead to model building and maintenance. Furthermore, due to stochastic elements {{and the size of the}} systems modelled, model execution times can be computationally demanding. Hence, its use in operational tasks such as design, sensitivity analysis and optimisation can be significantly undermined when efficiency is a concern. In this thesis, these shortcomings are addressed through research into the use of genetic programming for metamodelling. Genetic programming is a branch of evolutionary algorithms which emulate the natural evolution of species. It can evolve programs of a domain via symbolic regression. These programs can be interpreted as <b>logic</b> <b>instructions,</b> analytical functions etc. Furthermore, genetic programming develops the models without prior assumptions about the underlying function of the training data. This can provide significant advantage for modelling of complex systems with non-linear and multimodal response characteristics. Exploiting these properties, the dissertation presents research towards developing metamodels of manufacturing systems (or their DES models) via genetic programming in the context of symbolic regression. In particular, it contributes to; (i) exploration of an appropriate experimental design method suitable to use with genetic programming, (ii) to a comparison of the performance of genetic programming with neural networks, using three different stochastic industrial problems to identify its robustness; (iii) research into an improved genetic programming and dynamic flow time estimation...|$|R
