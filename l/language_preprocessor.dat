10|47|Public
50|$|From 1970 to 1984, Lesk {{worked at}} Bell Labs {{in the group}} that built Unix. Lesk wrote Unix tools for word {{processing}} (tbl, refer, and the standard ms macro package, all for troff), for compiling (Lex), and for networking (uucp). He also wrote the Portable I/O Library (the predecessor to stdio.h in C) and {{contributed significantly to the}} development of the C <b>language</b> <b>preprocessor.</b>|$|E
5000|$|The term {{postprocessor}} {{has caused}} some confusion. The PostCSS team {{used the term}} to show that PostCSS was not a template <b>language</b> (<b>preprocessor)</b> but a CSS tool. However, some developers think the term postprocessor would better suit browser tools [...] (for instance, -prefix-free). The situation has become even more complicated {{after the release of}} PreCSS. Now, instead of postprocessor, the PostCSS team use the term processor.|$|E
40|$|Many {{software}} {{systems are}} developed with configurable functionality, and for multiple hardware platforms and operating systems. This {{can lead to}} thousands of possible configurations, requiring each configuration-dependent programming entity or variable to have different types. Such configuration-dependent variables are often declared inside preprocessor conditionals (e. g., C <b>language).</b> <b>Preprocessor...</b>|$|E
50|$|The <b>language</b> of <b>preprocessor</b> {{directives}} is only weakly {{related to}} the grammar of C, and so is sometimes used to process other kinds of text files.|$|R
50|$|The PL/I {{preprocessor}} is the preprocessor for the PL/I {{computer programming}} <b>language.</b> The <b>preprocessor</b> interprets {{a subset of}} the full PL/I language to perform source file inclusion, conditional compilation, and macro expansion.|$|R
50|$|Prior to FORTRAN 77, {{a number}} of preprocessors were {{commonly}} used to provide a friendlier language, with the advantage that the preprocessed code could be compiled on any machine with a standard FORTRAN compiler. These preprocessors would typically support structured programming, variable names longer than six characters, additional data types, conditional compilation, and even macro capabilities. Popular preprocessors included FLECS, iftran, MORTRAN, SFtran, S-Fortran, Ratfor, and Ratfiv. Ratfor and Ratfiv, for example, implemented a C-like language, outputting preprocessed code in standard FORTRAN 66. Despite advances in the Fortran <b>language,</b> <b>preprocessors</b> continue {{to be used for}} conditional compilation and macro substitution.|$|R
40|$|This paper {{describes}} {{a tool that}} mimics {{the design of the}} remote procedure call (RPC) system to support the building of replicated objects in a cluster of workstations (COW). The tool includes an interface definition language for describing a replica group, a <b>language</b> <b>preprocessor</b> and a runtime library system. The paper also presents one example and discusses some performance issues for replicated objects. <br /...|$|E
40|$|The START system {{responds}} to natural language queries with answers in text, pictures, and other media. START’s sentence-level natural language parsing {{relies on a}} number of mechanisms to help it process the huge, diverse resources available on the World Wide Web. Blitz, a hybrid heuristicand corpus-based natural <b>language</b> <b>preprocessor,</b> enables START to integrate a large and ever-changing lexicon of proper names, by using heuristic rules and precompiled tables of symbols to preprocess various highly regular and fixed expressions into lexical tokens. LaMeTH, a contentbased system for extracting information from HTML documents, assists START by providing a uniform method of accessing information on the Web in real time. These mechanisms have considerably improved START’s ability to analyze real-world sentences and answer queries through expansion of its lexicon and integration of Web resources. 1...|$|E
40|$|Service {{replication}} {{is a key}} {{to providing}} high availability, fault tolerance and good performance in distributed systems. However, building a service replication system is a di#cult and complex task. This paper describes a tool that mimics the design of the remote procedurecall #RPC# system to support building distributed servicereplication systems. The tool includes an interface de#nition language for describing a replicagroup, a <b>language</b> <b>preprocessor</b> and a runtime library system. Keywords: Service Replication, Distributed System, Interface De#nition Language 1. Introduction Replication in general is an important approach to increasing the availability, achieving faulttolerance, and improving the e#ciency of a system. Replication is a technique of duplicating a critical data item and#or software entity on multiple sites so that one server#site failure can be tolerated by the replicated servers #replicas#. Better performance also can be achieved by replicas executing client requests [...] ...|$|E
40|$|The UNIX {{operating}} system supports {{a number of}} software tools; a mathematical equation-setting language, a phototypesetting <b>language,</b> a FORTRAN <b>preprocessor</b> <b>language,</b> a text editor, and a command interpreter. The design, implementation, documentation, and maintenance of a portable FORTRAN test of the floating-point arithmetic unit of a computer is used to illustrate these tools at work...|$|R
50|$|The C {{preprocessor}} or cpp is {{the macro}} preprocessor for the C and C++ computer programming <b>languages.</b> The <b>preprocessor</b> provides {{the ability for}} the inclusion of header files, macro expansions, conditional compilation, and line control.|$|R
5000|$|Ratfiv is an {{enhanced}} {{version of the}} Ratfor programming <b>language,</b> a <b>preprocessor</b> for Fortran designed to give it C-like capabilities. Fortran was widely used for scientific programming but had very basic control-flow primitives ("do" [...] and [...] "goto") and no [...] "macro" [...] facility which limited its expressiveness.|$|R
40|$|Typical {{algorithms}} for distributed or parallel computations are cooperative, {{meaning that}} the sequential component is broken down into cooperating pieces, which are distributed across available hardware. An approach wich has recently gained some attention is competitive processing, where several versions of a sequential program are distributed across available processors to gain performance from algorithmic diversity. There is also potential for fault tolerance from available hardware by executing the sequential versions, called alternatives, on a distributed configuration. Schemes for implementing competitive concurrent processing have been described in the literature, {{but there is little}} implementation experience. RB is a practical step towards gaining such experience. RB is a programming language for specifying alternative methods of per- forming a computation, where at most one {{of the results of the}} alternatives is used. Our prototype implementation uses a combination of a <b>language</b> <b>preprocessor</b> for C and a runtime library to provide the desired semantics. Using other base programming languages, e. g., Ada, or other methods of managing alternatives is straightforward...|$|E
40|$|The flow {{of natural}} {{language}} is often broken by constructions which are di#cult to analyze with conventional linguistic parsers. To handle these constructions, which include numbers, dates, addresses, etc., and, {{to a lesser}} extent, proper nouns, natural language systems typically implement specialized new rules. This leads {{to a level of}} complexity which renders development and maintenance di#cult. Analyzing and tokenizing these constructions with an independent preprocessor can alleviate the burden on already taxed systems. Because these constructions have highly regular forms, and can be largely understood in the absence of context, it is possible to shift the burden of processing away from the primary parser, and onto a simpler, faster, non-linguistic preprocessor. This paper describes Blitz, a hybrid database- and heuristic-based natural <b>language</b> <b>preprocessor,</b> which has been integrated into the START Natural Language System in order to demonstrate how non-linguistic preprocessing can improve parsing. As a result, START's ability to analyze realworld sentences has improved considerably...|$|E
40|$|RB is a {{programming}} language for specifying redundancy in various dimensions. Avizienis's notation T I HIS, for Time I Hardware I Software, describes {{the different types of}} redundancy possible in a computation: repetition (nT I HIS), redundant hardware (T I nH I S), and program (software) (T I H InS). These can each be controlled by the programmer with RB. RB derives its name from its use of the recovery block notion to specify fault-tolerant segments of software. RB also supplies the programmer with the ability to specify degrees of replication and repetition for a given recovery block alternate; the underlying support software can then take this advice to replicate in time or hardware, based on available resources. An implementation of RB based on the C {{programming language}} is described in this paper. This implementation uses a combination of a <b>language</b> <b>preprocessor</b> for C and a runtime library to provide the desired semantics. Modification of RB to support other programming languages, or programmer specification of N-Version Programming as the decision mechanism. is straightforward. QC 2012022...|$|E
50|$|Most preprocessors are {{specific}} to a particular data processing task (e.g., compiling the C <b>language).</b> A <b>preprocessor</b> may be promoted as being general purpose, meaning {{that it is not}} aimed at a specific usage or programming language, and is intended to be used {{for a wide variety of}} text processing tasks.|$|R
40|$|The {{purpose of}} this thesis is to design {{information}} systems sales aroma diffuser that can assist the sales department {{in view of the}} sales and allow companies to sell his goods. System design method used is the system development life cycle (SDLC). application development is done by using a programming <b>language</b> hypertext <b>preprocessor</b> (PHP) with the database using MYSQL...|$|R
40|$|Yuuji ICHISUGI, Yves ROUDIER fichisugi,roudierg@etl. go. jp Electrotechnical Laboratory 1 Introduction To {{implement}} new languages or extend existing <b>languages,</b> <b>preprocessors</b> or translators {{are often}} used rather than native compilers. The first implementation of C++ was a translator to C. Many language extensions and source level optimization tools for C/C++ are implemented as a translator to C/C++. Recently, many extensions for the Java language[5] have also been proposed which are implemented as preprocessors. Because of the simplicity of Java, {{it is easier to}} design and implement new extensions. The merits of this style of implementation is easiness and high portability. Instruction level optimization can be delegated to the compiler of the target language. Although there are many useful language extension systems for C++ and Java, the users have to select only one extended language for their own projects. Normally, it is impossible to merge several language extensions or eliminate [...] ...|$|R
40|$|The Problem: The flow {{of natural}} {{language}} is often broken by constructions such as numbers, dates, addresses, etc., which {{are difficult to}} analyze with conventional linguistic parsers. Blitz, a heuristic-based natural <b>language</b> <b>preprocessor,</b> has been integrated into the START Natural Language System [4], considerably improving START’s ability to analyze real-world sentences. Motivation: Real-world sentences are populated with numerous constructionsthat do not submit neatly to regular linguistic parsing methods. To handle these constructions, natural language systems typically implement specialized new rules. This leads {{to a level of}} complexity which renders development and maintenance difficult. Because these constructions have highly regular forms, and can be largely understood in the absence of context, it is possible to shift the burden of processing away from the primary parser, and onto a simpler, faster, non-linguistic preprocessor. Previous Work: There already exist several systems (such as [7, 9, 3, 2, 6, 8, 10, 1]) which specialize in the extraction of proper nouns and names. However, the focus of the Blitz system differs somewhat from these other systems. Blitz was designed to handle not only proper nouns, but the entire spectrum of special constructions, and to assist in the goal of natural language understanding, as opposed toprevioussystems ’ somewhat less ambitious goals of automatic indexing, keyword extraction, and summary generation...|$|E
5000|$|In 1965 {{an update}} to IBM's PL/I Language {{specification}} defined an even less ambitious <b>preprocessor</b> <b>language.</b> All mention of preprocessor procedures was omitted. The following compile-time statements were specified: ...|$|R
5000|$|... troff {{features}} {{commands to}} designate fonts, spacing, paragraphs, margins, footnotes and more. Unlike many other text formatters, troff can position characters arbitrarily on a page, even overlapping them, {{and has a}} fully programmable input <b>language.</b> Separate <b>preprocessors</b> are used for more convenient production of tables, diagrams, and mathematics. Inputs to troff are plain text files that can be created by any text editor.|$|R
40|$|There is some evidence, that {{assertion}} techniques, i. e., preconditions, postconditions and invariants have {{a positive}} effect on the overall software quality. Unfortunately only a limited number of commercially relevant programming languages support assertion techniques (e. g., Eiffel). Even modern programming languages like Java have very limited built-in support for assertions. Nevertheless a number of systems exist for the the Java programming language, that support assertion techniques in different ways (<b>language</b> extensions, <b>preprocessors,</b> metaprogramming approaches). In order to make these different approaches comparable we developed a set of criteria and used these criteria to evaluate these systems. ...|$|R
40|$|Mathematical {{modeling}} and constraint programming languages have orthogonal strengths in stating combinatorial optimization problems. Modeling languages typically feature high-level set and algebraic notations, while constraint programming languages provide a rich constraint {{language and the}} ability to specify search procedures. This paper shows that many of the functionalities typically found in modeling languages can be integrated elegantly in constraint programming libraries without defining a specific <b>language</b> or <b>preprocessor.</b> In particular, it presents the design of OPL++, a C++ modeling layer for constraint programming that combines the salient features of both approaches. Of particular interest is the one-to-one correspondence between high-level models and OPL++ statements and the negligible overhead induced by the extension...|$|R
40|$|Text {{preprocessing}} {{plays an}} important role in a text-to-speech (TTS) synthesis system. The correct detection and interpretation of input strings influence the overall system accuracy and contribute to the conversion of an unrestricted text into synthetic speech. This paper describes the design philosophy of a preprocessing module for a TTS system in Romanian <b>language.</b> The <b>preprocessor</b> is implemented using the standard flex/bison lexer and parser generators. The paper discusses the text preprocessing task and the major difficulties connected with Romanian language, proposes a set of definitions and rules, gives some implementation details and concludes with a few considerations about the TTS system and performances of the preprocessing module. 1...|$|R
40|$|In {{contrast}} with classical simulation languages, the present trends are evolving towards fully integrated interactive modelling and simulation evironmens. These environments have to combine interdisciplianry tecniques such as expert systems, {{object oriented programming}} and data base management. To achieve the above objectives, {{the architecture of the}} simulation programming language and that of the run-time simulation environment which exercises the models should be deinged allowing modularity and flexibility. Furthermore, the robustness of the environment should be reinforced. In this paper the MUSS simulation system is presented, emphasizing the innovative conepts: the hierachcical architecture of the MUSS simulation <b>language,</b> the <b>preprocessor</b> analysis anf segmentation pases and the structure of the run-time simulation environment. Postprint (published version...|$|R
40|$|Slicing C {{programs}} {{has been one}} of the most popular ways for the implementation of slicing algorithms; out of the very few practical implementations that exist many deal with this programming <b>language.</b> Yet, <b>preprocessor</b> related issues have been addressed very marginally by these slicers, despite the fact that ignoring (or handling poorly) these constructs may lead to serious inaccuracies in the slicing results and hence in the comprehension process. Recently, an accurate slicing method for preprocessor related constructs has been proposed which – when combined with existing C/C++ language slicers – can provide a more complete comprehension of these languages. In this paper, we overview our approach for this combination and report its benefits in terms of the completeness of the resulting slices...|$|R
40|$|Abstract:- This paper {{presents}} a preprocessor based parsing system for Tree Adjoining Grammars. The preprocessor {{is used for}} two purposes: (1) to organize the data structures, (2) to reduce the runtime processing load so that the parser executes fast. A parallel parsing algorithm is presented that {{takes advantage of the}} preprocessor. The future goals of the proposed research are to achieve scalability and efficiency in processing the language. Key-Words:- parsing, <b>language,</b> grammar, parsing, <b>preprocessor</b> 1...|$|R
5000|$|The <b>{{preprocessor}}</b> <b>language</b> has a PL/I-like syntax with preprocessor {{statements and}} preprocessor procedures prefixed with a percent symbol (...) [...] Listing-control statements, which supply formatting commands for the compiler listing, are usually considered preprocessor statements and also begin with [...] Preprocessor statements are imbedded in and operate on input text. The input text is normally a PL/I program, but is agnostic to the grammar of PL/I, so the preprocessor {{can also be}} used independently to process other kinds of text files.|$|R
40|$|Application {{website at}} Van Cellular counter {{is made to}} {{facilitate}} community in getting an update on developments surrounding the world of cell phones that are now increasingly popular in the community with {{ways to make the}} application a list of prices of mobile phones sold in one mobile counter, which is Mobile Van Cellular Conter who exactly was in the area are Pamulang Tangerang. Application of this website is made by using a merger between Adobe Dreamweaver CS 3 software used to design web pages, programming <b>language</b> Hypertext <b>Preprocessor</b> (PHP) which is a server side scripting language for web content that integrates with the Hypertext Markup Language (HTML). In particular, PHP is designed to create dynamic web, which means that php can form a view based on current demand and is very easy to use and learn...|$|R
40|$|The C {{preprocessor}} {{is heavily}} used in C programs {{because it provides}} useful and even necessary additions to the C <b>language.</b> Since <b>preprocessor</b> directives {{are not part of}} C, they are removed before parsing and program analysis take place, during the phase called preprocessing. In the context of refactoring, it is inappropriate to remove preprocessor directives: if changes are applied on the preprocessed version of a program, it may not be possible to recover the un-preprocessed version. This means that after refactoring, all the source code would be contained in a single unit, targeted to a single con¯guration and without preprocessor macros. This thesis describes a novel approach to preserve preprocessor directives during parsing and program analysis, and integrate them in the program representations. Furthermore, it illustrates how the program representations are used during refactor-ing and how transformations preserve preprocessor directives. Additionally, the semantics of the C preprocessor are formally speci¯ed, and the results of implementing this approach in a refactoring tool for C, CRefactory, are presented...|$|R
40|$|Abstract. As one HTML {{embedded}} scripting <b>language,</b> PHP (Hypertext <b>Preprocessor)</b> is {{a powerful}} computer programming language which is a remarkable tool to enhance the expression of webpage. JavaScript is a client-side technology that is processed by the client-side software. But PHP is completely the server-side scripting language. It is a critical issue that how to effectively complete the client’s request and transfer the information between two languages. The form is adopted in this paper. And based on that, the information transfer between two languages is tested. The result proves that in web project the interaction via form is an effective and reliable method...|$|R
40|$|ABSTRACT: ABC++ is a {{portable}} object-oriented type-safe class library for parallel programming in C++. It supports active objects, synchronous and asynchronous object interactions, and object-based shared regions on both shared- and distributed-memory parallel computers. ABC++ is written in, and compatible with, standard C++: no <b>language</b> extensions or <b>preprocessors</b> are used. This paper focuses on {{its use of}} an object-oriented technique called smart messages to support object interactions. Smart messages demonstrate the effectiveness of object-oriented programming in encapsulating low-level details of concurrency and in improving software portability. *This work has been supported by the Centre for Advanced Studies...|$|R
40|$|Refactoring {{has become}} a {{well-known}} technique for transforming code {{in a way that}} preserves behavior. Refactorings may be applied manually, although manual code manipulation is error prone and cumbersome, so maintainers need tools to make automatic refactorings. There is currently extensive literature on refactoring object-oriented programs and some very good tools for refactoring Smalltalk and Java code. Although there is more code written in C or C++ than in any other language, refactoring tools for C with full support for preprocessor directives have not yet appeared. The C programming <b>language,</b> especially the <b>preprocessor</b> directives that coexist with it, complicates refactorings in different ways as directives are not legal C code and may violate otherwise correct refactorings...|$|R
40|$|Design {{automation}} inventory {{credit balance}} this stock is a server application {{that is used}} to facilitate pulse process purchases and sales of electronic pulses/ electric then reporting the results of transaction processing and supply management stock/ credit balances automatically. This application was built using the programming <b>language</b> Hypertext <b>Preprocessor.</b> The purpose of this final report to compare the practice of application design automation inventory stock outstanding balance with the theory that has been obtained from the lecture bench and gain experience valuable observations in the field (counter/ kiosk Chantika), as a graduation requirement assessment and Engineering Program Information S 1. Data collection methods used by the author is observation, interviews, and literature. The data used are primary data and secondary data. Activities conducted by the author at the time in the counter/ kiosk Chantika is helping field applications that can facilitate the process of credit sales transactions electronically/ electrically, reporting the results of the transaction and supply management stock/ credit balances automatically. With applications design automation inventory balances this stock balance {{can be one of the}} alternatives used by counter/ kiosk Chantika in transaction processing and supply management stock/ credit balances automatically...|$|R
40|$|The {{dynamism}} and multi-tasking {{is now the}} web {{is necessary}} to make systems {{with the possibility of}} spatial information in a particular geographical environment with complete user interaction in building its senary information. Innovations are needed to design and develop a system for SIGWeb the spatial information, with support for various areas takes this possibility. The focus is not only to develop a system for web and yes, a generic system capable of being adaptable to various topics that have some type of variable which can be spatialized. Will use free tools such as the PostgreSQL database with PostGIS spatial extension related to web programming <b>language</b> PHP (Hypertext <b>Preprocessor)</b> and API (Application Programming Interface) Google Maps. Pages: 4864 - 487...|$|R
40|$|Abstract. Creating a valid {{software}} configuration {{of a product}} line can require laborious customizations involving multiple configuration file types, such as feature models, domain-specific <b>languages,</b> or <b>preprocessor</b> defines in C header files. Using configurable off-the-shelf components causes additional complexity. Without checking of constraints across file types boundaries already at configuration time, intricate inconsistencies {{are likely to be}} introduced—resulting in product defects, which are costly to discover and resolve later on. Up to now, at best ad-hoc solutions have been applied. To tackle this problem in a general way, we have developed an approach and a corresponding plug-in infrastructure. It allows for convenient definition and checking of constraints across configuration file types and product line boundaries. Internally, all configuration files are converted to models, facilitating the use of model-based constraint languages (e. g., OCL). Converter plug-ins for arbitrary configuration file types may be integrated and hide a large amount of complexity usually associated with modeling. We have validated our approach using a quadrotor helicopter product line comprising three sub–product-lines and four different configuration file formats. The results give evidence that our approach is practically applicable, reduces time and effort for product derivation (by avoiding repeated compiling, testing, and reconfiguration cycles), and prevents faulty software deployment. ...|$|R
