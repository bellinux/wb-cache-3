29|136|Public
6000|$|... "Yes, truly, {{and they}} press hard upon the castle, {{for they are}} an {{exceeding}} multitude and full of courage. See how they storm and rage against the gate, while some rear ladders, and others, line after <b>line,</b> <b>sweep</b> the walls with their arrows. They are many leaders who shout and beckon, and one, {{a tall man with}} a golden beard, who stands before the gate stamping his foot and hallooing them on, as a pricker doth the hounds. But those in the castle fight bravely. There is a woman, two women, who stand upon the walls, and give heart to the men-at-arms. They shower down arrows, darts and great stones. Ah! they have struck down the tall leader, and the others give back. The mist thickens and I can see no more." ...|$|E
50|$|The {{standard}} <b>line</b> <b>sweep</b> algorithm for merging upper envelopes sweeps {{though all}} of vertices {{of the red}} and blue upper envelopes, from left to right. The most recently encountered red and blue points are maintained as the line sweeps. When a point is encountered, the algorithm checks if the point is above or below the segment following the last encountered point of the opposite color. If it is above, that point {{is added to the}} merged upper envelope. If it of a different color than the last added point, the red and blue envelopes have crossed, so the intersection point is also added to the merged upper envelope.|$|E
50|$|We must {{notice that}} {{according}} to the update policy of the population used, we could also define an asynchronous cEA. This is also a well-known issue in cellular automata. In asynchronous cEAs {{the order in which}} the individuals in the grid are update changes depending on the criterion used: <b>line</b> <b>sweep,</b> fixed random sweep, new random sweep, and uniform choice. These are the four most usual ways of updating the population. All of them keep using the newly computed individual (or the original if better) for the computations of its neighbors immediately. This makes the population to hold at any time individual in different states of evolution, defining a very interesting new line of research.|$|E
50|$|In {{computational}} geometry, a <b>sweep</b> <b>line</b> algorithm or plane sweep {{algorithm is}} an algorithmic paradigm {{that uses a}} conceptual <b>sweep</b> <b>line</b> or <b>sweep</b> surface to solve various problems in Euclidean space. It {{is one of the}} key techniques in computational geometry.|$|R
50|$|The {{algorithm}} maintains both a <b>sweep</b> <b>line</b> and a beach line, {{which both}} {{move through the}} plane as the algorithm progresses. The <b>sweep</b> <b>line</b> is a straight line, which we may by convention assume to be vertical and moving left to right across the plane. At {{any time during the}} algorithm, the input points left of the <b>sweep</b> <b>line</b> will have been incorporated into the Voronoi diagram, while the points right of the <b>sweep</b> <b>line</b> will not have been considered yet. The beach line is not a straight line, but a complicated, piecewise curve {{to the left of the}} <b>sweep</b> <b>line,</b> composed of pieces of parabolas; it divides the portion of the plane within which the Voronoi diagram can be known, regardless of what other points might be right of the <b>sweep</b> <b>line,</b> from the rest of the plane. For each point left of the <b>sweep</b> <b>line,</b> one can define a parabola of points equidistant from that point and from the sweep line; the beach line is the boundary of the union of these parabolas. As the <b>sweep</b> <b>line</b> progresses, the vertices of the beach line, at which two parabolas cross, trace out the edges of the Voronoi diagram. The beach line progresses by keeping each parabola base exactly half way between the points initially swept over with the <b>sweep</b> <b>line,</b> and the new position of the <b>sweep</b> <b>line.</b> Mathematically, this means each parabola is formed by using the <b>sweep</b> <b>line</b> as the directrix and the input point as the focus.|$|R
5000|$|... #Caption: The Grenaa <b>Line</b> railway <b>sweeps</b> west {{around the}} meadows.|$|R
50|$|The dual of a {{convex hull}} {{of a set}} of points is the upper and lower {{envelopes}} of the dual set of lines. Therefore, maintaining the upper and lower envelopes {{of a set of}} moving lines is equivalent to maintaining the convex hull of a set of moving points. Computing upper and lower envelopes are equivalent problems, so computing the upper envelope of a set of lines is equivalent to computing the convex hull of a set of moving points.The upper envelope of a set of static lines can be computed using a divide and conquer algorithm which partitions the lines into two sets of equal size, calls itself recursively on the two sets to find their upper envelopes, and then merges the two resulting upper envelopes. The merge step is performed using a vertical <b>line</b> <b>sweep.</b> Call the first set of points blue and the second set of points red.|$|E
50|$|The aim of {{the flight}} is to {{complete}} a number of fast laps, flown as quickly as possible, followed {{by a number of}} slow laps, flown as slowly as possible. This is followed by the carrier deck landing, attempting to snag the arrestor wire. The score depends on the difference of the high and low speed, and the arrested landing. Carrier models usually have a third control line, worked by a finger trigger in the handle. This line allows the throttle setting of the engine to be controlled and the arrestor hook to be dropped. Often, a carrier model will have flaps. Unlike a stunt model, however these flaps are worked separately from the elevator. A large amount of flap is usually applied during the slow laps, and a large amount of <b>line</b> <b>sweep</b> is added to yaw the model out of the circle to maintain line tension at the very low ground speeds. Low speeds are frequently no faster than a fast walk, and when aimed into a light breeze forward motion may stop completely with the model hanging at a very high angle of attack from the propeller.|$|E
5000|$|To {{control the}} airplane, the lines must remain in tension. Centrifugal force is {{generally}} sufficient to maintain line tension if the airplane is properly [...] "trimmed" [...] (adjusted), but sometimes additional {{features such as}} rudder offset and engine offset are added to provide extra tension. Weight in the outboard wing tip is usually used to balance {{the weight of the}} lines. Top aerobatics models typically have a large number of adjustable features like tip weight boxes, adjustable rudder offset, adjustable <b>line</b> <b>sweep,</b> and adjustable elevator and flap controls. Some aerobatics models use a variable rudder system (commonly called the Rabe rudder after its inventor, Al Rabe) to vary the rudder offset during flight. The adjustment of the various adjustable features on a modern stunt model can become quite complex.Many models also feature a longer inboard wing; aerobatics models use this to balance the lift from side-to-side, compensating for the difference in velocity from inboard to outboard wing, while some speed models use a very exaggerated longer inboard wing to provide streamlining of the flying lines. On small speed models the drag of the flying lines can be three times the drag {{of the rest of the}} model.|$|E
5000|$|A single Stick made up {{the stop}} groups (stops), patrols, ambushes and often <b>sweep</b> <b>lines,</b> {{although}} larger <b>sweep</b> <b>lines</b> could be made up from para-sticks or by combining the sticks positioned by the G-Cars, or from those sticks transported by the [...] "Landtail". In all formations the MAG gunner was next in position to the Stick Leader.|$|R
5000|$|From another viewpoint, {{the central}} {{meaning of the}} poem is {{revealed}} layer by layer as each line is read. Each line raises a question which is answered in the next. That line in turn raises another question, and so on. This poetic technique is known as [...] "sweep and renew" [...] 扫处还生. As each <b>line</b> <b>sweeps</b> away a question it presents a new one.|$|R
50|$|The {{algorithm}} maintains as data structures {{a binary}} search tree describing the combinatorial structure of the beach line, and a priority queue listing potential future events that could change the beach line structure. These events include the addition of another parabola to the beach <b>line</b> (when the <b>sweep</b> <b>line</b> crosses another input point) {{and the removal of}} a curve from the beach <b>line</b> (when the <b>sweep</b> <b>line</b> becomes tangent to a circle through some three input points whose parabolas form consecutive segments of the beach line). Each such event may be prioritized by the x-coordinate of the <b>sweep</b> <b>line</b> at the point the event occurs. The algorithm itself then consists of repeatedly removing the next event from the priority queue, finding the changes the event causes in the beach line, and updating the data structures.|$|R
40|$|Multipartitioning is a {{strategy}} for partitioning multidimensional arrays among a collection of processors so that line-sweep computations can be performed e#ciently. The principal property of a multipartitioned array is that for a <b>line</b> <b>sweep</b> along any array dimension, all processors have {{the same number of}} tiles to compute at each step in the sweep. This property results in full, balanced parallelism. A secondary benefit of multipartitionings is that they induce only coarse-grain communication. Previously, computing a d-dimensional multipartitioning required that p 1 d- 1 be integral, where p is the number of processors. Here, we describe an algorithm to compute a d-dimensional multipartitioning of an array of # dimensions for an arbitrary number of processors, for any d, 2 # d # #. When using a multipartitioning to parallelize a <b>line</b> <b>sweep</b> computation, the best partitioning is the one that exploits all of the processors and has the smallest communication volume. To compute the best multipartitioning of a #-dimensional array, we describe a cost model for selecting d, the dimensionality of the best partitioning, and the number of cuts along each partitioned dimension. In practice, our technique will choose a 3 -dimensional multipartitioning for a 3 -dimensional line-sweep computation, except when p is a prime; previously, a 3 -dimensional multipartitioning could be applied only when # p is integral. We describe an implementation of multipartitioning in the Rice dHPF compiler and performance results obtained to parallelize a <b>line</b> <b>sweep</b> computation on a range of di#erent numbers of processors. # This work performed while a visiting scholar at Rice University. ...|$|E
40|$|This paper proposes an {{efficient}} face recognition scheme, which incorporates certain methods. In this scheme, edges are obtained from sobelled face images. The major feature areas are segmented and principal curves are obtained by applying thinning algorithm on {{the features of}} resulting face image. A modified thinning algorithm based on <b>line</b> <b>sweep</b> procedures is used. A <b>line</b> <b>sweep</b> is a process where the plane is divided into parallel slabs by lines passing through certain “events ” and then items are processed according to an order of the slabs [1]. A new method for Bezier contour point interpolation is used after locating the two end points of the curve on the prime facial features. The two control points of a Bezier curve are interpolated by this method. The Bezier points i. e. the two end points of a curve and the two control points, form the line segments whose Hausdroff distances are calculated as specified in the algorithm discussed in this paper. The recognition rate is 100 % on normal faces and also on faces with some simple expressions. 1...|$|E
40|$|Abstract-A new fast {{switchbox}} router, BEAVER, is presented. BEAVER {{combines a}} delayed layering scheme with computational ge-ometry techniques to heuristically produce a switchbox solution that minimizes both via usage and wire length, and maximizes {{the use of}} a preferred routing layer. Other important features are its use of prior-ity queues to determine the order that nets are routed and its priori-tized control of individual track and column usage to prevent routing conflicts. BEAVER consists of four tools that are run successively-a corner router, a <b>line</b> <b>sweep</b> router, a thread router, and a layerer. The corner router makes single-bend terminal-to-terminal connections. The <b>line</b> <b>sweep</b> router makes straight-line connections, single-bend connec-tions, and two-bend connections. The thread router makes connections of arbitrary form. The layerer completes the switchbox by layering wires that have been assigned a location but not yet a layer. BEAVER has successfully routed all of the classic switchboxes. Its solution qual-ity with respect to wire length was better than or comparable to the best previous solutions and its via usage was consistently the minimum. These characteristics make it appropriate for its intended use as the initial router invoked to solve a switchbox...|$|E
5000|$|... #Caption: Animation of Fortune's algorithm, a <b>sweep</b> <b>line</b> {{technique}} for constructing Voronoi diagrams.|$|R
40|$|Given n line {{segments}} in the plane, the Bentley-Ottmann sweep maintains the exact ordering of the intersections of the segments with a vertical line, as this <b>line</b> <b>sweeps</b> the plane {{from left to}} right. To accomplish this, every intersection between two segments must be processed, and the running time of the sweep can be (n 2). In this paper, it is shown how a heap on the intersections can be maintained during the sweep. This new type of sweep processes O(n log² n) intersections when sweeping over lines and O(n p n log n) intersections when sweeping over {{line segments}}. Alower bound of (n log n) is also established...|$|R
40|$|In {{the thesis}} we first {{describe}} {{the definition of}} a Voronoi diagram and several properties of Voronoi diagrams in the plane. We also define triangulations of the plane and the concept of a Delaunay triangulation, and present the connection between Voronoi diagrams and Delaunay triangulations. We then present three different algorithms for constructing a Voronoi diagram in the plane, and provide a more detailed description of Fortune’s algorithm which {{is an example of a}} <b>sweep</b> <b>line</b> algorithm. <b>Sweep</b> <b>line</b> algorithms are especially widespread in computational geometry and are used for solving various problems in Euclidean space. We selected Fortune’s algorithm for constructing Voronoi diagrams, and implemented it in the Java programming language. The performance of our implementation of the algorithm was checked on several randomly generated datasets and on a dataset of geographic coordinates of public charging stations for electric cars in Slovenia...|$|R
40|$|We {{show that}} the {{wavefront}} approach to Voronoi diagrams (a deterministic <b>line</b> <b>sweep</b> algorithm that does not use geometric transform) can be generalized to distance measures more general than the Euclidean metric. In fact, we provide the first worstcase optimal (O(n log time, O(n) space) algorithm that is valid for the full class {{of what has been}} called nice metrics in the plane. This also solves the previously open problem of providing an time plane-sweep algorithm for arbitrary L k -metrics...|$|E
40|$|Includes bibliographical {{references}} (p. 53 - 55). <b>Line</b> <b>sweep</b> {{algorithm is}} probably the most popular algorithm in Computational Geometry. The algorithm basically tries to find intersection points among a set of lines in a Cartesian coordinate space. The algorithm has many real life usages and hence probably is more popular. In this thesis I am presenting two different implementations of the <b>Line</b> <b>Sweep</b> algorithm. The two variations of the algorithm are developed using C++ programming language. C++, is the chosen language as it provides a large amount of control over the program but the algorithm can be potentially developed in any choice of programming language. First implementation represents the algorithm as stated in the text book and in the second implementation I am proposing a slight modification. The goal of the alteration would be to enhance the efficiency of this algorithm by modifying one of the data structure used by line-sweep algorithm, namely status structure such as in the line-segment intersection problem, is the objective of this research. The status structure is used {{to keep track of the}} segments currently adjacent to one another and the proposed alteration will increase the efficiency of search operations on this structure. I will then be comparing the search operation time required by the two variants of the algorithm to prove the statement. Modern Design patterns like iterator and factory pattern have been used to develop the algorithm so that it can be easily applied to other use cases with little or no modifications. All the data structures have been self-implemented without dependency on any third party libraries or dynamic link libraries (DLLs). The primary goal of this project besides understanding and implementing the <b>Line</b> <b>sweep</b> algorithm is to suggest some modifications in the original data structure used in this algorithm in order to make it more efficient. Also the secondary goal is to present a working algorithm so that future students/ researchers can better understand the algorithm when they see the internal data structures being updated as the algorithm proceeds, which is very critical in understanding the overall algorithm...|$|E
40|$|Strategies for {{partitioning}} an application's data play {{a fundamental}} {{role in determining}} the range of possible parallelizations that can be performed and ultimately their potential efficiency. This paper describes extensions to the Rice dHPF compiler for High Performance Fortran which enable it to support data distributions based on multipartitioning. Using these distributions can help close the substantial gap between the eciency and scalability of compiler-parallelized codes for multi-directional <b>line</b> <b>sweep</b> computations and their hand-coded counterparts. We describe our the design and implementation of compiler support for multipartitioning and show preliminary results for a benchmark compiled using these techniques...|$|E
40|$|Given {{a set of}} {{horizontal}} line segments, the hive-graph is a data structure that supports queries of the form "given a point p belonging to a line segment report the segment above (or below) and visible from p", answering in constant time. It has been introduced in a static setting [1]. In this paper we provide algorithms that maintain a hive-graph {{of a set of}} n horizontal line segments between two vertical <b>sweep</b> <b>lines.</b> The <b>sweep</b> <b>lines</b> can independently move right and left (giving rise to insertions and deletions of endpoints). Space and update time are O(n) and O(log n), respectively. We retain the optimal query time of the static solution. What we actually maintain is a simplified version of the original hive-graph, obtained through a relaxation of its constraint on rectangles abutting. 1 Introduction The hive-graph is a data structure introduced by Chazelle [1], in the framework of the filtering search technique, to the purpose of solving problems of the following form: p [...] ...|$|R
60|$|Again {{the spell}} is broken; our men attempt to cheer; they are choking with emotion; they utter hoarse, {{discordant}} cries; they clutch {{their weapons and}} press tumultuously forward into the open. The skirmishers, without orders, against orders, are going forward at a keen run, like hounds unleashed. Our cannon speak and the enemy's now open in full chorus; to right and left {{as far as we}} can see, the distant crest, seeming now so near, erects its towers of cloud and the great shot pitch roaring down among our moving masses. Flag after flag of ours emerges from the wood, <b>line</b> after <b>line</b> <b>sweeps</b> forth, catching the sunlight on its burnished arms. The rear battalions alone are in obedience; they preserve their proper distance from the insurgent front.|$|R
50|$|Initialize {{a binary}} search tree T of the line {{segments}} that cross the <b>sweep</b> <b>line</b> L, ordered by the y-coordinates of the crossing points. Initially, T is empty.|$|R
40|$|Multipartitioning is a {{strategy}} for partitioning multi-dimensional arrays among a collection of processors so that line-sweep computations can be performed eciently. The principal property of a multipartitioned array is that for a <b>line</b> <b>sweep</b> along any array dimension, all processors have {{the same number of}} tiles to compute at each step in the sweep, in other words, it describes a latin hyper-rectangle, natural extension of the notion of latin squares. This property results in full, balanced parallelism. A secondary benet of multipartitionings is that they induce only coarse-grain communication. All of the multipartitionings described in the literature to date assign only one tile per processor per hyperplane of a multipartitioning (latin hyper-cube). While this class of multipartitionings is optimal for two dimensions, in three dimensions it requires the number of processors to be a perfect square. This paper considers the general problem of computing optimal multipartitionings for multi-dimensional data volumes on an arbitrary number of processors. We describe an algorithm to compute a d-dimensional multipartitioning of a multi-dimensional array for an arbitrary number of processors. When using a multipartitioning to parallelize a <b>line</b> <b>sweep</b> computation, the best partitioning is the one that exploits all of the processors and has the smallest communication volume. To compute the best multipartitioning of a multi-dimensional array, we describe a cost model for selecting d, the dimensionality of the best partitioning, and the number of cuts along each partitioned dimension. In practice, our technique will choose a 3 -dimensional multipartitioning for a 3 -dimensional line-sweep computation, except when p is a prime; previously, a 3 -dimensional multipartitioning could be a [...] ...|$|E
40|$|A linearized {{theoretical}} {{analysis has}} been made to determine mininnxn-wave-dragairfoil sections for arrow wings having the same air-foil sections at all spanwise stations. The drag of the wings was mini-mized subject to the condition of either a given thiclmess ratio at a specified chordwise location or a given volume. Numerical computations of the airfoil shape and wing wave drag were performed for a delta wing and for sm arrow wing having a ratio of the tangent of the trailing-edge sweep angle to the tangent of the leading-edge sweep angle of 0. 4. The range of the ratio of the tangent of the leading-edge sweep angle to the tangent of the ~ch <b>line</b> <b>sweep</b> angle extended from O (two-dimensional) tO 2. 5. ...|$|E
40|$|Multipartitioning is a {{strategy}} for partitioning multidimensional arrays among a collection of processors. With multipartitioning, computations that require solving one-dimensional recurrences along each dimension of a multi-dimensional array can be parallelized effectively. Previous techniques for multipartitioning yield efficient parallelizations over threedimensional domains only {{when the number of}} processors is a perfect square. This paper considers the general problem of computing optimal multipartitionings for d-dimensional data volumes on an arbitrary number of processors. We describe an algorithm that computes an optimal multipartitioning for this general case, which enables multipartitioning to be used for performing efficient parallelizations of linesweep computations under arbitrary conditions. Finally, we describe a prototype implementation of generalized multipartitioning in the Rice dHPF compiler and performance results obtained when using it to parallelize a <b>line</b> <b>sweep</b> computation for different numbers of processors. ...|$|E
50|$|The {{resulting}} graph {{has only}} a linear number of edges and can be constructed in O(n log n) using a divide and conquer algorithm or a <b>sweep</b> <b>line</b> algorithm.|$|R
60|$|These flats of pumice, 'stones of emptiness,' loose {{incoherent}} matter, are {{the site}} of the first great crater. Tenerife is the type of a three-storied volcano, as Stromboli is of one and Vesuvius of two stages. The enormous diameter of this ancient feature is eight by seven miles, with a circumference of twenty-three--greater even than Hawaii--and here one feels that our earth was once a far sublimer scene. Such forms belong to the earlier volcanic world, and astronomers still suspect them in the moon. [Footnote: Las Cañádas was shown to be a volcanic crater in 1803 by Professor Cordier, the first scientific visitor in modern days (Lettre à Devilliers fils), and in 1810 by D. Francisco Escobar (Estadistica). They make the old vent ten leagues round.] The altitude is 6,900 feet, nearly double the height of Vesuvius (3,890 feet); and the <b>lines</b> <b>sweep</b> upwards towards the Pilon, where they reach 8,950 feet.|$|R
5000|$|In {{order to}} {{efficiently}} maintain the intersection {{points of the}} <b>sweep</b> <b>line</b> L with the input line segments and the sequence of future events, the Bentley-Ottmann algorithm maintains two data structures: ...|$|R
40|$|Data {{parallel}} compilers {{have long}} aimed to equal {{the performance of}} carefully hand-optimized parallel codes. For tightly-coupled applications based on line sweeps, this goal has been particularly elusive. In the Rice dHPF compiler, we have developed {{a wide spectrum of}} optimizations that enable us to closely approach hand-coded performance for tightly-coupled <b>line</b> <b>sweep</b> applications including the NAS SP and BT benchmark codes. From lightly-modified copies of standard serial versions of these benchmarks, dHPF generates MPI-based parallel code that is within 4 % of the performance of the hand-crafted MPI implementations of these codes for a 102 &sup 3; problem size (Class B) on 64 processors. We describe and quantitatively evaluate the impact of partitioning, communication and memory hierarchy optimizations implemented by dHPF that enable us to approach handcoded performance with compiler-generated parallel code...|$|E
40|$|Abstract. We {{present a}} new <b>line</b> <b>sweep</b> algorithm, HeapSweep, for {{reporting}} bichromatic (`purple') intersections between {{a red and}} a blue family of line segments. If the union of the segments in each family is connected as a point set, HeapSweep reports all k purple intersections in time O((n + k) (n) log 3 n), where n is {{the total number of}} input segments and (n) is the familiar inverse Ackermann function. To achieve these bounds, the algorithm keeps only partial information about the vertical ordering between segments of the same color, using a new data structure called a kinetic queue. In order to analyze the running time of HeapSweep, wealsoshow that a simple polygon containing a set of n line segments can be partitioned into monotone regions by lines cutting these segments (n log n) times. ...|$|E
40|$|This paper {{presents}} a full fingerprint verification system. It {{is composed of}} a tactile fingerprint sensor, integrated read out and conversion circuits, and dedicated recognition algorithms. The sensor is a single <b>line</b> <b>sweep</b> mode sensor, e. g. it is made of single line of sensing elements, thus covering the minimum surface of silicon. Compared to cm 2 sized touch sensors, it offers a large cost reduction and possibility of easy integration into portable devices. The use of a single line to measure fingerprint requires the user to sweep its finger along the sensor. This sensing scheme produces fingerprint images with several distortions that needs further image processing to allow efficient fingerprint recognition. This is why we developed and present here specific algorithms {{to take care of}} the sensor?s specifications. The paper will present measurement results as well as a performance evaluation of the entire verification system...|$|E
50|$|Modern {{implementations}} for Boolean {{operations on}} polygons {{tend to use}} plane sweep algorithms (or <b>Sweep</b> <b>line</b> algorithms). A list of papers using plane sweep algorithms for Boolean operations on polygons {{can be found in}} References below.|$|R
50|$|Note {{that if you}} {{are moving}} downwards, the points where both of the {{vertices}} are below the <b>sweep</b> <b>line</b> are 'split points'. They mark a split in the polygon. From there you have to consider both sides separately.|$|R
40|$|Many {{geometric}} algorithms {{that are}} usually formulated for points and segments generalize easily to inputs also containing rays and <b>lines.</b> The <b>sweep</b> algorithm for segment intersection is a prototypical example. Implementations of such algorithms do, in general, not extend easily. For example, segment endpoints cause events in <b>sweep</b> <b>line</b> algorithms, but lines have no endpoints. We describe a general technique, which we call infimaximal frames, for extending implementations to inputs also containing rays and lines. The technique {{can also be used}} to extend implementations of planar subdivisions to subdivisions with many unbounded faces. We have used the technique successfully in generalizing a sweep algorithm designed for segments to rays and lines and also in an implementation of planar Nef polyhedra [Nef 78, Bie 95]. Our implementation is based on concepts of generic programming in C++ and the geometric data types provided by the C++ Computational Geometry Algorithm...|$|R
