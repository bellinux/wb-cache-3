15|19|Public
50|$|In linguistics, syntax is {{the study}} of the {{structure}} of grammatical utterances, and accordingly syntax-directed editor is a synonym for structure editor. <b>Language-based</b> <b>editor</b> and language-sensitive editor are also synonyms. A language-based editor’s features may be implemented by ad hoc code or by a formal grammar. For example, language sensitivity in Emacs is implemented in the Lisp definition of the edit mode for the given language. In contrast, language sensitivity in an XML editor is driven by a formal DTD schema for the given language.|$|E
40|$|As {{a uniform}} {{front-end}} user interface, a generic <b>language-based</b> <b>editor</b> {{should have the}} capability to incorporate both analytic and constructive back-end tools. In this paper, we analyse the requirements of, and propose a strategy for, integrating constructive tools into a generic <b>language-based</b> <b>editor.</b> The major issues addressed include definition of software documents containing tool contributions, real-time consistency checking of such documents, communication and synchronisation between the editor and constructive tools. We demonstrate the feasibility of this approach by integrating a theorem prover into the enhanced generic editor. To cater for the full range of representation and integration requirements of both analytic and constructive tools, we propose to define a generic model of software documents and to develop a corresponding front-end editor for such documents which is capable of real-time interaction with these tools. 1 Introduction Software development tools [...] ...|$|E
40|$|We {{consider}} {{the problem of}} designing the top-level modular structure of an implementation. Our starting point is a formal specification of the system. Our approach is to analyse the references to the state variables by {{the operations of the}} system. Those variables that are referenced/modified together are likely candidates for forming the state of a module. We evaluate the strategy by applying it to a large Z specification of a <b>language-based</b> <b>editor...</b>|$|E
40|$|User {{interface}} {{choices are}} vital {{to the success of}} <b>language-based</b> <b>editors.</b> This paper presents a case-study of some significant user interface choices made in the design of <b>language-based</b> <b>editors</b> for software development at the University of Queensland, and discusses the conceptual models on which the choices are based...|$|R
40|$|Knowledge of a {{programming}} language's grammar allows <b>language-based</b> <b>editors</b> {{to enforce}} syntactic correctness {{at all times}} during development by restricting editing operations to legitimate modifications ot ~ the program's context-free derivation tree; however, not all language constraints can be enforced in this way because not all features can be described by the context-free formalism. Attribute grammars permit context-dependent language features to be expressed in a modular, declarative fashion and thus are a good basis for specifying <b>language-based</b> <b>editors.</b> Such editors represent programs as attributed trees, Which are modified by operations such as subtree pruning and grafting. Incremental analysis is performed by updating attribute values after every modification. This paper discusses how updating {{can be carried out}} and presents several algorithms for the task, including one that is asymptotically optimal in time...|$|R
50|$|Abstract-Type and Scheme-Definition Language (ASDL) is a {{computer}} language developed as part of ESPRIT project GRASPIN, {{as a basis for}} generating <b>language-based</b> <b>editors</b> and environments. It combines an object-oriented type system, syntax-directed translation schemes and a target-language interface.|$|R
40|$|This study {{examines}} {{the relevance of}} user interface design guidelines, such as the extensive set developed by Smith and Mosier (1986), to the relatively sophisticated user interface of an existing <b>language-based</b> <b>editor.</b> The aims {{of the study were}} to ascertain the potential impact of the advice offered by the guidelines on this type of software product and to investigate whether any issues, relevant to this and future versions of the editor, were not addressed by the guidelines...|$|E
40|$|The authors {{present the}} Abstract-Type and Scheme-Definition Language (ASDL), a new {{formalism}} and environment kernel. The main {{goal of this}} object-oriented kernel is to reconcile integration and extensibility. ASDL adopts the ideas underlying <b>language-based</b> <b>editor</b> generators but overcomes their extensibility deficiencies. ASDL combines an object-oriented type system with syntax-directed translation schemes and a target-language interface. Its power lies in utilizing inheritance for structure-driven computations. The authors discuss object types, translation rules, and semantic information in ASDL...|$|E
40|$|This {{technical}} report {{consists of an}} M. S. thesis that presents {{the development of a}} technology for integrating language-based editors with existing tools, whereby the editor and tools operate as cooperating processes communicating via message passing. The thesis describes the validation of this technology with the design and implementation of A Manufacturing Programming En-vironment (AMPE), which integrates an ALOE <b>language-based</b> <b>editor</b> for AMUX with the AMl) X interpreter. The dissertation includes the user manual for AMPE as an appendix. AMPE was funded by IBM Contract # 703013, Research in Robotics and Manufacturing...|$|E
40|$|User {{interface}} {{choices are}} vital {{to the success of}} software use by skilled users, such as software engineers themselves. This paper presents a case-study of some significant user-interface choices made in the design of <b>language-based</b> <b>editors</b> for software development at the University of Queensland, and discusses the difficulties perceived in their validation...|$|R
40|$|We {{present an}} {{incremental}} semantic analysis strategy {{for use in}} <b>language‐based</b> <b>editors.</b> Its advantage is the low storage cost involved in achieving incremental semantic operation with a relatively small loss in response. The scheme, which involves limiting identifier attribute flow, is first described for a simple block‐structured language like Pascal, and then extended to more modern modular languages. Copyrigh...|$|R
40|$|This {{technical}} report {{consists of three}} related papers {{in the area of}} distributed programming environments. Incremental Attribute Evaluation in Distributed Language-Based Environments presents algorithms that extend existing technology for the generation of single-user <b>language-based</b> <b>editors</b> from attribute grammars to the cases of multiple-user concurrent and distributed environments. Multi-User Distributed Language-Based Environment, an extended abstract, provides additional information on how to apply the algorithms. Reliability in Distributed Programming Environments presents additional algorithms that extend our results to unreliable networks...|$|R
40|$|This paper {{describes}} {{the design and}} implementation of an interactive, incremental-attribution-based program transformation system, CACHET, that derives incremental programs from non-incremental programs written in a functional language. CACHET is designed as a programming environment and implemented using a <b>language-based</b> <b>editor</b> generator, the Synthesizer Generator, with extensions that support complex transformations. Transformations directly manipulate the program tree and take into consideration information obtained from program analyses. Program analyses are performed via attribute evaluation, which is done incrementally as transformations change the program tree. The overall approach also explores a general framework for describing dynamic program semantics using annotations, which allows interleaving transformations with external input, such as user input. Designing CACHET as a programming environment also facilitates the integration of program derivation and validation with inte [...] ...|$|E
40|$|Abstract {{visualisation}} {{of software}} documents {{is a powerful}} tool for software comprehension. A good software visualisation tool should provide the user with the flexibility to define new visualisations as they are required and powerful navigation facilities within visualisations that convey the structures and relationships inherent in the underlying software documents. We argue that software visualisation is inherently part of the creative process and therefore, where possible, it is desirable to allow the user to manipulate the underlying documents via visualisations. In this paper we describe how the UQ* software development environment and, in particular, the associated generic <b>language-based</b> <b>editor</b> provides for: the flexible definition of software visualisations; powerful navigation facilities that are common to both the software visualisations and the actual software documents; and the manipulation of appropriate content within such visualisations. We note some shortcomings of the [...] ...|$|E
40|$|The {{choice between}} tree-building and text-recognition {{paradigms}} {{has been an}} issue in <b>language-based</b> <b>editor</b> design over the past decade, with much intuitive comment appearing in the literature. To {{the best of our}} knowledge, however, no systematic attempt to demonstrate the advantage of either paradigm, by application of relevant theories or by controlled experimental evaluation, has been attempted. The problem is complicated by the interaction of several factors - in addition to the user's conceptual model of a structured document, factors such as the error discipline to be applied, the model bias produced by textual display, and the adequacy of implementation of the text-recognition approach, have all to be taken into account. In this theoretical study we analyse and compare various editing tasks undertaken by software engineers. The Keystroke Level Model (KLM) is used to assess the efficiency of the paradigms...|$|E
40|$|This paper {{reviews the}} design issues {{that arise in}} the {{construction}} of effective <b>language-based</b> <b>editors</b> for the preparation of syntactically and static semantically correct language sentences, typically computer programs. The need for such editors to support a pluralistic view of program structure is identified, together with the need to observe the constraints on performance and storage consumption if such editors are to be accepted by professional programmers. From these basic needs, more specific requirements for the display, parsing and semantic checking components of such an editor are derive...|$|R
40|$|We {{have been}} {{concerned}} for some time {{with the lack of}} rigorous experimental evaluation of design options chosen for tools used by software engineers. In a series of studies using various evaluation techniques we built Keystroke-Level Models (KLM) and conducted an empirical usability study of a design issue (choice of editing paradigm for <b>language-based</b> <b>editors)</b> that has reached a 'subjective stalemate' in the research community. The KLM analysis enabled us to predict usage differences and while this was useful we also noticed several problems, in particular we were concerned about the estimated value and placement of the memory operator. By utilizing the same tasks in the usability study as in the KLM analysis, we were able to compare results from both evaluations and effectively validate the overall KLM estimates and the specific operator values involved...|$|R
40|$|Tree transformations offer a {{convenient}} method to describe various manipulations that are commonly performed by compilers and <b>language-based</b> <b>editors.</b> Many of the compiler stages, such as semantic analysis, code optimization, and code generation [Pelegri-Llopart 1988], are frequently specified as {{a sequence of}} tree transformations that transform parse tree into output representation (e. g. machine language). Similarly, structured-document environments, such as Ensemble [Dennis et al. 1995], can benefit {{from the use of}} tree transformations to convert parse trees to abstract syntax trees (and vice versa, given sufficient information for the reverse transformation), compute presentation-trees, etc. In this paper, we describe design and implementation of tree transformation subsystem in Ensemble environment. Ensemble (presently a research prototype) provides to the user a number of document services (including incremental analysis, revision management, presentation, etc.), simplifying the t [...] ...|$|R
40|$|Existing {{tools for}} {{software}} development by formal methods lack user-oriented properties necessary to their effective use in software engineering. We propose {{a strategy for}} overcoming these deficiencies by interposing a user-oriented front-end editor between the user and the formal method tool itself. We demonstrate the feasibility of this approach by adapting an existing generic <b>language-based</b> <b>editor</b> to provide a frontend to an existing theorem prover. To cater for {{the full range of}} structures which arise in formal methods, we propose to define a generic model of formal method documents and to develop a corresponding front-end editor for such documents which is capable of real-time interaction with a corresponding variety of tools supporting formal methods. 1 Introduction Software development by formal methods must be seen as an advanced form of computer-aided software engineering. Development by such methods involves an overwhelming amount of technical and managerial detail in gener [...] ...|$|E
40|$|As part of {{a project}} {{with the aim of}} scaling up formal methods, we have {{developed}} a library construct for the specification language Z. This paper reports on the result of using libraries to structure a specification of a relatively complicated parser for a <b>language-based</b> <b>editor.</b> The parser is complicated by the need to cope with multiple languages as well as tolerate errors in the input. Our goal in producing the specification of the parser has been to separate each of the major concepts on which the specification is based (eg, multiple languages and error-tolerance) into a separate library. To achieve the separation of concerns we have applied the novel technique of specifying each of the major concepts of the parser as grammar transformations. The full parser can then be specified by composing the separate transformations to give a grammar incorporating all the desired features. 1 Introduction In working towards a suitable framework for writing large specifications we have devel [...] ...|$|E
40|$|In program {{visualization}} {{some form}} of graphics is used to represent some aspect of a program. However, graphics are necessarily expensive with respect to 'screen real estate'. Alternatives, therefore, may be required for presentation of certain concepts fundamental to the programmer's model of a program. For example, one graphical representation of a program, written in a block-structured language like Pascal or Modula- 2, is the structure chart model of the hierarchical structure of the blocks or modules making up the program. This graphic {{may be the most}} appropriate {{but it may not be}} conveniently implemented as a menu and a means of 'directly' selecting blocks of program code to view or edit. Such graphics are used extensively, for example, in the Garden environment developed at Brown University. An alternative is a text-based list of block names indented to summarize the program's structure. UQ 1, a <b>language-based</b> <b>editor</b> developed at the University of Queensland, implements the concept in this manner. Both types of menu structure were examined and compared for efficiency in a direct manipulation style of interaction. In general, there was no significant difference (P > 0. 05) in time taken by subjects to select items from either style of menu...|$|E
40|$|Attribute grammars are a {{valuable}} tool for constructing compilers and building user interfaces. This paper reports on a system we are developing, called AML (for Attribution in ML), which is an attribute grammar toolkit for building such applications as language-based programming environments using SML. This system builds on the proven technology of efficient attribute evaluation, while using a higher-level foundation {{for the implementation of}} interactive systems. It supports a general and uniform platform for building applications that can manipulate attributed terms and allow access to attribute values. We describe the design of the AML system, its current implementation status, and our plans for the future. 1 Introduction Attribute grammars provide a formalism for assigning meaning to parse trees of a context-free language [Knu 68]. Because of their syntax-directed form and declarative style, they provide a useful notation for specifying compilers [KHZ 82] and <b>language-based</b> <b>editors</b> [...] ...|$|R
40|$|<b>Language-based</b> <b>editors</b> (LBE’s) for {{programming}} languages are central components of Interactive Programming Environments (IPE’s). These editors incorporate knowledge about programming languages {{in order to}} make program construction less difficult. They may also serve as gateways to the IPE, structuring programs as objects amenable to manipulation and control by the IPE. This paper describes Syned, a prototype LBE which runs under the UNIX * operating system. Syned accepts the full C language, except for some pre-processor statements, and allows free and unrestricted intermixing of parsing and menu selection in the creation of programs. It offers a powerful editor control language and a highly flexible, extendable menu system. Syned can be configured to accept other languages in addition to C. This paper is primarily concerned with LBE’s as program editors rather than as IPE input gateways. However, some aspects of Syned as an IPE gateway are discussed. 1...|$|R
40|$|We {{have been}} {{concerned}} for some time {{with the lack of}} rigorous experimental evaluation of design options chosen for tools used by software engineers. In a series of studies of various evaluation techniques we conducted an empirical usability study of a design issue (choice of editing paradigm for <b>language-based</b> <b>editors)</b> that has reached a "subjective stalemate" in the research community. This usability study, although limited to some extent by sample size and user type, has shown little advantage to either tree-building or text-recognition and probably indicated that some hybrid of the two is most appropriate. KEYWORDS: usability study, languagebased editors. 1 INTRODUCTION Two basic paradigms for editing are commonly associated with language-based editors: treebuilding and text-recognition. Briefly, with the tree-building paradigm the user is only allowed operations that ensure the structural correctness of the program tree at all times. To extend a program the user selects a templa [...] ...|$|R
40|$|Attributed {{context-free}} grammars {{provide a}} rigorous {{basis for the}} semantic analysis and translation of tree-structured objects and {{have been used to}} build a variety of systems. A number of programming language compiler, compiler generators, and <b>language-based</b> <b>editor</b> generators employing attribute grammars have been described in the literature. Many of these systems make use of l-ordered attribute grammars, attribute grammars for which particularly efficient methods for attributing derivation trees have been described. Derivation trees representing constructs of only moderate size may contain thousands of nodes {{and tens of thousands of}} attribute instances, and attribution of such trees on uniprocessor systems may require a significant amount of time. One possibility for reducing this time is to find techniques that exploit opportunities for parallelism in the attribution process and allow attribution to be performed on multiprocessor systems. Such techniques would permit attribute grammars to serve as a rigorous foundation for the development of parallel compilation systems and other parallel applications. We present several methods for the parallel attribution of trees derived from l-ordered attribute grammars. These methods take advantage of parallelism implicit in the attribution process and, thus, do not require any special considerations to be taken when constructing grammars. Methods appropriate for use on tightly - and loosely-coupled multiprocessor architectures and for use when complete and incremental tree attribution are required are presented. We present preliminary performance results obtained from implementations of some of the methods on a simple shared-memory multiprocessor simulator embedded within an attribute grammar-based editor generator system. The results suggest that the methods may provide useful reductions in attribution time in some cases...|$|E
40|$|This thesis {{concerns}} {{the design of}} interactive, language-based programming environments that use knowledge of a programming language to provide functions based on the structure and meaning of programs. The goal of the research is a system-constructor to enable editors for different languages to be created easily. The most challenging aspect of such a system is {{the design of the}} semantic component, because a <b>language-based</b> <b>editor</b> performs static semantic analysis when a program is altered in order to detect erroneous constructions or to prevent illegal modifications. For efficiency, this should be performed incrementally, re-using as much old information as possible; therefore, a major focus of my research concerns a model of editing for which it is possible to perform incremental semantic analysis efficiently. In this model, a program is represented as an attributed tree in which all attributes have consistent values; programs are modified by tree operations such as pruning, grafting, and deriving. After each modification, some of the attributes require new values; incremental semantic analysis is performed by updating attribute values to again make them all consistent. The thesis presents several algorithms for this process that are asymptotically optimal in time. The chief disadvantage of attribute grammars is that they use large amounts of storage. The thesis discusses three aspects of utilizing storage efficiently in such systems. One way {{to reduce the amount of}} storage used is to reduce the number of atttribute values retained at any stage of attribute evaluation. The thesis establishes two results concerning this idea: it presents one algorithm for evaluating an n-attribute tree that never saves more than O(√(n) attribute values, and it presents a second algorithm that never saves more than O(n) attribute values. A second method for reducing the amount of storage is to share the space used for storing attributes whose values are complex data structures; the thesis presents a very general method for such sharing that can be applied to attributes of many types. Finally, the thesis describes how, by restricting the class of attribute grammars, it is possible to reduce the amount of storage overhead required for updating trees in optimal time...|$|E
40|$|A {{specification}} of a software program, hardware component, or system, is {{a description of}} what the system is required to do without describing how {{it is to be}} done. Specifications provide the necessary details for system developers, suppliers, users and regulators to understand and agree upon the requirements of a system. It is therefore vital that specifications are clear, concise, complete, and are free of ambiguity and inconsistency. Specifications are usually expressed using a combination of informal natural language descriptions, diagrams, and formal mathematical techniques. The degree to which formal mathematics is used depends {{on the nature of the}} application and the criticality of the function being described. In industries where the cost of a system or software failure is high, such as national defence and government, banking, transport, energy, and communication, and some manufacturing industries, formal specification is recommended because it offers greater clarity and consistency, and moreover, formal specification are machine readable, allowing some automated checking to be applied. However, poorly written formal specifications can be less useful than informal specifications if they are unreadable (or not clear), or if they are overly large or complex (or not concise), making it hard to determine whether they are consistent or complete. In particular, if the system itself is large or complex, or it features multiple and diverse aspects of behaviour, it can be difficult to capture all aspects of its behaviour clearly and concisely in a monolithic formal model, or within a single formal notation. In many cases this is because the modeling approach may be particularly suited to some aspects of the system but not to others. The widely accepted solution to this problem is to use diverse modeling techniques to specify the different aspects of the system from different viewpoints. This results in a number of view specifications that taken together make up the complete {{specification of}} the system. The thesis introduces structuring mechanisms for the formal specification language Z that allow the view specifications of a system to be described, combined and reused. Specification encapsulation and parameter abstraction and application are explored along with object-oriented concepts such sub-typing and sub-classing. Two case studies, which are based on a <b>language-based</b> <b>editor</b> and a database system, are provided to illustrate how the techniques developed in this thesis may be used...|$|E
40|$|Approved {{for public}} release; {{distribution}} is unlimitedThe formal specification language Spec {{is used for}} writing black-box specifications for large software systems. These black-box specifications describe the interface beteen a system and its users, as well as internal interfaces between modules. Systems analysts use specifications written in Spec to verify the customer's requirements during {{the development of a}} software system. This thesis demonstrates the feasibility of designing and implementing a syntax directed editor for a subset of the specification language Spec. The editor is a software tool for writing Spec specifications that ensures syntactic correctness of such specifications. The syntax directed editor is created using the Synthesizer Generator, a Computer-Aided Software Engineering (CASE) tool for generating <b>language-based</b> <b>editors.</b> The specification for the editor is written in the Synthesizer Specification Language (SSL) which is based on an attribute grammar. The software tool developed in this thesis supports the Requirements Analysis phase of the software development cycle. [URL] Commander, United States Nav...|$|R
40|$|This {{thesis is}} {{concerned}} with design options for user interfaces for <b>language-based</b> <b>editors</b> {{and in particular the}} evaluation of these options where competing choices are available. Most design and evaluation within this domain is based on the intuition and experience of the designers. Tool designers consider themselves typical users of the tools that they design and tend to subjectively evaluate their products rather than seek the views of their colleagues or indeed the potential users of those products. We consider this approach inadequate if the quality of software tools is to improve and we advocate the use of more systematic methods. Four studies have been conducted as part of this research project. All four show how user interface design choices for software development tools can be evaluated using methods not routinely applied in this domain. Firstly we conducted a study of the application of user interface design guidelines by examining their use in a retrospective evaluation o [...] ...|$|R
40|$|In many situations, {{embedded}} menus {{represent an}} attractive {{alternative to the}} more traditional explicit menus, particularly in touchtext, spelling checkers, <b>language-based</b> program <b>editors,</b> and graphics-based systems. When compared to command driven systems, computer menu systems are appealing because they reduce memorization of commands, reduce training, and structure the user’s decision making. Menus can be categorized as either embedded or explicit (Koved, 1984), the difference being {{the context in which}} the menu items are presented...|$|R
40|$|Incremental parsing {{has long}} been {{recognized}} as a technique of great utility {{in the construction of}} <b>language-based</b> <b>editors,</b> and correspondingly, the area currently enjoys a mature theory. Unfortunately, many practical considerations have been largely overlooked in previously published algorithms. Many user requirements for an editing system necessarily impact on the design of its incremental parser, but most approaches focus only on one: response time. This paper details an incremental parser based on LR parsing techniques and designed for use in a modeless syntax recognition editor. The nature of this editor places significant demands on the structure and quality of the document representation it uses, and hence, on the parser. The strategy presented here is novel in that both the parser and the representation it constructs are tolerant of the inevitable and frequent syntax errors that arise during editing. This is achieved by a method that differs from conventional error repair techniques, and that is more appropriate for use in an interactive context. Furthermore, the parser aims to minimize disturbance to this representation, not only to ensure other system components can operate incrementally, but also to avoid unfortunate consequences for certain user-oriented services. The algorithm is augmented with a limited form of predictive tree-building, and a technique is presented for the determination of valid symbols for menu-based insertion. Copyright (C) 2001 John Wiley & Sons, Ltd...|$|R
40|$|Evolution towards {{specifications}} environment: {{experiences with}} syntax <b>editors</b> <b>Language-based</b> <b>editors</b> have been thoroughly studied {{over the last}} 10 years and {{have been found to}} be less effective than orig-inally thought. The paper reviews some relevant aspects of such editors, describes experiences with one such editor (Support), and then describes two current projects that extend the syntax-editing paradigm to the specifications and design phases of the sol?ware life-cycle. software design, environments, specification, syntax editors SYNTAX EDITORS Syntax-editing (or alternatively language-based editing) is a technique that had its beginning about 20 years ago (e. g., Emily I) and blossomed into a major research activity 10 years later (e. g., Mentor % CPS 3) [...] During the mid- 1980 s, major conferences were often dominated by syntax-editing techniques 4,s. Many of these projects, however, have since been terminated or have taken a much lower profile. There are few widely used commer-cial products that use this technology. Why? This paper briefly introduces the concept of syntax editing, describes one particular editor, and explains some experiences in using it. It is then shown how the syntax-editing paradigm is powerful but perhaps misap-plied in the domain of source-program generation. Just using a syntax editor for source-code production does not result in significantly higher productivity. By integrating specification generation with this source-code production, however, the author believes that increased productivity can be provided by making more of the life-cycle visible to the programmer. Two extensions to the current environment are described that apply syntax editing within a specifications environment to provide additional functionality over that of standard syntax editors. With a conventional editor, the user may insert an arbitrary string of characters at any point in a file, and a later compilation phase will determine if there are any errors. With a syntax editor, however, only those choice...|$|R
40|$|UQ* is a {{software}} development environment that maintains documents described and represented {{in terms of}} their underlying syntactic structure. By providing for the expression of arbitrary relationships between syntactic elements that constitute documents, it also maintains relationships within and between documents in the environment. Currently the only mechanism to manipulate documents is via a recognition based text editor. A natural extension to the environment is the inclusion of a diagram editor whose functionality and capabilities are analogous with that of the text editor. In this propose a generic, <b>language-based</b> diagram <b>editor</b> for the UQ* environment, and describe how a combination of syntactic and relational structures can be used as the underlying representation of documents which are traditionally presented as diagrams. The viability of the proposal is illustrated by a detailed case study involving data-flow diagrams. The results of the case study are a detailed description of a relational and syntactic representation for data-flow diagrams and a discussion of some of the resulting consequences for the end user...|$|R
40|$|The {{constant}} {{improvements in}} device integration, {{the development of}} new technologies and the emergence of new design techniques call for flexible, maintainable and robust software tools. The generic nature of compiler-compiler systems, with their semi-formal specifications, can help in the construction of those tools. This thesis describes the Wright editor generator which is used in the synthesis of <b>language-based</b> graphical <b>editors</b> (LBGEs). An LBGE is a programming environment where the programs being manipulated denote pictures. Editing actions can be specified through both textual and graphical interfaces. Editors generated by the Wright system are specified using the formalism of attribute grammars. The major example editor in this thesis, Stick-Wright, is a design entry system for the construction of VLSI circuits. Stick-Wright is a hierarchical symbolic layout editor which exploits a combination of text and graphics in an interactive environment to provide the circuit designer with a tool for experimenting with circuit topologies. A simpler system, Pict-Wright: a picture drawing system, is also used to illustrate the attribute grammar specification process. This thesis aims to demonstrate the efficacy of formal specification in the generation of software-tools. The generated system Stick-Wright shows that a text/graphic programming environment can form the basis of a powerful VLSI design tool, especially with regard to providing the designer with immediate graphical feedback. Further applications of the LBGE generator approach to system design are given for a range of VLSI design activities...|$|R

