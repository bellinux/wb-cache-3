8|10000|Public
40|$|Most current {{approaches}} to concurrency control in database systems rely on <b>locking</b> <b>of</b> <b>data</b> objects {{as a control}} mechanism. In this paper, two families of nonlocking concurrency controls are presented. The methods used are “optimistic ” {{in the sense that}} they rely mainly on transaction backup as a control mechanism, “hoping ” that conflicts between transactions will not occur. Applications for which these methods should be more efficient than locking are discussed...|$|E
3000|$|... (i) {{the study}} {{revealed}} five case study commonalities: disk space reduction, use of locking, low cloud resource consumption, customization {{and use of}} plugin architecture, and choice of multi-tenancy pattern. Two of these factors {{have a negative impact}} on tenant isolation. The degree of isolation is reduced when there no strategy to reduce disk space and customization and plugin architecture is not adopted. In contrast, the degree of isolation improves when careful consideration is given to handling a high workload, <b>locking</b> <b>of</b> <b>data</b> and processes is used to prevent clashes between multiple tenants, data transfer between repositories and selection of appropriate multi-tenancy pattern. (see “Results” section).|$|E
40|$|AbstractÐThis paper formalizes {{the concept}} of {{similarity}} which has been used on an ad hoc basis by application engineers to provide more flexibility in concurrency control. We show how the usual correctness criteria of concurrency control, namely, final-state, view, and conflict serializability, can be weakened to incorporate similarity. We extend the weakened correctness criteria in [16] for real-time applications which may run continually, have concurrent transaction executions, or skip unimportant computations. A semantic approach based on the similarity concept is then taken to propose a sufficient condition for scheduling real-time transactions without <b>locking</b> <b>of</b> <b>data.</b> Index TermsÐConcurrency control, schedule correctness, real-time database, serializability, similarity. æ...|$|E
40|$|Abstract—In {{this paper}} {{simulation}} models <b>of</b> two-phase <b>locking</b> in distributed database systems are presented. A mechanism of timestamp ordering (―wait – die ‖ method) {{is embedded in}} the modeling algorithms to prevent deadlocks. The results of running model of Centralized, Distributed and Primary copy Two-phase locking algorithms are gathered and analyzed and represented. The main characteristics of transaction processing in distributed database management systems such as throughput, response time and probability service are given. If Тi is “younger ” then Тj (TS(Ti) > TS(Tj)), transaction Тi restarts. The algorithm <b>of</b> <b>lock</b> manager handling transaction Ti, and its requesting <b>locking</b> <b>of</b> the <b>data</b> element х is shown on fig. 1. Index Terms — Simulation models, GPSS transactions...|$|R
40|$|We {{describe}} the compiler analyses of Reform Prolog and evaluate their effectiveness in eliminating suspension and locking {{on a range}} of benchmarks. The results of the analysis may also be used to extract non-strict independent and-parallelism. We find that 90 % of the predicate arguments are ground or local, and that 95 % of the predicate arguments do not require suspension code. Hence, very few suspension operations need to be generated to maintain sequential semantics. The compiler can also remove unnecessary <b>locking</b> <b>of</b> local <b>data</b> by <b>locking</b> only updates to shared data; however, even though locking writes are reduced to 52 % of the unoptimized number for our benchmark set, this has little effect on execution times. We find that the ineffectiveness <b>of</b> <b>locking</b> elimination is due to the relative rarity <b>of</b> <b>locking</b> writes, and the execution model of Reform Prolog, which results in few invalidations of shared cache lines when such writes occur. The benchmarks are evaluated on a cache-coherent [...] ...|$|R
40|$|Developing an ecient {{parallel}} simulation framework for multiprocessor systems is hard. A primary {{concern is the}} considerable amount of parallelization overhead imposed on the event handling routines of the simulator. Besides complex event scheduling algorithms, the main sources of overhead are thread synchronization and <b>locking</b> <b>of</b> shared <b>data.</b> Thus, compared to sequential simulation, the overhead of parallelization may easily outweigh its performance benets. We introduce two ecient event handling schemes based on our parallel-simulation extension Horizon for OMNeT++. First, we present a push-based event handling scheme to minimize the overhead of thread synchronization and locking. Second, we complement this scheme with a novel event scheduling algorithm that signicantly reduces the overhead of parallel event scheduling. Lastly, we prove the correctness of the scheduling algorithm. Our evaluation reveals a total reduction of the event handling overhead of up to 16 x. QC 20140102 </p...|$|R
30|$|The cross-case {{analysis}} revealed five case study commonalities: disk space reduction, use of locking, low cloud resource consumption, customization {{and use of}} plug-in architecture, and choice of multi-tenancy pattern. The degree of isolation is reduced when there no strategy to reduce disk space and customization and plug-in architecture is not adopted. The degree of isolation improves when careful consideration is given to {{how to handle a}} high workload, <b>locking</b> <b>of</b> <b>data</b> and processes is used to prevent clashes between multiple tenants, data transfer between repositories and selection of appropriate multi-tenancy pattern. The study also revealed five differences: size of generated data, cloud resource consumption, sensitivity to workload changes, the effect of the software process, client latency and bandwidth, and type of software process). The large size of generated data, high resource consumption processes, high or fluctuating workload, low client latency, and bandwidth when transferring multiple files between repositories reduces the degree of isolation. The type of software process is challenging because it depends on the cloud resource being optimised.|$|E
30|$|Cassandra {{has been}} {{recognized}} {{for its ability to}} handle large numbers of write requests [19], and therefore architecture characteristics contributing to Cassandra’s write scalability are highlighted. Although the storage structure in typical relational databases and a number of NoSQL data stores including MongoDB and CouchDB relies on a B-Tree, Cassandra takes advantage of a log-structured merge tree. When a write occurs, Cassandra stores the changes in two places: in the memory structure called memtable, and in the commit log on disk by appending to the existing data. When the memtable reaches a threshold, the memtable data are flashed to SSTables (sorted string tables) on disk, and data in the commit log corresponding to the flushed memtable are purged. When flashing the memtable, Cassandra writes entire sectors to disk using sequential I/O instead of modifying rows in place. This approach eliminates <b>locking</b> <b>of</b> <b>data</b> on disk for concurrency control because write operations only append data and do not modify existing data on disk. Consequently, Cassandra is especially suitable for applications with high write volume or those that require very fast writes.|$|E
40|$|This paper {{presents}} general algorithms for {{concurrency control}} in tree-based access methods {{as well as}} a mcove ~ protocol and a mechanism for ensuring repeatable read. The algorithms arc developed {{in the context of the}} Generalized Search Tme (GiST) data structure, an index structure supporting an extensible set of queries and data types. Although developed in a GiST contexL the algorithms are generally applicable to many tree-based access methods. The concurrency control protocol is based on an extension of the link technique originally developed for B-trees, and completely avoids holding node locks during I/Os. Repeatable mad isolation is achieved with a novel combination of predicate locks and two-phase <b>locking</b> <b>of</b> <b>data</b> records. To our knowledge, this is the first time that isolation issues have been addressed outside the context of B-trees. A discussion of the fundamental structural differences between Btrees and more general We stntctures like GiSTs explains why the algorithms developed here deviate from their B-tree counterparts. An implementation of GiSTs emulating B-trees in DB 2 /Common Server is underway. ...|$|E
50|$|In {{one of the}} few {{electrophysiology}} studies {{performed on}} A lineatus, it was found that of all the primary afferents from neuromasts that they recorded, half phase-locked to wave stimuli. These neurons had weaker ongoing activity than non-phase-locked neurons. With waves of decreasing amplitude, phase-locking also decreased. Phase-locking was best in the 40-70 Hz range or in the 80-100 Hz range. Within a neuromast different afferents phase-locked best to waves of different frequencies and amplitudes, and they found no correlation between a unit’s dynamic amplitude range and its ability to phase <b>lock.</b> Analysis <b>of</b> <b>data</b> revealed that wave amplitude of waves was encoded in the degree of phase-locking and in the afferent’s firing rate. Since this was the extent of the feature representation found, it was concluded that further analysis of waves must happen at higher levels in the nervous system.|$|R
40|$|International audienceData {{structures}} with relaxed balance eases {{the update}} of shared resources on asynchronous parallel architectures. This improvement is obtained by a better <b>locking</b> scheme <b>of</b> the <b>data</b> structure. In this paper, {{we describe the}} complexity and analyze the worst case cost of access operations on such a structure. We propose a data structure with the same properties as Java TreeMap but implemented with chromatic search tree; a tree with relaxed balance. The aim of our structure {{is to provide a}} more efﬁcient TreeMap we can use in concurrent and real-time applications...|$|R
40|$|This paper {{addresses}} {{the problem of}} coordinating a team of software developers concurrently working on a common software system. The standard approach to coordinate concurrent activities on a common set <b>of</b> <b>data</b> is <b>locking.</b> Any part <b>of</b> <b>data</b> used by one person is locked against concurrent use by another person. The second person has {{to wait until the}} first person has finished his or her task and releases the lock. In databases, sophisticated locking and transaction concepts minimize the waiting times for concurrent users by offering different lock granularities and different locking levels (e. g. multiple read locks vs. single write locks). However, these locking strategies assume that locks are hold for relatively short times (some seconds), only. In software development [...] ...|$|R
30|$|A challenge, when {{implementing}} multi-tenancy in a cloud-hosted software service, is how {{to ensure}} that the performance and resource consumption of one tenant does not adversely affect other tenants. Software designers and architects must achieve an optimal degree of tenant isolation for their chosen application requirements. The objective of this research is to reveal the trade-offs, commonalities, and differences to be considered when implementing the required degree of tenant isolation. This research uses a cross-case analysis of selected open source cloud-hosted software engineering tools to empirically evaluate varying degrees of isolation between tenants. Our research reveals five commonalities across the case studies: disk space reduction, use of locking, low cloud resource consumption, customization and use of plug-in architecture, and choice of multi-tenancy pattern. Two of these common factors compromise tenant isolation. The degree of isolation is reduced when there is no strategy to reduce disk space and customization and plug-in architecture is not adopted. In contrast, the degree of isolation improves when careful consideration is given to how to handle a high workload, <b>locking</b> <b>of</b> <b>data</b> and processes is used to prevent clashes between multiple tenants and selection of appropriate multi-tenancy pattern. The research also revealed five case study differences: size of generated data, cloud resource consumption, sensitivity to workload changes, the effect of the software process, client latency and bandwidth, and type of software process. The degree of isolation is impaired, in our results, by the large size of generated data, high resource consumption by certain software processes, high or fluctuating workload, low client latency, and bandwidth when transferring multiple files between repositories. Additionally, this research provides a novel explanatory framework for (i) mapping tenant isolation to different software development processes, cloud resources and layers of the cloud stack; and (ii) explaining the different trade-offs to consider affecting tenant isolation (i.e. resource sharing, the number of users/requests, customizability, the size of generated data, the scope of control of the cloud application stack and business constraints) when implementing multi-tenant cloud-hosted software services. This research suggests that software architects {{have to pay attention to}} the trade-offs, commonalities, and differences we identify to achieve their degree of tenant isolation requirements.|$|E
40|$|Most high {{performance}} scientific components or applications are implemented as parallel programs operating on physically or logically distributed data. As {{we consider the}} interaction between such components two major issues arise: (1) the definition of what exactly it means for two parallel components to interact, for example in terms of synchronization, and (2) how those components can most efficiently exchange the distributed data they operate on. Since both are common and important significant efforts have been expanded to implement them efficiently. Many of those efforts were, and still are, undertaken by applications developers (see [Cou 99] for an example). Several {{attempts have been made}} to develop generic frameworks solving this problem; [FKKCSCi, KG 97 a, BFHM 98, GKP 971] have all addressed its aspects. Unfortunately, all of these solutions are limited to a set of applications that have fallen within the scope of experience of their developers, and therefore none of them have been fully successful in providing a general solution. Several factors influence the difficulty of producing a general solution. First, data redistribution depends on data representation which in applications is very often specific to an application. Therefore developing a standardized solution for distributed data transfer depends on developing a standardized data representation. Further, different systems assume different transfer logistics, such as timing of transfer, <b>locking</b> <b>of</b> <b>data,</b> and synchronization assumptions. Finally, the shape of abstractions in different systems depends on time and tolerance of different users. The Common Component Architecture (CCA) effort is promising with respect to addressing these challenges as it has already introduced a standardized system of interactions [AGG+ 99] and is in the process of defining standardized representations for distributed data. Furthermore, CCA builds on the sum of experiences of its participants. In this paper we summarize our most recent contributions to the CCA design process related to the interactions of parallel components, called collective components. We introduce the notion of a collectible port which is an extension of the CCA ports [AGG+ 99] and allows collective components to interact as one entity. This is a functionality not found in other existing standards of the day such as [OMG 95, Ses 97] and represents a significant extension of these standards. The usefulness and efficiency of similar abstractions has been shown in [KG 97 a, KG 97 b]. The abstraction described here, extends them in that it allows the programmer to define the performance/utility trade-off of his or her choice. We further describe a class of translation components, which translate between the distributed data format used by one parallel implementation, to that used by another. A well known example of such components is the MxN component which translates between data distributed on M processors to data distributed on N processors. We described its implementation in PAWS, and the supporting data structures. We also present a mechanism allowing the framework to invoke this component on the programmer's behalf whenever such translation is necessary freeing the programmer from treating collective component interactions as a special case. In doing that we introduce user-defined distributed type casts. Finally, we discuss our initial experiments in building complex translation components out of atomic functionalities. Since PAWS assumes a distributed memory model, our experiments are limited to dense rectilinear data. We describe a PAWS application to illustrate the results of this discussion...|$|E
40|$|This paper {{presents}} a scheme using the virtual machine concept for creating: 1) An environment {{for increasing the}} effectiveness of researchers who must use analytical, modeling systems and have complex data management needs; 2) A mechanism for multi-user coordination of access and update to a central data base; 3) A mechanism for creating an environment where several different modeling facilities can access the same data base; 4) A mechanism for creating an environment where several different and potentially incompatible data management systems can all be accessed by the same user models or facilities. The paper investigates and formalizes the performance implications of this scheme specifically directed at the question of response time degradation {{as a function of}} number of virtual machines, <b>of</b> <b>locked</b> time <b>of</b> the <b>data</b> base machine, and of query rate of the modeling machine...|$|R
5000|$|When {{disabling}} interrupts {{are used}} to prevent priority inversion, {{there are only two}} priorities: preemptible, and interrupts disabled. With no third priority, inversion is impossible. Since there's only one piece <b>of</b> <b>lock</b> <b>data</b> (the interrupt-enable bit), misordering locking is impossible, and so deadlocks cannot occur. Since the critical regions always run to completion, hangs do not occur. Note that this only works if all interrupts are disabled. If only a particular hardware device's interrupt is disabled, priority inversion is reintroduced by the hardware's prioritization of interrupts. In early versions of UNIX, a series of primitives named splx(0) ... splx(7) disabled all interrupts up through the given priority. By properly choosing the highest priority of any interrupt that ever entered the critical section, the priority inversion problem could be solved without <b>locking</b> out all <b>of</b> the interrupts. Ceilings were assigned in rate-monotonic order, i.e. the slower devices had lower priorities.|$|R
40|$|Accesses to {{shared data}} {{structures}} in multithreaded programs must be correctly synchronized to ensure data consistency and integrity. However, this synchronization between threads {{is a common}} source of performance problems in multithreaded applications. Lock-free data structures are an alternative to traditional synchronization methods that have potential for not only better performance and scalability, but better energy efficiency as well. This paper presents {{a study of the}} relationship between the performance and energy consumption <b>of</b> various lockfree <b>data</b> structures based on the compare-and-swap primitive. We give a head-to-head comparison <b>of</b> lock-free and <b>locking</b> implementations <b>of</b> three <b>data</b> structures executing set of highly contentious workloads. We compare the execution time, peak power and total energy consumption of each and explain these results with the help of hardware performance counters. Our results show that under these workloads, the lock-free variants often perform better and use less energy then their traditional locking implementations. 1...|$|R
40|$|The {{awareness}} {{of the importance of}} effective health information systems (HIS) has increased substantially and is reflected by many ongoing efforts of HISs reform in many developing countries. However, the one mostly mentioned obstacle for health information systems reform is Legacy Information Systems (LIS). The impacts of LIS in the reporting of routine health delivery services were studied in a participatory action research using case study sites in Tanzania and Mozambique. LIS impacts are on the process of introducing changes (reforms) on the HIS, and on everyday functioning of the HIS. LIS were determined to cause poor quality <b>of</b> health <b>data,</b> incomplete reporting <b>of</b> health <b>data,</b> and burden to health workers. The study recommends the Ministries of Health to relinquish the LIS. A demonstration on extracting and loading <b>of</b> <b>locked</b> health <b>data</b> on LIS to new health information software using extraction transformation and loading (ETL) software was performed...|$|R
50|$|Tropospheric signals {{exhibit a}} slow cycle of fading and will {{occasionally}} produce signals sufficiently strong for noise-free stereo, reception <b>of</b> Radio <b>Data</b> System (RDS) <b>data,</b> and solid <b>locks</b> <b>of</b> HD Radio streams on FM or noise-free, color TV pictures.|$|R
5000|$|In Victorian times, it {{was common}} for {{bereaved}} family members to keep <b>locks</b> <b>of</b> hair from deceased children or family members. These <b>locks</b> <b>of</b> hair were seen as mementos and served to comfort the surviving loved ones. These <b>locks</b> <b>of</b> hair were typically kept in lockets though small jars, {{and in some cases}} jewelry. Jewelry could include everything from bracelets, to earrings, as well as various types of brooches.|$|R
60|$|MACAIRE. None: it spoils your clothes. Now, see: {{you have}} keys {{and you have}} experience: up that stair and pick me the <b>lock</b> <b>of</b> that man's door. Pick me the <b>lock</b> <b>of</b> that man's door.|$|R
25|$|Picking: A thief may pick a <b>lock</b> <b>of</b> <b>locks</b> {{that require}} a keyhole.|$|R
40|$|Cutting off the <b>lock</b> <b>of</b> hair {{just before}} baptism takes place. This <b>lock</b> <b>of</b> hair is {{a badge of}} Hinduism. " Three young men squat on the ground next to a river. Another man cuts a <b>lock</b> <b>of</b> hair {{from one of the}} three {{squatting}} men. Another man sits in the background, farther down the bank of the river. This photograph is from an album prepared by W. K. Norton of The Pilgrims Mission, Benares [Vārānasi]...|$|R
50|$|Serpentine {{vines and}} flowing <b>locks</b> <b>of</b> gold.|$|R
5000|$|... #Caption: Stacked rock detail <b>of</b> <b>lock</b> wall <b>of</b> <b>Lock</b> 28 near White Haven, 2008 ...|$|R
50|$|Clay Township {{contains}} the unincorporated locale <b>of</b> <b>Lock</b> Seventeen., {{named for its}} location at the seventeenth <b>lock</b> <b>of</b> the Ohio Canal.|$|R
6000|$|... "Yes, and he {{has worn}} mine; and I have a <b>lock</b> <b>of</b> his hair, {{and he has}} a <b>lock</b> <b>of</b> mine; yet I don't believe he cares for them a bit. Oh, his heart is safe enough. If he has any, it isn't with me: that I know." ...|$|R
5000|$|An {{ancient and}} {{worldwide}} (e.g. China, Egypt, Thailand, Albania, Ukraine, India, Israel, etc.) pre-adolescent custom was to shave children's heads but leave a <b>lock</b> <b>of</b> hair (sometimes several locks) remaining on their heads. Upon reaching adulthood the <b>lock</b> <b>of</b> hair was usually cut off (see Rites of passage).|$|R
50|$|While she cannot get {{the formula}} from Cutter or Clancy, Patricia learns that the formula can be {{obtained}} through analysis <b>of</b> a <b>lock</b> <b>of</b> hair from the one person known to have used the hairspray, who {{turns out to be}} Clancy's secretary, Su Ling (Irene Tsu). As Patricia goes to work trying to cut off a <b>lock</b> <b>of</b> Su Ling's hair, Christopher spots her. Patricia is unable to get that <b>lock</b> <b>of</b> hair, but Christopher tells her that he too is truly working for Sir Jason, and has the proof to back up his claim.|$|R
40|$|A {{patient is}} {{described}} in whom loose bodies in the distal radio-ulnar joint caused intermittent <b>locking</b> <b>of</b> rotation of the forearm. Journal of Hand Surgery (British Volume, 1989) 14 B: 322 A mechanical block to supination causing <b>locking</b> <b>of</b> the forearm is a rare presenting complaint. We report a patient with loose bodies in the distal radio-ulnar joint causing intermittent <b>locking</b> <b>of</b> forearm rotation. Case report A 46 -year-old man of sedentary occupation presented following two episodes <b>of</b> pain and <b>locking</b> <b>of</b> his left wrist on pronation as he turned his forearm {{to look at his}} watch. The first attack settled within a few hours. The second episode, which occurred three weeks subse-quently, took two days to recover. On examination, he had a normal-looking wrist with a full range of movement...|$|R
5000|$|... #Caption: <b>Locks</b> <b>of</b> the Panama Canal during construction, 1913.|$|R
5000|$|... #Caption: The ship <b>locks</b> <b>of</b> the Nizhny Novgorod Hydroelectric Station ...|$|R
40|$|Abstract. Most ancient Chinese {{padlocks}} are key-operated locks with splitting springs, {{and partially}} keyless letter-combination locks. They can be character-ized {{based on the}} types <b>of</b> <b>locks,</b> the shapes <b>of</b> <b>locks,</b> the engravings <b>of</b> <b>locks,</b> the materials <b>of</b> <b>locks,</b> and the mechanisms <b>of</b> <b>locks.</b> Some locks and keys are not only very beautiful and artistic colorful, but also with various designs. As a result, a splitting spring padlock is an asymmetric key cryptosystem, and a combination padlock is a symmetric key cryptosystem. ...|$|R
50|$|The City Museum in Düsseldorf has a <b>lock</b> <b>of</b> her hair.|$|R
5000|$|... #Caption: The old {{staircase}} <b>of</b> seven <b>locks</b> <b>of</b> the Briare Canal ...|$|R
5000|$|<b>Locking</b> <b>of</b> Zonal Office of M.C.D, Rajouri Garden, Tis Hazari Court ...|$|R
