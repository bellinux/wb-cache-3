40|62|Public
25|$|Loop {{counters}} {{change with}} each iteration of a loop, providing a unique value {{for each individual}} iteration. The <b>loop</b> <b>counter</b> is used to decide when the loop should terminate and for the program flow to continue to the next instruction after the loop.|$|E
25|$|Unlike {{many other}} kinds of loops, such as the while-loop, the for-loop is often {{distinguished}} by an explicit <b>loop</b> <b>counter</b> or loop variable. This allows {{the body of the}} for-loop (the code that is being repeatedly executed) to know about the sequencing of each iteration. For-loops are also typically used when the number of iterations is known before entering the loop. For-loops are the shorthand way to make loops when the number of iterations is known, as every for-loop could be written as a while-loop.|$|E
25|$|A common {{identifier}} {{naming convention}} {{is for the}} <b>loop</b> <b>counter</b> to use the variable names i, j, and k (and so on if needed), where {{i would be the}} most outer loop, j the next inner loop, etc. The reverse order is also used by some programmers. This style is generally agreed to have originated from the early programming of FORTRAN, where these variable names beginning with these letters were implicitly declared as having an integer type, and so were obvious choices for loop counters that were only temporarily required. The practice dates back further to mathematical notation where indices for sums and multiplications are often i, j, etc. A variant convention is the use of reduplicated letters for the index, ii, jj, and kk, as this allows easier searching and search-replacing than using a single letter.|$|E
5000|$|Using variant {{data types}} as <b>loop</b> <b>counters</b> in Microsoft Visual Basic where an integer type is also available.|$|R
50|$|The chip {{featured}} {{much more}} than the 29,000 transistors of the simpler 8088 CPU, ran at 5 to 10 MHz and was around 30% faster (application dependent) than the 8088 at the same clock speed, primarily due to faster effective address calculation, along with faster <b>loop</b> <b>counters,</b> shift registers and multiplier.|$|R
50|$|Some designs, notably some Forth implementations, {{used two}} {{separate}} stacks, one mainly for control information (like return addresses and <b>loop</b> <b>counters)</b> {{and the other}} for data. The former was, or worked like, a call stack and was only indirectly accessible to the programmer through other language constructs while the latter was more directly accessible.|$|R
2500|$|An {{example of}} C code {{involving}} nested for loops, where the <b>loop</b> <b>counter</b> variables are i and j: ...|$|E
2500|$|In {{computer}} programming a <b>loop</b> <b>counter</b> is the variable {{that controls the}} iterations of a loop (a {{computer programming}} language construct). [...] It is so named because most uses of this construct result in the variable taking {{on a range of}} integer values in some orderly sequences (example., starting at 0 and end at 10 in increments of 1) ...|$|E
50|$|Note that a <b>loop</b> <b>counter</b> is {{sometimes}} {{also referred to}} as a loop iterator. A <b>loop</b> <b>counter,</b> however, only provides the traversal functionality and not the element access functionality.|$|E
25|$|With {{all these}} {{definitions}} it is convenient to include0 (corresponding {{to the empty}} set) as a natural number. Including0 is now the common convention among set theorists and logicians. Other mathematicians also include0 although many have kept the older tradition and take1 {{to be the first}} natural number. Computer scientists often start from zero when enumerating items like <b>loop</b> <b>counters</b> and string- or array- elements.|$|R
50|$|A {{manifest}} {{expression is}} {{a programming language}} construct that a compiler can analyse to deduce which values it can take without having to execute the program. This information can enable compiler optimizations, in particular loop nest optimization, and parallelization through data dependency analysis. An expression is called manifest if it is computed only from outer <b>loop</b> <b>counters</b> and constants (a more formal definition is given below).|$|R
50|$|SSE2 extends MMX {{instructions}} {{to operate on}} XMM registers. Therefore, {{it is possible to}} convert all existing MMX code to an SSE2 equivalent. Since an SSE2 register is twice as long as an MMX register, <b>loop</b> <b>counters</b> and memory access may need to be changed to accommodate this. However, 8 byte loads and stores to XMM are available, so this is not strictly required.|$|R
50|$|As {{can be seen}} s.n acts as the <b>loop</b> <b>counter.</b>|$|E
5000|$|An {{example of}} C code {{involving}} nested for loops, where the <b>loop</b> <b>counter</b> variables are i and j: ...|$|E
5000|$|The <b>loop</b> <b>counter</b> [...] is {{declared}} {{inside the}} parallel [...] loop in C99 style, which gives each thread {{a unique and}} private version of the variable.|$|E
50|$|With {{all these}} {{definitions}} it is convenient to include 0 (corresponding {{to the empty}} set) as a natural number. Including 0 is now the common convention among set theorists and logicians. Other mathematicians also include 0 although many have kept the older tradition and take 1 {{to be the first}} natural number. Computer scientists often start from zero when enumerating items like <b>loop</b> <b>counters</b> and string- or array- elements.|$|R
40|$|We {{report on}} a {{successful}} preliminary experience {{in the design and}} implementation of a special-purpose Abstract Interpretation based static program analyzer for the verification of safety critical embedded real-time software. The analyzer is both precise (zero false alarm in the considered experiment) and e#cient (less than one minute of analysis for 10, 000 lines of code). Even if it is based on a simple interval analysis, many features have been added to obtain the desired precision: expansion of small arrays, widening with several thresholds, loop unrolling, trace partitioning, relations between <b>loop</b> <b>counters</b> and other variables...|$|R
50|$|However, Java {{does not}} have {{generators}} built into the language. This means that creating iterators is often much trickier than in languages with built-in generators, especially when the generation logic is complex. Because all state must be saved and restored every time an item is to be yielded from an iterator, {{it is not possible}} to store state in local variables or use built-in looping routines, as when generators are available; instead, all of this must be manually simulated, using object fields to hold local state and <b>loop</b> <b>counters.</b>|$|R
5000|$|Note {{that the}} loop {{termination}} condition, here specified as [...] (<b>loop</b> <b>counter</b> expired), {{can be set}} to other values including always-true and always-false. With an always-true condition, we have a genuine [...] The hardware supports up to six simultaneously active s.|$|E
50|$|Loop {{counters}} {{change with}} each iteration of a loop, providing a unique value {{for each individual}} iteration. The <b>loop</b> <b>counter</b> is used to decide when the loop should terminate and for the program flow to continue to the next instruction after the loop.|$|E
5000|$|In {{procedural}} languages it {{is common}} to use the subscript operator and a <b>loop</b> <b>counter</b> to loop through all the elements in a sequence such as an array. Although indexing may also be used with some object-oriented containers, the use of iterators may have some advantages: ...|$|E
5000|$|In the Sieve System, only local {{variables}} to the sieve block scope may have dependencies. However, these dependencies must not cross splitpoints; they will generate compiler warnings [...] In order to parallelize this loop, a special 'Iterator' class {{may be used}} in place of a standard integer <b>looping</b> <b>counter.</b> It is safe for parallelization, and the programmer is free to create new Iterator classes at will http://codeplaysoftware.typepad.com/codeplay/2007/05/loop_carried_de.html. In addition to these Iterator classes, the programmer is free to implement classes called 'Accumulators' which are used to carry out reduction operations.|$|R
3000|$|Exploration Search (Inner Loop). Repeat this {{inner loop}} steps until a {{predefined}} number of consecutive inner iterations fail to obtain improvement or the inner <b>loop</b> iteration <b>counter</b> exceeds a predefine maximum number.|$|R
50|$|Twelve of Line 2's {{eighteen}} {{stations are}} named after city gates. These stations end in men, meaning gate. The following table lists Line 2 {{stations in the}} outer <b>loop</b> or <b>counter</b> clockwise order.|$|R
5000|$|... ++ Cell c0 = 2> +++++ Cell c1 = 5Start your loops {{with your}} cell pointer on the <b>loop</b> <b>counter</b> (c1 in our case)< + Add 1 to c0> - Subtract 1 from c1 End your loops with the cell pointer on the loop counterAt this point our program has added 5 to 2 leaving 7 in c0 and 0 in c1BUT we cannot output this {{value to the}} {{terminal}} since it's not ASCII encoded!To display the ASCII character [...] "7" [...] we must add 48 to the value 7!48 = 6 * 8 so let's use another loop to help us!++++ ++++ c1 = 8 {{and this will be}} our <b>loop</b> <b>counter</b> again+++ +++ Add 6 to c0> - Subtract 1 from c1< [...] Print out c0 which has the value 55 which translates to [...] "7"! ...|$|E
5000|$|In {{computer}} programming a <b>loop</b> <b>counter</b> is the variable {{that controls the}} iterations of a loop (a {{computer programming}} language construct). It is so named because most uses of this construct result in the variable taking {{on a range of}} integer values in some orderly sequence (e.g., starting at 0 and end at 10 in increments of 1) ...|$|E
50|$|Example 2:A {{programmer}} may define {{several large}} arrays as globals or as class variables.The {{start of the}} array is stored in the literal address (perhaps modified at program-load time by a relocating loader) of the instruction that references it.The offset—which item from the array to use on this iteration of a loop—is stored in the index register.Often the instructions in a loop re-use the same register for the <b>loop</b> <b>counter</b> and the offsets of several arrays.|$|E
5000|$|... shared: {{the data}} within a {{parallel}} region is shared, which means visible and accessible by all threads simultaneously. By default, all {{variables in the}} work sharing region are shared except the <b>loop</b> iteration <b>counter.</b>|$|R
40|$|International audienceThe {{inference}} and the {{verification of}} numerical relationships among variables {{of a program}} {{is one of the}} main goals of static analysis. In this paper, we propose an Abstract Interpretation framework based on higher-dimensional ellipsoids to automatically discover symbolic quadratic invariants within <b>loops,</b> using <b>loop</b> <b>counters</b> as implicit parameters. In order to obtain non-trivial invariants, the diameter of the set of values taken by the numerical variables of the program has to evolve (sub-) linearly during loop iterations. These invariants are called ellipsoidal cones and can be seen as an extension of constructs used in the static analysis of digital filters. Semidefinite programming is used to both compute the numerical results of the domain operations and provide proofs (witnesses) of their correctness...|$|R
40|$|Abstract. We {{report on}} a {{successful}} preliminary experience {{in the design and}} implementation of a special-purpose Abstract Interpretation based static program analyzer for the verification of safety critical embedded real-time software. The analyzer is both precise (zero false alarm in the considered experiment) and efficient (less than one minute of analysis for 10, 000 lines of code). Even if it is based on a simple interval analysis, many features have been added to obtain the desired precision: expansion of small arrays, widening with several thresholds, loop unrolling, trace partitioning, relations between <b>loop</b> <b>counters</b> and other variables. The efficiency of the tool mainly comes from a clever representation of abstract environments based on balanced binary search trees. Dedicated to Neil Jones, for his 60 th birthday...|$|R
50|$|Unlike {{many other}} kinds of loops, such as the while-loop, the for-loop is often {{distinguished}} by an explicit <b>loop</b> <b>counter</b> or loop variable. This allows {{the body of the}} for-loop (the code that is being repeatedly executed) to know about the sequencing of each iteration. For-loops are also typically used when the number of iterations is known before entering the loop. For-loops are the shorthand way to make loops when the number of iterations is known, as every for-loop could be written as a while-loop.|$|E
5000|$|With {{programs}} {{constructed from}} randomly selected modules, Zgrass {{needed to have}} better control over its variables than BASIC. In BASIC all variables are [...] "global", so if two subroutines both use the variable [...] (very common) then they could set each others values, leading to hard-to-debug problems. Under Zgrass a programmer loading up two modules could easily find that both used i as a <b>loop</b> <b>counter,</b> which could cause problems. To address this issue, Zgrass considered variables named with lowercase letters to be local only to that macro. Oddly, the examples provided with the language do not make widespread use of this feature, potentially confusing new programmers who might not be aware the feature exists.|$|E
50|$|A common {{identifier}} {{naming convention}} {{is for the}} <b>loop</b> <b>counter</b> to use the variable names i, j, and k (and so on if needed), where {{i would be the}} most outer loop, j the next inner loop, etc. The reverse order is also used by some programmers. This style is generally agreed to have originated from the early programming of FORTRAN, where these variable names beginning with these letters were implicitly declared as having an integer type, and so were obvious choices for loop counters that were only temporarily required. The practice dates back further to mathematical notation where indices for sums and multiplications are often i, j, etc. A variant convention is the use of reduplicated letters for the index, ii, jj, and kk, as this allows easier searching and search-replacing than using a single letter.|$|E
40|$|Existing {{approaches}} to array fusion {{can deal with}} straight-line producer consumer pipelines, but cannot fuse branching data flows where a generated array is consumed by several different consumers. Branching data flows are common and natural to write, but a lack of fusion leads {{to the creation of}} an intermediate array at every branch point. We present a new array fusion system that handles branches, based on Waters’s series expression framework, but extended to work in a functional setting. Our system also solves a related problem in stream fusion, namely the introduction of duplicate <b>loop</b> <b>counters.</b> We demonstrate speedup over existing fusion systems for several key examples. Categories and Subject Descriptors D. 3. 3 [Programming Languages]: Language Constructs and Features—Concurrent programming structures; Control structures; Abstract data type...|$|R
40|$|Calculating the {{worst-case}} execution time (WCET) of real-time tasks {{is still a}} tedious job. Programmers are required to provide additional information on the program flow, analyzing subtle, context dependent loop bounds manually. In this paper, we propose to restrict written and generated code to the class of programs with input-data independent <b>loop</b> <b>counters.</b> The proposed policy builds on the ideas of single-path code, but only requires partial input-data independence. It is always possible to find precise loop bounds for these programs, using an efficient variant of abstract execution. The systematic construction of tasks following the policy is facilitated by embedding knowledge on inputdata dependence in function interfaces and types. Several algorithms and benchmarks are analyzed to show that this restriction is indeed {{a good candidate for}} removing the need for manual annotations. 1...|$|R
5000|$|An {{enhanced}} {{instruction set}} including single-bit addressing, shifts/rotates on memory and registers {{other than the}} accumulator, rotate instructions for BCD number strings in memory, program <b>looping,</b> program <b>counter</b> relative jumps, block copy, block input/output (I/O), and byte search instructions. The Z80 also incorporated an overflow flag and had better support for signed 8- and 16-bit arithmetics.|$|R
