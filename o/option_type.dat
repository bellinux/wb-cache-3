58|657|Public
25|$|Consider the <b>option</b> <b>type</b> Maybe t, {{representing}} a value that {{is either a}} single value of type t, or no value at all. To distinguish these, there are two algebraic data type constructors: Just t, containing the value t, or Nothing, containing no value.|$|E
25|$|A monad may {{encapsulate}} {{values of}} a particular data type, creating a new type associated with a specific additional computation, typically to handle special cases of the type. For example, the simple Maybe monad encapsulates variables which may have a null value, representing an <b>option</b> <b>type,</b> and automatically ensures that null values are not passed as arguments to functions that cannot handle them, serving as an alternative programming technique to throwing and catching exceptions when null values arise. Another example is the List monad, where the empty list is a constant value of type List, and the cons operator binds a plain value {{as the head of}} a previous list.|$|E
2500|$|In the Swift {{programming}} language, a type {{followed by}} [...] "!" [...] denotes an [...] "implicitly unwrapped optional", an <b>option</b> <b>type</b> where the compiler does not enforce safe unwrapping. The [...] "!" [...] operator [...] "force unwraps" [...] an <b>option</b> <b>type,</b> causing an error {{if it is}} nil.|$|E
40|$|Abstract. <b>Option</b> <b>types</b> are a {{powerful}} abstraction {{that allows the}} concise mod-elling of combinatorial problems where some decisions are relevant only if other decisions are made. They have {{a wide variety of}} uses: for example in modelling optional tasks in scheduling, or exceptions to a usual rule. <b>Option</b> <b>types</b> represent objects {{which may or may not}} exist in the constraint problem being modelled, and can take an ordinary value or a special value> indicating they are absent. The key property of variables of <b>option</b> <b>types</b> is that if they take the value> then the constraints they appear in should act as if the variable was not in the origi-nal definition. In this paper, we explore the different ways that basic constraints can be extended to handle <b>option</b> <b>types,</b> and we show that extensions of global constraints to <b>option</b> <b>types</b> cover existing and common variants of these global constraints. We demonstrate how we have added <b>option</b> <b>types</b> to the constraint modelling language MINIZINC. Constraints over variables of <b>option</b> <b>types</b> can either be handled by transformation into regular variables without extending the requirements on underlying solvers, or they can be passed directly to solvers that support them natively. ...|$|R
2500|$|<b>Option</b> <b>types</b> and Result types, {{alternative}} ways of handling errors in functional programming without exceptions ...|$|R
50|$|In the Curry-Howard correspondence, <b>option</b> <b>types</b> {{are related}} to the {{annihilation}} law for ∨: x∨1=1.|$|R
50|$|In {{different}} programming languages, the <b>option</b> <b>type</b> has various {{names and}} definitions.|$|E
50|$|This returns an <b>Option</b> <b>type,</b> Scala's {{equivalent}} of a the Maybe monad in Haskell.|$|E
50|$|An <b>option</b> <b>type</b> {{can also}} be seen as a {{collection}} containing either one or zero elements.|$|E
5000|$|<b>Option</b> <b>types</b> and Result types, {{alternative}} ways of handling errors in functional programming without exceptions ...|$|R
50|$|In {{languages}} having tagged unions, {{as in most}} {{functional programming}} languages, <b>option</b> <b>types</b> can be expressed as the tagged union of a unit type plus the encapsulated type.|$|R
40|$|International audienceWe {{propose a}} unified syntactic-semantic account of passive {{sentences}} and sentences with an unspecified object (John read). For both constructions, we employ <b>option</b> <b>types</b> for introducing implicit arguments into the syntactic-semantic categorial mechanism. We show {{the advantages of}} this approach over previous proposals in the domains of scope and unaccusatives. Unlike pure syntactic treatments, <b>option</b> <b>types</b> immediately derive the obligatory narrow scope of existential quantification over an implicit argument's slot. Unlike purely semantic, eventbased treatments, our proposal naturally accounts for syntactic contrasts between passives and unaccusatives, as in the door *(was) opened by John...|$|R
5000|$|Given any monad , {{the option}} monad {{transformer}} [...] (where [...] denotes the <b>option</b> <b>type)</b> is defined by: ...|$|E
5000|$|Note: Copied, Option Class, and Option Number are {{sometimes}} referred to as a single eight-bit field, the <b>Option</b> <b>Type.</b>|$|E
5000|$|In Perl 6, {{this is the}} default, but you can add a [...] "smiley" [...] to opt into a non <b>option</b> <b>type.</b>|$|E
30|$|A {{comprehensive}} review of the scientific literature was conducted to identify response scale <b>option</b> <b>types</b> appropriate for use in pediatric populations and to review and summarize the available empirical evidence for each scale type.|$|R
5000|$|As an {{indication}} of error; this usage primarily occurs in theoretical languages where distinguishing between errors is unimportant. Production programming languages typically use other methods, such as <b>option</b> <b>types</b> (including tagged pointers) or exception handling.|$|R
50|$|There is a {{more general}} and formal concept that extend the nullable type concept, it comes from <b>option</b> <b>types,</b> which enforce {{explicit}} handling of the exceptional case.Option type implementations usually adhere to the Special Case pattern.|$|R
50|$|There {{are as many}} null {{values as}} there are types, that is because every type is its own null.So all types are also their own <b>option</b> <b>type.</b>|$|E
5000|$|The <b>option</b> <b>type</b> is a monad {{under these}} functions:We may also {{describe}} the option monad {{in terms of}} functions return, fmap and join, where the latter two are given by: ...|$|E
5000|$|... {{optional}} - optional data is notated {{similarly to}} C pointers, but is represented as the data type [...] "pointed to" [...] with a boolean [...] "present or not" [...] flag. Semantically this is <b>option</b> <b>type.</b>|$|E
40|$|TRNAUS – TRNSYS {{extensions}} {{for solar}} water heaters This report outlines extensions of the TRNSYS simulation program {{for the analysis of}} a range of solar collectors and {{solar water heaters}} that are used or being investigated in Australia. The emphasis is in the area of thermosyphon systems, heat exchangers, evacuated tubular collectors, non-tracking concentrators and solar boosted heat pump water heaters. Extensions are detailed for TYPE 101 Solar collector TYPE 137 Solar boosted heat pump TYPE 138 Stratified tank model TYPE 145 Thermosyphon solar water heater including collector loop heat exchanger <b>options</b> <b>TYPE</b> 160 Stratified tank model with mantle heat exchanger and falling film heat exchanger <b>options</b> <b>TYPE</b> 176 One-shot user over-ride of boostin...|$|R
30|$|The {{purpose of}} this article is to provide an {{overview}} of the published research on response scale <b>option</b> <b>types</b> used within pediatric populations. Evidence identified through this comprehensive literature review is intended to inform and enhance response scale selection for newly developed PRO instruments designed for use in pediatric populations.|$|R
40|$|We {{develop a}} method for pricing long and short {{positions}} in European options modeled by jump diffusion process (where the jump component of the stock return represents “non-systematic ” risk) inclusive of transaction costs. We compute the total transaction costs and the turnover for different <b>option</b> <b>types,</b> transaction cost regimes, and revision interval lengths...|$|R
5000|$|A {{common type}} of PPN is the stock plus <b>option</b> <b>type.</b> Its return equals [...] at {{maturity}} for underlying call options. Where [...] is a multiplication factor set in the contract, [...] is the stock price at maturity, and [...] is the option's strike price.|$|E
5000|$|Values can {{be looked}} up via {{one of the}} [...] functions, such as [...] This returns an <b>option</b> <b>type</b> with a value of , for a {{successful}} lookup, or , for an unsuccessful one. Pattern matching can then be used to extract the raw value, or a default, from the result.|$|E
5000|$|The list type is an {{immutable}} {{linked list}} represented either using a [...] notation ( [...] is the cons operator) or a shorthand as [...] An empty list is written [...] The <b>option</b> <b>type</b> is a discriminated union type with choices [...] or [...] F# types may be generic, implemented as generic [...]NET types.|$|E
25|$|An {{important}} new feature in Swift is <b>option</b> <b>types,</b> which allow references or values {{to operate in}} a manner similar to the common pattern in C, where a pointer may refer to a value or may be null. This implies that non-optional types cannot result in a null-pointer error; the compiler can ensure this is not possible.|$|R
30|$|Li et al. [15] {{identified}} nine condition types, some {{of which}} are time-based while others are value-based. Minimum Response Time, Maximum Response Time, and Periodic <b>option</b> <b>types</b> are time-based conditions, whereas AllValues<, AllValues>, Value=, Value<>, and Step use the sensor reading values as notification criteria. The Time Series condition type is neither related to time nor to sensor readings.|$|R
40|$|We use a re ection result to give simple proofs of (well-known) {{valuation}} formu-las and static hedge portfolios constructions for zero-rebate single-barrier {{options in}} the Black-Scholes model. We then illustrate how to extend the ideas to other model types giving (at least) easy-to-program numerical methods and other <b>option</b> <b>types</b> such as <b>options</b> with rebates, double-barrier and lookback options...|$|R
50|$|A {{null pointer}} has a value {{reserved}} for {{indicating that the}} pointer does not refer to a valid object. Null pointers are routinely used to represent conditions such {{as the end of}} a list of unknown length or the failure to perform some action; this use of null pointers can be compared to nullable types and to the Nothing value in an <b>option</b> <b>type.</b>|$|E
50|$|In {{programming}}, nullable {{types are}} {{a feature of}} the type system of some programming languages which allow the value to be set to the special value NULL instead of the usual possible values of the data type. In statically-typed languages, a nullable type is an <b>option</b> <b>type</b> (in functional programming terms), while in dynamically-typed languages (where values have types, but variables do not), equivalent behavior is provided by having a single null value.|$|E
50|$|In {{programming}} languages (more so {{functional programming}} languages) and type theory, an <b>option</b> <b>type</b> or maybe type is a polymorphic type that represents encapsulation of an optional value; e.g., {{it is used}} as the return type of functions {{which may or may}} not return a meaningful value when they are applied. It consists of a constructor which either is empty (named None or Nothing), or which encapsulates the original data type A (written Just A or Some A). Outside of functional programming, these are termed nullable types.|$|E
40|$|In {{this short}} paper, we study the asymptotics {{for the price}} of call options for very large strikes and put options for very small strikes. The stock price is assumed to follow the Black-Scholes models. We analyze European, Asian, American, Parisian and {{perpetual}} options and conclude that the tail asymptotics for these <b>option</b> <b>types</b> fall into four scenarios...|$|R
50|$|An {{important}} new feature in Swift is <b>option</b> <b>types,</b> which allow references or values {{to operate in}} a manner similar to the common pattern in C, where a pointer may refer to a value or may be null. This implies that non-optional types cannot result in a null-pointer error; the compiler can ensure this is not possible.|$|R
40|$|We use a {{reflection}} result to give simple proofs of (well-known) valuation formulas and static hedge portfolio constructions for zero-rebate single-barrier {{options in the}} Black-Scholes model. We then illustrate how to extend the ideas to other model types giving (at least) easy-to-program numerical methods and other <b>option</b> <b>types</b> such as <b>options</b> with rebates, and double-barrier and lookback options. Barrier option, Static hedging,...|$|R
