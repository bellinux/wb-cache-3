46|75|Public
500|$|... British Museum database, <b>object</b> <b>ID</b> 1958,1006.1957, {{retrieved}} 1 January 2012, [...]|$|E
2500|$|... Clark County Historical Museum, <b>object</b> <b>ID</b> P81.6.3. (high {{resolution}} image).|$|E
50|$|Trees {{refer to}} each other by <b>object</b> <b>id.</b> They may also refer to {{individual}} nodes in other trees as a triplet of the tree's <b>object</b> <b>id,</b> the node's level within the tree and its leftmost key value. Such references are independent of where the tree is actually stored.|$|E
5000|$|<b>Object</b> <b>IDs</b> {{come from}} the set of all object {{identifiers}} allocated {{according to the rules}} specified in ASN.1.|$|R
5000|$|<b>Object</b> <b>id’s</b> are {{guaranteed}} to be unique across all physical nodes. Objects could be [...] "moved" [...] from one physical node to another without any application code changes required.|$|R
5000|$|Distribution: Lock server and 64-bit <b>object</b> <b>IDs</b> support dynamic {{addressing}} space (with each federation capable of managing up to 65,535 individual databases and 10^24 bytes (one quadrillion gigabytes, or a yottabyte) of physical addressing space).|$|R
50|$|An object {{identifier}} (or <b>object</b> <b>ID</b> or OID) uniquely identifies a managed {{object in the}} MIB hierarchy.|$|E
50|$|Every tree {{appears as}} an object in the root tree (or tree of tree roots). Some trees, such as file system trees and log trees, have a {{variable}} number of instances, {{each of which is}} given its own <b>object</b> <b>id.</b> Trees which are singletons (the data relocation, extent and chunk trees) are assigned special, fixed object ids ≤256. The root tree appears in itself as a tree with <b>object</b> <b>id</b> 1.|$|E
50|$|R+ trees {{differ from}} R trees in that: nodes are not {{guaranteed}} {{to be at least}} half filled, the entries of any internal node do not overlap, and an <b>object</b> <b>ID</b> may be stored in more than one leaf node.|$|E
50|$|Features of ODBPP include: full {{multi-process}} and multi-thread transaction control, auto real-time database recovery, hierarchical object data design, {{native code}} and script access, static hash index on <b>object</b> <b>IDs,</b> numerous supported index methods including full-text and biometric pattern matching.|$|R
50|$|The extent {{allocation}} tree {{acts as an}} {{allocation map}} for the file system. Unlike other trees, items in this tree do not have <b>object</b> <b>ids</b> and represent regions of space: their left-hand and right-hand key values are the starting offsets and lengths of the regions they represent.|$|R
40|$|We propose two {{approaches}} to sense tangible objects on capacitive touch screens, {{which are used}} in off-the-shelf multi-touch devices such as Apple iPad, iPhone, and 3 M’s multi-touch displays. We seek for the approaches {{that do not require}} modifications to the panels: spatial tag and frequency tag. Spatial tag is similar to fiducial tag used by tangible tabletop surface interaction, and uses multi-point, geometric patterns to encode <b>object</b> <b>IDs.</b> Frequency tag simulates high-frequency touches in the time domain to encode <b>object</b> <b>IDs,</b> using modulation circuits embedded inside tangible objects to simulate high-speed touches in varying frequency. We will show several demo applications. The first combines simultaneous tangible + touch input system. This explores how tangible inputs (e. g., pen, easer, etc.) and some simple gestures work together on capacitive touch panels. ACM Classification: H 5. 2 [Information interfaces an...|$|R
50|$|A CDMI client may access objects, {{including}} containers, {{by either}} name or <b>object</b> <b>id</b> (OID), assuming the CDMI server supports both methods. When storing objects by name, {{it is natural}} to use nested named containers; the resulting structure corresponds exactly to a traditional filesystem directory structure.|$|E
50|$|Besides inode items, {{files and}} {{directories}} {{also have a}} reference item whose right-hand key value is the <b>object</b> <b>id</b> of their parent directory. The data part of the reference item is the filename that inode is known by in that directory. This allows upward traversal through the directory hierarchy by providing a way to map inodes back to paths.|$|E
50|$|To write file data, YAFFS {{initially}} {{writes a}} whole page (chunk in YAFFS terminology) {{that describes the}} file metadata, such as timestamps, name, path, etc. The new file is assigned a unique <b>object</b> <b>ID</b> number; every data chunk within the file will contain this unique <b>object</b> <b>ID</b> within the spare area. YAFFS maintains a tree structure in RAM memory of the physical location of these chunks. When a chunk is no longer valid (the file is deleted, or parts of the file are overwritten), YAFFS marks a particular byte in the spare area of the chunk as ‘dirty’. When an entire block (32 pages) is marked as dirty, YAFFS can erase the block and reclaim the space. When the filesystem's free space is low, YAFFS consolidates a group of good pages onto a new block. YAFFS then reclaims the space used by dirty pages {{within each of the}} original blocks.|$|E
40|$|This paper {{presents}} {{a method of}} planar object recognition for aiming at accessing information about objects by taking pictures of them. For this purpose efficiency of processing is the central issue because current state-of-the-art technologies with tree structures do not necessarily work well with {{a large amount of}} data represented as high dimensional vectors. To solve this problem, we employ hashing of keypoints extracted from images of objects. With the help of hash keys obtained as integers converted from the real valued vectors, keypoints are stored with <b>object</b> <b>IDs</b> and retrieved with no search process. Voting for <b>object</b> <b>IDs</b> is employed to determine a recognized object as the one with the largest vote. Experimental results show that the proposed method is at least 400 times faster than a brute-force method while 90 % of objects were correctly recognized. 1...|$|R
5000|$|... @interface Forwarder : <b>Object</b> { <b>id</b> recipient; //The <b>object</b> we want {{to forward}} the message to.} ...|$|R
40|$|What do {{you already}} know about LDAP? I How many know that a {{directory}} is tree shaped? I How many have worked with a directory before? I How many know about SNMP <b>object</b> <b>IDs?</b> I How many know [...] . I What [...] . is the air-speed velocity of an unladen swallow? I The European swallow appears to do about 11 ms− 1 How we implemented an LDAP directory fo...|$|R
50|$|PTP {{specifies}} {{a way of}} creating, transferring and manipulating objects {{which are}} typically photographic images such as a JPEG file. While {{it is common to}} think of the objects that PTP handle as files, they are abstract entities identified solely by a 32-bit <b>object</b> <b>ID.</b> These objects can however have parents and siblings so that a file-system-like view of device contents can be created.|$|E
50|$|In {{the first}} version of the OSD standard, objects are {{specified}} with a 64-bit partition ID and a 64-bit <b>object</b> <b>ID.</b> Partitions are created and deleted within an OSD, and objects are created and deleted within partitions. There are no fixed sizes associated with partitions or objects; they are allowed to grow subject to physical size limitations of the device or logical quota constraints on a partition.|$|E
5000|$|Attributes are {{sometimes}} multi-valued, allowing multiple naming attributes {{at one level}} (such as machine type and serial number concatenation, or multiple phone numbers for [...] "work phone"). Attributes and object classes are standardized throughout the industry, and formally registered with the IANA for their <b>object</b> <b>ID.</b> Therefore, directory applications try to reuse standard classes and attributes to maximize the benefit of existing directory-server software.|$|E
40|$|Structured {{peer-to-peer}} (P 2 P) systems {{address the}} load balancing {{issue in a}} rather naive way, by simply resorting to the uniformity of the hash function utilized to generate <b>object</b> <b>IDs.</b> Such a random choice of <b>object</b> <b>IDs</b> could result in O(log N) load imbalance. In this position paper, we propose an efficient, proximity-aware load balancing algorithm for such systems. To our knowledge, {{this is the first}} work to utilize the proximity information to guide load balancing. In particular, our main contributions are: (1) A self-organized, fully distributed K-nary tree structure is constructed on top of a DHT for load balancing information collection/dissemination and load reassignment. (2) Load balancing is achieved by aligning those two skews in both load distribution and node capacity inhere in P 2 P systems — that is, have higher capacity nodes carry more loads. (3) Proximity information is utilized to guide load balancing such that virtual servers are assigned and transferred between physically close heavy nodes and light nodes, thereby minimizing the load transferring overhead and making load balancing fast and efficient. 1...|$|R
5000|$|... #There's no top-to-bottom {{ordering}} to the rows.#There's no left-to-right ordering to the columns.#There are no duplicate rows.#Every row-and-column intersection contains {{exactly one}} value from the applicable domain (and nothing else).#All columns are regular rows have no hidden components such as row <b>IDs,</b> <b>object</b> <b>IDs,</b> or hidden timestamps. Violation {{of any of}} these conditions would mean that the table is not strictly relational, and therefore that it is not in first normal form.|$|R
50|$|The MIB {{hierarchy}} can be {{depicted as}} a tree with a nameless root, the levels of which are assigned by different organizations. The top-level MIB OIDs belong to different standards organizations, while lower-level <b>object</b> <b>IDs</b> are allocated by associated organizations. This model permits management across all layers of the OSI reference model, extending into applications such as databases, email, and the Java reference model, as MIBs can be defined for all such area-specific information and operations.|$|R
5000|$|In {{clinical}} data, {{the entity}} is typically a clinical event, as described above. In more general-purpose settings, the entity is a foreign key into an [...] "objects" [...] table that records common information about every [...] "object" [...] (thing) {{in the database}} - at the minimum, a preferred name and brief description, {{as well as the}} category/class of entity to which it belongs. Every record (object) in this table is assigned a machine-generated <b>object</b> <b>ID.</b>|$|E
50|$|For {{persistence}} to take place, the Python Car class must {{be derived}} from the persistence.Persistent class — this class both holds the data necessary for the persistence machinery to work, such as the internal <b>object</b> <b>id,</b> state of the object, and so on, but also defines the boundary of the persistence in the following sense: every object whose class derives from Persistent is the atomic unit of storage (the whole object is copied to the storage when a field is modified).|$|E
50|$|Consider {{the case}} where a client {{application}} wishes to read a file. Normally this would require one message to the kernel to find the file server, then three additional messages to the file server itself - one to resolve the file name into an <b>object</b> <b>id,</b> another to open that id, then finally another to read the file. Using Vanguard's chaining, a single message could be constructed by the client that contained all of these requests. The message {{would be sent to}} the kernel, and then passed off to the file server who would handle all three requests before finally returning data.|$|E
50|$|Now, when eat {{is called}} with a generic <b>object</b> (an <b>id),</b> the {{function}} will behave correctly {{depending on the}} type of the generic object.|$|R
30|$|Apart from integer and boolean datatype, {{five new}} data types are {{introduced}} to support the mentioned objects, namely, NOType, MOType, Location, NOStateType, MOStateType, NOID and MOID. NOType defines the type (ex: cabinet, door, switch) of non-movable <b>object</b> with <b>ID</b> defined in data type NOID. Likewise, MOType defines the type (towel, paper, cup) of movable <b>object</b> with <b>ID</b> defined in data type MOID. Location is the datatype of location.MOStateType and NOStateType are the datatype that defines the state of a movable and non-movable object respectively.|$|R
50|$|Some NTFS {{features}} are not implemented in ReFS. These include <b>object</b> <b>IDs,</b> 8.3 filename, NTFS compression, Encrypting File System (EFS), transactional NTFS, hard links, extended attributes, and disk quotas. In addition, Windows cannot be booted from a ReFS volume. Dynamic disks with mirrored or striped volumes are replaced with mirrored or striped storage pools provided by Storage Spaces; however, automated error-correction is only supported on mirrored spaces. Data deduplication was missing in early versions of ReFS., it was implemented in v3.2, debuting in Windows Server v1709.|$|R
50|$|Distributed link {{tracking}} allows {{applications to}} track files, shell shortcuts or OLE links {{even if they}} were renamed or moved to another volume within the same machine, domain or workgroup. Tracking is implemented as a system service, which uses the object identifier (OID) index stored in a metafile. When the application requests a track to a file or directory, the tracking service creates the OID entry, which points to the file, and file rename, copy or move operation to a NTFS v3 volume also copies the <b>object</b> <b>ID.</b> This allows the tracking service to eventually find the target file.|$|E
5000|$|ReiserFS stores file {{metadata}} ("stat items"), directory entries ("directory items"), inode block lists ("indirect items"), {{and tails}} of files ("direct items") in a single, combined B+ tree keyed by a universal <b>object</b> <b>ID.</b> Disk blocks allocated to nodes {{of the tree}} are [...] "formatted internal blocks". Blocks for leaf nodes (in which items are packed end-to-end) are [...] "formatted leaf blocks". All other blocks are [...] "unformatted blocks" [...] containing file contents. Directory items with too many entries or indirect items which are too long {{to fit into a}} node spill over into the right leaf neighbour. Block allocation is tracked by free space bitmaps in fixed locations.|$|E
50|$|Btrfs is {{structured}} as {{several layers of}} such trees, all using the same B-tree implementation. The trees store generic items sorted on a 136-bit key. The first 64 bits of the key are a unique <b>object</b> <b>id.</b> The middle 8 bits are an item type field; its use is hardwired into code as an item filter in tree lookups. Objects can have multiple items of multiple types. The remaining right-hand 64 bits are used in type-specific ways. Therefore, items for the same object end up {{adjacent to each other}} in the tree, ordered by type. By choosing certain right-hand key values, objects can further put items of the same type in a particular order.|$|E
40|$|Abstract A top-k spatial keyword query returns k objects {{having the}} highest (or lowest) scores {{with regard to}} spatial {{proximity}} as well as text relevancy. Approaches for answering top-k spatial keyword queries can be classified into two categories: the separate index approach and the hybrid index approach. The separate index approach maintains the spatial index and the text index independently and can accommodate new data types. However, {{it is difficult to}} support top-k pruning and merging efficiently at the same time since it requires two different orders for clustering the objects: the first based on scores for top-k pruning and the second based on <b>object</b> <b>IDs</b> for efficient merging. In this paper, we propose a new separate index method called Rank-Aware Separate Index Method (RASIM) for top-k spatial keyword queries. RASIM supports both top-k pruning and efficient merging at the same time by clustering each separate index in two different orders through the partitioning technique. Specifically, RASIM partitions the set of objects in each index into rank-aware (RA) groups that contain the objects with similar scores and applies the first order to these groups according to their scores and the second order to the objects within each group according to their <b>object</b> <b>IDs.</b> Based on the RA groups, we propose two query processing algorithms: (i) External Threshold Algorithm (Externa...|$|R
5000|$|Attributes used: role, action <b>ID,</b> <b>object</b> type, amount, {{approval}} limit.|$|R
40|$|The {{introduction}} of Jumplists in Windows 7 {{was an important}} feature from a forensic examiners viewpoint. Jumplist configuration files can provide the examiner with {{a wealth of information}} relating to file access and in particular: dates/times, Volume GUIDs and unique file <b>object</b> <b>IDs</b> relating to those files. Some of the information in the Jumplist could be used to build a more precise timeline relating to system and file usage. In this article, we analyse the structure of a Jumplist configuration file and in particular a record from a Jumplist configuration file and highlight some of the important entries therein. </span...|$|R
