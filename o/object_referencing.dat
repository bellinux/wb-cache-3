24|2164|Public
5000|$|The [...] "self" [...] window {{containing}} an <b>object</b> <b>referencing</b> {{the main}} character. In Déjà Vu and Uninvited, {{the self is}} simply an oval with the text SELF, in Shadowgate and Déjà Vu II it is decorated in {{the theme of the}} game. Clicking in the background of the inventory window acts as a shortcut for selecting the self.|$|E
5000|$|Access to and {{manipulation}} of multiple DOM nodes in jQuery typically begins with calling the [...] function with a CSS selector string. This returns a jQuery <b>object</b> <b>referencing</b> all the matching {{elements in the}} HTML page. , for example, returns a jQuery object with all the [...] elements of class [...] This node set can be manipulated by calling methods on the returned jQuery object or on the nodes themselves.|$|E
50|$|<b>Object</b> <b>referencing</b> {{can be used}} as a {{means of}} {{breaking}} up large monolithic structures. More significantly it can allow objects to be defined only once and then referenced any number of times. A section of the geometry of the land-water interface could define part of a coastline as well as part of a municipal boundary and part of a marine park boundary. This geometric feature can be defined and given an object reference, which is then used when the geometry of the coastline, municipality and marine park are specified.|$|E
5000|$|<b>Object</b> <b>references</b> on {{the stack}}. <b>Object</b> <b>references</b> on the stack are checked. One {{of the two}} {{following}} actions is taken for each <b>object</b> <b>reference</b> that points to an object in from-space: ...|$|R
25|$|The JSON {{standard}} {{does not}} support <b>object</b> <b>references,</b> but an IETF draft standard for JSON-based <b>object</b> <b>references</b> exists.|$|R
5000|$|Since class Z {{contains}} an <b>object</b> <b>reference,</b> its clone (...) method also clones that <b>object</b> <b>reference</b> {{in order to}} return a deep copy of the original.|$|R
30|$|To {{define a}} precise meaning for {{input and output}} datapoints far beyond {{standardized}} variable types, semantic types are introduced. They are assigned to datapoints and used to create semantically correct connections between datapoints and to analyse the interoperability between profiles. Semantic types are predefined in the semantics ontology of Layer 2 of the ontology layer architecture (cf. Figure 1) and used via <b>object</b> <b>referencing</b> in the ODDs.|$|E
40|$|This online {{practical}} tutorial covers skills using MS Word {{to manage}} tables and images effectively. It builds upon materials covered in [URL] {{and should be}} completed in conjunction with this tutorial. In particular, this course covers how to manage tables using table styles and new styles; managing images including creating your own using PDF selector, screen capture and MS PowerPoint; and using captions, cross-references, lists of figures/tables and update references shortcuts to manage <b>object</b> <b>referencing.</b> ...|$|E
40|$|Abstract: Large {{scientific}} applications which rely on highly parallel computational analysis require highly parallel data access. We {{describe an}} object-oriented, scientific database system that achieves nearly linear scale-up over large, million object data sets. Of primary importance are those features which seem {{central to the}} development of this, or any other parallel database system. These include techniques of object distribution, of multi-operator parallelism, and of indirect <b>object</b> <b>referencing.</b> It also appears to require a query server architecture instead of the more common page server configurations. 1...|$|E
50|$|Object Reference: Objects can be {{accessed}} via <b>object</b> <b>references.</b> To invoke a method in an <b>object,</b> the <b>object</b> <b>reference</b> and method name are given, together with any arguments.|$|R
5000|$|<b>Object</b> <b>References</b> {{are unique}} {{addresses}} {{that may be}} used to identify and point to objects in a program. <b>Object</b> <b>references</b> allow access to the attributes and methods of an object.|$|R
5000|$|The JSON {{standard}} {{does not}} support <b>object</b> <b>references,</b> but an IETF draft standard for JSON-based <b>object</b> <b>references</b> exists.The Dojo Toolkit supports <b>object</b> <b>references</b> using standard JSON; specifically, the [...] module provides support for several forms of referencing including circular, multiple, inter-message, and lazy referencing.Alternatively, non-standard solutions exist {{such as the use}} of Mozilla JavaScript Sharp Variables. However this functionality became obsolete with JavaScript 1.8.5 and was removed in Firefox version 12.|$|R
40|$|We {{describe}} a prototype {{system in which}} task animation is driven via natural language. The primary effort in developing the system is concentrated on {{the link between the}} natural language parser and the animation environment. Two primary problems are <b>object</b> <b>referencing</b> and specifying action durations. We {{describe a}} technique by which objects referenced by the parser can be correctly mapped to their geometric representation within the animation environment even though the internal representations may be vastly different. Furthermore, we show that results from experiments measuring human motor behavior can b...|$|E
40|$|This paper {{describes}} {{the design and}} proposed implementation of a shared object hierarchy. The object hierarchy is stored in a relational database and objects referenced by an application program are cached in the program’s address space. The paper {{describes the}} database representation for the object hierarchy {{and the use of}} POSTGRES, a next-generation relational database management system, to implement <b>object</b> <b>referencing</b> efficiently. The shared object hierarchy system will be used to implement OBJFADS, an object-oriented programming environment for interactive multimedia database applications, that will be the programming interface to POSTGRES. 1...|$|E
40|$|In {{this paper}} we {{investigate}} how to incrementally maintain materialized views in object-relational (OR) databases. The materialized views that we discuss {{in the paper}} are defined in OR-SQL, a language containing the features of <b>object</b> <b>referencing,</b> inheritance, collection, and aggregate functions. We propose an architecture and detailed algorithms for the maintenance. A view in the architecture is maintained in three stage: propagating updates through SELECT-FROMWHERE clauses; incrementally computing aggregate functions; and applying the view update to the view using partitioned normal formed union and difference. Finally, we hilight {{the results of our}} performance analysis of the view maintenance algorithms. 1...|$|E
5000|$|The $ (...) {{function}} {{can also}} receive an element as parameter and will return, {{as in the}} previous example, a prototype extended object.var domElement = document.getElementById("id_of_element"); // Usual <b>object</b> <b>reference</b> returnedvar prototypeEnhancedDomElement = $(domElement); // Prototype extended <b>object</b> <b>reference</b> ...|$|R
40|$|In {{object-oriented}} systems, it {{is often}} the case that an object will have an attribute whose value identifies (points or refers to) some other object in the system so that the identified object can be sent messages. The association between objects determined by the <b>object</b> <b>references</b> in a system will generally result in a complex structure whose design and specification is a crucial part of {{the development and implementation of}} the system. The aim of this paper is to look at ways of capturing formally <b>object</b> <b>reference</b> structures that occur frequently in object-oriented systems. For example, consider a system consisting of car and wheel objects where each car has attributes <b>referencing</b> its wheel <b>objects.</b> If wheels are not shared between cars, distinct car <b>objects</b> will <b>reference</b> distinct wheel <b>objects.</b> In this paper we distinguish such <b>object</b> <b>references</b> by saying that a car object (directly) contains the wheel <b>objects</b> it <b>references.</b> The nature of the contained <b>object</b> <b>references</b> as suggest [...] ...|$|R
50|$|Many OOP {{programming}} languages (including Java, D, ECMAScript, and C#) {{make use}} of <b>object</b> <b>references.</b> <b>Object</b> <b>references,</b> which are similar to pointers in other languages, allow for objects to be passed around by address so that the whole object need not be copied.|$|R
40|$|Abstract. This paper investigates whether {{first year}} {{programming}} {{students can be}} helped to understand program behaviour {{through the use of}} Object (Instance) diagrams. Students were introduced to this diagramming technique as a way of visualising program behaviour and then given questions that tested their understanding of <b>object</b> <b>referencing.</b> It appears that drawing their own diagrams is a strategy applied by more successful students. Attempts to encourage all students to use this technique through scaffolding with partially completed diagrams failed however. Weaker students did not appear to find that the partially completed diagrams helped their understanding or go on to use the technique themselves. ...|$|E
40|$|Abstract. We {{introduce}} an object-oriented referencing abstraction {{to express}} coordination between objects hosted on mobile devices interconnected by a wireless ad hoc network. On the one hand, we {{notice that the}} most popular communication paradigms for mobile ad hoc networks, such as publish/subscribe and tuple space architectures, promote loose coupling of collaborating participants. On the other hand, the paradigm in which many applications are developed is objectoriented, and traditional <b>object</b> <b>referencing</b> abstractions typically lack the beneficial loose coupling properties of aforementioned paradigms. This paper proposes to close the paradigmatic gap between an object-oriented language and its distributed communication infrastructure by introducing ambient references: loosely-coupled remote object references designed for mobile ad hoc networks. ...|$|E
40|$|This paper {{reports on}} an {{experiment}} in which first year programming students were given explicit encouragement to use Object (Instance) diagrams when tracing code in multiple-choice questions. We conjectured that by providing scaffolding in this technique, students would be helped to understand the code better {{and that they would}} then continue to draw their own diagrams in similar situations. This {{turned out not to be}} the case. Although generally students who draw diagrams do better in questions that test their understanding of code behaviour and <b>object</b> <b>referencing,</b> our intervention does not appear to have helped students and the students who were exposed to the intervention were not more likely to go on to use the technique themselves...|$|E
5000|$|SCORM Shareable Content <b>Object</b> <b>Reference</b> Model (training and {{learning}} content) ...|$|R
2500|$|The Dojo Toolkit {{supports}} <b>object</b> <b>references</b> using standard JSON; specifically, the ...|$|R
40|$|A {{significant}} body {{of research}} in ubiquitous computing deals with mobile networks, i. e. networks of mobile devices interconnected by wireless communication links. Due to {{the very nature of}} such mobile networks, addressing and communicating with remote objects is significantly more difficult than in their fixed counterparts. This paper reconsiders the remote <b>object</b> <b>reference</b> concept – one of the most fundamental programming abstractions of distributed programming languages – in the context of mobile networks. We describe four desirable characteristics of remote references in mobile networks, show how existing remote <b>object</b> <b>references</b> fail to exhibit them, and subsequently propose ambient references: remote <b>object</b> <b>references</b> designed for mobile networks...|$|R
40|$|We {{describe}} the Collie collector, a fully concurrent compacting collector that uses transactional memory techniques to achieve waitfree compaction. The collector uses compaction {{as the primary}} means of reclaiming unused memory, and performs “individual object transplantations ” as transactions. We introduce new terms and requirements useful for analyzing concurrent relocating collectors, including definitions of referrer sets, object transplantation {{and the notion of}} individually transplantable objects. The Collie collector builds on these terms and on a detailed analysis of an object’s legal states during compaction. Collie uses a combination of read barriers, write barriers and transactional memory operations. Its read-barrier supports fast, direct <b>object</b> <b>referencing</b> while using a bound, constant time, waitfree triggering path. Collie thereby avoids the constant indirectio...|$|E
40|$|A {{middleware}} for {{object-oriented software}} systems which provides for transparent {{remote method invocation}} and transparent object mobility may require a very flexible object reference model. Distributed garbage collection algorithms, on the other hand, rely on simple object reference models, either to count object references or to traverse object references to mark unreachable objects. Thus, implementing automatic distributed garbage collection in a middleware which employes a non-conventional object reference model may be a challenge. Virtuosi is such a middleware. This paper discusses the implementation of two traditional algorithms (SSP Chains, and Maheshwari and Liskov) in the Virtuosi middleware. The performance of both implementations is assessed through the simulation of object creation, <b>object</b> <b>referencing,</b> object migration and object destruction, spanning several machines...|$|E
40|$|Software {{architectural}} design forms {{an important part}} of today's software development processes. By clearly defining the blueprint of a software system, it is a lot easier to maintain and modify. The focus with current {{architectural design}} processes is too much on the results, rather than on the steps which led to these results. Archium is a programming language which allows for the specification of architectural design results, the rationale explaining the design steps, and the implementation of the architecture. In order to make the language more mature, a number of extensions have been developed: a requirements model has been added, <b>object</b> <b>referencing</b> from rationale has been made possible, a managed threading model has been added and the visualization of running Archium systems has been enhanced and extended with the possibility of applying Design Decisions at run-time. ...|$|E
50|$|Empire-db also {{supports}} field access through <b>object</b> <b>references</b> or obtaining query results as XML.|$|R
40|$|This paper {{shows how}} to make the latency of {{scanning}} a page in the Appel-Ellis-Li real-time garbage collector be proportional only to the number of <b>object</b> <b>references</b> on a page (the page size), instead of to the sum of the sizes of the <b>objects</b> <b>referenced</b> by the page. This makes the garbage collection algorithm much more suitable for real-time systems...|$|R
30|$|The Sharable Content <b>Object</b> <b>Reference</b> Model (SCORM) was {{an early}} {{undertaking}} of the ADL initiative.|$|R
40|$|This paper {{describes}} {{the design and}} proposed implementation of a shared object hierarchy. The object hierarchy is stored in a relational database and objects referenced by an application program are cached in the program's address space. The paper {{describes the}} database representation for the object hierarchy {{and the use of}} POSTGRES, a next-generation relational database management system, to implement <b>object</b> <b>referencing</b> efficiently. The shared object hierarchy system will be used to implement OBJFADS, an object-oriented programming environment for interactive multimedia database applications, that will be the programming interface to POSTGRES. 1. Introduction Object-oriented programming has received much attention recently as a new way to develop and structure programs [GoR 83, StB 86]. This new programming paradigm, when coupled with a sophisticated interactive programming environment executing on a workstation with a bit-mapped display and mouse, improves programmer productivity and [...] ...|$|E
40|$|Software Transactional Memory (STM) is {{a generic}} {{non-blocking}} synchronization construct that enables automatic conversion of correct sequential objects into correct concur-rent objects. Because it is nonblocking, STM avoids tradi-tional performance and correctness problems due to thread failure, preemption, page faults, and priority inversion. In this paper we compare and analyze two recent object-based STM systems, the DSTM of Herlihy et al. and the FSTM of Fraser, {{both of which}} support dynamic transac-tions, in which the set of objects to be modied is not known in advance. We highlight aspects of these systems that lead to performance tradeos for various concurrent data structures. More specically, we consider object own-ership acquisition semantics, concurrent <b>object</b> <b>referencing</b> style, the overhead of ordering and bookkeeping, contention management versus helping semantics, and transaction vali-dation. We demonstrate for each system simple benchmarks on which it outperforms the other by a signicant margin. This in turn provides us with a preliminary characterization of the applications for which each system is best suited. 1...|$|E
40|$|Telecommunication systems, such as AccessGrid, allow {{collaboration}} {{across a}} distributed group. However, these systems typically introduce fragmentation into {{the view of}} the shared environment. Many have found that IPT systems offer several important advantages above other display technologies in supporting distance working. This study focuses on fragmentation, which has previously been shown to induce problems in efficient <b>object</b> <b>referencing</b> within a shared virtual environment accessed through desktop displays. We have attempted to repeat the experiment while varying the display type. The results reinforce previous studies by showing a significant improvement in task performance when the entire team uses IPT displays. Further, the results provide an original contribution by demonstrating a relationship between the scale of this performance and the spatial extent of the task. We postulate that this is due to a reduction in fragmentation when compared to other display technologies. Categories and Subject Descriptors (according to ACM CCS) : I. 3. 6 [Computer Graphics]: Methodology and Techniques 1...|$|E
5000|$|Objects in the to-space. The garbage {{collector}} examines all <b>object</b> <b>references</b> in the <b>objects</b> {{that have been}} migrated to the to-space, and performs one of the above two actions on the <b>referenced</b> <b>objects.</b>|$|R
5000|$|In astrodynamics, {{canonical}} {{units are}} {{defined in terms}} of an <b>object's</b> <b>reference</b> orbit. In this system, a reference mass, for example the sun, is assumed to be 1 [...] "mass unit" [...] and the mean distance from the orbiting <b>object</b> to the <b>reference</b> <b>object</b> is considered the [...] "distance unit".|$|R
500|$|... {{which has}} 15 formats: it can modify indices, assign <b>object</b> <b>references</b> and alter table capacities, among other functions.|$|R
