63|95|Public
5|$|The {{following}} sample SQL query {{performs a}} left <b>outer</b> <b>join</b> {{on these two}} tables.|$|E
500|$|SQL outer joins, {{including}} left outer joins, right outer joins, {{and full}} outer joins, automatically produce Nulls as placeholders for missing values in related tables. [...] For left outer joins, for instance, Nulls are produced {{in place of}} rows missing from the table appearing {{on the right-hand side}} of the LEFT <b>OUTER</b> <b>JOIN</b> operator. [...] The following simple example uses two tables to demonstrate Null placeholder production in a left <b>outer</b> <b>join.</b>|$|E
5000|$|Three <b>outer</b> <b>join</b> {{operators}} are defined: left <b>outer</b> <b>join,</b> right <b>outer</b> <b>join,</b> and full <b>outer</b> <b>join.</b> (The word [...] "outer" [...] is sometimes omitted.) ...|$|E
50|$|The joined table retains each row—even if {{no other}} {{matching}} row exists. <b>Outer</b> <b>joins</b> subdivide further into left <b>outer</b> <b>joins,</b> right <b>outer</b> <b>joins,</b> and full <b>outer</b> <b>joins,</b> {{depending on which}} table's rows are retained (left, right, or both).|$|R
50|$|Right {{and left}} <b>outer</b> <b>joins</b> are {{functionally}} equivalent. Neither provides any functionality {{that the other}} does not, so right and left <b>outer</b> <b>joins</b> may replace each other {{as long as the}} table order is switched.|$|R
50|$|No {{implicit}} join-notation for <b>outer</b> <b>joins</b> {{exists in}} standard SQL.|$|R
50|$|The <b>outer</b> <b>join</b> or full <b>outer</b> <b>join</b> {{in effect}} {{combines}} {{the results of}} the left and right outer joins.|$|E
50|$|The right <b>outer</b> <b>join</b> behaves almost identically to {{the left}} <b>outer</b> <b>join,</b> but {{the roles of the}} tables are switched.|$|E
5000|$|Example {{of a full}} <b>outer</b> <b>join</b> (the '''''' keyword is optional): ...|$|E
40|$|Queries {{containing}} <b>outer</b> <b>joins</b> {{are common}} in data warehousing applications. Materialized outer-join views could greatly speed up many such queries but most database systems do not allow <b>outer</b> <b>joins</b> in materialized views. In part, this is because outer-join views could not previously be maintained efficiently when base tables are updated. In this paper we show how to efficiently maintain general outer-join views, that is, views composed of selection, projection, inner and <b>outer</b> <b>joins.</b> Foreign-key constraints are exploited to reduce maintenance overhead. Experimental results show that maintaining an outer-join view need not be more expensive than maintaining an inner-join view. ...|$|R
5000|$|The {{discussion}} of full <b>outer</b> <b>joins</b> {{also has an}} example that uses [...]|$|R
40|$|<b>Outer</b> <b>joins</b> are {{ubiquitous}} in databases and big data systems. The {{question of how}} best to execute <b>outer</b> <b>joins</b> in large parallel systems is particularly challenging as real world datasets are characterized by data skew leading to performance issues. Although skew handling techniques have been extensively studied for inner joins, there is little published work solving the corresponding problem for parallel <b>outer</b> <b>joins.</b> Conventional approaches to this problem such as ones based on hash redistribution often lead to load balancing problems while duplication-based approaches incurs significant overhead in terms of network communication. In this paper, we propose a new algorithm, query with counters (QC), for directly handling skew in <b>outer</b> <b>joins</b> on distributed architectures. We present an efficient implementation of our approach based on the asynchronous partitioned global address space (APGAS) parallel programming model. We evaluate the performance of our approach on a cluster of 192 cores (16 nodes) and datasets of 1 billion tuples with different skew. Experimental results show that our method is scalable and, in cases of high skew, faster than the state-of-the-art...|$|R
5000|$|SELECT *FROM {{employee}} FULL <b>OUTER</b> <b>JOIN</b> department ON employee.DepartmentID = department.DepartmentID; ...|$|E
50|$|The right <b>outer</b> <b>join</b> of {{relations}} R and S is written as R ⟖ S. The {{result of the}} right <b>outer</b> <b>join</b> is the set of all combinations of tuples in R and S that are equal on their common attribute names, in addition to tuples in S that have no matching tuples in R.|$|E
5000|$|Let s1, s2, ..., sn be the {{attributes}} of the relation S and let {(ω, ..., ω)} be the singletonrelation on {{the attributes}} that are unique to the relation R (those that are not attributes of S). Then, as with the left <b>outer</b> <b>join,</b> the right <b>outer</b> <b>join</b> can be simulated using the natural join as follows: ...|$|E
5000|$|... 2014 Polyhedra 8.9: SQL {{enhancements}} (GROUP BY and HAVING, DISTINCT, <b>outer</b> <b>joins),</b> security enhancements, {{and online}} backups for time-series data.|$|R
50|$|In {{practice}} the classical relational algebra described above is extended with various operations such as <b>outer</b> <b>joins,</b> aggregate functions and even transitive closure.|$|R
50|$|Use the JOIN {{operator}} {{to express a}} join between two or more input arrays. This operator supports multiple types of joins, including natural, left-outer, right-outer, and <b>outer</b> <b>joins.</b>|$|R
5000|$|SELECT employee.LastName, employee.DepartmentID, {{department}}.DepartmentNameFROM employeeLEFT <b>OUTER</b> <b>JOIN</b> department ON employee.DepartmentID = department.DepartmentID; ...|$|E
50|$|The left <b>outer</b> <b>join</b> {{is written}} as R ⟕ S where R and S are relations. The {{result of the}} left <b>outer</b> <b>join</b> is the set of all {{combinations}} of tuples in R and S that are equal on their common attribute names, in addition (loosely speaking) to tuples in R that have no matching tuples in S.|$|E
50|$|The {{following}} sample SQL query {{performs a}} left <b>outer</b> <b>join</b> {{on these two}} tables.|$|E
40|$|Prior work on {{computing}} queries from materialized views {{has focused}} on views defined by expressions consisting of selection, projection, and inner joins, with an optional aggregation on top (SPJG views). This paper provides the first view matching algorithm for views that may also contain <b>outer</b> <b>joins</b> (SPOJG views). The algorithm relies on a normal form for SPOJ expressions and does not use bottomup syntactic matching of expressions. It handles any combination of inner and <b>outer</b> <b>joins,</b> deals correctly with SQL bag semantics and exploits not-null constraints, uniqueness constraints and foreign key constraints. ...|$|R
40|$|Abstract—Outer joins are {{ubiquitous}} in databases and big data systems. The {{question of how}} best to execute <b>outer</b> <b>joins</b> in large parallel systems is particularly challenging as real world datasets are characterized by data skew leading to performance issues. Although skew handling techniques have been extensively studied for inner joins, there is little published work solving the corresponding problem for parallel <b>outer</b> <b>joins.</b> Conventional approaches to this problem such as ones based on hash redistribution often lead to load balancing problems while duplication-based approaches incurs significant overhead in terms of network communication. In this paper, we propose a new algorithm, query with counters (QC), for directly handling skew in <b>outer</b> <b>joins</b> on distributed architectures. We present an efficient implementation of our approach based on the asynchronous partitioned global address space (APGAS) parallel programming model. We evaluate the performance of our approach on a cluster of 192 cores (16 nodes) and datasets of 1 billion tuples with different skew. Experimental results show that our method is scalable and, in cases of high skew, faster than the state-of-the-art. Keywords-Distributed join; parallel join; outer join; data skew; X 10 I...|$|R
40|$|Prior work on {{computing}} queries from materialized views {{has focused}} on views defined by expressions consisting of selection, projection, and inner joins, with an optional aggregation on top (SPJG views). This paper provides the first view matching algorithm for views that may also contain <b>outer</b> <b>joins</b> (SPOJG views) ...|$|R
5000|$|SELECT e.ID, e.LastName, e.FirstName, pn.NumberFROM Employee eLEFT <b>OUTER</b> <b>JOIN</b> PhoneNumber pnON e.ID = pn.ID; ...|$|E
5000|$|A right <b>outer</b> <b>join</b> (or right join) {{closely resembles}} a left <b>outer</b> <b>join,</b> except with the {{treatment}} of the tables reversed. Every row from the [...] "right" [...] table (B) will appear in the joined table at least once. If no matching row from the [...] "left" [...] table (A) exists, NULL will appear in columns from A for those rows that have no match in B.|$|E
5000|$|Below is {{an example}} of a right <b>outer</b> <b>join</b> (the '''''' keyword is optional), with the {{additional}} result row italicized: ...|$|E
40|$|One of the {{approaches}} for integrating object-oriented programs with databases is to instantiate objects from relational databases by evaluating view queries. In that approach, {{it is often}} necessary to evaluate some joins of the query by left <b>outer</b> <b>joins</b> to prevent information loss caused by the tuples discarded by inner joins. It is also necessary to filter some relations with selection conditions to prevent the retrieval of unwanted nulls. The system should automatically prescribe joins as inner or left <b>outer</b> <b>joins</b> and generate the filters, rather than letting them be specified manually for every view definition. We develop such a mechanism in this paper. We first develop a rigorous system model to facilitate the mapping between an object-oriented model and the relational model. The system model provides a well-defined context for developing a simple mechanism. The mechanism requires only one piece of information from users: null options on an object attribute. The semantics of these [...] ...|$|R
40|$|When {{it comes}} to {{performing}} PROC SQL joins, users supply {{the names of the}} tables for joining along with the join conditions, and the PROC SQL optimizer determines which of the available join algorithms to use for performing the join operation. Attendees explore nested loop joins, merge joins, index joins, and hash join algorithms along with selective options to control processing. This presentation illustrates the various join algorithms; join processes including Cartesian Product joins, equijoins, many table <b>joins,</b> and <b>outer</b> <b>joins...</b>|$|R
50|$|The DataWindow {{is the key}} {{component}} (and selling point) of PowerBuilder. The DataWindow offers a visual SQL painter which supports <b>outer</b> <b>joins,</b> unions and subquery operations. It can convert SQL to visual representation and back, so the developer can use native SQL if desired. DataWindow updates are automatic — it produces the proper SQL at runtime based on the DBMS to which the user is currently connected. This feature {{makes it easier for}} developers who are not experienced with SQL.|$|R
50|$|The full <b>outer</b> <b>join</b> {{is written}} as R ⟗ S where R and S are relations. The {{result of the}} full <b>outer</b> <b>join</b> is the set of all {{combinations}} of tuples in R and S that are equal on their common attribute names, in addition to tuples in S that have no matching tuples in R and tuples in R that have no matching tuples in S in their common attribute names.|$|E
5000|$|Example of a left <b>outer</b> <b>join</b> (the '''''' keyword is optional), {{with the}} {{additional}} result row (compared with the inner join) italicized: ...|$|E
5000|$|The full <b>outer</b> <b>join</b> can be {{simulated}} {{using the}} left and right outer joins (and hence the natural join and set union) as follows: ...|$|E
50|$|When {{a result}} set is {{produced}} by joining several tables, including master tables used to look up full text descriptions of numeric identifier codes (a Lookup table), a NULL value {{in any one of}} the foreign keys can result in the entire row being eliminated from the result set, with no indication of error. A complex SQL query that includes one or more inner <b>joins</b> and several <b>outer</b> <b>joins</b> has the same risk for NULL values in the inner join link columns.|$|R
40|$|Real systems rarely store {{all their}} data in one large table. To {{do so would}} require {{maintaining}} several duplicate copies of the same values and could threaten {{the integrity of the}} data. Instead, IT departments everywhere almost always split their data among several different tables. Because of this, a method is needed to simultaneously access two or more tables to help answer the interesting questions about our data. This presentation illustrates a variety of join processes including Cartesian Product joins, equijoins, many table <b>joins,</b> and <b>outer</b> <b>joins...</b>|$|R
40|$|AbstractThis work {{describes}} a novel {{implementation of a}} deductive database system which fills some gaps other systems do not. In fact, this system was born to this end and since its inception, many new features have been added (null values, <b>outer</b> <b>joins,</b> aggregates, …). In particular, it embodies both Datalog and SQL query languages, where the same database can be queried. It enjoys an actual interactive environment for any platform (Windows, Linux, Macintosh, …) {{and it has been}} plugged to a Java GUI IDE for easing user interaction (syntax highlighting, projects, …). The system is distributed under GPL license, hosted by sourceforge, and heavily used all around the world...|$|R
