48|114|Public
5000|$|Smalltalk: In general, non-recursive and non-sharing objects can {{be stored}} and {{retrieved}} in a human readable form using the / protocol. The [...] method generates the text of a Smalltalk expression which - when evaluated using [...] - recreates the original object. This scheme is special, in that it uses a procedural description of the object, not the data itself. It is therefore very flexible, allowing for classes to define more compact representations. However, in its original form, it does not handle cyclic data structures or preserve the identity of shared references (i.e. two references a single object will be restored as references to two equal, but not identical copies). For this, various portable and non-portable alternatives exist. Some of them are specific to a particular Smalltalk implementation or class library. There are several ways in Squeak Smalltalk to serialize and store objects. The easiest and most used are [...] and binary storage formats based on [...] serializers. In addition, bundled objects {{can be stored}} and retrieved using [...] Both provide a so-called [...] "binary-object storage framework", which support serialization into and retrieval from a compact binary form. Both handle cyclic, recursive and shared structures, storage/retrieval of class and metaclass info and include mechanisms for [...] "on the fly" [...] object migration (i.e. to convert instances which were written by an older version of a class with a different <b>object</b> <b>layout).</b> The APIs are similar (storeBinary/readBinary), but the encoding details are different, making these two formats incompatible. However, the Smalltalk/X code is open source and free and can be loaded into other Smalltalks to allow for cross-dialect object interchange. Object serialization {{is not part of}} the ANSI Smalltalk specification. As a result, the code to serialize an object varies by Smalltalk implementation. The resulting binary data also varies. For instance, a serialized object created in Squeak Smalltalk cannot be restored in Ambrai Smalltalk. Consequently, various applications that do work on multiple Smalltalk implementations that rely on object serialization cannot share data between these different implementations. These applications include the MinneStore object database http://minnestore.sourceforge.net/ and some RPC packages. A solution to this problem is SIXX http://www.mars.dti.ne.jp/~umejava/smalltalk/sixx/index.html, which is a package for multiple Smalltalks that uses an XML-based format for serialization.|$|E
40|$|Existing {{schemes for}} <b>object</b> <b>layout</b> and {{dispatch}} {{in the presence}} of multiple inheritance and separate compilation waste space and are slower than systems with single inheritance. This paper describes the bidirectional <b>object</b> <b>layout,</b> a new scheme for <b>object</b> <b>layout</b> that produces smaller objects and faster method invocations than existing schemes by automatically optimizing particular uses of multiple inheritance. The bidirectional <b>object</b> <b>layout</b> is used for the programming language Theta, and is applicable to languages like C++. This paper also demonstrates how to efficiently implement method dispatch when method signatures are allowed to change in subclasses. Most current statically compiled languages require identical signatures for efficiency. 1 Introduction Existing schemes for object memory layout and method dispatch in statically typed languages with multiple inheritance assume the use of multiple inheritance in its full generality. These schemes incur high per-object space overhea [...] ...|$|E
40|$|<b>Object</b> <b>layout</b> — the {{concrete}} in-memory representation of objects — raises many delicate {{issues in the}} case of the C++ language, owing in particular to multiple inheritance, C compatibility and separate compilation. This paper formalizes a family of C++ <b>object</b> <b>layout</b> schemes and mechanically proves their correctness against the operational semantics for multiple inheritance of Wasserrab et al. This formalization is flexible enough to account for spacesaving techniques such as empty base class optimization and tailpadding optimization. As an application, we obtain the first formal correctness proofs for realistic, optimized <b>object</b> <b>layout</b> algorithms, including one based on the popular “common vendor ” Itanium C++ application binary interface. This work provides semantic foundations to discover and justify new layout optimizations; it is also a first step towards the verification of a C++ compiler frontend...|$|E
40|$|Programming idioms, design {{patterns}} and application libraries often introduce cumbersome and repetitive boilerplate code to a software system. Language extensions and external DSLs (domain specific languages) are sometimes introduced {{to reduce the}} need for boilerplate code, but they also complicate the system by introducing the need for language dialects and inter-language mediation. To address this, we propose to extend the structural reflective model of the language with <b>object</b> <b>layouts,</b> layout scopes and slots. Based on the new reflective language model we can 1) provide behavioral hooks to <b>object</b> <b>layouts</b> that are triggered when the fields of an object are accessed and 2) simplify the implementation of state-related language extensions such as stateful traits. By doing this we show how many idiomatic use cases that normally require boilerplate code can be more effectively supported. We present an implementation in Smalltalk, and illustrate its usage through a series of extended examples...|$|R
40|$|A new system, the {{so-called}} MUVIS, is introduced for content-based indexing and retrieval for image database management systems. In addition to traditional indexing by key words, MUVIS allows indexing {{of objects and}} images based on color, texture, shape and <b>objects</b> <b>layout</b> inside them. Due {{to the use of}} large vector features, the pyramid trees are employed to create the index structure...|$|R
40|$|International audienceProgramming idioms, design {{patterns}} and application li- braries often introduce cumbersome and repetitive boiler- plate code to a software system. Language extensions and external DSLs (domain specific languages) are sometimes introduced {{to reduce the}} need for boilerplate code, but they also complicate the system by introducing the need for lan- guage dialects and inter-language mediation. To address this, we propose to extend the structural reflec- tive model of the language with <b>object</b> <b>layouts,</b> layout scopes and slots. Based on the new reflective language model we can 1) provide behavioral hooks to <b>object</b> <b>layouts</b> that are triggered when the fields of an object are accessed and 2) simplify the implementation of state-related language exten- sions such as stateful traits. By doing this we show how many idiomatic use cases that normally require boilerplate code can be more effectively supported. We present an implementation in Smalltalk, and illustrate its usage through a series of extended examples...|$|R
40|$|Abstract. This demo shows a {{real-time}} object-layout-aware image re-trieval {{system for}} personal album management. The query {{of the system}} is image’s <b>object</b> <b>layout</b> and the system retrieves images based on the layout similarity of concerned objects in the query. Using automatic object localization algorithms, we propose to index the personal album with the object positions and scales in the 2 D image plane, which can reflect their layout in 3 D scene and hence be used to measure the <b>object</b> <b>layout</b> similarity. To query from the database, the users need describe their query by plac-ing objects onto a canvas and configuring the position and scale of the objects. Then the system searches the album database and returns pho-tos with the similar <b>object</b> <b>layout.</b> This system can facilitate people in finding the photos of which they have impression on the layout of certain objects...|$|E
40|$|Abstract—The aim of {{declarative}} modeling is to {{help the}} user to build a three-dimensional scene from a high level description. As underlying problems are combinatorial, constraints programming and related solving techniques are a neat and effective way to depict and to solve such problems. In this paper we focus on <b>object</b> <b>layout</b> in a three-dimensional environment that is usually a consuming time and tedious task. This study is restricted to isothetic 1 objects only. In this way, it is related to classical bidimensional space planning problems. Index Terms—Declarative modeling, Constraint-based 3 Dscenes generation, constraint solver, combinatorial problems, isothetic <b>object</b> <b>layout.</b> I...|$|E
40|$|International audienceObject layout - the {{concrete}} in-memory representation of objects - raises many delicate {{issues in the}} case of the C++ language, owing in particular to multiple inheritance, C compatibility and separate compilation. This paper formalizes a family of C++ <b>object</b> <b>layout</b> scheme and mechanically proves their correctness against the operational semantics for multiple inheritance of Wasserrab et al. This formalization is flexible enough to account for space-saving techniques such as empty base class optimization and tail-padding optimization. As an application, we obtain the first formal correctness proofs for realistic, optimized <b>object</b> <b>layout</b> algorithms, including one based on the popular GNU C++ application binary interface. This work provides semantic foundations to discover and justify new layout optimizations; it is also a first step towards the verification of a C++ compiler front-end...|$|E
40|$|Generating {{captions}} for {{images is}} a task that has recently received considerable attention. In this work we focus on caption generation for abstract scenes, or <b>object</b> <b>layouts</b> where the only information provided {{is a set of}} objects and their locations. We propose OBJ 2 TEXT, a sequence-to-sequence model that encodes a set of objects and their locations as an input sequence using an LSTM network, and decodes this representation using an LSTM language model. We show that our model, despite encoding <b>object</b> <b>layouts</b> as a sequence, can represent spatial relationships between objects, and generate descriptions that are globally coherent and semantically relevant. We test our approach in a task of object-layout captioning by using only object annotations as inputs. We additionally show that our model, combined with a state-of-the-art object detector, improves an image captioning model from 0. 863 to 0. 950 (CIDEr score) in the test benchmark of the standard MS-COCO Captioning task. Comment: Accepted at EMNLP 201...|$|R
40|$|The {{computer-based}} {{creation of}} realistic images often requires to generate {{large amount of}} similar objects – a mass scene. Common modelling and rendering tools offer only the support to copy or clone a specific object. This paper suggests an alternative approach. By providing a parametric description of the models, {{it is possible to}} generate many different objects (instances) automatically. The second step is to put these objects into the virtual scene. Different techniques for automatic <b>object</b> positioning (<b>layout)</b> are proposed. The results are tested on the Persistence of Vision Ray Tracer (POV-Ray) platform. To fulfil the desired tasks, additional commands for the POV-Ray scene description language are created. Keywords: mass scenes, photo-realistic rendering, parametric <b>objects,</b> <b>layout,</b> POV-Ray. 1...|$|R
40|$|Spatial {{relationships}} between objects provide important information for text-based image retrieval. As users {{are more likely}} to describe a scene from a real world perspective, using 3 D spatial relationships rather than 2 D relationships that assume a particular viewing direction, one of the main challenges is to infer the 3 D structure that bridges images with users' text descriptions. However, direct inference of 3 D structure from images requires learning from large scale annotated data. Since interactions between objects can be reduced to a limited set of atomic spatial relations in 3 D, we study the possibility of inferring 3 D structure from a text description rather than an image, applying physical relation models to synthesize holistic 3 D abstract <b>object</b> <b>layouts</b> satisfying the spatial constraints present in a textual description. We present a generic framework for retrieving images from a textual description of a scene by matching images with these generated abstract <b>object</b> <b>layouts.</b> Images are ranked by matching object detection outputs (bounding boxes) to 2 D layout candidates (also represented by bounding boxes) which are obtained by projecting the 3 D scenes with sampled camera directions. We validate our approach using public indoor scene datasets and show that our method outperforms baselines built upon object occurrence histograms and learned 2 D pairwise relations. Comment: CVPR 201...|$|R
40|$|Abstract. We {{propose a}} static type {{system for a}} {{significant}} subset of JavaScript, dubbed SJS, {{with the goal of}} ensuring that objects have a statically known layout at the allocation time, which in turn can en-able an ahead-of-time (AOT) compiler to generate efficient code. The main technical challenge we address is to ensure fixed <b>object</b> <b>layout,</b> while supporting popular language features such as objects with proto-type inheritance, structural subtyping, and method updates, with the additional constraint that SJS programs can run on any available stan-dard JavaScript engine, with no deviation from JavaScript’s standard operational semantics. The core difficulty arises from the way standard JavaScript semantics implements object attribute update with prototype-based inheritance. To our knowledge, combining a fixed <b>object</b> <b>layout</b> property with prototype inheritance and subtyping has not been achieved previously. ...|$|E
40|$|High-level {{language}} {{virtual machine}} implementations offer a chal-lenging domain for modularization, {{not only because}} they are in-herently complex, but also because efficiency {{is not likely to be}} traded for modularity. The central data structure used throughout the VM, the <b>object</b> <b>layout,</b> cannot be succinctly modularised by current aspect technology, as provisions for static crosscutting are not fine-grained enough. This position paper motivates the need for a declarative, domain-specific language for handling the tan-gled <b>object</b> <b>layout</b> concern. Based on observations in real-world VM implementations, we propose such a language, D 4 OL. It com-bines a two-level layout mapping, constraints and an engine to di-vide responsibilities between VM component and VM developers. We consider a domain-specific language like D 4 OL a necessary complement to behavioural aspect languages in order to modular-ize VM implementations...|$|E
40|$|Introduction The object-level tracing toolkit (OLTT) is a {{collection}} of an interface and several optimised algorithms and data structures intended for tracking individual objects in any object-based programming system. A variety of tracing tools can be built using the provided code to gather different object-level statistics. 2 Interface OLTT defines a simple interface between the instrumented object-based programming system and the object-level tracing routines. The interface makes only rudimentary assumptions about <b>object</b> <b>layout,</b> thus object-level tracing can be used with any foreseeable objectbased system. The only assumptions made about <b>object</b> <b>layout</b> in memory are that each object consists of a number of memory words, that there is a distinguished first word, that the first word at any time has an address, that no two objects have the same first word address at any time, and that o...|$|E
40|$|In this paper, {{we propose}} {{innovative}} system {{in order to}} assist the user in a 3 D <b>objects</b> <b>layout</b> context. Through a combination between virtual reality (VR) and constraint programming (CP) technique, user's 3 D interaction and manipulation will be translated to incoming queries of a constraints solver which propagate constraints and generate a new possible solution. The computed solution is transmitted, as new positions of 3 D objects, to virtual environment (VE) which reconfigures itself. We focus in this paper on the architecture of our system and we describe the implementation of several constraints and some first results...|$|R
40|$|Typed {{assembly}} languages usually support heap allocation safely, {{but often}} rely on an external garbage collector to deallocate {{objects from the}} heap and prevent unsafe dangling pointers. Even if the external garbage collector is provably correct, verifying {{the safety of the}} interaction between TAL programs and garbage collection is nontrivial. This paper introduces a typed assembly language whose type system is expressive enough to type-check a Cheney-queue copying garbage collector, so that ordinary programs and garbage collection can co-exist and interact inside a single typed language. The only built-in types for memory are linear types describing individual memory words, so that TAL programmers can define their own <b>object</b> <b>layouts,</b> method table layouts, heap layouts, and memory management techniques. 1...|$|R
50|$|In C++03, a {{class or}} struct must follow {{a number of}} rules {{for it to be}} {{considered}} a plain old data (POD) type. Types that fit this definition produce <b>object</b> <b>layouts</b> that are compatible with C, and they could also be initialized statically. The C++03 standard has restrictions on what types are compatible with C or can be statically initialized despite there being no technical reason a compiler couldn't accept the program; if someone were to create a C++03 POD type and add a non-virtual member function, this type would no longer be a POD type, could not be statically initialized, and would be incompatible with C despite no change to the memory layout.|$|R
40|$|<b>Object</b> <b>layout</b> schemes used in C++ {{and other}} {{languages}} rely on (sometimes numerous) compiler generated fields. We describe a language-independent <b>object</b> <b>layout</b> scheme, which is space optimal, i. e., objects are contiguous, and contain no compiler generated fields {{other than a}} single type identifier. As in C++ and other multiple inheritance languages such as Cecil and Dylan, the new scheme sometimes requires extra levels of indirection to access some of the fields. Using a data set of 28 hierarchies, totaling almost 50, 000 types, we show that this scheme improves field access efficiency over standard implementations, and competes favorably with (the non-space optimal) highly optimized C++ specific implementations. The benchmark includes an analytical model for computing the frequency of indirections in a sequence of field access operations. Our layout scheme relies on whole-program analysis, which requires about 10 micro-seconds per type on a contemporary architecture (Pentium III, 900 Mhz, 256 MB machine), even in very large hierarchies. We also present a layout scheme for separate compilation using the user-annotation of virtual inheritance edge that is used in C++...|$|E
40|$|Research into {{embedded}} sensor networks {{has placed}} increased {{focus on the}} problem of developing reliable and flexible software for microcontroller-class devices. Languages such as nesC [8] and Virgil [14] have brought higher-level programming idioms to this lowest layer of software, thereby adding expressiveness. Both languages are marked by the absence of dynamic memory allocation, which removes the need for a runtime system to manage memory. To provide data structures, nesC offers modules, and Virgil offers the application an opportunity to allocate and initialize objects during compilation. This paper explores techniques for compressing fixed object heaps with the goal of reducing the RAM footprint of a program. We explore table-based compression and introduce a novel form of <b>object</b> <b>layout</b> called vertical <b>object</b> <b>layout.</b> We provide experimental results that measure the impact on RAM size, code size, and execution time for a set of Virgil programs. Our results show that compressed vertical layout has better execution time and code size than tablebased compression while achieving more than 20 % heap reduction on 6 of 12 benchmark programs...|$|E
40|$|Java’s {{automatic}} {{memory management}} {{is the main}} reason that prevents Java from being used in hard realtime environments. We present the garbage collection mechanism that is used by the Jamaica Virtual Machine, an implementation of the Java Virtual Machine Specification. This mechanism differs significantly from existing implementations in the way threads are implemented, root references are found and in the <b>object</b> <b>layout</b> that is used. The implementation provides hard real-time guarantees while it allows unrestricted use of the Java language. Even dynamic allocation of normal garbage collected Java objects is possible with hard real-time guarantees. 1...|$|E
40|$|DESIGNER is a layout {{specification}} {{system for}} generically coded documents. It {{is based on}} the paradigm design by example and the methodology of using <b>layout</b> <b>objects</b> to provide graphic artists with an ergonomically sound user interface for their trade. In this paper we introduce <b>layout</b> <b>objects</b> and present DESIGNER 2 ̆ 7 S graphical user interface using some simple examples to explain the main ideas of our system...|$|R
40|$|This paper discribes a {{document}} analysis system broadly {{consisting of a}} knowledge base, a blackboard {{and a set of}} tasks having their own set of spacialists for segmentation, recognition and for inheritance. The knowledge base contains a generic hierarchical description of the document structure in terms of <b>layout</b> <b>objects</b> labeled logically. This allows the generation of hypothetic networks of linked objects in the blackboard. The specialists cooperate indirectly through the blackboard by updating the <b>layout</b> <b>object</b> descriptors. A blackboard modification causes an "event " to propagate up to some specific tasks. A task could then choose another subset of specialists to carry on with the process. Finally, a synthesized blackboard summary allows a task selector to focus efficiently on the most useful <b>layout</b> <b>object</b> to process. ...|$|R
40|$|Tree {{detection}} and reconstruction {{is of great}} interest in large-scale city modelling. In this paper, we present a marked point process model to detect single trees from airborne laser scanning (ALS) data. We consider single trees in ALS recovered canopy height model (CHM) as a realization of point process of circles. Unlike traditional marked point process, we sample the model in a constraint configuration space by making use of image process techniques. A Gibbs energy is defined on the model, containing a data term which judge the fitness of the model {{with respect to the}} data, and prior term which incorporate the prior knowledge of <b>object</b> <b>layouts.</b> We search the optimal configuration through a steepest gradient descent algorithm. The presented hybrid framework was test on three forest plots and experiments show the effectiveness of the proposed method...|$|R
40|$|This paper {{presents}} a procedural approach to generate furniture arrangements for large virtual indoor scenes. The interiors of buildings in 3 D city scenes are often omitted. Our solution creates rich furniture arrangements for all rooms of complex buildings {{and even for}} entire cities. The key idea is to only furnish the rooms {{in the vicinity of}} the viewer while the user explores a building in real time. In order to compute the <b>object</b> <b>layout</b> we introduce an agent-based solution and demonstrate the flexibility and effectiveness of the agent approach. Furthermore, we describe advanced features of the system, like procedural furniture geometry, persistent room layouts, and styles for high-level control...|$|E
40|$|This paper {{explains}} how the Alloy model-finding method {{has been used}} to check the specification of an electronic purse (also called smart card) system, called the Mondex case study, initially written in Z. After describing the payment protocol between two electronic purses, and presenting an overview of the Alloy model-finding method, this paper {{explains how}} technical issues about integers and conceptual issues about the <b>object</b> <b>layout</b> in Z have been tackled in Alloy, giving general methods {{that can be used in}} most case studies with Alloy. This work has also pointed out some significant bugs in the original Z specification such as reasoning bugs in the proofs, and proposes a way to solve them...|$|E
40|$|The object {{oriented}} (OO) paradigm {{has become the}} norm for software development. OO languages, such as C++ [58], JAVA [4], EIFFEL [43], and SMALLTALK’s [33], are used in almost every software project. The OO programming style, and the languages that enable it, have acquired an aura of respectability. OO programming promotes reusability, extendibility, reliability, and portability. But this come {{at a cost of}} runtime efficiency. This proposed research is to find efficient algorithms for (at least) four problems: subtyping tests, single dispatching, multiple dispatching, and <b>object</b> <b>layout.</b> It {{is important to note that}} although the problems take variations in different languages, these variations are minor. Our results will therefore be of general interest, and applicable to many different languages. ...|$|E
50|$|The Axis & Allies map editor lets players {{create their}} own maps to play in both singleplayer and {{multiplayer}} mode. Players are able to customize many map options, including player starting units, scenery <b>objects,</b> terrain <b>layout,</b> audio sources, and game triggers. Game triggers allow for custom creation of cutscenes, unit & VFX spawns, storylines, and military objectives.|$|R
40|$|We usually {{perceive}} {{things in}} our surroundings as unchanged despite viewpoint changes caused by self-motion. The visual system therefore {{must have a}} function to process objects independently of viewpoint. In this study, we examined whether viewpoint-independent spatial layout can be obtained implicitly. For this purpose, we used a contextual cueing effect, a learning effect of spatial layout in visual search displays known to be an implicit effect. We compared {{the transfer of the}} contextual cueing effect between cases with and without self-motion by using visual search displays for 3 D objects, which changed according to the participant’s assumed location for viewing the stimuli. The contextual cueing effect was obtained with self-motion but disappeared when the display changed without self-motion. This indicates that there is an implicit learning effect in spatial coordinates and suggests that the spatial representation of <b>object</b> <b>layouts</b> or scenes can be obtained and updated implicitly. We also showed that binocular disparity {{play an important role in}} the layout representations...|$|R
40|$|Spatial mental {{representations}} {{learned by}} the study of maps {{are thought to be}} orientation specific. Studies have shown that people have difficulty in making judgments from an orientation which is different from the orientation of the map itself. It has been hypothesized that such alignment effects can be attributed to differences in the number of viewpoints encountered during learning. The current study used virtual environments to test this hypothesis. Participants were presented several objects located on a plain within an immersive virtual environment. They learned the environment to a criterion level. The critical task for all experiments was to judge the accuracy with which subjects could identify correct triads of <b>object</b> <b>layouts</b> as well as the response latency to make the judgment. The results of the first experiment showed a linear increase in judgment time as the amount of normalization required of the stimulus increased thus supporting the multiple views theory. The results of the second experiment suggested that four viewpoints were needed for simple spacial configurations before orientation specificity could be eliminated...|$|R
40|$|This {{research}} studies {{the characteristics of}} field usage patterns in the SpecJVM 98 benchmarks. It finds that multiple object instances of the same class often exhibit different field-usage patterns. Motivated by this observation, we designed a heap compression mechanism that classifies object instances at runtime based on their field-usage patterns and eliminates unused fields to save space. To achieve the maximum space savings while minimizing the space and time overhead, our design combines three interrelated techniques in a novel manner: runtime object instance classification, field virtualization, and bidirectional <b>object</b> <b>layout.</b> An experimental evaluation reveals that this mechanism can reduce the maximum heap occupancy of SpecJVM 98 benchmarks by up to 18 % and 14 % on average while keeping the application execution overhead low. 1...|$|E
40|$|We propose SCALPEL, a {{flexible}} method for object segmentation that integrates rich region-merging cues with mid- and high-level information about <b>object</b> <b>layout,</b> class, and scale into the segmentation process. Unlike competing approaches, SCALPEL uses {{a cascade of}} bottom-up segmentation models {{that is capable of}} learning to ignore boundaries early on, yet use them as a stopping criterion once the object has been mostly segmented. Furthermore, we show how such cascades can be learned efficiently. When paired with a novel method that generates better localized shape priors than our competitors, our method leads to a concise, accurate set of segmentation proposals; these proposals are more accurate on the PASCAL VOC 2010 dataset than state-of-the-art methods that use re-ranking to filter much larger bags of proposals. The code for our algorithm is available online. 1...|$|E
40|$|Abstract In this paper, {{we present}} a {{simultaneous}} segmentation algorithm for multiple highly-occluded objects, which combines high-level knowledge and low-level information in a unified framework. The high-level knowledge provides sophis-ticated shape priors with the consideration of blocking relationship between nearby objects. Different from conventional layered model which attempts to solve the full ordering problem, we decompose the problem {{into a series of}} pairwise ones and this makes our algorithm scalable to a large number of objects. Objects are segmented in pixel level with higher-order soft constraints from superpixels, by a dual-level conditional random field. The model is optimized alternately by <b>object</b> <b>layout</b> and pixel-wise segmentation. We evaluate our system on different objects, i. e., clothing and pedestrian, and show impressive segmentation results and significant improvement over state-of-the-art segmentation algorithms...|$|E
40|$|In {{this work}} {{we seek to}} move away from the {{traditional}} paradigm for 2 D object recognition whereby objects are identified in the image as 2 D bounding boxes. We focus instead on: i) detecting objects; ii) identifying their 3 D poses; iii) characterizing the geometrical and topological properties of the objects in terms of their aspect configurations in 3 D. We call such characterization an <b>object’s</b> aspect <b>layout</b> (see Fig. 1). We propose a new model for solving these problems in a joint fashion from a single image for object categories. Our model is constructed upon a novel framework based on conditional random fields with maximal margin parameter estimation. Extensive experiments are conducted to evaluate our model’s performance in determining <b>object</b> pose and <b>layout</b> from images. We achieve superior viewpoint accuracy results on three public datasets and show extensive quantitative analysis to demonstrate the ability of accurately recovering the aspect <b>layout</b> of <b>objects.</b> 1...|$|R
40|$|A scene {{category}} imposes tight distributions {{over the}} kind of objects that might appear in the scene, the appear-ance of those <b>objects</b> and their <b>layout.</b> In this paper, we propose a method to learn scene structures that can encode three main interlacing components of a scene: the scene category, the context-specific appearance of <b>objects,</b> and their <b>layout.</b> Our experimental evaluations show that our learned scene structures outperform state-of-the-art method of Deformable Part Models in detecting objects in a scene. Our scene structure provides a level of scene understanding that is amenable to deep visual inferences. The scene struc-tures can also generate features that can later be used for scene categorization. Using these features, we also show promising results on scene categorization. 1...|$|R
40|$|As {{computer}} graphical {{user interfaces}} (GUIs) are loaded with increasingly greater numbers of objects, researchers in HCI are forced {{to look for the}} next step in constructing user interface. In this paper, we examine the effects of employing more “natural ” representations in GUIs. In particular, we experimentally assess the impact of object form (2 D iconic versus 3 D realistic) and layout (regular versus ecological) have on target acquisition time. Results indicate that both form and layout significantly affect performance; subjects located targets more quickly when using interfaces with 3 D <b>objects</b> and ecological <b>layouts</b> than they do with 2 D <b>objects</b> and regular <b>layouts.</b> An interface with an ecological <b>layout,</b> realistic <b>objects,</b> or both may be an improvement over traditional interfaces...|$|R
