10|11|Public
50|$|Current {{developments}} try {{to integrate}} the visual programming approach with dataflow programming languages to either have immediate access to the program state, resulting in <b>online</b> <b>debugging,</b> or automatic program generation and documentation. Dataflow languages also allow automatic parallelization, {{which is likely to}} become one of the greatest programming challenges of the future.|$|E
40|$|This paper {{presents}} LiteOS, a multi-threaded {{operating system}} that provides Unix-like abstractions for wireless sensor networks. Aiming {{to be an}} easy-to-use platform, LiteOS offers a number of novel features, including: (1) a hierarchical file system and a wireless shell interface for user interaction using UNIX-like commands; (2) kernel support for dynamic loading and native execution of multithreaded applications; and (3) <b>online</b> <b>debugging,</b> dynamic memory, and file system assisted communication stacks. LiteOS also supports software updates through a separation between the kernel and user applications, which are bridged through a suite of system calls. Besides the features that have been implemented, we also describe our perspective on LiteOS as an enabling platform. We evaluate the platform experimentally by measuring the performance of common tasks, and demonstrate its programmability through twenty-one example applications. ...|$|E
30|$|To allow {{doctors to}} monitor the {{physical}} parameters of the patient’s body in real time and to understand {{the changes in the}} patient’s condition in time, the medical remote monitoring system based on the Internet of Things was studied. From the perspective of practical application of hospital wards, a medical health monitoring system was designed with the help of CC 2430 microcontroller, human information sensor, and microelectronic and modern wireless communication technology. In addition, a sensor node circuit and a coordinator node circuit for collecting medical signals were designed. Meanwhile, the software of wireless sensor network was designed. Finally, the <b>online</b> <b>debugging</b> of each system module was combined with hardware and software. The experimental result proved that the network node was reliable and the data transmission was accurate. It is concluded that the medical monitoring system basically meets the design requirements of this paper.|$|E
40|$|Abstract—As {{complexity}} {{and size of}} Systems-on-Chip (SoC) grow, debugging becomes a bottleneck for designing IC products. In this paper, we present an approach for <b>online</b> <b>debug</b> of NoC-based multiprocessor SoCs. Our approach utilizes monitors and filters implemented in hardware. Monitors and filters observe and filter transactions at run-time. They are connected to a Debug Unit (DU). Transaction-based programmable Finite State Machines (FSMs) in the DU check assertions online to validate the correct relation of transactions at run-time. The experimental results show efficiency and performance of our approach. Keywords—transaction-based <b>online</b> <b>debug,</b> system-on-chip (SoC), network-on-chip (NoC) I...|$|R
40|$|This paper {{presents}} a concurrent soft-error resilience (CSER) scheme with features that aid manufacturing test, <b>online</b> <b>debug,</b> and defect tolerance. The proposed CSER scheme {{is based on}} the built-in soft-error resilience (BISER) technique [4]. A BISER cell is redesigned into various robust CSER cells that provide slow-speed snapshot, manufacturing test, slow-speed signature analysis, and defect tolerance capabilities. The cell-level area, power, and performance overhead of the robust CSER cells were found to be generally within 1 % to 22 % of the BISER cell. 1...|$|R
5000|$|Improved {{testing and}} {{debugging}} including off-line testing, improved <b>debugging,</b> <b>online</b> terminal testing, and logging.|$|R
40|$|Although {{in recent}} years many {{research}} activities {{have been carried out}} on underwater communication, still many challenges need to be tackled to make the underwater communication suitable for real applications. To this end, availability of an open and well-designed platform and performing realworld experiments are crucial. In reality, the real-world experiments have proved to be much more difficult than expected as the underwater communication channel has not yet fully and precisely been modeled and the performance of signal processing part might be varied from application to application. The deployment itself, <b>online</b> <b>debugging,</b> dealing with variable channel characteristics, and packaging are issues making reallife underwater communication experiments challenging. In this paper, we present initial results of dealing with and solving some practical problems of experimenting with an underwater wireless sensor node platform. We also highlight the drawbacks of current underwater research platform as far as deployments are concerned...|$|E
40|$|This paper {{describes}} {{the design and}} construction of a Haskell source-level debugger built into the GHCi interactive environment. We have taken a pragmatic approach: the debugger {{is based on the}} traditional stop-examine-continue model of <b>online</b> <b>debugging,</b> which is simple and intuitive, but has traditionally been shunned in the context of Haskell because it exposes the lazy evaluation order. We argue that this drawback is not as severe as it may seem, and in some cases is an advantage. The design focuses on availability: our debugger is intended to work on all programs that can be compiled with GHC, and without requiring the programmer to jump through additional hoops to debug their program. The debugger has a novel approach for reconstructing the type of runtime values in a polymorphic context. Our implementation is light on complexity, and was integrated into GHC without significant upheaval. 1...|$|E
40|$|The {{development}} of webpages and web applications {{has become one}} of the most popular fields of programming. It is then only natural that often during the {{development of}} those web projects a problem appears, and the programmer needstosolveitasquicklyaspossible,evenwhenhedoesn'thaveaccesstohisown computer. In this thesis we create a simple integrated development tool attachable to a web application managed by the tool's user in a way that the user's web application can be edited online in a web browser. In contrast with other currently popular online developer environments, our IDE is located and run on the same server as the user's application. The IDE can manage the user's application's files and edit its source codes. Additionally, the IDE contains a tool for managing databases, a tool for <b>online</b> <b>debugging</b> of PHP scripts and an integrated version control system used to track and manage changes done to the user's project. Powered by TCPDF (www. tcpdf. org...|$|E
40|$|Abstract. This paper {{discusses}} {{the principle of}} SPWM, {{as well as its}} mathematical models, highlight introduce the generation principle of SPWM wave based on TI digital signal processor TMS 320 LF 2407 A. The formula and mathematical model are simplified by using the symmetric regular sampling method. Update the value of the program by comparing the look-up table, this method improves the operational efficiency, and reduces the error generation. The paper detailed analysis the configuration of each register in event manager module, and gives a critical interrupt subroutine. Through <b>online</b> simulation <b>debugging,</b> get the correct SPWM and the corresponding dead-time waveform...|$|R
40|$|On-line {{parallel}} debugging {{can provide}} very accurate and reliable information in diagnosis of parallel programs. Unfortunately, commercially available tools for on-line parallel debugging are hardly seen. This is mainly {{due to the}} lack of a suitable environment for multiprogramming of mixed parallel and sequential workloads so that the resources cannot be utilised efficiently. In this paper we present a two-level scheduling scheme for mixed parallel and sequential workloads on parallel machines [...] a key step in the establishment of a proper environment for <b>online</b> parallel <b>debugging.</b> 1 Introduction On-line parallel debugging is defined as debugging a parallel program during its execution on a real parallel system. It is in contrast to off-line parallel debugging which means the debugging of parallel programs is done by running a simulator on a sequential machine, or by accumulating trace data during the program execution and then analysing them post-mortem. There are several problems a [...] ...|$|R
25|$|In {{addition}} to the native computer software, there are <b>online</b> JavaScript IDEs, <b>debugging</b> aids that are themselves written in JavaScript and built to run on the Web. An example is the program JSLint, developed by Douglas Crockford {{who has written extensively}} on the language. JSLint scans JavaScript code for conformance to a set of standards and guidelines. Many libraries for JavaScript, such as three.js, provide links to demonstration code that can be edited by users. They are also used as a pedagogical tool by institutions such as Khan Academy to allow students to experience writing code in an environment where they can see the output of their programs, without needing any setup beyond a Web browser.|$|R
40|$|Homogeneous {{and stable}} {{magnetic}} field {{is essential for}} a high-resolution NMR spectrum, especially one which requires signal averaging or phase cycling. The field-frequency lock technique can effectively improve the long-term stability of the magnetic field. The whole design scheme of the lock system for NMR spectrometer is presented in this paper. The digital control is implemented with Xilinx Virtex- 4 FPGA, XC 4 VFX 12 -FF 668, the signal received from the probe is detected by the quadrature detector, and the resonance frequency drift is locked by the quasi-feedback loops. In the slave computer of the lock system, Wind River's VxWorks real-time operating system is chosen to fulfill the strict requirement {{for the performance of}} real-time data acquisition and control, as well as the stability of operation system. <b>Online</b> <b>debugging</b> with the Varian 500 MHz spectrometer shows that the lock system achieves the goal of compensating for the intrinsic drift of a superconducting magnet field...|$|E
40|$|Hard {{real-time}} {{systems have}} stringent timing and resource require-ments. As such, debugging and tracing such systems often requires low-level hardware support, and <b>online</b> <b>debugging</b> is usually pre-cluded entirely. In other areas, visual debugging has greatly im-proved program understanding and late cycle development times for non real-time applications. In this paper we introduce a visual test and debug framework for hard real-time Java applications {{built around the}} JIVE platform and realized in the Fiji VM. Our framework, called JI. FI ["dZIfi], provides high-level debug-ging support over low-level execution traces. JI. FI provides both powerful visualizations and real-time centric temporal query sup-port. To ensure preservation of the real-time characteristics of the application being tested and debugged, JI. FI leverages a real-time event log infrastructure that logs only relevant application and vir-tual machine level events, such as synchronization and modifica-tions to priorities or thread state. Our performance results indicate that our logging infrastructure is suitable for hard real-time sys-tems, as the performance impact is both uniform and quantifiable...|$|E
40|$|The {{purpose is}} to achieve drive {{controller}} of PMSM connect with industrial control configuration software seamless and to meet the industrial configuration software in the demand for motor to realize intelligent control. A software interface was designed and implemented about motor drive controller and the PC the industrial control configuration base on Modbus_RTU serial communication protocol of industrial control. One kind of design and implementation methods have been proposed in the communication interfaces for industrial applications scalable multiselectivity. Using the latest high-performance multiprotocol transceiver device pin programmable SP 339 as the lower machine communications chip designed optional multi-interface hardware circuit with DSP TMS 320 F 2812 as the processor. The interface program was studied with regard to C language software of lower machine and control configuration software of PC. Database creation, data acquisition, and animation links of PC configuration software are realized. <b>Online</b> <b>debugging</b> results meet the design requirements on account of PC control configuration software and the lower machine controller hardware and software...|$|E
40|$|Abstract On-line {{parallel}} debugging {{can provide}} very accurate and reliable information in diagnosis of parallel programs. Unfortunately, commercially available tools for on-line parallel debugging are hardly seen. This is mainly {{due to the}} lack of a suitable environment for multiprogramming of mixed parallel and sequential workloads so that the resources cannot be utilised efficiently. In this paper we present a two-level scheduling scheme for mixed parallel and sequential workloads on parallel machines- a key step in the establishment of a proper environment for <b>online</b> parallel <b>debugging.</b> 1 Introduction On-line parallel debugging is defined as debugging a parallel program during its execution on a real parallel system. It is in contrast to off-line parallel debugging which means the debugging of parallel programs is done by running a simulator on a sequential machine, or by accumulating trace data during the program execution and then analysing them post-mortem. There are several problems associated with off-line parallel debugging. When a simulation is carried out on a sequential machine, parallel computation is actually serialised. Then the simulation may not exactly match the real situation. Problems caused by asynchronous events (e. g. asynchronous messages between differen...|$|R
40|$|Thesis (Ph. D.) [...] University of Washington, 2015 This {{dissertation}} describes Gidget, an <b>online</b> educational <b>debugging</b> {{game that}} is designed to engage and teach novices introductory programming concepts. Players solve puzzles throughout the game to help a robotic character complete its missions. These puzzles are actually debugging tasks, where players must inspect, modify, and test existing code to fulfill the goals that are written as test cases. Each level teaches a specific concept or set of concepts related to topics that are covered in introductory programming courses. The dissertation defines the core principles that constitute an educational debugging game. Three controlled experimental studies show that the game is engaging to novice programmers. This was especially true when 1) the compiler/interpreter and its feedback messages were personified, 2) objects in the game attributed more purpose to the game goals, and 3) assessments were integrated seamlessly into the game. Another controlled experiment, where participants were assigned to use one of three learning interventions, revealed that those who completed the Gidget game or an online tutorial on a website called Codecademy showed similar learning gains, with Gidget players doing so in about half the time. Thousands of people have played Gidget through its development and public release. It {{has been shown to be}} appealing to a broad range of users independent of age, gender, education, or place of residence. A total of 68 teenagers from underrepresented groups in computing (i. e., females, and those from rural communities) took part in four, weeklong summer camps. With only about 5 hours of training playing through and completing the Gidget game, these teenagers were able to create a total of 210 of their own Gidget levels with minimal or no outside help. Furthermore, Gidget has attracted several thousands of players since its release. Registered players, composed of 54. 8 % males and 45. 2 % females, completed 0 - 37 levels playing between between 1 minute to 5. 22 hours each...|$|R
40|$|Abstract—This work {{proposes a}} new, software-based, defect {{detection}} and diagnosis technique. We introduce a novel set of instructions, called Access-Control Extensions (ACE), that can access {{and control the}} microprocessor’s internal state. Special firmware periodically suspends microprocessor execution and uses the ACE instructions to run directed tests on the hardware. When a hardware defect is present, these tests can diagnose and locate it, and then activate system repair through resource reconfiguration. The software nature of our framework makes it flexible: testing techniques can be modified/upgraded {{in the field to}} trade-off performance with reliability without requiring any change to the hardware. We describe and evaluate different execution models for using the ACE framework. We also describe how the proposed ACE framework can be extended and utilized {{to improve the quality of}} post-silicon debugging and manufacturing testing of modern processors. We evaluated our technique on a commercial chipmultiprocessor based on Sun’s Niagara and found that it can provide very high coverage, with 99. 22 percent of all silicon defects detected. Moreover, our results show that the average performance overhead of software-based testing is only 5. 5 percent. Based on a detailed register transfer level (RTL) implementation of our technique, we find its area and power consumption overheads to be modest, with a 5. 8 percent increase in total chip area and a 4 percent increase in the chip’s overall power consumption. Index Terms—Reliability, hardware defects, online defect detection, testing, <b>online</b> self-test, post-silicon <b>debugging,</b> manufacturing test. Ç...|$|R
40|$|Where {{the role}} of software-intensive systems has shifted from the {{traditional}} one of fulfilling isolated computational tasks, larger collaborative societies with interaction as primary resource, is gradually taking its place. This {{can be observed in}} anything from logistics to rescue operations and resource management, numerous services with key-roles in the modern infrastructure. In the light of this new collaborative order, it is imperative that the tools (compilers, debuggers, profilers) and methods (requirements, design, implementation, testing) that supported traditional software engineering values also adjust and extend towards those nurtured by the online instrumentation of software intensive systems. That is, to adjust and to help to avoid situations where limitations in technology and methodology would prevent us from ascertaining the well-being and security of systems that assists our very lives. Coupled with most perspectives on software development and maintenance is one well established member of, and complement to, the development process. Debugging; or the art of discovering, localising, and correcting undesirable behaviours in software-intensive systems, the need for which tend to far outlive development in itself. Debugging is currently performed based on a premise of the developer operating from a god-like perspective. A perspective that implies access and knowledge regarding source code, along with minute control over execution properties. However, the quality as well as accessibility of such information steadily decline with time as requirements, implementation, hardware components and their associated developers, all alike fall behind their continuously evolving surroundings. In this thesis, it is argued that the current practice of software debugging is insufficient, and as precursory action, introduce a technical platform suitable for experimenting with future methods regarding <b>online</b> <b>debugging,</b> maintenance and analysis. An initial implementation of this platform will then be used for experimenting with a simple method that is targeting online observation of software behaviour...|$|E
40|$|A {{complete}} {{computational model}} for industrial robot programming is presented. There {{are two main}} objectives in realizing this model. The first is to allow shop floor production engineers (application programmers) to create and modify sensor-based robot programs. The proposed iconic user interface provides a non-textual programming mechanism. The icons, which represent individual robot skills, are linked and parameterized to modify the behaviour of the skills. Use of a control flow mechanism, as opposed to data flow, makes {{the description of the}} robot operation as a set of skills immediately obvious. Linking the skill icons requires only a few control constructs which makes the interface usable on the shop floor. This system provides a mechanism for <b>online</b> creation and <b>debugging</b> of sensor-based robot operations. The second objective is to enable the system programmer to create and maintain the robot skills using consistent and facilitated methods. This is the underlying software architecture that makes the iconic shop floor interface possible. It is an object-based method that provides functional abstraction of the sensors and machines. The objects include skills, sensor drivers, logical sensors, and machine drivers. The skills are defined in the form of templates that completely specify a sensor-based robot action. Other significant results ensue from the two listed above, for example, the possibility of standardization in robot programming at the skill level. The ability to separate the responsibilities of individuals with different capabilities is another objective that has the side effect of making robot systems development manageable. The computational model presented is called "SKills-Oriented Robot Programming (SKORP). " In this model the skills execute exclusive of each other and therefore the computation for each skill can be represented independently. Skills are designed and documented using realtime design tools from the multiactivity paradigm. The SKORP model provides consistent and usable design methods for describing computation in embedded systems. These design tools are used by the system programmer to guarantee the realtime interaction of the software modules that compose a skill. This research is directed toward industrial robotics in traditional and non-traditional habitats, but the model presented is equally applicable to any numerically controlled machine that either requires sensors or interacts with the environment in a complex way...|$|R

