1|42|Public
40|$|A {{combining}} {{window is}} an interval {{of time in}} a combining node during which incoming requests are gathered in the node in order to combine them into a single <b>outgoing</b> <b>request.</b> Our thesis is that a combining window is {{necessary in order to}} realize the dual forms of concurrency — execution and storage concurrency — that a combining tree is designed to achieve. Execution concurrency among the nodes at each level of a combining tree is necessary for the tree to achieve the speed up that it is designed to give. Without sufficient execution concurrency, the tree will not achieve the desired speed up. Storage concurrency among the nodes at each level of a combining tree is necessary for the tree to achieve the buffer storage that is required in order to implement the combining of requests. Without sufficient storage concurrency, node buffers will overflow. More specifically, the combining window shows how to bound node buffer size. ivv For Marie who has put up with so much and so little for so longvivi...|$|E
50|$|The Polipo proxy {{pipelines}} <b>outgoing</b> <b>requests.</b>|$|R
50|$|Most HTTP proxies do not {{pipeline}} <b>outgoing</b> <b>requests.</b>|$|R
50|$|By {{establishing}} an SSH tunnel, a user can forward all their traffic over an encrypted channel, so both <b>outgoing</b> <b>requests</b> for blocked sites {{and the response}} from those sites are hidden from the censors, for whom it appears as unreadable SSH traffic.|$|R
5000|$|Some {{versions}} of the Squid web proxy will pipeline up to two <b>outgoing</b> <b>requests.</b> This functionality has been disabled by default {{and needs to be}} manually enabled for [...] "bandwidth management and access logging reasons." [...] Squid supports multiple requests from clients.|$|R
50|$|An HTTP module is an {{assembly}} {{that is called}} on every request that is made to your application. HTTP modules are called {{as part of the}} ASP.NET request pipeline and have access to life-cycle events throughout the request. HTTP modules let you examine incoming and <b>outgoing</b> <b>requests</b> and take action based on the request.|$|R
50|$|The stub acts as {{a gateway}} for client side objects and all <b>outgoing</b> <b>requests</b> to server side objects that are routed through it. The stub wraps client object {{functionality}} and by adding the network logic ensures the reliable communication channel between client and server. The stub can be written up manually or generated automatically depending on chosen communication protocol.|$|R
50|$|NAT {{devices are}} {{commonly}} used to alleviate IPv4 address exhaustion by allowing the use of private IP addresses on private networks behind routers with a single public IP address facing the public Internet. The internal network devices communicate with hosts on the external network by changing the source address of <b>outgoing</b> <b>requests</b> {{to that of the}} NAT device and relaying replies back to the originating device.|$|R
25|$|Network {{firewalls}} prevent unknown {{programs and}} processes from accessing the system. However, {{they are not}} antivirus systems and make no attempt to identify or remove anything. They may protect against infection from outside the protected computer or network, and limit the activity of any malicious software which is present by blocking incoming or <b>outgoing</b> <b>requests</b> on certain TCP/IP ports. A firewall is designed to deal with broader system threats that come from network connections into the system and is not an alternative to a virus protection system.|$|R
30|$|During this checks, {{we found}} another issue of interest. While Azure Resource Managers prohibits Echo Requests from the virtual {{instance}} to other targets; Azure Classics seems {{to let them}} pass {{as well as their}} replies. This implies that there are some statefulness insofar as echo replies to <b>outgoing</b> <b>requests</b> are allowed to pass. In consequence, we re-tried our checks at Amazon Classic for Path MTU discovery answering to a previously outgoing UDP packets, however, still without success. In consequence, only Amazon shows behavior that is accordant with RFC 2979 [25].|$|R
40|$|Abstract—Third-party {{embedded}} scripts {{provide a}} powerful {{way to build}} rich web applications, but raise important security risks. These untrusted scripts can access everything on the embedding web pages including sensitive data, which can then be leaked to malicious third-party servers. We propose RedactDOM, an egress-based approach that prevents untrusted scripts from leaking sensitive information without disrupting the scripts’ functionality. For each page, a projection page is created with a redacted DOM that has the structure and scripts from the original page but removes all potentially sensitive data. RedactDOM blocks <b>outgoing</b> <b>requests</b> generated by untrusted scripts on the real page and replaces them with a safe substitutes from the redacted page. I...|$|R
5000|$|Spare resources, {{providing}} {{central services}} for multiple applications. e.g.: The {{control of all}} incoming and <b>outgoing</b> SIP <b>requests</b> are managed by the SIP service, avoiding the creation of one SIP stack and allocation of a network port for each SIP-based application.|$|R
5000|$|DNS {{blocking}} {{can also}} be applied for <b>outgoing</b> <b>requests</b> as well. Instead of returning the valid IP address of a requested site (for example, instead of 198.35.26.96 being returned by the DNS when [...] "www.wikipedia.org" [...] is entered into a browser, if this IP were on a block list, the DNS might reply that the domain is unknown or with a different IP address that directs to a site with a page stating that the requested domain is not permitted). The latter case where the user is redirected to another destination would be considered DNS Spoofing, otherwise known as [...] "DNS Poisoning". DNS blocking {{can be applied to}} individual servers/IP address, or entire blocks of IP addresses.|$|R
40|$|Part 5 : Interaction at the WorkplaceInternational audienceReminding {{others to}} do {{something}} or bringing something to someone’s attention by sending reminders is common in the workplace. Our goal {{was to create a}} system to reduce the cognitive overhead for employees to manage their email, specifically the incoming and <b>outgoing</b> <b>requests</b> with their colleagues and others. We build on prior research on social request management, interruptions, and cognitive psychology in the design of such a system that includes an email reminder creation algorithm, with a built-in learning mechanism for improving such reminders over time, and a reminder delivery user interface. The system is delivered to users through a browser plugin, allowing it to be built on top of an existing web-based email system within an enterprise...|$|R
50|$|In early {{versions}} of MojoNation, users {{were required to}} set prices for any services their node provided. Most users {{had no idea how}} to choose prices, so the Mojo layer was rewritten to use a second-price rolling auction. Each node maintained a queue of incoming requests that had not yet been processed, sorted by a bid field contained in each request. Requests were serviced in order, from highest to lowest bids. This shifted the burden of pricing decisions from servers to clients: each user could set a price he was willing to pay for services, and his node would offer that bid in <b>outgoing</b> <b>requests.</b> This scheme was intended to create a simple feedback loop: if the system is responding slowly, increase your bid and if the system is responding quickly, decrease it.|$|R
40|$|Abstract. Cross-site {{scripting}} (XSS) vulnerabilities make {{it possible}} for worms to spread quickly to a broad range of users on popular Web sites. To date, the detection of XSS worms has been largely unexplored. This paper proposes the first purely client-side solution to detect XSS worms. Our insight is that an XSS worm must spread from one user to another by reconstructing and propagating its payload. Our approach prevents the propagation of XSS worms by monitoring <b>outgoing</b> <b>requests</b> that send self-replicating payloads. We intercept all HTTP requests on the client side and compare them with currently embedded scripts. We have implemented a cross-platform Firefox extension that is able to detect all existing self-replicating XSS worms that propagate on the client side. Our test results show that it incurs low performance overhead and reports no false positives when tested on popular Web sites...|$|R
40|$|Viola is a newly {{developed}} document delivery system that handles incoming and <b>outgoing</b> <b>requests</b> for printed books, articles, sharing electronic resources, and other document delivery services {{on the local}} level in a library organisation. An important part of Viola is the stack fetching Android application that enables librarians to collect books in the open and closed stacks in an efficient manner using a smartphone and a Bluetooth connected portable printer. The aim {{of this article is to}} show how information is transferred between systems and devices in Viola. The article presents code examples from Viola that use current. NET technologies. The examples span from the creation of high-level REST-based JSON APIs to byte array communication with a Bluetooth connected printer and the reading of RFID tags. Please note that code examples in this article are for illustration purposes only. Null checking and other exception handling has been removed for clarity. Code that is separated in Viola for testability and other reasons has been brought together to make it more readable...|$|R
5000|$|A {{client program}} (e.g. browser) either has to specify {{explicitly}} the proxy server {{it wants to}} use (typical for ISP customers), {{or it could be}} using a proxy without any extra configuration: [...] "transparent caching", in which case all <b>outgoing</b> HTTP <b>requests</b> are intercepted by Squid and all responses are cached. The latter is typically a corporate set-up (all clients are on the same LAN) and often introduces the privacy concerns mentioned above.|$|R
40|$|As {{the number}} of {{processors}} in multiprocessor system-on-chip devices continues to in-crease, the complexity required for full cache coherence support is often unwarranted for application-specific designs. Bus-based interconnects are no longer suitable for larger-scale systems, and the logic and storage overhead {{associated with the use}} of a complex packet-switched network and directory-based cache coherence may be undesirable in single-chip systems. Unidirectional rings are a suitable alternative because they offer many properties favorable to both on-chip implementation and to supporting cache coherence. Reducing the overhead of cache coherence traffic is, however, a concern for these systems. This thesis adapts two filter structures that are based on principles of coarse-grained coherence tracking, and applies them to a ring-based multiprocessor. The first structure tracks the total number of blocks of remote data cached by all processors in a node for a set of regions, where a region is a large area of memory referenced by the upper bits of an address. The second structure records regions of local data whose contents are not cached by any remote node. When used together to filter incoming or <b>outgoing</b> <b>requests...</b>|$|R
40|$|BlockChain (BC) has {{attracted}} tremendous attention {{due to its}} immutable nature and the associated security and privacy benefits. BC {{has the potential to}} overcome security and privacy challenges of Internet of Things (IoT). However, BC is computationally expensive, has limited scalability and incurs significant bandwidth overheads and delays which are not suited to the IoT context. We propose a tiered Lightweight Scalable BC (LSB) that is optimized for IoT requirements. We explore LSB in a smart home setting as a representative example for broader IoT applications. Low resource devices in a smart home benefit from a centralized manager that establishes shared keys for communication and processes all incoming and <b>outgoing</b> <b>requests.</b> LSB achieves decentralization by forming an overlay network where high resource devices jointly manage a public BC that ensures end-to-end privacy and security. The overlay is organized as distinct clusters to reduce overheads and the cluster heads are responsible for managing the public BC. LSB incorporates several optimizations which include algorithms for lightweight consensus, distributed trust and throughput management. Qualitative arguments demonstrate that LSB is resilient to several security attacks. Extensive simulations show that LSB decreases packet overhead and delay and increases BC scalability compared to relevant baselines...|$|R
40|$|In this study, we {{analyzed}} KERIS Document Delivery Service (DDS) using its transaction {{data for the}} period of nine years from 2004 to 2012. We first examined the overall statistics focusing on member contributions, and conducted a network analysis based on the records of request/response (supply) between member libraries. Key findings include the following: First, in over 80 % of member libraries, the number of <b>outgoing</b> <b>requests</b> exceeded the number of their responses to incoming requests. That is, {{for the vast majority of}} member libraries, their participation was concentrated on the request side. Second, KERIS DDS relies heavily on a relatively small number of top contributors, especially on the supply side. While the top contributors were active in both requests and responses (supplies), in most cases, they received and processed a disproportionally large number of requests. Third, the network analysis based on DDS requests for journal articles in 2012 further revealed the central role of top contributors. The level and pattern of concentration, however, appeared to differ by subjects (DDC). Three main patterns of centralization were found in different subjects - a network centered on a single member, a network having multiple centers, or a distributed network...|$|R
5000|$|The {{network layer}} manages routing, {{processing}} received messages and being capable of broadcasting <b>requests.</b> <b>Outgoing</b> frames {{will use the}} adequate link key according to the routing if it is available; otherwise, the network key {{will be used to}} protect the payload from external devices.|$|R
2500|$|Many Internet service {{providers}} restrict their customers' {{ability to perform}} port scans to destinations outside of their home networks. [...] This is usually covered {{in the terms of}} service or acceptable use policy to which the customer must agree. Some ISPs implement packet filters or transparent proxies that prevent <b>outgoing</b> service <b>requests</b> to certain ports. For example, if an ISP provides a transparent HTTP proxy on port 80, port scans of any address will appear to have port 80 open, regardless of the target host's actual configuration.|$|R
50|$|The DNS {{protocol}} vulnerability {{announced by}} Dan Kaminsky on July 8, 2008 is indirectly affected by NAT port mapping. To avoid DNS server cache poisoning, {{it is highly}} desirable not to translate UDP source port numbers of <b>outgoing</b> DNS <b>requests</b> from a DNS server which is behind a firewall that implements NAT. The recommended work-around for the DNS vulnerability is to make all caching DNS servers use randomized UDP source ports. If the NAT function de-randomizes the UDP source ports, the DNS server becomes vulnerable.|$|R
50|$|Many Internet service {{providers}} restrict their customers' {{ability to perform}} port scans to destinations outside of their home networks. This is usually covered {{in the terms of}} service or acceptable use policy to which the customer must agree. Some ISPs implement packet filters or transparent proxies that prevent <b>outgoing</b> service <b>requests</b> to certain ports. For example, if an ISP provides a transparent HTTP proxy on port 80, port scans of any address will appear to have port 80 open, regardless of the target host's actual configuration.|$|R
40|$|Abstract—Reflector {{attacks are}} {{a variant of}} denial-of-service attacks that use unwitting, {{legitimate}} servers to flood a target. The attacker spoofs the target’s address in legitimate service requests, such as TCP SYN packets. The servers, called “reflectors, ” reply to these requests, flooding the target. RAD is a novel defense against reflector attacks. It has two variants – locally-deployed (L-RAD) and core-deployed (C-RAD). Local RAD uses message authentication codes (MACs) to mark <b>outgoing</b> <b>requests</b> at their source, so {{the target of a}} reflector attack can differentiate between replies to legitimate and spoofed requests. MACs can be validated either at the target machine or on a gateway router at the target’s network. Core RAD, which is deployed at the AS level, handles larger attacks that overwhelm L-RAD. The source AS marks each packet it sends with a hash message authentication code (HMAC) and core ASes filter packets that carry incorrect HMACs. C-RAD prevents reflector attacks by filtering spoofed requests, rather than filtering reflected replies. We tested both variants using the DETER testbed by replaying backbone traces from the MAWI project archive in a congestionresponsive manner. Our tests show that Local RAD is better than the no-defense case, but gets overwhelmed when the attack exceeds the target’s network capacity. Core-deployed RAD successfully handles attacks of all rates...|$|R
50|$|Legislation {{passed in}} 1992 {{led to the}} {{establishment}} of Local Government Commission whose remit was to review the system created in 1974. As a result there was a partial reorganisation, with a number of districts with borough or city status being abolished. The mechanism of creating charter trustees to preserve civic traditions was again used. However, trustees were created only where an <b>outgoing</b> council <b>requested</b> their establishment. The failure of the extinguished City of Rochester-upon-Medway council to appoint charter trustees for Rochester or to apply for Rochester's city status to be transferred to the replacement unitary authority of Medway led to Rochester losing its city status.|$|R
25|$|Calls from manual {{offices to}} panel offices {{required}} the A board, or <b>outgoing</b> operator, to <b>request</b> the number from the caller, connect to an idle trunk {{to the distant}} exchange and relay the desired number to the B Board Manual Incoming Call operator, who keyed it to the Panel machine for setting up the incoming and final frames to the called telephone number.|$|R
30|$|MaaS {{components}} come {{in three}} variants, {{depending on their}} position in the data flow of the application. They are observing the external behaviour (input and/or output) of the functional component inside the SCC component (see Figs 1 and 4). They play the role of interceptors: e.g. for an input MaaS, that we call InMonitor, incoming service requests are intercepted, the interceptor component stores the non-functional information about the requests, which are then transmitted (unchanged) to the functional component, via the corresponding internal interfaces. Similarly, the OutMonitor intercepts <b>outgoing</b> service <b>requests.</b> The last case is called InOutMonitor, and is used in the case of SCC components delivering a return value on their service interface.|$|R
30|$|Transitions specify {{links between}} phases which are {{designed}} during service creation {{and followed by}} an engine at execution time. Internal transitions link phases of the same service entity, whereas external transitions link different services. The transitions between internal phases are dynamically bound by default, which means that one phase sends a request to the next phase, to be evaluated at runtime. Since {{the structure of the}} refinement cycle is flexible, each phase within a particular refinement chain contains a pointer to the next phase. For each application programming interface (API) function of the service phase, there must be an associated logical refinement. However, a single incoming external request received by the service phase may cause many <b>outgoing</b> external <b>requests</b> to be issued by the binding phase.|$|R
40|$|In {{organizations}} {{with access to}} the internet, the potential for data leakage is ever present. Data loss prevention is a difficult issue because exfiltration channels, such as modern webmail services, are readily available to insiders. An insider can paste text into a webmail message to bypass other controls. Therefore, monitoring must include the content of this communication. A data loss prevention control determines if the content in <b>outgoing</b> web <b>requests</b> is similar to the organization 2 ̆ 7 s intellectual property, actively blocks suspicious requests, and logs these events. This technical note describes how a control can monitor web request traffic for text-based data exfiltration attempts and block them in real time. Using this control can help an organization protect text-based intellectual property, including source code repositories...|$|R
40|$|As {{businesses}} are {{opening up to}} the web, securing their web applications becomes paramount. Nevertheless, the number of web application attacks is constantly increasing. Cross-Site Request Forgery (CSRF) {{is one of the}} more serious threats to web applications that gained a lot of attention lately. It allows an attacker to perform malicious authorized actions originating in the end-users browser, without his knowledge. This paper presents a client-side policy enforcement framework to transparently protect the end-user against CSRF. To do so, the framework monitors all <b>outgoing</b> web <b>requests</b> within the browser and enforces a configurable cross-domain policy. The default policy is carefully selected to transparently operate in a web 2. 0 context. In addition, the paper also proposes an optional server-side policy to improve the accuracy of the client-side policy enforcement. A prototype is implemented as a Firefox extension, and is thoroughly evaluated in a web 2. 0 context. status: publishe...|$|R
40|$|The {{problem of}} {{performance}} and scalability of web applications is challenged {{by most of the}} software companies. It is difficult to maintain the performance of a web application while the number of users is continuously increasing. The common solution for this problem is scalability. A web application can handle incoming and <b>outgoing</b> <b>requests</b> using blocking or non-blocking Input/Output operation. The way that a single server handles requests affects its ability to scale and depends on a web framework that was used to build the web application. It is especially important for Resource Oriented Architecture (ROA) based applications which consist of distributed Representational State Transfer (REST) web services. This research was inspired by a real problem stated by a software company that was considering the migration to the non-blocking web framework but did not know the possible profits. The objective of the research was to evaluate the influence of web framework's type on the performance of ROA based applications and to provide guidelines for assessing profits of migration from blocking to non-blocking JVM web frameworks. First, internet ranking was used to obtain the list of the most popular web frameworks. Then, the web frameworks were used to conduct two experiments that investigated the influence of web framework's type on the performance of ROA based applications. Next, the consultations with software architects were arranged in order to find a method for approximating the performance of overall application. Finally, the guidelines were prepared based on the consultations and the results of the experiments. Three blocking and non-blocking highly ranked and JVM based web frameworks were selected. The first experiment showed that the non-blocking web frameworks can provide performance up to 2. 5 times higher than blocking web frameworks in ROA based applications. The experiment performed on existing application showed average 27 % performance improvement after the migration. The elaborated guidelines successfully convinced the company that provided the application for testing to conduct the migration on the production environment. The experiment results proved that the migration from blocking to non-blocking web frameworks increases the performance of web application. The prepared guidelines can help software architects to decide if it is worth to migrate. However the guidelines are context depended and further investigation is needed to make it more general...|$|R
50|$|After the {{completion}} of the previous stage, the two nodes connected by the core can inform each other of the best edges they received. Then they can identify the minimum outgoing edge from the entire fragment. A message will be sent from the core to the minimum outgoing edge via a path of branch edges. Finally, a message will be sent out via the chosen <b>outgoing</b> edge to <b>request</b> to combine the two fragments that the edge connects. Depending on the levels of those two fragments, one of two combined operations are performed to form a new fragment (details discussed below).|$|R
40|$|Interlibrary loan (ILL) {{system is}} one of the {{important}} library services provided by most public libraries. Through ILL, public libraries share their collections of reading material and library users are able to access library resources beyond their affiliated libraries. However, the present manual ILL process is inconvenient, inefficient and error-prone. In this project, we developed a system that automated many tedious procedures in the existing ILL system. The new ILL system is realized by a number of Java applets customized for librarians and library users. The new ILL system allows library users to submit ILL requests at any time using their favorite Web browsers without being physically present at the libraries. ibrarians can also process ILL requests as and when they have accessed to Java -enabled Web browsers. The new ILL implementation is achieved without forcing libraries to sacrifice their local autonomy over their legacy library systems, e. g. Online Public Acess Catalogue (OPAC) System. For each participating library, two databases containing incoming and <b>outgoing</b> ILL <b>requests</b> respectively are maintained. The entire ILL process is tracked by multiple ILL Java applets updating the borrowing and lending libraries 2 ̆ 7 databases...|$|R
40|$|Ankara : The Department of Industrial Engineering and Tte Institute of Engineering and Science of Bilkent University, 2008. Thesis (Master's) [...] Bilkent University, 2008. Includes bibliographical {{references}} leaves 76 - 79. In this study, {{a storage}} assignment problem {{for an automobile}} spare parts warehouse is considered. Incoming items from the suppliers are located at storage slots in pallet loads with single stop storage tours while <b>outgoing</b> items <b>requested</b> from the company’s service centers are collected {{on a daily basis}} with multi-stop pick tours. The problem involves seeking a layout (defined by an assignment of items to storage slots) to minimize the total distance items are moved from the receiving dock to storage slots and from storage slots to the shipping dock. The items requested each day are not the same. Consequently, the number and locations of pick stops in pick tours differ from day to day. This feature of the problem sufficiently complicates the structure to make analytical approaches difficult to use. Two simulation models are developed, one single-level and one multi-level model, to investigate factors that have some effect on the storage assignment problem under consideration. Various insights are obtained for a set of storage assignment alternatives for both models. Aybar, EsraM. S...|$|R
