2|20|Public
2500|$|MIPS I has {{instructions}} to perform addition and subtraction. These instructions source their operands from two GPRs (rs and rt), {{and write the}} result to a third GPR (rd). Alternatively, addition can source one of the operands from a 16-bit immediate (which is sign-extended to 32 bits). The instructions for addition and subtraction have two variants: by default, an exception is signaled if the result overflows; instructions with the [...] "unsigned" [...] suffix do not signal an exception. The <b>overflow</b> <b>check</b> interprets the result as a 32-bit two's complement integer.|$|E
50|$|Specifically, the invariants on stacked run sizes {{ensure a}} tight {{upper bound on}} the maximum size of the {{required}} stack. The implementation preallocated a stack sufficient to sort 264 bytes of input, and avoided further <b>overflow</b> <b>checks.</b>|$|R
40|$|One of {{the best}} {{approaches}} for designing future computers is that we use reversible logic. Reversible logic circuits have lower power consumption than the common circuits, used in computers nowadays. In this study we propose a new reversible division circuit. This reversible division circuit is signed divider and has an <b>overflow</b> <b>checking</b> capability. Among the designed and proposed reversible division circuits, our proposed division circuit is the first reversible signed divider with <b>overflow</b> <b>checking</b> capability which has been designed. In this circuit we use some reversible components like reversible parallel adder, reversible left-shift register, reversible multiplexer, reversible n-bit register and reversible n-bit register with parallel load line. In this paper all the scales are in the nanometric area...|$|R
5000|$|By default, numeric {{operations}} are not checked. This results in slightly faster code, {{at the risk}} that numeric overflows will not be detected. However, the programmer can place arithmetic operations into a checked context to activate <b>overflow</b> <b>checking.</b> (It {{can be done in}} Visual Basic by checking an option) ...|$|R
25|$|The {{system is}} useful in {{simplifying}} the implementation of arithmetic on computer hardware. Adding 0011(3) to 1111(1) at first seems to give the incorrect answer of 10010. However, the hardware can simply ignore the left-most bit to give the correct answer of 0010(2). <b>Overflow</b> <b>checks</b> still must exist to catch operations such as summing 0100 and 0100.|$|R
50|$|In {{scenarios}} where {{security is}} critical, undefined behavior {{can lead to}} security vulnerabilities in software. When GCC's developers changed their compiler in 2008 such that it omitted certain <b>overflow</b> <b>checks</b> that relied on undefined behavior, CERT issued a warning against the newer versions of the compiler. Linux Weekly News {{pointed out that the}} same behavior was observed in PathScale C, Microsoft Visual C++ 2005 and several other compilers; the warning was later amended to warn about various compilers.|$|R
40|$|Over several years, RNS {{applications}} {{were limited}} to addition, subtraction and multiplication with results expected within a predetermined range because of the absence an explicit information on number magnitude in the residue representation. Hybrid notations have been proposed to overcome this obstacle. In this paper, an architecture for adding <b>overflow</b> <b>checking</b> is presented which is based Residue Systems Magnitude Index (RNS with MI) and its area-time complexity is evaluated. It is shown that considerable execution time reduction may result for a wide class of applications at cost of a slight increase of area occupancy as compared with binary realizations...|$|R
5000|$|... #Subtitle level 3: Algorithm for {{inserting}} ‘k’ and <b>checking</b> <b>overflow</b> condition ...|$|R
40|$|The {{definition}} of Standard ML dictates that overflow in integer arithmetic raises an overflow exception. As a consequence standard-conforming implementations {{of the language}} have to checkforoverflowwhichcanbecostly. Weexaminethepossibility of further optimizing the code generated by the industrial-strength compiler MLton. By studying the code generated for integer arithmetic we identify dead code where overflow cannot happen. We propose a flow-sensitive integer interval analysis that detects and removes such needless <b>overflow</b> <b>checks</b> on integer arithmetic. We have implemented an analysis prototype in Standard ML and integrateditintoMLtonasanadditionaloptimizationpass. Itisableto remove 22 %oftheoverflowchecksintheMLtonbenchmarksuite. The binary size of the programs decrease up to 10 % and the run timeof arithmeticheavy programs decreasesignificantly-insome cases upto 27 %. 1...|$|R
50|$|Buffer {{overflow}} {{protection is}} used to detect the most common buffer <b>overflows</b> by <b>checking</b> that the stack has not been altered when a function returns. If it has been altered, the program exits with a segmentation fault. Three such systems are Libsafe, and the StackGuard and ProPolice gcc patches.|$|R
40|$|Abstract. Interval {{analysis}} seeks static {{lower and}} upper bounds on {{the values of}} program variables. These bounds are useful, especially for inferring invariants to prove buffer <b>overflow</b> <b>checks.</b> In practice, however, intervals by themselves are often inadequate as invariants {{due to the lack}} of relational information among program variables. In this paper, we present a technique for deriving symbolic bounds on variable values. We study a restricted class of polyhedra whose constraints are stratified with respect to some variable ordering provided by the user, or chosen heuristically. We define a notion of normalization for such constraints and demonstrate polynomial time domain operations on the resulting domain of symbolic range constraints. The abstract domain is intended to complement widely used domains such as intervals and octagons for use in buffer overflow analysis. Finally, we study the impact of our analysis on commercial software using an overflow analyzer for the C language. ...|$|R
40|$|We {{propose a}} new method of {{eliminating}} range checks {{in connection with}} array index expressions and assignments to variables of subrange types. Contrary to the approaches documented in the literature, we work on an extended static single assignment form (XSA) very near the target level. This gives significant advantages over previous attempts since many questions don't occur at all or else in a simpler form in the XSA. The technique has been implemented {{in a family of}} Modula- 2 and Oberon- 2 compilers. Introduction Implementation of safe programming languages requires range checks in connection with array index expressions and, where applicable, with assignments to variables of subrange types. Also, it calls for <b>overflow</b> <b>checks</b> in connection with arithmetic operations. Of course, these checks cause run time overhead, which is why they are frequently turned off for the production version of a program. This inherently bad practice has been compared by Hoare to a pilot who wears a parachute [...] ...|$|R
40|$|John Gough, Queensland University of Technology Herbert Klaeren, University of Tubingen y November 1, 1994 Abstract We {{propose a}} new method of {{eliminating}} range checks {{in connection with}} array index expressions and assignments to variables of subrange types. Contrary to the approaches documented in the literature, we work on an extended static single assignment form (XSA) very near the target level. This gives significant advantages over previous attempts since many questions don't occur at all or else in a simpler form in the XSA. The technique has been implemented {{in a family of}} Modula- 2 and Oberon- 2 compilers. Introduction Implementation of safe programming languages requires range checks in connection with array index expressions and, where applicable, with assignments to variables of subrange types. Also, it calls for <b>overflow</b> <b>checks</b> in connection with arithmetic operations. Of course, these checks cause run time overhead; it is therefore a good idea to eliminate at compile t [...] ...|$|R
50|$|Index {{checking}} means that, in all expressions indexing an array, {{the index}} value is checked against {{the bounds of}} the array (which were established when the array was defined), and if the index is out-of-bounds, further execution is suspended via some sort of error. Because using a number outside of the upper range in an array may cause the program to crash, or may introduce security vulnerabilities (see buffer <b>overflow),</b> index <b>checking</b> {{is a part of}} many high-level languages.|$|R
50|$|When {{examining}} a sump pump and cleaning it, dirt, gravel, sand, and other debris {{should be removed}} to increase efficiency and {{extend the life of}} the pump. These obstructions can also decrease the pump's ability to drain the sump, and can allow the sump to <b>overflow.</b> The <b>check</b> valve can also jam from the debris. Examine the discharge line opening, when applicable, to ensure there are no obstructions in the line. Even a partially obstructed discharge line can force a sump pump to work harder and increase its chance of overheating and failure.|$|R
40|$|A MATLAB toolbox is presented, {{with the}} goal of {{checking}} occurrences of design errors typically found in fixed-point digital systems, considering finite word-length effects. In particular, the present toolbox works as a front-end to a recently introduced verification tool, known as Digital-System Verifier (DSVerifier), and <b>checks</b> <b>overflow,</b> limit cycle, quantization, stability, and minimum phase errors in digital systems represented by transfer-function and state-space equations. It provides a command-line version with simplified access to specific functionality and a graphical-user interface, which was developed as a MATLAB application. The resulting toolbox enables application of verification to real-world systems by control engineers...|$|R
5000|$|It is even {{theoretically}} possible, {{using the}} above technique, {{together with a}} suitable instruction set simulator to simulate any machine code or the intermediate (byte code) of any processor/language in another language that does not support pointers at all (for example Java / JavaScript). To achieve this, the binary code can initially be loaded into contiguous bytes of the array for the simulator to [...] "read", interpret and action entirely within the memory contained of the same array.If necessary, to completely avoid buffer <b>overflow</b> problems, bounds <b>checking</b> can usually be actioned for the compiler (or if not, hand coded in the simulator).|$|R
40|$|Detecting {{arithmetic}} overflow during summation {{operations is}} vital to ensuring correct and secure behavior of many types of code. For example, applying transformations to signed integer pixel co-ordinates without any overflow detection may result in pixels rendering at unexpected negative co-ordinates, summing a large array of signed or unsigned integers without overflow detection can result in bogus totals, or performing arithmetic operations on packed bitfields without overflow detection could result in corruption of data in adjacent bitfields. A traditional way to detect arithmetic overflow is to insert specific checks of the host processor’s Overflow arithmetic condition flag after each arithmetic operation to detect signed integer <b>overflow,</b> or a <b>check</b> of the host processor’...|$|R
60|$|But these discourses {{were not}} without their effect upon the {{extremely}} conscientious mind of Anne. They were, moreover, much helped by an incident {{which took place}} one evening {{in the autumn of}} this year, when John came to tea. Anne was sitting on a low stool in front of the fire, her hands clasped across her knee. John Loveday had just seated himself on a chair close behind her, and Mrs. Loveday was in the act of filling the teapot from the kettle which hung in the chimney exactly above Anne. The kettle slipped forward suddenly, whereupon John jumped from the chair and put his own two hands over Anne's just in time to shield them, and the precious knee she clasped, from the jet of scalding water which had directed itself upon that point. The accidental <b>overflow</b> was instantly <b>checked</b> by Mrs. Loveday; but what had come was received by the devoted trumpet-major {{on the back of his}} hands.|$|R

