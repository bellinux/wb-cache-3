1067|7233|Public
5000|$|Conference on <b>Object</b> <b>Oriented</b> <b>Programming</b> Systems Languages and Applications archive Proceedings of the 20th annual ACM SIGPLAN {{conference on}} <b>Object</b> <b>oriented</b> <b>programming,</b> systems, languages, and {{applications}} http://portal.acm.org/citation.cfm?id=1094811.1094841&coll=GUIDE&dl=GUIDE&CFID=10871926&CFTOKEN=54412436 ...|$|E
5000|$|... #Subtitle level 2: Abstraction in <b>object</b> <b>oriented</b> <b>programming</b> ...|$|E
5000|$|<b>Object</b> <b>Oriented</b> <b>Programming,</b> a {{style of}} modern {{computer}} programming ...|$|E
5000|$|CSLA [...]NET is a {{software}} framework created by Rockford Lhotka {{that provides a}} standard way to create robust <b>object</b> <b>oriented</b> <b>programs</b> using business <b>objects.</b> Business objects are objects that abstract business entities in an <b>object</b> <b>oriented</b> <b>program.</b> Some examples of business entities include sales orders, employees, or invoices.|$|R
40|$|Upon {{introducing}} a local {{change in a}} method or a class in an <b>object</b> <b>oriented</b> <b>program,</b> the ripple effect gives {{a measure of the}} amount by which this change may affect other methods/classes. That is, the ripple effect shows maintainers the ramifications of any change they may make before that change is actually implemented. In this paper, we propose techniques for measuring the ripple effect in <b>object</b> <b>oriented</b> <b>programs</b> and use it to compute an indicator of logical stability. First, we investigate <b>object</b> <b>oriented</b> dependences and illustrate how these dependences and some metrics can be used to determine change impact and propagation. Then, we use matrix arithmetic techniques for computing the ripple effect in <b>object</b> <b>oriented</b> <b>programs</b> and show their application at the intra-class, inter-class and architectural levels. PublishedN/...|$|R
40|$|<b>Object</b> <b>oriented</b> methods allow programmers to {{construct}} software {{with a simple}} and uniform structure. <b>Object</b> <b>oriented</b> <b>programs</b> should be simple to maintain and extend. Source code browsers are not sufficient for understanding <b>object</b> <b>oriented</b> <b>programs.</b> We have combined a strongly-typed <b>object</b> <b>oriented</b> language with an integrated, interactive development environment. For several reasons, we designed the compiler as an integral component of the environment. Coupling the compiler and the browser simplifies symbol table management in the compiler. Conversely, the same coupling ensures that information is semantically checked before the browser displays it. Also, programmers {{do not have to}} understand the class hierarchy because the compiler creates class views. ...|$|R
5000|$|Data Structures Lab Algorithms Lab <b>Object</b> <b>Oriented</b> <b>Programming</b> Lab System Software Lab ...|$|E
50|$|Proper <b>object</b> <b>oriented</b> <b>programming</b> {{involves}} design {{principles that}} avoid action at a distance.|$|E
50|$|Xbase++ is an <b>object</b> <b>oriented</b> <b>programming</b> {{language}} {{which has}} multiple inheritance and polymorphism. It {{is based on}} the XBase language dialect and conventions.It is 100% Clipper compatible language supporting multiple inheritance, polymorphism, <b>object</b> <b>oriented</b> <b>programming.</b> It supports the xBase data types, including Codeblocks. With Xbase++ it is possible to generate applications for Windows NT, 95, 98, Me, 2000, XP, VISTA and Windows 7.|$|E
40|$|Abstract — Bug {{localization}} in <b>object</b> <b>oriented</b> <b>program</b> {{has always}} been an important issue in softeware engineering. In this paper, I propose a source level bug localization technique for <b>object</b> <b>oriented</b> embedded <b>programs.</b> My proposed technique, presents the idea of debugging an <b>object</b> <b>oriented</b> <b>program</b> in class level, incorporating the object state information into the Class Dependence Graph (ClDG). Given a program (having buggy statement) and an input that fails and others pass, my approach uses concrete as well as symbolic execution to synthesize the passing inputs that marginally from the failing input in their control flow behavior. A comparison of the execution traces of the failing input and the passing input provides necessary clues to the root-cause of the failure. A state trace difference, regarding the respective nodes of the ClDG is obtained, which leads to detect the bug in the program...|$|R
40|$|Source code {{analysis}} {{does not}} provide enough information for the program understanding activities. Understanding <b>object</b> <b>oriented</b> software systems during software maintenance are difficult and take {{a considerable amount of}} time and cost. In software maintenance perspective reverse engineering process extracts information to provide visibility of the <b>object</b> <b>oriented</b> components and relations in the software that are essential for maintainers. Various tools have been developed to help maintainers undergo this process. One such tool is reverse engineering <b>object</b> <b>Oriented</b> <b>program</b> tool. In this paper, we provide a framework environment for <b>object</b> <b>oriented</b> <b>programs.</b> The framework focuses on the technical side of maintaining object-oriented program. This paper will discuss the development of the tool and highlight a scenario to show the viability of the tool by providing querying and browsing facilities...|$|R
40|$|Many dynamic {{analysis}} approaches to specification mining that ex-tract behavioral models from execution traces, {{do not consider}} ob-ject identities which limit their power when used to analyze traces of general <b>object</b> <b>oriented</b> <b>programs.</b> In this work we present a novel specification mining approach that considers object identi-ties, and, moreover, generalizes from specifications involving con-crete objects to their symbolic class-level abstractions. Our ap-proach uses data mining methods to extract significant scenario-based specifications {{in the form of}} Damm and Harel’s live sequence charts (LSC), a formal and expressive extension of classic sequence diagrams. We guarantee that all mined symbolic LSCs are sig-nificant (statistically sound) and all significant symbolic LSCs are mined (statistically complete). The technique can potentially be ap-plied to general <b>object</b> <b>oriented</b> <b>programs</b> to reveal expressive an...|$|R
5000|$|Enthusiasts of {{functional}} or <b>object</b> <b>oriented</b> <b>programming</b> can solve contest {{problems in their}} favorite language.|$|E
50|$|The D3DX library {{follows the}} COM <b>object</b> <b>oriented</b> <b>programming</b> model. Functionality is {{accessed}} using C++-like interfaces.|$|E
5000|$|OOPSTAD was the <b>Object</b> <b>Oriented</b> <b>Programming</b> For Smalltalk Application Developers Association. It {{published}} the periodical HOOPLA! ...|$|E
40|$|This paper {{describes}} {{the outline of}} our lecture and the experience we have had when introducing <b>object</b> [...] <b>oriented</b> <b>programming,</b> design, and software architecture to students of different educational and vocational backgrounds. While other courses on <b>object</b> [...] <b>oriented</b> <b>programming</b> only show how to implement things in an <b>object</b> [...] <b>oriented</b> way, we emphasize on the production of reusable class libraries and frameworks. 1. 1 The audienc...|$|R
5000|$|AMMORIA - Open source <b>object</b> <b>oriented</b> Arabic <b>programming</b> language, {{designed}} {{especially for}} Arabs.|$|R
50|$|SCOOP {{defines a}} way for an <b>object</b> <b>oriented</b> <b>program</b> to be written without the concept of threads, locks, or other typical {{multiprogramming}} methods. This allows the compiler or runtime environment to optimize the amount of concurrency as well as eliminate typical design flaws such as deadlock.|$|R
50|$|Combined together, {{these two}} parts form a {{complete}} prototype-based <b>Object</b> <b>Oriented</b> <b>programming</b> language which is entirely self-hosting.|$|E
5000|$|Andrew Koenig, Barbara Moo: Teaching Standard C++, Part 2. Journal of <b>Object</b> <b>Oriented</b> <b>Programming</b> (JOOP) 11(8): 64-67 (1999) ...|$|E
5000|$|Bachelor of Information Management (BIM): <b>Object</b> <b>Oriented</b> <b>Programming,</b> Web Techonolgy, JAVA Programming, Client Server Computing, Software project {{management}} and others.|$|E
40|$|Abstract: Aspect <b>Oriented</b> <b>Programming</b> is {{changing}} the way software is developed in various domains of computing and software Engineering. In this project we discuss the main characteristics of Aspect <b>oriented</b> <b>program</b> (AOP) with a particular focus on distributed systems. Our experiments {{support the hypothesis that}} the use of Aspect <b>oriented</b> <b>program</b> will result in a better separation of concerns and thus in better maintainability and portability of such systems (in comparison with a classical <b>object</b> <b>oriented</b> <b>program</b> development approach). Classical <b>object</b> <b>oriented</b> <b>program</b> is not allowing the separation of concerns but here in aspect <b>oriented</b> <b>program</b> is allowing the separation of cross cutting concerns. Aspect <b>oriented</b> <b>programming</b> (AOP) is a programming paradigm that increases modularity by allowing the separation of cross-cutting concerns. Separation of concerns leads to breaking down a paradigm into distinct parts called concerns. We focus mainly, in this project, is designing the Aspect <b>oriented</b> <b>program</b> with a particular focus on distributed application. The use of Aspect <b>oriented</b> <b>program</b> will result in a better separation of concerns and thus in better maintainability and portability of distributed applications...|$|R
40|$|This report {{illustrates}} the progress {{made on the}} Rubber Boat Ship Specification System for NavSim between May and September of 1999. The work centers on the usage of <b>objected</b> <b>oriented</b> <b>programming</b> where imported CAD drawings are converted to graphical patch objects in MATLAB. Peer reviewed: NoNRC publication: Ye...|$|R
40|$|We {{present a}} novel way of using <b>object</b> <b>oriented</b> design metrics as to {{support for the}} {{incremental}} development of <b>object</b> <b>oriented</b> <b>programs.</b> Based on a quality model (factor-criteria-metrics model), so-called multi-metrics relate a number of simple structural measurements to design principles and rules. Single components of an <b>object</b> <b>oriented</b> <b>program</b> like classes or subsystems are analyzed {{to determine whether they}} conform to specific design goals. Concise measurement reports together with detailed explanations of the obtained values identify problem spots in system design and give hints for improvement. This allows the designer to measure and evaluate programs at an appropriate level of abstraction. This paper details the use of the multi-metrics approach for the design and improvement of a framework for industry and used for graphical applications. Multimetrics tools were used with several versions of the framework. The measurement results were used in design reviews to quantify the eff [...] ...|$|R
5000|$|LotusScript is an <b>object</b> <b>oriented</b> <b>programming</b> {{language}} used by Lotus Notes (since version 4.0) and other IBM Lotus Software products.|$|E
50|$|Programmers {{often use}} assertions in their code to make invariants explicit. Some <b>object</b> <b>oriented</b> <b>programming</b> {{languages}} {{have a special}} syntax for specifying class invariants.|$|E
50|$|SCOOP (Simple Concurrent <b>Object</b> <b>Oriented</b> <b>Programming)</b> is a {{concurrency}} model {{designed for}} the Eiffel programming language, conceived by Eiffel's creator and designer, Bertrand Meyer.|$|E
40|$|<b>Object</b> <b>oriented</b> {{methodology}} {{is increasingly}} {{being used for}} software development. There is now a need to develop testing methodologies for <b>object</b> <b>oriented</b> <b>programs.</b> These methodologies should exploit the characteristics of object orientation. In this paper we develop a framework for semi-automated generation of test cases for <b>object</b> <b>oriented</b> <b>programs</b> from formal specifications. We use Object-Z as the formal specification language. We have designed and prototyped a test system called OZTEST. OZTEST understands characteristics of object-oriented specifciations including inheritance. It maps the specification to a corresponding implementation. Test shells generated from the given Object-Z specification are stored as test scripts. OZTEST chooses the test shells to be executed in a particular test-session based on user given criteria. A test class is created by inheriting from the class being tested. The child class thus has all {{the features of the}} class being tested, in addition to the rou [...] ...|$|R
40|$|This paper {{argues that}} <b>object</b> <b>oriented</b> {{distributed}} <b>programming</b> {{should not be}} about wrapping existing technologies with <b>object</b> <b>oriented</b> like interfaces nor should it be about hiding distribution behind classical abstractions of traditional (centralized) <b>object</b> <b>oriented</b> languages. Roughly speaking, <b>object</b> <b>oriented</b> distributed <b>programming</b> has {{very little to do}} with building a distributed <b>object</b> <b>oriented</b> language or system. The metaphor of a community of independent objects communicating through message passing should not hide the fact that distributed interaction is not local interactio...|$|R
40|$|Java {{programs}} can greatly differ {{in terms of}} required runtime support. C-like Java programs which are usually computation intensive tend to require little, whereas heavily <b>object</b> <b>oriented</b> <b>programs</b> such as compilers, can {{spend most of their}} execution time in runtime handlers. This report begins to explore the differences in instruction level parallelism between these two extreme types of Java programs. No solid conclusions can be drawn, however, due to an oversimplified execution model and the scarcity of appropriate benchmarks. 1 Introduction In our previous studies of Java [1], we discovered that Java {{programs can}} differ greatly in terms of required runtime support. At one end, we have heavily <b>object</b> <b>oriented</b> <b>programs,</b> such as <b>object</b> <b>oriented</b> compilers, which make heavy use of runtime features such as dynamic binding and garbage collection. At the other end, we have C-like programs, which avoid these features and behave like regular C programs, minus complicated pointer manipulations [...] ...|$|R
50|$|FreeMED is {{a direct}} descendent of AMOS, a Pascal/DBase program which was created in 1983 before the {{widespread}} use of relational databases and <b>object</b> <b>oriented</b> <b>programming.</b>|$|E
50|$|ZZT-oop was {{an early}} in-game {{scripting}} programming language, designed by Tim Sweeney, for his computer game ZZT. The name stands for ZZT <b>Object</b> <b>Oriented</b> <b>Programming</b> language.|$|E
50|$|Jeroo is a {{cross-platform}} educational {{tool for}} learning <b>object</b> <b>oriented</b> <b>programming</b> concepts. In particular, the program helps learning {{concepts such as}} objects, methods and basic control structures.|$|E
40|$|In {{this paper}} we report the {{experience}} of using AutoProof to statically verify a small <b>object</b> <b>oriented</b> <b>program.</b> We identified the problems that emerged by this activity and we classified them according to their nature. In particular, we distinguish between tool-related and methodology-related issues, and propose necessary changes to simplify both tool and method...|$|R
40|$|Object-Oriented {{programming}} {{is a combination}} of different levels consists of abstraction, class level cluster level and system level. In this article, we are going to discuss about the different testing aspects for <b>object</b> <b>oriented</b> <b>programs.</b> Idea is to test different testing aspects of Object-oriented Software Systems. The challenge is to cover testing with minimum effort to get maximum output...|$|R
40|$|In {{this paper}} we {{describe}} the architecture and implementation strategy of a concurrent distributed <b>object</b> <b>oriented</b> <b>program</b> execution environment, where concurrently executing processes access objects in a virtual shared memory. Linearizability, basic correctness condition for the semantics of concurrent object invocation, is implemented using a lockfree protocol, and integrated transparently into sequential code requiring no explicit synchronisation...|$|R
