0|103|Public
50|$|See Character and <b>op</b> <b>codes</b> {{for a list}} of operations.|$|R
5000|$|Encodings of {{punched card}} {{characters}} {{with two or}} more digit punches {{can be found in}} the Character and <b>op</b> <b>codes</b> table.|$|R
5000|$|... 24 {{addressing}} modes - 13 original 6502 modes with 92 instructions using 256 <b>op</b> <b>codes,</b> including most new opcodes {{implemented in the}} 65C02.|$|R
25|$|Number of {{instructions:}} 39 types from a 4-bit <b>op</b> <b>code</b> {{by using}} five {{bits of the}} operand address field for instructions which do not access memory.|$|R
5000|$|<b>Op</b> <b>Code</b> Mask1 [...] Mask2 [...] Base Displacement +--------------+-------+-------+-------+------------+ | x'47' | 0 | M2 [...] | B2 [...] | D2 [...] | +--------------+-------+-------+-------+------------+ 0 8 12 16 20 31 ...|$|R
5000|$|A full {{running and}} {{extended}} application is maXbox.maXbox a scripter studio with an inbuild delphi engine in one Exe! Designed for teaching/programming methods and algorithms for Win, Mac and Linux (CLX) to build <b>OP</b> <b>code</b> plus support Arduino / Android.https://github.com/maxkleiner/maXbox3/releases ...|$|R
5000|$|Adders {{are a part}} of {{the core}} of an {{arithmetic}} logic unit (ALU).The control unit decides which operations an ALU should perform (based on the <b>op</b> <b>code</b> being executed) and sets the ALU operation.The [...] input to the adder-subtractor above would be one such control line from the control unit.|$|R
5000|$|CARDIAC has a 10 {{instruction}} machine language. An {{instruction is}} three decimal digits (the sign is ignored) {{in the form}} [...] The first digit is the <b>op</b> <b>code</b> (...) {{the second and third}} digits are an address (...) [...] Addressing is one of accumulator to memory absolute, absolute memory to accumulator, input to absolute memory and absolute memory to output.|$|R
25|$|There {{were also}} four {{locations}} in core memory, at addresses 20-23, dubbed editing locations because whatever was stored there would emerge shifted or rotated by one bit position, {{except for one}} that shifted right seven bit positions, to extract one of the seven-bit interpretive <b>op.</b> <b>codes</b> that were packed two to a word. This was common to Block I and Block II AGCs.|$|R
5000|$|... #Caption: A {{math and}} {{computer}} programming class at Science in 1960, with an IBM 650 <b>op</b> <b>code</b> chart, upper right. Science {{was one of}} the first high schools to teach computers. The school had a keypunch machine and students ran their programs at the Watson lab at Columbia University. Science obtained its own computer, an IBM 1620, a year and a half later.|$|R
5000|$|The {{instruction}} format used 3 bits for opcode, and 12 bits for address. Block I had 11 instructions: , , , , , , , and [...] (basic), and , , and [...] (extra). The first eight, called basic instructions, were directly accessed by the 3-bit <b>op.</b> <b>code.</b> The final three were denoted as extracode instructions {{because they were}} accessed by performing a special type of [...] instruction (called [...] ) immediately before the instruction.|$|R
5000|$|... 1996 Intel {{announced}} the MCS-151 family, an up to 6 times faster variant. 8051 fully binary and instruction set compatible, but with pipelined CPU, 16 bit internal <b>code</b> <b>bus</b> and 6x speed. The MCS-151 family was also discontinued by Intel, but is {{widely available in}} binary compatible and partly enhanced variants.|$|R
25|$|The {{instruction}} format used 3 bits for opcode, and 12 bits for address. Block I had 11 instructions: TC, CCS, INDEX, XCH, CS, TS, AD, and MASK (basic), and SU, MP, and DV (extra). The first eight, called basic instructions, were directly accessed by the 3-bit <b>op.</b> <b>code.</b> The final three were denoted as extracode instructions {{because they were}} accessed by performing a special type of TC instruction (called EXTEND) immediately before the instruction.|$|R
50|$|Most {{assembly}} languages {{will have}} a macro instruction or an interrupt address available for the particular system to intercept events such as illegal <b>op</b> <b>codes,</b> program check, data errors, overflow, divide by zero, and other such. IBM and Univac mainframes had the STXIT macro. Digital Equipment Corporation RT11 systems had trap vectors for program errors, i/o interrupts, and such. DOS has certain interrupt addresses. Microsoft Windows has specific module calls to trap program errors.|$|R
25|$|INDEX: Add {{the data}} {{retrieved}} at the address {{specified by the}} instruction to the next instruction. INDEX {{can be used to}} add or subtract an index value to the base address specified by the operand of the instruction that follows INDEX. This method is used to implement arrays and table look-ups; since the addition was done on both whole words, it was also used to modify the <b>op.</b> <b>code</b> in a following (extracode) instruction, and on rare occasions both functions at once.|$|R
50|$|Another {{example was}} the IBM 650 (1953), a decimal machine, {{which had a}} group of ten 10-position {{switches}} on its operator panel which were addressable as a memory word (address 8000) and could be executed as an instruction. Thus setting the switches to 7004000400 and pressing the appropriate button would read the first card in the card reader into memory (<b>op</b> <b>code</b> 70), starting at address 400 and then jump to 400 to begin executing the program on that card.|$|R
5000|$|Add {{the data}} {{retrieved}} at the address {{specified by the}} instruction to the next instruction. [...] {{can be used to}} add or subtract an index value to the base address specified by the operand of the instruction that follows [...] This method is used to implement arrays and table look-ups; since the addition was done on both whole words, it was also used to modify the <b>op.</b> <b>code</b> in a following (extracode) instruction, and on rare occasions both functions at once.|$|R
5000|$|Note: EXEC 8 Idle Loop - the [...] "Idle Loop" [...] {{was entered}} when a CPU had no {{available}} task to execute (typically when {{waiting for an}} I/O operation to complete). A simplified description is that the CPU executed a block transfer (<b>op</b> <b>code</b> 022) of the ICR stack (the first 0200 memory addresses) {{back to the same}} addresses. Since the ICR stack was contained in the CPU, this minimized use of core memory cycles, freeing them up for active CPUs.|$|R
5000|$|For {{more complex}} operations, MBASIC allowed {{user-defined}} functions {{that could be}} called from a BASIC program. These were typically placed in a reserved area of memory, or POKEd into string constants, {{as a series of}} machine <b>codes</b> (<b>op</b> <b>codes).</b> MBASIC also provided hardware [...] and [...] instructions that read and wrote directly to the 8080 hardware input/output ports. This could be used to control peripheral devices, though on at least one common CP/M system, the Osborne 1, all I/O instructions were pre-empted for use by the system.|$|R
40|$|This updated, {{classic work}} on the RPG {{language}} covers all the new functions and features that have been added since 2003, including new <b>op</b> <b>codes</b> and built-in functions, new chapters on free-format RPG IV and Web programming interfaces, information on implementing XML within RPG IV, and expanded information on procedures. This reference guide takes both novice and experienced RPG IV programmers through the language, from its foundation to its most advanced techniques. More than 100 charts and tables, as well as 350 real-life code samples of functions and operations are included, showing reader...|$|R
5000|$|Instructions {{were fixed}} length (12 decimal digits), {{consisting}} of a 2-digit [...] "op code", a 5-digit [...] "P Address" [...] (usually the destination address), and a 5-digit [...] "Q Address" [...] (usually the source address or the source immediate value). Some instructions, such as the B (branch) instruction, only used the P Address, and later smart assemblers included a [...] "B7" [...] instruction that generated a 7-digit branch instruction (<b>op</b> <b>code,</b> P address, and one extra digit because the next instruction had to start on an even-numbered digit).|$|R
50|$|On POSIX-compliant platforms, bus errors usually {{result in}} the SIGBUS signal {{being sent to the}} process that caused the error. SIGBUS can also be caused by any general device fault that the {{computer}} detects, though a bus error rarely means that the computer hardware is physically broken—it is normally caused by a bug in a program's source <b>code.</b> <b>Bus</b> errors may also be raised for certain other paging errors; see below.|$|R
50|$|The BeOS uses ELF format {{executable}} files, much as {{many other}} operating systems. BeIA uses an extended version of ELF, the name of which is unknown but which {{has come to be}} known as CELF, from the CEL magic word within the executable header and the fact that it is derived from ELF format executables through a compression process. The CELF (Compressed ELF) files use a patented technique to compress the <b>op</b> <b>codes</b> within the executable and reduce the overall footprint of each executable file. The file was compressed by creating a set of dictionaries that contain the <b>op</b> <b>codes</b> and are read by the kernel at start up and mapped into the executable in memory at run time. This makes the file fast loading, but has an extreme disadvantage, in that the dictionary is not extendible by the user and adding extra executable was not possible when using CELF compression techniques unless the executable symbols existed within the dictionary already present. The creation of CELF executables is generally done in batch. The entire system will be compressed and a file system image created from the crushed files. Crushing was the term coined for the compression of the system using CELF format. BeIA can run either as CELF or ELF based. However, it can only use one or the other file formats.|$|R
50|$|The series stars a {{group of}} fictional androids {{who are members of}} a covert black <b>ops</b> program <b>code</b> named Project Livewire. These androids are on a mission to seek out and destroy other black ops.|$|R
5000|$|Instructions {{were either}} 15 or 30 bits long, so {{there could be}} up to four {{instructions}} per 60-bit word. A 60-bit word could contain any combination of 15-bit and 30-bit instructions that fit within the word, but a 30-bit instruction could not wrap to the next word. The <b>op</b> <b>codes</b> were six bits long. The remainder of the instruction was either three three-bit register fields (two operands and one result), or two registers with an 18-bit immediate constant. All instructions were 'register to register'. For example, the following COMPASS code loads two values from memory, performs a 60-bit integer add, then stores the result: ...|$|R
50|$|More generally, {{the form}} is x ?= expressionwhere the ? stands for some {{operator}} (not always +), {{and there may}} be no special <b>op</b> <b>codes</b> to help. There is still the possibility that if x is a complicated entity the compiler will be encouraged to avoid duplication in accessing x, and of course, if x is a lengthy name, there will be less typing required. This last was the basis of the similar feature in the ALGOL compilers offered via the Burroughs B6700 systems, using the tilde symbol to stand for the variable being assigned to, so that LongName:=x + sqrt(LongName)*7;would become LongName:=x + sqrt(~)*7;and so forth. This is more general than just x:=~ + 1; Producing optimum code would remain the province of the compiler.|$|R
5000|$|The Argus {{circuitry}} {{was based}} on germanium transistors with 0 and -6 volts representing binary 1 and 0, respectively. The computer {{was based on}} a 12-bit word length with 24-bit instructions. The arithmetic was handled in two parallel 6-bit ALUs operating at 500 kHz. Additions in the ALU took 12 µs, but adding in the memory access time meant simple instructions took about 20 µs. Double-length (24-bit) arithmetic operations were also provided. Data memory was supplied in a 12-bit, 4096 word, core memory store, while up to 64 instruction words were stored in a separate plugboard array, using ferrite pegs dropped into holes to create a [...] "1". <b>Op</b> <b>codes</b> were 6 bits, registers 3 bits, index register (modifier) 2 bits and data address 13 bits.|$|R
5000|$|With this version, {{there is}} no excuse for a {{compiler}} failing to generate code that looks up the location of variable x just once, and modifies it in place, if of course the machine code supports such a sequence. For instance, if x is a simple variable, the machine code sequence might be something like Load x Add 1 Store xand the same code would be generated for both forms. But if there is a special <b>op</b> <b>code,</b> it might be MDM x,1meaning [...] "Modify Memory" [...] by adding 1 to x, and a decent compiler would generate the same code for both forms. Some machine codes offer INC and DEC operations (to add or subtract one), others might allow constants other than one.|$|R
5000|$|IDT 'HELLO' TITL 'HELLO - {{hello world}} program' * DXOP SVC,15 Define SVC TMLUNO EQU 0 Terminal LUNO * R0 EQU 0 R1 EQU 1 R2 EQU 2 R3 EQU 3 R4 EQU 4 R5 EQU 5 R6 EQU 6 R7 EQU 7 R8 EQU 8 R9 EQU 9 R10 EQU 10 R11 EQU 11 R12 EQU 12 R13 EQU 13 R14 EQU 14 R15 EQU 15 * DATA WP,ENTRY,0 * [...] * Workspace (On the 990 we can [...] "preload" [...] registers) * WP DATA 0 R0 DATA 0 R1 [...] DATA >1600 R2 - End of program SVC DATA >0000 R3 - Open I/O opcode DATA >0B00 R4 - Write I/O opcode DATA >0100 R5 - Close I/O opcode DATA STRING R6 - Message address DATA STRLEN R7 - Message length DATA 0 R8 DATA 0 R9 DATA 0 R10 DATA 0 R11 DATA 0 R12 DATA 0 R13 DATA 0 R14 DATA 0 R15 * [...] * Terminal SVC block * TRMSCB BYTE 0 SVC <b>op</b> <b>code</b> (0 = I/O) TRMERR BYTE 0 Error code TRMOPC BYTE 0 I/O <b>OP</b> <b>CODE</b> TRMLUN BYTE TMLUNO LUNO TRMFLG DATA 0 Flags TRMBUF DATA $-$ Buffer address [...] TRMLRL DATA $-$ Logical record length TRMCHC DATA $-$ Character count * [...] * Message * STRING TEXT 'Hello world!' BYTE >D,>A STRLEN EQU $-STRING EVEN PAGE * [...] * Main program entry * ENTRY MOVB R3,@TRMOPC Set open opcode in SCB SVC @TRMSCB Open {{terminal}} MOVB @TRMERR,R0 Check for error JNE EXIT MOVB R4,@TRMOPC Set write opcode MOV R6,@TRMBUF Set buffer address [...] MOV R7,@TRMLRL Set {{logical record length}} MOV R7,@TRMCHC and character count SVC @TRMSCB Write message MOVB @TRMERR,R0 Check for error JNE CLOSE CLOSE MOVB R5,@TRMOPC Set close opcode SVC @TRMSCB Close terminal EXIT SVC R2 Exit program * END ...|$|R
5000|$|... {{real-time}} bus arrivals by scanning a QR <b>code</b> at the <b>bus</b> stop, ...|$|R
40|$|Abstract This work {{presents}} {{a method of}} automatically generating embedded software including <b>bus</b> driver <b>code</b> from a transaction level model (TLM). For the application software, a real time operating system (RTOS) adapter is introduced to model scheduling and synchronization at C level. ANSI-C code is generated targeting this RTOS adapter. Bus drivers are also automatically created for HW/SW communication. Finally, the software image file is created from the C <b>code,</b> <b>bus</b> driver <b>code,</b> RTOS adapter and RTOS library code. As a result, efficient embedded software is synthesized from abstract, target CPU independent source code, {{eliminating the need for}} manual RTOS targeting, I/O driver coding and system integration. 1...|$|R
40|$|To {{diagnose}} the vulnerabilities {{of target}} system using a remote penetration test approach needs {{to avoid the}} modification of the security configuration of the target network. So the carrier of test codes needs {{to hide from the}} IDS filter out of our penetrating test codes. Hence, we proposed a polymorphic carrier which carries encrypted test codes and diversified decrypters, and, the proposed carrier is also able to adjust the <b>OP</b> <b>code</b> distribution {{to make it look like}} a normal packet. To make sure whether it can hide from the detection of an intrusion detection system and deliver the test codes to target system, we use simulation to analyze whether IDS such as STRIDE and APE can successfully detect the polymorphic test codes that we created, and whether the created carrier has a 90 % or above possibility of successful execution in target system...|$|R
50|$|On 31 December 2009 Olympic Airlines ceased all operations, as {{flights to}} Greek islands {{have already been}} {{allocated}} and are being flown by other carriers and flights to destinations outside the European Union have been allocated to other carriers who started operating them from 1 January 2010. Until the final closure, Olympic Airlines used the temporary <b>code</b> <b>OP</b> for their flights (instead of OA, which is used by their successor, Olympic Air). All Olympic Airlines flights (using the <b>OP</b> <b>code)</b> since 29 September 2009 and until the final deadline of 31 December 2009, were operated by Olympic Air on a wet lease basis. The 31 December 2009 deadline as the final possible date that Olympic Airlines should cease operations, was agreed between the Greek Government and the European Commission {{as part of the}} deal to close Olympic Airlines and sell the name and assets to Olympic Air. It was initially expected that operations would end much earlier, but due to the change of government in October 2009 the public tenders for the reallocation of subsidised flights to the Greek islands and for international flight rights outside the European Union were postponed. The company stayed alive until the final deadline of 31 December 2009.|$|R
3000|$|We analyse the {{asymptotic}} behaviour {{of the network}} at high average SNR {{to gain a better}} insight on outage performance. As both average uplink and average internode SNR increase, we examine the relation of γ̅_i and γ̅_u and present OP approximations for two distinct cases, the former being high average internode (γ̅_i≫γ̅_u) and the latter being the high average uplink (γ̅_u≫γ̅_ij) regime. In both cases, all the average internode SNRs are assumed to be equal, i.e. γ̅_ij = γ̅_i. In addition, as the average uplink SNR goes to infinity, we observe the diversity and coding gains, as the OP can be written as P̃_O (γ _ 0) = [...] (G_cγ̅_u)^- G_d, with G_c denoting the coding gain and G_d the diversity gain. We first solve <b>OP,</b> <b>coding</b> and diversity gains for the non-blocked case, and then extend to the blocked case by averaging over the number of blocked links.|$|R
40|$|This paper {{describes}} a working chip, called FLEETzero, built to test an asynchronous switch fabric. The switch fabric transports 8 -bit data items {{from any of}} eight sources to any of eight destinations. Measured throughput corresponds to approximately six gate-delays per data item, which in its 0. 35 micron technology is in excess of 1. 2 Giga-Data-Items per second (GDIh); the corresponding latency through seven stages from source to destination is less than 4 nanoseconds. FLEETzero demonstrates a new family of high speed asynchronous control circuits, especially data-controlled branch and merge circuits that form the switch fabric. The FLEET concept may also herald a paradigm shqt for computers. This new paradigm emphasizes data movement as the core action and contrasts with the traditional <b>op</b> <b>code</b> paradigm that focuses attention on logic and arithmetic instructions. The new paradigm promises outstanding throughput and many opportunities for optimization...|$|R
50|$|PDP-11 {{processor}} speed varied by model, memory configuration, <b>op</b> <b>code,</b> and addressing modes. Instruction timing had {{up to three}} components, execute/fetch of the instruction itself and access time for the source and the destination. The last two components depended on the addressing mode. For example, on the PDP-11/70 (circa 1975), an instruction of the form ADD x(Rm),y(Rn) had a fetch/execute time of 1.35 microseconds plus source and destination times of 0.6 microseconds each, for a total instruction time of 2.55 microseconds. Any case where addressed memory {{was not in the}} cache added 1.02 microseconds. The register-to-register ADD Rm,Rn could execute from the cache in 0.3 microseconds. Floating point was even more complex, since there was some overlap between the CPU and the floating-point processor, but in general, floating point was significantly slower. A single-precision floating add instruction could range from 2.4 to 5.5 microseconds plus time to fetch the operands.|$|R
