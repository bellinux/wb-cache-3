4680|176|Public
25|$|CSP {{has been}} imbued with several {{different}} formal semantics, which define {{the meaning of}} syntactically correct CSP expressions. The theory of CSP includes mutually consistent denotational semantics, algebraic semantics, and <b>operational</b> <b>semantics.</b>|$|E
25|$|Over the years, {{a number}} of tools for {{analyzing}} and understanding systems described using CSP have been produced. Early tool implementations {{used a variety of}} machine-readable syntaxes for CSP, making input files written for different tools incompatible. However, most CSP tools have now standardized on the machine-readable dialect of CSP devised by Bryan Scattergood, sometimes referred to as CSPM. The CSPM dialect of CSP possesses a formally defined <b>operational</b> <b>semantics,</b> which includes an embedded functional programming language.|$|E
2500|$|In {{computer}} science, simulation {{has some}} specialized meanings: Alan Turing {{used the term}} [...] "simulation" [...] to refer to {{what happens when a}} universal machine executes a state transition table (in modern terminology, a computer runs a program) that describes the state transitions, inputs and outputs of a subject discrete-state machine. [...] The computer simulates the subject machine. Accordingly, in theoretical computer science the term simulation is a relation between state transition systems, useful in the study of <b>operational</b> <b>semantics.</b>|$|E
40|$|Extended Markovian Process Algebra (EMPA) is {{a process}} algebra {{suitable}} for expressing functional and performance aspects of concurrent systems. It is equipped with an <b>operational</b> interleaving <b>semantics,</b> a functional semantics, a Markovian <b>semantics</b> and an <b>operational</b> net <b>semantics.</b> In this paper we apply an integrated approach based on EMPA for mod-eling and analyzing concurrent systems to the Dining Philosophers problem. The problem is firstly described by an EMPA term and then it is studied on the semantic models associated with the term. ...|$|R
5000|$|Additional {{desirable}} properties we {{may wish}} to hold between <b>operational</b> and denotational <b>semantics</b> are: ...|$|R
50|$|Watt is a {{professor}} at the University of Glasgow, Scotland. With Peter Mosses he developed action semantics, a combination of denotational <b>semantics,</b> <b>operational</b> and algebraic <b>semantics.</b> He currently teaches a third year programming languages course, and a postgraduate course on algorithms and data structures. http://www.dcs.gla.ac.uk/people/personal/daw/ He is recognisable around campus for his more formal attire compared to the department's normally casual dress code.|$|R
5000|$|<b>Operational</b> <b>semantics,</b> {{whereby the}} {{execution}} of the language is described directly (rather than by translation). <b>Operational</b> <b>semantics</b> loosely corresponds to interpretation, although again the [...] "implementation language" [...] of the interpreter is generally a mathematical formalism. <b>Operational</b> <b>semantics</b> may define an abstract machine (such as the SECD machine), and give meaning to phrases by describing the transitions they induce on states of the machine. Alternatively, as with the pure lambda calculus, <b>operational</b> <b>semantics</b> can be defined via syntactic transformations on phrases of the language itself; ...|$|E
50|$|Small-step {{semantics}} {{give more}} {{control of the}} details and order of evaluation. In the case of instrumented <b>operational</b> <b>semantics,</b> this allows the <b>operational</b> <b>semantics</b> to track and the semanticist to state and prove more accurate theorems about the run-time behaviour of the language. These properties make small-step semantics more convenient when proving type soundness of a type system against an <b>operational</b> <b>semantics.</b>|$|E
50|$|Structural <b>operational</b> <b>semantics</b> (also called {{structured}} <b>operational</b> <b>semantics</b> or small-step semantics) {{was introduced}} by Gordon Plotkin in (Plotkin81) as a logical means to define <b>operational</b> <b>semantics.</b> The basic idea behind SOS is to define {{the behavior of a}} program in terms of the behavior of its parts, thus providing a structural, i.e., syntax-oriented and inductive, view on <b>operational</b> <b>semantics.</b> An SOS specification defines the behavior of a program in terms of a (set of) transition relation(s). SOS specifications {{take the form of a}} set of inference rules that define the valid transitions of a composite piece of syntax in terms of the transitions of its components.|$|E
3000|$|In this section, we {{prove that}} the <b>{{operational}}</b> net <b>semantics</b> is sound w.r.t. the operational LTS semantics: for any process p ∈P, the LTS rooted in p is bisimilar to the rooted LTS IMG(Net(dec([...] p))). First, some auxiliary lemmata.|$|R
40|$|Abstract. Orc [6] is a {{language}} for task orchestration. It {{has a small}} set of primitives, but it is sufficient to express many useful programs succinctly. We show that the <b>operational</b> and denotational <b>semantics</b> given in Kitchin et. al [6] do not agree, by giving a counterexample to their Theorem 3. We remedy this situation by providing new <b>operational</b> and denotational <b>semantics</b> with a better treatment of variable binding, and proving an adequacy theorem to relate them. ...|$|R
40|$|In last year’s HSCC conference, we {{introduced}} the Φ-calculus [8], {{an extension of}} Milner’s powerful π-calculus, so that concurrent and reconfigurable programs could interact with a (concurrent) continuous environment in {{the sense in which}} ordinary hybrid automata do so. In that paper, though, we were concerned only with the <b>operational</b> (hybrid) <b>semantics</b> of such systems, and no...|$|R
50|$|Big-step {{structural}} <b>operational</b> <b>semantics</b> is {{also known}} under the names natural semantics, relational semantics and evaluation semantics. Big-step <b>operational</b> <b>semantics</b> was introduced under the name natural semantics by Gilles Kahn when presenting Mini-ML, a pure dialect of the ML language.|$|E
5000|$|Disambiguation {{based on}} <b>operational</b> <b>semantics</b> of default logic.|$|E
50|$|It {{is often}} {{considered}} important to connect denotational semantics with <b>operational</b> <b>semantics.</b> This {{is especially important}} when the denotational semantics is rather mathematical and abstract, and the <b>operational</b> <b>semantics</b> is more concrete or closer to the computational intuitions. The following properties of a denotational semantics are often of interest.|$|E
40|$|Java `ight {{is a large}} {{sequential}} sublanguage of Java. We formalize its abstract syntax, type system, well-formedness conditions, and an <b>operational</b> evaluation <b>semantics.</b> Based on this formalization, we {{can express}} and provetype soundness. All definitions and proofs have been done formally in the theorem prover Isabelle/HOL. Thus this paper demonstrates that machine-checking the design of non-trivial programming languages has become a reality...|$|R
40|$|Extended Markovian Process Algebra (EMPA) is {{a process}} algebra {{suitable}} for expressing functional and performance aspects of concurrent systems. It is equipped with an <b>operational</b> interleaving <b>semantics,</b> a functional semantics, a Markovian <b>semantics</b> and an <b>operational</b> net <b>semantics.</b> In this paper we apply an integrated approach based on EMPA for modeling and analyzing concurrent systems to the Dining Philosophers problem. The problem is firstly described by an EMPA term and then it is studied on the semantic models associated with the term. 1 Introduction The need of integrating the performance analysis of a concurrent system into the design process of the system itself has been widely recognized and stimulated many researchers. The problem is that, in the case when the performance aspect is neglected, time-critical concurrent systems, such as real-time systems and communication protocols, cannot be modeled in a completely satisfactory manner. And, more important, {{there is no way}} of e [...] ...|$|R
50|$|Action {{semantics}} is {{a framework}} for the formal specification of semantics of programming languages invented by David Watt and Peter D. Mosses in the 1990s. It {{is a mixture of}} denotational, <b>operational</b> and algebraic <b>semantics.</b>|$|R
5000|$|In {{computer}} science, {{denotational semantics}} is contrasted with <b>operational</b> <b>semantics.</b>|$|E
5000|$|Z.164 - <b>Operational</b> <b>Semantics</b> - Defines how TTCN-3 is {{executed}} ...|$|E
5000|$|In 1981, Gordon Plotkin publishes {{his paper}} on {{structured}} <b>operational</b> <b>semantics.</b>|$|E
40|$|In {{this article}} wepresent Bali, the {{formalization}} {{of a large}} (hitherto sequential) sublanguage of Java. Wegive its abstract syntax, type system, well-formedness conditions, and an <b>operational</b> evaluation <b>semantics.</b> Based on these definitions, we can express soundness of the type system, an important design goal claimed to be reached by the designers of Java, and provethatBali is indeed type-safe. All definitions and proofs have been done formally in the theorem prover Isabelle/HOL. Thus this article demonstrates that machine-checking the design of non-trivial programming languages has become a reality...|$|R
40|$|The denotational, <b>operational,</b> and axiomatic <b>semantics,</b> a {{verification}} condition generator, and all {{the necessary}} soundness, completeness and equivalence proofs. Essentially a formalization of the first 100 pages of [3]. An eminently readable description of this theory is found in [2]. See also HOLCF/IMP for a denotational semantics...|$|R
40|$|This paper {{describes}} compositional <b>semantics</b> (<b>operational,</b> denotational and logical) for {{a process}} algebra enhanced with input/output actions and preemption combinators, {{in the presence}} of fairness. The context of this paper is Triveni, a process-algebra-based design methodology that combines threads and events in the context of object-oriented programming [CJ...|$|R
5000|$|<b>Operational</b> <b>semantics</b> — {{in terms}} {{of the state of the}} {{computation}} ...|$|E
50|$|<b>Operational</b> <b>semantics</b> is a {{category}} of formal programming language semantics in which certain desired properties of a program, such as correctness, safety or security, are verified by constructing proofs from logical statements about its execution and procedures, rather than by attaching mathematical meanings to its terms (denotational semantics). <b>Operational</b> <b>semantics</b> are classified in two categories: structural <b>operational</b> <b>semantics</b> (or small-step semantics) formally describe how the individual steps of a computation {{take place in a}} computer-based system. By opposition natural semantics (or big-step semantics) describe how the overall results of the executions are obtained. Other approaches to providing a formal semantics of programming languages include axiomatic semantics and denotational semantics.|$|E
50|$|RIF-PRD has an <b>operational</b> <b>semantics,</b> {{whereas the}} {{condition}} formulas {{also have a}} model-theoretic semantics.|$|E
50|$|Mosses {{has spent}} most of his career at BRICS in Denmark. He {{returned}} to a chair at Swansea University, Wales. His main contribution has been in the area of formal program semantics. In particular, with David Watt he developed action semantics, a combination of denotational, <b>operational</b> and algebraic <b>semantics.</b>|$|R
40|$|We {{introduce}} a trace semantics for a call-by-value language with full polymorphism and higher-order references. This is an <b>operational</b> game <b>semantics</b> model {{based on a}} nominal interpretation of parametricity whereby polymorphic values are abstracted with special kinds of names. The use of polymorphic references leads to violations of parametricity which we counter by closely recoding the disclosure of typing information in the semantics. We prove the model sound for the full language and strengthen our result to full abstraction for a large fragment where polymorphic references obey specific inhabitation conditions...|$|R
40|$|In {{this article}} we present Bali, the {{formalization}} of a large (hitherto sequential) sublanguage of Java. We give its abstract syntax, type system, well-formedness conditions, and an <b>operational</b> evaluation <b>semantics.</b> Based on these definitions, we can express soundness of the type system, an important design goal claimed to be reached by the designers of Java, and prove that Bali is indeed type-safe. All definitions and proofs have been done formally in the theorem prover Isabelle/HOL. Thus this article demonstrates that machine-checking the design of non-trivial programming languages has become a reality...|$|R
5000|$|Irene Greif, for her {{definition}} of an <b>operational</b> <b>semantics</b> for the actor model in 1975 ...|$|E
50|$|Gordon David Plotkin, FRS, FRSE (born 9 September 1946) is a {{theoretical}} computer scientist in the School of Informatics at the University of Edinburgh. Plotkin {{is probably best}} known for his introduction of structural <b>operational</b> <b>semantics</b> (SOS) and his work on denotational semantics. In particular, his notes on A Structural Approach to <b>Operational</b> <b>Semantics</b> were very influential. He has contributed to many other areas of computer science.|$|E
50|$|Methods {{have been}} {{proposed}} to use the <b>operational</b> <b>semantics</b> of machine languages to automatically generate verification condition generators.|$|E
40|$|Three {{languages}} with polymorphic type disciplines are discussed, {{namely the}} *-calculus with Milner's polymorphic type discipline; a language with imperative features (polymorphic references); and a skeletal module language with structures, signatures and functors. In {{each of the}} two first cases we show that the type inference system is consistent with an <b>operational</b> dynamic <b>semantics.</b> On the module level, polymorphic types correspond to signatures. There is a notion of principal signature. So-called signature checking is the module level equivalent of type checking. In particular, there exists an algorithm which either fails or produces a principal signature...|$|R
40|$|AbstractThe paper {{describes}} a semantic framework for languages used in defining non-deterministic search of problem spaces. The chosen formalism is production system formalism. Semantics is discussed from an operational viewpoint, {{taking into account}} the role of control strategies, and from a denotational viewpoint. Comparisons between <b>operational</b> and denotational <b>semantics</b> are developed...|$|R
40|$|AbstractThis paper {{describes}} the automated complexity analysis (ACA) system for automated higher-order complexity analysis of functional programs synthesized with the NUPRL proof development system. We introduce a general framework for defining models of computational complexity for functional programs {{based on an}} annotation of a given <b>operational</b> language <b>semantics.</b> Within this framework, we use type decomposition and polynomialization to express the complexity of higher-order terms. Symbolic interpretation of open terms automates complexity analysis, which involves generating and solving higher-order recurrence equations. Finally, {{the use of the}} ACA system is demonstrated by analyzing three different implementations of the pigeonhole principle...|$|R
