3|10|Public
500|$|There are few {{varieties}} in the series, {{and they}} are relatively minor. [...] They principally involve the mint mark: several repunchings, one <b>overpunching</b> of a D over an S in 1942, and some changes in size. [...] One oddity is the 1943/1942, {{which is not a}} true overdate but was formed by a working die struck once from a 1942-dated master die, and once from one dated 1943. [...] Some 1946 half dollars show a doubled die on the reverse.|$|E
50|$|The top two {{positions}} of a column are called zone punches, 12 (top) and 11. For decimal data the lower ten positions represent (from top to bottom) the digits 0 through 9. An arithmetic sign {{can be specified}} for a decimal field by <b>overpunching</b> the field's rightmost column with a zone punch: 12 for plus, 11 for minus (CR). For Pound sterling pre-decimalization currency a pence column represented the values zero through eleven; 10 (top), 11, then 0 through 9 as above. An arithmetic sign can be punched in the adjacent shilling column. Zone punches had other uses in processing, such as indicating a master card.|$|E
5000|$|... and [...] were rarely-used {{characters}} that {{corresponded to the}} punched-card convention of a digit 0 with an <b>overpunched</b> sign in rows 12 or 11.) ...|$|R
50|$|Standard sign {{values are}} 1100 (hex C) for {{positive}} (+) and 1101 (D) for negative (−). This convention {{comes from the}} zone field for EBCDIC characters and the signed <b>overpunch</b> representation. Other allowed signs are 1010 (A) and 1110 (E) for positive and 1011 (B) for negative. IBM System/360 processors will use the 1010 (A) and 1011 (B) signs if the A bit {{is set in the}} PSW, for the ASCII-8 standard that never passed. Most implementations also provide unsigned BCD values with a sign nibble of 1111 (F). ILE RPG uses 1111 (F) for positive and 1101 (D) for negative. These match the EBCDIC zone for digits without a sign <b>overpunch.</b> In packed BCD, the number 127 is represented by 0001 0010 0111 1100 (127C) and −127 is represented by 0001 0010 0111 1101 (127D). Burroughs systems used 1101 (D) for negative, and any other value is considered a positive sign value (the processors will normalize a positive sign to 1100 (C)).|$|R
5000|$|A signed <b>overpunch</b> is a code used {{to store}} {{the sign of a}} number by {{changing}} the last digit. It is used in COBOL, especially when using EBCDIC. Its purpose is to save a character that would otherwise be used by the sign digit. [...] The code is derived from the Hollerith Punched Card Code, where both a digit and a sign can be entered in the same card column.|$|R
50|$|Numeric columns {{have one}} punch in rows 0-9, {{possibly}} a sign <b>overpunch</b> in rows 11-12, {{and can be}} sorted {{in a single pass}} through the sorter. Alphabetic columns have a zone punch in rows 12, 11, or 0, a digit punch in one of the rows 1-9, and can be sorted by passing {{some or all of the}} cards through the sorter twice on that column. For more details of punched card codes see Punched card#IBM 80-column punched card formats and character codes.|$|R
50|$|Due to {{primitive}} working conditions, {{materials and}} poorly constructed dies numerous errors and variations appeared. These include letters and numbers shaped differently, cracks {{appearing on the}} surface of the coins, misstrikes and overstrikes (Liberty half dime, 1796), the size of stars or numbers varied from one die to the next (1807 half dollar) and dates <b>overpunched</b> previous dates (1800 large cent, printed over 1798 and 1799). Incongruities persisted: In 1796 the half dollar appeared with 15 stars, then 16 stars. Mysteriously it portrayed 15 stars in 1797 despite the presence of 16 states. Many of these faults are quite rare and demand a high premium due to their scarcity.|$|R
500|$|When {{it became}} known that the Denver Mint had struck only 2,630,030nickels in 1950, the coins (catalogued as 1950-D) began to be widely hoarded. [...] Speculation in them {{increased}} in the early 1960s, but prices decreased sharply in 1964. Because they were so widely pulled from circulation, the 1950-D is readily available today. [...] A number of reverse dies with an S mint mark, intended for the San Francisco Mint, were created in 1955; they were not used as that mint struck no nickels that year and subsequently closed, and the unused dies were sent for use at Denver, where the S mint mark was <b>overpunched</b> with a D. [...] 1949 and 1954 are other years where one mintmark was punched over another.|$|R
5000|$|Note: {{the binary}} {{conversions}} of the codepoints are often shown in reverse order, depending on (presumably) from which side one views the paper tape. Note further that the [...] "control" [...] characters were chosen {{so that they}} were either symmetric or in useful pairs so that inserting a tape [...] "upside down" [...] {{did not result in}} problems for the equipment and the resulting printout could be deciphered. Thus FIGS (11011), LTRS (11111) and space (00100) are invariant, while CR (00010) and LF (01000), generally used as a pair, are treated the same regardless of order by page printers. LTRS could also be used to <b>overpunch</b> characters to be deleted on a paper tape (much like DEL in 7-bit ASCII).|$|R
5000|$|Code 127 (DEL, a.k.a. [...] "rubout") is {{likewise}} a special case. Its 7-bit code is all-bits-on in binary, which essentially erased a character cell {{on a paper}} tape when <b>overpunched.</b> Paper tape was a common storage medium when ASCII was developed, with a computing history dating back to WWII code breaking equipment at Biuro Szyfrów. Paper tape became obsolete in the 1970s, so this clever aspect of ASCII rarely saw any use after that. Some systems (such as the original Apples) converted it to a backspace. But because its code is in the range occupied by other printable characters, and because it had no official assigned glyph, many computer equipment vendors used it as an additional printable character (often an all-black [...] "box" [...] character useful for erasing text by overprinting with ink).|$|R
50|$|Some {{software}} development {{from the early}} 1970s is notable. PLN (created by Robert Nichols) was the host language {{for a number of}} DG products, making them easier to develop, enhance, and maintain than macro assembler equivalents. PLN smacked of a micro-subset of PL/I, in sharp contrast to other languages of the time, such as BLISS. The RPG product (shipped in 1976) incorporated a language runtime system implemented as a virtual machine which executed pre-compiled code as sequences of PLN statements and Eclipse commercial instruction routines. The latter provided microcode acceleration of arithmetic and conversion operations {{for a wide range of}} now-arcane data types such as <b>overpunch</b> characters. The DG Easy product, a portable application platform developed by Nichols and others from 1975 to 1979 but never marketed, had roots easily traceable back to the RPG VM created by Stephen Schleimer.|$|R

