3|2|Public
50|$|A {{specific}} component of anti-virus and anti-malware software, {{commonly referred to}} as an on-access or real-time scanner, hooks deep into the operating system's core or kernel and functions {{in a manner similar to}} how certain malware itself would attempt to operate, though with the user's informed permission for protecting the system. Any time the operating system accesses a file, the <b>on-access</b> <b>scanner</b> checks if the file is a 'legitimate' file or not. If the file is identified as malware by the scanner, the access operation will be stopped, the file will be dealt with by the scanner in a pre-defined way (how the anti-virus program was configured during/post installation), and the user will be notified. This may have a considerable performance impact on the operating system, though the degree of impact is dependent on how well the scanner was programmed. The goal is to stop any operations the malware may attempt on the system before they occur, including activities which might exploit bugs or trigger unexpected operating system behavior.|$|E
40|$|The biographical texts {{constitute}} today one of {{the main}} products of cultural consumer, whose success is understandable by the innate curiosity that feeds the mind in the mayora of people towards their fellow citizens. From here it is an <b>on-access</b> <b>scanner</b> types (biographies autobiographies, memories) and patterns of consumption in the culture marke...|$|E
40|$|Abstract — Fast virus {{scanning}} {{is becoming}} increasingly important in today’s Internet. While Moore’s law continues to double CPU cycle speed, virus scanning applications fail to ride on the performance wave due to their frequent random memory accesses. This paper proposes Hash-AV, a virus scanning “booster ” technique that aims {{to take advantage of}} improvements in CPU performance. Using a set of hash functions and a bloom filter array that fits in CPU second-level (L 2) caches, Hash-AV determines the majority of “no-match ” cases without accesses to main memory. Experiments show that Hash-AV improves the performance of the open-source virus scanner Clam-AV by a factor of 2 to 10. The key to Hash-AV’s success lies in a set of “bad but cheap ” hash functions that are used as initial hashes. The speed of Hash-AV makes it well suited for “on-access” virus scanning, providing greater protections to the user. Through intercepting system calls and wrapping glibc libraries, we have implemented an “on-access ” version for Hash-AV+Clam-AV. The <b>on-access</b> <b>scanner</b> can examine input data at a throughput of over 200 Mb/s, making it suitable for network-based virus scanning. I...|$|E
50|$|An {{edition of}} Kaspersky's {{anti-virus}} solution for Linux workstations {{is available to}} business consumers. It offers many of the features included in the mainstream version for Windows, including <b>on-access</b> and on-demand <b>scanners.</b>|$|R
40|$|Smartphones {{have come}} to {{resemble}} PCs in software complexity. Moreover, as they are often used for privacy-sensitive tasks, they are becoming attractive targets for attackers. Unfortunately, they are quite different from PCs in terms of resources, so that PC-oriented security solutions are not always applicable. Worse, common security solutions (such as <b>on-access</b> file <b>scanners,</b> system call profilers, etc.) protect against a very limited set of attacks. Comprehensive measures require a far wider and more expensive set of checks- {{some of which are}} much beyond the capacity of a phone. We propose an alternative solution, where security checks are applied on remote security servers which host exact replicas of the phones in virtual environments. The servers are not subject to the same constraints, allowing us to apply multiple detection techniques simultaneously (including ones that are very heavy-weight). Moreover, as the full execution trace is preserved on the security server, attackers cannot hide their traces. This property ensures that attacks for which a detection method exists at the security server- even if the detection method is installed at a later time- are detectable eventually. This is a stronger guarantee than existing solutions can give. It allows administrators to trade server resources for security by specifying how far back in time {{they want to be able}} to start looking for intrusions with a new detection method. We implemented the security model for Android phones and show that it is both practical and scalable: we generate about 2 KiB/s and 64 B/s of trace data under high-load and idle operation respectively, and are able to support more than a hundred replicas on a single server. ...|$|R

