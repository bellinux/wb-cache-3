1|5|Public
5000|$|Missing {{values in}} the last two fields are {{interpreted}} as zeros. If necessary, space characters in the first, second, and fourth fields are indicated by the <b>octal</b> <b>character</b> code [...]|$|E
50|$|The console {{consisting}} of a vertical display panel about 10 in high by about 5 ft long with a similarly sized slightly angled control panel below it. Each of these two parts was filled with labeled buttons and illuminated indicators each (roughly) one inch square. The display section {{was made up of}} indicators which when illuminated showed, in binary (grouped as <b>octal)</b> <b>characters,</b> the machine’s current running (or static) status at the individual machine core address and register level, for the compute, read and write operations then in progress. When a program was running, this display was a kaleidoscope of quickly changing, flashing, multi-colored lights. The control panel section consisted of press-buttons to select the next register to be set and a central part that mirrored the lay-out of a single machine core address. Other buttons accessed more complex operations. Use of these buttons enabled the operator to select and then directly input to the machine’s core storage locations and registers the octal pattern he/she keyed in manually. For an operator to input a single machine instruction, each of up to ten <b>octal</b> <b>characters</b> of the instruction had to be selected and keyed in as its binary pattern - each with the correct (odd) parity bit.|$|R
5000|$|KDF8 was a {{transistor}} based {{machine with}} magnetic core memory. The core {{memory of the}} machine installed at the Kidsgrove computer bureau was upgraded from 64k to the then maximum of 96k of core memory. KDF8 used an octal (base eight) addressing system. A machine-code instruction was fixed length, ten <b>octal</b> <b>characters</b> long. The instruction set was specifically designed for commercial use. It had machine-code level instructions for {{all four of the}} decimal arithmetic functions operating on variable length numbers, and also had instructions for efficient manipulation of variable-length data-strings. Not all instructions required all ten characters. Given the minimal core memory available, programmers frequently used [...] "spare" [...] characters in instructions for storage of constants and similar storage-saving tricks.|$|R
5000|$|Where 14 was the {{operation}} code {{for this type}} of read, 200000 was the lowest store location the data would be read to, 00 indicates that no register modification was to be done to the A or B addresses of the instruction, and 77 was the (fixed) device identifier of the paper tape reader. (Note - 77 used as a device ID for a write operation would direct the write to the operator's teleprinter. Embarrassing if this was due to a program error, and it was a large data block intended for mag tape.....) The last four <b>octal</b> <b>characters</b> (0000) were not required in this instruction, and would be ignored when the instruction was processed. Such [...] "spare" [...] characters were frequently, given the extremely limited main store available used by programmers to store constants.|$|R
5000|$|Data {{was sent}} to the {{terminal}} using an extended set of codes similar to those introduced on the VT52. VT52 codes generally started with the [...] <b>character</b> (<b>octal</b> 33 decimal 27) and was then followed by a single letter instruction. For instance, the string of four characters [...] would reposition the cursor in the upper left (home) and then clear the screen from that point down. These codes were basically modeless; triggered by the [...] the resulting escape mode automatically exited again when the command was complete. Escape codes could be interspersed with display text anywhere in the stream of data.|$|R
5000|$|This {{code was}} {{originally}} used to mark deleted characters on punched tape, since any character could {{be changed to}} all ones by punching holes everywhere. If a character was punched erroneously, punching out all seven bits caused this position to be ignored or deleted, a computer version of correction fluid. In hexadecimal, this is 7F to rubout 7 bits, and FF to rubout 8 bits. For teleprinters like the Teletype Model 33, lines were commonly ended by the three characters CR, LF, and rubout, with the rubout allowing time for the print mechanism to physically move to the left margin. On VT100 compatible terminals, this is the character generated by the key labeled Delete, which transmits a delete <b>character</b> (<b>octal</b> 177, hexadecimal 7F) to the host system. On VT510 compatible terminals, this is the character generated by the key labeled ?, usually called backspace on modern machines, and does not correspond to the PC [...] "Delete" [...] key.|$|R

