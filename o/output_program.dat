58|1350|Public
5000|$|If {{the input}} program [...] uses [...] registers, the <b>output</b> <b>program</b> [...] will need [...] registers, where [...] is a {{parameter}} of the construction. [...] uses [...] memory and its (worst-case) access overhead is [...]|$|E
50|$|In many {{applications}} the <b>output</b> <b>program</b> must be correct {{with respect to}} the examples and partial specification, and this leads to the consideration of inductive programming as a special area inside automatic programming or program synthesis, usually opposed to 'deductive' program synthesis, where the specification is usually complete.|$|E
50|$|Further, compilers {{can contain}} interpreters for {{optimization}} reasons. For example, where an expression can be executed during compilation {{and the results}} inserted into the <b>output</b> <b>program,</b> then it prevents it having to be recalculated each time the program runs, which can greatly speed up the final program. Modern trends toward just-in-time compilation and bytecode interpretation at times blur the traditional categorizations of compilers and interpreters even further.|$|E
40|$|Abstract. This paper defines and {{analyzes}} injection attacks. The def-inition {{is based}} on the NIE property, which states that an application’s untrusted inputs must only produce Noncode Insertions or Expansions in <b>output</b> <b>programs</b> (e. g., SQL queries). That is, when applications gen-erate <b>output</b> <b>programs</b> based on untrusted inputs, the NIE property re-quires that inputs only affect <b>output</b> <b>programs</b> by inserting or expand-ing noncode tokens (e. g., string and float literals, lambda values, point-ers, etc). This paper calls attacks based on violating the NIE property BroNIEs (i. e., Broken NIEs) and shows that all code-injection attacks are BroNIEs. In addition, BroNIEs contain many malicious injections that do not involve injections of code; we call such attacks noncode-injection attacks. In order to mitigate both code- and noncode-injection attacks, this paper presents an algorithm for detecting and preventing BroNIEs. Key words: injection attacks, formal methods, language-based security...|$|R
40|$|Autocapture is an {{algorithm}} for automatic {{adaptation of}} ventricular output to capture threshold. The {{aim of this}} prospective study was to estimate the effects of ventricular Autocapture algorithm on DDD-DDDR pacemaker longevity. METHODS AND RESULTS: Eighty-three patients implanted with a DDD-DDDR pacemaker (Affinity or Entity; St Jude Medical, USA) were enrolled and the Autocapture function was activated pre-discharge. Ventricular pulse duration was randomly programmed at 0. 3 or 0. 4 ms, with a cross-over at 8 - 12 weeks and again at 13 - 14 months. Diagnostic data were retrieved from device memory and by calculating battery current drain from long-term threshold recordings; device longevity was estimated at the following settings: Autocapture with a pulse duration of 0. 3 and 0. 4 ms, respectively, standard output (3. 5 V, 0. 4 ms) and conventional low <b>output</b> <b>programming</b> (2. 5 V, 0. 4 ms). According {{to a series of}} assumptions, Autocapture was associated with a 55 - 60 % increase in estimated device longevity compared with standard <b>output</b> <b>programming</b> and a 6 - 7 % increase in longevity compared with low <b>output</b> <b>programming.</b> No {{significant differences were found between}} Autocapture programmed with a pulse duration of 0. 3 or 0. 4 ms. In projections to a 10 -year follow-up, use of the Autocapture function resulted in a 42 % reduction in pacing-related estimated costs compared with standard <b>output</b> <b>programming</b> at 3. 5 V, 0. 4 ms. CONCLUSION: Pacing with constant adaptation of ventricular output in dual-chamber devices has the potential to increase generator longevity and to reduce sizeably pacing-related costs compared with standard programmin...|$|R
50|$|A {{programming}} {{language is a}} formal language that specifies a set of instructions {{that can be used}} to produce various kinds of <b>output.</b> <b>Programming</b> languages generally consist of instructions for a computer. Programming languages can be used to create programs that implement specific algorithms.|$|R
50|$|A {{compiler}} {{is likely}} to perform many {{or all of the}} following operations: preprocessing, lexical analysis, parsing, semantic analysis (syntax-directed translation), conversion of input programs to an intermediate representation, code optimization and code generation. Compilers implement these operations in phases that promote efficient design and correct transformations of source input to target <b>output.</b> <b>Program</b> faults caused by incorrect compiler behavior can be very difficult to track down and work around; therefore, compiler implementers invest significant effort to ensure compiler correctness.|$|E
5000|$|Compiler {{optimization}} {{is generally}} implemented using {{a sequence of}} optimizing transformations, algorithms which take a program and transform it to produce a semantically equivalent <b>output</b> <b>program</b> that uses fewer resources. It {{has been shown that}} some code optimization problems are NP-complete, or even undecidable. In practice, factors such as the programmer's willingness to wait for the compiler to complete its task place upper limits on the optimizations that a compiler implementor might provide. (Optimization is generally a very CPU- and memory-intensive process.) In the past, computer memory limitations were also a major factor in limiting which optimizations could be performed. Because of all these factors, optimization rarely produces [...] "optimal" [...] output in any sense, and in fact an [...] "optimization" [...] may impede performance in some cases; rather, they are heuristic methods for improving resource usage in typical programs.|$|E
5000|$|Therapy can {{be either}} group or individual. Group therapies {{integrating}} visual aids are good for persons with global aphasia because their social skills are largely intact. Group therapy sessions typically revolve around simple, preplanned activities or games and aim to facilitate social communication. Individual therapy sessions focus on improving communication essential for daily living. One particular therapy designed specifically for persons with aphasia is Visual Action Therapy (VAT). VAT is a non-verbal gestural <b>output</b> <b>program</b> with 3 phases and 30 total steps. The program teaches unilateral gestures as symbolic representations of real life objects. Research {{on the effectiveness of}} VAT is limited and inconclusive. Another important therapy technique includes teaching family members and caregivers strategies for communicating with their loved one with global aphasia. Research offers such strategies including, a) simplifying sentences and using common words, b) gaining the person's attention before speaking, c) using pointing and visual cues, d) allowing for adequate response time, and e) creating a quiet environment free of distractions. Additional forms of treatment can be broken down into the following categories: [...] "language impairment-based treatment" [...] and [...] "activities/ participation-based treatment". [...] "Language impairment-based treatment" [...] includes using computer programs to better language functioning, treatments centered on bettering one's reading ability, and treatments centered on bettering one's ability to retrieve words. [...] "Activities/participation-based treatment" [...] often involves working with others to develop conversational skills. Overall, treatment for persons with global aphasia can be effective and can improve patients' abilities to communicate and participate in daily life activities.|$|E
50|$|The <b>output</b> the <b>program</b> is as follows.|$|R
50|$|Groups contain {{multiple}} {{output devices}} such as relays. This allows a single input, such as a smoke detector or MCP, to have only one <b>output</b> <b>programmed</b> to a group, which then maps to between two and many outputs or relays. This enables an installer to simplify programming by having many inputs map to the same outputs, {{and be able to}} change them all at once, and also allows mapping to more <b>outputs</b> than the <b>programming</b> space for a single detector/input allows.|$|R
5000|$|... luit - {{program that}} {{converts}} encoding of input and <b>output</b> to <b>programs</b> running interactively ...|$|R
40|$|This is a {{specification}} for a 2 ̆ 7 state-driven 2 ̆ 7 VISIBLE PROGRAM EXECUTION (VPE) system which, given a small Pascal 2 ̆ 7 displayed program 2 ̆ 7, automatically {{produces a}} VPE <b>output</b> <b>program</b> 2 ̆ 7. The VPE 2 ̆ 7 <b>output</b> <b>program</b> 2 ̆ 7, when executed, visibly executes the 2 ̆ 7 displayed program 2 ̆ 7 {{on a computer}} terminal...|$|E
40|$|Injection attacks, {{including}} SQL injection, cross-site scripting, {{and operating}} system command injection, rank {{the top two}} entries in the MITRE Common Vulnerability Enumeration (CVE) [1]. Under this attack model, an application (e. g., a web application) uses some untrusted input to produce an <b>output</b> <b>program</b> (e. g., a SQL query). Applications may be vulnerable to injection attacks because the untrusted input may alter the <b>output</b> <b>program</b> in malicious ways. Recent work has established a rigorous definition of injection attacks. Injections are benign iff they obey the NIE property, which states that injected symbols strictly insert or expand noncode tokens in the <b>output</b> <b>program.</b> Noncode symbols are strictly those that are either removed by the tokenizer (e. g., insignificant whitespace) or span closed values in the <b>output</b> <b>program</b> language, and code symbols are all other symbols. This thesis demonstrates that such attacks are possible on applications for Android—a mobile device operating system—and Bash—a common Linux shell—and shows by construction that these attacks can be detected precisely. Specifically, this thesis examines the recent Shellshock attacks on Bash and shows how it widely differs from ordinary attacks, but can still be precisely detected by instrumenting the output program’s runtime. The paper closes {{with a discussion of}} the lessons learned from this study and how best to overcome the practical challenges to precisely preventing these attacks in practice...|$|E
40|$|Schema-based logic program {{transformation}} {{has proven}} to be an eective technique for the optimiza-tion of programs. Some transformation schemas were given in [3]; they pre-compile some widely used transformation techniques from an input program schema that abstracts a particular family of programs into an <b>output</b> <b>program</b> schema that abstracts another family of programs. This report presents the correctness proofs of these transformation schemas, based on a correctness de nition of transformation schemas. A transformation schema is correct i the templates of its input and <b>output</b> <b>program</b> schemas are equivalent wrt the specication of the top-level relation dened in these program schemas, under the applicability conditions of this transformation schema. ...|$|E
50|$|The {{previous}} NOS {{management was}} replaced by a three-man board, charged with developing strategies and responsibility for all public <b>output.</b> <b>Programming</b> co-ordinators were appointed for each of the television and radio networks, and channel identities were created, largely replacing the varying on-air presentation of the pillar broadcasters. The broadcasting associations also have a degree of input through a Supervisory Board.|$|R
50|$|A new Supervisory Board {{replaced}} the Board of Directors in 1998. The previous management {{was replaced with}} a three-man board, now charged with developing strategies and responsibility for all public <b>output.</b> <b>Programming</b> co-ordinators were appointed for each television and radio network and channel identities were created, largely replacing the varying on-air presentation of the pillar broadcasters. The broadcasting associations also have a degree of input through the Supervisory Board.|$|R
40|$|Techniques for {{manual and}} {{automated}} grading of programming labs are discussed. Topics investigated include: general grading of programming labs, plagiarism detection, pro gram documentation, <b>program</b> <b>output,</b> and <b>program</b> efficiency. This investigation {{led to the}} development of automated grading tools that report on style and point to possible instances of plagiarism. The techniques utilized will be discussed and their use demonstrated...|$|R
40|$|Abstract This paper {{presents}} a region inference framework {{designed specifically for}} imperative pro-grams with dynamic allocation and destructive updates. Given an input program, the algorithm automatically translates it into an <b>output</b> <b>program</b> with region annotations on proce-dures and allocation commands, and with explicit region creation and removal commands...|$|E
40|$|Isothermal Gas Transfer program (GASXFER) solves {{variety of}} {{problems}} in which gas or gas mixture transferred between two containers. Special features of program include ease of entering data and ease of obtaining <b>output.</b> <b>Program</b> displays, prints, or graphs complete pressure history of each gas as function of time. Written in Lotus Symphony macrolanguage...|$|E
40|$|Transformation {{rules are}} often used to {{implement}} compilers for domain-specific languages. In an ideal situation, each transformation rule is a modular unit transforming one input element of the source program into a new element of the <b>output</b> <b>program.</b> However, in practice, transformation rules must be written which take one input element and produce several new elements belonging to various locations in the <b>output</b> <b>program,</b> the so-called local-to-global transformations. The implementation of such transformations is very complex and tightly coupled which imposes severe constraints on maintenance and evolvability. In this paper, we propose a transformation architecture on top of rewrite rules to loosen this coupling. The resulting transformation system combines the simplicity and modularity properties of rewrite rules with a new semi-automatic composition system that enables the implementation of local-to-global transformations without hampering maintenance and future evolutions...|$|E
50|$|JSP uses a diagramming {{notation}} {{to describe}} the structure of inputs, <b>outputs</b> and <b>programs,</b> with diagram elements {{for each of the}} fundamental component types.|$|R
25|$|Computers: The {{on-board}} equipment centered around a 2-of-3 computer system. The original LZB 80 design used 8085 microprocessors programmed in assembly language. The programs were interrupt driven, with interrupts {{generated by a}} 70 ms clock, the track receivers and transmitters, the serial interface, and also within the program itself. Interrupts triggered comparison and <b>output</b> <b>programs.</b> Peripheral equipment was arranged around the computers with all interfaces electrically separated and all grounds tied to the cabinet frame which was tied to the vehicle chassis.|$|R
50|$|Channel 5 and ITV Breakfast use {{a similar}} model to Channel 4 for {{providing}} their own advertising regions, despite also having a single national <b>output</b> of <b>programming.</b>|$|R
40|$|Development of a {{two-dimensional}} model to hindcast spectral wave parameters in an estuary with tidal flats {{on the basis}} of bottomtopography, current and wind data. The propagation of waves has been implemented (except diffraction) and tested. The input program is under design. The <b>output</b> <b>program</b> will be developed in two versions. Hydraulic EngineeringCivil Engineering and Geoscience...|$|E
40|$|This paper {{presents}} a region analysis and transformation framework for Java programs. Given an input Java program, the compiler automatically translates {{it into an}} equivalent <b>output</b> <b>program</b> with region-based memory management. The generated program contains statements for creating regions, allocating objects in regions, removing regions, and passing regions as parameters. As a particular case, the analysis can enable the allocation of objects on the stack. Our algorithm uses a flow-insensitive and context-sensitive points-to analysis to partition {{the memory of the}} program into regions and to identify points-to relations between regions. It then performs a flow-sensitive, inter-procedural region liveness analysis to identify object lifetimes. Finally, it uses the computed region information to produce the region annotations in the <b>output</b> <b>program.</b> Our results indicate that, for several of our benchmarks, the transformation can allocate most of the data on stack or in short-lived regions, and can yield substantial memory savings...|$|E
40|$|A {{tool for}} {{managing}} {{large numbers of}} APEX runs, handling data input and <b>output.</b> <b>Program</b> Components: ACCESS Database: Contains input tables used by i_APEX to construct APEX runs and output tables to organize APEX output. Graphical User Interface: Allows for single runs and ranges of runs and permits editing of input data as well as selection of output variables and output files...|$|E
50|$|The numeric base {{of input}} (in {{interactive}} mode), <b>output</b> and <b>program</b> constants may be specified by setting the reserved '''''' (input base) and '''''' (output base) variables.|$|R
5000|$|Tecplot 360 {{may be used}} to {{visualize}} <b>output</b> from <b>programming</b> languages such as Fortran. Tecplot's native data format is PLT or SZPLT. Many other formats are also supported, including: ...|$|R
50|$|This pattern {{encourages}} {{the use of}} text streams as the input and <b>output</b> of <b>programs.</b> This reliance on text has to be accounted when creating graphic shells to text programs.|$|R
40|$|Development of a {{two-dimensional}} model to hindcast spectral wave parameters in an estuary with tidal flats {{on the basis}} of bottomtopography, current and wind data. Diffraction-like propagation has been implemented and tested. Tests indicate that this type of propagation cannot. be used for most applications. Wave growth and decay has been implemented and tested. The results are satisfactory. The input program has been finalized. The <b>output</b> <b>program</b> has been implemented and is being tested. Hydraulic EngineeringCivil Engineering and Geoscience...|$|E
40|$|The {{author has}} {{identified}} the following significant results. As {{part of the}} tape reformatting process, a simple coded picture <b>output</b> <b>program</b> was developed. This represents Pixel's radiance level by one of a 47 character set on a nonoverprinting line printer. It not only has aided in locating areas for the reformatting process, but has also formed {{the foundation for a}} supervised clustering package. This in turn has led to a simplistic but effective thematic mapping package...|$|E
40|$|A package {{written in}} C for identif~’ingvariable {{dependencies}} in tables of data is presented. Thekey ingredient is the 8 -test, which establishes dependency structures by exploiting theproperties of continuous functions using conditional probabilities formed {{out of the}} data. The method estimates most relevantvariables, embedding dimensions and noise levels. The program, which is self-contained, also includes optional graphical <b>output.</b> <b>PROGRAM</b> SUMMARY Memory required to execute with typical data: 170 k words for a data file of 4000 lines lUle ofprogram: Delta 2. 0 No. of bits in a word: 3...|$|E
50|$|Osterley Television Centre is {{the home}} studio to much of BSkyB's <b>programming</b> <b>output.</b>|$|R
40|$|A {{simple method}} for blood spatter {{analysis}} was implemented using an image processing technique. The advantagesof the computer application were exploited which subsequently provides minimal time consumed and user friendly interface. The <b>outputs</b> from the <b>program</b> {{associated with the}} string method are used for finding {{the origin of the}} incident, i. e. wherethe blood came from. The direction and the impact angle of the bloodstain use 4 -step process analysis. The comparisonsbetween <b>outputs</b> from the <b>program</b> and the traditional method were reported. The primitive <b>outputs</b> from the <b>program</b> aremarginally acceptable with approximately 10 % error; however, with a simple tweak manually, the errors drop more than threetimes...|$|R
5000|$|This {{complete}} PDP-8 {{assembly language}} <b>program</b> <b>outputs</b> [...] "Hello, world!" [...] to the teleprinter.|$|R
