11|55|Public
5000|$|More precisely, one may {{distinguish}} {{three types}} of parameters or parameter modes: s, output parameters, and s; these are often denoted , , and [...] or [...] An input argument (the argument to an input parameter) must be a value, such as an initialized variable or literal, and must not be redefined or assigned to; an <b>output</b> <b>argument</b> must be an assignable variable, but it need not be initialized, any existing value is not accessible, and must be assigned a value; and an input/output argument must be an initialized, assignable variable, and can optionally be assigned a value. The exact requirements and enforcement vary between languages - for example, in Ada 83 output parameters can only be assigned to, not read, even after assignment (this was removed in Ada 95 to remove {{the need for an}} auxiliary accumulator variable). These are analogous to the notion of a value in an expression being an r-value (has a value), an l-value (can be assigned), or an r-value/l-value (has a value and can be assigned), respectively, though these terms have specialized meanings in C.|$|E
3000|$|Step 11 : Using {{the above}} {{constraints}} matrix and objective function, it computes the optimal solution using the usual simplex method. This {{optimized solution is}} then passed to the main function as its <b>output</b> <b>argument.</b>|$|E
3000|$|Step 3 : In this step, firstly the simplex {{function}} {{separates the}} constraints matrix and objective function matrix {{and then it}} computes the optimized solution based on the simplex method after some iteration. Then it provides these optimized solutions to the main function as its <b>output</b> <b>argument</b> in a single matrix containing values of decision variables and values of corresponding objective functions.|$|E
5000|$|Imported {{function}} {{shall not}} assume any initial values of formal <b>output</b> <b>arguments.</b> The initial value of <b>output</b> <b>arguments</b> is undetermined and implementation dependent.|$|R
5000|$|A concept cast (also concept recast or concept recasting) is a rewrite of {{a concept}} as a {{different}} concept because the original concept cannot {{be represented by}} the tools. In C, using pointers for <b>output</b> <b>arguments</b> because C doesn't support <b>output</b> <b>arguments</b> explicitly {{is an example of}} concept cast.|$|R
5000|$|... stub passes <b>output</b> <b>arguments</b> to the caller, {{releases}} execution {{thread and}} caller then continues in execution ...|$|R
40|$|Machine [21], is to {{pass the}} ith {{argument}} in register i: if the ith argument {{happens to be a}} variable (which typically corresponds to an <b>output</b> <b>argument),</b> the value passed is a pointer to the location of the variable (which may be either on the stack or on the heap). In effect, this policy passes output arguments by reference. The policy is motivated by the fact that, in general, Prolog procedures do not have any notion of input and output arguments, and a particular argument to a procedure can be an input argument in one invocation and an <b>output</b> <b>argument</b> in another. Returning outputs in memory allows a simple and uniform treatment of communication between procedure activations under these circumstances. The main advantage of a memory return policy, apart from simplicity, is that it never prevents tail call optimizations, since one memory location is as good as any other. Because of this, {{there is no need to}} insert code to move a value to a preferred location, as in Example 3. 2. Thus, [...] ...|$|E
40|$|Certain {{aspects of}} {{functional}} programming provide syntactic convenience, {{such as having}} a designated implicit <b>output</b> <b>argument,</b> which allows function cali nesting and sometimes results in more compact code. Functional programming also sometimes allows a more direct encoding of lazy evaluation, with its {{ability to deal with}} infinite data structures. We present a syntactic functional extensión of Prolog covering function application, predefined evaluable functors, functional definitions, quoting, and lazy evaluation. The extensión is also composable with higher-order features. We also highlight the Ciao features which help implementation and present some data on the overhead of using lazy evaluation with respect to eager evaluation...|$|E
40|$|Nondeterminism and {{partially}} instantiated data structures give logic programming expressive power {{beyond that of}} functional programming. However, functional programming often provides convenient syntactic features, such as having a designated implicit <b>output</b> <b>argument,</b> which allow function cali nesting and sometimes results in more compact code. Functional programming also sometimes allows a more direct encoding of lazy evaluation, with its {{ability to deal with}} infinite data structures. We present a syntactic functional extensión, used in the Ciao system, which can be implemented in ISO-standard Prolog systems and covers function application, predefined evaluable functors, functional definitions, quoting, and lazy evaluation. The extensión is also composable with higher-order features and can be combined with other extensions to ISO-Prolog such as constraints. We also highlight the features of the Ciao system which help implementation and present some data on the overhead of using lazy evaluation with respect to eager evaluation...|$|E
40|$|We {{address the}} task of annotating images with {{semantic}} tuples. Solving this problem requires an algorithm {{able to deal with}} hundreds of classes for each argument of the tuple. In such contexts, data sparsity becomes a key challenge. We propose handling this sparsity by incorporating feature representations of both the inputs (images) and <b>outputs</b> (<b>argument</b> classes) into a factorized log-linear model. Peer ReviewedPostprint (author's final draft...|$|R
5000|$|Message {{communication}} is then achieved with the [...] and [...] statements. The expression or variable providing the value for , and the variable in , must both {{be of the}} same type as the first channel argument. The following example shows {{the use of these}} functions in a process that receives a value from the left channel and outputs it on the right one.var left, right: channel; a: number;receive(left, a);send(right, a)The functions [...] and [...] can both take multiple input and <b>output</b> <b>arguments</b> respectively: ...|$|R
5000|$|Imported {{function}} {{can have}} input, <b>output,</b> and inout <b>arguments.</b>|$|R
40|$|Parallelism {{capabilities}} are becoming ubiquitous {{thanks to the}} widespread use of multi-core processors. This has renewed interest in language-related designs and tools which can simplify the task of producing parallel programs. The use of declarative languages {{is considered to be a}} valid approach for increasing performance through the execution of parallel programs. In particular, nondeterminism and partially instantiated data structures give logic programming expressive power beyond that of functional programming. However, functional programming often provides convenient syntactic features, such as having a designated implicit <b>output</b> <b>argument,</b> which allow function call nesting and sometimes results in more compact code, and also sometimes a more direct encoding of lazy evaluation, with its ability to deal with infinite data structures. The high-level nature of these languages, in addition to their iv relatively simple semantics and the use of logic variables, preserves more of the original parallelism to be uncovered by an automatic parallelization. Different alternative...|$|E
40|$|In general, logic {{programs}} are undirected, i. e. {{there is no}} concept of "input" and "output" arguments to a procedure. An argument may be used either as an input or as an <b>output</b> <b>argument,</b> and programs may be executed either in a "forward" direction or in a "backward" direction. However, it {{is often the case}} that in a given program, a predicate is used with some of its arguments used consistently as input arguments and others as output arguments. Such mode information can be used by a compiler to effect various optimizations. This paper considers the problem of automatically inferring the modes of the predicates in a program. The dataflow analysis we use is more powerful than approaches relying on syntactic characteristics of programs, e. g. [18]. Our work differs from that of Mellish [14, 15] in that (i) we give a sound and efficient treatment of variable aliasing in mode inference; (ii) by propagating instantiation information using state transformations rather than through dependen [...] ...|$|E
40|$|AbstractIn general, logic {{programs}} are undirected, i. e., {{there is no}} concept of “input” and “output” arguments to a procedure. An argument may be used either as an input or as an <b>output</b> <b>argument,</b> and programs may be executed either in a “forward” direction or in a “backward” direction. However, it {{is often the case}} that in a given program, a predicate is used with some of its arguments used consistently as input arguments and others as output arguments. Such mode information can be used by a compiler to effect various optimizations. This paper considers the problem of automatically inferring the models of the predicates in a program. The dataflow analysis we use is more powerful than approaches relying on syntactic characteristics of programs. Our work differs from that of Mellish in that (1) we give a sound and efficient treatment of variable aliasing in mode inference; (2) by propagating instantiation information using state transformations rather than through dependencies between variables, we achieve greater precision in the treatment of unification, e. g. through =/ 2; and (3) we describe an efficient implementation based on the dynamic generation of customized mode interpreters. Several optimizations to improve the performance of the mode inference algorithm are described, as are various program optimizations based on mode information...|$|E
40|$|Modes were {{introduced}} in logic programming to differentiate the input arguments of a predicate from its <b>output</b> <b>arguments.</b> This information {{can be used for}} verifying the most diverse properties of logic programs notably absence of run-time errors and absence of dead-locks in presence of delay declarations. We introduce here layered modes, an extension of existing mode systems which allow us to enlarge the class of programs which can be verified by using modes. In particular, we show that this extension allows us to better handle programs that employ a dynamic selection rule and programs that use incomplete data structures such as difference-lists...|$|R
40|$|Known issues: [URL] version 1. 1. 3 add gtools to Imports bug fix in {{experiment}} {{that did not}} allow parallel spawning on some systems and crashed with empty <b>outputs</b> <b>argument</b> fix minor bugs in sampleModules lots of documentation enhancements, esp. ?inputs and ?outputs add. plotInitialTime and. saveInitialTime arguments to spades() to easily allow turning off plotting and saving more robust inputs and outputs, including extension-based automated outputs, using data. frame instead of data. table allowing lists to be passed for "arguments" allow vectorized n in setColors (# 70), and partial n if named many more unit tests (# 139) other bug fixe...|$|R
5000|$|Every D-Bus message {{consists}} of a header and a body. The header is formed by several fields that identifies the type of message, the sender, {{as well as information}} required to deliver the message to its recipient (destination bus name, object path, method or signal name, interface name, etc.). The body contains the data payload that the receiver process interprets [...] - for instance the input or <b>output</b> <b>arguments.</b> All the data is encoded in a well known binary format called the wire format which supports the serialization of various types, such as integers and floating-point numbers, strings, compound types, and so on, also referred to as [...] marshaling.|$|R
40|$|Abstract: In general, logic {{programs}} are undirected, i. e. {{there is no}} concept of ‘‘input’ ’ and ‘‘output’’ arguments to a procedure. An argument may be used either as an input or as an <b>output</b> <b>argument,</b> and programs may be executed either in a ‘‘forward’ ’ direction or in a ‘‘backward’ ’ direction. However, it {{is often the case}} that in a given program, a predicate is used with some of its arguments used consistently as input arguments and others as output arguments. Such mode information can be used by a compiler to effect various optimizations. This paper considers the problem of automatically inferring the modes of the predicates in a pro-gram. The dataflow analysis we use is more powerful than approaches relying on syntactic characteristics of programs, e. g. [18]. Our work differs from that of Mellish [14, 15] in that (i) we give a sound and efficient treatment of variable aliasing in mode inference; (ii) by propagating instantiation information using state transformations rather than through dependencies between variables, we achieve greater preci-sion in the treatment of unification, e. g. through =/ 2; and (iii) we describe an efficient implementation based on the dynamic generation of customized mode interpreters. Several optimizations to improve the performance of the mode inference algorithm are described, as are various program optimizations based on mode information...|$|E
40|$|Abstract. Abstract argumentation {{frameworks}} (AFs) {{are one of}} {{the central}} formalisms in AI; equipped {{with a wide range of}} semantics, they have proven useful in several application domains. We contribute to the systematic analysis of semantics for AFs by connecting two recent lines of research – the work on input/output frameworks and the study of the expressiveness of semantics. We do so by considering the following ques-tion: given a function describing an input/output behaviour by mapping extensions (resp. labellings) to sets of extensions (resp. labellings), is there an AF with designated input and <b>output</b> <b>arguments</b> realizing this function under a given semantics? For the major semantics we give exact characterizations of the functions which are realizable in this manner. ...|$|R
40|$|We {{address the}} task of annotating images with {{semantic}} tuples. Solving this problem requires an algorithm which is {{able to deal with}} hundreds of classes for each argument of the tuple. In such contexts, data sparsity becomes a key challenge, as there will be a large number of classes for which only a few examples are available. We propose handling this by incorporating feature representations of both the inputs (images) and <b>outputs</b> (<b>argument</b> classes) into a factorized log-linear model, and exploiting the flex-ibility of scoring functions based on bilinear forms. Ex-periments show that integrating feature representations of the outputs in the structured prediction model leads to bet-ter overall predictions. We also conclude that the best out-put representation is specific for each type of argument. ...|$|R
40|$|We {{present a}} library of {{routines}} whose main goal is {{to read and write}} exchange-able files (NetCDF file format) storing electronic structure and crystallographic information. It is based on the specification agreed inside the European Theoreti-cal Spectroscopy Facility (ETSF). Accordingly, this library is nicknamed ETSF IO. The {{purpose of this article is}} to give both an overview of the ETSF IO library and a closer look at its usage. ETSF IO is designed to be robust and easy to use, close to Fortran read and write routines. To facilitate its adoption, a complete documenta-tion of the input and <b>output</b> <b>arguments</b> of the routines is available in the package, as well as six tutorials explaining in detail various possible uses of the library routines. PACS: 70; 71. 15. Mb; 7...|$|R
5000|$|The utility reads a byte stream {{from its}} {{standard}} input and writes the result {{to the standard}} <b>output.</b> As <b>arguments,</b> it takes two sets of characters (generally of the same length), and replaces occurrences {{of the characters in}} the first set with the corresponding elements from the second set. For example, ...|$|R
40|$|Site editors {{roam the}} Web for new facts � may {{discover}} further links while roaming � They update the site manually � And the site gets soon out-of-date Presented by Herbert Van de Sompel at TICER 2010, Tilburg, The NetherlandsHow to build such a site 2. � Editors roam the Web for new data published on Web sites � “Scrape ” the sites {{with a program}} to extract the information � Ie, write some code to incorporate the new data � Easily get out of date again… Presented by Herbert Van de Sompel at TICER 2010, Tilburg, The NetherlandsHow to build such a site 3. � Editors roam the Web for new data via APIs � Understand those… � input, <b>output</b> <b>arguments,</b> datatypes used, etc � Write some code to incorporate the new data � Easily get out of date again...|$|R
5000|$|FIGlet {{can read}} from {{standard}} input or accept a message {{as part of}} the command line. It prints to standard <b>output.</b> Some common <b>arguments</b> (options) are: ...|$|R
5000|$|One {{common use}} {{is to provide}} custom error {{messages}} in failed assertions. This is done by passing a parenthesized expression list to the [...] macro, where the first expression is an error string and the second expression is the condition being asserted. The [...] macro <b>outputs</b> its <b>argument</b> verbatim on an assertion failure. The following is an example: ...|$|R
40|$|SLDNF-resolution is {{complete}} for allowed programs and allowed queries. But {{the condition of}} allowedness is very stringent and excludes many common Prolog constructs. We show that allowedness is a special case of a more general principle. We show that if the clauses of a normal program are correct with respect to an input/output specification then SLDNFresolution {{is complete}} for it. An input/output specification assigns to every predicate a set of positive {{and a set of}} negative mode specifications. A mode specification declares the arguments of predicates as input <b>arguments,</b> <b>output</b> <b>arguments</b> or normal arguments. Positive modes are used in positive calls and negative modes are used in negative calls. Definite programs together with definite goals, allowed programs together with allowed goals and many programs and goals used in practice are correct with respect to some input/output specification. Therefore our results imply that the three-valued Fitting/Kunen completion is the right declarative semantics for negation as failure. Keywords: Logic programming, negation as failure, SLDNF-resolution, completion of programs, three-valued logic. ...|$|R
40|$|Recently {{researches}} {{in natural}} language processing are developed because of a rapid progress in software and hardware. Especially, the appearance of programming language Prolog makes remarkable improvements {{in the field of}} rule repetitive application. The authors have recently constructed an experimental machine translation system named BIJET (____directional J____apanese E____nglish T____ranslation system). This system consists of three parts : a Japanese processor, a English processor and a transfer processor. Both Japanese and English processors are divided into a morphological analyser, a morphological synthesizer and a syntactic processor. A transfer processor is divided into a Japanese-English transfer processor and a English-Japanese one. BIJET is programmed in Prolog and Lisp. Especially the syntactic processors are written only by Prolog. These processors can be used as both analyser and synthesizer, because the input and <b>output</b> <b>arguments</b> of a Prolog statement {{do not have to be}} distinguished in advance. This paper discusses the general performance of BIJET and gives the details of its English processor...|$|R
5000|$|... instructs {{the system}} {{how to do}} tabling on , where , called a {{cardinality}} limit, is an integer which limits the number of answers to be tabled, and each [...] is a mode which can be , , [...] (input), or [...] (<b>output).</b> An <b>argument</b> with the mode [...] or [...] {{is assumed to be}} output. If the cardinality limit [...] is , it can be omitted with the preceding [...]|$|R
40|$|We {{describe}} {{a pilot study}} in using argumentation frameworks obtained from an online debate to evaluate positions expressed in the debate. This pilot study aims at exploring the richness of Computational Argumentation methods and techniques for evaluating arguments to reason with the <b>output</b> of <b>Argument</b> Mining. It uses a hand-generated graphical representation of the debate as an intermediate representation from which argumentation frameworks can be extracted, but richer than any existing argumentation framework. The intermediate representation can provide insights for benchmark sets derived from online debates...|$|R
40|$|Intuitively speaking, “self-programming ” {{means the}} ability for a {{computer}} system to program its own actions. This notion is clearly related to Artificial Intelligence, and {{has been used by}} many researchers. Like many other high-level concepts, however, scrutiny shows that the term can be interpreted in several different ways. To make the discussion concrete and meaningful we introduce here a working definition of self-programming. In this definition we increase its concreteness while trying to keep the intuitive meaning of the concept. The activities of a computer system usually are considered to consist of atomic actions (which can also be called instructions, operations, behavior, or something else in different contexts). At any given moment the system’s primitive actions are in a finite and constant set A, meaning that they are distinct from each other, and can be enumerated. An action may take some input arguments, and produce some <b>output</b> <b>arguments.</b> The system can execute each of its actions, This work is licensed under the Creative Commons Attribution 3. 0 License. THÓRISSON ET AL as long as certain conditions are satisfied. When executed, an action produces certain effects in the system and the outside world. A program refers to a structure of actions to be executed (a) in the future (a “plan ” plu...|$|R
40|$|This text is a {{reply to}} E. A. J. Honigmann and {{presents}} {{another point of}} view on Shakespeare’s Catholicism. H. Hammerschmidt-Hummel defends her thesis and tries to convince that her book is based on reliable studies and historical sources. She proves that a secret Catholic code in his plays is the most important key to understanding his whole <b>output.</b> Her <b>arguments</b> are based on two evidences: the known or presumed “Catholic sympathies” of the dramatist’s family, friends and patrons and the “Catholic attitudes” embedded in the plays. </span...|$|R
40|$|In this lecture {{we discuss}} another logic program analysis, namely verifying the {{progress}} property. Progress guarantees that a predicate can never fail for arbitrary values of its input arguments. Together with termination this guarantees that a predicate is total in its given input arguments. As sketched {{in the previous}} lecture, this an important piece in the general technique of verifying properties of logic programs by reasoning about proof terms. 19. 1 The Progress Property Progress in general just says that during the execution of a program we have either finished computation with a value, or {{we can make a}} further step. In particular, computation can never “get stuck”. In logic programming this translates to saying the computation can never fail. This requires an understanding of the intended input and <b>output</b> <b>arguments</b> of a predicate, as well as the domain on which it is to be applied. Returning to the well-worn example of addition, plus(z,N,N). plus(s(M),N,s(P)) ← plus(M,N,P). the plus predicate is total in the first two arguments, assuming they are natural numbers. It is not total in the first and third argument, because a query such as plus(s(z),N,z) will fail. Totality decomposes into two subquestions, namely progress and termination, since we always assume the program is well-typed and well-moded. Termination is easy to see here because th...|$|R
40|$|A robust MPC {{algorithm}} {{solving the}} tracking and the infeasible reference problems for constrained systems subject to bounded disturbances {{is presented in}} this paper. The proposed solution relies on three main concepts: (1) the reformulation of the system in the so-called velocity form to obtain offset-free tracking when constant disturbances are present, (2) {{the use of a}} tube-based approach to cope with nonconstant but bounded disturbances, (3) the use of reference <b>outputs</b> as <b>arguments</b> of the optimization problem to cope with infeasible references. Convergence results are derived by suitably defining the auxiliary control law and the terminal set used in the problem formulation...|$|R
40|$|Researchers {{working on}} the {{automatic}} parallelization of programs {{have long known that}} too much parallelism can be even worse for performance than too little, because spawning a task to be run on another CPU incurs overheads. Autoparallelizing compilers have therefore long tried to use granularity analysis to ensure that they only spawn off computations whose cost will probably exceed the spawn-off cost by a comfortable margin. However, this is not enough to yield good results, because data dependencies may also limit the usefulness of running computations in parallel. If one computation blocks almost immediately and can resume only after another has completed its work, then the cost of parallelization again exceeds the benefit. We present a set of algorithms for recognizing places in a program where it is worthwhile to execute two or more computations in parallel that pay attention to the second of these issues as well as the first. Our system uses profiling information to compute the times at which a procedure call consumes the values of its input arguments and the times at which it produces the values of its <b>output</b> <b>arguments.</b> Given two calls that may be executed in parallel, our system uses the times of production and consumption of the variables they share to determine how much their executions would overlap if they were run in parallel, and therefore whether executing them in parallel is a good idea or not. We have implemented this technique for Mercury {{in the form of a}} tool that uses profiling data to generate recommendations about what to parallelize, for the Mercury compiler to apply on the next compilation of the program. We present preliminary results that show that this technique can yield useful parallelization speedups, while requiring nothing more from the programmer than representative input data for the profiling run...|$|R
5000|$|At {{the time}} that Keynes's wrote the General Theory, {{it had been a}} tenet of {{mainstream}} economic thought that the economy would automatically revert to a state of general equilibrium: it had been assumed that, because the needs of consumers are always greater than the capacity of the producers to satisfy those needs, everything that is produced would eventually be consumed once the appropriate price was found for it. This perception is reflected in Say's law [...] and in the writing of David Ricardo, which state that individuals produce so that they can either consume what they have manufactured or sell their output so that they can buy someone else's <b>output.</b> This <b>argument</b> rests upon the assumption that if a surplus of goods or services exists, they would naturally drop in price {{to the point where they}} would be consumed.|$|R
