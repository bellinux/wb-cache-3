4478|1457|Public
5|$|The {{language}} {{is intended to}} be a simple, modern, general-purpose, <b>object-oriented</b> <b>programming</b> language.|$|E
5|$|The class statement, which executes a {{block of}} code and {{attaches}} its local namespace to a class, for use in <b>object-oriented</b> <b>programming.</b>|$|E
5|$|C# is a general-purpose, <b>object-oriented</b> <b>programming</b> language. Its {{development}} team {{is led by}} Anders Hejlsberg. The {{most recent}} version is C# 7.1, which was released in 2017 along with Visual Studio 2017 Update 3.|$|E
40|$|The {{objective}} {{of this study was}} to determine whether the mental representation of <b>object-oriented</b> <b>programs</b> differs from imperative programs for novice programmers. In our study novices who had little or no previous programming experience studied and answered questions about three imperative and three <b>object-oriented</b> <b>programs.</b> The questions targeted information categories making up the program model and the domain model representations of the programs. It was found that there was a sharp contrast between the mental representations of the imperative and <b>object-oriented</b> <b>programs.</b> While the comprehension of the imperative programs was better overall than that of the <b>object-oriented</b> <b>programs,</b> the mental representations of the imperative programs focused on program-level knowledge. On the other hand, the mental representations of the <b>object-oriented</b> <b>programs</b> focused more strongly on domain-level knowledge. The results tend to support the view that language notations differ in how well they support the extraction of various kinds of information. 1...|$|R
40|$|This {{thesis is}} the study of testing <b>object-oriented</b> <b>programs.</b> Aspects of <b>object-oriented</b> <b>programs</b> for which testing {{techniques}} are developed include classes, methods, inheritance, polymorphism, and encapsulation. The application of these techniques are illustrated, and a comparison between traditional testing techniques and object-oriented techniques is also drawn...|$|R
40|$|Traditional information-flow {{analysis}} is mainly based on data-flow and control-flow analysis. In <b>object-oriented</b> <b>program,</b> because of pointer aliasing, inheritance, and polymorphism, information-flow analysis become very complicated. Especially, it is dicult to rely only on normal data and control-flow analysis techniques. some new approaches {{are required to}} analyze the information-flow between components in <b>object-oriented</b> <b>program.</b> In this paper, <b>object-oriented</b> <b>program</b> slicing technique is introduced. By this technique, the amount of information-flow, the width of information-flow and correlation coefficient between components can be computed. Some applications of the information-flow are also discussed and analyzed in this paper...|$|R
5|$|Python is a multi-paradigm {{programming}} language: <b>object-oriented</b> <b>programming</b> {{and structured}} programming are fully supported, and many language features support functional programming and aspect-oriented programming (including by metaprogramming and metaobjects (magic methods)). Many other paradigms are supported via extensions, including design by contract and logic programming.|$|E
5|$|Despite NeXT's limited {{commercial}} success, {{the company}} had a wide-ranging impact on the computer industry. <b>Object-oriented</b> <b>programming</b> and graphical user interfaces became more common after the 1988 release of the NeXTcube and NeXTSTEP, when other companies started to emulate NeXT's object-oriented system. Apple started the Taligent project in 1989, {{with the goal of}} building a NeXT-like operating system for the Macintosh, with collaboration from Hewlett-Packard and IBM.|$|E
5|$|Methods on {{objects are}} {{functions}} {{attached to the}} object's class; the syntax instance.method(argument) is, for normal methods and functions, syntactic sugar for Class.method(instance, argument). Python methods have an explicit self parameter to access instance data, {{in contrast to the}} implicit self (or this) in some other <b>object-oriented</b> <b>programming</b> languages (e.g., C++, Java, Objective-C, or Ruby).|$|E
40|$|We suggest {{and analyze}} a new {{approach}} to make object-oriented software more maintainable. The basic idea is to split an <b>object-oriented</b> <b>program</b> into a class graph and a traversal specification. We call the result an adaptive program. It is straightforward to generate an <b>object-oriented</b> <b>program</b> from an adaptive program. We present an example that indicates that compared to <b>object-oriented</b> <b>programs,</b> adaptive programs are shorter, easier to write, and easier to maintain. The two components of an adaptive program may be incompatible or inconsistent. Incompatibility prevents us from generating an <b>object-oriented</b> <b>program</b> at all, and inconsistency prevents us from generating efficient and compact code. Checking compatibility is easy but checking consistency is non-trivial. We introduce a core language of succinct traversal specifications, we present and prove the soundness of a proof system for conservatively checking consistency, and we give an efficient algorithm for checking if [...] ...|$|R
40|$|An {{extensible}} representation for <b>object-oriented</b> <b>programs,</b> the <b>Object-oriented</b> <b>Program</b> Dependence Graph (OPDG), is presented. The {{representation is}} divided into three layers: a first layer that presents the class inheritance structure, a second layer that combines a traditional control dependence subgraph and a data dependence subgraph with objects, and a third layer that presents the dynamic, runtime aspects of an <b>object-oriented</b> <b>program</b> as an Object Dependence Subgraph. The representation is modular allowing specific tools to only use the portion required for the tool's operation. The complete representation provides information sufficient for most program analysis techniques including data flow analysis, reverse engineering, interactive debuggers and other tools...|$|R
40|$|Abstract. This paper {{presents}} a new rule for reasoning about method calls in <b>object-oriented</b> <b>programs.</b> It concerns an optimized adaptation of Hoare’s rule of {{adaptation to the}} object-oriented paradigm. The new rule contributes in various ways to the modularity of the specification. We also argue that our rule of adaptation is the missing link between Hoare logics and proof outlines for <b>object-oriented</b> <b>programs.</b> ...|$|R
5|$|This {{situation}} improved as COBOL adopted more features. COBOL-74 added subprograms, giving programmers {{the ability}} to control the data each part of the program could access. COBOL-85 then added nested subprograms, allowing programmers to hide subprograms. Further control over data and code came in 2002 when <b>object-oriented</b> <b>programming,</b> user-defined functions and user-defined data types were included.|$|E
5|$|On July 13, 2004, PHP 5 was released, {{powered by}} the new Zend Engine II. PHP 5 {{included}} new features such as improved support for <b>object-oriented</b> <b>programming,</b> the PHP Data Objects (PDO) extension (which defines a lightweight and consistent interface for accessing databases), and numerous performance enhancements. In 2008 PHP 5 became the only stable version under development. Late static binding had been missing from PHP and was added in version 5.3.|$|E
25|$|C# has {{direct support}} for <b>object-oriented</b> <b>programming.</b>|$|E
40|$|This paper {{introduces}} {{the concept of}} Leaner Object-Oriented Slicing, an extension of <b>Object-Oriented</b> <b>Program</b> Slicing [4]. Leaner Object-Oriented Slicing can perform extra code reduction from an object-oriented slice, {{reducing the amount of}} information that a programmer must examine. This paper also provides a discussion on the implementation issues of a Leaner Object-Oriented Slicing based debugging tool. Key words: Software Engineering, <b>Object-Oriented</b> <b>Programs,</b> Debuggin...|$|R
5000|$|An <b>object-oriented</b> <b>program</b> {{structure}} {{in which a}} class serves as the basic unit of decomposition.|$|R
5000|$|<b>Object-Oriented</b> <b>Program</b> Tracing and Visualization. Danny B. Lange and Yuichi Nakamura. IEEE Computer, May 1997.|$|R
25|$|For the <b>object-oriented</b> <b>programming</b> language, see Gello Expression Language.|$|E
25|$|Fully formed <b>object-oriented</b> <b>{{programming}}</b> in the Smalltalk {{programming language}} and integrated development environment.|$|E
25|$|Octave {{programs}} {{consist of}} a list of function calls or a script. The syntax is matrix-based and provides various functions for matrix operations. It supports various data structures and allows <b>object-oriented</b> <b>programming.</b>|$|E
40|$|Abstract — We propose an {{efficient}} technique for slicing <b>object-oriented</b> <b>programs.</b> We use a dependence based intermediate program representation, {{which we have}} named Concurrent System Dependence Graph (CSDG) to represent <b>object-oriented</b> <b>programs.</b> The CSDG is an arcclassified digraph that represents various dependences like synchronization and communication dependences between statements. Our slicing algorithm marks and unmarks the executed nodes of CSDG appropriately during run time...|$|R
40|$|The dynamic {{behavior}} of <b>object-oriented</b> <b>programs</b> {{is difficult to}} design, implement, and modify. Understanding the interactions between classes and objects is necessary to create efficient designs and make safe modifications. This work seeks to identify, visualize, and analyze recurring message patterns in <b>object-oriented</b> <b>program</b> executions {{as a means for}} understanding and examining dynamic behavior. Our visualizations focus on supporting design recovery, validation, and reengineering tasks...|$|R
40|$|A {{number of}} {{proposals}} to manage aliasing in Java-like programming languages have been advanced {{over the last}} five years. It is not clear how practical these proposals are, that is, how well they relate to the kinds of programs currently written in Java-like languages. To address this problem, we analysed heap snapshots from a corpus of Java programs. Our results indicate that <b>object-oriented</b> <b>programs</b> do in fact exhibit symptoms of encapsulation in practice, and that proposed models of uniqueness, ownership, and confinement can usefully describe the aliasing structures of <b>object-oriented</b> <b>programs.</b> Understanding the kinds of aliasing present in programs should help us to design formalisms to make explicit the kinds of aliasing implicit in <b>object-oriented</b> <b>programs...</b>|$|R
25|$|The Common Lisp Object System, CLOS, is an {{integral}} part of ANSI Common Lisp. CLOS descended from New Flavors and CommonLOOPS. ANSI Common Lisp was the first standardized <b>object-oriented</b> <b>programming</b> language (1994, ANSI X3J13).|$|E
25|$|Simonyi {{introduced}} to Microsoft {{the techniques of}} <b>object-oriented</b> <b>programming</b> that he had learned at Xerox. He developed the Hungarian notation convention for naming variables. These standards were originally part of his doctoral thesis. The Hungarian notation has been widely used inside Microsoft.|$|E
25|$|Software reuse {{grew out}} of the {{standard}} subroutine libraries of the 1960s. It is the main principle of today's <b>object-oriented</b> <b>programming.</b> Instead of constantly reinventing software wheels, programming languages like C++, Java, Objective-C, and others are building vast collections of reusable software objects and components.|$|E
40|$|Well-written <b>object-oriented</b> <b>programs</b> exhibit many {{structural}} regularities {{ranging from}} naming and coding conventions, through design patterns, to architectural constraints. Tools and environments that aid a software developer in constructing, understanding or modifying <b>object-oriented</b> <b>programs</b> {{should be able}} to reason about and manipulate such regularities. We codify structural regularities of <b>object-oriented</b> <b>programs</b> as predicates in a logic meta language on top of Smalltalk. These predicates can be used not only to enforce regularities in the software, but also to search the source code, detect violations against certain regularities and to generate code fragments that exhibit a certain regularity. On the basis of two case studies we illustrate how the use of such predicates supports a developer in various activities throughout the software development life-cycle...|$|R
40|$|Various {{methods for}} formal program {{verification}} {{have been around}} for a long time. Hoare logic is one such formalism for verification of imperative programs. When aliasing may occur in the programs, which is usually the case in <b>object-oriented</b> <b>programs,</b> this logic is no longer sound. Some solutions to this problem exist, but there are few that allow high-level reasoning about <b>object-oriented</b> <b>programs,</b> where method- and functioncalls are far more important than low-level manipulation of the objects' components. In this thesis I first give a few examples of low-level solutions to the alias-problem in Hoare logic. Based on one of these, I then introduce a new formalism, designed to be used for high-level reasoning about <b>object-oriented</b> <b>programs</b> using methods and functions rather than low-level manipulation of object-components...|$|R
40|$|The {{classical}} {{view of a}} register-based {{abstract machine}} is a barrier for understanding the execution of <b>object-oriented</b> <b>programs.</b> We visualize program execution based on the object-oriented paradigm with its objects and the message flows between them. For this we propose a visualisation for intuitive understanding of <b>object-oriented</b> based <b>program</b> executions. Three dimensional animated illustrations are created from UML diagrams. We do not visualize explaining an algorithm, but giving a tool to aid the intuitive understanding of <b>object-oriented</b> <b>program</b> execution. Our Java prototype uses an XML structure created by "Together" representing UML diagrams to transform into VRML that can be displayed in web browsers...|$|R
25|$|Founded in 1970 as a {{division}} of Xerox Corporation, PARC has been in large part responsible for such developments as laser printing, Ethernet, the modern personal computer, graphical user interface (GUI) and desktop paradigm, <b>object-oriented</b> <b>programming,</b> ubiquitous computing, amorphous silicon (a-Si) applications, and advancing very-large-scale integration (VLSI) for semiconductors.|$|E
25|$|A GUI toolkit called GTK (GIMP tool kit) was {{developed}} to facilitate the development of GIMP. GTK was replaced by its successor GTK+ after being redesigned using <b>object-oriented</b> <b>programming</b> techniques. The development of GTK+ {{has been attributed to}} Peter Mattis becoming disenchanted with the Motif toolkit GIMP originally used; Motif was used up until GIMP 0.60.|$|E
25|$|C++ {{introduces}} <b>object-oriented</b> <b>programming</b> (OOP) {{features to}} C. It offers classes, which provide the four features commonly present in OOP (and some non-OOP) languages: abstraction, encapsulation, inheritance, and polymorphism. One distinguishing feature of C++ classes compared to classes in other programming languages is support for deterministic destructors, {{which in turn}} provide support for the Resource Acquisition is Initialization (RAII) concept.|$|E
40|$|When an {{expression}} {{refers to a}} memory location that is referred to by another expression, we {{say that there is}} an alias relation between those expressions. Alias analysis, i. e, the extraction of such relations is essential for efficient maintenance of <b>object-oriented</b> <b>programs.</b> Although many researchers have already proposed analysis methods and implemented pro-totype tools for <b>object-oriented</b> <b>programs,</b> difficulties still remain in applying such methods to practical tools in the sense of precision, extensibility, and scalability. Focusing mainly on prac-tical implementation, we propose an alias analysis method for <b>object-oriented</b> <b>programs.</b> This method employs a two-phase, on-demand, instance-based, and extensible algorithm. We have implemented the proposed method as JAAT. JAAT can analyze large programs such as Java Developer’s Kit (JDK) class library. We have applied JAAT to various large Java programs and confirmed JAAT’s performance...|$|R
40|$|The dynamic {{behavior}} of <b>object-oriented</b> <b>programs</b> {{is difficult to}} design, implement, and modify. Understanding the interactions between classes and objects is necessary to create efficient designs and make safe modifications. This work seeks to identify, visualize, and analyze recurring message patterns in <b>object-oriented</b> <b>program</b> executions {{as a means for}} understanding and examining dynamic behavior. Our visualizations focus on supporting design recovery, validation, and reengineering tasks. Keywords: software visualization, <b>object-oriented</b> <b>programs,</b> program understanding, software reengineering 1 Addressing Problems of OO Dynamics The importance of dynamic behavior in the design and implementation of object-oriented (OO) systems cannot be over-emphasized. Object-oriented analysis and design techniques (OOA/D) that evolve around object models created from static problem statements or object decomposition of real-world systems must not avoid the dynamic issues. Usage-scenario based a [...] ...|$|R
40|$|On {{the basis}} of {{analyzing}} the defects that traditional system dependence graph have, a novel method based on ripple effect is proposed to construct coarse-grained system dependence graph. The method perfects <b>object-oriented</b> <b>program</b> semantics and reduces the computation complexity through expanding the signification of coarse-grained and analyzing ripple effect. <b>Object-oriented</b> <b>program</b> semantics are described in detail. The algorithms for analyzing ripple effects and constructing system dependence graph are designed. Furthermore the computation complexity of algorithms is analyzed to validate effectiveness. </em...|$|R
