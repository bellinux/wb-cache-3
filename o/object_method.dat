57|4102|Public
50|$|An action {{refers to}} the suite of rules and {{policies}} associated with a state machine state, and is represented as an <b>object</b> <b>method.</b>|$|E
5000|$|... public class AnotherActiveObject { private double val; [...] // {{container}} for tasks // decides which request to execute next [...] // asyncMode=true means our worker thread processes its local task queue in the FIFO order [...] // only single thread may modify internal state private final ForkJoinPool fj = new ForkJoinPool(1, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true); [...] // implementation of active <b>object</b> <b>method</b> public void doSomething (...) throws InterruptedException { fj.execute( [...] (...) -> {val = 1.0;}); } [...] // implementation of active <b>object</b> <b>method</b> public void doSomethingElse (...) throws InterruptedException { fj.execute( [...] (...) -> {val = 2.0;}); }} ...|$|E
5000|$|IDEF4 uses an {{object-oriented}} design method or procedure {{that is very}} similar to Rumbaugh’s <b>Object</b> <b>Method</b> Technique and Schlaer/Mellor’s Object-Oriented Analysis and Design (OOA/OOD) technique. However, there are some crucial differences: ...|$|E
5000|$|Extended support, {{access to}} {{internal}} <b>objects,</b> <b>methods</b> and properties, for the following: ...|$|R
5000|$|<b>Object</b> <b>methods</b> {{can change}} the {{reference}} used to access them with the [...] keyword.|$|R
5000|$|Railo allows using <b>object</b> <b>methods.</b> So {{instead of}} using arrayAppend(arr, [...] "value") one can write: arr.append("value").append("anotherValue").|$|R
50|$|The RPC {{facilities}} of {{the cross}} platform serialization protocol, Cap'n Proto amount to a distributed object protocol. Distributed <b>object</b> <b>method</b> calls can be executed(chained, in a single network request, if needs be) through interface references/capabilities.|$|E
5000|$|If you {{omit the}} [...] "of object" [...] postfix, the {{reference}} {{can only be}} used on procedures and functions on unit level. The compiler does not allow you to reference an <b>object</b> <b>method</b> without [...] "of object" [...] being clearly defined.|$|E
5000|$|All {{the classes}} inherit a basic hash scheme from the {{fundamental}} base class java.lang.Object, but instead many override this {{to provide a}} hash function that better handles their specific data. Classes which provide their own implementation must override the <b>object</b> <b>method</b> public int hashCode (...) [...]|$|E
50|$|Both {{overloads}} and overrides {{are provided}} for and <b>object's</b> <b>methods.</b> A method {{that will be}} overridden must be indicated as virtual.|$|R
5000|$|... 1997. [...] "Why explore <b>object</b> <b>methods,</b> patterns, and architectures?" [...] with Ralph Johnson. In: IEEE Software. Vol. 14, no. 1, pp. 27-29.|$|R
50|$|Jeroo is a {{cross-platform}} educational {{tool for}} learning {{object oriented programming}} concepts. In particular, the program helps learning concepts such as <b>objects,</b> <b>methods</b> and basic control structures.|$|R
50|$|Bogus {{isolates}} objects while {{unit testing}} i.e., {{it does not}} require any information of classes or objects involved in testing <b>object</b> <b>method,</b> whereas Rspec Mocks require additional information regarding objects used in testing object. One major advantage of using bogus over Rspec Mocks is that Bogus provides safe stubbing.|$|E
50|$|In {{object-oriented}} programming, {{dynamic dispatch}} selects an <b>object</b> <b>method</b> at runtime, though whether the actual name binding is done at compile time or run time {{depends on the}} language. De facto dynamic scoping is common in macro languages, which do not directly do name resolution, but instead expand in place.|$|E
5000|$|In most {{programming}} languages a called {{method is}} executed synchronously, i.e. in {{the thread of}} execution from which it is invoked. If the method {{takes a long time}} to complete, e.g. because it is loading data over the internet, the calling thread is blocked until the method has finished. When this is not desired, it is possible to start a [...] "worker thread" [...] and invoke the method from there. In most programming environments this requires many lines of code, especially if care is taken to avoid the overhead that may be caused by creating many threads. AMI solves this problem in that it augments a potentially long-running ("synchronous") <b>object</b> <b>method</b> with an [...] "asynchronous" [...] variant that returns immediately, along with additional methods that make it easy to receive notification of completion, or to wait for completion at a later time.|$|E
40|$|We {{present an}} {{approach}} to decomposing legacy systems written in procedural languages into objects. The identification of the objects is centred around persistent data scores, such as files or tables in the database, while programs and subroutines are candidate to implement <b>object</b> <b>methods.</b> The approach proposed for assigning programs and subroutines as <b>object</b> <b>methods</b> exploits <b>object</b> oriented design metrics. The rationale behind this choice is that any object oriented decomposition of a legacy system should {{not lead to a}} poor design, as this would make the reengineered system more difficult to maintai...|$|R
50|$|Claris CAD uses {{a drawing}} system defined by Tools, Methods, and Modifiers. Tools draw <b>objects,</b> <b>methods</b> allow {{different}} ways of drawing with the tools, and modifiers help to position objects.|$|R
50|$|In 1991, Statistical Models in S (1991 White Book) was published, which {{introduced}} {{the use of}} formula-notation (which use the '~' operator), data frame objects, and modifications {{to the use of}} <b>object</b> <b>methods</b> and classes.|$|R
3000|$|... 1 {{in class}} java.lang.reflect.Method (in short, Method) [23, 24]. As stated above, when we hook a {{specific}} API, we replace the API call {{with a call}} to its corresponding wrapper function. We name the invoke (...) API’s wrapper as wrapper invoke. In wrapper invoke, we check whether the function being invoked by reflection is the critical sensor-related API, i.e., the listener registration function regsiterListener (...) in SensorManager. In specific, when wrapper invoke is called, besides the invoke (...) API’s original parameters, a Method object (say <b>object</b> <b>method)</b> is also passed to wrapper invoke, which represents the method being invoked. From <b>object</b> <b>method,</b> we can retrieve the class name and method name of the method being invoked (with APIs like getDeclaringClass (...) and getName (...) [24]) and then check whether the class name is SensorManager and the method name is regsiterListener (...) [...]. If they are, then we invoke wrapper reg instead of the original registration function.|$|E
40|$|There is a {{difference}} in how Danish and Chinese people group <b>object,</b> <b>method</b> and concepts into categories. Difference in these points affect the information structure in applications, which involve menus, links and directories. This study involves groups from Chinese and Danish cultures and investigates how these two cultures group cards into different categories and how their cultural backgrounds affect the structure of their categories. Card Sort, Information Structure, Cultural Difference and Usability. na...|$|E
40|$|Abstract. This paper {{introduces}} a general multi-layer storage structure. Object instances from geographic surface objects are transferred and stored into the standard structure. We introduce some new access control rules {{to modify the}} BLP model, so that the owner can process unrestrictedly an object that is created by the owner. When a process needs {{to decide whether to}} execute an <b>object</b> <b>method,</b> it calculates using the object instance the security level and information flow direction. Key words. Spatial databases, Object-relational data structure, Discretionary Access Control, Mandatory Access Control. ...|$|E
5000|$|Liu’s {{research}} interests in early 2000s {{have been in}} the field of [...] "requirements studies, information systems analysis and design, <b>object</b> <b>methods</b> for systems engineering, normative modelling of software agents, e-commerce systems, digital strategy and leadership." ...|$|R
5000|$|One-to-one request-response: This {{is the way}} for {{a client}} to invoke an <b>object's</b> <b>method.</b> The client sends a message to the service process {{exporting}} the object, and the service in turn replies with a message back to the client process. The message sent by the client must contain the object path, the name of the invoked method (and optionally the name of its interface), and the values of the input parameters (if any) as defined by the object's selected interface. The reply message carries the result of the request, including the values of the output parameters returned by the <b>object's</b> <b>method</b> invocation, or exception information if there was an error.|$|R
50|$|This object {{system is}} {{turned into a}} useful {{programming}} language by complementing it with a functional language describing what each <b>object's</b> <b>methods</b> do. The methods called from the object language are closures running a functional programming language.|$|R
40|$|Church History: Perspectives {{from the}} Nederduitsch Hervormde Kerk van Afrika. The Nederduitsch Hervormde Kerk van Afrika has always {{regarded}} Church Hisory {{as a very}} important part of the theological curiculum. For that reason little attention has been given to metatheological quesions concening the subject, <b>object,</b> <b>method</b> and purpose of Church History. This article examines these questions, applying insights and contributions from several sciences such as Hisory, Philosophy of History, Theory of Science and Theology. This aricle reflects on questions as to why and how Church History can be regarded as a theological disciplin...|$|E
40|$|In {{object-oriented}} technology, some {{concepts are}} so often used {{that people have}} no doubt about their meaning (e. g. class, <b>object,</b> <b>method).</b> This {{is not the case}} when abstraction concerns lead to the use of some conceptual representations such as an object being part of another one. Even the standardized notation UML (Unified Modeling Language [...] version 1. 3) is confusing in some of its definitions. In this paper, we use the benefits from a formal definition for the semantics of the Whole-Part relationship to improve the metamodel used in the UML. The ai...|$|E
40|$|This paper {{addresses}} Object-Oriented (OO) system complexity at the application, <b>object,</b> <b>method,</b> {{and variable}} levels. At each level measures are proposed {{to account for}} the cohesion and coupling aspects of the system. OO system complexity at each level is presented {{as a function of the}} measurable characteristics such as fan-in, fan-out, number of I/O variables, fan-up, fan-down, and polymorphism. Each measure is defined with adherence to the principles that measures must be intuitive and that they must be applicable to all phases of the OO development life cycle. I...|$|E
50|$|Accessor {{methods are}} used to read data values of an <b>object.</b> Mutator <b>methods</b> {{are used to}} modify the data of an <b>object.</b> Manager <b>methods</b> are used to {{initialize}} and destroy objects of a class, e.g. constructors and destructors.|$|R
40|$|Invariant object {{localization}} {{is one of}} {{the challenging}} tasks in computer vision research. In this paper we present a robust rotation and scale invariant <b>object</b> recognition <b>method.</b> A local Gabor filter space is treated as the core of this method. Image rotation and scaling operations were transformed into shift operations along the Gabor filter space dimensions. This property enables efficient scale and rotation estimation. The Gabor filter space allows a comparison of local environments and is used as the basis of the invariant <b>object</b> recognition <b>method.</b> After introducing the basics of the <b>object</b> localization <b>method,</b> two examples are shown. The examples clarify the potentialities of the <b>object</b> recognition <b>method</b> and show its flexibility and robustness...|$|R
50|$|The actual {{implementation}} of the Storable is generated at runtime by Carbonado itself. The standard <b>object</b> <b>methods</b> of toString, equals and hashCode are also generated. This greatly simplifies the process of defining new entities, since no boilerplate code needs to be written.|$|R
40|$|This study aims at {{automatic}} {{construction of}} cell lineage from time-lapse images of progenitor cells. In {{order to construct}} the cell lineage it is very useful to have an efficient cell tracking system. In this paper we have described a system for tracking neural progenitor cells in a sequence of images using multiple matching <b>object</b> <b>method</b> based on modified mahalanobis algorithm. This system produces the results including the position, shape, motility and ancestry of each cell in every frame, which helps in construction of cell lineage. The proposed method has been implemented to the sequence of image frames and the computational results of cell tracking are presented...|$|E
40|$|Writing {{programs}} in continuation-passing style {{is a good}} tool for understanding reified continuations and call/cc. Similarly, writing {{programs in}} an object-oriented style is a good tool for understanding object-oriented language features, such as super (or <b>object)</b> <b>method</b> invocation. We present an object-oriented style and a simple example of its use. From this example, we present protocols that make this style more natural. We then enforce the style and protocols by introducing a macro per class. These macros are macrogenerating macros that package the syntactic redundancy of the style, approximating a compiler for a conventional object-oriented language. Exercises are scattered throughout to help the energetic reader develop {{a deeper understanding of}} the paper's concepts...|$|E
40|$|In this paper, {{we propose}} the new fast {{calculation}} method of computer generated cylindrical hologram and report experimental results of three-dimensional image reconstruction. Conventionally, {{it takes a}} huge amount of time to compute cylindrical hologram data, because it is based on a point-light <b>object</b> <b>method.</b> On the contrary, the proposed method is based on the angular spectrum of plane wave and Fast Fourier Transform (FFT) algorithm. By using the method, computation time of the hologram data becomes 500 times faster than conventional methods. We made holograms by this proposed method and performed optical image-reconstruction experiments. The results of optical experiments make clear that the hologram has the full-parallax three-dimensional image that has ”look around property”. 1...|$|E
50|$|Engineers and {{scientists}} have performed {{various kinds of}} research to investigate the possibility of finding ways to create real optical invisibility (cloaks) for <b>objects.</b> <b>Methods</b> are typically based on implementing the theoretical techniques of transformation optics, which {{have given rise to}} several theories of cloaking.|$|R
30|$|In [4 – 11], {{the authors}} {{presented}} several Kalman filter (KF)-based <b>object</b> tracking <b>methods.</b> Extended Kalman filter (EKF)-based <b>object</b> tracking <b>method</b> is proposed in [12]. The unscented Kalman filter (UKF) is applied for visual contour tracking in [13] and object tracking in [14]. In terms of object tracking in a VSN, the cubature Kalman filter (CKF) is primarily applied {{in our previous}} work [15]. In [16 – 24], the authors presented particle filter (PF)-based object tracking. The <b>object</b> tracking <b>methods</b> based on these conventional Bayesian filters have a varying degree of complexity and accuracy.|$|R
40|$|The {{correction}} of atmospheric effects is very essential because visible bands of shorter wavelength are highly affected by atmospheric scattering especially of Rayleigh scattering. The {{objectives of the}} paper {{is to find out}} the haze values present in the all spectral bands and to correct the haze values for urban analysis. In this paper, Improved Dark <b>Object</b> Subtraction <b>method</b> of P. Chavez (1988) is applied for the {{correction of}} atmospheric haze in the Resoucesat- 1 LISS- 4 multispectral satellite image. Dark object Subtraction is a very simple image-based method of atmospheric haze which assumes that there are at least a few pixels within an image which should be black (% reflectance) and such black reflectance termed as dark object which are clear water body and shadows whose DN values zero (0) or Close to zero in the image. Simple Dark <b>Object</b> Subtraction <b>method</b> is a first order atmospheric correction but Improved Dark <b>Object</b> Subtraction <b>method</b> which tends to correct the Haze in terms of atmospheric scattering and path radiance based on the power law of relative scattering effect of atmosphere. The haze values extracted using Simple Dark <b>Object</b> Subtraction <b>method</b> for Green band (Band 2), Red band (Band 3) and NIR band (band 4) are 40, 34 and 18 but the haze values extracted using Improved Dark <b>Object</b> Subtraction <b>method</b> are 40, 18. 02 and 11. 80 for aforesaid bands. Here it is concluded that the haze values extracted by Improved Dark <b>Object</b> Subtraction <b>method</b> provides more realistic results than Simple Dark <b>Object</b> Subtraction <b>method...</b>|$|R
