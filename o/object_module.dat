51|318|Public
50|$|Each {{programming}} language {{used in a}} computer shop will have an associated compiler that translates a source program into a machine-language <b>object</b> <b>module.</b> Then the <b>object</b> <b>module</b> from the compiler must be processed by the linkage editor, IEWL, to create an executable load module.|$|E
5000|$|Output formats: Binary, Intel HEX, OMF51 <b>Object</b> <b>Module</b> Format ...|$|E
5000|$|Yasm lacks Relocatable <b>Object</b> <b>Module</b> Format (OMF) object support.|$|E
50|$|Since version 6.1, MASM is able {{to produce}} <b>object</b> <b>modules</b> in the Portable Executable (PE/COFF) format. PE/COFF is {{compatible}} with recent Microsoft C compilers, and <b>object</b> <b>modules</b> produced by either MASM or the C compiler can be routinely intermixed and linked into Win32 and Win64 binaries.|$|R
50|$|A CO-OPN {{specification}} {{consists of}} a collection of two different modules: the abstract data type <b>modules</b> and the <b>object</b> <b>modules.</b> The abstract data type modules concern the data structure component of the specifications, and many sorted algebraic specifications are used when describing these <b>modules.</b> Furthermore, the <b>object</b> <b>modules</b> represent the concept of encapsulated entities that possess an internal state and provide the exterior with various services. For this second sort of modules, an algebraic net formalism has been adopted. Algebraic Petri nets, a kind of high level nets, are a great improvement over the Petri nets, i.e. Petri nets tokens are replaced with data structures which are described by means of algebraic abstract data types. For managing visibility, both abstract data type <b>modules</b> and <b>object</b> <b>modules</b> are composed of an interface (which allows some operations to be visible from the outside) and a body (which mainly encapsulates the operations properties and some operation which are used for building the model). In the case of the <b>objects</b> <b>modules,</b> the stateand the behavior of the objects remain concealed within the body section.|$|R
50|$|Early {{versions}} of MASM generated <b>object</b> <b>modules</b> using the OMF format, {{which was used}} to create binaries for MS-DOS or OS/2.|$|R
5000|$|The Relocatable <b>Object</b> <b>Module</b> Format (OMF) is {{an object}} file format used {{primarily}} for software intended {{to run on}} Intel 80x86 microprocessors. It was originally developed by Intel under the name <b>Object</b> <b>Module</b> Format, and is perhaps best known to DOS users as an [...]OBJ file. It has since been standardised by the Tool Interface Standards Committee.|$|E
5000|$|The Relocatable <b>Object</b> <b>Module</b> Format, however, was {{designed}} to require minimal memory when linking, and consists {{of a series of}} records that have the following format: ...|$|E
50|$|Materials held within special {{collections}} (manuscripts, photos, letters, …) can {{be described}} using the so-called <b>object</b> <b>module,</b> in which these materials are described using specifically tailored metadata schemes.|$|E
5000|$|FakeOS, a {{simulator}} {{that allows}} <b>object</b> <b>modules</b> containing OS/360 SVCs, control blocks, and references to OS/360 access methods to execute under MTS.|$|R
5000|$|Them What Make the Rules and Them What Live the Dream: case/when, while/until, {{variable}} scope, blocks, methods, class definitions, class attributes, <b>objects,</b> <b>modules,</b> introspection in IRB, dup, self, rbconfig module ...|$|R
50|$|NLMs were {{supported}} {{beginning with the}} Intel 80386-based NetWare version 3.x. Prior versions of NetWare had a monolithic kernel, and significant hardware or functionality changes required re-linking the kernel from <b>object</b> <b>modules.</b>|$|R
50|$|Panvalet {{can be used}} {{to manage}} program source code, JCL, and <b>object</b> <b>module</b> files. It {{supports}} granular access controls including check-in and check-out by specific mainframe user IDs.|$|E
50|$|Composition filters {{model were}} applied to {{abstract}} communications among objects. The <b>object</b> <b>module</b> is extended by introducing input and output filters which determine {{what needs to be}} done with received and sent messages.|$|E
50|$|In the 1990s, a {{new record}} type, the XSD record was added to extend {{the use of this}} <b>object</b> <b>module</b> format to {{encompass}} longer module names than 8 characters and to permit mixed-case names, as required by the C programming language.|$|E
40|$|We have‘implemented'a {{software}} package for our IBM 360 / 370 system at SLAC, which we {{use in the}} development of stand alone LSI- 11 software systems. Included in this package are: * XASMll- a cross assembler which handles a substantial subset of MACRO- 11 * PL- 11 - a cross compiler for a structured programming language designed around the PDP- 11 instruction set * FORTRAN- FORTRAN code is compiled under RT: 11, and the <b>object</b> <b>modules</b> are transmitted to the IBM 360 / 370 for translation and integration * XLCVT- a conversion program which takes as input standard DEC DOS/RT- 11 <b>object</b> <b>modules</b> or LIBR files, or <b>object</b> <b>modules</b> produced by PL- 11 and XASMll; it converts them to a form suitable for input to XLINKll * XLINKll- a cross linker which takes in relocatable <b>object</b> <b>modules</b> and outputs a DEC DOS/RT- 11 absolute loader format module, or a format suitable for an IBM 360 / 370 PDP- 11 simulator * REFORM/EPROM- conversion programs which take as input a DEC DOS absolute loader format module generated by XLINKll and convert it to a format suitable for downloading into an LSI- 11 or for burning into EPROM's * XREF- a cross reference program which takes as input a PDS of XLINKll type <b>object</b> <b>modules,</b> and outputs cross reference tables and information on each of the modules * WYLBUR execute files- several files of commands which may be executed from the terminal to create jobs in response to simple prompts * KERNEL- a set of MACRO- 11 and PL- 11 routines which have been burnt into 2708 EPROM's and include a terminal emulator, a down line loader, and several utility routines for the LSI- 11 All of this was accomplished by using the facilities already available on our IBM 3601370 system. Most of this package has been in regular use since Spring 1976, although new features are still being added. The manpower cost of researching, organizing, developing, and integrating the tools has paid off well in terms of programmer productivity, source code readability, accessibility, and integrity...|$|R
50|$|After preprocessing, at {{the highest}} level a C program {{consists}} of a sequence of declarations at file scope. These may be partitioned into several separate source files, which may be compiled separately; the resulting <b>object</b> <b>modules</b> are then linked along with implementation-provided run-time support modules to produce an executable image.|$|R
40|$|A set of {{software}} tools for the Motorola M 68000 microprocessor {{was developed to}} run under the UNIX* operating system. A C language cross compiler was created by modifying the UNIX ‘C’ compiler for the PDP- 11. A macro cross assembler was designed and implemented to produce relocatable <b>object</b> <b>modules</b> for the M 68000 in the a. out format of PDP- 11 UNIX <b>object</b> <b>modules.</b> The UNIX loader for the PDP- 11 was changed to allow relocation of 32 -bit quantities {{as required by the}} M 68000. A small set of utility routines was also written to assist in the implementation effort. The language processors and utilities provide the means by which high level ‘C’ programs can produce executable images for the M 68000. All of the programs are currently running on a PDP- 11 / 70 UNIX system...|$|R
50|$|The linker (@LINK) is {{the modern}} linking {{environment}} which combines object modules {{into a new}} <b>object</b> <b>module.</b> It provides both static and dynamic linking capabilities. The most common usage is to combine the object modules of a program statically but to allow dynamic linking to libraries.|$|E
50|$|In {{computing}} object code, {{or sometimes}} an <b>object</b> <b>module,</b> {{is what a}} compiler produces. In a general sense object code is a sequence of statements or instructions in a computer language, usually a machine code language (i.e., binary) or an intermediate language such as register transfer language (RTL).|$|E
50|$|The {{first product}} {{developed}} was a GPIB controller (computing) plug-in {{board for the}} IBM PC. The founders eventually {{came up with the}} idea of creating one or more software development tools for the PC which they could sell to provide working capital. The first such product was PolyLibrarian, an <b>object</b> <b>module</b> library utility, which was introduced in late 1982 and written by Kinzer. At the time, there were few, if any, <b>object</b> <b>module</b> librarians available to PC programmers. In 1983, Polytron introduced PolyMake, an MS-DOS version of the well known Unix make utility, initially written by Perkins. The PolyMake product was followed in 1985 by the Polytron Version Control System (PVCS) (also written by Kinzer), that was loosely based on the RCS change control system authored by Walt Tichy while at Purdue University.|$|E
5000|$|Since {{bytecode}} {{instructions are}} processed by software, {{they may be}} arbitrarily complex, but are nonetheless often akin to traditional hardware instructions: virtual stack machines are the most common, but virtual register machines have been built also. [...] Different parts may often be stored in separate files, similar to <b>object</b> <b>modules,</b> but dynamically loaded during execution.|$|R
40|$|In {{this paper}} we show how {{by means of}} a {{categorical}} framework we can compose systems of concurrent <b>object</b> <b>modules</b> satisfying some interaction rules given by a specification. Module interaction can be either synchronous or asynchronous and both cases are considered separately. The behaviour of <b>object</b> <b>modules</b> is modelled by labelled prime event structures. The category of labelled prime event structures has (co) products. A product in the category of labelled prime event structures is given accordingly to Winskel and Nielsen but denotes parallel composition in a sense that does not have much practical interest. For synchronously communicating modules, by applying to the product a restriction on the allowed life cycles by means of the categorical concept of a functor induced by a co bration and a morphism on labels, we achieve the desired joint behaviour. A way to model asynchronous composition of modules is to construct a coproduct and extend it by their interaction rules. At the end of [...] ...|$|R
40|$|We have {{developed}} a system called OM to explore the problem of code optimization at link-time. OM takes a collection of <b>object</b> <b>modules</b> constituting the entire program, and converts the object code into a symbolic Register Transfer Language (RTL) form {{that can be easily}} manipulated. This RTL is then transformed by intermodule optimization and finally converted back into object form. Although much high-level information about the program is gone at link-time, this approach enables us to perform optimizations that a compiler looking at a single module cannot see. Since <b>object</b> <b>modules</b> are more or less independent of the particular source language or compiler, this also gives us the chance to improve the code in ways that some compilers might simply have missed. To test the concept, we have used OM to build an optimizer that does interprocedural code motion. It moves simple loop-invariant code out of loops, even when the loop body extends across many procedures and the loop con [...] ...|$|R
5000|$|The compilers {{developed}} within ICL share {{a common}} architecture, {{and in some cases}} share components such as code-generators. Many of the compilers used a module named ALICE Language Internal Common Environment and produced an early form of precompiled code (P-Code) termed ROSE, making compiled <b>Object</b> <b>Module</b> Format (OMF) libraries loadable on any machine in the range[...]|$|E
5000|$|... OpenSSL {{is one of}} two {{open source}} {{programs}} to be involved with validation under the FIPS 140-2 computer security standard by the National Institute of Standards and Technology's (NIST) Cryptographic Module Validation Program (CMVP). (OpenSSL itself is not validated, but a component called the OpenSSL FIPS <b>Object</b> <b>Module,</b> based on OpenSSL, was created to provide many of the same capabilities).|$|E
50|$|Compiled {{object code}} is {{maintained}} in a format called OMF (<b>Object</b> <b>Module</b> Format). Unlike {{in many other}} operating systems, {{this is also the}} format used by the loader. Various compilers are available, as well as utilities, notably the Collector, which links the code in several OMF modules into a single module, for more efficient loading at run-time, and the Module Amender, which allows patching of the instructions in an OMF module to fix bugs, using assembly language syntax.|$|E
50|$|A server {{could support}} {{up to four}} network cards, and these could be a mixture of {{technologies}} such as ARCNET, Token Ring and Ethernet. The operating system was provided {{as a set of}} compiled <b>object</b> <b>modules</b> that required configuration and linking. Any change to the operating system required a re-linking of the kernel. Installation also required the use of a proprietary low-level format program for MFM hard drives called COMPSURF.|$|R
50|$|The first C compiler, {{written by}} Dennis Ritchie, used a {{recursive}} descent parser, incorporated specific {{knowledge about the}} PDP-11, and relied on an optional machine-specific optimizer to improve the assembly language code it generated. In contrast, Johnson's pccm {{was based on a}} yacc-generated parser and used a more general target machine model. Both compilers produced target-specific assembly language code which they then assembled to produce linkable <b>object</b> <b>modules.</b>|$|R
40|$|A {{description}} is given of three programs catalogued {{in the form}} of <b>object</b> <b>modules</b> in the library of a system for processing photographic images computer. PFT is the subprogram of the multi-dimensional BPF of real-valued information, in the operative computer memory. INRECO is a subprogram-interface between the real and complex formats for representing two-dimensional spectra and images. FFT 2 is a subprogram for calculating the correlation functions of the image using the previous subprograms...|$|R
50|$|In {{handling}} CBC cipher-suites in SSL, TLS, and DTLS, OpenSSL {{was found}} to be vulnerable to a timing attack which arises during the MAC processing. This was found by Nadhem Alfardan and Kenny Paterson, who published their findings on February 5, 2013. The vulnerability was assigned the CVE identifier CVE-2013-0169. All versions of OpenSSL were affected, and it was only partially mitigated by the use of the OpenSSL FIPS <b>Object</b> <b>Module</b> and the FIPS mode of operation is enabled.|$|E
5000|$|This format {{provides}} for the description of a compiled application's object code, which can be fed to a linkage editor to be made into an executable program, or run directly through an <b>object</b> <b>module</b> loader. It is created by the Assembler or by a programming language compiler. For {{the rest of this}} article, unless a reason for being explicit in the difference between a language compiler and an assembler is required, the term [...] "compile" [...] includes [...] "assemble" [...] and [...] "compiler" [...] includes [...] "assembler." ...|$|E
50|$|Data {{references}} from position-independent code {{are usually}} made indirectly, through global offset tables (GOTs), which store the addresses of all accessed global variables. There is one GOT per compilation unit or <b>object</b> <b>module,</b> {{and it is}} located at a fixed offset from the code (although this offset is not known until the library is linked). When a linker links modules to create a shared library, it merges the GOTs and sets the final offsets in code. It {{is not necessary to}} adjust the offsets when loading the shared library later.|$|E
40|$|Abstract. Type {{systems for}} {{communicating}} processes are typically studied using abstract models – e. g., process algebras – that distill the communication behavior of programs but overlook their structure {{in terms of}} functions, methods, <b>objects,</b> <b>modules.</b> It is not always obvious how to apply these type systems to structured programming languages. In this work we port a recently developed type system that ensures deadlock freedom in the pi-calculus to a higher-order language. ...|$|R
5000|$|The system's Linkage Editor {{application}} is named IEWL. IEWL's main {{function is to}} associate load modules (executable programs) and <b>object</b> <b>modules</b> (the output from, say, assemblers and compilers), including [...] "automatic calls" [...] to libraries (high-level language [...] "built-in functions"), into a format which may be most efficiently loaded by IEWFETCH. There are {{a large number of}} editing options, but for a conventional application only a few of these are commonly employed.|$|R
40|$|Mudflap is a pointer use {{checking}} technology {{based on}} compile-time instrumentation. It transparently adds protective code {{to a variety}} of potentially unsafe C/C++ constructs that detect actual erroneous uses at run time. The class of errors detected includes the most common and annoying types: NULL pointer dereferencing, running off the ends of buffers and strings, leaking memory. Mudflap has heuristics that allow some degree of checking even if only a subset of a program's <b>object</b> <b>modules</b> are instrumented...|$|R
