0|6600|Public
40|$|En Computer-Aided Mechanical Assembly Planning, 81 - 109. Kluwer Academic Publishers, 1991. When {{a set of}} {{kinematic}} constraints {{are imposed}} between several rigid bodies finding out the set of configurations that satisfy all these constraints {{is a matter of}} special interest. The problem is not new and has been discussed, not only in kinematics, but also in the design of <b>object</b> <b>level</b> robot <b>programming</b> languages for assembly tasks. Peer Reviewe...|$|R
40|$|We {{report on}} {{preliminary}} experiments with inferring types for meta programs: programs that manipulate programs. For this purpose we provide a two-level type {{system in a}} fragment of a higher-order system of dependent types. The system is formulated with automatic type inference in mind. In particular, we give a type system for dependent types and a constraint generation procedure which generates semi-unification constraints from untyped terms that have a solution {{if and only if}} the terms have a type annotation in the type system. More interestingly, typability is preserved under reflection, i. e. when <b>object</b> <b>level</b> <b>programs</b> are reflected to the meta-level. 1 Introduction We {{would like to have a}} way to infer that the operations meta programs perform on their objects preserve typability of the objects. Here, we develop type rules and constraint solving techniques for inferring types of such programs. On the surface this may seem as an innocent exercise in extending for instance the Hindley [...] ...|$|R
40|$|We {{propose a}} novel {{approach}} to automating the synthesis of logic programs: Logic programs are synthesized as a by-product of the planning of a verification proof. The approach is a two-level one: At the <b>object</b> <b>level,</b> we prove <b>program</b> verification conjectures in a sorted, first-order theory. The conjectures are of the form 8 args ΓΓΓΓ! : prog(args ΓΓΓΓ!) spec(args ΓΓΓΓ!). At the meta-level, we plan the object-level verification with an unspecified program definition. The definition is represented with a (second-order) meta-level variable, which becomes instantiated {{in the course of}} the planning...|$|R
40|$|The network {{reduction}} systen of RAPT, an offline <b>object</b> <b>level</b> {{language for}} <b>programming</b> robot assembly tasks {{is described in}} this paper. The task description is converted into a relational network with the positions of bodies as nodes, and relationships between positions as links. Rewrite rules based on the intersection and conposition of relations are used to simplify the network. 1 Introduction. As versatile industrial robots come into greater use, particularly for snail batch assembly, the ability to program then offline becomes more desirable. The RAPT language has been develope...|$|R
40|$|We {{propose a}} novel {{approach}} to automating the synthesis of logic programs: Logic programs are synthesized as a by-product of the planning of a verification proof. The approach is a two-level one: At the <b>object</b> <b>level,</b> we prove <b>program</b> verification conjectures in a sorted, first-order theory. The conjectures are of the form ∀a⃗r⃗g⃗s⃗. prog(a⃗r⃗g⃗s⃗) spec(a⃗r⃗g⃗s⃗). At the meta-level, we plan the object-level verification with an unspecified program definition. The definition is represented with a (second-order) meta-level variable, which becomes instantiated {{in the course of}} the planning. This technique is an application of the Clam proof planning system. Clam is currently powerful enough to plan verification proofs for given programs. We show that, if Clam's use of middle-out reasoning is extended, it will also be able to synthesize programs...|$|R
40|$|Over {{the last}} few years several new data models {{together}} with their languages have been developed to meet the increasing requirements of engineering or office applications. A major characteristic of these data models is their ability to process and manage complex objects which the relational model does not provide adequate support for. Whereas the problem of query translation for relational languages has pro-voked broad research activities during the last fifteen years, the analogous problem of translating non-procedural queries on complex <b>objects</b> into lower <b>level</b> <b>programs</b> for efficient execution has received only little attention. This paper tries to reveal the new aspects of query translation and execution on complex objects as com-pared to similar activities when processing flat relations. For this purpose, we investigate the essential concepts necessary to perform compilation, optimization, and execution of queries on complex objects. 1...|$|R
40|$|We {{propose a}} novel {{approach}} to automating the synthesis of logic programs: logic programs are synthesized as a by-product of the planning of a verification proof. The approach is a two-level one: at the <b>object</b> <b>level,</b> we prove <b>program</b> verification conjectures in a sorted, first-order theory. The conjectures are of the form for each #vector#a#vector#r#vector#g#vector#s. prog(#vector#a#vector#r#vector#g#vector#s) spec(#vector#a#vector#r#vector#g#vector#s). At the meta-level, we plan the object-level verification with an unspecified program definition. The definition is represented with a (second-order) meta-level variable, which becomes instantiated {{in the course of}} the planning. This technique is an application of the Clam proof planning system. Clam is currently powerful enough to plan verification proofs for given programs. We show that, if Clam's use of middle-out reasoning is extended, it will also be able to synthesize programs. (orig.) Available from TIB Hannover: RR 1912 (92 - 244) / FIZ - Fachinformationszzentrum Karlsruhe / TIB - Technische InformationsbibliothekSIGLEDEGerman...|$|R
50|$|It {{was soon}} {{realised}} in the Freddy project that the 'move here, do this, move there' style of robot behavior programming (actuator or joint <b>level</b> <b>programming)</b> is tedious and {{also did not}} allow for the robot to cope with variations in part position, part shape and sensor noise. Consequently, the RAPT robot programming language was developed by Pat Ambler and Robin Popplestone, in which robot behavior was specified at the <b>object</b> <b>level.</b>|$|R
40|$|We {{introduce}} an {{object-oriented language}} following a "process algebra" style. The {{idea is to}} define a formalism that enjoys a clean formal definition allowing the reuse of the rich algebraic theory typical of the process algebras in a context where an high <b>level</b> <b>object</b> oriented <b>programming</b> style is preserved. We provide an operational semantics based on a labelled transition system which allows to discuss, e. g., how different notions of equivalence, such as standard and asynchronous bisimulation, {{can be adapted to}} reason about our language. Finally, we illustrate the framework showing that an explicit receive primitive expressing a synchronization constraint or an update operation on the state of an object can be implemented in the language preserving a notion of observation equivalence among objects...|$|R
40|$|In this paper, we {{introduce}} {{an actor}} language following a "process algebra'' style. The {{idea is to}} define a formalism that enjoys a clean formal definition allowing the reuse of standard results {{of the theory of}} concurrency in a context where an high <b>level</b> <b>object</b> oriented <b>programming</b> style is preserved. We provide an operational semantics based on a labelled transition system which allows us to discuss how different notions of equivalence, such as standard and asynchronous bisimulation, map in the actor model. To illustrate the expressive power of the language, we provide an encoding of the asynchronous π-calculus and several programming examples. Finally, we define a simple object oriented notation and we provide a specification of the Hurried Philosophers case study...|$|R
40|$|Abstract — Modelling the {{neuronal}} substrate {{of higher}} cognitive functions is very time consuming. Apart {{from a few}} exceptions, the models are only available in print. The source code behind these models is hardly ever published, {{which means that the}} model has to be re-implemented {{if it is to be}} extended or to be examined in detail. This prevents the creation of really complex models, since it is impossible to build on existing models. Many models share quite a number of characteristics, however, which can be captured by high <b>level</b> <b>object</b> oriented <b>programming</b> languages. Factoring out these characteristics leads to low level components which can be reused in a surprisingly versatile manner. In this paper we present a number of such components, which collectively are called MIIND. We will give examples of their use and will indicate how they could be extended. I...|$|R
40|$|GRALPLA Translator is a {{tool that}} {{translates}} algebraic specification to a high <b>level</b> <b>object</b> oriented <b>programming</b> language (C++). The purpose of this tool is the automatic development of software using formal methods [Gea 97] {{and one of the}} key points is the graphic object specification [Torres 92]. 1. Objectives In this paper we briefly discuss the available tools for the software development using a formal approach with the GRALPLA language. We will focus on the process of software generation from algebraic specifications in GRALPLA to a C++ code. In the next section the use of the tool is explained. A formal verification of properties is given in the translation process, and discussed in the following section. 2. Translation tool Nowadays, there {{is a tool}} that accepts specification in GRALPLA language and produces C++ code. In the translation phase, it checks the syntax and semantic of the specification. The translator can be used as follows. There is an application named: gralpla [...] . ...|$|R
40|$|Handling highly dynamic {{scenarios}} as {{they arise}} in emergency situations requires lots of semantic {{information about the}} situation and an extremely flexible, selforganizing IT infrastructure that provides services {{that can be used}} to manage the situation. We show that a distributed meta level architecture is particularly suited for the implementation of such a self-organizing grid of services. This architecture (SOGOS) distinguishes between an <b>object</b> <b>level</b> and a meta level. The middle ware processes of the grid are running on the <b>object</b> <b>level.</b> The meta level defines an explicitly and declaratively represented dynamic meta model that provides the semantics for the <b>object</b> <b>level</b> processes. Additionally, this level runs processes that plan, supervise and control mobile agents on the <b>object</b> <b>level.</b> The levels are linked together by reflection processes that ensure that relevant changes on the <b>object</b> <b>level</b> are reflected in the meta model and vice versa. The corresponding reflection principles provide the basis for the implementation of the selforganizing mechanisms that govern the overall system...|$|R
50|$|JScript {{support at}} a global and <b>object</b> <b>level.</b>|$|R
2500|$|Nelson and Narens {{proposed}} {{a theoretical framework}} for understanding metacognition and metamemory. In this framework there are two levels: the <b>object</b> <b>level</b> (for example, cognition and memory) and the meta level (for example, metacognition and metamemory). Information flow from the meta <b>level</b> to the <b>object</b> <b>level</b> is called control, and information flow from the <b>object</b> <b>level</b> to the meta level is called monitoring. Both monitoring and control processes occur in acquisition, retention, and retrieval. Examples of control processes are allocating study time and selecting search strategies, and examples of monitoring processes are ease-of-learning (EOL) judgments and FOK judgments.|$|R
40|$|This paper {{describes}} {{the work on}} using vision verification within an <b>object</b> <b>level</b> language for robot assenbly (RAPT). The framework which handles vision data is discussed in detail. The framework enables us to combine a verification vision facility with an <b>object</b> <b>level</b> language in an intelligent way. It can also handle other kinds of sensory data. 1...|$|R
40|$|A novel local {{threshold}} algorithm for {{images with}} poor illumination and complex texture surface {{is presented in}} this paper. This algorithm improves segmentation quality by selecting local thresholds according to <b>object</b> <b>level</b> information incorporating prior knowledge, specifically the solidity features. Local thresholds are searched by maximizing the probability of solidity, and fragments with lower segmentation quality are filtered by the stability of solidity. Since thresholding results are produced with <b>object</b> <b>level</b> information, our algorithm is robust in dealing with images of poor quality. Experiments on oil sand images show the proposed algorithm has superior performance to existing local threshold approaches in terms of segmentation quality. Index Terms — local threshold, solidity, <b>object</b> <b>level</b> information 1...|$|R
5000|$|BIM {{data and}} process {{management}} (accessing and managing BIM models at the <b>object</b> <b>level</b> for project management) ...|$|R
5000|$|In this representation, <b>object</b> <b>level</b> {{variables}} do {{not appear}} explicitly. The constant [...] takes an expression (that is being bound) and a meta-level function [...] → [...] (the body of the let). This function is the higher-order part: an expression with a free variable isrepresented as an expression with holes that are filled in by the meta-level function when applied. As a concrete example, we would construct the <b>object</b> <b>level</b> expression ...|$|R
5|$|The Division of Continuing Education {{offers many}} {{distance}} learning and online degree programs. It offers undergraduate <b>level</b> <b>programs</b> in Chemical Engineering, Civil Engineering, Electrical Engineering and Mechanical Engineering. Graduate <b>level</b> <b>programs</b> like MBA, Applied Economics, Educational Leadership, Forensic Psychology, Social Work, Public Administration and Nursing are offered, {{in addition to}} doctoral <b>level</b> <b>programs</b> in Educational Leadership, Teaching & Learning, and Nursing.|$|R
40|$|A {{proof of}} Gödel’s incompleteness theorem is given. With this new proof a transfinite {{extension}} of Gödel’s theorem is considered. It is shown {{that if one}} assumes the set theory ZFC on the meta level {{as well as on}} the <b>object</b> <b>level,</b> a contradiction arises. The cause is shown to be the implicit identification of the meta <b>level</b> and the <b>object</b> <b>level</b> hidden behind the Gödel numbering. An implication of these considerations is stated...|$|R
5000|$|One level deeper is the <b>Object</b> <b>Level,</b> which scopes on single data objects. The {{optionality}} on {{this level}} is more dynamic.|$|R
40|$|We {{present a}} system, called GETFOL, where, {{for any given}} {{mathematical}} object theory, {{it is possible to}} define a provably correct and complete metatheory MT. Theorem proving in MT can be used to build metatheoretic representations of <b>object</b> <b>level</b> proofs. Within GETFOL, these representations can be executed to prove <b>object</b> <b>level</b> theorems. Mathematical proofs can thus be built by intermixing reasoning in the object theory and reasoning in the metatheory. This provides a very flexible way to mechanize mathematical reasoning...|$|R
2500|$|RMC offers 34 {{graduate}} studies opportunities, including 14 doctorates. In {{addition to the}} Faculty (university) of Arts, Engineering, and Science, the Division of Continuing Studies offers undergraduate and graduate <b>level</b> <b>programs</b> including the [...] "Officer Professional Military Education" [...] program (OPME). The Department of Applied Military Science (AMS) offers a graduate <b>level</b> <b>program</b> – the Land Force Technical Staff Programme (LFTSP) and an undergraduate/community college <b>level</b> <b>program</b> – the Army Technical Warrant Officer's Programme.|$|R
40|$|Three {{important}} {{properties of}} Higher-Order Abstract Syntax are the (higherorder) induction principle, which allows proofs by induction, the (higher-order) injection principle, which asserts that equal terms have equal heads and equal sons, and the extensionality principle, which asserts that functional terms which are pointwise equal are equal. Higher-order abstract syntax is implemented {{for instance in}} the Edinburgh Logical Framework and the above principles are satisfied by this implementation. But although they can be proved at the meta level, they cannot be proved at the <b>object</b> <b>level</b> and furthermore, {{it is not so}} easy to know how to formulate them in a simple way at the <b>object</b> <b>level.</b> We explain here how Second-Order Abstract Syntax can be implemented in a more powerful type system (Coq) {{in such a way as}} to make available or provable (at the <b>object</b> <b>level)</b> the corresponding induction, injection and extensionality principles...|$|R
5000|$|RMC offers 19 {{undergraduate}} {{programs in}} Arts, Science and Engineering.RMC offers 34 graduate studies opportunities, including 14 doctorates. In {{addition to the}} Faculty (university) of Arts, Engineering, and Science, the Division of Continuing Studies offers undergraduate and graduate <b>level</b> <b>programs</b> including the [...] "Officer Professional Military Education" [...] program (OPME). The Department of Applied Military Science (AMS) offers a graduate <b>level</b> <b>program</b> - the Land Force Technical Staff Programme (LFTSP) and an undergraduate/community college <b>level</b> <b>program</b> - the Army Technical Warrant Officer's Programme.|$|R
50|$|Managed code: Memory {{protection}} on <b>object</b> <b>level,</b> {{rather than}} on process level; absence of pointer arithmetic in managed code avoids many problems that are present in unmanaged code.|$|R
40|$|Abstract-We {{propose a}} {{wireless}} sensor network management framework where we consider the management activity as a meta level thread of computation that monitors the lower (<b>object)</b> <b>level</b> protocol related thread of computations and performs management actions to affect the lower level computations. While the protocols perform the <b>object</b> <b>level</b> computations, the management level computations are performed {{by a set of}} rules. In this framework, the wireless network management can not only be tuned for specific applications, but also can be driven by flexible management policies, which can be coded explicitly in the implementation...|$|R
50|$|International {{affairs is}} not a major {{available}} to undergraduate students, although the school does offer a handful of courses open to upper-year students at the Arthur Kroeger College of Public Affairs. The school offers three different Masters <b>level</b> <b>programs,</b> and one PhD <b>level</b> <b>program.</b>|$|R
40|$|Meta-level {{architectures}} {{often are}} used either to model dynamic {{control of the}} <b>object</b> <b>level</b> inferences, or to extend the inference relation of the <b>object</b> <b>level.</b> In [Treur, 1992] we introduced formal semantics for meta-level architectures of the first kind based on temporal models. It may be considered quite natural that for such a dynamic type of reasoning system the temporal element of the reasoning should be made explicit in the formal semantics. For the use of meta-level architectures to extend the <b>object</b> <b>level</b> inference relation the situation looks different. In principle one may work out formal semantics in terms of (the logic behind) this extended, non-classical inference relation; e. g., as in the literature for nonmonotonic logics. However, much discussion is possible about this case. Some papers argue that also {{in the case of}} a non-monotonic logic the semantics have to make the inherent temporal element explicit; approaches are described in, e. g., [Gabbay, 1982], [Engelfriet and Treur, 1993]. In the current paper we adopt this line...|$|R
40|$|Situation Calculus is {{probably}} the most widely studied and used formalism for reasoning about action and change. The main reason for its popularity is the ability to reason about different courses of actions on the <b>object</b> <b>level.</b> In particular, planning can be formulated as an existence problem. This paper shows how these properties break down when incomplete information about the initial state and nondeterministic action effects are introduced, basically because this incompleteness is not manifested on the <b>object</b> <b>level.</b> A version of situation calculus is presented where incompleteness is present on the <b>object</b> <b>level,</b> and the do function for representing state transitions due to actions is replaced by a relation. 1 Introduction Situation Calculus [McCarthy and Hayes, 1969; Reiter, 1991] is a formalism for reasoning about action and change that has been widely studied and applied {{to a wide range of}} problems. Its major strength relative to other formalisms is the possibility to do a la [...] ...|$|R
5000|$|Enhance Support <b>Level</b> <b>Program</b> for Marine Engineering (ESLPME) ...|$|R
50|$|The Petroleum Institute {{also offers}} {{graduate}} <b>level</b> <b>programs.</b>|$|R
5000|$|Ingénieur ENM (ENM Graduate {{engineer}} Masters <b>level</b> <b>program)</b> ...|$|R
5000|$|Ingénieur ICAM (ICAM Graduate {{engineer}} Masters <b>level</b> <b>program)</b> ...|$|R
5000|$|Ingénieur Purpan (Purpan Graduate {{engineer}} Masters <b>level</b> <b>program)</b> ...|$|R
