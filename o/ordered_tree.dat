154|1088|Public
25|$|A {{binary tree}} is a rooted tree {{that is also}} an <b>ordered</b> <b>tree</b> (a.k.a. plane tree) in which every node has at most two children. A rooted tree {{naturally}} imparts a notion of levels (distance from the root), thus for every node a notion of children may {{be defined as the}} nodes connected to it a level below. Ordering of these children (e.g., by drawing them on a plane) makes possible to distinguish left child from right child. But this still doesn't distinguish between a node with left but not a right child from a one with right but no left child.|$|E
25|$|In {{computer}} science, a trie, {{also called}} digital tree and sometimes radix tree or prefix tree (as {{they can be}} searched by prefixes), {{is a kind of}} search tree—an <b>ordered</b> <b>tree</b> data structure that is used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Values are not necessarily associated with every node. Rather, values tend only to be associated with leaves, and with some inner nodes that correspond to keys of interest. For the space-optimized presentation of prefix tree, see compact prefix tree.|$|E
2500|$|C'n is {{the number}} of non-isomorphic ordered trees with n vertices. (An <b>ordered</b> <b>tree</b> is a rooted tree in which the {{children}} of each vertex are given a fixed left-to-right order.) ...|$|E
40|$|We {{describe}} a bijection which maps trivalent <b>ordered</b> <b>trees,</b> representing certain formulae, onto <b>ordered</b> <b>trees.</b> The mapping {{is such that}} an equivalence relation of the type ((ƒ·g) ·h) ((ƒ·h) ·g) {{on the set of}} formulae, induces the equivalence relation of being equal modulo order on the set of <b>ordered</b> <b>trees...</b>|$|R
40|$|AbstractIn {{this paper}} <b>ordered</b> <b>trees</b> are studied {{with respect to}} the inorder traversal. New decompositions of <b>ordered</b> <b>trees</b> are {{introduced}} and used to obtain enumeration results according to various parameters. Furthermore, the set of all <b>ordered</b> <b>trees</b> with prescribed degree sequence according to the inorder is studied with the aid of Dyck paths. This set is constructed and its cardinal number is evaluated recursively...|$|R
40|$|AbstractWe use a known {{combinatorial}} {{argument to}} prove that among all <b>ordered</b> <b>trees</b> {{the ratio of the}} total number of vertices to leaves is two. We introduce a new combinatorial bijection on the set of these trees that shows why this must be so. <b>Ordered</b> <b>trees</b> are then enumerated by number of leaves, total path length, and number of vertices to obtain q-analogs of Catalan numbers. The results on <b>ordered</b> <b>trees</b> are then readily transferred by the skew diagrams to help enumerate parallelogram polyominoes by their area, perimeter, and other statistics...|$|R
2500|$|There is a {{one-to-one}} mapping between general ordered trees and binary trees, which {{in particular is}} used by Lisp to represent general ordered trees as binary trees. To convert a general <b>ordered</b> <b>tree</b> to binary tree, we only need to represent the general tree in left-child right-sibling way. The result of this representation will automatically be a binary tree, if viewed from a different perspective. Each node N in the <b>ordered</b> <b>tree</b> corresponds to a node N' [...] in the binary tree; the left child of N' [...] is the node corresponding to the first child of N, and the right child of N' [...] is the node corresponding to N 's next sibling --- that is, the next node in order among {{the children of the}} parent of N. This binary tree representation of a general order tree is sometimes also referred to as a left-child right-sibling binary tree (LCRS tree), or a doubly chained tree, or a Filial-Heir chain.|$|E
5000|$|Gives {{access to}} an <b>ordered</b> <b>tree</b> {{structure}} of synthesis nodes which define the order of execution ...|$|E
5000|$|An <b>ordered</b> <b>tree</b> (or plane tree) is a rooted tree {{in which}} an {{ordering}} is specified {{for the children of}} each vertex. This is called a [...] "plane tree" [...] because an ordering of the children is equivalent to an embedding of the tree in the plane, with the root at the top and the children of each vertex lower than that vertex. Given an embedding of a rooted tree in the plane, if one fixes a direction of children, say left to right, then an embedding gives an ordering of the children. Conversely, given an <b>ordered</b> <b>tree,</b> and conventionally drawing the root at the top, then the child vertices in an <b>ordered</b> <b>tree</b> can be drawn left-to-right, yielding an essentially unique planar embedding [...]|$|E
40|$|We study an {{abstract}} notion of tree structure which {{lies at the}} common core of various tree-like discrete structures commonly used in combinatorics: <b>trees</b> in graphs, <b>order</b> <b>trees,</b> nested subsets of a set, tree-decompositions of graphs and matroids etc. Unlike graph-theoretical or <b>order</b> <b>trees,</b> these _tree sets_ can provide a suitable formalization of tree structure also for infinite graphs, matroids, and set partitions. <b>Order</b> <b>trees</b> reappear as oriented tree sets. We show how each of the above structures defines a tree set, and which additional information, if any, is needed to reconstruct it from this tree set...|$|R
40|$|Abstract. We {{consider}} the Edit distance with moves on {{the class of}} words and the class of <b>ordered</b> <b>trees.</b> We first exhibit a simple tester for the class of regular languages on words and generalize it to the class of ranked regular trees. We also show that the distance problem is NPcomplete on <b>ordered</b> <b>trees.</b> ...|$|R
40|$|AbstractWe {{begin an}} {{investigation}} of group actions on <b>order</b> <b>trees.</b> We develop some basic definitions and properties. When G is the fundamental group of a non-Haken Seifert fibered space, we completely describe all minimal <b>order</b> <b>tree</b> actions of G by showing that any nontrivial minimal action is necessarily dual to a foliation transverse to the Seifert fibering of M...|$|R
5000|$|T13 in LoF generalizes C2 as follows. Any pa (or sentential logic) formula B can {{be viewed}} as an <b>ordered</b> <b>tree</b> with branches. Then: ...|$|E
5000|$|Viewed as a whole, a tree data {{structure}} is an <b>ordered</b> <b>tree,</b> generally with values attached to each node. Concretely, it is (if {{required to be}} non-empty): ...|$|E
5000|$|Cn is {{the number}} of non-isomorphic ordered trees with n vertices. (An <b>ordered</b> <b>tree</b> is a rooted tree in which the {{children}} of each vertex are given a fixed left-to-right order.) ...|$|E
40|$|We {{consider}} the edit distance with moves on {{the class of}} words and the class of <b>ordered</b> <b>trees.</b> We first exhibit a simple tester for the class of regular languages on words and generalize it to the class of ranked and unranked regular trees. We also show that this distance problem is NP-complete on <b>ordered</b> <b>trees.</b> ...|$|R
40|$|Abstract. The maximum common {{embedded}} subtree problem, which generalizes {{the minor}} containment problem on trees, is reduced for <b>ordered</b> <b>trees</b> to {{a variant of}} the longest common subsequence problem. While the maximum common embedded subtree problem is known to be APX-hard for unordered trees, an exact solution for <b>ordered</b> <b>trees</b> can be found in polynomial time. In this paper, the longest common balanced sequence problem, and thus the maximum common embedded subtree problem, are solved in O(n 1 n 2 min(d 1,ℓ 1) min(d 2,ℓ 2)) time, on <b>ordered</b> <b>trees</b> with n 1 and n 2 nodes, of depth d 1 and d 2, andwithℓ 1 and ℓ 2 leaves. ...|$|R
40|$|Abstract. We {{apply the}} tree-pattern {{enumeration}} formulæ of earlier work of ours [N. Dershowitz and S. Zaks, Discrete Appl. Math., 25 (1989), pp. 241 – 255], {{and a new}} extension thereof, to some recent enumerations of distributions of leaves in <b>ordered</b> <b>trees</b> [W. Y. C. Chen, E. Deutsch, and S. Elizalde, European J. Combin., 27 (2006), pp. 414 – 427] and in bicolored <b>ordered</b> <b>trees</b> [L. H...|$|R
50|$|Genetic editing {{is named}} by analogy with {{genetics}} manuscripts (individuals) {{are derived from}} other manuscripts (or previous states of the same manuscript) and with the derivation tree being a partial <b>ordered</b> <b>tree.</b>|$|E
5000|$|There is a {{one-to-one}} mapping between general ordered trees and binary trees, which {{in particular is}} used by Lisp to represent general ordered trees as binary trees. To convert a general <b>ordered</b> <b>tree</b> to binary tree, we only need to represent the general tree in left-child right-sibling way. The result of this representation will automatically be a binary tree, if viewed from a different perspective. Each node N in the <b>ordered</b> <b>tree</b> corresponds to a node N' [...] in the binary tree; the left child of N' [...] is the node corresponding to the first child of N, and the right child of N' [...] is the node corresponding to N 's next sibling --- that is, the next node in order among {{the children of the}} parent of N. This binary tree representation of a general order tree is sometimes also referred to as a left-child right-sibling binary tree (LCRS tree), or a doubly chained tree, or a Filial-Heir chain.|$|E
50|$|Parse trees and/or {{derivation}} {{trees are}} {{encountered in the}} study of phrase structure grammars such as context-free grammars or linear grammars. The leaves of a derivation tree for a formal grammar G are the terminal symbols of that grammar, and the internal nodes the nonterminal or variable symbols. One can read off the corresponding terminal string by performing an <b>ordered</b> <b>tree</b> traversal and recording the terminal symbols in the order they are encountered. The resulting sequence of terminals is a string of the language L(G) generated by the grammar G.|$|E
40|$|Semi-structured data such as XML and HTML is {{attracting}} considerable attention. It {{is important to}} develop various kinds of data mining techniques that can handle semistructured data. In this paper, we discuss applications of kernel methods for semistructured data. We model semi-structured data by labeled <b>ordered</b> <b>trees,</b> and present kernels for classifying labeled <b>ordered</b> <b>trees</b> based on their tag structures by generalizing the convolution kernel for parse trees introduced by Collins and Duffy (2001). We give algorithms to efficiently compute the kernels for labeled <b>ordered</b> <b>trees.</b> We also apply our kernels to node marking problems that are special cases of information extraction from trees. Preliminary experiments using artificial data and real HTML documents show encouraging results. 1...|$|R
40|$|A {{mutation}} {{will affect}} {{an individual and}} {{some or all of}} its descendants. In this paper, we investigate <b>ordered</b> <b>trees</b> with a distinguished vertex called the mutator. We describe various mutations in <b>ordered</b> <b>trees,</b> and find the generating functions for statistics concerning trees with those mutations. The examples give new interpretations to several known sequences and also introduce many new sequences and their combinatorial interpretations. Comment: 11 page...|$|R
40|$|NSFCThe set {{of trees}} with n {{vertices}} is denoted by T(n). In this paper, {{we consider the}} problem of <b>ordering</b> <b>trees</b> in T(n) by their Wiener indices. Some <b>order</b> relations of <b>trees</b> in T(n) are obtained. Based on the <b>order</b> relations, the <b>trees</b> in T(n) with the first up to fifteenth smallest Wiener indices are determined...|$|R
5000|$|The data {{structure}} manipulated by a Q-system is a Q-graph, {{which is a}} directed acyclic graph with one entry node and one exit node, where each arc bears a labelled <b>ordered</b> <b>tree.</b> An input sentence is usually represented by a linear Q-graph where each arc bears a word (tree reduced to one node labelled by this word). After analysis, the Q-graph is usually a bundle of 1-arc paths, each arc bearing a possible analysis tree. After generation, the goal is usually to produce as many paths as desired outputs, with again one word per arc.|$|E
50|$|A {{binary tree}} is a rooted tree {{that is also}} an <b>ordered</b> <b>tree</b> (a.k.a. plane tree) in which every node has at most two children. A rooted tree {{naturally}} imparts a notion of levels (distance from the root), thus for every node a notion of children may {{be defined as the}} nodes connected to it a level below. Ordering of these children (e.g., by drawing them on a plane) makes possible to distinguish left child from right child. But this still doesn't distinguish between a node with left but not a right child from a one with right but no left child.|$|E
50|$|An {{address space}} usually {{provides}} (or allows) a partitioning to several regions {{according to the}} mathematical structure it has. In the case of total order, as for memory addresses, these are simply chunks. Some nested domains hierarchy appears {{in the case of}} directed <b>ordered</b> <b>tree</b> as for the Domain Name System or a directory structure; this is similar to the hierarchical design of postal addresses. In the Internet, for example, the Internet Assigned Numbers Authority (IANA) allocates ranges of IP addresses to various registries in order to enable them to each manage their parts of the global Internet address space.|$|E
5000|$|Iota is the LL(1) {{language}} that prefix <b>orders</b> <b>trees</b> {{of the aforementioned}} Universal iota [...] combinator leafs, consed by function application , ...|$|R
40|$|Motivation: Computing the {{similarity}} between two <b>ordered</b> <b>trees</b> has applications in RNA secondary structure comparison, genetics and chemical structure analysis. Alignment of tree {{is one of the}} proposed measures. Similar to pair-wise sequence comparison, there is often disagreement about how to weight matches, mismatches, indels and gaps when we compare two trees. For sequence comparison, the parametric sequence alignment tools have been developed. The users are allowed to see explicitly and completely the effect of parameter choices on the optimal sequence alignments. A similar tool for aligning two <b>ordered</b> <b>trees</b> is required in practice. Results: We develop a parametric tool for aligning two <b>ordered</b> <b>trees</b> that allow users to see the effect of parameter choices on the optimal alignment of trees. Our contributions include: (1) develop a parametric tool for aligning two ordered trees; (2) design an efficient algorithm for aligning two <b>ordered</b> <b>trees</b> with gap penalties that runs in O(n 2 deg 2) time, where n is the number of nodes in the trees and deg is the degree of the trees; and (3) reduce the space of the algorithm from O(n 2 deg) to O(n log n · deg 2) ...|$|R
40|$|We {{address the}} problem of finding {{interesting}} substructures from a colletion of semi-structured data such as XML or HTML. Our framework of data mining is optimized pattern discovery introduced by Fukuda et al., where the goal of a mining algorithm is to discover a pattern that optimizes a given statistical measure such as the information entropy over a class of simple patterns. In this paper, modeling semi-structured data with labeled <b>ordered</b> <b>trees,</b> we study the efficient algorithm for the optimized pattern discovery problem for the class. In a previous paper, we developed the rightmost expansion technique and the incremental occurrence update technique by generalizing enumeration technique developed by Bayardo (SIGMOD 2 ̆ 798) for discovering long itemsets to implement an efficient frequent pattern miner for the class of labeled <b>ordered</b> <b>trees.</b> By combining these technique with the pruning technique for optimized patterns of Morishita and Sese (PODS 2 ̆ 700), we present an efficient algorithm for finding optimized patterns for labeled <b>ordered</b> <b>trees</b> of bounded size. Experimental results show that our algorithm perform well on a variety of size of data and range of parameters. We also show an approximation hardness result for labeled <b>ordered</b> <b>trees</b> of unbounded size...|$|R
50|$|How {{to ensure}} that readers will grasp the topic, get the point, {{keep track of the}} players, and see how one idea follows from another - Even if every {{sentence}} in a text is crisp, lucid, and well formed, a succession of them can feel choppy, disjointed, unfocused, incoherent. A coherent text is a designed object: an <b>ordered</b> <b>tree</b> of sections within sections, crisscrossed by arcs that track topics, points, actors, and themes, and held together by connectors that tie one proposition to the next. Like other designed objects, it comes about not by accident but by drafting a blueprint, attending to details, and maintaining a sense of harmony and balance.|$|E
5000|$|Alternatively, a tree can {{be defined}} abstractly as a whole (globally) as an <b>ordered</b> <b>tree,</b> with a value {{assigned}} to each node. Both these perspectives are useful: while a tree can be analyzed mathematically as a whole, when actually represented as a data structure it is usually represented and worked with separately by node (rather than as a list of nodes and an adjacency list of edges between nodes, as one may represent a digraph, for instance). For example, looking at a tree as a whole, one can talk about [...] "the parent node" [...] of a given node, but in general as a data structure a given node only contains the list of its children, but does not contain a reference to its parent (if any) ...|$|E
5000|$|In {{computer}} science, a range tree is an <b>ordered</b> <b>tree</b> {{data structure}} {{to hold a}} list of points. It allows all points within a given range to be reported efficiently, and is typically used in two or higher dimensions. Range trees were introduced by Jon Louis Bentley in 1979. Similar data structures were discovered independently by Lueker, Lee and Wong, and Willard.The range tree is {{an alternative to the}} k-d tree. Compared to k-d trees, range trees offer faster query times of (in Big O notation) [...] but worse storage of , where n is the number of points stored in the tree, d is the dimension of each point and k is the number of points reported by a given query.|$|E
40|$|Abstract. We enumerate {{permutations}} {{which have}} exactly r 123 -patterns and s 132 patterns where r + s ≤ 2. We also give a new bijection between the <b>ordered</b> <b>trees</b> on n+ 1 vertices and 123 -avoiding permutations of length n. We define {{the weight of}} <b>ordered</b> <b>trees</b> so that the bijection becomes weight-preserving, and find the generating function, {{in the form of}} a continued fraction, of 123 -avoiding permutations of length n that have exactly r 132 -patterns. 1...|$|R
30|$|Remark 3.1 High order {{implicit}} Runge-Kutta {{methods and}} their discretization error estimates {{can be derived}} using <b>order</b> <b>tree</b> methods as described in [1] and [10].|$|R
40|$|A {{one-dimensional}} {{fragment of}} first-order logic is obtained by restricting quantification to blocks of existential quantifiers that leave at most one variable free. This fragment contains two-variable logic, {{and it is}} known that over words both formalisms have the same complexity and expressive power. Here we investigate the one-dimensional fragment over trees. We consider unranked unordered trees accessible by {{one or both of the}} descendant and child relations, as well as <b>ordered</b> <b>trees</b> equipped additionally with sibling relations. We show that over unordered trees the satisfiability problem is ExpSpace-complete when only the descendant relation is available and 2 ExpTime-complete with both the descendant and child or with only the child relation. Over <b>ordered</b> <b>trees</b> the problem remains 2 ExpTime-complete. Regarding expressivity, we show that over <b>ordered</b> <b>trees</b> and over unordered trees accessible by both the descendant and child the one-dimensional fragment is equivalent to the two-variable fragment with counting quantifiers...|$|R
