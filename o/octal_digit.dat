16|17|Public
25|$|Binary is also easily {{converted}} to the octal numeral system, since octal uses a radix of 8, {{which is a}} power of two (namely, 23, so it takes exactly three binary digits to represent an <b>octal</b> <b>digit).</b> The correspondence between octal and binary numerals {{is the same as}} for the first eight digits of hexadecimal in the table above. Binary 000 is equivalent to the <b>octal</b> <b>digit</b> 0, binary 111 is equivalent to octal 7, and so forth.|$|E
5000|$|To convert octal to binary, replace each <b>octal</b> <b>digit</b> by its binary representation. Example: Convert 518 to binary: ...|$|E
50|$|Binary is also easily {{converted}} to the octal numeral system, since octal uses a radix of 8, {{which is a}} power of two (namely, 23, so it takes exactly three binary digits to represent an <b>octal</b> <b>digit).</b> The correspondence between octal and binary numerals {{is the same as}} for the first eight digits of hexadecimal in the table above. Binary 000 is equivalent to the <b>octal</b> <b>digit</b> 0, binary 111 is equivalent to octal 7, and so forth.|$|E
5000|$|The {{original}} CompuServe user IDs {{consisted of}} seven <b>octal</b> <b>digits</b> {{in the form}} 7xxxx,xx - a legacy of PDP-10 architecture - (later eight and nine <b>octal</b> <b>digits</b> in the form 7xxxx,xxx [...] and 7xxxx,xxxx and finally ten <b>octal</b> <b>digits</b> in the form 1xxxxx,xxxx) that were generated in advance and issued on printed [...] "Snap Paks".|$|R
50|$|Hexadecimal to octal {{conversion}} proceeds {{by first}} converting the hexadecimal digits to 4-bit binary values, then regrouping the binary bits into 3-bit <b>octal</b> <b>digits.</b>|$|R
50|$|Input and Output device {{addresses}} at {{machine level}} were two <b>octal</b> <b>digits</b> 0-7. At ARGUS level {{it was two}} letters A-G. The first digits identified the controller, the second digit identified the device number on that controller.|$|R
5000|$|In this formula, [...] is an {{individual}} <b>octal</b> <b>digit</b> being converted, where [...] is {{the position of the}} digit (counting from 0 for the right-most digit).|$|E
5000|$|... {{where the}} <b>octal</b> <b>digit</b> dn {{specifies}} whether the player {{is allowed to}} leave zero, one, or two heaps after removing n tokens from a heap. The digit dn {{is the sum of}} ...|$|E
50|$|The octal {{numbering}} system {{is also used}} as another way to represent binary numbers. In this case the base is 8 and therefore only digits 0, 1, 2, 3, 4, 5, 6, and 7 are used. When converting from binary to octal every 3 bits relate to one and only one <b>octal</b> <b>digit.</b>|$|E
25|$|The chmod {{numerical}} format accepts {{up to four}} <b>octal</b> <b>digits.</b> The three rightmost digits refer to permissions for the file owner, the group, and other users. The optional leading digit, when 4 digits are given, specifies the special setuid, setgid, and sticky flags.|$|R
50|$|For mode A, each digit in the {{transponder}} code (A, B, C, or D) {{may be a}} number from zero to seven. These <b>octal</b> <b>digits</b> are transmitted as groups of three pulses each, the A slots reserved for the first digit, B for the second, and so on.|$|R
50|$|If {{fewer than}} 4 digits are entered, leading zeros are assumed. An error will result if the {{argument}} is not a valid octal number or if {{it has more than}} 4 digits. The three rightmost <b>octal</b> <b>digits</b> address the 'owner', 'group' and 'other' user classes, respectively. If a fourth digit is present, the leftmost (high-order) digit addresses three additional attributes, the setuid bit, the setgid bit and the sticky bit.|$|R
50|$|The {{process is}} the reverse of the {{previous}} algorithm. The binary digits are grouped by threes, starting from the least significant bit and proceeding {{to the left and}} to the right. Add leading zeroes (or trailing zeroes to the right of decimal point) to fill out the last group of three if necessary. Then replace each trio with the equivalent <b>octal</b> <b>digit.</b>|$|E
50|$|The octal and {{hexadecimal}} {{systems are}} often used in computing because of their ease as shorthand for binary. Every hexadecimal digit corresponds to a sequence of four binary digits, since sixteen is the fourth power of two; for example, hexadecimal 7816 is binary 2. A similar relationship holds between every <b>octal</b> <b>digit</b> and every possible sequence of three binary digits, since eight is the cube of two.|$|E
50|$|All modern {{computing}} platforms, however, use 16-, 32-, or 64-bit words, further {{divided into}} eight-bit bytes. On such systems three octal digits per byte would be required, {{with the most}} significant <b>octal</b> <b>digit</b> representing two binary digits (plus one bit of the next significant byte, if any). Octal representation of a 16-bit word requires 6 digits, but the most significant <b>octal</b> <b>digit</b> represents (quite inelegantly) only one bit (0 or 1). This representation offers no way to easily read the most significant byte, because it's smeared over four octal digits. Therefore, hexadecimal is more commonly used in programming languages today, since two hexadecimal digits exactly specify one byte. Some platforms with a power-of-two word size still have instruction subwords that are more easily understood if displayed in octal; this includes the PDP-11 and Motorola 68000 family. The modern-day ubiquitous x86 architecture belongs to this category as well, but octal is rarely used on this platform, although certain properties of the binary encoding of opcodes become more readily apparent when displayed in octal, e.g. the ModRM byte, which is divided into fields of 2, 3, and 3 bits, so octal {{can be useful in}} describing these encodings.|$|E
50|$|The {{octal numeral}} system, or oct for short, is the base-8 number system, {{and uses the}} digits 0 to 7. Octal numerals {{can be made from}} binary numerals by {{grouping}} consecutive binary digits into groups of three (starting from the right). For example, the binary representation for decimal 74 is 1001010. Two zeroes can be added at the left: (00)1 001 010, corresponding the <b>octal</b> <b>digits</b> 1 1 2, yielding the octal representation 112.|$|R
5000|$|For instance, in a C string literal, if the {{backslash}} {{is followed}} by a letter such as [...] "b", [...] "n" [...] or [...] "t", then this represents a nonprinting backspace, newline or tab character respectively. Or if the backslash {{is followed by}} 1-3 <b>octal</b> <b>digits,</b> then this sequence is interpreted as representing the arbitrary character with the specified ASCII code. This was later extended to allow more modern hexadecimal character code notation: ...|$|R
50|$|Machine code {{programming}} used an unusual form of octal, {{known locally as}} 'bastardized octal'. It represented 8 bits with three <b>octal</b> <b>digits</b> but the first represented only two bits, whilst the others, the usual three. A more polite colloquial name was 'silly octal', derived from the official name which was syllabic octal. Although the word 'byte' had been coined by the designers of the IBM 7030 Stretch {{for a group of}} eight bits, it was not yet well known, and English Electric used the word 'syllable' for what is now called a byte.|$|R
50|$|In binary (base-2), a full space {{can be used}} {{between groups}} of four digits, {{corresponding}} to a nibble, or equivalently to a hexadecimal digit. For integer numbers, dots are used as well to separate groups of four bits. Alternatively, binary digits may be grouped by threes, corresponding to an <b>octal</b> <b>digit.</b> Similarly, in hexadecimal (base-16), full spaces are usually used to group digits into twos, making each group correspond to a byte. Additionally, groups of eight bytes are often separated by a hyphen.|$|E
5000|$|The 930 {{offers a}} [...] "memory {{extension}} system" [...] that allows addressing more than 16284 words. Two 3-bit [...] "Extend Memory Registers", called EM2 and EM3, are provided {{which can be}} loaded with a value {{to be used as}} the high-order three bits of the effective address. Addresses 000008-177778 (the first 8192 words of memory) are always unmodified. If the high-order <b>octal</b> <b>digit</b> of the address in the instruction is two the contents of EM2 replaces the high-order digit in the effective address; when the digit is three the contents of EM3 are used.|$|E
5000|$|Typically, the {{operator}} {{would have a}} written procedure containing a short series of bootstrap instructions that would be hand-entered using the toggle switches. First, {{the operator}} would set the [...] "address" [...] switch and enter the address in binary using the switches. For easier entry and readout, on some computers (such as the DEC PDP-8 or MITS Altair 8800) binary digits were grouped into threes on the front panel, with each group of lights or switches representing a single <b>octal</b> <b>digit</b> between 0 and 7. Decimal computers like the IBM 1620 used binary-coded decimal for memory addresses.|$|E
5000|$|... {{the base}} of the octal number system, which is mostly used with computers. In <b>octal,</b> one <b>digit</b> {{represents}} 3 bits. In modern computers, a byte is a grouping of eight bits, also called an [...]|$|R
50|$|Numeric {{values are}} encoded in octal numbers using ASCII digits, with leading zeroes. For {{historical}} reasons, a final NUL or space character {{should also be}} used. Thus although there are 12 bytes reserved for storing the file size, only 11 <b>octal</b> <b>digits</b> can be stored. This gives a maximum file size of 8 gigabytes on archived files. To overcome this limitation, star in 2001 introduced a base-256 coding that is indicated by setting the high-order bit of the leftmost byte of a numeric field. GNU-tar and BSD-tar followed this idea. Additionally, versions of tar from before the first POSIX standard from 1988 pad the values with spaces instead of zeroes.|$|R
50|$|Some {{equipment}} uses a 136 Hz {{square wave}} turn off code. The turn-off signal is sent for one- to three-tenths {{of a second}} (100-300 ms) {{at the end of}} a transmission to mute the audio so that a squelch crash is not heard. Radios with DCS options are generally compatible provided the radio's encoder-decoder will use the same code as radios in the existing system. Codes are usually described as three <b>octal</b> <b>digits,</b> (for example, 054). Some DCS codes are inverted data of others: one code with the marks and spaces inverted may form a different valid DCS code (413 is equivalent to 054 inverted).|$|R
50|$|Octal became {{widely used}} in {{computing}} when systems such as the PDP-8, ICL 1900 and IBM mainframes employed 12-bit, 24-bit or 36-bit words. Octal was an ideal abbreviation of binary for these machines because their word size is divisible by three (each <b>octal</b> <b>digit</b> represents three binary digits). So four, eight or twelve digits could concisely display an entire machine word. It also cut costs by allowing Nixie tubes, seven-segment displays, and calculators {{to be used for}} the operator consoles, where binary displays were too complex to use, decimal displays needed complex hardware to convert radices, and hexadecimal displays needed to display more numerals.|$|E
5000|$|The [...] and [...] bits are {{normally}} set with the command [...] by setting the high-order <b>octal</b> <b>digit</b> to 4 for [...] or 2 for [...] [...] "" [...] will set both the [...] and [...] bits (4+2=6), making the file read/write/executable for the owner (7), and executable {{by the group}} (first 1) and others (second 1). When a user other than the owner executes the file, the process will run with user and group permissions set upon it by its owner. For example, if the file is owned by user [...] and group , it will run as [...] no matter who executes the file.|$|E
5000|$|The null {{character}} is often represented as the escape sequence [...] in source code string literals or character constants. In many languages (such as C, which introduced this notation), {{this is not}} a separate escape sequence, but an octal escape sequence with a single <b>octal</b> <b>digit</b> of 0; as a consequence, [...] must not be followed by any of the digits [...] through otherwise it is interpreted as the start of a longer octal escape sequence. Other escape sequences that are found in use in various languages are , , , or the Unicode representation [...] A {{null character}} can be placed in a URL with the percent code [...]|$|E
500|$|This formula, unlike {{others before}} it, can produce any {{individual}} hexadecimal digit of [...] without calculating all the preceding digits. Individual binary digits may be extracted from individual hexadecimal <b>digits,</b> and <b>octal</b> <b>digits</b> can be extracted {{from one or}} two hexadecimal digits. Variations of the algorithm have been discovered, but no digit extraction algorithm has yet been found that rapidly produces decimal digits. An important application of digit extraction algorithms is to validate new claims of record [...] computations: After a new record is claimed, the decimal result is converted to hexadecimal, and then a digit extraction algorithm {{is used to calculate}} several random hexadecimal digits near the end; if they match, this provides a measure of confidence that the entire computation is correct.|$|R
5000|$|Another spigot algorithm, the BBP digit {{extraction}} algorithm, {{was discovered}} in 1995 by Simon Plouffe:This formula, unlike others before it, can produce any individual hexadecimal digit of [...] without calculating all the preceding digits. Individual binary digits may be extracted from individual hexadecimal <b>digits,</b> and <b>octal</b> <b>digits</b> can be extracted from one or two hexadecimal digits. Variations of the algorithm have been discovered, but no digit extraction algorithm has yet been found that rapidly produces decimal digits. An important application of digit extraction algorithms is to validate new claims of record [...] computations: After a new record is claimed, the decimal result is converted to hexadecimal, and then a digit extraction algorithm {{is used to calculate}} several random hexadecimal digits near the end; if they match, this provides a measure of confidence that the entire computation is correct.|$|R
5000|$|Squawk {{codes are}} four-digit octal numbers; the dials on a {{transponder}} read {{from zero to}} seven, inclusive. Thus the lowest possible squawk is 0000 and the highest is 7777. Four <b>octal</b> <b>digits</b> can represent up to 4096 different codes, which is why such transponders are often called [...] "4096 code transponders." [...] Care must be taken not to squawk any emergency code during a code change. For example, when changing from 1200 to 6501 (an example of an assigned air traffic control squawk), one might turn the second wheel to a 5 (thus 1500), and then rotate the first wheel backwards in the sequence 1-0-7-6 to get to 6. This would momentarily cause the transponder to squawk the code 7500, which is an emergency code signalling to ATC that the aircraft has been hijacked, causing an unnecessary false alarm situation. However, while {{it is important to}} not select an emergency code by mistake, pilots are also instructed to avoid setting the transponder in [...] "standby mode" [...] as a means of avoiding accidental selection, as it causes the loss of target information by ATC. Modern digital transponders allow the direct selection of squawk codes, without having to cycle past other numbers.|$|R
40|$|Abstract- Real-time {{implementation}} of many {{digital signal processing}} (DSP) algorithms and multimedia applications is performance limited by the available speed, energy efficiency, and area requirement of multiplication. This is exacerbated in handheld multimedia devices due to the small size and limited battery lifetimes. In our previous work, we introduce a novel canonical signed digit (CSD) iterative multiplier structure in which the conversion from 2 's complement to CSD representation is implicitly implemented in real-time. In this work, we further improve the iterative multiplier performance by introducing explicit radix- 8 hardware support in which the multiplier is shifted by one <b>octal</b> <b>digit</b> in each iteration as opposed to {{only one or two}} bits. Thus, this new structure further reduces the power consumption while simultaneously increasing the computational bandwidth significantly with only a small sacrifice in area consumption. This new design also uses a bypass technique to further reduce the need for devices such as carry save adder (CSA) arrays and adder trees for partial product reduction operations. Therefore, the new structure introduced here greatly improves the multiplier throughput and energy efficiency. Moreover, the number of iterations required to complete a fixed length multiply is data dependent {{as a result of a}} novel variable shifting technique; hence there is no energy and time overhead expended for unnecessary iterations as observed in multipliers where the number of iterations is fixed. Our results show that this new iterative structure delivers significant performance improvements with respect to speed, area, and power consumption relative to previous iterative multiplier designs. I...|$|E
50|$|The {{checksum}} {{is calculated}} {{by taking the}} sum of the unsigned byte values of the header record with the eight checksum bytes taken to be ascii spaces (decimal value 32). It is stored as a six <b>digit</b> <b>octal</b> number with leading zeroes followed by a NUL and then a space. Various implementations do not adhere to this format. For better compatibility, ignore leading and trailing whitespace, and take the first six digits. In addition, some historic tar implementations treated bytes as signed. Implementations typically calculate the checksum both ways, and treat it as good if either the signed or unsigned sum matches the included checksum.|$|R

