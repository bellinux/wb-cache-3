1114|3600|Public
25|$|Classes are {{fundamentals}} of an <b>object-oriented</b> <b>language</b> such as C#. They {{serve as a}} template for objects. They contain members that store and manipulate data in a real-lifelike way.|$|E
500|$|To {{address these}} {{business}} concerns, an aspect weaver enables {{the use of}} widely adopted languages like Java with aspect-oriented programming through minor adaptations such as AspectJ which work with existing tools. Instead of developing an entirely new language, the aspect weaver interprets the extensions defined by AspectJ and builds [...] "woven" [...] Java code which can then be used by any existing Java compiler. This ensures that any existing object oriented code will still be valid aspect-oriented code and that development will feel like a natural extension of the <b>object-oriented</b> <b>language.</b> The AspectC++ programming language extends C++ through the use of an aspect weaver, offering the additional efficiency over AspectJ that is necessary for embedded systems while still retaining the benefits of aspect-oriented programming.|$|E
2500|$|The 1980s saw a {{rapid growth}} in {{interest}} in object-oriented programming. These languages were imperative in style, but added features to support objects. The last two decades of the 20th century saw the development of many such languages. Smalltalk-80, originally conceived by Alan Kay in 1969, was released in 1980, by the Xerox Palo Alto Research Center (PARC). Drawing from concepts in another object-oriented language—Simula (which is considered the world's first object-oriented programming language, developed in the 1960s)—Bjarne Stroustrup designed C++, an <b>object-oriented</b> <b>language</b> based on C. Design of C++ began in 1979 and the first implementation was completed in 1983. In the late 1980s and 1990s, the notable imperative languages drawing on object-oriented concepts were Perl, released by Larry Wall in 1987; Python, released by Guido van Rossum in 1990; Visual Basic and Visual C++ (which included Microsoft Foundation Class Library (MFC) 2.0), released by Microsoft in 1991 and 1993 respectively; PHP, released by Rasmus Lerdorf in 1994; Java, released by Sun Microsystems in 1994, JavaScript, by Brendan Eich (Netscape), and Ruby, by Yukihiro [...] "Matz" [...] Matsumoto, both released in 1995. Microsoft's [...]NET Framework (2002) is imperative at its core, as are its main target languages, VB.NET and C# that run on it; however Microsoft's F#, a functional language, also runs on it.|$|E
50|$|At HP Labs his {{research}} {{was on the}} foundations of <b>object-oriented</b> <b>languages,</b> including formal models of mixins, inheritance, and typed models of <b>object-oriented</b> <b>languages.</b>|$|R
40|$|OSUIF is an {{extension}} to SUIF 2. 0 that provides support for the compilation of <b>object-oriented</b> <b>languages.</b> OSUIF extends standard SUIF in three main areas: symbol table, intermediate language, and exception handling. The resulting system {{should be able to}} support compilers for many (but not all) <b>object-oriented</b> <b>languages.</b> The two initial OSUIF front ends will support C++ and Java. 1. Introduction The original SUIF system [SCG 94] is a research compiler for procedural languages like C and Fortran. While these languages cover a large spectrum of compiler research, many software developers (including the SUIF developers) use <b>object-oriented</b> <b>languages</b> today. As a result, compilation of <b>object-oriented</b> <b>languages</b> has become a relevant research area. <b>Object-oriented</b> <b>languages</b> like C++ and Java are quite different from procedural languages. The most striking language difference may be the support for polymorphism that allows pieces of code to be reused with objects of different types. This p [...] ...|$|R
40|$|The {{integration}} of concurrent and object-oriented programming, although promising, presents {{problems that have}} not yet been fully explored. In this paper we attempt to identify issues in the design of concurrent <b>object-oriented</b> <b>languages</b> that must be addressed to achieve a satisfactory {{integration of}} concurrency in the object-oriented framework. We consider the approaches followed by <b>object-oriented</b> <b>languages</b> for supporting concurrency and identify six categories of concurrent <b>object-oriented</b> <b>languages.</b> Then, we review several concurrent <b>object-oriented</b> <b>languages</b> and examine the interaction of their concurrency features with their object-oriented features and with object-oriented software construction. 1 Introduction Object-oriented programming and <b>object-oriented</b> programming <b>languages</b> (OOPLs) are becoming increasingly popular for the construction of computer software. OOPLs integrate a host of techniques that have proven useful for the development and maintenance of software and that [...] ...|$|R
5000|$|Visual Basic was an object-based language. It {{supported}} classes, but not other {{concepts that}} would make it an <b>object-oriented</b> <b>language.</b> Visual Basic [...]NET is a true <b>object-oriented</b> <b>language</b> with the following features: ...|$|E
5000|$|BETA {{is a pure}} <b>object-oriented</b> <b>language</b> {{originating}} {{within the}} [...] "Scandinavian School" [...] in object-orientation where the first <b>object-oriented</b> <b>language</b> Simula was developed. Among its notable features, it introduced nested classes, and unified classes with procedures into so called patterns.|$|E
5000|$|Smalltalk (mid-1970s) {{provided}} a complete ground-up design of an <b>object-oriented</b> <b>language.</b>|$|E
40|$|<b>Object-oriented</b> <b>languages</b> {{dominate}} procedural {{languages in}} certain software-engineering categories, {{but not in}} others. Further progress may involve adapting and reintroducing principles that are already well understood and widely exploited in procedural <b>languages.</b> The <b>object-oriented</b> paradigm emerged in the 60 Õs, roughly {{during the time that}} important notions such as data abstraction, polymorphism, and modularization were applied to the procedural paradigm. Eventually, <b>object-oriented</b> <b>languages</b> also acquired notions of data abstraction, polymorphism, and modularization, but not quite in the same way, and not quite as effectively. In the last decade, <b>object-oriented</b> <b>languages</b> have been widely adopted as engineering tools because of their superiority with respect to software extensibility, which is a critical engineering property [4]. A large and growing fraction of software engineering is now carried out in <b>object-oriented</b> <b>languages,</b> taking over the domain traditionally covered by procedural <b>languages.</b> However, <b>object-oriented</b> <b>languages</b> have not incorporated all the engineering insights that have been successfully deployed in procedural languages. For example, they have emphasized code reuse at the expense of modularization, and dynamic inspection at the expense of static detection. Therefore, opportunities remain for applying important ideas that hopefully will result in even stronger engineering advantages for <b>object-oriented</b> <b>languages.</b> I will begin by considering some obvious engineering metrics. For comparison purposes, I will first recall how advances in language design have resulted in the past in engineering improvements, according to these metrics. Next, I will review how <b>object-oriented</b> <b>languages</b> have yet to show similar improvements in some of these areas. Finally, I will discuss what remains to be done to integrate certain good engineering principles into <b>object-oriented</b> <b>languages.</b> Consider the following (informal) metrics: ¥ Economy of execution. How fast does a program run...|$|R
5000|$|Foundations and Developments of <b>Object-Oriented</b> <b>Languages</b> (FOOL/WOOD) ...|$|R
50|$|<b>Object-oriented</b> <b>languages</b> such as Java, Smalltalk or C#.|$|R
5000|$|TOOL is an <b>object-oriented</b> <b>language</b> {{with the}} {{following}} features (among others): ...|$|E
5000|$|F-logic is a {{declarative}} <b>object-oriented</b> <b>language</b> for deductive {{databases and}} knowledge representation.|$|E
50|$|Although Groovy {{is mostly}} an <b>object-oriented</b> <b>language,</b> {{it also offers}} {{functional}} programming features.|$|E
5000|$|... #Subtitle level 3: Software {{interfaces}} in <b>object-oriented</b> <b>languages</b> ...|$|R
5000|$|... #Subtitle level 2: History of {{imperative}} and <b>object-oriented</b> <b>languages</b> ...|$|R
5000|$|... #Subtitle level 3: Late binding in dynamically-typed <b>object-oriented</b> <b>languages</b> ...|$|R
50|$|The ChucK {{programming}} {{language is a}} loosely C-like <b>object-oriented</b> <b>language,</b> with strong static typing.|$|E
5000|$|LabVIEW—graphical, dataflow, {{functions}} are nodes in a graph, data is wires between the nodes; includes <b>object-oriented</b> <b>language</b> ...|$|E
5000|$|Ellsberger J, Hogrefe D. & Sarma A., SDL: Formal <b>Object-Oriented</b> <b>Language</b> for Communicating Systems. Upper Saddle River: Prentice Hall 1997.|$|E
5000|$|The {{following}} <b>object-oriented</b> <b>languages</b> have no universal base class: ...|$|R
40|$|This work {{proposes a}} model to {{implement}} aspect-oriented systems, through the definition of generic aspects. This model {{could be applied to}} <b>object-oriented</b> <b>languages</b> by the implementation of the abstractions for aspects and one or more strategies defined in the model. This model can be adapted and applied to <b>object-oriented</b> <b>languages</b> in general...|$|R
40|$|<b>Object-oriented</b> <b>languages</b> offer {{mechanisms}} to help structure large programs. However, the semantics of these constructs {{are often not}} very precisely defined. For example, the use of inheritance {{as a substitute for}} subtype polymorphism in many <b>object-oriented</b> <b>languages</b> either leads to an unsound or a too inflexible type system. In addition, ideas from module constructs of functional languages could increase the expressiveness of <b>object-oriented</b> <b>languages</b> and vice versa. We propose to design module constructs incorporating the best features found among module constructs of <b>object-oriented</b> <b>languages</b> and of functional languages. In particular, we plan to incorporate parametric polymorphism, subtype polymorphism, overloading, type abstraction, and compile-time type inference in a semantically clean manner. We try to achieve this with a minimumamount of declarations required from the programmer and a minimum amount of run-time type information. 1 Introduction Module constructs are generally [...] ...|$|R
5000|$|Smalltalk is an <b>object-oriented</b> <b>language</b> {{that was}} {{designed}} and created at Xerox PARC by {{a team led by}} Alan Kay.|$|E
5000|$|A team of {{scientists}} at Xerox PARC led by Alan Kay develop Smalltalk, an <b>object-oriented</b> <b>language</b> widely known for its innovative development environment.|$|E
5000|$|Eiffel is {{a purely}} <b>object-oriented</b> <b>language</b> but {{provides}} an open architecture for interfacing with [...] "external" [...] software {{in any other}} programming language.|$|E
50|$|This pattern {{may be seen}} as a {{procedural}} extension to <b>object-oriented</b> <b>languages.</b>|$|R
40|$|In this, {{the eighteenth}} article {{in a regular}} series on {{object-oriented}} type theory, we look at how <b>object-oriented</b> <b>languages</b> might evolve in the future, given that the formal notion of class is now better understood than at the outset. <b>Object-oriented</b> <b>languages</b> were the first family to suppose {{that there might be}} systematic sets of relationships between all th...|$|R
40|$|Reuse of already {{developed}} object-oriented software components is reduced when software {{is written in}} different <b>object-oriented</b> <b>languages,</b> or {{when it is not}} easy to relocate the software components from one machine to another machine. Software development in a distributed and heterogeneous environment is a solution to this problem. Several common object models have been defined for software development in a distributed and heterogeneous environment. Most of the existing common object models do not agree upon a common set of object-oriented features. These models are weak (i. e., they have only a modest subset of object-oriented features) because they support both object-oriented and non <b>object-oriented</b> <b>languages</b> and mapping of the model into non <b>object-oriented</b> <b>languages</b> is a complex problem. In this paper an interoperable common object model (ICOM) that supports statically typed <b>object-oriented</b> <b>languages</b> is presented. The ICOM model has an extensive set of object-oriented features alon [...] ...|$|R
50|$|Compared to {{traditional}} techniques of exchange between an <b>object-oriented</b> <b>language</b> and a relational database, ORM often reduces {{the amount of}} code {{that needs to be}} written.|$|E
5000|$|In the 1960s, Simula was {{the first}} {{language}} designed to support object-oriented programming; in the mid-1970s, Smalltalk followed with the first [...] "purely" [...] <b>object-oriented</b> <b>language.</b>|$|E
50|$|Much of {{his work}} has focused on garbage collection.In 2009 he was {{inducted}} as an ACM Fellow"for contributions to real-time systems and to <b>object-oriented</b> <b>language</b> design and implementation".|$|E
50|$|Although many <b>object-oriented</b> <b>languages</b> {{support the}} above access specifiers, their {{semantics}} may differ.|$|R
50|$|Simula is {{considered}} the first <b>object-oriented</b> programming <b>language.</b> As its name suggests, Simula was designed for doing simulations, {{and the needs of}} that domain provided the framework for many of the features of <b>object-oriented</b> <b>languages</b> today.|$|R
40|$|The {{understanding}} of <b>object-oriented</b> programming <b>languages</b> is generally {{based on their}} included features. In this understanding, these features form the underlying concepts of both the languages and the modeling processes based on the <b>languages.</b> Consequently, <b>object-oriented</b> <b>languages</b> are generally compared and evaluated based on these features. Alternatively, <b>object-oriented</b> programming <b>languages</b> {{may be seen as}} supporting a conceptual perspective on programming. Instead of the features, the underlying concepts are then concepts such as phenomenon and concept, and also the abstraction processes in relation to these concepts. A comparison of <b>object-oriented</b> <b>languages</b> from the conceptual perspective gives additional {{understanding of}} each language and the mutual relations and differences between these. 1 Introduction The paper presents a comparison of <b>object-oriented</b> programming <b>languages</b> using a conceptual framework. The framework is based on a conceptual perspective on programming and [...] ...|$|R
