5|60|Public
50|$|Busy {{override}} is {{a function}} of the private branch exchange that allows the calling party to override the busy signal on the called party in order to break into the ongoing conversation. Before breaking in most PBX announce the incoming call by a distinctive sound signal or tone, but in most cases this can be disabled by software. The Busy <b>override</b> <b>function</b> was originally intended to allow the called party to receive a high priority, implying that the call is very important, and should be handled first.|$|E
50|$|The current {{length of}} the track is around 1/4 of a mile and the journey time is 3.5 minutes. There are 4 steam locos, 2 petrol {{hydraulic}} and 1 battery electric belonging to the company which are in regular use. The site comprises a station with canopy and booking office, bridge, engine shed, tunnel, turntable, signal box (with ex London Underground westinghouse 'B' style lever frame from Hyde Park Corner), steaming bays, level crossing, water tower and workshop. Colour light signals and electro-pneumatic points operate every time the railway operates and {{are in the process}} of being computerised so that the system can be used without a human signaller required. A manual <b>override</b> <b>function</b> is included.|$|E
40|$|Automated {{dispensing}} machines (ADM) are {{a computerized}} companion technology that reduces labor {{and contributes to}} patient safety. When stocked, ADMs store medications and control electronic dispensing. In emergent situations, facilities can approve nursing retrieval of medications prior to pharmacy review via override from the ADM. However, retrieving medications by the override mechanism and administering prior to pharmacy review increases the risk for medication errors. The primary objective {{of this study was}} to evaluate the appropriateness of medications removed from the ADM using the <b>override</b> <b>function</b> at a facility owned by Hospital Corporation of America (HCA). The secondary objective was to determine the barcode scan rates of medications removed by the <b>override</b> <b>function.</b> Information was collected to determine which medications were removed from the ADM and the shift, indication, and medication barcode/patient armband scanning rates. Based on medication errors identified, significant changes have been made to the override process, including the number of medications available for override and the requirement of an indication prior to medication removal. Formulary changes were made and opportunities for education identified during the evaluation. This study highlighted an opportunity to embed the culture of patient safety to promote safe medication practices...|$|E
5000|$|... #Caption: In his {{majority}} opinion, Justice William J. Brennan, Jr. {{emphasized that}} [...] "the <b>overriding</b> <b>function</b> of the Fourth Amendment {{is to protect}} personal privacy and dignity against unwarranted intrusion by the State." ...|$|R
5000|$|In C++, {{the name}} of the parent or base class is used {{followed}} by the scope resolution operator to <b>override</b> <b>functions.</b> For example, the following code presents two classes, the base class , and the derived class [...] [...] overrides the [...] class's [...] method, so as also to print its height.|$|R
50|$|However, if {{base class}} member {{functions}} use CRTP for all member <b>function</b> calls, the <b>overridden</b> <b>functions</b> in the derived class {{will be selected}} at compile time. This effectively emulates the virtual function call system at compile time without the costs in size or function call overhead (VTBL structures, and method lookups, multiple-inheritance VTBL machinery) at the disadvantage {{of not being able}} to make this choice at runtime.|$|R
40|$|The {{productivity}} of machining centers is influenced strongly {{by the quality}} of NC programs. To investigate the productivity, an NC program simulator has been developed to analyze and evaluate an NC program by decoding its NC codes. With the simulator, even before the actual machining, the tool paths can be displayed and the operational times occupied in the positioning feed motion and cutting feed motion, etc. can be calculated. The effects of the maximum speed and the acceleration of positioning feed on the productivity have been analyzed. Additionally, the influence of feedrate <b>override</b> <b>function</b> to shorten the operational time has been investigated in the conventional and the high speed cutting, respectively. From the results obtained from analyzing three NC programs, it is found that the effectiveness of the <b>override</b> <b>function</b> depends on the relation among the average moving distance, the commanded feedrate and the acceleration of cutting feed. Especially, {{in the case of the}} NC program for machining dies or molds, the productivity will be hardly improved using faster feedrate, because the actual feedrate hardly increases as expected due to the tiny moving distances of NC blocks. High speed & high precision function, which is an advanced optional function, is much more effective not only to improve the productivity but also to keep the machining accuracy of high speed cutting...|$|E
40|$|This paper {{introduces}} {{the concepts of}} wide classes and widening as extensions to the object model of class-based languages such as Java and Smalltalk. Widening allows an object to be temporarily widened, that is transformed into an instance of a subclass, a wide class, and, later on, to be shrunk, that is reshaped to its original class. Wide classes share the main properties of plain classes: they have a name, a superclass, they may be instantiated, they have an associated class predicate and an associated type {{that may be used}} to <b>override</b> <b>function</b> definnitions. Widening is also useful to implement transient data storage for longlasting computations. In particular, it helps reducing software data retention. This phenomenon arises when the actual data structures used in a program fail to reect time-dependent properties of values and can cause excessive memory consumption during the execution. Wide classes may be implemented for any dynamically-typed class-based programm [...] ...|$|E
40|$|Abstract- The Polymorphism is {{the main}} feature of Object Oriented Programming. Run Time Polymorphism is concept of late binding; means the thread of the program will be {{dynamically}} executed, according to determination of the compiler. In this paper, we will discuss the role of Run Time Polymorphism {{and how it can}} be effectively used to increase the efficiency of the application and overcome complexity of <b>overridden</b> <b>function</b> and pointer object during inheritance i...|$|R
5000|$|... class ConcreteReportGenerator : ReportGenerator { public {{override}} Report CreateReport (...) { // Tabulate {{data in the}} store-specific way // ... // Design of {{this class}} requires the parent CreateReport (...) function to be called at the [...] // end of the <b>overridden</b> <b>function.</b> But note this line could easily be left out, or the // returned report could be further modified after the call, violating the class design // and possibly also the company-wide report format. return base.CreateReport (...) }} ...|$|R
50|$|Call super is a code smell or anti-pattern of some {{object-oriented}} programming languages. Call super is a design pattern {{in which a}} particular class stipulates that in a derived subclass, the user is required to override a method and call back the <b>overridden</b> <b>function</b> itself at a particular point. The overridden method may be intentionally incomplete, and reliant on the overriding method to augment its functionality in a prescribed manner. However, {{the fact that the}} language itself {{may not be able to}} enforce all conditions prescribed on this call is what makes this an anti-pattern.|$|R
40|$|National audienceSettlement-delivery (S&D) {{operations}} of CSDs or ICSDs are the second last {{stage of the}} securities treatment procedure, the last stage being the delivery of securities into the accounts of the final holders by their account managers/custodians. As for national transfers, the organisation is fairly simple since regional depositors are directly connected to the central securities depositary which fulfils two <b>overriding</b> <b>functions</b> on their behalf: - ensuring the final custody of securities and testifying to their authenticity; - ensuring the circulation of securities within the market through one or several S&D systems...|$|R
50|$|However, {{often the}} intricacies of {{languages}} require more sophisticated mechanisms, {{which is why the}} internationalisation layers sometimes <b>override</b> entire <b>functions.</b> For example, a plural-mapping function is provided which specifies how many and which strings a language uses following an integer number.|$|R
40|$|Abstract—In the Object-Oriented Programming Systems (OOPS), {{these two}} {{concepts}} namely function overloading and <b>function</b> <b>overriding</b> {{are a bit}} confusing to the programmers. In this article this confusion is tried to be removed. Both of these are the concepts which come under the polymorphism (poly means many and morph mean forms). In the article the comparison is done in between them. For the new programmers and the learners, {{it is important to}} understand them. The function overloading [1] is achieved at the time of the compile and the <b>function</b> <b>overriding</b> is achieved at the run time. The <b>function</b> <b>overriding</b> always takes place in inheritance, but the function overloading can also take place without inheritance...|$|R
5000|$|... nomask : A type {{modifier}} for function declarations; specifies that {{it should}} not be permitted to <b>override</b> the <b>function</b> or otherwise obscure it in the function namespace. It is similar to the final type modifier in Java or PHP. Supported by most drivers.|$|R
5000|$|... 5th law (“Quintessence”): The {{conflict}} active {{phase and}} the healing phase of diseases, as described above, constitute “special meaningful programs of nature,” {{developed during the}} evolution of the species, to allow organisms to <b>override</b> everyday <b>functioning</b> {{in order to deal with}} particular emergency situations.|$|R
40|$|In the Object-Oriented Programming Systems (OOPS), {{these two}} {{concepts}} namely function overloading and <b>function</b> <b>overriding</b> {{are a bit}} confusing to the programmers. In this article this confusion is tried to be removed. Both of these are the concepts which come under the polymorphism (poly means many and morph mean forms). In the article the comparison is done in between them. For the new programmers and the learners, {{it is important to}} understand them. The function overloading [1] is achieved at the time of the compile and the <b>function</b> <b>overriding</b> is achieved at the run time. The <b>function</b> <b>overriding</b> always takes place in inheritance, but the function overloading can also take place without inheritance. Comment: 4 pages, 5 figures, 1 tabl...|$|R
40|$|Object-oriented {{programs}} {{often have}} a regular structure in that functions are propagated to classes which are connected by part-of and inheritance relations. To abbreviate the description of programs and to organize them effectively, we propose a propagation model which allows a concise specification of propagation patterns. Propagation patterns offer an abstraction mechanism for object-oriented programs that exploits part-of and inheritance relations on classes. A propagation pattern consists {{of a set of}} propagation directives. Each propagation directive is specified by a set of source vertices, an optional set of target vertices, an optional set of required edges and an optional set of bypassing edges. For each vertex to which the function interface is propagated, the function body calls the function recursively for (some of) its parts. A set of <b>overriding</b> <b>functions</b> may replace some of the generated functions. We have implemented propagation patterns for C++ and we are already using [...] ...|$|R
30|$|While some demand {{response}} strategies are implemented by artificial approach, the automated {{demand response}} can dynamically adjust load according real-time information of price or incentive signals [9]. Automated demand response will not involve any human interventions and the user response with preprogrammed demand response strategy. If the users {{are not willing}} to accept the customized strategy for specified reduction, the participants can also select the opt-out or <b>override</b> <b>functions</b> [10, 11]. Automated demand response can optimize the allocation of resources in load side, or to improve the load capability for ancillary services, and enhance the ability for peak shaving and valley filling [12]. Some users can participate the DR program through load plastic suppliers (load aggregator), which can be regarded as intermediaries between the user side and grid side. A variety of operators will gain an understanding of the level of control in their participation in DR programs and the pricing or incentive signals from power system [13, 14, 15].|$|R
50|$|Factory {{machines}} today {{usually have}} lube systems, {{in which a}} central pump serves periodic charges of oil or grease from a reservoir through lube lines to the various lube points in the machine's bearing surfaces, bearing journals, pillow blocks, and so on. The timing and number of such lube cycles {{is controlled by the}} machine's computerized control, such as PLC or CNC, as well as by manual <b>override</b> <b>functions</b> when occasionally needed. This automated process is how all modern CNC machine tools and many other modern factory machines are lubricated. Similar lube systems are also used on nonautomated machines, in which case there is a hand pump that a machine operator is supposed to pump once daily (for machines in constant use) or once weekly. These are called one-shot systems from their chief selling point: one pull on one handle to lube the whole machine, instead of a dozen pumps of an alemite gun or oil can in a dozen different positions around the machine.|$|R
40|$|This chapter {{explores the}} {{contribution}} of neuroimaging in advancing our understanding how the human brain processes language generally, but discourse specifically. The right hemisphere has long been thought to play no, or a very small role in language comprehension. However, patient studies, and now neuroimaging studies are forcing a reconceptualization of the neural language processing network. The <b>overriding</b> <b>function</b> of discourse comprehension is to combine information to generate a coherent representation of a text. It is the combining function that {{is thought to be}} particularly dependent on the right hemisphere. The neuroimaging studies discussed support this hypothesis and reveal that the right hemisphere is particularly important in connecting ideas within a text whether it be during text integration, inference generation and integration or nonliteral language comprehension. 3 Introduction Linguists and psychologists have awaited the ability of brain imaging to aid in characterizing the cognitive processes underlying language comprehension. After many initial successes in the areas of word and sentence comprehension, neuroimaging researchers are increasingly turning their attention to discourse processing. Neuroimaging techniques such a...|$|R
40|$|A {{prosecutor}} {{is viewed by}} the public as a powerful law enforcement official whose responsibility is to convict guilty people of crimes. But not everybody understands that a prosecutor’s function {{is not only to}} win convictions of law-breakers. A {{prosecutor is}} a quasi-judicial official who has a duty to promote justice to the entire community, including those people charged with crimes. Indeed, an <b>overriding</b> <b>function</b> of a prosecutor is to ensure that innocent people not get convicted and punished. A prosecutor is constitutionally and ethically mandated to promote justice. The prosecutor is even considered a 2 ̆ 2 Minister of Justice 2 ̆ 2 who has a constitutional, statutory, and ethical duty to ensure that a defendant is convicted on the basis of reliable evidence in proceedings that are fair. Nevertheless, some prosecutors deviate from these rules and engage in conduct that distorts the fact-finding process and produces erroneous convictions. Indeed, if a prosecutor is motivated to zealously win a conviction by any means, and engages in conduct that either intentionally or carelessly undermines the integrity of the fact-finding process, the prosecutor inescapably will bring about the conviction of a defendant who is actually innocent...|$|R
25|$|Templates in C++ {{provide a}} {{sophisticated}} mechanism for writing generic, polymorphic code (i.e. parametric polymorphism). In particular, through the curiously recurring template pattern, it's possible {{to implement a}} form of static polymorphism that closely mimics the syntax for <b>overriding</b> virtual <b>functions.</b> Because C++ templates are type-aware and Turing-complete, {{they can also be}} used to let the compiler resolve recursive conditionals and generate substantial programs through template metaprogramming. Contrary to some opinion, template code will not generate a bulk code after compilation with the proper compiler settings.|$|R
50|$|To {{elaborate}} on the above example, consider a base class with no virtual functions. Whenever the base class calls another member function, it will always call its own base class functions. When we derive a class from this base class, we inherit all the member variables and member <b>functions</b> that weren't <b>overridden</b> (no constructors or destructors). If the derived class calls an inherited function which then calls another member function, that function will never call any derived or <b>overridden</b> member <b>functions</b> in the derived class.|$|R
50|$|Templates in C++ {{provide a}} {{sophisticated}} mechanism for writing generic, polymorphic code (i.e. parametric polymorphism). In particular, through the Curiously Recurring Template Pattern, it's possible {{to implement a}} form of static polymorphism that closely mimics the syntax for <b>overriding</b> virtual <b>functions.</b> Because C++ templates are type-aware and Turing-complete, {{they can also be}} used to let the compiler resolve recursive conditionals and generate substantial programs through template metaprogramming. Contrary to some opinion, template code will not generate a bulk code after compilation with the proper compiler settings.|$|R
5000|$|The type of [...] {{is simply}} {{whatever}} the particular template <b>function</b> <b>override</b> of [...] returns for those particular arguments. This type is easily determined procedurally by the compiler {{as part of}} its semantic analysis duties, but is not easy for the user to determine upon inspection.|$|R
5000|$|Stack {{limited to}} 20 {{elements}} using Design by contract featurefunction Push(item)to 10 items pre(meCount{ //me is mutated object, [...] //stack {{in this case}} me.Push(item);}function Pop (...) emptiness hardik pre(meCount{ return me.Pop (...)}stack = new Stack<|int|> (...)//Create Mutant hardik//1. Set <b>Functions,</b> <b>override</b> stackPushmObject=Push->Push,PopCheck->Pop;//2. Capture objectmObject.Mutate(stack);for (i=0; i<5; i++) mObject.Push(i);Console.WriteLine((string)mObject.PopCheck (...) [...] ); ...|$|R
5000|$|... class Rectangle{ public: void SetWidth(double w) { itsWidth = w; } void SetHeight(double h) { itsHeight = h; } double GetHeight (...) const { return itsHeight; } double GetWidth (...) const { return itsWidth; } private: double itsWidth; double itsHeight;};This {{works well}} {{but when it}} comes to Square class, which {{inherits}} Rectangle class, it violates LSP even though the is-a relationship holds between Rectangle and Square. Because square is rectangular. The following example <b>overrides</b> two <b>functions,</b> Setwidth and SetHeight, to fix the problem. But fixing the code implies that the design is faulty.|$|R
50|$|Edward Lytener is {{a master}} inventor, {{specialized}} in miniature electronics and manipulating light. Prior to becoming Luminus, Edward developed devices such as laser guns, remote-controls capable of <b>overriding</b> an automobile's <b>functions,</b> and a suit of powered armor that granted him enough strength to go toe-to-toe with Superman (for a while, at least).|$|R
50|$|The comma {{operator}} has relatively {{limited use}} cases. Because it discards its first operand, {{it is generally}} only useful where the first operand has desirable side effects. Further, because it is rarely used outside of specific idioms, and easily mistaken with other commas or the semicolon, it is potentially confusing and error-prone. Nevertheless, there are certain circumstances where it is commonly used, notably in for loops and in SFINAE. For embedded systems which may have limited debugging capabilities, the comma operator {{can be used in}} combination with a macro to seamlessly <b>override</b> a <b>function</b> call, to insert code just before the function call.|$|R
5000|$|Because [...] and its {{relatives}} {{can have}} a strong impact {{on the performance of}} a program, {{it is not uncommon to}} <b>override</b> the <b>functions</b> for a specific application by custom implementations that are optimized for application's allocation patterns. The C standard provides no way of doing this, but operating systems have found various ways to do this by exploiting dynamic linking. One way is to simply link in a different library to override the symbols. Another, employed by Unix System V.3, is to make [...] and [...] function pointers that an application can reset to custom functions.|$|R
50|$|Pluggability is a core {{feature of}} the framework, as is {{object-oriented}} programming, so the application and core is mainly extended via plugin classes using a public method naming convention to denote event hooks, 'magic event' hooks, 'magic methods', and occasionally method <b>overrides.</b> Some general <b>functions</b> in the core can be overridden by predefining them.|$|R
5000|$|A simple {{example of}} {{object-oriented}} PL/SQLcreate or replace type base_type as object ( [...] a number, constructor function base_type return self as result, member function func return number, member procedure proc (n number)) instantiable not final;/Now, the type's implementation is created. The implementation defines how the type's functions, procedures and how explicit constructors behave:create or replace type body base_type as [...] constructor function base_type return self as result is begin a:=0; return; end base_type; member function func return number is begin return a; end func; member procedure proc (n number) as begin a:=n; end proc;end;/We're ready {{to derive from}} base_type. The keyword for deriving is under. The derived type defines a new attribute (named: m) and overrides func.create or replace type deriv_type under base_type ( [...] m number, <b>overriding</b> member <b>function</b> func return number);/As {{is the case with}} base types, the overridden methods in the derived type must be implemented:create or replace type body deriv_type as <b>overriding</b> member <b>function</b> func return number is begin return m*a; end;end;/The created types can be instantiated and methods can be called:declare b1 base_type :=base_type (...) b2 base_type :=base_type(4); d1 deriv_type:=deriv_type(5,6); d2 deriv_type:=deriv_type(5,6);begin dbms_output.put_line(b1.func); dbms_output.put_line(b2.func); d1.proc(4); dbms_output.put_line(d1.func); dbms_output.put_line(d2.func);end;/Results 0 4 24 30The created types have become real types and can be used in tables:create table table_base ( [...] b base_type);declare base base_type := base_type (...) deriv deriv_type:= deriv_type(8,9);begin insert into table_base values(base); insert into table_base values(deriv);end;/select t.b.func (...) from table_base t;Results: 0 72select avg(t.b.func (...) [...] ) from table_base t;Result: 36 ...|$|R
5000|$|Since modules can <b>override</b> {{lower level}} <b>functions</b> such as Pascal's [...] "write" [...] statement, normal, unmodified ISO 7185 Pascal {{programs}} {{can also use}} advanced aspects of the porting platform. This is unlike many or most portable graphics libraries that force the user to use a completely different I/O methodology to access a windowed graphics system, for example C, other Pascals, and Visual Basic.|$|R
40|$|The {{political}} border limits a state’s {{territory and}} symbolizes {{the extent of}} a state’s power and ownership. Borders give integrity to the inner state territory which they enclose (the role of establishing national integrity) {{and at the same}} time form an outer boundary segregating the state territory from the surrounding politicial entities (the segregation role). European borders are old and reﬂect the political history of an old continent. The last major border changes happened after World War II. Over the centuries borders were merely lines separating one territory from another. Such borders were understood as »frontiers«. Forming an effective barrier against enemies was the <b>overriding</b> <b>function</b> of borders. Many borders were fortiﬁed and further enhanced by means of various defensive systems. In the second half of the 20 th century the character of political borders changed. They became a contact area between countries, nations and cultures. Contemporary European borders reﬂect the colourful history of an old continent. They are predominantely functional markers: they represent the political and juridical delimitation of territories, they mark economic barriers and show their defensive nature and reveal the extent of cultural contact. As a result of European integration processes, the nature of political borders has changed: instead of division, their integration role is brought to the fore. A united Europe is nevertheless still not a borderless Europe! The borders within the »Schengen-area« have retained their political and administrative functions, it is just that the customs and security checks at the borders have been removed. During the period of European integration, borderlines were stabilized in accordance with the 1974 Helsinki Agreement. But despite this we can still observe ongoing changes to state borders, particularly in areas of conﬂict such as the Balkan peninsula. It seems after all that the process of demarcation of political borders has not yet come to an end...|$|R
40|$|Gaining {{the code}} re-use {{advantages}} of {{object oriented programming}} requires dynamic function binding, which allows a new subclass to <b>override</b> a <b>function</b> of a superclass. Dynamic binding is obtained in C++ {{through the use of}} virtual functions. Unfortunately, virtual functions have two negative impacts on performance. First, they are traditionally compiled into indirect call instructions, which take longer to execute than direct call instructions. Second, it is difficult for the compiler to perform optimization since summary information from called procedures is hard or even impossible to obtain. The net effect is that C++ programmers avoid the use of virtual functions. We present a new optimization that (1) removes the indirect function calls used for virtual functions, (2) enables other compiler optimizations such as inlining and constant propagation, and (3) requires no extensive dataflow analysis or profile information and thus is easily implemented in an existing compiler. We includ [...] ...|$|R
