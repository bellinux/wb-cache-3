118|62|Public
25|$|Core Data is the <b>object</b> <b>persistence</b> {{framework}} {{included with}} Foundation and Cocoa and found in Cocoa.h.|$|E
2500|$|These {{concepts}} make up {{the majority}} of the HyperCard system; stacks, backgrounds and cards provide a form-like GUI system, the stack file provides <b>object</b> <b>persistence</b> and database-like functionality, and HyperTalk allows handlers to be written for GUI events. Unlike the majority of RAD or database systems of the era, however, HyperCard combined all of these features, both user-facing and developer-facing, in a single application. This allowed rapid turnaround and immediate prototyping, allowing users to author custom solutions to problems with their own personalized interface. [...] "Empowerment" [...] became a catchword as this possibility was embraced by the Macintosh community, as was the phrase [...] "programming for the rest of us", that is, anyone, not just professional programmers.|$|E
50|$|Maglev runs {{inside an}} image like Smalltalk, {{offering}} transparent <b>object</b> <b>persistence</b> to Ruby objects and classes. <b>Object</b> <b>persistence</b> {{is based on}} ACID transactions that allow multiple running instances to see a shared object graph. Maglev uses a process-based concurrency model, mapping Ruby threads to Smalltalk Processes, which are scheduled in the VM as green threads.|$|E
3000|$|In the {{distributed}} systems domain <b>objects</b> <b>persistence</b> {{has been an}} important issue addressed already by consolidated middleware such as JBOSS and PiJAMA. The new exascale requirements introduced by greedy processes often related to Big Data processing has introduced <b>objects</b> <b>persistence</b> again. In order for exascale and/or Big Data systems to deliver the needed I/O performance, new storage devices such as NVRAM or Storage Class Memories (SCM) need to be included into the storage/memory hierarchy. Given that the nature of these new devices will be closer to memory than to storage (low latencies, high bandwidth, and byte-addressable interface) using them as block devices for a file system {{does not seem to be}} the best option. DataClay, 22 proposes object storage to enable both the programmer, and DataClay, to take full advantage of the coming high-performance and byte-addressable storage devices. Today, given the lack of such devices, DataClay performs a mapping of such abstractions to key-value stores such as Kinetic drives from Seagate. 23 [...]...|$|R
50|$|In philosophy, four-dimensionalism (also {{known as}} the {{doctrine}} of temporal parts) is an ontological position that an <b>object's</b> <b>persistence</b> through time is like its extension through space. Thus, an object that exists in time has temporal parts in the various subregions of the total region of time it occupies, just like an object that exists in a region of space {{has at least one}} part in every subregion of that space.|$|R
40|$|Object-oriented {{systems could}} use {{much of the}} {{functionality}} of database systems to manage their <b>objects.</b> <b>Persistence,</b> <b>object</b> identity, storage management, distribution and concurrency control {{are some of the}} things that database systems traditionally handle well. Unfortunately there is a fundamental difference in philosophy between the object-oriented and database approaches, namely that of object independence versus data independence. We discuss the ways in which this difference in outlook manifests itself, and we consider the possibilities for resolving the two views, including the current work on object-oriented databases. We conclude by proposing an approach to co-existence that blurs the boundary between the object-oriented execution environment and the database. 1. Introduction Consider an environment for running object-oriented applications. There are a number of object management issues that should ideally be directly supported by the environment: persistence, creation and des [...] ...|$|R
5000|$|Core Data is the <b>object</b> <b>persistence</b> {{framework}} {{included with}} Foundation and Cocoa and found in Cocoa.h.|$|E
50|$|F-Script {{provides}} an interpreted, interactive environment with support for workspaces, which provide a {{rich set of}} functionality including <b>object</b> <b>persistence,</b> distributed objects, GUI framework, database access, among other things.|$|E
50|$|This {{pattern is}} {{commonly}} used by <b>object</b> <b>persistence</b> tools and in object-relational mapping (ORM). Typically, foreign key relationships will be exposed as an object instance of the appropriate type via a property.|$|E
40|$|Mobile {{software}} {{objects are}} autonomous computational entities that travel in large-scale and widely-distributed heterogeneous systems, and whose functionality can {{be attached to}} diverse computing environments. Incorporation of mobile objects into large-scale distributed systems introduces new challenges to distributed object management (sub) system (DOMS). In this paper we focus on two important aspects of DOMS for mobile <b>objects,</b> <b>persistence</b> and security. The gist of our approach is to enable objects to determine and set the policies governing their own persistence and security, coupled with infrastructure-level mechanisms for managing the persistent store and enforcing the security policies. This approach is embodied in the Hadas object manager, which is fully implemented in Java and utilizes Java's serialization and security manager for persistence and security, respectively. 1...|$|R
40|$|The paper {{discusses}} the relevant features {{of an object}} support system that provides basic facilities for building flexible distributed applications in environments where objects can be mobile and occasional failures (node crashes, real or virtual network partitions) are possible. These facilities are for naming, locating and invoking <b>objects,</b> <b>persistence</b> and garbage collection. One of the key features is an efficient and reliable object reference scheme that is particularly good for dealing with mobile objects. The design presented scales to systems of arbitrary size and is portable since it only requires a few standard capabilities from the underlying operating system. Keywords: distribution, mobility, persistence, garbage-collection, fault-tolerance, naming. Note: Full Paper for IWOOOS 95 2 1. Introduction Large-scale distributed computing systems (LSDCS) comprising several thousands to millions of individual computer systems (nodes) are coming into existence both as a consequence [...] ...|$|R
40|$|In {{the last}} three years we have been working with {{persistence}} and distribution, in particular migration of higher-level objects between autonomous persistent programs. In this chapter we introduce persistence and then present a few examples of opportunities and many more challenges that exist in the combination of persistence and mobility. 1 Introduction Mobile objects are active objects that migrate between programs. These active objects are commonly implemented as procedures, instances of classes or abstract data types, or threads. A persistent program is a program written in a language that permits to create and manipulate objects independent of their life time (see section 2). The main motivation for the research work described here is our perception that persistence has not been properly addressed by the research community studying mobile <b>objects.</b> <b>Persistence</b> is important because many of the examples for mobile object applications presented in the literature include local or re [...] ...|$|R
5000|$|Perl Object-Oriented Persistence (POOP) is {{the term}} given to refer to object-relational mapping {{mechanisms}} written in the Perl programming language to provide <b>object</b> <b>persistence.</b> Dave Rolsky divides POOP mechanisms into two categories: ...|$|E
50|$|InfiniteGraph is {{produced}} by Objectivity, Inc. - a company that develops database technologies supporting large-scale, distributed data management, <b>object</b> <b>persistence</b> and relationship analytics. InfiniteGraph was first {{released to the public}} in 2010 and the latest version (v3.3) was made available in June 2014.|$|E
50|$|LiteSQL creates tables, indexes and {{sequences}} to {{database and}} upgrades schema when needed. In addition to <b>object</b> <b>persistence,</b> LiteSQL provides object relations {{which can be}} used to model basic OO building blocks (aggregation, composition, association). Objects can be selected, filtered and ordered using template- and class-based API with type checking at compile time.|$|E
40|$|Abstract: The {{cultural}} heritage preservation requires that objects persist throughout time {{to continue to}} communicate an intended meaning. Digital technology and specifically 3 D digital technology is naturally a critical component in preservation. Yet once in the digital world the <b>object's</b> <b>persistence</b> is inextricably linked to data persistence and current 3 D technologies {{do little more than}} capture a silhouette of the original object. HyperFun is a simple geometric modeling language which realizes two valuable qualities key to historical preservation: absolute data persistence, as HyperFun describes objects with mathematical functions; and secondly, by using a new approach called Function Representation (FRep), HyperFun provides a uniform method to model both surface geometry and internal composition simultaneously, making it is possible to preserve a very complete structural understanding of any object. We illustrate the properties of this new modeling system using several case studies involving the digital capture of traditional objects and craft patterns, which we also reuse in modern designs. 1...|$|R
50|$|QxOrm is an <b>Object</b> Rational Mapping <b>persistence</b> {{framework}} for C++ with Qt. It supports cross compilation {{and is available}} for the platforms Windows 64/32 bit, Linux 64/32 bit and Mac OS.|$|R
30|$|A SLEE is {{a service}} {{container}} made of several abstraction layers. Its multi-tier architecture simplifies {{the development of}} complex services by providing the non-functional features needed for their execution, such as <b>object</b> lifecycle management, <b>persistence</b> management, thread management, object pooling, and so on.|$|R
50|$|ECO {{performs}} object-relational mapping {{based on}} metadata which {{is taken from}} the model or from an xml file. It implements such advanced <b>object</b> <b>persistence</b> features as caching, lazy load and others. Mapping scheme is configurable enough to use ECO with existing databases. Database reverse engineering wizard {{as a part of}} ECO helps with this task.|$|E
50|$|Object storage mechanisms: Object-relational mapping, object databases, and <b>object</b> <b>persistence</b> are all {{concerned}} with {{eliminating the need}} to write a conventional Data access layer underneath the domain objects. These patterns are complementary and potentially synergistic with the naked objects pattern, which is concerned with eliminating the need to write layers above the domain objects.|$|E
50|$|<b>Object</b> <b>persistence</b> {{is defined}} in the {{external}} XML metafiles, which may have vendor-specific extensions. JDO vendors provide developers with enhancers, which modify compiled Java class files {{so they can be}} transparently persisted. (Note that byte-code enhancement is not mandated by the JDO specification, although it is the commonly used mechanism for implementing the JDO specification's requirements.) Currently, JDO vendors offer several options for persistence, e.g. to RDBMS, to OODB, or to files.|$|E
50|$|Spring's {{data access}} {{framework}} addresses common difficulties developers face {{when working with}} databases in applications. Support is provided for all popular data access frameworks in Java: JDBC, iBatis/MyBatis, Hibernate, Java Data <b>Objects</b> (JDO), Java <b>Persistence</b> API (JPA), Oracle TopLink, Apache OJB, and Apache Cayenne, among others.|$|R
40|$|Object-oriented {{programs}} involve many unique {{features that}} are not present in their conventional counterparts. Examples are message passing, synchronization, dynamic binding, <b>object</b> instantiation, <b>persistence,</b> encapsulation, inheritance, and polymorphism. Integration testing for such programs is, therefore, more difficult than that for conventional programs. In this paper, we present an overview of current work on integration testing for object-oriented and/or concurrent programs, {{with a view to}} identifying areas for future research. We cover state-based testing, event- based testing, fault-based testing, deterministic and reachability techniques, and formal and semi- formal techniques...|$|R
40|$|Object-oriented {{programs}} involve many unique {{features that}} are not present in their conventional counterparts. Examples are message passing, synchronization, dynamic binding, <b>object</b> instantiation, <b>persistence,</b> encapsulation, inheritance, and polymorphism. Testing for such program is, therefore, more difficult than that for conventional programs. Object-orientation has rapidly become accepted as the preferred paradigm for large-scale system design. In this paper we have discussed about how testing is being {{carried out in the}} Object Oriented environment. To accommodate this, several new techniques have been proposed like fault-based techniques, Scenario based, Surface structure testing, and Deep structural testin...|$|R
50|$|Apache Cayenne is an {{open source}} {{persistence}} framework licensed under the Apache License, providing object-relational mapping (ORM) and remoting services. Cayenne binds one or more database schemas directly to Java objects, managing atomic commit and rollbacks, SQL generation, joins, sequences, and more. With Cayenne's Remote <b>Object</b> <b>Persistence,</b> those Java objects can even be persisted out to clients via Web Services. Or, with native XML serialization, objects can be further persisted to non-Java clientsâ€”such as an Ajax-capable browser.|$|E
50|$|Athena Framework is an {{enterprise}} object-relational mapping (ORM) framework that employs metadata as mapping configuration. It simplifies Java web application development {{by removing the}} requirement of manual mapping and manual database schema updating. In addition to features like Java <b>object</b> <b>persistence,</b> powerful EJBQL querying execution and comprehensive code generation, Athena has built-in support for multi-tenancy which enables developers to build cloud applications easily. Athena can be easily integrated with other libraries like Struts or Spring to provide full stacks of service.|$|E
50|$|Primary {{keys are}} the {{foundation}} of <b>object</b> <b>persistence</b> between server and client. Although the client may {{have more than one}} instance of a database object available, on the server it is always the same one managed by the ORM Layer. Changes to the server side objects are therefore directly available to all clients. The Force4 server ensures the integrity of the objects, even if several clients manipulate the same object. The ORM Layer takes care of both database integrity and also object caching. Thereby guaranteeing optimal performance and memory usage.|$|E
50|$|Many {{traditional}} {{web application}} architectures {{created in the}} late 1990 were based on middle <b>object</b> tiers and <b>persistence</b> layers that used tabular data streams and relational database systems. Because each of these layers used different structures to store the models the systems required much additional complexity to translate between layers.|$|R
2500|$|Unlike the [...] "{{everything}} is a file" [...] {{feature of}} Unix and its derivatives, on IBM i everything is an <b>object</b> (with built-in <b>persistence</b> and garbage collection). [...] IBM i offers Unix-like file directories using the Integrated File System. [...] Java compatibility is implemented through a native port of the Java virtual machine.|$|R
50|$|Prior to the {{introduction}} of EJB 3.0 specification, many enterprise Java developers used lightweight persistent objects, provided by either persistence frameworks (for example Hibernate) or data access objects instead of entity beans. This is because entity beans, in previous EJB specifications, called for too much complicated code and heavy resource footprint, and they could be used only in Java EE application servers because of interconnections and dependencies in the source code between beans and DAO <b>objects</b> or <b>persistence</b> framework. Thus, many of the features originally presented in third-party persistence frameworks were incorporated into the Java Persistence API, and, as of 2006, projects like Hibernate (version 3.2) and TopLink Essentials have become themselves implementations of the Java Persistence API specification.|$|R
50|$|Java Data Objects (JDO) is a {{specification}} of Java <b>object</b> <b>persistence.</b> One of its features is a transparency of the persistence {{services to the}} domain model. JDO persistent objects are ordinary Java programming language classes (POJOs); there is no requirement for them to implement certain interfaces or extend from special classes. JDO 1.0 was developed under the Java Community Process as JSR 12. JDO 2.0 was developed under JSR 243 and was released on May 10, 2006. JDO 2.1 was completed in Feb 2008, developed by the Apache JDO project. JDO 2.2 was released in October 2008. JDO 3.0 was released in April 2010.|$|E
5000|$|These {{concepts}} make up {{the majority}} of the HyperCard system; stacks, backgrounds and cards provide a form-like GUI system, the stack file provides <b>object</b> <b>persistence</b> and database-like functionality, and HyperTalk allows handlers to be written for GUI events. Unlike the majority of RAD or database systems of the era, however, HyperCard combined all of these features, both user-facing and developer-facing, in a single application. This allowed rapid turnaround and immediate prototyping, allowing users to author custom solutions to problems with their own personalized interface. [...] "Empowerment" [...] became a catchword as this possibility was embraced by the Macintosh community, as was the phrase [...] "programming for the rest of us", that is, anyone, not just professional programmers.|$|E
5000|$|Spring did {{not include}} a {{built-in}} <b>object</b> <b>persistence</b> system, but the name service was persistent and could be used to find objects in this sort of manner. To some degree the series of servers started during boot time provided a persistent name space which survived boots, as they copied their names into the same server. In theory the system could allow the name server to provide a [...] "lazy launch" [...] system, not starting the networking server until someone requests it for instance, but it does not appear it included this functionality. In fact the separation of name spaces would allow this to be separated out to the service which actually implemented the naming of doors, making implementation considerably easier.|$|E
40|$|This paper {{presents}} an electronic auction {{system as a}} case study of a distributed computing application using the Java language and the Voyager distributed programming platform. It stresses the importance of state-of-the-art WWW development tools that address the run-to-the-market need of electronic commerce applications. Conceptual simplicity and efficient design and implementation are the major advantages from the adoption of a platform where <b>object</b> mobility and <b>persistence</b> are transparently available...|$|R
50|$|At {{about the}} same time, a group of {{third-party}} developers had met at the Apple Worldwide Developers Conference (WWDC '91) and tried to hammer out a standardized document format, based conceptually on the Electronic Arts Interchange File Format (IFF). Apple became interested in this work, and soon dedicated some engineers {{to the task of}} building, or at least documenting, such a system. Initial work was published on the WWDC CDs, {{as well as a number}} of follow-up versions on later developer CDs. A component document system would only work with a known document format that all the components could use, and so soon the standardized document format was pulled into the component software effort. The format quickly changed from a simple one using tags to a very complex <b>object</b> oriented <b>persistence</b> layer called Bento.|$|R
40|$|This paper {{explains}} {{what is an}} object, a session, and a room persistence in a virtual collaboration room, describes functions of object recording/replaying, session recording/replaying, and <b>object</b> and room <b>persistence,</b> shows how to implement the functions in VCR system, and finally demonstrates by examples how the functions are used to solve schedule conflicting problem in a synchronous group activity and to support asynchronous group activities as well. Online learning is improved with the functions in terms of effectiveness and efficiency...|$|R
