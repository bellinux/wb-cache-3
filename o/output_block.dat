54|256|Public
5000|$|A {{cryptographic}} {{operation is}} (optionally) {{performed on the}} last iteration <b>output</b> <b>block</b> Hq to produce the block G. Three output transformations are defined: ...|$|E
5000|$|Examples of [...] "abstractions" [...] on a PC include video input, printers, {{audio input}} and <b>output,</b> <b>block</b> devices (e.g. hard disk drives or USB flash drive), etc.|$|E
5000|$|Yarrow-160 uses three-key triple-DES in {{counter mode}} to {{generate}} outputs. [...] is an n-bit counter value; [...] is the key. In order {{to generate the}} next <b>output</b> <b>block,</b> Yarrow follows the functions shown here.|$|E
5000|$|... #Caption: The sponge {{construction}} for hash functions. pi are {{blocks of}} the input string, zi are hashed <b>output</b> <b>blocks.</b>|$|R
5000|$|The [...] option {{means to}} keep going {{if there is an}} error, while the [...] option causes <b>output</b> <b>blocks</b> to be padded.|$|R
50|$|Its {{requiring}} a fixed-length <b>block</b> <b>output</b> makes it lesser than Lempel-Ziv, {{which has a}} similar dictionary-based design, but with a variable-sized <b>block</b> <b>output.</b>|$|R
50|$|KFB mode outputs m bits (typically m = 8) at a {{time and}} uses a {{constant}} bitstring p as block cipher input, a key k of n bit length, and a n Ã— m matrix with non-zero rows as IV. It is possible {{to reduce the size of}} the matrix and it does not need to be secret but must be random. If the <b>output</b> <b>block</b> size of the block cipher is not equal to the key size, a function is needed to form a valid key from the <b>output</b> <b>block.</b> The speed of KFB is a bit lower than for other modes of operation like OFB, mainly because the key schedule has to be done for each key.|$|E
50|$|In {{cryptography}} key feedback mode (KFB) is a mode {{of operation}} for cryptographic block ciphers. It uses the block cipher <b>output</b> <b>block</b> to form the block cipher key of the next round, thereby creating a keystream generator {{that can be used}} as a synchronous stream cipher.|$|E
5000|$|MUGI takes a 128-bit {{secret key}} and a 128-bit initial vector (IV). After a key- and IV- setup process, MUGI outputs 64-bit output strings {{based on the}} {{internal}} state, while updating the internal state after each <b>output</b> <b>block.</b> MUGI has a 1216-bit internal state; there are three 64-bit registers (the [...] "state") and 16 64-bit registers (the [...] "buffer").|$|E
50|$|Perhaps {{the most}} common and {{straight}} forward mechanism to build a MGF is to iteratively apply a hash function together with an incrementing counter value. The counter may be incremented indefinitely to yield new <b>output</b> <b>blocks</b> until a sufficient amount of output is collected. This is the approach used in MGF1 shown below.|$|R
5000|$|Figure (a) {{shows the}} section of the input array [...] Figure (b) shows the region of support of the {{convolution}} of that section with [...] that is [...] The <b>block</b> <b>output</b> [...] is the convolution of [...] with block [...] of [...] The result of the block convolution must be added together to produce the complete filter output [...] As the support of [...] is greater than the support of , the <b>output</b> <b>blocks</b> will of necessity overlap, but the degree of that overlap is limited.|$|R
40|$|Control circuit {{designed}} for use with commercially available AHA 4610 Reed-Solomon encoder. Needed to select depth of interleaving and to synchronize input and <b>output</b> <b>blocks</b> of data and parity bits with suitable clock signals. Circuit provides synchronizing and control signals for Reed-Solomon encoder. Encoder can operate with asynchronous input and output data streams at rates up to 80 Mb/s. Interleaving depth selectable, and accommodation to input data rate automatic...|$|R
5000|$|Any PRG [...] can {{be turned}} into a forward secure PRG with block length [...] by {{splitting}} its output into the next state and the actual output. This is done by setting , in which [...] and then [...] is a forward secure PRG with [...] as the next state and [...] as the pseudorandom <b>output</b> <b>block</b> of the current period.|$|E
5000|$|This {{method is}} known as overlap-add. [...] In our example, it uses {{contiguous}} input blocks of size 824 and pads each one with 200 zero-valued samples. Then it overlaps and adds the 1024-element output blocks. Nothing is discarded, but 200 values of each <b>output</b> <b>block</b> must be [...] "saved" [...] for the addition with the next block. Both methods advance only 824 samples per 1024-point IFFT, but overlap-save avoids the initial zero-padding and final addition.|$|E
5000|$|Yarrow keeps {{count of}} the <b>output</b> <b>block,</b> because once the key is {{compromised}}, the leak of the old output before the compromised one can be stopped immediately. Once some system security parameter [...] is reached, the algorithm will generate [...] bits of PRNG output and use them as the new key. In Yarrow-160, the system security parameter is set to be 10, which means [...] The parameter is intentionally set to be low to minimize the number of outputs that can be backtracked.|$|E
40|$|WO 200258054 A UPAB: 20020910 NOVELTY - The method {{involves}} {{writing a}} destination block {{for the current}} section of the input signal from one decoder, writing a second encoder (14) <b>output</b> data <b>block</b> after the destination data block, writing at least one first decoder (12) <b>output</b> data <b>block</b> before the destination data block and writing offset information in the scaleable data stream that indicates that the first encoder <b>output</b> data <b>block(s)</b> is before the destination data block. DETAILED DESCRIPTION - INDEPENDENT CLAIMS are also included for the following: a method of decoding a scaleable data stream, an arrangement for producing a scaleable data stream and an arrangement for decoding a scaleable data stream. USE - For producing a scaleable data stream. ADVANTAGE - Enables delay-free decoding of the first scaling layer...|$|R
40|$|The {{following}} paper {{describes a}} method to increase {{the rate of the}} generating pseudo random numbers. The proposed solution, that works according to described method, consists of shift register generator and additional data <b>output</b> <b>blocks.</b> Through adding these functional blocks, connected with a classical LFSR generator, increase of the pseudo random number generating rate was obtained. A number of these additional blocks were discussed in the following paper. Operation of these additional blocks was shown on a example...|$|R
40|$|This paper {{studies the}} {{decoupling}} problem in infinite-dimensional systems using the so-called geometric approach of Wonham, and presents necessary and/or sufficient {{conditions for the}} problem to be solvable for various cases, including (a) the case for which the input operator B satisfies dim (Im B) = k, where k {{is the number of}} <b>output</b> <b>blocks,</b> and (b) the case for which the pre-input operator G satisfies rank G = m, where m is the dimension of the input space. 1...|$|R
5000|$|At Eurocrypt 2006, speed {{reports were}} {{presented}} for QUAD instances with 160-bit state and <b>output</b> <b>block</b> over the fields GF(2), GF(16), and GF(256). These speed reports {{were part of}} an analysis of [...] "Efficient Implementations of Multivariate Quadratic Systems" [...] which was published by Berbain, Billet, and Gilbert at SAC 2006. This analysis (which also covers several multivariate public-key schemes as well as the QUAD stream cipher) studied in part the impact of changing the size of the field on the performances without considering the security aspect.|$|E
5000|$|A forward-secure PRG with {{block length}} [...] is a PRG , where the input string [...] with length [...] {{is the current}} state at period , and the output ( [...] , [...] ) {{consists}} of the next state [...] and the pseudorandom <b>output</b> <b>block</b> [...] of period , such that it withstands state compromise extensions in the following sense. If the initial state [...] is chosen uniformly at random from , then for any , the sequence [...] must be computationally indistinguishable from , in which the [...] are chosen uniformly at random from [...]|$|E
50|$|The PISO (Parallel Input, Serial <b>Output)</b> <b>block</b> {{typically}} has {{a parallel}} clock input, {{a set of}} data input lines, and input data latches. It may use an internal or external phase-locked loop (PLL) to multiply the incoming parallel clock up to the serial frequency. The simplest form of the PISO has a single shift register that receives the parallel data once per parallel clock, and shifts it out at the higher serial clock rate. Implementations may also make use of a double-buffered register to avoid metastability when transferring data between clock domains.|$|E
50|$|There {{are also}} methods {{for dealing with}} an x {{sequence}} that is longer than a practical value for N. The sequence is divided into segments (blocks) and processed piecewise. Then the filtered segments are carefully pieced back together. Edge effects are eliminated by overlapping either the input <b>blocks</b> or the <b>output</b> <b>blocks.</b> To help explain and compare the methods, we discuss them both {{in the context of}} an h sequence of length 201 and an FFT size of N = 1024.|$|R
2500|$|... 1965 {{also added}} another 350hp small block engine (Option L79) which used {{hydraulic}} rather than solid lifters, a milder camshaft and a modestly redesigned smaller oil pan. Otherwise, the 350hp engine was cosmetically and mechanically {{identical to the}} 365hp engine (Option L76) solid lifter engine. The smaller oil pan allowed this high <b>output</b> small <b>block</b> 350hp engine to be ordered with optional Power Steering {{for the first time}} amongst the optional stable of higher <b>output</b> small <b>block</b> engines. Power steering was previously only available with the lower 250hp and 300hp engines.|$|R
5000|$|Algorithm 1 (OA for linear convolution) Evaluate {{the best}} value of N and L (L>0, N = M+L-1 nearest to power of 2). Nx = length(x); H = FFT(h,N) [...] (zero-padded FFT) i = 1 y = zeros(1, M+Nx-1) while i <= Nx [...] (Nx: the last index of xn) il = min(i+L-1,Nx) yt = IFFT( [...] FFT(x(i:il),N) * H, N) k = min(i+N-1,M+Nx-1) y(i:k) = y(i:k) + yt(1:k-i+1) [...] (add the {{overlapped}} <b>output</b> <b>blocks)</b> i = i+L endThis algorithm {{is based on the}} linearity of the DFT ...|$|R
5000|$|In an RA code, an {{information}} block of length [...] is repeated [...] times, scrambled by an interleaver of size , and then encoded by a rate 1 accumulator. The accumulator {{can be viewed}} as a truncated rate 1 recursive convolutional encoder with transfer function , but Divsalar et al. prefer to think of it as a block code whose input block [...] and <b>output</b> <b>block</b> [...] are related by the formula [...] and [...] for [...] The encoding time for RA codes is linear and their rate is [...] They are nonsystematic.|$|E
5000|$|A {{block is}} a unit {{measuring}} {{the number of}} bytes that are read, written, or converted at one time. Command line options can specify a different block size for input/reading (...) compared to output/writing (...) , though the block size (...) option will override both [...] and [...] The default value for both input and <b>output</b> <b>block</b> sizes is 512 bytes (the traditional block size of disks, and POSIX-mandated size of [...] "a block"). The [...] option for copying is measured in blocks, as are both the [...] count for reading and [...] count for writing. Conversion operations are also affected by the [...] "conversion block size" [...] (...) [...]|$|E
50|$|The SIPO (Serial Input, Parallel <b>Output)</b> <b>block</b> {{typically}} has a {{receive clock}} output, {{a set of}} data output lines and output data latches. The receive clock may have been recovered from the data by the serial clock recovery technique. However, SerDes which do not transmit a clock use reference clock to lock the PLL to the correct Tx frequency, avoiding low harmonic frequencies present in the data stream. The SIPO block then divides the incoming clock down to the parallel rate. Implementations typically have two registers connected as a double buffer. One register is used to clock in the serial stream, {{and the other is}} used to hold the data for the slower, parallel side.|$|E
40|$|We show {{two methods}} of {{distinguishing}} the LEVIATHAN stream cipher from a random stream using 2 ^{ 36 } bytes of output and proportional effort; both arise from compression within the cipher. The first models the cipher as two random functions in sequence, and {{shows that the}} probability of a collision in 64 -bit <b>output</b> <b>blocks</b> is doubled as a result; the second shows artifacts where the same inputs are presented to the key-dependent S-boxes in the final stage of the cipher for two successive outputs. Both distinguishers are demonstrated with experiments on a reduced variant of the cipher...|$|R
5000|$|... 1965 {{also added}} another 350 hp small block engine (Option L79) which used {{hydraulic}} rather than solid lifters, a milder camshaft and a modestly redesigned smaller oil pan. Otherwise, the 350 hp engine was cosmetically and mechanically {{identical to the}} 365 hp engine (Option L76) solid lifter engine. The smaller oil pan allowed this high <b>output</b> small <b>block</b> 350hp engine to be ordered with optional Power Steering {{for the first time}} amongst the optional stable of higher <b>output</b> small <b>block</b> engines. Power steering was previously only available with the lower 250 hp and 300 hp engines.|$|R
5000|$|Blocking: This type {{of network}} cannot realize all {{possible}} connections between inputs and outputs. This is because {{a connection between}} one free input to another free <b>output</b> is <b>blocked</b> by an existing connection in network.|$|R
5000|$|A {{block cipher}} {{consists}} of two paired algorithms, one for encryption, E, {{and the other for}} decryption, D. Both algorithms accept two inputs: an input block of size n bits and a key of size k bits; and both yield an n-bit <b>output</b> <b>block.</b> The decryption algorithm D is defined to be the inverse function of encryption, i.e., D = Eâˆ’1. More formally, a block cipher is specified by an encryption functionwhich takes as input a key K of bit length k, called the key size, and a bit string P of length n, called the block size, and returns a string C of n bits. P is called the plaintext, and C is termed the ciphertext. For each K, the function EK(P) is required to be an invertible mapping on {0,1}n. The inverse for E is defined as a functiontaking a key K and a ciphertext C to return a plaintext value P, such that ...|$|E
3000|$|The {{measured}} data y [...] i, which are generator outputs in this paper, {{are divided into}} two parts representing past and future, and formed into an <b>output</b> <b>block</b> Hankel matrix [19], H: [...]...|$|E
30|$|Lemma 1 {{shows the}} {{recovery}} probability of each Layer i increases {{with the number}} of the received symbols, which is in accordance with our intuition. Furthermore, given a fixed received ratio of output symbols, we have Lemma 2 when the <b>output</b> <b>block</b> size N increases with a fixed overall coding rate Î³.|$|E
40|$|Abstractâ€”In {{digital signal}} {{processing}} applications involving filtering long sequences, block filtering methods like overlap-save and overlap-add are widely used. Like all finite-precision applications, overlap-save and overlap-add methods are also affected by quantization errors. The goal {{of this paper is}} to calculate and make a quantitative comparison of the overall quantization noise resulting from the two methods in terms of power (variance) of the quantization noise. Multiple quantization noise sources are taken into consideration in the computation of the variances. The calculations reveal that the overlap-add approach is more prone to quantization noise compared to the overlap-save approach due to the addition of overlapping sections between overlap-add <b>output</b> <b>blocks.</b> Keywords-block filter; quantization noise; overlap-add; overlap-save; I...|$|R
50|$|The Enhanced Full Rate (GSM 06.60) {{technical}} specification describes the detailed mapping between input blocks of 160 speech samples in 13-bit uniform PCM format to encoded blocks of 244 bits and from encoded blocks of 244 bits to <b>output</b> <b>blocks</b> of 160 reconstructed speech samples. It also specifies the conversion between A-law or Î¼-law (PCS 1900) 8-bit PCM and 13-bit uniform PCM. This part of specification also describes the codec {{down to the}} bit level, thus enabling the verification of compliance to the part to {{a high degree of}} confidence by use of a set of digital test sequences. These test sequences are described in GSM 06.54 and are available on disks.|$|R
40|$|Abstractâ€”Search engines {{have become}} an {{indispensable}} tool for browsing information on the Internet. The user, however, is often annoyed by redundant results from irrelevant web pages. One reason is because search engines also look at non-informative blocks of web pages such as advertisement, navigation links, etc. In this paper, we propose a fast algorithm called FastContentExtractor to automatically detect main content blocks in a web page by improving the ContentExtractor algorithm. By automatically identifying and storing templates representing the structure of content blocks in a website, content blocks of a new web page from the website can be extracted quickly. The hierarchical order of the <b>output</b> <b>blocks</b> is also maintained which guarantees that the extracted content blocks {{are in the same}} order as the original ones...|$|R
