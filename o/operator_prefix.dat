3|60|Public
5000|$|Occurrence of an {{increment}} or a decrement <b>operator</b> (<b>prefix</b> or postfix) (++, --).|$|E
50|$|In Example 2 the + sign is introduced, {{meant to}} {{represent}} addition of natural numbers. Its definition is {{almost identical to}} the previous one, with input and output sorts {{but there is a}} difference, its operator has underscores on each side. Maude lets the user specify whether or not operators are infix, postfix or prefix (default), this is done using underscores as place fillers for the input terms. So the + operator takes its input on each side making it an infix operator. Unlike our previous operator s which takes its input terms after the <b>operator</b> (<b>prefix).</b>|$|E
5000|$|The {{position}} of the operator with respect to its operands may be prefix, infix or postfix, and the syntax of an expression involving an operator depends on its arity (number of operands), precedence, and (if applicable), associativity. Most programming languages support binary operators and a few unary operators, with a few supporting more operands, such as the ?: operator in C, which is ternary. There are prefix unary operators, such as unary minus , and postfix unary operators, such as post-increment and binary operations are infix, such as [...] or [...] Infix operations of higher arity require additional symbols, such as the ternary operator ?: in C, written as [...] - indeed, {{this is the only}} common example, it {{is often referred to as}} the ternary <b>operator.</b> <b>Prefix</b> and postfix operations can support any desired arity, however, such as [...]|$|E
40|$|The initial {{breakthrough}} {{in our understanding}} of natural language quantification came with Frege’s insight that quantifiers are <b>operators</b> <b>prefixed</b> to an open sentence, binding a variable inside it. An examination of predicate logic formulae highlights features of the logical calculus that continue to be of relevance in current thinking on the topic o...|$|R
50|$|The {{rightmost}} {{column of}} the table indicates how each mathematical notation example can be represented by a lambda term, also converting common infix <b>operators</b> into <b>prefix</b> form.|$|R
2500|$|The <b>prefix</b> <b>operator</b> {{combines}} {{an event}} and {{a process to}} produce a new process. For example, ...|$|R
40|$|AbstractTPALp is an {{algebraic}} language for {{the description of}} concurrent systems with capabilities to express timed and probabilistic behaviours, as well as urgent interactions. In this paper we present the main features of the language, its operational semantics, and a translation of TPALp terms into a particular class of timed-probabilistic Petri nets. The language includes a probabilistic choice <b>operator,</b> a timed <b>prefix</b> <b>operator,</b> and an urgent <b>prefix</b> <b>operator,</b> {{as well as some}} other operators that we may find in classical process algebras. An important feature of the language is that urgency is considered at any instant by executing as many urgent actions as possible, with the goal of complying in a great extent with the urgent actions indicated in the user specifications...|$|R
40|$|The {{implementation}} of integrated circuits {{becomes more and}} more difficult in the Ultra-Deep-Submicron regime due to sub-wavelength lithography issues. An approach called Brick-Based Design was recently proposed to eliminate the disadvantages of staying with the classical approach to layout design. Prefix adders are a core component {{in a wide variety of}} applications due to their high speed and regular topology. In this paper, a modified <b>prefix</b> <b>operator</b> for <b>prefix</b> adders is proposed which is well suited for brick-style layout implementation and, in addition, offers an increase in efficiency. The proposed operator makes it possible to use a mirror gate for the generation of both generate and propagate signals, which exhibits a forbidden input signal combination. This "forbidden state" causes an increase in power dissipation due to transient short circuit currents. The effect of the forbidden state was quantified as part of a comparison against the classical <b>prefix</b> <b>operator,</b> based on 64 -bit Sklansky adders implemented in a 40 -nm CMOS technology. The effects of the forbidden state were found to be well acceptable. The {{implementation of}} the adder based on the proposed <b>prefix</b> <b>operator</b> reduces the area by 29 % while increasing the power by 13 % compared to one based on the classical operator...|$|R
40|$|Nested sequent {{systems for}} modal logics are a {{relatively}} recent development, within the general area known as deep reasoning. The idea of deep reasoning is to create systems within which one operates at lower levels in formulas than just those involving the main connective or <b>operator.</b> <b>Prefixed</b> tableaus go back to 1972, and are modal tableau systems with extra machinery to represent accessibility in a purely syntactic way. We show that modal nested sequents and prefixed modal tableaus are notational variants of each other, roughly {{in the same way}} that Gentzen sequent calculi and tableaus are notational variants. This immediately gives rise to new modal nested sequent systems which may be of independent interest. We discuss some of these, including those for some justification logics that include standard modal operators. ...|$|R
50|$|In {{terms of}} {{operator}} position, an <b>operator</b> may be <b>prefix,</b> postfix, or infix. A <b>prefix</b> <b>operator</b> immediately precedes its operand, as in −x. A postfix operator immediately succeeds its operand, as in x! for instance. An infix operator is positioned in between a left and a right operand, as in x+y. Some languages, {{most notably the}} C-syntax family, stretches this conventional terminology and speaks also of ternary infix operators (a?b:c). Theoretically it would even be possible (but not necessarily practical) to define parenthesization as a unary bifix operation.|$|R
50|$|Mathematically {{oriented}} languages (such as {{on scientific}} calculators) sometimes allow implicit multiplication with higher priority than <b>prefix</b> <b>operators</b> (such as sin), so that sin 2x+1 = (sin(2x))+1, for instance.|$|R
40|$|We {{describe}} a scheme for constructing parsers for precedence grammars {{based on the}} combinators described in [4]. The new combinators provide a robust method for building parsers and help avoid {{the possibility of a}} non-terminating parser. Efficiency is improved via an optimisation to the grammar. A number of approaches to the problem are described [...] the most elegant and efficient method is based on continuation passing. A parser for the expression part of the C programming language is presented. 1 Introduction In this paper, we use the parsing combinators described in [4] to construct a set of higher-level combinators designed specifically to handle precedence grammars. This set is open ended [...] we have chosen to implement functions to handle the most common expressions syntaxes; specifically, there are combinators for infix binary <b>operators,</b> <b>prefix</b> and postfix unary operators, subexpressions and atoms. In Section 5 we develop some specialised combinators to handle some of the more un [...] ...|$|R
50|$|Conway {{polyhedron}} notation {{is another}} way to describe these polyhedra, starting with a regular form, and applying <b>prefix</b> <b>operators.</b> The notation doesn't imply which faces should be made regular beyond the uniform solutions of the Archimedean solids.|$|R
5000|$|It is {{symbolized by}} the <b>prefix</b> <b>operator</b> J and by the infix {{operators}} XOR (...) , EOR, EXOR, ⊻, ⊕, ↮, and &#8802;. The negation of XOR is logical biconditional, which outputs true only when both inputs are the same.|$|R
5000|$|Northern Cyprus {{uses the}} prefix block of [...] "1BA-1BZ", {{which has not}} been {{allocated}} by the ITU, for its radio operation. There is regular tension with the block's use, especially for visitors to the north who sign with a [...] "1B/" [...] <b>prefix.</b> <b>Operators</b> in the south tell them to use [...] "5B/".|$|R
40|$|We study two {{different}} ways to enhance PAFAS, a process algebra for modelling asynchronous timed concurrent systems, with non-blocking reading actions. We first add reading {{in the form of}} a read-action <b>prefix</b> <b>operator.</b> This operator is very flexible, but its somewhat complex semantics requires two types of transition relations. We also present a read-set <b>prefix</b> <b>operator</b> with a simpler semantics, but with syntactic restrictions. We discuss the expressiveness of read prefixes; in particular, we compare them to read-arcs in Petri nets and justify the simple semantics of the second variant by showing that its processes can be translated into processes of the first with timed-bisimilar behaviour. It is still an open problem whether the first algebra is more expressive than the second; we give a number of laws that are interesting in their own right, and can help to find a backward translation. ...|$|R
30|$|The “:=” {{operator}} both declares and initializes a variable. The arrow is {{the operator}} used both for sending (as an infix operator) and receiving (as a <b>prefix</b> <b>operator).</b> The close operation closes a channel so a receiver can {{know that there}} is no further data going through it (once all buffered messages have been consumed).|$|R
50|$|Parse {{expressions}} {{are written}} in the parse dialect, which, like the do dialect, is an expression-oriented sublanguage of the data exchange dialect. Unlike the do dialect, the parse dialect uses keywords representing operators {{and the most important}} nonterminals, infix parsing <b>operators</b> don't have <b>prefix</b> equivalents and use precedence rules (sequence has higher precedence than choice).|$|R
5000|$|For numeric literals, {{the type}} of the cooked literal is either [...] for {{integral}} literals or [...] for floating point literals. (Note: There {{is no need for}} signed integral types because a sign-prefixed literal is parsed as an expression containing the sign as a unary <b>prefix</b> <b>operator</b> and the unsigned number.) There is no alternative template form: ...|$|R
5000|$|Chapter 12 of the Unicode {{specification}} {{defines a}} syntax for [...] "Ideographic Description Sequences" [...] (IDSes) {{intended for use}} in describing characters {{not included in the}} standard in terms of combinations of components that do have code points. Twelve special characters in the range U+2FF0 to U+2FFB act as <b>prefix</b> <b>operators</b> to combine other characters or sequences to form larger characters.|$|R
5000|$|Let σx φ(x) {{denote the}} mereological sum (fusion) of all {{individuals}} in the domain satisfying φ(x). σ is a variable binding <b>prefix</b> <b>operator.</b> The axioms of GEM assure that this sum exists if φ(x) is a first-order formula. With σ and the relation IP in hand, we can define the interior of x, [...] as the mereological sum of all interior parts z of x, or: ...|$|R
5000|$|SequenceL is {{strictly}} evaluated (like Lisp), statically typed with type inference (like Haskell), {{and uses a}} combination of infix and <b>prefix</b> <b>operators</b> that resemble standard, informal mathematical notation (like C, Pascal, Python, etc.). It is a purely declarative language, meaning that a programmer defines functions, in the mathematical sense, without giving instructions for their implementation. For example, the mathematical definition of matrix multiplication is as follows: ...|$|R
5000|$|In the United Kingdom, BT {{introduced}} [...] "Linkline" [...] on 12 November 1985. No more need to manually {{ring the}} <b>operator,</b> two new <b>prefixes</b> 0800 (an automated toll-free service which became [...] "Freefone") and 0345 (a shared-cost service marketed as [...] "Lo-Call" [...] because initially its rates resembled those of local calls) {{could be reached}} by direct dial. Cable and Wireless used 0500 and 0645, {{in much the same}} way, just a few years later.|$|R
40|$|State {{of the art}} quality {{assurance}} for safety critical software systems requires formal methods for verification and testing. The context of this thesis is the field of specification based testing of embedded reactive real-time systems. The authors present an approach to reduce the problem of state explosions using {{a representation of the}} transition system of a CSP specification, that does not require the calculation of the complete state space. The new representation consists of two parts: High-Level transition graphs (HLTG) to model sequential processes containing only low-level CSP operators and synchronisation terms that represent the high-level communication structure of sequential components expressed using high-level transition graphs. HLTG are an extension of conventional transition systems, which contain events, conditions and assignments of CSP specifications at the transitions, containing parameters and parametrised expressions. The value of a parameter is bound through assignments at transitions, which are created for the CSP <b>operators</b> <b>prefixing</b> and process references. A node in a HLTG can represent multiple states of the complete state space. The interpretation of a HLTG requires the evaluation of the conditions, events and assignments of a transition to perform a state change. Real-time testing requires an upper bound of time required for the calculation of the initial actions and refusals of a location. This can be achieved by using normalised transition systems. Different stages of the normalisation of HLTG and synchronisation terms have been developed. To enable real-time testing with unnormalised graphs, an on-the-fly normalisation is introduced. For those cases, where test evaluation needs not to be performed in real-time, a new test algorithm for a delayed test evaluation is suggested, which can be used for testing purposes based on any type of transition systems, even unnormalised systems...|$|R
25|$|Scheme is {{primarily}} a functional programming language. It shares many characteristics {{with other members of}} the Lisp programming language family. Scheme's very simple syntax is based on s-expressions, parenthesized lists in which a <b>prefix</b> <b>operator</b> is followed by its arguments. Scheme programs thus consist of sequences of nested lists. Lists are also the main data structure in Scheme, leading to a close equivalence between source code and data formats (homoiconicity). Scheme programs can easily create and evaluate pieces of Scheme code dynamically.|$|R
40|$|AbstractWe study a new {{operator}} of projection onto {{state and the}} <b>prefix</b> <b>operator</b> in the extension μHDC of DC by quantifiers over state and a polyadic least fixed point operator. We give axioms and rules to enable deduction in the extension of μHDC by the new operators. Our axioms {{can be used to}} eliminate the new operators from formulas in a practically significant fragment of μHDC. This entails the decidability of certain subfragments of this fragment is preserved {{in the presence of the}} new operators...|$|R
5000|$|Syntactically {{operators}} usually {{contrast to}} functions. In most languages, functions {{may be seen}} as a special form of <b>prefix</b> <b>operator</b> with fixed precedence level and associativity, often with compulsory parentheses e.g. [...] (or [...] in LISP). Most languages support programmer-defined functions, but cannot really claim to support programmer-defined operators, unless they have more than prefix notation and more than a single precedence level. Semantically operators can be seen as special form of function with different calling notation and a limited number of parameters (usually 1 or 2).|$|R
5000|$|The [...] {{function}} normally {{follows a}} prefix style of evaluation, where a function processes {{the arguments that}} follow it. However, infix evaluation using infix operators exists too. Infix evaluation takes precedence over the prefix evaluation. For example, abs -2 + 3returns 1, since the infix addition takes precedence over the computation of the absolute value. When evaluating infix expressions, the order of evaluation is left to right, no operator takes precedence over another. For example,2 + 3 * 4returns 20, while an evaluation giving precedence to multiplication would yield 14. All <b>operators</b> have <b>prefix</b> versions. [...] usually evaluates arguments before passing them to a function. So, the below expression:print read http://en.wikipedia.org/wiki/Rebolfirst reads the Wikipedia Rebol page and then passes the result to the [...] function. Parentheses {{can be used to}} change the order of evaluation. Using prefix notation, the usage of parentheses in expressions can be avoided.|$|R
50|$|Operator {{associativity}} determines {{what happens}} when an operand is surrounded by operators of the same precedence, as in 1-2-3: An operator can be left-associative, right-associative, or non-associative. Left-associative operators are applied to operands in left-to-right order while right-associative operators are the other way round. The basic arithmetic operators are normally all left-associative, which means that 1-2-3 = (1-2)-3 ≠ 1-(2-3), for instance. This does not hold true for higher operators. For example, exponentiation is normally right-associative in mathematics, but is implemented as left-associative in some computer applications like Excel. In programming languages where assignment is implemented as an operator, that operator is often right-associative. If so, a statement like a := b := c would be equivalent to a := (b := c), {{which means that the}} value of c is copied to b which is then copied to a. An operator which is non-associative cannot compete for operands with operators of equal precedence. In Prolog for example, the infix operator :- is non-associative, so constructs such as a :- b :- c are syntax errors. Unary <b>prefix</b> <b>operators</b> such as − (negation) or sin (trigonometric function) are typically associative <b>prefix</b> <b>operators.</b> When more than one associative <b>prefix</b> or postfix <b>operator</b> of equal precedence precedes or succeeds an operand, the operators closest to the operand goes first. So −sin x = −(sin x), and sin -x = sin(-x).|$|R
5000|$|... is {{evaluated}} as follows: Prolog {{attempts to}} prove the [...] If a proof for that goal can be found, the original goal (i.e., [...] ) fails. If no proof can be found, the original goal succeeds. Therefore, the [...] <b>prefix</b> <b>operator</b> is called the [...] "not provable" [...] operator, since the query [...] succeeds if Goal is not provable. This kind of negation is sound if its argument is [...] "ground" [...] (i.e. contains no variables). Soundness is lost if the argument contains variables. In particular, the query [...] can now {{not be used to}} enumerate all things that are legal.|$|R
2500|$|... is {{evaluated}} as follows: Prolog {{attempts to}} prove illegal(X). If a proof for that goal can be found, the original goal (i.e., \+ illegal(X)) fails. If no proof can be found, the original goal succeeds. Therefore, the \+/1 <b>prefix</b> <b>operator</b> {{is called the}} [...] "not provable" [...] operator, since the query ?- \+ Goal. succeeds if Goal is not provable. This kind of negation is sound if its argument is [...] "ground" [...] (i.e. contains no variables). Soundness is lost if the argument contains variables and the proof procedure is complete. In particular, the query ?- legal(X). can now {{not be used to}} enumerate all things that are legal.|$|R
40|$|We {{introduce}} the process calculus Multi-CCS, which extends conservatively CCS with an <b>operator</b> of strong <b>prefixing</b> able to model atomic sequences of actions {{as well as}} multiparty synchronization. Multi-CCS {{is equipped with a}} labeled transition system semantics, which makes use of a minimal structural congruence. Multi-CCS is also equipped with an unsafe P/T Petri net semantics by means of a novel technique. This is the first rich process calculus, including CCS as a subcalculus, which receives a semantics in terms of unsafe, labeled P/T nets. The main result of the paper is that a class of Multi-CCS processes, called finite-net processes, is able to represent all finite (reduced) P/T nets. ...|$|R
40|$|We give {{sound and}} {{complete}} proof systems {{for a variety}} of bisimulation based equivalences over a message-passing process algebra. The process algebra is a generalisation of pure CCS where the actions consist of receiving and sending messages or data on communication channels; the standard <b>prefixing</b> <b>operator</b> a:p is replaced by the two operators c?x:p and c!e:p and in addition messages can be tested by a conditional construct. The various proof systems are parameterised on auxiliary proof systems for deciding on equalities or more general boolean identities over the expression language for data. The completeness of these proof systems are thus relative to the completeness of the auxiliary proof systems...|$|R
5000|$|... is {{evaluated}} as follows: Prolog {{attempts to}} prove [...] If a proof for that goal can be found, the original goal (i.e., [...] ) fails. If no proof can be found, the original goal succeeds. Therefore, the [...] <b>prefix</b> <b>operator</b> {{is called the}} [...] "not provable" [...] operator, since the query [...] succeeds if Goal is not provable. This kind of negation is sound if its argument is [...] "ground" [...] (i.e. contains no variables). Soundness is lost if the argument contains variables and the proof procedure is complete. In particular, the query [...] can now {{not be used to}} enumerate all things that are legal.|$|R
40|$|Abstract. Two of the {{significant}} issues in Service Oriented Architecture (SOA) are, first, the compositional analysis (and construction) of ser-vices and, second, the analysis and modeling of service communication. Existing formalisms {{to address these issues}} that have been investigated include petri nets and process algebras. The objective of this report is to delineate an appropriate class of petri nets, suitable for the modeling of communicating processes (services) with value (message) passing, ex-tending our results in [3, 4]. This involves defining appropriate <b>operators,</b> such as <b>prefix,</b> choice and, more significantly, concurrent composition. It also involves demonstrating how recursive equations can be solved in such a class of petri nets, providing the necessary semantic background for recursively definable processes...|$|R
40|$|Abstract. We give {{sound and}} {{complete}} proof systems {{for a variety}} of bisimu-lation based equivalences over a message-passing process algebra. The process algebra is a generalisation of CCS where the actions consist of receiving and sending messages or data on communication channels; the standard <b>prefixing</b> <b>operator</b> a. p is replaced by the two operators c?x. p and c!e. p and in addition messages can be tested by a conditional construct. The various proof sys-tems are parameterised on auxiliary proof systems for deciding on equalities or more general boolean identities over the expression language for data. The completeness of these proof systems are thus relative to the completeness of the auxiliary proof systems. ...|$|R
