15|34|Public
50|$|<b>Object</b> <b>deletion</b> {{is rarely}} {{used as the}} {{scripting}} engine will garbage collect objects that are no longer being referenced.|$|E
40|$|Rappaport Hovav and Levin 1998 {{contend that}} result verbs {{disallow}} <b>object</b> <b>deletion</b> because () of their lexical semantic properties. Their {{point is that}} the distinction between result verbs and manner verbs with their different event structure representation constitutes the important factor which dictates the possibility of the variation of argument realization, of which <b>object</b> <b>deletion</b> represents one instance. Responding to their claim, Goldberg 2001 presents the evidence () () which mainly concerns the <b>object</b> <b>deletion</b> of causative verbs which correspond to result verbs in English in order to show that the distinction is not substantial. The {{purpose of this paper is}} two-fold. One is to present several pieces of evidence for Goldberg's contention based on the behavior of causative verbs with respect to <b>object</b> <b>deletion.</b> It is made evident that causative verbs in fact behave even freer than Goldberg's principle predicts. The other purpose is to examine some aspects of Goldberg's principle and demonstrate that it has wider applicability than originally intended, which eventually indicates that the principle comprises a part of a general set of conditions on the <b>object</b> <b>deletion</b> in English. The conclusion is that <b>object</b> <b>deletion</b> is not so much sensitive to the distinction between causative verbs and non-causative verbs as Rappaport Hovav and Levin claim it to be and therefore, <b>object</b> <b>deletion</b> fails to be a good diagnostic tool for the differentiation of the two verb classes. In other words, causativity is not a good parameter for the possibility of <b>object</b> <b>deletion.</b> 1...|$|E
40|$|Rappaport Hovav and Levin (1998) {{contend that}} result verbs {{disallow}} <b>object</b> <b>deletion</b> becauseof their lexical semantic properties. Their {{point is that}} the distinction between result verbs andmanner verbs with their different event structure representation constitutes the important factorwhich dictates the possibility of the variation of argument realization, of which object deletionrepresents one instance. Responding to their claim, Goldberg (2001) presents the evidencewhich mainly concerns the <b>object</b> <b>deletion</b> of causative verbs (which correspond to result verbs) in English in order to show that the distinction is not substantial. The purpose of this paper istwo-fold. One is to present several pieces of evidence for Goldberg 2 ̆ 7 s contention based on thebehavior of causative verbs with respect to <b>object</b> <b>deletion.</b> It is made evident that causative verbsin fact behave even freer than Goldberg 2 ̆ 7 s principle predicts. The other purpose is to examine someaspects of Goldberg 2 ̆ 7 s principle and demonstrate that it has wider applicability than originallyintended, which eventually indicates that the principle comprises a part of a general set ofconditions on the <b>object</b> <b>deletion</b> in English. The conclusion is that <b>object</b> <b>deletion</b> is not so muchsensitive to the distinction between causative verbs and non-causative verbs as Rappaport Hovavand Levin claim it to be and therefore, <b>object</b> <b>deletion</b> fails to be a good diagnostic tool for thedifferentiation of the two verb classes. In other words, causativity is not a good parameter for thepossibility of <b>object</b> <b>deletion...</b>|$|E
5000|$|It {{distinguishes between}} {{constituents}} (sub-objects) and object acquaintances (pointers to independent <b>objects).</b> Copying and <b>deletion</b> of complex <b>objects</b> is largely facilitated in this way.|$|R
40|$|In a {{one-shot}} change detection task, we investigated {{the relationship between}} semantic properties (high consistency, i. e., diagnosticity, versus inconsistency with regard to gist) and perceptual properties (high versus low salience) of objects in guiding attention in visual scenes and in constructing scene representations. To produce the change an object was added or deleted in either the right or left half of coloured drawings of daily-life events. Diagnostic <b>object</b> <b>deletions</b> were more accurately detected than inconsistent ones, indicating rapid inclusion into early scene representation for the most predictable objects. Detection was faster and more accurate for high salience than for low salience changes. An advantage was found for diagnostic object changes in the high salience condition, although it was limited to additions when considering response speed. For inconsistent objects of high salience, deletions were detected faster than additions. These findings may indicate that objects are primarily selected on a perceptual basis with subsequent and supplementary effect of semantic consistency, {{in the sense of}} facilitation due to object diagnosticity or lengthening of processing time due to inconsistency...|$|R
40|$|International audienceIn {{this paper}} {{we present a}} new {{technique}} to dynamically adapt the first step (broad phase) of the collision detection process on hardware architecture during simulation. Our approach enables to face the unpredictable evolution of the simulation scenario (this includes addition of complex <b>objects,</b> <b>deletion,</b> split into several objects, [...] .). Our technique of dynamic adaptation is performed on sequential CPU, multi-core, single GPU and multi-GPU architectures. We propose to use off-line simulations to determine fields of optimal performance for broad phase algorithms and use them during in-line simulation. This is achieved by a features analysis of algorithmic performances on different architectures. In this way we ensure the real time adaptation of the broad-phase algorithm during the simulation, switching it to a more appropriate candidate. We also present a study on how graphics hardware parameters (number of cores, bandwidth, [...] .) can influence algorithmic performance. The goal of this analysis is {{to know if it}} is possible to find a link between variations of algorithms performances and hardware parameters. We test and compare our model on 1, 2, 4 and 8 cores architectures and also on 1 Quadro FX 3600 M, 2 Quadro FX 4600 and 4 Quadro FX 5800. Our results show that using this technique during the collision detection process provides better performance throughout the simulation and enables to face unpredictable scenarios evolution in large-scale virtual environments...|$|R
40|$|Constructions {{surfacing}} as intransitive {{are highly}} ambiguous in English. They {{may be the}} reflection of a true intransitive verb or, rather, the result {{of one of the}} linguistic processes which derive an intransitive construction from a canonical transitive one (e. g. contextual deletion of an understood <b>object,</b> <b>deletion</b> of an optional reflexive marker or disergativization). This type of lexical/structural ambiguity poses many problems in Machine Translation. In this article we offer a possible solution which has been implemented in JULIETTA, a Lexical-Functional Grammar-based machine translation prototyp...|$|E
40|$|Abstract- The {{filling-in}} missing {{region in}} an image is called image Inpainting. Inpainting strategies {{play a significant}} role in numerous applications like <b>object</b> <b>deletion,</b> scratch deletion, Image restoration. The inpainted of a rough version of the input image allows to reduce the machine difficulty, to be less sensitive to noise and to work with the dominant orientations of image structures. During this paper, to achieve inpaint function based on Curvature driven diffusion inpainting and total variation image inpainting. Additionally to compute the signal to noise quantitative relation of several inpainting style. Keywords- Image inpainting, Super resolution based inpainting, filling-in, exemplar-based inpainting. I...|$|E
40|$|Although 4 -month-olds {{perceive}} {{continuity of}} an object's trajectory through occlusion, {{little is known}} about the information specifying an occluding surface at this age. We investigated this in 3 experiments involving 84 participants. Testing the claim that 5 -month-olds are unable to perceive the Kanizsa figure as an occluding surface (Csibra, 2001), we demonstrated that 4 -month-olds perceived trajectory continuity behind this figure providing its horizontal extent was small. We demonstrated that the presence of visible occluding edges or occlusion of background was insufficient to specify an occluding surface but that their combination was sufficient. Thus, beyond <b>object</b> <b>deletion</b> and accretion, both visible occluding edges and occlusion of background are necessary for perception of occluding surfaces at this age...|$|E
5000|$|The naive {{algorithm}} {{described above}} can't handle , an object which refers {{directly or indirectly}} to itself. A mechanism relying purely on reference counts will never consider cyclic chains of <b>objects</b> for <b>deletion,</b> since their reference count is guaranteed to stay nonzero. Methods for dealing with this issue exist but can also increase the overhead and complexity of reference counting — on the other hand, these methods need only be applied to data that might form cycles, often a small subset of all data. One such method {{is the use of}} weak references, while another involves using a mark-sweep algorithm that gets called infrequently to clean up.|$|R
5000|$|The primary {{motivation}} for slab allocation {{is that the}} initialization and destruction of kernel data objects can actually outweigh the cost of allocating memory for them. [...] As <b>object</b> creation and <b>deletion</b> are widely employed by the kernel, overhead costs of initialization can result in significant performance drops. The notion of object caching was therefore introduced {{in order to avoid}} the invocation of functions used to initialize object state.|$|R
40|$|Factory and Factory Method. Implementations {{of these}} {{patterns}} could register dynamically allocated <b>objects</b> for <b>deletion</b> at program termination. Alternatively (or additionally), they could provide interfaces for object destruction, corresponding {{to those for}} object creation. Cargill presented a taxonomy of the dynamic C++ object lifetime [16]. The Localized Ownership pattern language includes patterns, such as Creator-as-Owner, Sequence-ofOwners, and Shared Ownership, which primarily address object ownership. Ownership conveys the responsibility for destruction. Creator-as-Owner is further subdivided into Function-asOwner, Object-as-Owner, and Class-as-Owner. The Singleton destruction capability of Object Lifetime Manager {{may be viewed as}} new category of Creator-as-Owner: Program-asOwner. It is distinct from Function-as-Owner, because static objects outlive the program entry point (main). Object Lifetime Manager's Preallocated Objects similarly can be viewed logically, at least, as ou [...] ...|$|R
40|$|Abstract. The M-tree is a paged, {{dynamically}} balanced metric {{access method}} that responds gracefully to {{the insertion of}} new objects. Like many spatial access methods, the M-tree’s performance is largely dependent {{on the degree of}} overlap between spatial regions represented by nodes in the tree, and minimisation of overlap is key to many of the design features of the M-tree and related structures. We present a novel approach to overlap minimisation using a new bulk loading algorithm, resulting in a query cost saving of between 25 % and 40 % for non-uniform data. The structural basis of the new algorithm suggests a way to modify the M-tree to produce a variant which we call the SM-tree. The SM-tree has the same query performance after bulk loading as the M-tree, but further supports efficient <b>object</b> <b>deletion</b> while maintaining the usual balance and occupancy constraints. ...|$|E
40|$|Curb {{detection}} is {{an important}} research topic in environment perception, which {{is an essential part}} of unmanned ground vehicle (UGV) operations. In this paper, a new curb detection method using a 2 D laser range finder in a semi-structured environment is presented. In the proposed method, firstly, a local Digital Elevation Map (DEM) is built using 2 D sequential laser rangefinder data and vehicle state data in a dynamic environment and a probabilistic moving <b>object</b> <b>deletion</b> approach is proposed to cope with the effect of moving objects. Secondly, the curb candidate points are extracted based on the moving direction of the vehicle in the local DEM. Finally, the straight and curved curbs are detected by the Hough transform and the multi-model RANSAC algorithm, respectively. The proposed method can detect the curbs robustly in both static and typical dynamic environments. The proposed method has been verified in real vehicle experiments...|$|E
40|$|This article {{examines}} the phenomenon of object clitic omission in French. Previous research contains contradictory results depending on {{the source of the}} data: it seems that in spontaneous production children prefer DPs while in elicited production they prefer omissions. It is proposed that a common methodology be used across different modalities in measuring the rate of omissions, and that the notion of «illicit object omission» be dispensed with. The analysis of the proposed «clitic-contexts» reveals that the strategy favoured by children is omission of all kinds of lexical material in both spontaneous and elicited production. Moreover, it is shown that child behaviour is quantitatively different from the adult one. These findings have consequences on the status of null objects in child grammar: child grammar allows optional <b>object</b> <b>deletion</b> without clitic recoverability, as opposed to adult grammar. Several theoretical approaches are evaluated {{in the light of the}} new findings...|$|E
40|$|The Tutte {{polynomial}} is {{the most}} general invariant of matroids and graphs that can be computed recursively by deleting and contracting edges. We generalize this invariant to any class of combinatorial <b>objects</b> with <b>deletion</b> and contraction operations, associating to each such class a universal Tutte character by a functorial procedure. We show that these invariants satisfy a universal property and convolution formulae similar to the Tutte polynomial. With this machinery we recover classical invariants for delta-matroids, matroid perspectives, relative and colored matroids, generalized permutohedra, and arithmetic matroids, and produce some new convolution formulae. Our principal tools are combinatorial coalgebras and their convolution algebras. Our results generalize in an intrinsic way the recent results of Krajewski [...] Moffatt [...] Tanasa. Comment: 48 p...|$|R
40|$|Tracking {{unknown number}} of moving objects in {{cluttered}} scenes is an important yet difficult research issue in computer vision. Two fundamental problems encountered are high-dimensional parameter space and complicated situations such as <b>object</b> addition, <b>deletion,</b> and occlusion. The recently proposed CONDENSATION algorithm and its variants enable the estimation of arbitrary multi-modal posterior distributions that potentially represent multiple tracked objects. However, the specific state representation adopted in the earlier work does not explicitly support counting, addition, deletion and occlusions of objects. Furthermore, the representation may increasingly bias the posterior density estimates towards objects with dominant likelihood as the estimation progresses over many frames. In this paper, a novel formulation and an associated CONDENSATION-like sampling algorithm that explicitly support counting, addition and <b>deletion</b> of <b>objects</b> are proposed. We represent all objects in an imag [...] ...|$|R
40|$|We {{propose a}} formal {{real-time}} semantics for UML statecharts {{aimed at the}} requirements level. A requirements-level model assumes perfect technology and has a considerably simpler semantics than an implementation level model. Our semantics is an adaptation of the Statemate statechart semantics, with local variables, real time, identifier addressing, point-to-point communication, synchronous communication and dynamic <b>object</b> creation and <b>deletion.</b> We start with an informal comparison of Statemate and UML statechart semantics and then give a formalisation of our semantics in terms of labelled transition systems...|$|R
40|$|Celeste is {{a robust}} {{peer-to-peer}} object store built {{on top of}} a distributed hash table (DHT). Celeste is a working system, developed by Sun Microsystems Laboratories. During the development of Celeste, we faced the challenge of complete <b>object</b> <b>deletion,</b> and moreover, of deleting “files ” composed of several different objects. This important problem is not solved by merely deleting meta-data, as there are scenarios in which all file contents must be deleted, e. g., due to a court order. Complete file deletion in a realistic peer-topeer storage system has not been previously dealt with due to the intricacy of the problem – the system may experience high churn rates, nodes may crash or have intermittent connectivity, and the overlay network may become partitioned at times. We present an algorithm that eventually deletes all file content, data and meta-data, in the aforementioned complex scenarios. The algorithm is fully functional and has been successfully integrated into Celeste. ...|$|E
40|$|The {{field of}} {{object-oriented}} databases {{is suffering from}} the lack of a [...] -widely agreed upon [...] -formal model. In this paper we develop the basics of a formal model for an object-oriented data model (kernel). The formalization is based on dynamic logic: combining many-sorted algebras with states and state transitions. The many-sorted algebras are utilized to model the static aspects, i. e., the value-oriented part of the object model. The state transitions account for the dynamic behavior of the object base due to object modifications. The main dynamic features that we incorporate in the formal model comprise (object) attribute assignment, object creation, <b>object</b> <b>deletion,</b> and set object manipulation, i. e., removing and inserting elements. The virtues of the proposed model are demonstrated on three sample applications. Dangling references may lead a given program to nonterminate [...] -we will show this fact. Second, a desirable property of a program will be verified. Last, the semantics of a [...] ...|$|E
40|$|Many programmers use custom memory allocators {{hoping to}} achieve {{performance}} improvements. This first in-depth study examines eight applications that use custom allocators. Surprisingly, for six of these applications, a state-of-the-art general-purpose allocator performs {{as well as}} or better than the custom allocators. The two exceptions use regions, which deliver higher performance (up to 44 % faster). Regions also reduce programmer burden and help eliminate a source of memory leaks. We show, however, that the inability of programmers to free individual objects within regions {{can lead to a}} substantial increase in memory consumption (up to 230 % more). To eliminate this excessive memory consumption, we develop the Reap extended general-purpose memory allocator, which combines region semantics with individual <b>object</b> <b>deletion.</b> Reap outperforms similar allocators and comes close to matching region performance while providing the potential for reduced memory consumption. We thus demonstrate an implementation of an extended memory allocation interface that eliminates the need for most custom memory allocators and the programmer effort needed to build and maintain them. 1...|$|E
40|$|In {{databases}} {{of moving}} objects {{it is important}} to answer queries that concern the future positions of the objects. An important query type in such an environment is the nearest-neighbor query, which asks for the k closest objects of a query object during a time interval [ts, te]. However, there are cases where the (k+ 1) -th nearest-neighbor is requested after the execution of the k-NN query. In such a case, either the query must be evaluated again, or we can exploit the previous result and use an incremental method to determine the new answer. We focus on the second alternative and present efficient incremental algorithms that outperform the trivial method which is based on complete re-execution of the query. In addition, we study the problem of keeping the query result consistent in the presence of <b>object</b> insertions, <b>deletions</b> and updates which are very common in a dynamic moving-object environment...|$|R
40|$|The SPIN {{extension}} {{presented in}} this article is meant as a way to facilitate the modeling and verification of object-oriented programs. It provides means for the formal representation of some run-time mechanisms intensively used in OO software, such as dynamic <b>object</b> creation and <b>deletion,</b> virtual function calls, etc. This article presents a number of language extensions along with their implementation in SPIN. We carried out a number of experiments and found out that an important expressibility gain can be achieved with at most a small loss of performance...|$|R
40|$|Object-oriented {{software}} essentially has dynamic aspect such as <b>object</b> creation, <b>deletion</b> {{and dynamic}} binding during execution. This aspect makes behavior analysis and tests of object-oriented software significantly complicated. In this paper, we propose {{a new technique}} of objectoriented software analysis and testing by using Coloured Petri Nets (CPN), which is an extended version of Perti Net, one of formal techniques having the ability to analyze concurrent behavior. We represent identified objects with colored tokens of a CPN expressing object oriented software {{in order to avoid}} the net-explosion problem. We provide translation rules of object-oriented software into a CPN and a technique to analyze and test effectively the net to investigate several behavioral properties. Our translation technique is essentially independent of which language we describe software. As an example, to show the effectiveness of our technique, we pick up UML (Unified Modeling Language) and translate a specification written in it into a CPN. The net is analyzed, tested and simulated as a prototype of the specification. 1...|$|R
40|$|It is {{the purpose}} of this paper to {{consider}} the double object construction in the light of some data of Kihaya and Sesotho, two Bantu languages in which the objects display symmetrical behaviour with respect to word order, cliticisation, passivisation, unspe-cified <b>object</b> <b>deletion,</b> and raising to subject. In some special circumstances, though, such as those where a relation of inalienability holds between the two objects, they cease to behave in the same way. An analysis of inalienability as an anaphoric relation leads us to expect the existence of asymmetry between the two objects; the word order pat-tems and associated syntactic phenomena encountered in these Bantu languages can be accounted for if a structure such as the one proposed by Larson (1988, 1990) for mul-tiple complementation is assumed. This does not require appeal to a directionality parameter, since word order is derived from the hierarchical structure postulated; thus the theory of binding becomes instrumental in the establishment of structure. Key words: African languages, double object structure, inalienability. Resum. Sobre les implicacions de la inalienabilitat per a l'estructura d'objecte dobl...|$|E
40|$|Programmers {{hoping to}} achieve {{performance}} improvements often use custom memory allocators. This in-depth study examines eight applications that use custom allocators. Surprisingly, for six of these applications, a state-of-the-art general-purpose allocator (the Lea allocator) performs {{as well as}} or better than the custom allocators. The two exceptions use regions, which deliver higher performance (improvements of up to 44 %). Regions also reduce programmer burden and eliminate a source of memory leaks. However, we show that the inability of programmers to free individual objects within regions {{can lead to a}} substantial increase in memory consumption. Worse, this limitation precludes the use of regions for common programming idioms, reducing their usefulness. We present a generalization of general-purpose and region-based allocators that we call reaps. Reaps are a combination of regions and heaps, providing a full range of region semantics with the addition of individual <b>object</b> <b>deletion.</b> We show that our implementation of reaps provides high performance, outperforming other allocators with region-like semantics. We then use a case study to demonstrate the space advantages and software engineering benefits of reaps in practice. Our results indicate that programmers needing fast regions should use reaps, and that most programmers considering custom allocators should instead use the Lea allocator...|$|E
40|$|This study {{deals with}} Stylistic {{study on the}} {{language}} used among the Chinese ethnic sellers and buyers at Pasar Atum Surabaya especially on the style of code mixing which commonly called by Pidgin or Creole The writer herself as a Chinese ethnic descent {{is aware of the}} fact that Chinese sellers and buyers at Pasar Atum are unconsciously use words from many languages as they speak. It means that they tend to combine two or more different languages varieties in forming a sentence and a word. This mixing variety used by Chinese sellers and buyers at Pasar Atum would be called by the writer as Surabaya Chinese Creole. In this thesis, the writer wants to limits the discussion on the linguistic features of Surabaya Chinese Creole that is sentence patterns, word classess, morphologycal componence of word construction. sto find out what features which dominantly used and what languages variety do the features belong. In doing her research, the writer uses qualitative approach. She collects the data by recording the conversation between Chinese sellers and buyers at Pasar Atum Surabaya Then, she transcribes and translates it into Standard Indonesian to make the analysis easier. In analyzing the linguistic features, the writer uses a downward analysis. First of all, she classifies the features into four tables. Those tables contain of grammatical features (sentence patterns), morphologycal features (morphemes), phonological features (phonologycal process) and lexical features (contain and function words). In her analysis, the writer finds out that the language variety of Surabaya Chinese Creoles has various sentence patterns, the languages are used are short and simple because of subject and <b>object</b> <b>deletion.</b> The speakers often using function words such as interjection and number than contain words such as nouns and verbs. The language variety used in words and in bound morphemes are mainly dominated by Indonesian variety. Based on her findings, the writer may conclude that in trading communication, of people tend to speak effectively. The using of language variety depends on the situation where they communicate and to whom they contact to each other...|$|E
50|$|A {{committee}} set {{up under}} the Federal Advisory Committee Act monitored the progress of SAP 4.1, and questioned several aspects of the final report. The original plan included maps and estimates of wetland loss from a then-ongoing EPA mapping study conducted by James G. Titus, {{who was also a}} lead author of SAP 4.1. Early drafts included the maps and results, but the final draft did not. Experts and environmental organizations <b>objected</b> to the <b>deletions.</b> The federal advisory committee also took issue with the maps' removal from SAP 4.1 and recommended that EPA publish the mapping study. EPA later confirmed that EPA management had altered the report and suppressed the mapping study, although it declined to explain why.|$|R
40|$|Paulo Borba Programming Research Group Oxford University Computing Laboratory Abstract FOOPS is a functional, concurrent, {{object-oriented}} language. We give {{a structural}} operational semantics for FOOPS, considering features such as: classes of objects with associated methods and attributes, object identity, dynamic <b>object</b> creation and <b>deletion,</b> overloading, polymorphism, inheritance with overriding, concurrency, nondeterminism and atomic execution. 1 Introduction FOOPS is a functional, object-oriented specification language with an executable subset [5, 18]. The functional part of FOOPS {{is derived from}} OBJ [8], which is a first order, purely functional language supporting an algebraic style for the specification, rapid prototyping and implementation of abstract data types. FOOPS extends OBJ by providing a simple declarative style for object-oriented programming and specification using (conditional) equations. It supports classes of objects with associated methods and attributes, ob [...] ...|$|R
40|$|FOOPS is a {{concurrent}} object-oriented language. We give {{a structural}} operational semantics for FOOPS, considering {{features such as}} classes of objects with associated methods and attributes, object identity, dynamic <b>object</b> creation and <b>deletion,</b> overloading, polymorphism, inheritance with overriding, concurrency, nondeterminism, atomic execution, evaluation of expressions as background processes, and object protection. 1 Introduction FOOPS is a concurrent object-oriented specification language with an executable subset [13, 27]. FOOPS includes a functional language derived from OBJ [16], which is a first order, purely functional language supporting an algebraic style for the specification, rapid prototyping, and implementation of abstract data types. FOOPS extends OBJ by providing a simple declarative style for object-oriented programming and specification using (conditional) equations. It supports classes of objects with associated methods and attributes, object identity, dynami [...] ...|$|R
40|$|This paper {{presents}} the first fully dynamic and reactive data structure. Reac tive data structures are vector based structures {{tailored to the}} efficient storage and retrieval of geometric objects {{at different levels of}} detail. Geometric se lections can be interleaved by insertions of new <b>objects</b> and by <b>deletions</b> of existing <b>objects.</b> Detail levels are closely related to cartographic map general ization techniques. The proposed data structure supports the following gener alization techniques: simplification, aggregation, symbolization, and selection. The core of the reactive data structure is the Reactive-tree, a geometric index structure, that also takes care of the selection-part of the generalization. Other aspects of the generalization process are supported by introducing associated structures, e. g. the Binary Line Generalization-tree for simplification. The proposed structure forms an important step {{in the direction of the}} develop ment of a seamless, scaleless geographic database. ...|$|R
40|$|FOOPS is a {{concurrent}} object-oriented language. Based on FOOPS operational semantics, {{we define}} {{a notion of}} refinement, and an associated proof technique. The use of refinement for stepwise formal development of programs in FOOPS is illustrated by examples involving memory cells, and different implementations of buffers. 1 Introduction FOOPS is a concurrent object-oriented specification language with an executable subset [8, 23]. FOOPS includes a functional language derived from OBJ [10], which is a first order, purely functional language supporting an algebraic style for the specification, rapid prototyping, and implementation of abstract data types. FOOPS extends OBJ by providing a simple declarative style for object-oriented programming and specification using (conditional) equations. It supports classes of objects with associated methods and attributes, object identity, dynamic <b>object</b> creation and <b>deletion,</b> overloading, polymorphism, inheritance with overriding, and many additiona [...] ...|$|R
40|$|We propose an {{architecture}} for Digital Library Repositories that assures long-term archival storage of digital objects. The architecture is formed by a federation of independent but collaborating sites, each managing {{a collection of}} digital objects. The architecture {{is based on the}} following key components: use of signatures as <b>object</b> handles, no <b>deletions</b> of digital <b>objects,</b> functional layering of services, the presence of an awareness service in all layers, and use of disposable auxiliary structures. Long-term persistence of digital objects is achieved by creating replicas at several sites. KEYWORDS: Digital library repository, archival storage, long-term preservation of data. 1 INTRODUCTION A digital library repository (DLR) stores the digital objects that constitute the library. The two key requirements that distinguish DLRs from other information stores are archival storage and intellectual property management. The archival nature of a DLR means that the digital objects (e. g., [...] ...|$|R
40|$|OASIS is a Language for the Specification of Object Oriented Conceptual Models. Object Petri Nets (OPNs) {{support a}} full {{integration}} of object-oriented concepts into Petri Nets. We propose {{a way to}} represent objectoriented concepts used in the OASIS language with OPNs as a suitable semantic model for validating software specifications. We have developed a Basic Execution Model for OASIS Specifications including its main features. Communication aspects between objects {{are taken into account}} in our proposal (triggering mechanism and shared events). We will consider event preconditions reducing the worlds to be reached, attribute valuations changing the state of <b>objects,</b> creation and <b>deletion</b> of <b>objects,</b> and life cycles of objects. OPNs are an appropriate semantic foundation over build a concurrent software engineering environment for distributed computation because it allows a natural representation of concurrence. We show how the object-oriented concepts of an OASIS Specification are rep [...] ...|$|R
40|$|Abstract—Authentication of {{multimedia}} contents has gained much attention in recent times. In this paper, we propose a secure semi-fragile watermarking, {{with a choice}} of two watermarks to be embedded. This technique operates in integer wavelet domain and makes use of semi fragile watermarks for achieving better robustness. A self-recovering algorithm is employed, that hides the image digest into some Wavelet subbands to detect possible malevolent object manipulation undergone by the image (<b>object</b> replacing and/or <b>deletion).</b> The Semi-fragility makes the scheme tolerant for JPEG lossy compression as low as quality of 70 %, and locate the tempered area accurately. In addition, the system ensures more security because the embedded watermarks are protected with private keys. The computational complexity is reduced using parameterized integer wavelet transform. Experimental results show that the proposed scheme guarantees the safety of watermark, image recovery and location of the tempered area accurately...|$|R
40|$|Grizzly Bear {{is a new}} demonstrational {{tool for}} specifying user {{interface}} behavior. It can handle multiple application windows, dynamic <b>object</b> instantiation and <b>deletion,</b> changes to any object attribute, and operations on sets of objects. It enables designers to experiment with rubber-banding, deletion by dragging to a trashcan and many other interactive techniques. To the author's best knowledge it is currently the most complete demonstrational user interface design tool that does not base its inferencing on rule-based guessing. There are inherent limitations to the range of user interfaces that can ever be built by demonstration alone. Grizzly Bear is therefore designed to work hand-in-hand with a user interface specification language called the Elements, Events & Transitions model. As designers demonstrate behavior, they can watch Grizzly Bear incrementally build the corresponding textual specification, letting them learn the language on the fly. They can then apply their knowledge [...] ...|$|R
