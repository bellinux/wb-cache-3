416|2306|Public
25|$|The undefinability theorem {{shows that}} this {{encoding}} cannot be done for semantic concepts such as truth. It shows that no sufficiently rich interpreted language can represent its own semantics. A corollary is that any metalanguage capable of expressing the semantics of some <b>object</b> <b>language</b> must have expressive power exceeding that of the <b>object</b> <b>language.</b> The metalanguage includes primitive notions, axioms, and rules absent from the <b>object</b> <b>language,</b> {{so that there are}} theorems provable in the metalanguage not provable in the <b>object</b> <b>language.</b>|$|E
25|$|In 1996, after {{watching}} the growth and development of programming languages like Java, Perl, and Python, Sassenrath decided to publish his own ideas within the world of computer languages. The result was REBOL, the relative expression-based <b>object</b> <b>language.</b>|$|E
25|$|On {{the other}} hand, it is {{possible}} to derive triviality from the 'conflict' between consistency and contradictions, once these notions have been properly distinguished. The very notions of consistency and inconsistency may be furthermore internalized at the <b>object</b> <b>language</b> level.|$|E
30|$|In {{both types}} of Tsou applicatives, {{only one of the}} objects is {{eligible}} for extraction. This aligns Tsou with the Chichewa-type asymmetrical <b>object</b> <b>languages</b> instead of the Kichaga-type symmetrical <b>object</b> <b>languages</b> (Baker 1988, Bresnan and Moshi 1990, Alsina and Mchombo 1993, Marantz 1993, Donohue 1996, McGinnis 2001, among others).|$|R
5000|$|Siewierska, Anna. 1998b. Languages {{with and}} without <b>objects.</b> <b>Languages</b> in Contrast 1.2: 173-190.|$|R
5000|$|OCL (<b>Object</b> Constraint <b>Language).</b> Despite its name, OCL {{is also an}} <b>object</b> query <b>language</b> and an OMG standard; ...|$|R
25|$|Davidson's work is {{well noted}} for its unity, as he has brought a similar {{approach}} {{to a wide variety}} of philosophical problems. Radical interpretation is a hypothetical standpoint which Davidson regards as basic to the investigation of language, mind, action, and knowledge. Radical interpretation involves imagining that you are placed into a community which speaks a language you do not understand at all. How could you come to understand the language? One suggestion is that you know a theory that generates a theorem of the form 's means that p' for every sentence of the <b>object</b> <b>language</b> (i.e. the language of the community), where s is the name of a sentence in the <b>object</b> <b>language,</b> and p is that sentence, or a translation of it, in the metalanguage in which the theory is expressed. However, Davidson rejects that suggestion on the grounds that the sentential operator 'means that' is sensitive not only to the extensions of the terms that follow it, but also to their intensions. Hence, Davidson replaces 'means that' with a connective sensitive only to the extensions of sentences; since the extension of a sentence is its truth value, this is a truth functional connective. Davidson elects the biconditional (if and only if) as the connective needed in a theory of meaning. He concludes that a theory of meaning must be such that for each sentence of the <b>object</b> <b>language</b> it generates a theorem of the form 's is true if and only if p'. A theory of truth for a language can serve as a theory of meaning.|$|E
2500|$|Because {{mathematical}} logic {{has a long}} tradition of distinguishing between <b>object</b> <b>language</b> and metalanguage, logic programming also allows metalevel programming. [...] The simplest metalogic program is the so-called [...] "vanilla" [...] meta-interpreter: ...|$|E
2500|$|Alfred Tarski, a pupil of Łukasiewicz, is {{best known}} for his {{definition}} of truth and logical consequence, and the semantic concept of logical satisfaction. [...] In 1933, he published (in Polish) The concept of truth in formalized languages, in which he proposed his semantic theory of truth: a sentence such as [...] "snow is white" [...] is true if and only if snow is white. [...] Tarski's theory separated the metalanguage, which makes the statement about truth, from the <b>object</b> <b>language,</b> which contains the sentence whose truth is being asserted, and gave a correspondence (the T-schema) between phrases in the <b>object</b> <b>language</b> and elements of an interpretation. [...] Tarski's approach to the difficult idea of explaining truth has been enduringly influential in logic and philosophy, especially in the development of model theory. [...] Tarski also produced important work on the methodology of deductive systems, and on fundamental principles such as completeness, decidability, consistency and definability. According to Anita Feferman, Tarski [...] "changed the face of logic in the twentieth century".|$|E
500|$|There {{are several}} compilers to {{high-level}} <b>object</b> <b>languages,</b> with either unrestricted Python, a restricted subset of Python, or a language similar to Python {{as the source}} language: ...|$|R
40|$|International audienceTo program {{parallel}} systems {{efficiently and}} easily, {{a wide range}} of programming models have been proposed, each with different choices concerning synchronization and communication between parallel entities. Among them, the actor model is based on loosely coupled parallel entities that communicate by means of asynchronous messages and mailboxes. Some actor languages provide a strong integration with object-oriented concepts; these are often called active <b>object</b> <b>languages.</b> This paper reviews four major actor and active <b>object</b> <b>languages</b> and compares them according to carefully chosen dimensions that cover central aspects of the programming paradigms and their implementation...|$|R
40|$|The {{efficiency}} of dynamic dispatch {{is a major}} impediment {{to the adoption of}} multi-methods in <b>object</b> <b>languages.</b> In this paper, we propose a simple multi-method dispatch scheme based on compressed dispatch tables. This scheme is applicable to most existing <b>object</b> <b>languages,</b> and guarantees that dynamic dispatch is performed in constant time, a major requirement for some languages and applications. We provide efficient algorithms to build the compressed dispatch tables, and demonstrate the effectiveness of our scheme by real measurements performed on a large object-oriented application. Finally, we relate our scheme to existing techniques, including a detailed comparison with a recent proposal...|$|R
2500|$|In {{one of the}} {{articles}} in The Critical Difference, “Melville’s Fist: The Execution of Billy Budd,” Johnson reads Herman Melville’s novel as a performance of the irreconcilability between the [...] “signifier” and the “signified.” She argues that if a description could perfectly describe its referent and actually “hit” its intended object (just as Billy Budd hits and kills John Claggart), {{the result would be}} the annihilation of that <b>object.</b> <b>Language,</b> thus, can only function upon imperfection, instability, and unknowability.|$|E
2500|$|A curious {{design was}} A-natural, a [...] "stream-oriented" [...] {{assembler}} for 8080/Z80 processors from Whitesmiths Ltd. (developers of the Unix-like Idris operating system, {{and what was}} reported to be the first commercial C compiler). The language was classified as an assembler, because it worked with raw machine elements such as opcodes, registers, and memory references; but it incorporated an expression syntax to indicate execution order. Parentheses and other special symbols, along with block-oriented structured programming constructs, controlled the sequence of the generated instructions. A-natural was built as the <b>object</b> <b>language</b> of a C compiler, rather than for hand-coding, but its logical syntax won some fans.|$|E
2500|$|Logician and philosopher Alfred Tarski {{developed}} the theory for formal languages (such as formal logic). Here he restricted {{it in this}} way: no language could contain its own truth predicate, that is, the expression is true could only apply to sentences in some other language. The latter he called an <b>object</b> <b>language,</b> the language being talked about. (It may, in turn, have a truth predicate {{that can be applied}} to sentences in still another language.) The reason for his restriction was that languages that contain their own truth predicate will contain paradoxical sentences such as, [...] "This sentence is not true". As a result, Tarski held that the semantic theory could not be applied to any natural language, such as English, because they contain their own truth predicates. Donald Davidson used it as the foundation of his truth-conditional semantics and linked it to radical interpretation in a form of coherentism.|$|E
50|$|Computer <b>languages</b> are <b>object</b> <b>languages</b> of the {{metalanguage}} {{in which}} their specification is written. In computer science this {{is referred to as}} the specification language. Backus-Naur form was one of the earliest used specification languages.|$|R
40|$|This paper {{provides}} a general discussion of object-oriented computer languages. Deals with design {{and development of}} <b>object</b> oriented programming <b>languages,</b> and examines technical infrastructure for object oriented systems. Reviews the origins of <b>object</b> oriented <b>languages</b> from 1967 to 1988 in COBOL. Defines <b>object</b> oriented computer <b>languages,</b> such as "Smalltalk", class-less prototype-based <b>languages,</b> <b>object</b> oriented <b>language</b> derivatives, extensions of the JAVA language, and refers to the "beta" language. Refers to object-oriented methods {{which are based on}} experience, and defines a technical infrastructure, with reference to scheduling and synchronisation. Problems of object identity, referencing, aliasing and encapsulation, inheritance and modularisation. are listed. The increased use of inheritance and reusability is noted...|$|R
5000|$|Database {{access is}} {{supported}} via an {{application program interface}} for C++ or [...]NET programming languages and via the ODABA Script Interface (OSI). <b>Object</b> Definition <b>Language</b> (ODL) and <b>Object</b> Query <b>Language</b> (OQL) provided with OSI are ODMG 3.0 conform.|$|R
5000|$|An <b>object</b> <b>{{language}}</b> is {{a language}} {{which is the}} [...] "object" [...] of study in various fields including logic, linguistics, mathematics, and theoretical computer science. The language being {{used to talk about}} an <b>object</b> <b>language</b> is called a metalanguage. An <b>object</b> <b>language</b> may be a formal or natural language.|$|E
50|$|The undefinability theorem {{shows that}} this {{encoding}} cannot be done for semantic concepts such as truth. It shows that no sufficiently rich interpreted language can represent its own semantics. A corollary is that any metalanguage capable of expressing the semantics of some <b>object</b> <b>language</b> must have expressive power exceeding that of the <b>object</b> <b>language.</b> The metalanguage includes primitive notions, axioms, and rules absent from the <b>object</b> <b>language,</b> {{so that there are}} theorems provable in the metalanguage not provable in the <b>object</b> <b>language.</b>|$|E
50|$|These {{excerpts}} {{relate to}} the distinction in metalogic between the <b>object</b> <b>language,</b> the formal language of the logical system under discussion, and the metalanguage, a language (often a natural language) distinct from the <b>object</b> <b>language,</b> employed to exposit and discuss the <b>object</b> <b>language.</b> The first quote seems to assert that the canons {{are part of the}} metalanguage. The second quote seems to assert that statements in the <b>object</b> <b>language</b> are essentially commands addressed to the reader by the author. Neither assertion holds in standard metalogic.|$|E
50|$|Nominal {{techniques}} are {{a range of}} techniques, based on nominal sets, for handling names and binding, e.g. in abstract syntax. Research into nominal sets gave rise to nominal terms, a metalanguage for embedding <b>object</b> <b>languages</b> with name binding constructs.|$|R
40|$|Generalised {{recursion}} {{and type}} inference for intersection types – p. 1 General motivation To design a base language with: • functional core • objects • well-defined semantics, {{that can be}} realistically implemented • ML-like inference of principal types in the goal of adding other paradigms (migration, reactive) [...] . Generalised recursion and type inference for intersection types – p. 2 Outline First part: • semantics of <b>object</b> <b>languages</b> • a type system with degrees • implementation, abstract machine • mixins Generalised recursion and type inference for intersection types – p. 3 Outline First part: • semantics of <b>object</b> <b>languages</b> • a type system with degrees • implementation, abstract machine • mixins Second part: • intersection type...|$|R
40|$|Abella [3] is an {{interactive}} system for reasoning about aspects of <b>object</b> <b>languages</b> {{that have been}} formally presented through recursive rules based on syntactic structure. Abella utilizes a two-level logic approach to specification and reasoning. One level is defined by a specification logic which supports a transparen...|$|R
5000|$|The symbols A and B are not {{symbols of}} the <b>object</b> <b>language</b> , they are metavariables in the {{metalanguage}} (in this case, English) that is discussing the <b>object</b> <b>language</b> [...]|$|E
50|$|<b>Object</b> <b>language</b> in {{this context}} is synonymous with target language. The <b>object</b> <b>language</b> of a {{translation}} most often is a machine language, but can be some other kind of language, such as assembly language.|$|E
5000|$|To {{formulate}} linguistic theories without semantic paradoxes {{such as the}} liar paradox, it {{is generally}} necessary to distinguish the language that one is talking about (the <b>object</b> <b>language)</b> from the language that one is using to do the talking (the metalanguage). In the following, quoted text is use of the <b>object</b> <b>language,</b> while unquoted text is use of the metalanguage; a quoted sentence (such as [...] "P") is always the metalanguage's name for a sentence, such that this name is simply the sentence P rendered in the <b>object</b> <b>language.</b> In this way, the metalanguage {{can be used to}} talk about the object language; Tarski demanded that the <b>object</b> <b>language</b> be contained in the metalanguage.|$|E
50|$|<b>Object</b> Specification <b>Languages.</b> The ODMG <b>Object</b> Definition <b>Language</b> (ODL) {{was used}} to define the object types that conform to the ODMG Object Model. The ODMG Object Interchange Format (OIF) {{was used to}} dump and load the current state to or from a file or set of files.|$|R
5000|$|This {{language}} type {{was called}} dechticaetiative {{in an article}} by Edward L. Blansitt, Jr. (from Greek dekhomai [...] "take, receive" [...] and an obscure second element, unlikely kaitoi [...] "and indeed"), but that term did not catch on. They have also been called anti-ergative <b>languages</b> and primary <b>object</b> <b>languages.</b>|$|R
40|$|This paper {{concerns}} {{techniques for}} providing a convenient syntax for <b>object</b> <b>languages</b> implemented via a type-theoretic Logical Framework, and reports on work in progress. We first motivate {{the need for}} a type-theoretic logical framework. Firstly, we take the logical framework seriously as a meta-language for implementing <b>object</b> <b>languages</b> (including <b>object</b> type theories). Another reason is the goal of building domain-specific reasoning tools which are implemented using type theory technology but do not require great expertise in type theory to use productively. We then present several examples of bi-directional translations between an encoding in the framework language and a more convenient syntax. The paper ends by discusing several techniques for implementing the translations and properties that we may require for the translation. Coercive subtyping is shown to help in the translation...|$|R
5000|$|These {{sentences}} (1 and 2, etc.) {{have come}} to be called the [...] "T-sentences". The reason they look trivial is that the <b>object</b> <b>language</b> and the metalanguage are both English; here is an example where the <b>object</b> <b>language</b> is German and the metalanguage is English: ...|$|E
5000|$|SQL/OLB <b>Object</b> <b>Language</b> Bindings (SQL:1999 part 10) ISO/IEC 9075-10:2000 ...|$|E
50|$|Zabana is a {{mainly a}} VSO (Verb, Subject, <b>Object)</b> <b>language.</b>|$|E
50|$|Conventionally, {{designers}} communicate {{mostly in}} visual or <b>object</b> <b>languages.</b> Symbols, signs, and metaphors are used {{through the medium}} of sketching, diagrams and technical drawings to translate abstract requirements into concrete objects. The way designers communicate, then, is through understanding this way of coding design requirements in order to produce built products.|$|R
5000|$|Alice, an <b>object</b> based <b>language</b> used {{to program}} 3D environments.|$|R
5000|$|<b>Object</b> Constraint <b>Language</b> (OCL): a model {{constraint}} (and query) language ...|$|R
