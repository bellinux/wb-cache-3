297|272|Public
25|$|The map {{operation}} simply {{applies the}} given function (the kernel) to every {{element in the}} stream. A simple example is multiplying each value in the stream by a constant (increasing the brightness of an image). The map operation is simple to implement on the GPU. The programmer generates a fragment for each pixel on screen and applies a fragment program to each one. The result stream {{of the same size}} is stored in the <b>output</b> <b>buffer.</b>|$|E
5000|$|Read {{the first}} 10 MB (= 100MB / (9 chunks + 1)) of each sorted chunk into input buffers in main memory and {{allocate}} the remaining 10 MB for an <b>output</b> <b>buffer.</b> (In practice, it might provide better performance {{to make the}} <b>output</b> <b>buffer</b> larger and the input buffers slightly smaller.) ...|$|E
5000|$|To {{hold the}} current <b>output</b> <b>buffer</b> page {{for each of}} the [...] {{partitions}} ...|$|E
50|$|Data {{read from}} the cells {{does not need to}} be fed into the <b>output</b> <b>buffers</b> or the data bus to send to the CPU.|$|R
40|$|To {{support the}} Internet's {{explosive}} growth and expansion into a true integrated services network, {{there is a}} need for cost-effective switching technologies that can simultaneously provide high capacity switching and advanced QoS. Unfortunately, these two goals are largely believed to be contradictory in nature. To support QoS, sophisticated packet scheduling algorithms, such as Fair Queueing, are needed to manage queueing points. However, the bulk of current research in packet scheduling algorithms assumes an <b>output</b> <b>buffered</b> switch architecture, whereas most high performance switches (both commercial and research) are input <b>buffered.</b> While <b>output</b> <b>buffered</b> systems may have the desired quality of service, they lack the necessary scalability. Input buffered systems, while scalable, lack the necessary quality of service features. In this paper, we propose the construction of switching systems that are both input and <b>output</b> <b>buffered,</b> with the scalability of input buffered switches and the r [...] ...|$|R
40|$|The {{performance}} of Multistage Interconnection Networks (MIN's) constructed from <b>output</b> <b>buffered</b> switching elements (SE) {{is higher than}} those having input buffered SEs. Many of the existing analytical models for <b>output</b> <b>buffered</b> MIN's assume uniform traffic and infinite <b>buffers</b> at each <b>output</b> port of an SE. The models are not realistic because, in practice buffers are finite and the traffic may not be uniform. Moreover, because of simplifying assumptions, the models do not produce accurate results. For the purpose of network design and proper buffer dimensioning, {{it is important to}} develop an accurate analytical model under realistic traffic patterns and finite buffered SEs. The objective {{of this paper is to}} develop an accurate model for MINs using finite <b>output</b> <b>buffered</b> SEs and operating in the presence of nonuniform traffic patterns. It is shown that the proposed analytical model is much more accurate than existing models. 1 A part of this paper has been presented at the First IEEE In [...] ...|$|R
5000|$|The write {{function}} sends {{a string}} literal {{to the standard}} <b>output</b> <b>buffer,</b> which in most cases is a command line interface.|$|E
5000|$|Or most {{commonly}} when the <b>output</b> <b>buffer</b> is full - congestion (for example the combined rate of multiple inputs exceeds the output rate) ...|$|E
5000|$|Xlib {{does not}} send {{requests}} to the server immediately, but stores {{them in a}} queue, called the output buffer; the requests in the <b>output</b> <b>buffer</b> are actually sent when: ...|$|E
40|$|Problem statement: Optical Packet Switching (OPS) and {{transmission}} networks based on Wavelength Division Multiplexing (WDM) have been increasingly {{deployed in the}} Internet infrastructure {{over the last decade}} {{in order to meet the}} huge increasing demand for bandwidth. Several different technologies have been developed for optical packet switching such as space switches, broadcast-and-select, input <b>buffered</b> switches and <b>output</b> <b>buffered</b> switches. These architectures vary based on several parameters such as the way of optical buffering, the placement of optical buffers, the way of solving the external blocking inherited from switching technologies in general and the components used to implement WDM. Approach: This study surveys most of the exiting optical packet switching architectures. A simulation-based comparison of input <b>buffered</b> and <b>output</b> <b>buffered</b> architectures were presented. Results: The performance analysis of the selected two architectures derived using simulation program and compared at different scenarios. We found that the <b>output</b> <b>buffered</b> architectures give better performance than input buffered architectures. Conclusion: The simulation results shows that the-broadcast-and-select architecture is attractive in terms that it has lees number of components compared to other switches. </P...|$|R
50|$|Note: Symmetric {{parallel}} termination {{means that}} the termination resistor at the load is connected to half the <b>output</b> <b>buffer's</b> supply voltage. Double parallel termination means that parallel termination resistors are fitted {{at both ends of}} the transmission line.|$|R
40|$|In this article, {{the design}} of {{quadrature}} voltage controlled oscillator (Q-VCO), which covers the Bluetooh requirements is described. A methodology which makes easy {{the design of}} oscillators with negative resistance is shown. Standard 0. 35 um CMOS process was used. The circuit is fully monolithic, and this decreases its price. The oscillator has <b>output</b> <b>buffers,</b> which ensure the necessary power of the output signal. The supply voltage is 1, 5 volts and {{is limited by the}} used technology and the parameters necessary for the normal work of the os-cillator. The overall power consumption of the oscillator and the <b>output</b> <b>buffers</b> is 107 mW, and the phase noise is- 108 dBc/Hz, at 600 kHz from the carrier...|$|R
50|$|For a K-funnel {{occupies}} θ(K2) storage, and {{at least}} K2 storage. If the input lists have K3 elements total, then a K-funnel fills the <b>output</b> <b>buffer</b> in O(K3/B(logM/B K3/B)+K) memory transfers.|$|E
5000|$|Perform a 9-way merge {{and store}} the {{result in the}} <b>output</b> <b>buffer.</b> Whenever the <b>output</b> <b>buffer</b> fills, write it to the final sorted file and empty it. Whenever any of the 9 input buffers empties, fill it with the next 10 MB of its {{associated}} 100 MB sorted chunk until no more data from the chunk is available. This is the key step that makes external merge sort work externally -- because the merge algorithm only makes one pass sequentially through each of the chunks, each chunk {{does not have to}} be loaded completely; rather, sequential parts of the chunk can be loaded as needed.|$|E
5000|$|Accurate noise {{modeling}} is a must. Create a list {{of expected}} noise events, including different types of noise, such as coupling and charge sharing. Input <b>Output</b> <b>Buffer</b> Information Specification (IBIS) or circuit models {{may be used to}} represent drivers and receivers.|$|E
40|$|Scheduling: {{choose a}} packet to {{transmit}} over a link among all packets {{stored in a}} given buffer (multiplexing point) • Mainly look at QoS scheduling algorithms – Choose the packet according to QoS needs Computer Network Design- 3 Andrea Bianco – TNG group- Politecnico di Torino <b>Output</b> <b>buffered</b> architecture • Advantage of OQ (Output Queued) architectures – All data immediately transferred to <b>output</b> <b>buffers</b> according to data destination – It is possible to run QoS scheduling algorithms independently for each output link • In other architectures, like IQ or CIOQ switches, problems become more complex – Scheduling to satisfy QoS requirements and scheduling to maximize the transfer data from inputs to outputs have conflicting requirement...|$|R
30|$|Research on vector access {{performance}} for multibank memories {{has a long}} history. In [16] a memory system was proposed with input and <b>output</b> <b>buffers</b> for all memory banks including a stalling mechanism and a bank assignment function based on a cyclic permutation.|$|R
40|$|Versatile {{analog signal}} {{conditioning}} circuitry On-board reference, clock oscillator and buffers Buffered 14, 16 (or 18) bit parallel <b>outputs</b> <b>Buffered</b> serial port interface Ideal for DSP and data acquisition card interfaces Analog and digital prototyping area EVAL-CONTROL-BOARD compatibility PC software for control and data analysi...|$|R
5000|$|... 1. OBF (<b>Output</b> <b>Buffer</b> Full) - It is an output {{that goes}} low {{whenever}} data are output(OUT) {{to the port}} A or port B latch. This signal is set to a logic 1 whenever the ACK pulse returns from the external device.|$|E
50|$|The {{input buffer}} is a queue where events are stored (from keyboard, mouse etc.). The <b>output</b> <b>buffer</b> is a {{rectangular}} grid where characters are stored, {{together with their}} attributes. A console window may have several output buffers, only {{one of which is}} active (i.e. displayed) for a given moment.|$|E
50|$|Its text-only nature consumes {{very little}} system resources, and it uses an <b>output</b> <b>buffer</b> in a {{separate}} thread to avoid skipping under high system loads and to enable gapless playback. Normally, exiting the program only closes the interface - the program daemonizes itself so the audio continues playing in the background.|$|E
40|$|Abstract—Due to the {{emergence}} of more data centric applications, the replication of data has become a more common phenomenon. In the similar context, recently, (PDDRA) a Pre-fetching based dynamic data replication algorithm is developed. The main idea is to pre-fetch some data using the heuristic algorithm before actual replication start to reduce latency In the algorithm further modifications (M-PDDRA) are suggested to minimize the delay in data replication. In this paper, M-PDDRA algorithm is tested under shared and output buffering scheme. Simulation results are presented to estimate the packet loss rate and average delay for both shared and <b>output</b> <b>buffered</b> schemes. The simulation results clearly reveal that the shared buffering with load balancing scheme is as good as <b>output</b> <b>buffered</b> scheme with much less buffering resources...|$|R
40|$|Abstract—A 20 -GHz 130 -nm CMOS {{front-end}} using baluns {{on glass}} carrier is presented. The front-end {{consists of a}} CMOS die featuring a differential two-stage LNA, a passive double balanced mixer, and <b>output</b> <b>buffers,</b> which is flip-chipped on a glass carrier where baluns are realized for the RF and LO signals. The front-end measures a conversion gain of 11 dB, a noise figure of 7 dB, a 60 dB LO to RF isolation, an ICP 1 dB of- 16 dBm, an IIP 3 of- 5. 2 dBm, and an IIP 2 of + 34. 5 dBm. The power consumption, excluding <b>output</b> <b>buffers,</b> is 38 mW. Furthermore, the RF input is well protected as it can withstand a simulated 3 kV HBM ESD event. I...|$|R
40|$|Abstract—To {{support the}} Internet’s {{explosive}} growth and expansion into a true integrated services network, {{there is a}} need for cost-effective switching technologies that can simultaneously provide high capacity switching and advanced QoS. Unfortunately, these two goals are largely believed to be contradictory in nature. To support QoS, sophisticated packet scheduling algorithms, such as Fair Queueing, are needed to manage queueing points. However, the bulk of current research in packet scheduling algorithms assumes an <b>output</b> <b>buffered</b> switch architecture, whereas most high performance switches (both commercial and research) are input <b>buffered.</b> While <b>output</b> <b>buffered</b> systems may have the desired quality of service, they lack the necessary scalability. Input buffered systems, while scalable, lack the necessary quality of service features. In this paper, we propose the construction of switching systems that are both input and <b>output</b> <b>buffered,</b> with the scalability of input buffered switches and the robust quality of service of <b>output</b> <b>buffered</b> switches. We call the resulting architecture Distributed Packet Fair Queueing (D-PFQ) as it enables physically dispersed line cards to provide service that closely approximates an output-buffered switch with Fair Queueing. By equalizing the growth of the virtual time functions across the switch system, most of the PFQ algorithms in the literature can be properly defined for distributed operation. We present our system using a crossbar for the switch core, as they are widely used in commercial products and enable the clearest presentation of our architecture. Buffering techniques are used to enhance the system’s latency tolerance, which enables the use of pipelining and variable packet sizes internally. Our system is truly distributed in that there is neither a central arbiter nor any global synchronization. Simulation results are presented to evaluate the delay and bandwidth sharing properties of the proposed D-PFQ system. I...|$|R
5000|$|... id Tech 3s {{sound system}} outputs to two {{channels}} using a looping <b>output</b> <b>buffer,</b> mixed from 96 tracks with stereo spatialization and Doppler effect. All {{of the sound}} mixing is done within the engine, which can create problems for licensees hoping to implement EAX or surround sound support. Several popular effects such as echoes are also absent.|$|E
50|$|A major flaw of {{the sound}} system is that the mixer is not given its own thread, so if the game stalls for too long (particularly while {{navigating}} the menus or connecting to a server), the small <b>output</b> <b>buffer</b> will begin to loop, a very noticeable artifact. This problem was also present in the Doom 3, Quake, and Quake II engines.|$|E
50|$|To {{retrieve}} {{data from the}} EPROM, the address represented by the values at the address pins of the EPROM is decoded and used to connect one word (usually an 8-bit byte) of storage to the <b>output</b> <b>buffer</b> amplifiers. Each bit of the word is a 1 or 0, depending on the storage transistor being switched on or off, conducting or non-conducting.|$|E
50|$|Applications join {{specific}} {{groups as}} individual members. On joining a group a member can send or receive messages. Individual messages {{are assigned to}} specific transport classes, based on the message's size. Each transport class owns input and <b>output</b> <b>buffers.</b> Routing decisions are made at the transport class level.|$|R
40|$|This paper {{addresses}} {{the selection of}} parametric relations for the macromodeling of the output and power supply ports of IC <b>output</b> <b>buffers.</b> Relations defined by sigmoidal functions and parameter estimation via fully nonlinear optimization algorithms can lead to models with improved efficiency. Modeling examples involving commercial devices are shown. ...|$|R
50|$|Alternately, Paula may {{signal the}} CPU to load a new sample {{into any of}} the four audio <b>output</b> <b>buffers</b> by {{generating}} an interrupt when a new sample is needed. This allows for output rates that exceed 57 kHz per channel and increases the number of possible voices (simultaneous sounds) through software mixing.|$|R
50|$|Since SneakPeek accepts packets {{coming through}} an input buffer and {{delivers}} packets through an <b>output</b> <b>buffer</b> {{it can be}} easily connected to any standard I/O or network.The MIPI Alliance Specification for SneakPeek Protocol describes the basic concepts, the required infrastructure, the packets and the data flow. The last MIPI board adopted version of Specification for SneakPeek Protocol (SPPSM) is version 1.0 (August 2015).|$|E
50|$|A second {{improvement}} is {{the integration of}} an optional-use <b>output</b> <b>buffer</b> amplifier to the chip on which the OTA resides. This is actually a convenience to a circuit designer rather than an improvement to the OTA itself; dispensing {{with the need to}} employ a separate buffer. It also allows the OTA {{to be used as a}} traditional op-amp, if desired, by converting its output current to a voltage.|$|E
50|$|The LZ4 {{algorithm}} {{represents the}} data {{as a series}} of sequences. Each sequence begins with a one-byte token that is broken into two 4-bit fields. The first field represents the number of literal bytes that are to be copied to the output. The second field represents the number of bytes to copy from the already decoded <b>output</b> <b>buffer</b> (with 0 representing the minimum match length of 4 bytes). A value of 15 in either of the bitfields indicates that the length is larger and there is an extra byte of data that is {{to be added to the}} length. A value of 255 in these extra bytes indicates that yet another byte to be added. Hence arbitrary lengths are represented by a series of extra bytes containing the value 255. The string of literals comes after the token and any extra bytes needed to indicate string length. This is followed by an offset that indicates how far back in the <b>output</b> <b>buffer</b> to begin copying. The extra bytes (if any) of the match-length come at the end of the sequence.|$|E
50|$|A {{deadlock}} (shown in fig 1) is {{a situation}} in which no further transportation of packets can take place due to the saturation of network resources like buffers or links. The main reason for a deadlock is the cyclic acquisition of channels in the network. For example, consider there are four channels in a network. Four packets have filled up the input buffers of these four channels and needs to be forwarded to the next channel. Now assume that the <b>output</b> <b>buffers</b> of all these channels are also filled with packets that need to be transmitted to the next channel. If these four channels form a cycle, it is impossible to transmit packets any further because the <b>output</b> <b>buffers</b> and input buffers of all channels are already full. This is known as cyclic acquisition of channels and this results in a deadlock.|$|R
40|$|Small {{switching}} {{elements are}} the key components of multistage interconnection networks (MINs) used in multiprocessors and in high speed switching fabrics. Clock design for synchronous MINs is an important issue. The existing models assume that the clock period consists of two parts. The control messages are transferred between switching stages during the first part, and the actual data transfer takes place during the second part. We propose a new control design for single queue MINs that reduces {{the duration of the}} clock period by making use of <b>output</b> <b>buffers</b> and acknowledgments. The reduction in the clock period comes from the addition of two-unit <b>output</b> <b>buffers,</b> introducing a sophisticated hardware control mechanism, and sacrificing the FIFO feature. We develop an analytical model to compare its performance with the existing designs reported in the literature. We validate our model with extensive simulation studies...|$|R
40|$|Abstract—Large, fast {{switches}} require novel {{approaches to}} architecture and scheduling. In this paper, we propose the <b>Output</b> <b>Buffered</b> Switch with Input Groups (OBIG). We present simulation results, discuss the implementation, and show how our architecture {{can be used}} to build single-stage (flat) switches with multi-terabit-per-second throughput and hundreds of ports. Keywords- switching, routing I...|$|R
