15|5732|Public
2500|$|An {{instruction}} set {{is said to}} be orthogonal if it lacks redundancy (i.e., there is only a single instruction {{that can be used to}} accomplish a given task) and is designed such that instructions can use any register in any addressing mode. This terminology results from considering an instruction as a vector whose components are the instruction fields. [...] One field identifies the registers to be operated upon and another specifies the addressing mode. An <b>orthogonal</b> <b>instruction</b> <b>set</b> uniquely encodes all combinations of registers and addressing modes.|$|E
5000|$|In {{computer}} engineering, an <b>orthogonal</b> <b>instruction</b> <b>set</b> is {{an instruction}} set architecture where all instruction types can use all addressing modes. It is [...] "orthogonal" [...] {{in the sense}} that the instruction type and the addressing mode vary independently. An <b>orthogonal</b> <b>instruction</b> <b>set</b> does not impose a limitation that requires a certain instruction to use a specific register.|$|E
50|$|Programmers {{liked the}} TI-990 design {{because it had}} a fairly <b>orthogonal</b> <b>instruction</b> <b>set</b> which allowed a {{programmer}} to separately memorize all of the operations and the methods of accessing operands.|$|E
40|$|The hardware, software, and {{firmware}} of {{the parallel}} processor, Grundy, are examined. The Grundy processor uses a simple processor {{that has a}} totally <b>orthogonal</b> three-address <b>instruction</b> <b>set.</b> The system contains a relative and indirect processing mode to support the high-level language, and uses pseudoprocessors and read-only memory. The system supports high-level language in which arbitrary degrees of algorithmic parallelism is expressed. The functions of the compiler and invocation frame are described. Grundy uses an operating system that can be accessed by an arbitrary number of processes simultaneously, and the access time grows only as the logarithm {{of the number of}} active processes. Applications for the parallel processor are discussed...|$|R
50|$|PDP-11: The archetypal minicomputer; a 16-bit {{machine and}} another {{commercial}} success for DEC. The LSI-11 is a four-chip PDP-11 used primarily for embedded systems. The 32-bit VAX series is {{descended from the}} PDP-11, and early VAX models have a PDP-11 compatibility mode. The 16-bit PDP-11 <b>instruction</b> <b>set</b> has been very influential, with processors ranging from the Motorola 68000 to the Renesas H8 and Texas Instruments MSP430, inspired by its highly <b>orthogonal,</b> general-register oriented <b>instruction</b> <b>set</b> and rich addressing modes. The PDP-11 family was extremely long-lived, spanning 20 years and many different implementations and technologies.|$|R
40|$|The ever {{increasing}} complexity of signal processing appli-cations {{and the desire}} to reduce the time to market demands efficient compilation techniques for programmable Digital Signal Processors (DSPs). Because the <b>instruction</b> <b>sets</b> of VLIW processors are more regular and <b>orthogonal</b> then the <b>instruction</b> <b>sets</b> of the traditional DSPs, they tend to be more compiler friendly. However in order to improve the maximal clock frequency, the power efficiency and the code density, several register files are used in the newer genera-tion of VLIW processors instead of just one large register file. The use of several register files and partial connected networks leads, for example, to the problem that a result stored in a register file can not be accessed by all the func-tional units in the processor. This makes the assignment o...|$|R
50|$|A 32-bit {{system with}} a CISC {{architecture}} based on DEC's earlier PDP-11, VAX ("virtual address extension") was designed to extend or replace DEC's various PDP ISAs. The VAX architecture's primary features were virtual addressing (for example demand paged virtual memory) and its <b>orthogonal</b> <b>instruction</b> <b>set.</b>|$|E
5000|$|In {{computer}} programming, [...] "orthogonality in a {{programming language}} means that a relatively small set of primitive constructs can be combined in {{a relatively small number}} of ways to build the control and data structures of the language" [...] (...) [...] The term is most-frequently used regarding assembly instruction sets, as <b>orthogonal</b> <b>instruction</b> <b>set.</b>|$|E
50|$|It {{had a more}} <b>orthogonal</b> <b>instruction</b> <b>set</b> {{than those}} of many {{processors}} that came before (e.g., 8080) and after (e.g., x86). That is, it was typically possible to combine operations freely with operands, rather than being restricted to using certain addressing modes with certain instructions. This property made programming relatively easy for humans, and also {{made it easier to}} write code generators for compilers.|$|E
40|$|This thesis investigates {{hardware}} {{support for}} managing time, events, and process scheduling in embedded operating systems. An otherwise normal content-addressable memory that is tailored {{to handle the}} most basic func-tions of a typical RTOS, the CCAM (configurable content-addressable memory) turns what are usually O(n) tasks into O(1) tasks using the paral-lelism inherent in a hardware search implementation. The mechanism is modelled {{in the context of}} the MCORE embedded microarchitecture, sev-eral variations upon µC/OS-II, a popular open-source real-time operating system and Echidna, a commercial real-time operating system. The mecha-nism improves the real-time behavior of systems by reducing the overhead of the RTOS by 20 % and in some cases reduces energy consumption 25 %. This latter feature is due to the reduced number of instructions fetched and executed, even though the energy cost of one CCAM access is much higher than the energy cost of a single instruction. The performance and energy benefits come with a modest price: an increase in die area of roughly 10 %. The CCAM is <b>orthogonal</b> to the <b>instruction</b> <b>set</b> (it is accessed via memory-mapped I/O load/store instructions) and offers features used by most RTOSes...|$|R
50|$|In {{the early}} 1990s, {{engineers}} at Hitachi {{found ways to}} compress RISC <b>instruction</b> <b>sets</b> so they fit in even smaller memory systems than CISC <b>instruction</b> <b>sets.</b> They developed a compressed <b>instruction</b> <b>set</b> for their SuperH series of microprocessors, introduced in 1992. The SuperH <b>instruction</b> <b>set</b> was later adapted for the ARM architecture's Thumb <b>instruction</b> <b>set.</b> Compressed <b>instructions</b> appeared in the ARM architecture, after ARM Holdings licensed SuperH patents {{as a basis for}} its Thumb <b>instruction</b> <b>set.</b>|$|R
2500|$|All ARMv7 chips {{support the}} Thumb <b>instruction</b> <b>set.</b> All chips in the Cortex-A series, Cortex-R series, and ARM11 series support both [...] "ARM <b>instruction</b> <b>set</b> state" [...] and [...] "Thumb <b>instruction</b> <b>set</b> state", while chips in the Cortex-M series support only the Thumb <b>instruction</b> <b>set.</b>|$|R
50|$|In many CISCs, an {{instruction}} could access either registers or memory, usually {{in several different}} ways. This made the CISCs easier to program, because a programmer could remember only thirty to a hundred instructions, {{and a set of}} three to ten addressing modes rather than thousands of distinct instructions. This was called an <b>orthogonal</b> <b>instruction</b> <b>set.</b> The PDP-11 and Motorola 68000 architecture are examples of nearly orthogonal instruction sets.|$|E
5000|$|A fully {{orthogonal}} architecture {{may not be}} {{the most}} [...] "bit efficient" [...] architecture. In the late 1970s research at IBM (and similar projects elsewhere) demonstrated that the majority of these [...] "orthogonal" [...] addressing modes were ignored by most programs. Perhaps some of the bits that were used to express the fully <b>orthogonal</b> <b>instruction</b> <b>set</b> could instead be used to express more virtual address bits or select from among more registers.|$|E
50|$|An {{instruction}} set {{is said to}} be orthogonal if it lacks redundancy (i.e., there is only a single instruction {{that can be used to}} accomplish a given task) and is designed such that instructions can use any register in any addressing mode. This terminology results from considering an instruction as a vector whose components are the instruction fields. One field identifies the registers to be operated upon and another specifies the addressing mode. An <b>orthogonal</b> <b>instruction</b> <b>set</b> uniquely encodes all combinations of registers and addressing modes.|$|E
50|$|The B5000 was revolutionary at {{the time}} in that the {{architecture}} and <b>instruction</b> <b>set</b> were designed with the needs of software taken into consideration. This was a large departure from the computer system design of the time, where a processor and its <b>instruction</b> <b>set</b> would be designed and then handed over to the software people, and is still. That is, most other <b>instruction</b> <b>sets,</b> such as the IBM System/360 <b>instruction</b> <b>set</b> of that era, and later <b>instruction</b> <b>set</b> designs such as the x86, PPC, and ARM <b>instruction</b> <b>set</b> architectures, are essentially traditional <b>instruction</b> <b>set</b> based architectures rather than holistic designs like the original Burroughs systems.|$|R
50|$|In computing, binary {{translation}} (or (binary) recompilation) is the emulation of one <b>instruction</b> <b>set</b> {{by another}} through translation of binary code. Sequences of instructions are {{translated from the}} source to the target <b>instruction</b> <b>set.</b> In some cases such as <b>instruction</b> <b>set</b> simulation, the target <b>instruction</b> <b>set</b> may {{be the same as}} the source <b>instruction</b> <b>set,</b> providing testing and debugging features such as instruction trace, conditional breakpoints and hot spot detection.|$|R
50|$|Although the FS {{project as}} a whole was killed, a {{simplified}} version of the architecture for the smallest of the three machines continued to be developed in Rochester. It was finally released as the IBM System/38, which proved to be a good design for ease of programming, but it was woefully underpowered. The AS/400 inherited the same architecture, but with performance improvements. In both machines, the very CISCy <b>instruction</b> <b>set</b> generated by compilers is not interpreted, but translated into a lower-level machine <b>instruction</b> <b>set</b> and executed; the original lower-level <b>instruction</b> <b>set</b> was a CISC <b>instruction</b> <b>set</b> with some similarities to the System/360 <b>instruction</b> <b>set.</b> In later machines the lower-level <b>instruction</b> <b>set</b> was an extended version of the PowerPC <b>instruction</b> <b>set,</b> which evolved from John Cocke's RISC machine.|$|R
50|$|The PDP-11 {{processor}} architecture has {{a mostly}} <b>orthogonal</b> <b>instruction</b> <b>set.</b> For example, instead of instructions such as load and store, the PDP-11 has a move instruction for which either operand (source and destination) can be memory or register. There are no specific input or output instructions; the PDP-11 uses memory-mapped I/O {{and so the}} same move instruction is used; orthogonality even enables moving data directly from an input device to an output device. More complex instructions such as add likewise can have memory, register, input, or output as source or destination.|$|E
50|$|When {{there are}} only a few {{addressing}} modes, the particular addressing mode required is usually encoded within the instruction code(e.g. IBM System/360 and successors, most RISC). But when there are lots of addressing modes, a specific field is often set aside in the instruction to specify the addressing mode. The DEC VAX allowed multiple memory operands for almost all instructions, and so reserved the first few bits of each operand specifier to indicate the addressing mode for that particular operand.Keeping the addressing mode specifier bits separate from the opcode operation bits produces an <b>orthogonal</b> <b>instruction</b> <b>set.</b>|$|E
5000|$|In many CISC computers, an {{instruction}} could access either registers or memory, usually {{in several different}} ways. This made the CISC machines easier to program, because rather than being required to remember thousands of individual instruction opcodes, an <b>orthogonal</b> <b>instruction</b> <b>set</b> allowed a programmer to instead remember just thirty to a hundred operation codes ("ADD", [...] "SUBTRACT", [...] "MULTIPLY", [...] "DIVIDE", etc.) {{and a set of}} three to ten addressing modes ("FROM REGISTER 0", [...] "FROM REGISTER 1", [...] "FROM MEMORY", etc.). The DEC PDP-11 and Motorola 68000 computer architectures are examples of nearly orthogonal instruction sets, while the ARM11 and VAX are examples of CPUs with fully orthogonal instruction sets.|$|E
5000|$|Bit Manipulation <b>Instruction</b> <b>Sets</b> bit {{manipulation}} extensions for the x86 <b>instruction</b> <b>set.</b>|$|R
50|$|The GCN <b>instruction</b> <b>set</b> {{is owned}} by AMD {{as well as the}} X86-64 <b>instruction</b> <b>set.</b> The GCN <b>instruction</b> <b>set</b> has been {{developed}} specifically for GPUs (and GPGPU) and e.g. has no micro-operation for division.|$|R
50|$|Any given <b>instruction</b> <b>set</b> can be {{implemented}} {{in a variety of}} ways. All ways of implementing a particular <b>instruction</b> <b>set</b> provide the same programming model, and all implementations of that <b>instruction</b> <b>set</b> are able to run the same executables. The various ways of implementing an <b>instruction</b> <b>set</b> give different tradeoffs between cost, performance, power consumption, size, etc.|$|R
50|$|TriMedia is {{a family}} of very long {{instruction}} word media processors from NXP Semiconductors (formerly Philips Semiconductors). TriMedia is a Harvard architecture CPU that features many DSP and SIMD operations to efficiently process audio and video data streams. For TriMedia processor optimal performance {{can be achieved by}} only programming in C/C++ as opposed to most other VLIW/DSP processors which require assembly language programming to achieve optimal performance. High-level programmability of TriMedia relies on the large uniform register file and the <b>orthogonal</b> <b>instruction</b> <b>set,</b> in which RISC-like operations can be scheduled independently of each other in the VLIW issue slots. Furthermore, TriMedia processors boast advanced caches supporting unaligned accesses without performance penalty, hardware and software data/instruction prefetch, allocate-on-write-miss, as well as collapsed load operations combining a traditional load with a 2-taps filter function. TriMedia development has been supported by various research studies on hardware cache coherency, multithreading and diverse accelerators to build scalable shared memory multiprocessor systems.|$|E
40|$|Fully <b>orthogonal</b> <b>instruction</b> <b>set</b> • Pipelined {{architecture}} {{allows one}} instruction per clock cycle for most instructions • Byte, half-word, word and double word memory access • Fast interrupts and multiple interrupt priority levels • Optional branch prediction for minimum delay branches • Privileged and unprivileged modes enabling efficient and secure Operating Systems • Innovative instruction set together with variable instruction length ensuring industry leading code density • Optional DSP extention with saturated arithmetic, {{and a wide}} variety of multiply instructions • Optional extensions for Java, SIMD, Read-Modify-Write to memory, and Coprocessors • Architectural support for efficient On-Chip Debug solutions • Optional MPU or MMU allows for advanced operating systems • FlashVault ™ support through Secure State for executing trusted code alongside nontrusted code on the same CPU 1...|$|E
40|$|This thesis {{considers}} the definition {{and design of}} an embedded configurable DSP (Digital Signal Processor) core architecture and will address the necessary requirements for developing an optimizing high-level language compiler. The introduction {{provides an overview of}} typical DSP core architectural features, briefly discusses the currently available DSP cores and summarizes the architectural aspects which have to be considered when developing an optimizing high-level language compiler. The introduction is followed by a total of 12 publications which outline the research work carried out while providing {{a detailed description of the}} main core features and the design space exploration methodology. Most of the research work focuses on architectural aspects of the configurable RISC (Reduced Instruction Set Computer) DSP core based on a modified Dual-Harvard load-store architecture. Due to increasing application code size and the associated configuration aspect the use of automatic code generation by a high-level language compiler is required. To generate code efficiently requires that the architectural aspects be considered as early as definition stage. This results in an <b>orthogonal</b> <b>instruction</b> <b>set</b> architecture with simple issu...|$|E
40|$|This paper {{presents}} {{a new approach}} to retarget existing software at the assembly level from one <b>instruction</b> <b>set</b> to another <b>instruction</b> <b>set.</b> The approach is based on abstracting the <b>instruction</b> <b>set</b> as the symbolic transitions of the machine states, especially focuses on translating Intel x 86 <b>instruction</b> <b>set</b> into another efficient RISC-based core <b>instruction</b> <b>set.</b> The retargeting process is modeled as a planning process that finds a plan which brings the processor from the same initial states to the same final states as the original software. The assembly-to-assembly retargeting capability helps renovating the existing software investment and shortening the period of time-to-market when upgrading to processor with newer <b>instruction</b> <b>sets.</b> 1...|$|R
50|$|Their design uses a fixed {{architecture}} - {{it requires}} {{changes in the}} wiring if the <b>instruction</b> <b>set</b> is modified or changed.This architecture is preferred in reduced <b>instruction</b> <b>set</b> computers (RISC) as they use a simpler <b>instruction</b> <b>set.</b>|$|R
25|$|Thumb-2 {{technology}} {{was introduced in}} the ARM1156core, announced in 2003. Thumb-2 extends the limited 16-bit <b>instruction</b> <b>set</b> of Thumb with additional 32-bit instructions to give the <b>instruction</b> <b>set</b> more breadth, thus producing a variable-length <b>instruction</b> <b>set.</b> A stated aim for Thumb-2 was to achieve code density similar to Thumb with performance similar to the ARM <b>instruction</b> <b>set</b> on 32-bit memory.|$|R
50|$|An <b>instruction</b> <b>set</b> {{architecture}} is distinguished from a microarchitecture, {{which is the}} set of processor design techniques used, in a particular processor, to implement the <b>instruction</b> <b>set.</b> Processors with different microarchitectures can share a common <b>instruction</b> <b>set.</b> For example, the Intel Pentium and the AMD Athlon implement nearly identical versions of the x86 <b>instruction</b> <b>set,</b> but have radically different internal designs.|$|R
50|$|Thumb-2 {{technology}} {{was introduced in}} the ARM1156 core, announced in 2003. Thumb-2 extends the limited 16-bit <b>instruction</b> <b>set</b> of Thumb with additional 32-bit instructions to give the <b>instruction</b> <b>set</b> more breadth, thus producing a variable-length <b>instruction</b> <b>set.</b> A stated aim for Thumb-2 was to achieve code density similar to Thumb with performance similar to the ARM <b>instruction</b> <b>set</b> on 32-bit memory.|$|R
50|$|Although the LINC's <b>instruction</b> <b>set</b> was small, it {{was larger}} than the tiny PDP-8 <b>instruction</b> <b>set.</b>|$|R
50|$|Appendix E of Book I: PowerPC User <b>Instruction</b> <b>Set</b> Architecture of PowerPC Architecture Book, Version 2.02 {{describes}} {{the differences between}} the POWER and POWER2 <b>instruction</b> <b>set</b> architectures and the version of the PowerPC <b>instruction</b> <b>set</b> architecture implemented by the POWER5.|$|R
50|$|Bit Manipulation <b>Instructions</b> <b>Sets</b> (BMI sets) are {{extensions}} to the x86 <b>instruction</b> <b>set</b> architecture for microprocessors from Intel and AMD. The {{purpose of}} these <b>instruction</b> <b>sets</b> {{is to improve the}} speed of bit manipulation. All the <b>instructions</b> in these <b>sets</b> are non-SIMD and operate only on general-purpose registers.|$|R
50|$|The AVX <b>instruction</b> <b>set</b> is {{the first}} <b>instruction</b> <b>set</b> {{extension}} to use the VEX coding scheme. The AVX instructions have up to four operands. The AVX <b>instruction</b> <b>set</b> allows the VEX prefix to be applied only to instructions using the SIMD XMM registers. However, the VEX coding scheme has space for applying the VEX prefix to other instructions as well in future <b>instruction</b> <b>sets.</b>|$|R
