8|9|Public
40|$|Context Software {{obfuscation}} {{is commonly}} employed in contexts where the attacker has {{direct access to}} the software binary. <b>Obfuscated</b> <b>binaries</b> contain either data or algorithms that their vendors do not wish to disclose. Commercial software vendors employ obfuscation to protect their intellectual property. On the other hand, malware vendors employ obfuscation in order to circumvent signature-based detection techniques used in most anti-virus software nowadays. Since there are a myriad of obfuscation techniques, this thesis will mainly focus on a particular technique called “virtualization obfuscation ” [1]. Virtualization obfuscation transforms a program written for a particular target platform (e. g. x 86), into a bytecode program for a random instruction set architecture. This bytecode program is executed on an emulator which interprets the bytecode instructions and executes the corresponding target platform instructions. Goal Virtualization obfuscation is deemed difficult to reverse engineer [1], [2], [3], [4]. Some of the challenges of reverse engineering virtualization obfuscation include identification of: the virtual program counter, the bytecode instructions and the emulator code. The goal of this thesis is to design and implement a technique based on statistical analysis, which given a set of virtualization <b>obfuscated</b> <b>binaries</b> having the same functional behavior, can statically detect the emulator code and the bytecode instructions of these binaries...|$|E
40|$|Disassembly is {{the process}} of {{recovering}} a symbolic representation of a program’s machine code instructions from its binary representation. Recently, a number of techniques have been proposed that attempt to foil the disassembly process. These techniques are very effective against state-of-the-art disassemblers, preventing a substantial fraction of a binary program from being disassembled correctly. This could allow an attacker to hide malicious code from static analysis tools that depend on correct disassembler output (such as virus scanners). The paper presents novel binary analysis techniques that substantially improve the success of the disassembly process when confronted with <b>obfuscated</b> <b>binaries.</b> Based on control flow graph information and statistical methods, a large fraction of the program’s instructions can be correctly identified. An evaluation of the accuracy and the performance of our tool is provided, along with a comparison to several state-of-the-art disassemblers...|$|E
40|$|Summary. The {{classification}} {{of an unknown}} binary program as malicious or benign requires two steps. In the first step, the stream of bytes that constitutes the program has to be transformed (or disassembled) into the corresponding sequence of machine instructions. In the second step, based on this machine code representation, static or dynamic code analysis techniques {{can be applied to}} determine the properties and function of the program. Both the disassembly and code analysis steps can be foiled by techniques that obfuscate the binary representation of a program. Thus, robust techniques are required that deliver reliable results under such adverse circumstances. In this chapter, we introduce a disassemble technique that can deal with <b>obfuscated</b> <b>binaries.</b> Also, we introduce a static code analysis approach that can identify high-level semantic properties of code that are difficult to conceal. 1. ...|$|E
40|$|Malware {{programs}} that incorporate trigger-based behavior initiate malicious activities based on conditions satisfied only by specific inputs. State-of-the-art malware analyzers discover code guarded by triggers via multiple path exploration, symbolic execution, or forced conditional execution, all {{without knowing the}} trigger inputs. We present a malware obfuscation technique that automatically conceals specific trigger-based behavior from these malware analyzers. Our technique automatically transforms a program by encrypting code that is conditionally dependent on an input value with a key derived from the input and then removing the key from the program. We have implemented a compiler-level tool that takes a malware source program and automatically generates an <b>obfuscated</b> <b>binary.</b> Experiments on various existing malware samples show that our tool can hide {{a significant portion of}} trigger based code. We provide insight into the strengths, weaknesses, and possible ways to strengthen current analysis approaches in order to defeat this malware obfuscation technique. ...|$|R
40|$|Opaque predicates {{have been}} widely used to insert super-fluous {{branches}} for control flow obfuscation. Opaque predi-cates can be seamlessly applied together with other obfusca-tion methods such as junk code to turn reverse engineering attempts into arduous work. Previous efforts in detecting opaque predicates are far from mature. They are either ad hoc, designed for a specific problem, or have a considerably high error rate. This paper introduces LOOP, a Logic Ori-ented Opaque Predicate detection tool for <b>obfuscated</b> <b>binary</b> code. Being different from previous work, we do not rely on any heuristics; instead we construct general logical formu-las, which represent the intrinsic characteristics of opaque predicates, by symbolic execution along a trace. We then solve these formulas with a constraint solver. The result ac-curately answers whether the predicate under examination is opaque or not. In addition, LOOP is obfuscation resilient and able to detect previously unknown opaque predicates. We have developed a prototype of LOOP and evaluated it with a range of common utilities and obfuscated malicious programs. Our experimental results demonstrate the effi-cacy and generality of LOOP. By integrating LOOP with code normalization for matching metamorphic malware vari-ants, we show that LOOP is an appealing complement to existing malware defenses. 1...|$|R
5000|$|The key and iv are not {{hard-coded}} {{into the}} binary (unless {{you decide to}} build a reusable static binary with -r flag) but are retrieved each time from the hardware (hence binding it to a machine). In case of a reusable static binary (built wit -r flag) then the uuid and serial are in the binary itself but will be manipulated anyway by makekey and makeiv {{so that they are}} not usable immediately should anyone ever inspect the binary itself.Although the whereabouts from where the serial and uuid are retrieved is traceable and is not a secret (machine uuid and srial number for non reusable and random hex digits for reusable) these should be then manipulated {{in a way that they}} are not directly usable as is. In the code there is a comment suggesting where this should be done (see makekey and makeiv functions in functions.c): each and every one of you using obash is encouraged to do so or it would be fairly easy to extract the script source from the <b>obfuscated</b> <b>binary..</b> In the distributed code, as an example, the [...] "-" [...] are stripped from the uuid and the serial is padded to reach the suggested length for the cipher used.|$|R
40|$|With {{the wide}} {{existence}} of binary code, {{it is desirable}} to reuse it in many security applications, such as malware analysis and software patching. While prior approaches have shown that binary code can be extracted and reused, they are often based on static analysis and face challenges when coping with <b>obfuscated</b> <b>binaries.</b> This paper introduces trace-oriented programming (TOP), a general framework for generating new software from existing binary code by elevating the low-level binary code to C code with templates and inlined assembly. Different from existing work, TOP gains benefits from dynamic analysis such as resilience against obfuscation and avoidance of points-to analysis. Thus, TOP {{can be used for}} malware analysis, especially for malware function analysis and identification. We have implemented a proof-of-concept of TOP and our evaluation results with a range of benign and malicious software indicate that TOP is able to reconstruct source code from binary execution traces in malware analysis and identification, and binary function transplanting...|$|E
40|$|Malware analysts {{often need}} to search large corpuses of <b>obfuscated</b> <b>binaries</b> for {{particular}} sequences of related instructions. The use of simple tactics, such as dead code insertion and register renaming, prevents {{the use of}} conventional, big-data search indexes. Current, {{state of the art}} malware detectors are unable to handle the size of the dataset due to their iterative approach to comparing files. Furthermore, current work is also frequently designed to act as a detector and not a search tool. I propose a system that exploits the observation that many data/control-flow relationships between instructions are preserved in the presence of obfuscations. The system will extract chains of flow-dependent instructions from a binary’s Program Dependence Graph (PDG). It will then use a representation of each chain as a key for an index that points to lists of functions (and their corresponding files). Analysts will be able to quickly search for instruction sequences by querying the index...|$|E
40|$|Increasingly {{sophisticated}} {{code obfuscation}} techniques are quickly adopted by malware developers {{to escape from}} malware detection and to thwart the reverse engineering effort of security analysts. State-of-the-art de-obfuscation approaches rely on dynamic analysis, but {{face the challenge of}} low code coverage as not all software execution paths and behavior will be exposed at specific profiling runs. As a result, these approaches often fail to discover hidden malicious patterns. This paper introduces SEEAD, a novel and generic semantic-based de-obfuscation system. When building SEEAD, we try to rely on as few assumptions about the structure of the obfuscation tool as possible, so that the system can keep pace with the fast evolving code obfuscation techniques. To increase the code coverage, SEEAD dynamically directs the target program to execute different paths across different runs. This dynamic profiling scheme is rife with taint and control dependence analysis to reduce the search overhead, and a carefully designed protection scheme to bring the program to an error free status should any error happens during dynamic profile runs. As a result, the increased code coverage enables us to uncover hidden malicious behaviors that are not detected by traditional dynamic analysis based de-obfuscation approaches. We evaluate SEEAD on a range of benign and malicious obfuscated programs. Our experimental results show that SEEAD is able to successfully recover the original logic from <b>obfuscated</b> <b>binaries...</b>|$|E
50|$|Many {{antivirus}} {{programs can}} successfully detect and remove Blackshades, however hackers using the Blackshades software usually avoid detection of Blackshades infections by using software that <b>obfuscates</b> the Blackshades <b>binary</b> to avoid detection by antivirus programs, which the Blackshades organization also sold {{along with the}} Blackshades software.|$|R
40|$|Abstract—Malwares are {{becoming}} increasingly stealthy, more and more malwares are using cryptographic algorithms (e. g., packing, encrypting C&C communication) {{to protect themselves from}} being analyzed. The use of cryptographic algorithms and truly transient cryptographic secrets inside the malware binary imposes a key obstacle to effective malware analysis and defense. To enable more effective malware analysis, forensics and reverse engineering, we have developed CipherXRay – a novel binary analysis framework that can automatically identify and recover the cryptographic operations and transient secrets from the execution of potentially <b>obfuscated</b> <b>binary</b> executables. Based on the avalanche effect of cryptographic functions, CipherXRay is able to accurately pinpoint the boundary of cryptographic operation and recover truly transient cryptographic secrets that only exist in memory for one instant in between multi-ple nested cryptographic operations. CipherXRay can further identify certain operation modes (e. g., ECB, CBC, CFB) of the identified block cipher and tell whether the identified block cipher operation is encryption or decryption in certain cases. We have empirically validated CipherXRay with OpenSSL, popular password safe KeePassX, the ciphers used by malware Stuxnet, Kraken and Agobot, and a number of third party softwares with built-in compression and checksum. CipherXRay is able to identify various cryptographic operations and recover cryptographic secrets that exist in memory for only a few microseconds. Our results demonstrate that current software implementations of cryptographic algorithms hardly achieve any secrecy if their execution can be monitored. Index Terms—Binary analysis, avalanche effect, key recovery attack on cryptosystem, transient cryptographic secret recovery, secrecy of monitored execution, reverse engineering. I...|$|R
40|$|Botnets is {{a serious}} threat to Internet security. Popular defense {{strategies}} such as traffic filtering and malware detection all require a good understanding of the constituent bot binaries for creating the corresponding filter rules or signatures. This means that an effective analysis and classification process for bot binaries is needed for dealing with the threat of botnets. Unfortunately, the rampant usage of binary obfuscation these days has made the analysis and classification rather difficult. A simple string pattern matching or disassembly of the binary no longer suffices as the exact instruction sequence can be easily altered by obfuscation. In this work, we propose a new framework for automatic analysis and classification of bot binaries. The framework analyzes a bot binary’s runtime system call trace and uses the longest common subsequences between system call traces for the classification of bot binaries. The framework can effectively deal with <b>obfuscated</b> bot <b>binaries.</b> Experiment result shows that the framework can attain an overall 94 % true positive rate and 93 % true negative rate...|$|R
40|$|The {{ability to}} {{identify}} authors of computer programs based on their coding style is {{a direct threat to}} the privacy and anonymity of programmers. While recent work found that source code can be attributed to authors with high accuracy, attribution of executable binaries appears to be much more difficult. Many distinguishing features present in source code, e. g. variable names, are removed in the compilation process, and compiler optimization may alter the structure of a program, further obscuring features that are known to be useful in determining authorship. We examine programmer de-anonymization from the standpoint of machine learning, using a novel set of features that include ones obtained by decompiling the executable binary to source code. We adapt a powerful set of techniques from the domain of source code authorship attribution along with stylistic representations embedded in assembly, resulting in successful de-anonymization of a large set of programmers. We evaluate our approach on data from the Google Code Jam, obtaining attribution accuracy of up to 96 % with 100 and 83 % with 600 candidate programmers. We present an executable binary authorship attribution approach, for the first time, that is robust to basic obfuscations, a range of compiler optimization settings, and binaries that have been stripped of their symbol tables. We perform programmer de-anonymization using both <b>obfuscated</b> <b>binaries,</b> and real-world code found "in the wild" in single-author GitHub repositories and the recently leaked Nulled. IO hacker forum. We show that programmers who would like to remain anonymous need to take extreme countermeasures to protect their privacy. Comment: 15 page...|$|E
40|$|Abstract Disassembly is {{the process}} of {{recovering}} a symbolic rep-resentation of a program's machine code instructions from its binary representation. Recently, a number oftechniques have been proposed that attempt to foil the disassembly process. These techniques are very effec-tive against state-of-the-art disassemblers, preventing a substantial fraction of a binary program from being dis-assembled correctly. This could allow an attacker to hide malicious code from static analysis tools that depend oncorrect disassembler output (such as virus scanners). The paper presents novel binary analysis techniquesthat substantially improve the success of the disassembly process when confronted with <b>obfuscated</b> <b>binaries.</b> Based on control flow graph information and statistical methods, a large fraction of the program's instructionscan be correctly identified. An evaluation of the accuracy and the performance of our tool is provided, alongwith a comparison to several state-of-the-art disassemblers. Keywords: Binary Obfuscation, Reverse Engineering,Static Analysis. 1 Introduction Software applications are often distributed in binaryform to prevent access to proprietary algorithms or to make tampering with licensing verification proceduresmore difficult. The general assumption is that understanding the structure of a program by looking at its bi-nary representation is a hard problem that requires substantial resources and expertise. Software reverse-engineering techniques provide auto-mated support for the analysis of binary programs. The goal of these techniques is to produce a higher-level rep-resentation of a program that allows for comprehension and possibly modification of the program's structure. The software reverse-engineering process can be dividedinto two parts: disassembly and decompilation. The task of the disassembly phase is the extraction of thesymbolic representation of the instructions (assembly code) from the program's binary image [12]. Decompi-lation [5, 6] {{is the process}} of reconstructing higher-level semantic structures (and even source code) from the pro-gram's assembly-level representation...|$|E
40|$|Program {{obfuscation}} {{is increasingly}} popular among malware creators. Objectively comparing different malware detection approaches {{with respect to}} their resilience against obfuscation is challenging. To the best of our knowledge, there is no common empirical framework for evaluating the resilience of malware detection approaches w. r. t. behavior obfuscation. We propose and implement such a framework that obfuscates the observable behavior of malware binaries. To assess the framework's utility, we use it to <b>obfuscate</b> known malware <b>binaries</b> and then investigate the impact on detection effectiveness of different $n$-gram based detection approaches. We find that the obfuscation transformations employed by our framework significantly affect the precision of such detection approaches. Several $n$-gram-based approaches can hence be concluded not to be resilient against this simple kind of obfuscation...|$|R
40|$|Information about {{calls to}} the {{operating}} system (or kernel libraries) made by a binary executable {{may be used to}} determine whether the binary is malicious. Being aware of this approach, malicious programmers hide this information by making such calls without using the call instruction. For instance, the ‘call addr’ instruction may be replaced by two push instructions and a return instruction, the first push pushes the address of instruction after the return instruction, and the second push pushes the address addr. The code may be further obfuscated by spreading the three instructions and by splitting each instruction into multiple instructions. This paper presents a method to statically detect <b>obfuscated</b> calls in <b>binary</b> code. The notion of abstract stack is introduced to associate each element in the stack to the instruction that pushes the element. An abstract stack graph is a concise representation of all abstract stacks at every point in the program. An abstract stack graph, created by abstract interpretation of the binary executables, may be used to detect obfuscated calls and other stack related obfuscations. 1...|$|R
40|$|Software {{protection}} {{is one of}} the most important problems in the area of computing as it affects a multitude of players like software vendors, digital content providers, users, and government agencies. There are multiple dimensions to this broad problem of software protection. The most important ones are: (1) protecting software from reverse engineering. (2) protecting software from tamper (or modification). (3) preventing software piracy. (4) verification of integrity of the software;In this thesis we focus on these areas of software protection. The basic requirement to achieve these goals is to provide a secure execution environment, which ensures that the programs behave in the same way as it was designed, and the execution platforms respect certain types of wishes specified by the program;We take the approach of providing secure execution environment through architecture support. We exploit the power of reconfigurable components in achieving this. The first problem we consider is to provide architecture support for obfuscation. This also achieves the goals of tamper resistance, copy protection, and IP protection indirectly. Our approach is based on the intuition that the software is a sequence of instructions (and data) and if the sequence as well the contents are obfuscated then all the required goals can be achieved;The second problem we solve is integrity verification of the software particularly in embedded devices. Our solution is based on the intuition that an <b>obfuscated</b> (permuted) <b>binary</b> image without any dynamic traces reveals very little information about the IP of the program. Moreover, if this obfuscation function becomes a shared secret between the verifier and the embedded device then verification can be performed in a trustworthy manner;Cryptographic components form the underlying building blocks/primitives of any secure execution environment. Our use of reconfigurable components to provide software protection in both Arc 3 D and TIVA led us to an interesting observation about the power of reconfigurable components. Reconfigurable components provide the ability to use the secret (or key) in a much stronger way than the conventional cryptographic designs. This opened up an opportunity for us to explore the use of reconfigurable gates to build cryptographic functions...|$|R

