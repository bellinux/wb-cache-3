5|7|Public
5000|$|An [...] "overrun error" [...] {{occurs when}} the {{receiver}} cannot process the character that just came in before the next one arrives. Various devices have different amounts of buffer space to hold received characters. The CPU or DMA controller must service the UART in order to remove characters from the input buffer. If the CPU or DMA controller does not service the UART quickly enough and the buffer becomes full, an <b>Overrun</b> <b>Error</b> will occur, and incoming characters will be lost.|$|E
5000|$|The {{experimental}} valgrind tool exp-sgcheck {{has been}} written to address this limitation in Memcheck. It will detect array overrun errors, provided the first access to an array is within the array bounds. Note that exp-sgcheck will not detect the array overrun in the code above, since the first access to an array is out of bounds, but it will detect the array <b>overrun</b> <b>error</b> in the following code. [...] void func(void) { int i, Stack5; for (i = 0; i <= 5; i++) Stack i = 0; /* Within bounds for i=0..4, out of bounds error when i=5 */ } ...|$|E
50|$|A {{look at the}} {{performance}} requirements at high bit rates shows why the 16, 32, 64 or 128 byte FIFO is a necessity. The Microsoft specification for a DOS system requires that interrupts not be disabled for more than 1 millisecond at a time. Some hard disk drives and video controllers violate this specification. 9600 bit/s will deliver a character approximately every millisecond, so a 1 byte FIFO should be sufficient at this rate on a DOS system which meets the maximum interrupt disable timing. Rates above this may receive a new character before the old one has been fetched, and thus the old character will be lost. This {{is referred to as}} an <b>overrun</b> <b>error</b> and results in one or more lost characters.|$|E
5000|$|... exp-sgcheck (named exp-ptrcheck {{prior to}} version 3.7), an {{experimental}} tool to find stack and global array <b>overrun</b> <b>errors</b> which Memcheck cannot find. Some code results in false positives from this tool.|$|R
5000|$|A {{guaranteed}} {{maximum price}} (also known as GMP, not-to-exceed price, NTE, or NTX) contract is a cost-type contract (also {{known as an}} open-book contract) where the contractor is compensated for actual costs incurred plus a fixed fee subject to a ceiling price. The contractor is responsible for cost overruns, unless the GMP has been increased via formal change order (only {{as a result of}} additional scope from the client, not price <b>overruns,</b> <b>errors,</b> or omissions). Savings resulting from cost underruns are returned to the owner. This is different from a fixed-price contract (also known as stipulated price contract or lump-sum contract) where cost savings are typically retained by the contractor and essentially become additional profits.|$|R
50|$|As of July 2012 {{there had}} been 23 hull losses from all causes {{including}} prototype testing, fires, runway <b>overruns,</b> navigational <b>errors,</b> and non-operational incidents, 48% of which did not involve fatalities, with 1,141 fatalities total. This figure and the list below includes planes that were still operable but were deemed uneconomic to return to service due to their age and/or flight hours (YR-IRD and CU-T1283).|$|R
40|$|In {{parallel}} communication {{the cost}} {{as well as}} complexity of the system increases due to simultaneous transmission of data bits on multiple wires. Serial communication alleviates this drawback and emerges as effective candidate in many applications for long distance communication as it reduces the signal distortion because of its simple structure. This paper focuses on the VHDL implementation of UART with status register which supports asynchronous serial communication. The paper presents the architecture of UART which indicates, during reception of data, parity error, framing error, <b>overrun</b> <b>error</b> and break error using status register. The whole design is functionally verified using Xilinx ISE Simulator...|$|E
40|$|A UART (Universal Asynchronous Receiver and Transmitter) is {{a device}} {{allowing}} the reception and transmission of information, in a serial and asynchronous way. This project {{focuses on the}} implementation of UART with status register using multi bit flip-flop and comparing it with UART with status register using single bit flip-flops. During the reception of data, status register indicates parity error, framing error, <b>overrun</b> <b>error</b> and break error. The multi bit flip-flop is indicated in this status register. In modern very large scale integrated circuits, Power reduction and area reduction has become a vital design goal for sophisticated design applications. So in this project the power consumed and area occupied by both multi-bit flip-flop and single bit flip is compared. The underlying idea behind multi-bit flip-flop method is to eliminate total inverter number by sharing the inverters in the flip-flops. Based on the elimination feature of redundant inverters in merging single bit flip-flops into multi bit flip-flops, gives reduction of wired length and this result in reduction of power consumption and area...|$|E
40|$|This paper advocates {{the use of}} a monitor-and-recover {{programming}} paradigm {{to enhance}} the reliability of software, and proposes an architectural design that allows software and hardware to cooperate in making this paradigm more efficient and easier to program. We propose that programmers write monitoring functions assuming simple sequential execution semantics. Our architecture speeds up the computation by executing the monitoring functions speculatively in parallel with the main computation. For recovery, programmers can define fine-grain transactions whose side effects, including all register modifications and memory writes, can either be committed or aborted under program control. Transactions are implemented efficiently by treating them as speculative threads. Our experimental results suggest that monitored execution is more amenable to parallelization than regular program execution. Code monitoring is sped up by a factor of 1. 6 by exploiting singlethread instruction-level parallelism, and by another factor of 1. 6 using thread-level speculation. This results in an overall improvement of 2. 5 times and a sustained 5. 4 instructions-per-cycle performance. A monitored execution that used to be 2. 5 times slower executes with a degradation of only 12 % when compared to the performance on the baseline machine. We also show that the concept of fine-grain transactional programming is useful in catching buffer <b>overrun</b> <b>errors</b> through a number of real-life examples. 1...|$|R
40|$|An {{efficient}} {{way to reduce the}} consumption of materials and energy in buildings is represented by an improvement of building processes. A regulated information management is essential to avoid delays, cost <b>overrun,</b> <b>errors</b> and lack of performances during the whole building life-cycle. Thus, the adoption of an integrated design process is becoming of great importance; BIM, considered as building information modelling and management, could be a way to perform such integrated processes. A central repository for project data and information could be advantageous if knowledge is exchanged between different stakeholders (e. g. through IFC or gbXML). Moreover, BIM supports building performance analyses and evaluations, allowing, for instance, simulation of energy performance, computation of environmental impacts and estimation of costs. In this way, it is possible to compare several options and choose the optimal ones. The importance of the link between BIM and sustainable buildings is underlined by the state of the art, such as the Green Overlay to the RIBA Outline Plan of Work, the series 10 of COBIM related to energy analysis, and the BIM Guide for energy performance developed by GSA. An Italian case study for the improvement of the building process is Innovance, a research project with the aim of developing a national database for the construction sector. In order to improve the collection, storing, management and sharing of data, an unambiguous classification system and standardized technical sheets have been developed and a web portal has been designed to ensure the interaction among stakeholders...|$|R
40|$|The Danish {{construction}} industry {{is characterized by}} the same problems as construction industries in most countries: low productivity, <b>errors,</b> <b>overruns</b> in cost and schedule, bad reputation and a high accident rate. Since the mid 80 es a number of initiatives have been taken by the government and the industry to better this situation and a number of white papers have been prepared on the problems and possible solutions (Bertelsen and Nielsen, 1999). In the beginning of the 1990 'es a series of experiments was undertaken using a just in time pull logistic in supply of materials to the construction sites. The methods developed for this were strikingly similar to the Last Planner being developed independently by Glenn Ballard et al at the same time. (Bertelsen and Nielsen...|$|R
40|$|We {{consider}} {{the problem of}} routing in a delay tolerant network (DTN) {{in the presence of}} path failures. Previous work on DTN routing has focused on using precisely known network dynamics, which does not account for message losses due to link failures, buffer <b>overruns,</b> path selection <b>errors,</b> unscheduled delays, or other problems. We show how to split, replicate, and erasure code message fragments over multiple delivery paths to optimize the probability of successful message delivery. We provide a formulation of this problem and solve it for two cases: a 0 / 1 (Bernoulli) path delivery model where messages are either fully lost or delivered, and a Gaussian path delivery model where only a fraction of a message may be delivered. Ideas from the modern portfolio theory literature are borrowed to solve the underlying optimization problem. Our approach is directly relevant to solving similar problems that arise in replica placement in distributed file systems and virtual node placement in DHTs. In three different simulated DTN scenarios covering a wide range of applications, we show the effectiveness of our approach in handling failures. Categories and Subject Descriptors...|$|R

