17|185|Public
50|$|In contrast, {{configuration}} {{objects and}} attributes are prescriptive as for management applications - or <b>object</b> <b>managers</b> (OM) - {{they are the}} means to provide input to the object implementers on what entities they need to implement.|$|E
50|$|The Object Manager is {{in charge}} of {{managing}} NT objects. As part of this responsibility, it maintains an internal namespace where various operating system components, device drivers and Win32 programs can store and lookup objects. The NT Native API provides routines that allow user space (mode) programs to browse the namespace and query the status of objects located there, but the interfaces are undocumented. NT supports per-object (file, function, and role) access control lists allowing a rich set of security permissions to be applied to systems and services. WinObj is a Windows NT program that uses the NT Native API (provided by NTDLL.DLL) to access and display information on the NT <b>Object</b> <b>Managers</b> name space.|$|E
40|$|Future <b>object</b> <b>managers</b> will utilise {{existing}} {{relational database}} systems as primitive building blocks replacing today's file systems. SQL, similar to assembler language today, {{will be used}} to implement higher-order <b>object</b> <b>managers.</b> Current middleware layers will be extended to a coordination layer that uses and controls different database systems used as storage systems and as index managers. We substantiate this claim by presenting two middleware prototype systems as first steps into this visionary direction. One provides a generic object data model layer to the clients. It is mapped to a relational multiprocessor database system. The other is a textual document object manager that is implemented using a TP-monitor together with a relational multi-processor system for storage management. A key aspect in both prototypes is highlevel parallelism for high performance in terms of response times and throughput. We achieve this by a synthesis of research results in the area of multilevel tr [...] ...|$|E
50|$|An <b>Object</b> <b>manager</b> is a concept, {{and often}} a piece of software, found in Object-oriented programming. The <b>object</b> <b>manager</b> {{provides}} rules for retention, naming and security of objects.|$|R
40|$|In {{this paper}} we {{describe}} an <b>object</b> <b>manager,</b> {{that has been}} developed for simplifying groupware development. The <b>object</b> <b>manager</b> {{offers a variety of}} services for controlling an application's shared data, including flexible object distribution, flexible coupling of user interface and shared data, latecomer support and configurable concurrency control. After {{a brief description of the}} <b>object</b> <b>manager</b> in total, we focus on a configurable concurrency control scheme. An example and directions for future work conclude the paper...|$|R
25|$|The <b>Object</b> <b>Manager</b> (internal name Ob) is an {{executive}} subsystem that all other executive subsystems, especially system calls, must pass through {{to gain access}} to Windows NT resources—essentially making it a resource management infrastructure service. The <b>object</b> <b>manager</b> is used to reduce the duplication of object resource management functionality in other executive subsystems, which could potentially lead to bugs and make development of Windows NT harder. To the <b>object</b> <b>manager,</b> each resource is an object, whether that resource is a physical resource (such as a file system or peripheral) or a logical resource (such as a file). Each object has a structure or object type that the <b>object</b> <b>manager</b> must know about.|$|R
40|$|Data {{checkpointing}} is {{an important}} problem of distributed database systems. Actually, transactions establish dependence relations on data checkpoints taken by data <b>object</b> <b>managers.</b> So, given an arbitrary set of data checkpoints (including at least a single data checkpoint from a data manager, and at most a data checkpoint from each data manager), an important question is the following one: "Can these data checkpoints be members of a same consistent global checkpoint?". This paper answers this question and proposes a non-intrusive data checkpointing protocol. © Springer-Verlag Berlin Heidelberg 1999...|$|E
40|$|With {{the advent}} of the {{information}} society, many researchers are turning to artificial intelligence techniques to provide effective retrieval over large bodies of textual information. Yet any AI system requires a formalism for encoding its knowledge about the objects of its knowledge, the world, and the intelligence that it is designed to manifest. In the CODER system, the mission of which is to provide an environment for experiments in applying AI to information retrieval, that formalism is provided by a single well defined factual representation language. Designed as a flexible tool for retrieval research, the CODER factual representation language is a hybrid AI language involving a system of strong types for attribute values, a frame system, and a system of Prolog-like relational structures. Inheritance is enforced throughout, and the semantics of type subsumption and object matching formally defined. A collection of type and <b>object</b> <b>managers</b> called the knowledge administration complex implements this common language for storing knowledge and communicating it within the system. Of the three types of knowledge structures in the language, the frame facility has proven most useful in the retrieval domain. The factual representation language is implemented in Prolog as a set of predicates accessible to all system modules. Each level of knowledge representation (elementary primitives, frames, and relations) has a type manager; the frame and relation levels also have <b>object</b> <b>managers.</b> Storage of complete knowledge objects (statements in the factual representation language) is supported by a system or external knowledge bases. One paper discusses the frame construct itself, the implementation of the knowledge administration complex and external knowledge bases. {{and the use of the}} construct in retrieval research. The paper closes with a discussion of the utility of the language in experiments...|$|E
40|$|This paper {{presents}} an architecture for a persistent object store in which multi-level storage is explicitly included. Traditionally, DBMSs {{have assumed that}} all accessible data resides on magnetic disk, and recently several researchers have begun {{to consider the possibility}} that significant amounts of data will occupy space in a main memory cache. We feel that future <b>object</b> <b>managers</b> will be called on to manage very large object bases in which time critical objects reside in main memory, other objects are disk resident, and the remainder occupy tertiary memory. Moreover, it is possible that more than three levels will be present, and that some of these levels will be on remote hardware. This paper contains an architectural proposal addressing these needs along with a sketch of the required query optimizer. 1...|$|E
25|$|Object {{creation}} {{is a process}} in two phases, creation and insertion. Creation causes the allocation of an empty object and the reservation of any resources required by the <b>object</b> <b>manager,</b> such as an (optional) name in the namespace. If creation was successful, the subsystem responsible for the creation fills in the empty object. Finally, if the subsystem deems the initialization successful, it instructs the <b>object</b> <b>manager</b> to insert the object, which makes it accessible through its (optional) name or a cookie called a handle. From then on, the lifetime of the object is handled by the <b>object</b> <b>manager,</b> and it's up to the subsystem to keep the object in a working condition until being signaled by the <b>object</b> <b>manager</b> to dispose of it.|$|R
5000|$|<b>Object</b> <b>Manager</b> (internally called Ob) is a {{subsystem}} implemented {{as part of}} the Windows Executive {{which manages}} Windows resources. Each resource, which are surfaced as logical objects, resides in a namespace for categorization. Resources can be physical devices, files or folders on volumes, Registry entries or even running processes. All objects representing resources have an [...] property and other metadata about the resource. <b>Object</b> <b>Manager</b> is a shared resource, and all subsystems that deal with the resources have to pass through the <b>Object</b> <b>Manager.</b>|$|R
5000|$|... #Caption: <b>Object</b> <b>Manager</b> in Windows, {{categorized}} hierarchically using namespaces ...|$|R
40|$|Designers of {{data systems}} for {{next-generation}} physics experiments face a bewildering array of potential paths. On the one hand, object data base technology is quite promising, and standardization efforts are underway in this arena. On another, lightweight <b>object</b> <b>managers</b> may offer greater potential for delivering the high performance needed from petabyte-scale data stores, and may allow more efficient tailoring to specific parallel and distributed environments, {{as well as}} to multilevel storage. Adding to the confusion is the evolution of persistence services specifications such as those promulgated by the Object Management Group (OMG). In this paper, we describe what we have learned in efforts to implement a physics data store using several of these technologies, including a lightweight object persistence manager aiming at plug-and-play with object databases, and a trial implementation of the OMG Persistent Data Services Direct Access protocol...|$|E
40|$|Whether {{it is for}} audit or for {{recovery}} purposes, data checkpointing is an important problem of distributed database systems. Actually, transactions establish dependence relations on data checkpoints taken by data <b>object</b> <b>managers.</b> So, given an arbitrary set of data checkpoints (including at least a single data checkpoint from a data manager, and at most a data checkpoint from each data manager), an important question is the following one: "Can these data checkpoints be members of a same consistent global checkpoint?". This paper answers this question by providing a necessary and sufficient condition suited for database systems. Moreover, to show the usefulness of this condition, two non-intrusive data checkpointing protocols are derived from this condition. It is also {{interesting to note that}} this paper, by exhibiting "correspondences", establishes a bridge between the data object/transaction model and the process/message-passing model. Comment: 13 pages, 3 figure...|$|E
40|$|WEA is our {{implementation}} of a new architectural model for virtual memory access, the WorkSpace. It relies on a generalisation of client / server model and enables to build new distributed applications. The workspace supplies uniform access to a distributed persistent object store. This paper describes several ways of building multi-workspace architecture, and an {{implementation of}} this architecture. This implementation is based on new operating systems features. Keyword Codes: C. 2. 4, D. 1. 5, D 4. 2 Keywords: Distributed Systems; Object-oriented Programming; Storage Management 1. INTRODUCTION Object-oriented languages are a major advance in Software Engineering. However, the developer usually has to use file systems for data archival. File systems do not enable a simple memorization of pointers on the archive, or direct management of objects in the archive. Persistent <b>Object</b> <b>Managers</b> enable full and reliable integration of the functionalities of objectoriented programming languages, and [...] ...|$|E
5000|$|... {{the data}} (Fields, <b>Objects,</b> <b>Managers,</b> etc.) {{encapsulated}} by instances of the class.|$|R
40|$|We {{address the}} {{generation}} of execution plans for object-oriented database queries. This is a challenging area of study because, unlike the relational algebra, a uniformly accepted set of object algebra operators has not been defined. Additionally, a standardized <b>object</b> <b>manager</b> interface analogous to storage manager interfaces of relational systems does not exist. We define the interface to an <b>object</b> <b>manager</b> whose operations are the executable elements of query execution plans. Parameters to the <b>object</b> <b>manager</b> interface are streams of tuples of object identifiers. The <b>object</b> <b>manager</b> can apply methods and simple predicates to the objects identified in a tuple. Two algorithms for generating execution plans for queries expressed in an object algebra are presented. The first algorithm runs quickly but may produce inefficient plans. The second algorithm enumerates all possible execution plans and presents them in an efficient, compact representation. 1 Introduction There is significant inte [...] ...|$|R
40|$|The Teradata Multimedia <b>Object</b> <b>Manager</b> is a generalpurpose content {{analysis}} multimedia server designed for symmetric multiprocessing and massively parallel processing environments. The Multimedia <b>Object</b> <b>Manager</b> defines and manipulates user-defined functions (UDFs), which {{are invoked in}} parallel to analyze or manipulate the contents of multimedia objects. Several computationally intensive applications of this technology, which use large persistent datasets, include fingerprint matching, signature verification, face recognition, and speech recognition/translation...|$|R
40|$|Roberto Baldoni 1, Francesco Quaglia 1, and Michel Raynal 2 1 DIS, Universit`a "La Sapienza", Roma, Italy 2 IRISA - Campus de Beaulieu, 35042 Rennes Cedex, France Abstract. Data {{checkpointing}} is {{an important}} problem of distributed database systems. Actually, transactions establish dependence relations on data checkpoints taken by data <b>object</b> <b>managers.</b> So, given an arbitrary set of data checkpoints (including at least a single data checkpoint from a data manager, and at most a data checkpoint from each data manager), an important question is the following one: "Can these data checkpoints be members of a same consistent global checkpoint?". This paper answers this question and proposes a non-intrusive data checkpointing protocol. 1 Introduction Checkpointing the state of a database is important for audit or recovery purposes. When compared to its counterpart in distributed systems, the database checkpointing problem has additionally {{to take into account}} the serialization order [...] ...|$|E
40|$|We {{describe}} a new deadlock detection scheme that was devised for a distributed system of autonomously operating <b>object</b> <b>managers.</b> In this system two-phase lockingbased synchronization of parallel transactions is done locally [...] -e. g., by employing a semantic locking {{scheme based on}} the objects' interface operations. The deadlock detection is enabled by dynamically created deadlock detection agents (DDAs). Transactions start executing without any DDA. Only if a conflict with some other transaction occurs they {{are associated with a}} DDA: either a DDA one of the conflicting transactions is already associated with or, if no such DDA exists, a newly created one. If two transactions that are already associated with different DDAs encounter a conflict, their two DDAs are merged into one DDA. The DDA scheme is a "self-tuning" system: After an initial warm-up phase, dedicated DDAs will be formed for so-called centers of locality. A dynamic shift in locality of the distributed system wil [...] ...|$|E
40|$|Many {{applications}} of object-oriented systems {{benefit from the}} ability to make objects persistent. To be fully effective, this persistence must be provided {{in such a way as}} to allow both the database of persistent objects and the applications to evolve. As they evolve, upward compatibility must be maintained so that new versions of applications can continue to use existing persistent objects and vice versa. This implies that a persistent object system must be able to handle type mismatches between objects in secondary storage and objects in an application program. In this paper, we formalize some of the categories of type mismatches that can occur as a result of application program and database evolution. We show how the concept of an object manager can be used to resolve many of the mismatches in these categories. Finally, we discuss how <b>object</b> <b>managers</b> have been incorporated into a particular persistent object system under development at Rensselaer Polytechnic Institute. 1. Introduc [...] ...|$|E
40|$|Manage: creating, deleting, {{protecting}} and tracking Objects are data structures with optional names “Objects ” managed here include Executive objects and Kernel objects, but not Windows User/GDI objects (Win 32 k. sys) <b>Object</b> <b>manager</b> implements user-mode handles {{and the process}} handle table <b>Object</b> <b>manager</b> is not used for all Windows data structures Generally, only those types {{that need to be}} shared, named, or exported to user mode Some data structures are called “objects ” but are not managed by the <b>object</b> <b>manager</b> (e. g. “DPC objects”) 4 <b>Object</b> <b>Manager</b> (II) In part, a heap manager… Allocates memory for data structure from system-wide, kernel space heaps (pageable or nonpageable) … with a few extra functions: Assigns name to data structure (optional) Allows lookup by name Objects can be protected by ACL-based security Provides uniform naming, sharing, and protection scheme Simplifies C 2 security certification by centralizing all object protection in one place Maintains counts of handles and references (stored pointers in kernel space) to each object Object cannot be freed back to the heap until all handles and references are gone...|$|R
50|$|<b>Object</b> <b>Manager</b> is the {{centralized}} resource {{broker in}} the Windows NT line of Operating Systems, which {{keeps track of}} the resources allocated to processes. It is resource-agnostic and can manage any type of resource, including device and file handles. All resources are represented as objects, each belonging to a logical namespace for categorization and having a type that represents the type of the resource, which exposes the capabilities and functionalities via properties. An object is kept available until all processes are done with it; <b>Object</b> <b>Manager</b> maintains the record of which objects are currently in use via reference counting, {{as well as the}} ownership information. Any system call that changes the state of resource allocation to processes goes via the <b>Object</b> <b>Manager.</b>|$|R
40|$|MODULAR SIMULATION ENVIRONMENTS: AN <b>OBJECT</b> <b>MANAGER</b> BASED ARCHITECTURE To {{perform a}} {{simulation}} project, simulationists employ simulation specific software tools, {{general purpose software}} tools, and perhaps software developed {{to meet the needs}} of a particular project. Ideally, these divergent tools would work together in a seamless simulation environment. Modular simulation environments are one way of meeting this goal. Software tools can be added to or deleted from a modular simulation as needed. Thus, the simulation environment can be configured on a project by project basis or even dynamically during the course of a project. The flow of data between the tools in the environment is also a primary concern. An <b>object</b> <b>manager</b> based architecture provides the capabilities to add and delete software tools as necessary as well as to control the flow of data between the software tools. Each software tool and each data set can be viewed as an object with certain attributes. The <b>object</b> <b>manager</b> controls the invocation of the software tools as well as meeting input data requirements and organizing and managing the results of each operation. The design of such an <b>object</b> <b>manager</b> is presented. An example modular simulation environment is given and its configuration and operation illustrated. ...|$|R
40|$|Trust {{cannot be}} uniform across wide-area networks. There are regions of local trust. Within {{a region of}} trust, {{there can be a}} set of {{software}} components (<b>object</b> <b>managers)</b> that are mutually trusting for the purposes of object sharing, but more global trust models should also be supported. This paper describes such a model and proposes a protocol that exploits local trust to achieve high performance even when objects can migrate between trust domains. Introduction Islands of trust arise in the Internet because trust in computer systems and their software is largely based on confidence in the local administrators of systems and their managers. Each such region of local trust often corresponds to a corporate Intranet. Cooperative working and object sharing extends across the boundaries of local trust domains, for example when several companies collaborate in an engineering or construction project. This corresponds to the 'virtual enterprise' model for cooperation [BP 95]. When this occu [...] ...|$|E
40|$|Flask is a {{flexible}} access control security architecture that supports dynamic security policies. Flask creates this flexible support by separating the security policy decisions {{from the actual}} enforcement of the security policy. Flask “describes the interactions between subsystems that enforce security policy decisions and a subsystem which makes those decisions, and the requirements on the components within each subsystem ” [11]. The Flask security architecture also can be transferred to multiple operating systems {{as well as other}} systems that require a security policy decision-making and enforcement system. Flask is an improvement of the security architecture previously developed for the Distributed Trusted Operating System (DTOS) and described in [7]. Flask and DTOS separate security policy decisions from security policy enforcement {{through the use of a}} security server that makes the decisions and <b>object</b> <b>managers</b> that are in charge of the enforcement for individual tasks. This separation allows Flask to support flexible mandatory access control (MAC). This paper will describe the advantages of the Flask security architecture as well as some of the issues with this architecture. The specific advantages that will be discussed in this paper are the separation of access control decisions from enforcement including security policy flexibility and revocation of previously granted access rights, the caching of previously determined access rights, and the capability to implement the architecture i...|$|E
40|$|Traditional {{approaches}} to versioning semistructured information are edit-based, i. e., subsequent document versions {{are represented by}} using edit scripts. This paper proposes a reference-based version management scheme that preserves the logical structure of the evolving document {{through the use of}} object references. By preserving the document structure among versions the new scheme facilitates more efficient query support. In particular, we examine queries involving projections and selections on the document versions, as well as queries on the document evolution history. Moreover, we show that the proposed scheme provides an effective representation of multiversioned XML documents, both at the transport and exchange levels. In fact, with the reference-based scheme, a document's history can also be viewed and processed as yet another XML document. Furthermore, we demonstrate the effectiveness of the new scheme at the storage level. In particular, the scheme is enhanced with a usefulness-based page management policy that extends and adapts techniques used in transaction-time databases to ensure efficient clustering of information among versions. An extensive comparison of the reference-based versioning against representations used in temporal databases and persistent <b>object</b> <b>managers</b> depicts the performance advantages of the new approach. Finally {{it should be noted that}} reference-based versioning is applicable to other kinds of semistructured information (besides XML documents), and can be used to replace traditional version control schemes, such as the edit-based RCS and the timestamp-based SCCS...|$|E
40|$|In {{this paper}} we {{describe}} an <b>object</b> <b>manager,</b> {{that has been}} developed for simplifying groupware development. The <b>object</b> <b>manager</b> {{offers a variety of}} services for controlling an application's shared data, including flexible object distribution, flexible coupling of user interface and shared data, latecomer support and configurable concurrency control. After {{a brief description of the}} <b>object</b> <b>manager</b> in total, we focus on a configurable concurrency control scheme. An example and directions for future work conclude the paper. INTRODUCTION In this paper we focus on the development of synchronous groupware, which allows users at different places to interact at the same time. Until now synchronous groupware encompasses a wide range of applications like collaborative whiteboards, text editors or web browsers. All these applications have to share data and maintain data consistency. When developing several groupware applications, like a distance teaching environment [7], we noticed that shared [...] ...|$|R
50|$|The November 2007 {{release of}} version 4.4 {{introduced}} a web-based management console that replaced the Java-based <b>Object</b> <b>Manager</b> and Array Manager tools that were first introduced in version 3.0.|$|R
5000|$|... #Caption: Graphical {{view of the}} {{architecture}} of Windows NT 3.1. Shown are the following components of the operating system core: I/O <b>Manager,</b> <b>Object</b> <b>Manager,</b> Security Reference Monitor, Process Manager, Local Procedure Call Facility, Virtual Memory Manager.|$|R
40|$|The ATLAS {{conditions}} databases {{will be used}} {{to manage}} information of quite diverse nature and level of complexity. The usage of a relational database manager like Oracle, together with the <b>object</b> <b>managers</b> POOL and OKS developed in-house, poses special difficulties in browsing the available data while understanding its structure in a general way. This is particularly relevant for the database browser projects where it is difficult to link with the class defining libraries generated by general frameworks such as Athena. A modular approach to tackle these problems is presented here. The database infrastructure is under development using the LCG COOL infrastructure, and provides a powerful information sharing gateway upon many different systems. The nature of the stored information ranges from temporal series of simple values up to very complex objects describing the configuration of systems like ATLAS' TDAQ infrastructure, including also associations to large objects managed outside of the database infrastructure. An important example of this architecture is the online objects extended database browser (NODE), which is designed to access and display all data, available in the ATLAS monitoring data archive (MDA), including histograms and data tables. To deal with the special nature of the monitoring objects, a plugin from the MDA framework to the Time managed science Instrument Databases (TIDB 2) is used. The database browser is extended, in particular to include operations on histograms such as display, overlap, comparisons as well as commenting and local storage. status: publishe...|$|E
40|$|Most BIM (Building Information Modelling) systems serve {{designers}} well {{up until}} now but will have to evolve toward a more user-centered design, focusing on interactive spaces {{rather than focusing on}} digital representation. They are lack of information needed {{in order to create a}} virtual environment which can interact with users. Such problems will become more prominent in the case of smart spaces where the environment reacts to users' activity. There are no sufficient tools to design and represent real usage of smart space. Achieving this aim, the paper presents Smart-BIM consisting of smart objects which can react to user activities. The created virtual space with Smart-BIM is different from conventional 3 D space. Since the resulted space embodies smart objects with the capability of doing certain functions and reacting toward users interaction according to the property sets of objects. A task-based interaction is proposed to apply Smart BIM in a design process. Smart Design systems help end users to experience their daily activity in a virtual environment and understand the space reactions. It can be used as a toolset to improve communications among users and designers in design processes especially in the design of smart environments. Eventually, it is expected that Smart-BIM will lead to match smart technology usability with users' demands. To facilitate further developments of Smart Design systems, a prototyping experiment was done. The prototype application utilizes three typical domestic tasks and several real-time interactions. Scripting the tasks, using smart <b>object</b> <b>managers</b> and using smart home objects make the real-time interactions and system reactions possible. Hence, the prototype gives the opportunity of evaluating users' attitude and expressions toward an interactive and responsive BIM. The results from the first evaluations reveal a positive attitude of users toward the prototype. They also show that when the users can directly execute a task in the virtual model, they can deliver a better comprehension of how smart technologies can be utilized...|$|E
50|$|Accessor {{methods are}} used to read data values of an object. Mutator methods {{are used to}} modify the data of an <b>object.</b> <b>Manager</b> methods are used to {{initialize}} and destroy objects of a class, e.g. constructors and destructors.|$|R
40|$|The {{software}} {{architecture of the}} AVS/Express visualization system is described, with discussion of the dynamic <b>object</b> <b>manager</b> allowing scalable high-performance applications and computational steering. High performance parallel graphics methods are described, including interactive data exploration in immersive environments...|$|R
40|$|We {{developed}} a multimedia presentation authoring system supporting {{a mechanism for}} conceptually representing the temporal relations of different media. Our authoring system represents media (such as images, videos, sounds, etc.) as objects and provides various editing functionalities for temporal compositions and spatial compositions. It {{is based on the}} SMIL (Synchronized Multimedia Integration Language). The system contains a temporal relation editor, a timeline editor, a layout editor, an attribute editor, a tag editor, a text editor, and a SMIL <b>Object</b> <b>Manager.</b> Among the many editors that make up our system, the temporal relation editor provides users with an intuitive mechanism for representing the conceptual flow of a presentation by simple and direct graphical manipulations. The SMIL <b>Object</b> <b>Manager</b> is responsible for the dynamic modification of each editor. The conceptual temporal relation editor and other editors of our system exchange their information in real-time and automatically generate SMIL codes through the SMIL <b>Object</b> <b>Manager.</b> Together they form an easy and efficient multimedia authoring environment. In this paper, we present the design and implementation of a SMIL-based multimedia authoring system and we also propose some ideas to extend the current SMIL specification concerning the reusability of SMIL code...|$|R
50|$|The {{community}} of db4o registered members grew to over 60,000 members. Important db4o-related projects, such as standalone <b>Object</b> <b>Manager,</b> encryption support, Mono support etc., are fully driven by community members. db4o's Code Commander program defined {{the terms and}} conditions of community project development.|$|R
