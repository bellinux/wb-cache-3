15|20|Public
25|$|V (bit 28) is the <b>overflow</b> <b>bit.</b>|$|E
25|$|Q (bit 27) is {{the sticky}} <b>overflow</b> <b>bit.</b>|$|E
25|$|The {{computer}} had 2048 {{words of}} erasable magnetic core memory and 36 kilowords of read-only core rope memory. Both had cycle times of 11.72microseconds. The memory word length was 16 bits: 15 bits {{of data and}} one odd-parity bit. The CPU-internal 16-bit word format was 14 bits of data, one <b>overflow</b> <b>bit,</b> and one sign bit (ones' complement representation).|$|E
50|$|The {{accumulator}} was 38 bits long (adding two <b>overflow</b> <b>bits).</b>|$|R
50|$|The {{choice of}} modulus must {{obviously}} be {{such that the}} results will fit in the block size. 256 is therefore the largest possible modulus for Fletcher-16. It is a poor choice, however, as <b>bits</b> that <b>overflow</b> past <b>bit</b> 7 of the sum are simply lost. A modulus that takes the <b>overflow</b> <b>bits</b> and mixes them into the lower bits provides better error detection. The modulus should, however, be large so as to obtain the largest universe of checksum values. The value 255 takes the second consideration over the first, but {{has been found to}} have excellent performance.|$|R
5000|$|A {{variant of}} the {{previous}} algorithm is to add all the [...] "words" [...] as unsigned binary numbers, discarding any <b>overflow</b> <b>bits,</b> and append the two's complement of the total as the checksum. To validate a message, the receiver adds all {{the words in the}} same manner, including the checksum; if the result is not a word full of zeros, an error must have occurred. This variant too detects any single-bit error, but the promodular sum is used in SAE J1708.|$|R
500|$|The adder is {{designed}} to overflow when {{the sum of the}} absolute value of its operands exceeds its capacity (2N−1). The <b>overflow</b> <b>bit</b> is discarded so the output word width is always equal to its input word width. The remainder , called the residual, is stored in the register and the cycle repeats, starting this time from [...] (see figure 2). Since a phase accumulator is a finite state machine, eventually the residual at some sample K must return to the initial value [...] The interval K {{is referred to as the}} grand repetition rate (GRR) given by ...|$|E
5000|$|Carry-out, which {{conveys the}} carry {{resulting}} from an addition operation, the borrow {{resulting from a}} subtraction operation, or the <b>overflow</b> <b>bit</b> resulting from a binary shift operation.|$|E
50|$|Saturation {{arithmetic}} also enables overflow of additions and multiplications to {{be detected}} consistently without an <b>overflow</b> <b>bit</b> or excessive computation, by simple {{comparison with the}} maximum or minimum value (provided the datum is not permitted to take on these values).|$|E
5000|$|... {{corresponds}} to the carry input into the second CLA; [...] to the third CLA; [...] to the fourth CLA; and [...] to <b>overflow</b> carry <b>bit.</b>|$|R
50|$|Hashes are {{unsigned}} 32 bit integers, {{and start}} with a value of 5381. For each byte of the key, the current hash is multiplied by 33, then XOR'ed with the current byte of the key. <b>Overflow</b> <b>bits</b> are discarded. Slots and tables are trivially computed from hashes. The target table is simply the lowest eight bits of the hash (i.e. hash modulo 256), and the slot within the table is the remaining bits of the hash modulo the table length (i.e. hash divided by 256 modulo table length).|$|R
3000|$|From Fig. 14, we can {{see that}} the average BLR {{decreased}} rapidly as the buffer size increased from (0.5 × 104) bit to (2 × 104) bit. This mean that too small buffer size is more likely to incur queue <b>overflow</b> and <b>bit</b> loss. As Q [...]...|$|R
5000|$|The [...] "SO" [...] input pin, when asserted, {{will set}} the processor's {{overflow}} status bit (deasserting it does not clear the <b>overflow</b> <b>bit,</b> however). This {{can be used by}} a high-speed polling device driver, which can poll the hardware once in only three cycles by using a Branch-on-oVerflow-Clear (BVC) instruction that branches to itself. For example, the Commodore 1541 and other Commodore floppy disk drives use this technique to detect without delay whether the serializer is ready to accept or provide another byte of disk data. Obviously great care must be used in the device driver and the associated system design, as spurious assertion of the <b>overflow</b> <b>bit</b> could ruin arithmetic processing.|$|E
5000|$|The {{invention}} of the ALWAC III-E is attributed to Axel Wenner-Gren, and the name is derived from Axel Leonard Wenner-Gren Automatic Computer. The ALWAC III-E contained 132 - 275 vacuum tubes, 5000 - 5400 silicon diodes, and cost $60,000 - $80,000. [...] Word size was 32 bits + sign + recoverable <b>overflow</b> <b>bit.</b>|$|E
5000|$|At {{one time}} {{this sort of}} hybrid {{approach}} was common in disk and network drivers where there was not DMA or significant buffering available. Because the desired transfer speeds were faster even than could tolerate the minimum four-operation per-datum loop (bit-test, conditional-branch-to-self, fetch, and store), the hardware would often be built with automatic wait state generation on the I/O device, pushing the data ready poll out of software and onto the processor's fetch or store hardware and reducing the programmed loop to two operations. (In effect using the processor itself as a DMA engine.) The 6502 processor offered an unusual means to provide a three-element per-datum loop, as it had a hardware pin that, when asserted, would cause the processor's <b>Overflow</b> <b>bit</b> to be set directly. (Obviously {{one would have to}} take great care in the hardware design to avoid overriding the <b>Overflow</b> <b>bit</b> outside of the device driver!) ...|$|E
5000|$|The core's Status {{register}} has Carry and Zero flag <b>bits.</b> <b>Overflow</b> and Negative, {{usually found}} in other cores, are not present.|$|R
40|$|In this paper, a new notion {{which we}} call compact {{sequential}} aggregate signatures is introduced and formalized. Informally, a compact sequential aggregate signature states the following thing: for a given message vector m=(m 1, · · · mι), a public key vector PK=(PK 1, · · ·, PKι) and a path p=(v 1, · · ·, vι), where vi=(idi, PKi), {{the size of the}} third component σ in a sequential aggregate signature (m, p, σ) is independent of the path length ι We propose a novel implementation of RSA-based regular signature scheme that works in an extended domain, and then transform it into a compact sequential aggregate signature scheme that works in a common domain such that the size of <b>overflow</b> <b>bits</b> is independent of the path length ι Finally, we show that our implementation is provably secure in the random oracle model assuming that the RSA problem is hard...|$|R
50|$|The {{types of}} errors handled by model include packet errors (both IP and MPEG {{transport}} stream) such as Packet loss, Packet delay variation, Jitter, <b>overflow</b> and underflow, <b>bit</b> errors, and over-the-air transmission errors.|$|R
50|$|The {{computer}} had 2048 {{words of}} erasable magnetic core memory and 36 kilowords of read-only core rope memory. Both had cycle times of 11.72 microseconds. The memory word length was 16 bits: 15 bits {{of data and}} one odd-parity bit. The CPU-internal 16-bit word format was 14 bits of data, one <b>overflow</b> <b>bit,</b> and one sign bit (ones' complement representation).|$|E
5000|$|The adder is {{designed}} to overflow when {{the sum of the}} absolute value of its operands exceeds its capacity (2N−1). The <b>overflow</b> <b>bit</b> is discarded so the output word width is always equal to its input word width. The remainder , called the residual, is stored in the register and the cycle repeats, starting this time from [...] (see figure 2). Since a phase accumulator is a finite state machine, eventually the residual at some sample K must return to the initial value [...] The interval K {{is referred to as the}} grand repetition rate (GRR) given by ...|$|E
5000|$|While Bell in {{his book}} says {{designing}} the LINC provided the ideas for DEC's second and third machines, the 18-bit inexpensive follow-on to its first, the PDP-4 and the company's first 12-bit design of its own, the PDP-5, Digital Equipment Corporation would launch the extremely successful PDP-8 before it manufactured the first next-generation LINC-compatible computer, the LINC-8 and {{a combination of the}} 7400-series chip-based PDP-8/I and a redesigned LINC, combined as the PDP-12. DEC's final 12-bit lab machine, the Lab-8/E, did away with the LINC entirely. http://research.microsoft.com/~gbell/Digital/timeline/1969-2.htm. The first follow-on, the LINC-8, booted (slowly) to a PDP-8 program called PROGOFOP (PROGram OF OPeration) which interfaced to the separate LINC hardware. The PDP-12 was the last and most popular follow-on to the LINC. It was a capable and improved machine, and was more stable than the LINC-8, but architecturally was still an imperfect hybrid of a LINC and a PDP-8, full of many small technical glitches. (For example, the LINC had an <b>overflow</b> <b>bit</b> which was a small but important part of the LINC's machine state; the PDP-12 had no provision for saving and restoring the state of this bit across PDP-8 interrupts.) ...|$|E
25|$|ALGOL 68 leaves {{intentionally}} undefined {{what happens}} in case of integer <b>overflow,</b> the integer <b>bit</b> representation, {{and the degree of}} numerical accuracy for floating point. In contrast, the language Java has been criticized for over-specifying the latter.|$|R
50|$|The {{combination}} of German engines and Norwegian frames was cheap and reliable, with few errors. Tempo-Lett mopeds were especially popular during the 1960s and the 1970s. Carrying a 5-litre gasoline tank, one filling of 4% petroil mix gives a considerable range. The engine is started by selecting neutral between first and 2. gear, then hitting the kickstarter. The Corvette was very reliable; one just tipped the gas dipper until the carb <b>overflowed,</b> a <b>bit</b> throttle and kick, and the Corvette would start.|$|R
25|$|TS (transfer to storage): Store {{register}} A at {{the specified}} memory address. TS also detects, and corrects for, overflows {{in such a}} way as to propagate a carry for multi-precision add/subtract. If the result has no <b>overflow</b> (leftmost 2 <b>bits</b> of A the same), nothing special happens; if there is <b>overflow</b> (those 2 <b>bits</b> differ), the leftmost one goes the memory as the sign bit, register A is changed to +1 or −1 accordingly, and control skips to the second instruction following the TS. Whenever overflow is a possible but abnormal event, the TS was followed by a TC to the no-overflow logic; when it is a normal possibility (as in multi-precision add/subtract), the TS is followed by CAF ZERO (CAF = XCH to fixed memory) to complete the formation of the carry (+1, 0, or −1) into the next higher-precision word. Angles were kept in single precision, distances and velocities in double precision, and elapsed time in triple precision.|$|R
40|$|The Capstone Senior Project {{consists}} of designing {{some of the}} internal hardware components of a microcontroller in VLSI, using the software package L-EDIT. These components work together to create delays {{that can be used}} to run real time devices and trigger interrupts. The design is controlled by a 16 -bit timer. The user can enter an 8 -bit value into the accumulator and through the register controller, store the value in the specified register. The value in each of the four registers is compared to the lower 8 -bits of the timer value in the comparator subsystem. The four comparators then output a single bit that is dependent upon whether or not the values are equal. Description: The design uses a top-down approach. Figure 1 shows the complete system level block diagram. The system has four main subsystems that need to be designed: the timer, the register controller, the register, and the comparator. The user inputs are the 8 -bit value into the accumulator, the 2 -bit register controller value, the reset to the 16 -bit timer, and the clock. The user outputs are the 1 -bit value from each of the four comparators, and the 1 -bit overflow from the timer. Figure 1 : System Block Diagram 316 -bit timer subsystem: The timer is the main element of the project. As can be seen in Figure 2, the inputs to the system are clock and reset. The outputs are the lower 8 bits of the timer value, which input to the comparator subsystem, and the <b>overflow</b> <b>bit,</b> which is an external output. The timer operates as a 16 -bit counter. After FFFFh has been reached, it sets the <b>overflow</b> <b>bit</b> high for one clock pulse and will restart at 0000 h...|$|E
40|$|Beside {{external}} interrupt, the MCU {{responds to}} internal ones which are triggered by external events (on the external pins). The {{source of the}} internal interrupts are hardware components inside the MCU (like the Timers). Using the timer/counter interrupts, you can trigger events at specific time intervals (without using functions like delay and millis). Because these interrupts have an asynchronous behavior, the main program flow can be executed normally and only when a temporal threshold is reached a specific ISR is executed. The timer increments a counter register, and when its maximum counting capacity is reached an <b>overflow</b> <b>bit</b> (flag) is set. The flag can be manually checked or it can trigger an interrupt request. At the ISR execution the fag is reset. Each timer needs a clock source, which most commonly is the development board’s oscillator; its frequency can be divided by an auxiliary counter (prescaler) ...|$|E
30|$|To {{reduce the}} amount of data, the gain controller, which {{receives}} the accumulated spectra, extracts only a 16 -bit fraction from the 40 - to 45 -bit spectrum. The range of the extracted 16 bit, which we call the FFT gain, can be defined by the user with Telnet, where the user does not have to change the FPGA logic to set the FFT gain. This option can be also used to extend the accumulation time. The extracted 16 -bit spectrum is formatted and saved to the external media via G-bit Ethernet within 8  ms. Each spectrum has its own header that includes a timestamp of the hardware. The instrument should be synchronized by an external 10  MHz reference signal that has a precisely correct time to enable scanning observations. The ADC outputs an <b>overflow</b> <b>bit,</b> which is also included in the header, and can be used to check the analog signal level.|$|E
50|$|The scaling range here is for {{any number}} between 65535.9999 and −65536.0 with 16 bits to hold {{fractional}} quantities (of course assuming {{the use of a}} 64 bit result register). Note that some computer architectures may restrict arithmetic to 32 bit results. In this case extreme care must be taken not to <b>overflow</b> the 32 <b>bit</b> register. For other number ranges the binary scale can be adjusted for optimum accuracy.|$|R
25|$|The two's-complement {{system has}} the {{advantage}} that the fundamental arithmetic operations of addition, subtraction, and multiplication are identical to those for unsigned binary numbers (as long as the inputs are represented in {{the same number of}} <b>bits</b> and any <b>overflow</b> beyond those <b>bits</b> is discarded from the result). This property makes the system both simpler to implement and capable of easily handling higher precision arithmetic. Also, zero has only a single representation, eliminating the subtleties associated with negative zero, which exists in ones'-complement systems.|$|R
40|$|This thesis {{documents}} the schematic design, simulation, and fabrication mask layout of a highspeed 16 -bit summation adder {{to be integrated}} into the Digital Image Synthesizer (DIS) Application Specific Integrated Circuit (ASIC). The DIS is a single-chip false target radar image generator to be used in countering wide band imaging radars. The DIS will calculate the false target image in 512 range bins. Each range bit utilizes two identical 16 -bit binary adders. The 16 -Bit Adder must compute the sum of two 16 -bit numbers, providing a 16 -bit sum, carry output, and <b>overflow</b> detection <b>bit.</b> The stated goal is for this adder to perform all of these functions in one pipeline stage while being clocked at 600 MHz. The first part of the design process includes an extensive analysis to utilize the fewest gates in designing the simplest adder that can achieve the 600 MHz goal. SPICE net lists are extracted from these schematic designs and simulations conducted to verify logic functionality and propagation speed. Mask layout of the verified design is constructed using a CMOS 0. 18 micron process utilizing deep submicron technology with six metal interconnect layers. The mask layout design is verified by ensuring all design rule checks (DRC) and layout versus schematic (LVS) checks are satisfied. In aAddition, conclusions and recommendations are provided to assist other DIS project members in using this adder and the aforementioned design process for additional components of the DIS ASIC. US Marine Corps (USMC) autho...|$|R
5000|$|The 8086, 8088, and 80186 have a 20-bit address bus, but {{the unusual}} {{segmented}} addressing scheme Intel chose for these processors actually produces effective addresses which can have 21 significant bits. This scheme shifts a 16-bit segment number left four bits (making a 20-bit number with four least-significant zeros) before adding to it a 16-bit address offset; the maximum sum occurs when both the segment and offset are 0xFFFF, yielding 0xFFFF0 + 0xFFFF = 0x10FFEF. On the 8086, 8088, and 80186, {{the result of}} an effective address that <b>overflows</b> 20 <b>bits</b> is that the address [...] "wraps around" [...] to the zero end of the address range, i.e. it is taken modulo 2^20 (2^20 = 1048576 = 0x100000). However, the 80286 has 24 address bits and computes effective addresses to 24 bits even in real mode. Therefore, for the segment 0xFFFF and offset greater than 0x000F, the 80286 would actually make an access into the beginning of the second mebibyte of memory, whereas the 80186 and earlier would access an address equal to offset-0x10, which is {{at the beginning of the}} first mebibyte. (Note that on the 80186 and earlier, the first kibibyte of the address space, starting at address 0, is the permanent, immovable location of the interrupt vector table.) So, the actual amount of memory addressable by the 80286 and later x86 CPUs in real mode is 1 MiB + 64 KiB - 16 B = 1114096 B.|$|R
40|$|Abstract: Router buffer <b>overflow</b> {{and random}} <b>bit</b> errors {{have always been}} a problem in the Internet. The growth in {{multimedia}} applications in mobile extensions of the Internet has increased the threat from error bursts, random errors, and packet erasures that are a manifestation of wireless channels. Source-coded error resilience has come to prominence in the H. 264 /AVC codec standard, and this paper reviews such innovations surrounding this codec. Some innovations are new variants of an existing technique such as datapartitioning and some are entirely new such as the powerful dispersed-mode flexible macroblock ordering. Other techniques, such as reversible variable length coding, were not be transferred to H. 264 from earlier codecs and, hence, innovations are proposed to still provide robust entropy coding. Other variants such as adaptive intra-refresh are still being experimented with. When error resilience or other protection methods fail to present an adequate video frame then error concealment can be brought to bear. This paper reviews error concealment which is important to commercial companies as they are able to distinguish their codec from others. The paper considers spatial, temporal and hybrid error concealment methods. Though this paper contains over one hundred references it can only provide a slice through this rich field...|$|R

