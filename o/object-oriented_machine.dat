2|32|Public
50|$|Çevirmen is an <b>object-oriented</b> <b>machine</b> {{translation}} {{system designed}} to translate English text files to Turkish in an interactive environment.|$|E
40|$|In this article, an {{object-oriented}} {{approach to}} program applications onto reconfigurable hardware is presented. The underlying runtime support is a multiprocessor structure, called a ROOM (Reconfigurable <b>Object-Oriented</b> <b>Machine).</b> It {{is composed of}} a number of object processors equal to the number of classes required by the application. Some of these object processors can be tailored to the application domain to achieve high performance. We show how this approach facilitates the mapping of applications onto FPGA components. We also give preliminary results based on a pattern-matching algorithm example...|$|E
40|$|Modern virtual <b>machines</b> for <b>object-oriented</b> <b>machines</b> use dynamic (run-time) {{compilation}} {{in order}} to ensure fast execution while maintaining security and portability of program code. Several virtual machine implementations using this compilation model have been implemented and are successfully used in practice, but to date no formal model of program execution and dynamic compilation has been published. This paper presents a formal framework for describing dynamically optimizing virtual machines in the context of purely functional programming languages. ...|$|R
50|$|Bak {{studied at}} Aarhus University in Denmark, {{receiving}} an MS degree {{in computer science}} in 1988 after which he became active in designing and implementing <b>object-oriented</b> virtual <b>machines.</b>|$|R
40|$|The {{design of}} an {{object-oriented}} operating system involves {{the design of}} a model that governs the execution of the tasks. In this paper we show the design goals to build a computational model for an object-oriented operating system based in an <b>object-oriented</b> abstract <b>machine.</b> We propose to adopt an active object model and we consider features like uniformity, homogeneity or selfcontained are essential for objects. Finally, our proposal is to achieve the above using reflectivity as a key characteristic of the system. Keywords: Object-Oriented Operating System (OOOS), <b>Object-Oriented</b> Abstract <b>Machine</b> (OOAM), Object Computation, Object Synchronization, Active Object Model...|$|R
50|$|The <b>Object-Oriented</b> State <b>Machine</b> Operating System (OOSMOS), {{written in}} C, {{promotes}} object-oriented encapsulation and implements a full table-driven hierarchical state machine facility. OOSMOS operates on a bare board or {{in cooperation with}} an existing operating system.|$|R
40|$|The {{design of}} an {{adequate}} computational model for true distributed objects is a non-trivial task, mainly {{if we want}} {{a clear distinction between}} mechanisms and policies and even more if we want policies to be easily replaced or customised. We propose to build an integral object-oriented system structured as an objectoriented operating system based in an <b>object-oriented</b> abstract <b>machine</b> and reflection as the glue that allows interaction between them...|$|R
40|$|AbstractWe {{address the}} problem of {{applying}} resource-bounded functional programming languages in practice on <b>object-oriented</b> virtual <b>machines</b> which include calls to native methods coded in low-level languages without garbage collection support. We consider the application of a functional language with a high-level type system which incorporates measures of heap space consumption in types on such an execution platform. We supplement the syntactic type inference procedure of the functional language with a separate analysis which estimates the costs of memory leaks incurred by calls to garbage collection-ignorant functions...|$|R
50|$|The Little Smalltalk {{system was}} the first Smalltalk {{interpreter}} produced outside of Xerox PARC. Although it lacked many {{of the features of}} the original Smalltalk-80 system, it helped popularize the ideas of <b>object-oriented</b> programming, virtual <b>machines,</b> and bytecode interpreters. Timothy Budd later rewrote Little Smalltalk in Java, and distributes it as the SmallWorld system.|$|R
40|$|Object {{distribution}} {{is an essential}} feature for any object-oriented operating system. In this paper we show how to build the distribution subsystem for an integral object-oriented system based in an <b>object-oriented</b> abstract <b>machine.</b> We propose a distribution mechanism in which the abstract machine intervention has been taken to a minimum. An abstract machine will only know and manage its local objects. Other distributed concepts like replication and transactions can be built above this basic distribution layer. This work has been partially supported by the second regional plan (FICYT) of research of the Principality of Asturias, Spain, under project PBP-TIC 97 - 01 "Object Oriented Integral System: Oviedo 3 " 1...|$|R
40|$|Abstract: Using an <b>object-oriented</b> {{abstract}} <b>machine</b> {{brings a}} number of benefits {{for the construction of}} an object-oriented operating system. In this paper we describe the structure of an abstract machine designed for this task. This machine provides the basic object model and support {{for the rest of the}} system. Among other options, we propose a reflective architecture as a collaboration mechanism between the machine and the OS. Finally, we show how using this architecture based on the abstract machine improves and facilitates the construction of operating system features like orthogonal persistence, object distribution, concurrency and capability-based security, giving a flexible integral OO computing environment. ...|$|R
40|$|Abstract This paper {{describes}} eXAT, {{an experimental}} agent pro-gramming platform, {{based on the}} Erlang language, designed by the authors. The platform provides an "all-in-one " framework for the design, with a single tool, of agent intelligence, agent behaviour and agent communica-tion. This is made possible in eXAT {{by means of the}} integration of an Erlang-based expert system engine, togetherwith an execution environment for agent behaviours based on <b>object-oriented</b> finite-state <b>machines.</b> Such a system al-lows transition triggering on the basis of agent's mental state. Similarly, the provided agent communication facil-ity, which is based on the exchange of ACL speech acts, can not only trigger behaviours but also influence agent's men-tal state according to FIPA-ACL semantics. 1...|$|R
40|$|Conventional paging {{systems do}} not perform well with large {{object-oriented}} environments (such as Smalltalk- 80 1 [GR 83]) {{due to the}} fine granularity of objects and {{the persistence of the}} object space. One approach taken to increase efficiency has been to group objects together in virtual space in an attempt to keep related objects on the same page. Conventionally, grouping has been performed whilst the system is inactive with the objects being ordered in virtual space according to a depth- or breadth-first traversal of the graph formed by the pointers between objects. Whilst such static grouping reduces the amount of paging compared with an arbitrarily grouped system [Sta 84], it is not sufficiently effective to eliminate the paging problems of large persistent object-oriented applications. As part of current research on architectures for high-performance <b>object-oriented</b> <b>machines,</b> a novel dynamically grouped virtual memory system was developed and extensively simulated. With dynamic grouping, objects reside in a virtual object memory and are accessed by pointeroffset addresses. Objects are transferred between primary memory and disk in groups which are determined at run time. Our simulations show that dynamic grouping strategies can achieve significantly better performance than static grouping. In [WWH 87] static and dynamic grouping were simulated and it was discovered that for reasonable memory sizes dynamic grouping reduced page faults by up to three times compared with static grouping. This paper will describe an ideal dynamically grouped virtual memory and will investigate different practical realisations of dynamic grouping schemes. The results of comprehensive simulations of practical implementations will be presented and cost-performance estimations will be compared with conventional memory systems. ...|$|R
40|$|This {{project will}} take an <b>object-oriented</b> {{approach}} to <b>machine</b> translation. Using dependency trees, {{rather than the}} conventional phrase-structure representation, the translator will identify sentence structures and use holes in the parse tree to identify unknown words. Also, rather than making potentially incorrect guesses, the program will ask the user for input, {{with the goal of}} aiding a translator fluent in both languages, rather than users unable to read Russian...|$|R
40|$|Abstract — This paper {{describes}} eXAT, a new agent programming {{platform to}} write and execute agents using the Erlang language. The main characteristic of eXAT is that it provides an “all-in-one framework ” for the design, with a single tool, of agent intelligence, agent behavior and agent communication. This is made possible {{by means of a}} set of modules strongly tied to one another: (i) an Erlang-based rule-processing engine, (ii) an execution environment for agent tasks, based on <b>object-oriented</b> finite-state <b>machines,</b> and (iii) a module able to handle FIPA-ACL messages. Agent tasks are coupled with rule-processing engines in order to support transition triggering on the basis of agent’s mental state. Moreover, the agent communication facility provided by eXAT can not only trigger task’s events but also influence agent’s mental state according to FIPA-ACL semantics...|$|R
50|$|Additionally, {{the name}} {{inspired}} computer programmers {{to name a}} function found in object-oriented programming language a Mixin. Inspired by the concept of using a basic flavor of ice cream and blending in a combination of extra items, the programmers applied the term to small sets of pre-written computer code that was mixed into the main core of a larger program. Mixins {{first appeared in the}} MIT Lisp <b>Machine</b> <b>object-oriented</b> Flavors system, which was an approach to object-orientation used in Lisp Machine Lisp.|$|R
40|$|We {{adopt the}} untyped {{imperative}} object calculus of Abadi and Cardelli as a minimal {{setting in which}} to study problems of compilation and program equivalence that arise when compiling object-oriented languages. Our main result is a direct proof, via a small-step unloading machine, of the correctness of compilation to a closure-based abstract machine. Our second result is that contextual equivalence of objects coincides with a form of Mason and Talcott's CIU equivalence; the latter provides a tractable means of establishing operational equivalences. Finally, we prove correct an algorithm, used in our prototype compiler, for statically resolving method offsets. This is the first study of correctness of an <b>object-oriented</b> abstract <b>machine,</b> and of CIU equivalence for an object-oriented language. 1 Motivation This paper collates and extends a variety of operational techniques for describing and reasoning about programming languages and their implementation. We focus on implementation of i [...] ...|$|R
40|$|More than 90 % of the {{microprocessors}} produced {{today are}} used in embedded devices. With the current development tools, it is exceedingly difficult to debug, profile, and update code running on embedded devices in operation. This leaves developers unable to diagnose and solve software issues on deployed embedded systems, something that is unacceptable for an industry where robustness is paramount. In this thesis, we show {{that it is possible}} to build a fully serviceable software platform that fits on memory-constrained embedded devices. We use virtual machine technology to enable full serviceability even for system software components. At the bottom of the software stack, we have replaced real-time operating systems with an efficient 30 KB <b>object-oriented</b> virtual <b>machine.</b> The virtual machine contains a reflective interface that allows developers to debug, profile, and update code running on embedded devices even in operation. The serviceability extends to system software components, including interrupt handlers, device drivers, and networkin...|$|R
40|$|Implementing {{software}} solutions using finite {{state machines}} (FSMs) {{is a useful}} technique in many application areas, including compiler implementation and network protocols. This report examines possible implementation techniques for FSMs in the Smalltalk object-oriented system, and identifies techniques which best support the goals of generality, flexibility and software reuse. Keywords: Finite state <b>machines,</b> <b>object-oriented</b> design, Smalltalk. Contents 1 Introduction 3 2 Implementation Techniques 4 2. 1 Mapping States using Case Statements...................... 4 2. 1. 1 An Example............................... 5 2. 1. 2 Advantages and Disadvantages..................... 7 2. 2 Mapping States to Methods............................ 8 2. 2. 1 An Example............................... 8 2. 2. 2 Using doesNotUnderstand:...................... [...] . ...|$|R
40|$|Modern {{machine control}} systems {{rely heavily on}} {{software}} to achieve system functionality. Until recently, control software’s primary purpose was to provide logic and sequencing of machine execution. With computer hardware now providing power and memory to spare, control software is broadening its horizon from a focus on execution control to multiple phases within a control systems lifetime, such as design, testing, and maintenance. This paper reviews an <b>object-oriented</b> Finite State <b>Machine</b> (FSM) framework developed at National Institute of Standards and Technology (NIST) that exploits this potential and expands the software utility and functionality of machine control logic. The public domain FSM framework handles additional control requirements such as reusability, extensibility, modularity, testing, diagnostic troubleshooting, reporting, and maintenance. Please send any comments or questions by e-mail to...|$|R
40|$|Dynamic {{compilation}} {{techniques have}} found a renaissance in recent years due to their applicability to performance improvements of running Java-based code. Techniques originally developed for <b>object-oriented</b> language virtual <b>machines</b> are now commonly used in Java virtual machines and Java just-in-time compilers. Application of such techniques {{to the process of}} binary translation has also been done in recent years, mainly in the form of binary optimizers rather than binary translators. The Walkabout project proposes dynamic binary translation techniques based on properties of retargetability, ease of experimentation, separation of machine-dependent from machine-independent concerns, and good debugging support. Walkabout is a framework for experimenting with dynamic binary translation ideas, as well as ideas in related areas, such as interpreters, instrumentation tools, optimization and more...|$|R
40|$|Jcon is a new, full-featured, Java-based {{implementation}} of the Icon programming language. The compiler, written in Icon, generates an intermediate representation that is optimized and then used to produce classfiles of Java bytecode. A four-chunk control-flow model handles goal-directed evaluation and produces constructs not expressible as Java code. The runtime system, written in Java, finds object-oriented programming a great advantage in implementing a dynamically typed language, with method calls replacing many conditional tests. An all-encompassing descriptor class supports values, references, and suspended operations. The procedure call interface is simple and incurs overhead for generator support only when actually needed. Performance is somewhat disappointing, and some limitations are annoying, but in general Java provides a good implementation platform. Keywords: Icon, Java, compilation, generators, <b>object-oriented</b> programming, virtual <b>machine</b> This is a preprint of an article [...] ...|$|R
40|$|Abstract. This paper {{presents}} an <b>object-oriented</b> model for <b>machine</b> translation based on Universal Grammar, the Universal Lexicon and language-specific grammars and the lexicons, and demonstrates the internal structures of these linguistic constructs by following a step-by-step process of English to Japanese translation. It elucidates what elements are {{required in the}} Universal Lexicon and the lexicons of individual languages. The present model parses and generates sentences at three levels of structures: S-structure (Surface Structure), Istructure (Intermediary Structure) and U-Structure (Universal Structure). The present paper demonstrates {{the interaction of the}} three levels of structures in the process of translation, showing how economy and efficiency are achieved by incorporating the modules of Universal Grammar and the Universal Lexicon into the model of machine translation. This design makes each language grammar slim, distinguishing idiosyncrasies from elements of universal nature. ...|$|R
50|$|The 8086 was {{designed}} to be backward-compatible with the 8080 in the sense that 8080 assembly language could be mapped on to the 8086 architecture using a special assembler. Existing 8080 assembly source code (albeit no executable code) was thereby made upward compatible with the new 8086 to a degree. In contrast, the 432 had no software compatibility or migration requirements. The architects had total freedom to do a novel design from scratch, using whatever techniques they guessed would be best for large-scale systems and software. They applied fashionable computer science concepts from universities, particularly capability <b>machines,</b> <b>object-oriented</b> programming, high-level CISC machines, Ada, and densely encoded instructions. This ambitious mix of novel features made the chip larger and more complex. The chip's complexity limited the clock speed and lengthened the design schedule.|$|R
40|$|Abstract. The {{development}} of large scale multi-agent systems (MASs) requires the introduction and structuring {{of the learning}} in agents throughout the design and implementation stages. In open systems and complex environments, agents have to reason and adapt through machine learning techniques {{in order to achieve}} their goals. In this paper, we present the Agent Learning Design Pattern that guides the <b>object-oriented</b> design of <b>machine</b> learning algorithms in Software Agents. The intent of the Agent Learning Pattern is to add machine learning algorithms to an object-oriented agent design. The design separates key aspects in machine learning: knowledge representation, algorithm, performance evaluation and training example generator. Context Multi Agent Systems [Garcia et al. 2004 a] is a new technology that has been recently used in many simulators and intelligent systems to help humans perform several timeconsuming tasks. In complex and open environments with many cooperating agents, i...|$|R
40|$|This paper {{reports on}} an {{implementation}} of Kanerva's Sparse Distributed Memory for the Connection Machine and its application. In {{order to achieve}} a maximum of modularity in a highly adaptive software library we applied a native object-oriented programming style (namely the message passing style) to the Common Lisp extension *lisp. Furthermore some variations of the original model, the selected coordinate design, the hyperplane design, and a comprising general design, {{as well as the}} folded SDM due to Kanerva are realized. It has been necessary to work out an uniform presentation of the theoretical foundations the different designs are based on to gain a complete and comparable software architecture. Future work is outlined. Keywords: memorymodels, connectionist models, sparse distributed memory, associative memory, neural networks, connection <b>machine,</b> <b>object-oriented</b> programming, pattern recognition Declaration: This paper has not already been accepted by and is not currently unde [...] ...|$|R
40|$|This paper {{discusses}} {{the introduction of}} new programming methodologies to computer science and practice. Programming is ongoing deep evolution because the use of computers is getting larger and wider. As a consequence, programs are becoming more complex, dynamic, and resource demanding. This implies new methodologies to help decomposing large and complex programs and running them efficiently onto new parallel <b>machines.</b> <b>Object-oriented</b> concurrent programming (OOCP at short) {{is one of the leading}} methodology to match these requirements. It is based on the notion of active and autonomous entities (named objects) which run concurrently and communicate by exchanging messages. This paper introduces the concepts of OOCP methodology and discusses its advantages. It also surveys current application fields and research issues. We then focus on the issue of introducing and teaching OOCP. We describe a platform which we designed in order to help describing and experimenting with OOCP. We finally [...] ...|$|R
40|$|International audienceThe {{developers}} of tools for dynamic analysis {{are faced with}} choosing from the many approaches to gathering runtime data. Typically, dynamic analysis involves instrumenting the program under investigation to record its runtime behavior. Current approaches for byte-code based systems like Java and Smalltalk rely often on inserting byte-code into the program under analysis. However, detailed knowledge of the target programming language or virtual machine is required to implement dynamic analysis tools. Obtaining and exploiting this knowledge to build better analysis tools is cumbersome and often distracts the tool builder from the actual goal, which is {{the analysis of the}} runtime behavior of a system. In this paper, we argue that we need to adopt a higher level view of a software system when considering the task of abstracting runtime information. We focus on <b>object-oriented</b> virtual <b>machine</b> based languages. We {{want to be able to}} deal with the runtime system as a collection of reified first-class entities. We propose to achieve this by introducing a layer of abstraction, i. e., a behavioral middle layer. This has the advantage that the task of collecting dynamic information is not concerned with low level details of a specific language or virtual machine. The positive effect of such a behavioral middle layer is twofold: on the one hand it provides us with a standard API for all dynamic analysis based tools to use, on the other hand it allows the tool developer to abstract from the actual implementation technique...|$|R
40|$|Virtual {{machines}} (VMs) {{have been}} used to accelerate object-oriented applications and provide <b>object-oriented</b> features. Virtual <b>machines</b> can supply ample amounts of thread-level parallelism (TLP). This is a natural t for future microprocessors, which are likely to have abundant support for TLP. Virtual machines produce TLP in the form of service threads. Service threads perform tasks such as garbage collection, pro le analysis, and dynamic optimization in parallel with the main application thread(s). Most service threads must monitor the application's behavior in order to be e ective. The relational pro ling architecture (RPA) is designed to enable e cient interaction between the application and the service threads within a multithreaded VM. To this end, the RPA provides the following features: 1. The RPA selectively samples particular instructions under VM control. 2. The RPA collects the information needed, and only the information needed, for these instructions. 3. The RPA examines this information for patterns, and discards information that is no...|$|R
40|$|Parallel {{programming}} {{has become}} the focus of much research in the past decade. As the limits of VLSI technology are tested, it becomes more apparent that parallel processors will be responsible for the next quantum leap in performance. Already parallel programming is responsible for significant advances not so much in the speed of solving problems, but in the size of problems that can be solved. Carefully crafted parallel programs are solving problems magnitudes larger than could be considered for serial <b>machines.</b> <b>Object-oriented</b> programming has also become popular in academia and perhaps even moreso in industry. O-O holds out the promise of being able to efficiently build large systems that are understandable, maintainable, and more robust. The programs targetted by O-O are different than those typically found running on a computer such as the Connection Machine. Parallel programs are often designed for very specific tasks; O-O programs' strengths are that they handle a wide variety [...] ...|$|R
40|$|International audienceAcceleration {{of product}} development, {{decrease}} of NC programming effort and increase of product quality are demands from enterprises {{to make their}} products competitive. These requirements are hardly met by the today's used CAx process chain {{which is based on}} a multitude of interfaces and the standardised control data format ISO 6983. New concepts of product data modelling are necessary for a structured and <b>object-oriented</b> description of <b>machining.</b> The development of STEP-NC (ISO 14649) over the last ten years has brought new opportunities for automating the CAx process chain. This paper portrays a methodology for implementation of a standardised CAx process chain for rotational asymmetric parts, which are described in the technology-oriented process model for turning (ISO 14649 - 12). The methodology is realised through a suite of STEP compliant NC software tools, based on STEP compliant information models to integrate the whole chain from design to machining. Component case studies are used to demonstrate and analyse the methodology. The final part of the paper discusses the major issues and deficiencies related to the current phase of development of this new approach...|$|R
40|$|Purpose. To {{develop the}} {{theoretical}} basis of electrical <b>machines</b> <b>object-oriented</b> design, mathematical models and software {{to improve their}} design synthesis, analysis and optimization. Methodology. We have applied object-oriented design theory in electric machines optimal design and mathematical modelling of electromagnetic transients and electromagnetic field distribution. We have correlated the simulated results with the experimental data obtained {{by means of the}} double-stator screw dryer with an external solid rotor, brushless turbo-generator exciter and induction motor with squirrel cage rotor. Results. We have developed object-oriented design methodology, transient mathematical modelling and electromagnetic field equations templates for cylindrical electrical machines, improved and remade Cartesian product and genetic optimization algorithms. This allows to develop electrical machines classifications models, included not only structure development but also parallel synthesis of mathematical models and design software, to improve electric machines efficiency and technical performance. Originality. For the first time, we have applied a new way of design and modelling of electrical machines, which is based on the basic concepts of the object-oriented analysis. For the first time is suggested to use a single class template for structural and system organization of electrical machines, invariant to their specific variety. Practical value. We have manufactured screw dryer for coil dust drying and mixing based on the performed object-oriented theory. We have developed object-oriented software for design and optimization of induction motor with squirrel cage rotor of AIR series and brushless turbo-generator exciter. The experimental studies have confirmed the adequacy of the developed object-oriented design methodology...|$|R

