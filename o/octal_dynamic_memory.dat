0|1704|Public
40|$|We compare four {{existing}} <b>dynamic</b> <b>memory</b> allocators {{optimized for}} GPUs and show {{their strengths and}} weak-nesses. In the measurements we use three generic evaluation tests proposed in the literature and add one with a real workload where <b>dynamic</b> <b>memory</b> allocation is used for building the kd-tree data structure. Following the performance analysis we propose a new <b>dynamic</b> <b>memory</b> allocator and its variants that address {{the limitations of the}} existing <b>dynamic</b> <b>memory</b> allocators. The new <b>dynamic</b> <b>memory</b> allocator uses few resources and is targeted towards large and variably sized memory allocations on massively parallel hardware architectures...|$|R
50|$|The key {{component}} of <b>dynamic</b> <b>memory</b> is the last in, first out (LIFO) stack as this makes using the various functions much easier. A MULTOS chip is a stack machine, which makes use of this <b>dynamic</b> <b>memory</b> to pass parameters and perform calculations. In addition, the Input/output buffer resides in another <b>dynamic</b> <b>memory</b> segment.|$|R
40|$|Abstract—Current WCET {{analyses}} do {{not support}} <b>dynamic</b> <b>memory</b> allocation. This is mainly due to the unpredictability of the cache performance if standard memory allocators are used. We present a novel <b>dynamic</b> <b>memory</b> allocator that makes cache performance predictable and (de) allocates memory in constant time. It thereby enables WCET analysis {{in the presence of}} <b>dynamic</b> <b>memory</b> allocation. I...|$|R
5000|$|C <b>dynamic</b> <b>memory</b> {{allocation}} {{refers to}} performing manual <b>memory</b> management for <b>dynamic</b> <b>memory</b> allocation in the C programming language via {{a group of}} functions in the C standard library, namely , , [...] and [...]|$|R
25|$|Seizing {{an entry}} from a pre-allocated array is faster than using <b>dynamic</b> <b>memory</b> {{allocation}} for each node, since <b>dynamic</b> <b>memory</b> allocation typically requires {{a search for}} a free memory block of the desired size.|$|R
40|$|<b>Dynamic</b> <b>memory</b> {{allocation}} is {{an important}} mechanism used in operating systems. An efficient <b>dynamic</b> <b>memory</b> allocator can improve the performance of operating systems. In wireless sensor networks, sensor nodes have miniature computing device, small memory space and very limited battery power. Therefore, {{it is important that}} sensor operating systems operate efficiently in terms of energy consumption and resource management. And the role of <b>dynamic</b> <b>memory</b> allocator in sensor operating system is more important than one of general operating system. In this paper, we propose a new <b>dynamic</b> <b>memory</b> allocation scheme that resolves the existing problems in <b>dynamic</b> <b>memory</b> allocators. We implemented our scheme on Nano-Qplus which is a sensor operating system based on multi-threading. Our experimental results and static analysis result show our scheme performs efficiently in terms of the execution time and the memory space compared with existing memory allocation mechanisms...|$|R
40|$|For hard {{real-time}} applications, tight provable bounds on the application’s worst-case {{execution time}} must be derivable. Employing <b>dynamic</b> <b>memory</b> allocation, in general, significantly decreases an application’s timing predictability. In conse-quence, current hard real-time applications rely on static memory management. This thesis studies how the predictability issues of <b>dynamic</b> <b>memory</b> allocation {{can be overcome}} and <b>dynamic</b> <b>memory</b> allocation be enabled for hard real-time applications. We give {{a detailed analysis of}} the predictability challenges imposed on current state-of-the-art timing analyses by <b>dynamic</b> <b>memory</b> allocation. We propose two approaches to overcome these issues and enable <b>dynamic</b> <b>memory</b> allocation for hard real-time systems: automatically transforming dynamic into static allocation and using a novel, cache-aware and predictable memory allo-cator. Statically transforming <b>dynamic</b> into static <b>memory</b> allocation allows for very precise WCET bounds as all accessed memory addresses are completely known. However, this approach requires much information about the applica-tion’s allocation behavior to be available statically. For programs where a static precomputation of a suitable allocation scheme is not applicable, we investigate approaches to construct predictable <b>dynamic</b> <b>memory</b> allocators to replace the stan-dard, general-purpose allocators in real-time applications. We present evaluations of the proposed approaches to evidence their practical applicability. ...|$|R
50|$|For example, <b>dynamic</b> <b>memory</b> is {{commonly}} used for primary data storage due to its fast access speed. However <b>dynamic</b> <b>memory</b> must be repeatedly refreshed with a surge of current millions of time per second, or the stored data will decay and be lost. Flash memory allows for long-term storage {{over a period of}} years, but it is much slower than <b>dynamic</b> <b>memory,</b> and the static memory storage cells wear out with frequent use.|$|R
40|$|Abstract — In {{the near}} future, {{portable}} embedded devices must run multimedia applications with enormous computational requirements at low energy consumption. These applications demand extensive memory footprint and {{must rely on}} <b>dynamic</b> <b>memory</b> due to the unpredictability of input data (e. g. 3 D streams features) and system behaviour (e. g. variable number of applications running concurrently). Within this context, the <b>dynamic</b> <b>memory</b> subsystem {{is one of the}} main sources of power consumption and embedded systems have very limited batteries to provide efficient general-purpose <b>dynamic</b> <b>memory</b> management. As a result, consistent design methodologies that can tackle efficiently the complex <b>dynamic</b> <b>memory</b> behaviour of these new applications for low power embedded systems are in great need. In this paper we propose a step-wise system-level approach that allows the design of platform-specific <b>dynamic</b> <b>memory</b> management mechanisms with low power consumption for such kind of dynamic applications. The experimental results in reallife case studies show that our approach improves power consumption up to 89 % over current state-of-the-art <b>dynamic</b> <b>memory</b> managers for complex applications. Index Terms — real-time systems and embedded systems, dynamic storage management, multimedia applications I...|$|R
40|$|Abstract. The {{needs for}} {{run-time}} data storage in modern wired and wireless network applications are increasing. Additionally, {{the nature of}} these applications is very dynamic, resulting in heavy reliance to <b>dynamic</b> <b>memory</b> allocation. The most significant problem in <b>dynamic</b> <b>memory</b> allocation is fragmentation, which can cause the system to run out of memory and crash, if it is left unchecked. The available <b>dynamic</b> <b>memory</b> allocation solutions are provided by the real time Operating Systems used in embedded or general-purpose systems. These state-of-the-art <b>dynamic</b> <b>memory</b> allocators are designed to satisfy the run-time memory requests {{of a wide range of}} applications. Contrary to most applications, network applications need to allocate too many different memory sizes (e. g. hundreds different sizes for packets) and have an extremely dynamic allocation and de-allocation behavior (e. g. unpredictable web-browsing activity). Therefore, the performance and the de-fragmentation efficiency of these allocators is limited. In this paper, we analyze all the important issues of fragmentation and the ways to reduce it in network applications, while keeping the performance of the <b>dynamic</b> <b>memory</b> allocator unaffected or even improving it. We propose highly customized <b>dynamic</b> <b>memory</b> allocators, which can be configured for specific network needs. We assess the effectiveness of the proposed approach in two representative real-life case studies of wired and wireless network applications. Finally, we show very significant reduction in memory fragmentation and increase in performance compared to state-of-the-art <b>dynamic</b> <b>memory</b> allocators utilized by real-time Operating Systems. ...|$|R
40|$|Some {{students}} experience difficulties {{when first}} introduced to <b>dynamic</b> <b>memory.</b> The {{goal of this}} paper is to present an analogy behveen <b>dynamic</b> <b>memory</b> programming and a real-world example that will help students in understanding the underlying concepts behind dynamic memory: a left-luggage room with lockers. ...|$|R
30|$|The <b>dynamic</b> <b>memory</b> module allows {{services}} to be instantiated multiple times, and reduces static memory {{requirements of the}} implementation. The services can allocate memory in this space for their individual state information. This module is needed as TinyOS {{does not have an}} own <b>dynamic</b> <b>memory</b> management.|$|R
40|$|In general, hard {{real-time}} applications {{avoid the}} use of <b>dynamic</b> <b>memory</b> management systems due to the unbounded response times of <b>dynamic</b> <b>memory</b> management operations. Since the complexity of real-time applications grows, <b>dynamic</b> <b>memory</b> management systems are needed to increase their flexibility and functionalities. There exist memory management systems that offer O(1) operations’ response times, but do not consider memory fragmentation. In contrast is the Java domain, where memory fragmentation is handled by real-time garbage collected systems. This survey {{provides an overview of}} the approaches in both domains with focusing on the administration of memory...|$|R
40|$|Using <b>dynamic</b> <b>memory</b> {{has been}} a source of {{frustration}} for Computer Science and Engineering students programming in C++. We designed a tutor to help students understand <b>dynamic</b> <b>memory</b> and avoid the pitfalls of using it. The tutor automatically generates problems on <b>dynamic</b> <b>memory</b> usage, and provides detailed feedback on the user's answers. Our evaluation of the tutor indicates that using it helps improve both the cognitive and affective learning of students. In this paper, we will describe the design of the tutor, discuss our evaluation protocol and present the results of evaluation...|$|R
40|$|<b>Dynamic</b> <b>memory</b> {{management}} is {{one part of}} the soft-ware system that influences the performance and the cost of a product the most. In the context of an embedded real-time system, several requirements must be taken into account. The system must be optimized due to the limitation of mem-ory. Real-time deadlines must be respected: the <b>dynamic</b> <b>memory</b> management system must allocate and deallocate blocks in due time. One more challenge is represented when a <b>dynamic</b> <b>memory</b> management system is developed for a product family architecture, which is representative of a set of related products. We present a scenarios-based approach to analyze and evaluate <b>dynamic</b> <b>memory</b> management sys-tems for embedded real-time systems in a software product family architecture. Architectural transformations and im-provements against the tradeoffs for the software product family are analyzed. 1...|$|R
40|$|Absmcf- Currently, {{portable}} consumer {{embedded devices}} are increasing {{more and more}} their capabilities and can now implement new algorithms (e. g. multimedia and wireless protocols) that {{a few years ago}} were resewed only for powerful workstations. Unfortunately, the original design characteristics of such applications do not often allow to port them directly in current embedded devices. These applications share complex and intensive memory use. Furthermore, they must heavily rely on <b>dynamic</b> <b>memory</b> due to the unpredictability of the input data (e. g. 3 D streams features) and system behaviour (e. g. number of applications running concurrently defined by the user). Thus they require that the <b>dynamic</b> <b>memory</b> subsystem involved is able to provide the necessary level of performance for these new dynamic applications. However, actual embedded systems haw very limited resources (e. g. speed and power consumed in thc memory subsyslcm) to provide efficient general-purpose <b>dynamic</b> <b>memory</b> management. In this paper we propose a new methodology to design custom <b>dynamic</b> <b>memory</b> managers that provide the performance required in new embedded devices by reducing the amount of memory accesses to handle these new dynamic multimedia and wireless nehvork applications. Our results in real-life dynamic applications show significant improvements in <b>memory</b> BCC~SS~S of <b>dynamic</b> <b>memory</b> managers, i. e. up to 58 %, compared to state-of-the-art <b>dynamic</b> <b>memory</b> management solutions for complex applications. 1...|$|R
50|$|In C++, code cleanup {{involves}} deallocating previously allocated <b>dynamic</b> <b>memory.</b>|$|R
5000|$|... {{interfaces}} to <b>dynamic</b> <b>memory</b> (concern: latency for processor instruction/data fetch) ...|$|R
40|$|In {{this paper}} we discuss a concept of <b>dynamic</b> <b>memory</b> and an {{application}} of fractional calculus to describe the <b>dynamic</b> <b>memory.</b> The concept of memory is considered from the standpoint of economic models in the framework of continuous time approach based on fractional calculus. We also describe some general restrictions that can be imposed on the structure and properties of <b>dynamic</b> <b>memory.</b> These restrictions include the following three principles: (a) the principle of fading memory; (b) the principle of memory homogeneity on time (the principle of non-aging memory); (c) the principle of memory reversibility (the principle of memory recovery). Examples of different memory functions are suggested by using the fractional calculus. To illustrate an application of the concept of <b>dynamic</b> <b>memory</b> in economics we consider a generalization of the Harrod-Domar model, where the power-law memory is taken into account. Comment: 32 pages, pd...|$|R
40|$|Abstract. Portable {{embedded}} devices must presently run multimedia and wireless network applications with enormous computational performance requirements {{at a low}} energy consumption. In these applications, the <b>dynamic</b> <b>memory</b> subsystem {{is one of the}} main sources of power consumption and its inappropriate management can severely affect the performance of the system. In this paper, we present a new system-level approach to cover the large space of <b>dynamic</b> <b>memory</b> management implementations without a time-consuming programming effort and to obtain power consumption estimates that can be used to refine the <b>dynamic</b> <b>memory</b> management subsystem in an early stage of the design flow. ...|$|R
40|$|Traditional <b>dynamic</b> <b>memory</b> {{management}} techniques for imperative programming languages are unsuitable for reliable real-time applications because their worst-case {{time and space}} requirements are insufficiently bounded. This is demonstrated by detailed measurements of several real-world workloads. A special hardware-assisted real-time garbage collection system {{has been designed to}} facilitate reliable use of <b>dynamic</b> <b>memory</b> in hard real-time systems. By analyzing the <b>dynamic</b> <b>memory</b> use of application software, the real-time developer can prove compliance with time and space constraints. Analysis techniques are presented and the real-time performance of the hardware-assisted garbage collection system is compared to that of traditional allocators...|$|R
5000|$|... {{values of}} all {{variables}} and the information stored within <b>dynamic</b> <b>memory</b> ...|$|R
5000|$|... 32 MB onboard SDRAM {{split between}} system <b>memory,</b> <b>dynamic</b> <b>memory</b> and cache ...|$|R
5000|$|... #Subtitle level 4: Allocation of <b>dynamic</b> <b>memory</b> for {{message and}} object storage ...|$|R
40|$|<b>Dynamic</b> <b>memory</b> {{management}} {{is an important}} part of a large class of computer programs and high-performance algorithms for <b>dynamic</b> <b>memory</b> management have been, and will continue to be, of considerable interest. This paper presents empirical data from a collection of six allocation-intensive C programs. Extensive statistics about the allocation behavior of the programs measured, including the distributions of object sizes, lifetimes, and interarrival times, are presented. This data is valuable for the following reasons: first, the data from these programs can be used to design highperformance algorithms for <b>dynamic</b> <b>memory</b> management. Second, these programs can be used as a benchmark test suite for evaluating and comparing the performance of different <b>dynamic</b> <b>memory</b> management algorithms. Finally, the data presented gives readers greater insight into the storage allocation patterns of a broad range of programs. The data presented in this paper is an abbreviated version of more extensive sta [...] ...|$|R
40|$|The paper {{identifies}} the inefficiencies {{of the critical}} processes in concurrent fault simulation and proposes methods to remove such inefficiencies in a systematic manner. Also, proposed are <b>dynamic</b> <b>memory</b> usage reduction strategies for concurrent fault simulators. Through extensive step-by-step experimentation, we verified {{the effectiveness of the}} proposed methods for performance improvement and identified best memory management strategy for <b>dynamic</b> <b>memory</b> usage reduction. A simulator, HySim, based on the proposed methods is implemented and shown to outperform the existing fault simulators and achieve dramatic memory usage reduction. The HySim maintains fault lists which are subsets of that of a conventional concurrent fault simulator, which yields shorter fault list processing time and reduced <b>dynamic</b> <b>memory</b> usage. It also employs Release-and-Reconstruct method for fault list construction, where any fault list identified to be useless is released immediately. The experimental results show that Release-and-Reconstruct method is very effective in <b>dynamic</b> <b>memory</b> usage reduction...|$|R
5000|$|Schank, Roger. <b>Dynamic</b> <b>Memory</b> Revisited, 2nd Edition. New York: Cambridge University Press, 1999, [...]|$|R
40|$|International audienceResource {{reservation}} {{has been}} widely used in many realtime systems to guarantee the proper access to the system resources. Despite that being the memory a key resource, it has attracted little attention in the specific area of realtime systems. In order to use <b>dynamic</b> <b>memory</b> in real-time systems, two fundamental problems have to be settled: allocation and deallocation in bounded time, and the fragmentation problem. Recent research results have removed the unbounded timing behaviour of the <b>dynamic</b> <b>memory</b> allocation. TLSF is a fast and constant time memory allocator. Although the fragmentation is still an open research problem, we present a deep and comparative analysis showing that it has several characteristics {{in common with the}} well-known WCET analysis. In this paper, we present a contract based framework for handling <b>dynamic</b> <b>memory</b> in real-time systems. The framework provides both: i) timing guarantee for <b>dynamic</b> <b>memory</b> allocation and deallocation operations, and ii) spatial guarantee by using a flexible contract negotiation model...|$|R
40|$|Technology scaling {{has offered}} {{advantages}} to embedded systems, such as increased performance, more available memory and reduced energy consumption. However, scaling also brings {{a number of}} problems like reliability degradation mechanisms. The intensive activity of devices and high operating temperatures are key factors for reliability degradation in latest technology nodes. Focusing on embedded systems, the memory is prone to suffer reliability problems due to the intensive use of <b>dynamic</b> <b>memory</b> on wireless and multimedia applications. In this work we present a new approach to automatically design <b>dynamic</b> <b>memory</b> managers considering reliability, and improving performance, memory footprint and energy consumption. Our approach, based on Grammatical Evolution, obtains a maximum improvement of 39 % in execution time, 38 % in memory usage and 50 % in energy consumption over state-of-the-art <b>dynamic</b> <b>memory</b> managers for several real-life applications. In addition, the resulting distributions of memory accesses improve reliability. To the best of our knowledge, this is the first proposal for automatic <b>dynamic</b> <b>memory</b> manager design that considers reliability...|$|R
40|$|Resource {{reservation}} {{has been}} widely used in many realtime systems to guarantee the proper access to the system resources. Despite that being the memory a key resource, it has attracted little attention in the specific area of realtime systems. In order to use <b>dynamic</b> <b>memory</b> in real-time systems, two fundamental problems have to be settled: allocation and deallocation in bounded time, and the fragmentation problem. Recent research results have removed the unbounded timing behaviour of the <b>dynamic</b> <b>memory</b> allocation. TLSF is a fast and constant time memory allocator. Although the fragmentation is still an open research problem, we present a deep and comparative analysis showing that it has several characteristics {{in common with the}} well-known WCET analysis. In this paper, we present a contract based framework for handling <b>dynamic</b> <b>memory</b> in real-time systems. The framework provides both: i) timing guarantee for <b>dynamic</b> <b>memory</b> allocation and deallocation operations, and ii) spatial guarantee by using a flexible contract negotiation model. ...|$|R
5000|$|<b>Dynamic</b> <b>memory</b> {{allocation}} {{by means}} of the [...] attribute and the [...] and [...] statements ...|$|R
5000|$|The C <b>dynamic</b> <b>memory</b> {{allocation}} {{functions are}} defined in [...] header ( [...] header in C++).|$|R
5000|$|... 500 MB {{internal}} <b>dynamic</b> <b>memory,</b> microSD {{memory card}} slot with hot swap, max. 8 GB ...|$|R
5000|$|If {{it refers}} to an object inside a block of <b>dynamic</b> <b>memory</b> which has been freed.|$|R
40|$|Abstract:- Cerebellar Model Articulation Controllers (CMACs) are a biologically-inspired {{neural network}} system {{suitable}} for trajectory control. Traditionally, CMACs have been implemented using hash-coding for their memory allocation, requiring static allocation of fixed amounts of memory in advance to the training of the system. This paper presents a method for implementing CMACs using Binary Search Trees to provide <b>dynamic</b> <b>memory</b> allocation, allowing for lower memory usage without compromising the functionality of the CMAC. Key-Words:- CMAC, binary search trees, <b>dynamic</b> <b>memory</b> allocation, memory algorithm...|$|R
40|$|One of the {{significant}} issues that hinder the performance of Java program execution is <b>dynamic</b> <b>memory</b> usage. Some researchers stated that in executing Java programs, 15. 58 % of the CPU time is used in handling memory allocation requests and 28. 08 % of the CPU time in garbage collection. A statistical study on the <b>dynamic</b> <b>memory</b> usage behavior of both desktops and servers, Java applications show similar locality, and that memory allocation requests are concentrated on small block sizes (< 1 K bytes), and blocks allocated usually have short life times. Based on these findings, we proposed a hardware/software approach in handling memory allocation and deallocation requests that gives a 17 % overall performance gain in Java program execution. Key words: Java, <b>dynamic</b> <b>memory</b> management, memory allocation, memory deallocation...|$|R
