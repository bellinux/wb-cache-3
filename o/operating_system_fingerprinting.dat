15|10000|Public
5000|$|... 12 December 1998—Nmap 2.00 is released, {{including}} <b>Operating</b> <b>System</b> <b>fingerprinting</b> ...|$|E
50|$|The {{program can}} also be used to detect probes or attacks, including, but not limited to, <b>operating</b> <b>system</b> <b>fingerprinting</b> attempts, {{semantic}} URL attacks, buffer overflows, server message block probes, and stealth port scans.|$|E
50|$|Disallowing TCP/IP {{fingerprinting}} provides {{protection from}} vulnerability scanners looking to target machines running a certain <b>operating</b> <b>system.</b> <b>Fingerprinting</b> facilitates attacks. Blocking those ICMP messages {{is only one}} of an array of defenses required for full protection against attacks.|$|E
40|$|This paper {{discusses}} {{an experimental}} method {{for creating a}} 1 st generation smart-phone honey-pot {{with the intention of}} discovering automated worms. A Honeyd low-interaction virtual honey-pot is conceived as a possible method of discovering automated smart-phone worms by emulating the <b>operating</b> <b>system</b> Windows Mobile 5 and Windows Mobile 6, along with the available TCP/UDP ports of each <b>operating</b> <b>system.</b> This is an experimental method as there are currently no known malicious smart-phone worms. Honeyd emulates devices by mimicking the devices <b>operating</b> <b>system</b> <b>fingerprint</b> which is created by the unique responses each <b>operating</b> <b>system</b> sends to a discrete series of TCP and UDP packets sent by the network scanner Nmap. Honeyd uses the Nmap fingerprint database for how it should emulate these responses each <b>operating</b> <b>system.</b> A significant obstacle was discovered during the implementation of the Honeyd smartphone honey-pot, as the format of fingerprints (2 nd generation) utilised by Nmap are now different to the previous format (1 st generation) which is utilised by Honeyd. Honeyd cannot make use of the new Nmap format of the smart-phone <b>operating</b> <b>systems</b> and thus a honeypot for smart-phones cannot be created. Future work forecasts the creation of a technique to convert the new Nmap format to one which can be utilised by Honeyd...|$|R
50|$|TCP/IP stack {{fingerprinting}} is {{the passive}} collection of configuration attributes from a remote device during standard layer 4 network communications. The combination of parameters may {{then be used}} to infer the remote machine's <b>operating</b> <b>system</b> (aka, OS <b>fingerprinting),</b> or incorporated into a device fingerprint.|$|R
40|$|TCP/IP {{fingerprinting}} is {{the active}} or passive {{collection of information}} usually extracted from a remote computer’s network stack. The combi-nation of such information can be then used to infer the remote <b>operating</b> <b>system</b> (OS <b>fingerprinting).</b> OS fingerprinting is traditionally based on a database of “signatures”. A signature comprises several features (i. e., pairs attribute/value) extracted from network packets generated by a known op-erating system. Signatures are manually generated (and updated) by ob-serving several <b>operating</b> <b>systems.</b> There {{are two types of}} fingerprinting: active and passive. In this work, we focus on automating the generation and updating of the signatures for passive fingerprinting. By using classi-fication algorithms we deal with fingerprints which do not have an exact match with an already known signature. 1 Chapter...|$|R
5000|$|Nmap {{was first}} {{published}} in September 1997, as an article in Phrack Magazine with source-code included. With help and contributions of the computer security community, development continued. Enhancements included <b>operating</b> <b>system</b> <b>fingerprinting,</b> service fingerprinting, code rewrites (C to C++), additional scan types, protocol support (e.g. IPv6, SCTP) and new programs that complement Nmap's core features. Changes include: ...|$|E
40|$|Although some {{advancement}} {{was made}} in the field of active <b>operating</b> <b>system</b> <b>fingerprinting</b> in the recent years, still, there are many issues to resolve. This paper presents the enhancements made with Xprobe 2 v 0. 2 RC 1 and discusses the tool’s future development. Both the present and future versions of Xprobe 2 introduce many enhancements and advancements to the field of active <b>operating</b> <b>system</b> <b>fingerprinting,</b> which are discussed throughout the paper...|$|E
40|$|Active <b>operating</b> <b>system</b> <b>fingerprinting</b> is {{the process}} of {{actively}} determining a target network system’s underlying operating system type and characteristics by probing the target system network stack with specifically crafted packets and analyzing received response. Identifying the underlying operating system of a network host is an important char-acteristic {{that can be used to}} complement network inven-tory processes, intrusion detection system discovery mech-anisms, security network scanners, vulnerability analysis systems and other security tools that need to evaluate vul-nerabilities on remote network systems. During recent years there was a number of publications featuring techniques that aim to confuse or defeat remote network fingerprinting probes. In this paper we present a new version Xprobe 2, the net-work mapping and active <b>operating</b> <b>system</b> <b>fingerprinting</b> tool with improved probing process, which deals with most of the defeating techniques, discussed in recent literature...|$|E
40|$|In {{this work}} we present the {{differences}} and similarities {{of the web}} browsing behavior in most common mobile platforms. We devise a novel <b>Operating</b> <b>System</b> (OS) <b>fingerprinting</b> methodology to distinguish different types of wireless de-vices (smartphone vs laptops) as well as <b>operating</b> <b>system</b> instances (iOS, Android, BlackBerry etc.). We showcase {{that most of the}} multimedia content in smartphone devices is delivered via Range-Requests, and {{a large portion of the}} video transfers are aborted. We also show that laptop de-vices have more intelligent browser caching capabilities. We investigate the impact of an additional browser cache, and demonstrate that a 10 MB browser cache that is able to han-dle partial downloads in smartphones would be enough to handle the majority of the savings. Finally, we showcase that caching policies need to be amended to attain the max-imum possible savings in proxy caches. Based on those op-timizations the emulated proxy cache provides 10 % − 20 % in bandwidth savings...|$|R
30|$|A {{survey of}} web {{tracking}} and its mechanisms was proposed by Bujlow et al. [3]. The authors placed a special focus on fingerprinting {{as it is}} rich in various methods. The survey proposed a taxonomy of tracking mechanisms including a category of fingerprinting. The approaches relevant to our work are device <b>fingerprinting,</b> <b>operating</b> <b>System</b> instance <b>fingerprinting,</b> and browser instance fingerprinting. The methods are mostly focused on analysis of HTTP headers. However, TCP/IP headers can also be used, e.g., for OS fingerprinting. OS can be detected using information from network flows (TTL, SYN packet size, TCP window size, User-Agent) [21], DNS traffic analysis [22], or using combination of previous and prebuilt dictionary such as in p 0 f tool [23]. Regarding the client identification, remote psychical client fingerprinting using clock skews was described by Kohno et al. [24]. Graph-based structures for client profiling were introduced by Karagiannis et al. [25]. Manual labeling of fingerprints, a drawback of fingerprint-based methods, was tackled by Abdelnur et al. [26]. The authors intended {{to solve the problem}} by an automation of fingerprint signature creation.|$|R
40|$|Reneging {{occurs when}} a {{transport}} layer data receiver first selectively acks data, and later discards that data from its receiver buffer prior to delivery to the receiving application or socket buffer. Reliable transport protocols such as TCP and SCTP are designed to tolerate reneging. We argue that this design should be changed because: (1) reneging is a rare event in practice, and the memory saved when reneging does occur is insignificant, and (2) by not tolerating reneging, transport protocols {{have the potential for}} improved performance as has been shown in the case of SCTP. To support our argument, we analyzed TCP traces from three different domains (Internet backbone, wireless, enterprise). We detected reneging in only 0. 05 % of the analyzed TCP flows. In each reneging case, the <b>operating</b> <b>system</b> was <b>fingerprinted</b> thus allowing the reneging behavior of Linux, FreeBSD and Windows to be more precisely characterized. The average main memory returned each time to the reneging <b>operating</b> <b>system</b> was on the order of two TCP segments. Reneging saves so little memory that it is not worth the trouble. Since reneging happens rarely and when it does happen, reneging returns insignificant memory, we recommend designing reliable transport protocols to not tolerate reneging...|$|R
40|$|There {{are many}} tools today {{that are used}} for remote active <b>operating</b> <b>system</b> <b>{{fingerprinting}}.</b> They all have their own fingerprinting techniques. This paper gives an in-depth analysis of three such tools: Nmap, RINGv 2, and Xprobe 2. The purpose of the paper is to show how these tools work, and to understand {{the advantages and disadvantages}} they each offer...|$|E
40|$|Port {{scanning}} is {{the first}} activity an attacker pursues when attempting to compromise a target system on a network. The aim is to gather information {{that will result in}} identifying one or more vulnerabilities in that system. For example, network ports that are open can reveal which applications and services are running on the system. How a port responds when probed with data can reveal which protocol the port utilises and can also reveal which implementation of that protocol is being employed. One of the most valuable pieces of information to be gained via scanning and probing techniques is the operating system that is installed on the target. This technique is called <b>operating</b> <b>system</b> <b>fingerprinting.</b> The purpose of this research is to alert computer users of the dangers of port scanning, probing, and <b>operating</b> <b>system</b> <b>fingerprinting</b> by exposing these techniques and advising the users on which preventative countermeasures to take against them. Analysis is performed on the Transmission Control Protocol (TCP), User Datagram Protocol (UDP), Internet Protocol (IPv 4 and IPv 6), and the Internet Control Message Protocol (ICMPv 4 and ICMPv 6). All the software used in this project is free and open source. The operating system used for testing is Linux (2. 4 and 2. 6 kernels). Scanning, probing, and detection techniques are investigated {{in the context of the}} Network Mapper and Xprobe 2 tools. i...|$|E
40|$|Thesis (M. Sc. - Computer) -University of KwaZulu-Natal, Durban, 2007. Port {{scanning}} is {{the first}} activity an attacker pursues when attempting to compromise a target system on a network. The aim is to gather information {{that will result in}} identifying one or more vulnerabilities in that system. For example, network ports that are open can reveal which applications and services are running on the system. How a port responds when probed with data can reveal which protocol the port utilises and can also reveal which implementation of that protocol is being employed. One of the most valuable pieces of information to be gained via scanning and probing techniques is the operating system that is installed on the target. This technique is called <b>operating</b> <b>system</b> <b>fingerprinting.</b> The purpose of this research is to alert computer users of the dangers of port scanning, probing, and <b>operating</b> <b>system</b> <b>fingerprinting</b> by exposing these techniques and advising the users on which preventative countermeasures to take against them. Analysis is performed on the Transmission Control Protocol (TCP), User Datagram Protocol (UDP), Internet Protocol (IPv 4 and IPv 6), and the Internet Control Message Protocol (ICMPv 4 and ICMPv 6). All the software used in this project is free and open source. The operating system used for testing is Linux (2. 4 and 2. 6 kernels). Scanning, probing, and detection techniques are investigated {{in the context of the}} Network Mapper and Xprobe 2 tools...|$|E
40|$|AbstractMemory {{analysis}} is increasingly {{used to collect}} digital evidence in incident response. With the fast growth in memory analysis, however, anti-forensic techniques appear {{to prevent it from}} performing the bootstrapping steps — <b>operating</b> <b>system</b> (OS) <b>fingerprinting,</b> Directory Table Base (DTB) identification, and obtaining kernel objects. Although most published research works try to solve anti forensics, they deal only with one element among the three steps. Thus, collapse in any of the three steps using the suggested robust algorithms leads to failure in the memory analysis. In this paper, we evaluate the latest memory forensic tools against anti-forensics. Then, we suggest a novel robust algorithm that guarantees the bootstrapping analysis steps. It uses only one kernel data structure called KiInitialPCR, which is a kernel global variable based on the kernel processor control region (KPCR) structure and has many fields with tolerance to mutation. We characterize the robust fields of the KPCR structure to use them for OS fingerprinting, DTB identification, and obtaining kernel objects. Then, we implement the KiInitialPCR-based analysis system. Therefore, we can analyze the compromised memory in spite of the interference of anti-forensics...|$|R
40|$|The primary {{objective}} of the proposed research {{is to develop a}} framework for smart and robust <b>fingerprinting</b> of networked <b>systems.</b> Many <b>fingerprinting</b> techniques have been proposed in the past, however most of these techniques are designed for a specific purpose, such as <b>Operating</b> <b>System</b> (OS) <b>fingerprinting,</b> Access Point (AP) fingerprinting, etc. Such standalone techniques often have limitations which render them dysfunctional in certain scenarios or against certain counter measures. In order to overcome such limitations, we propose a fingerprinting framework that can combine multiple fingerprinting techniques in a smart manner, using a centralized decision making engine. We believe that any given scenario or a counter measure is less likely to circumvent a group of diverse fingerprinting techniques, which serves as the primary motivation behind the aforementioned method of attack. Another major portion of the thesis concentrates on the design and development of a device and device type fingerprinting sub-module (GTID) that has been integrated into the proposed framework. This sub-module used statistical analysis of packet inter arrival times (IATs) to identify the type of device that is generating the traffic. This work also analyzes the performance of the identification technique on a real campus network and propose modifications that use pattern recognition neural networks to improve the overall performance. Additionally, we impart capabilities to the fingerprinting technique to enable the identification of 'Unknown' devices (i. e., devices for which no signature is stored), and also show that it can be extended to perform both device and device type identification. MSCommittee Chair: Raheem A Beyah; Committee Member: Henry Owen; Committee Member: John Copelan...|$|R
40|$|Tying {{the browser}} {{more closely to}} <b>operating</b> <b>system</b> {{functionality}} and system hardware means that websites have more access to these resources, and that browser behavior varies depending {{on the behavior of}} these resources. We propose a new <b>system</b> <b>fingerprint,</b> inspired by the observation above: render text and WebGL scenes to a element, then examine the pixels produced. The new fingerprint is consistent, high-entropy, orthogonal to other fingerprints, transparent to the user, and readily obtainable. 1...|$|R
40|$|Tools {{for active}} remote <b>operating</b> <b>system</b> <b>fingerprinting</b> {{generate}} many packets and are easily detected by host and network defensive {{devices such as}} IDS/NIDS. Since each additional packet increases the probability of detection, it is advantageous to minimize the number of probe packets. We make use of an informationtheoretic measure of test quality to evaluate fingerprinting probes and use this evaluation to derive effective probe combinations that minimize probe packets. While the default configuration of Nmap’s second generation operating system detection transmits 16 different probe packets, we demonstrate successful fingerprinting with one to three packets. Furthermore, these packets are valid TCP SYN packets to open ports, which {{are less likely to}} be detected as fingerprinting probes than malformed packets or packets that are not part of a valid TCP three-way handshake. 1...|$|E
40|$|<b>Operating</b> <b>System</b> <b>fingerprinting</b> is a {{reconnaissance}} {{method used}} by Whitehats and Blackhats alike. Current techniques for fingerprinting {{do not take}} into account tunneling protocols, such as IPSec, SSL/TLS, and SSH, which effectively `wrap` network traffic in a ciphertext mantle, thus potentially rendering passive monitoring ineffectual. Whether encryption makes VPN tunnel endpoints immune to fingerprinting, or yields the encrypted contents of the VPN tunnel entirely indistinguishable, is a topic that has received modest coverage in academic literature. This study addresses these question by targeting two tunnelling protocols: IPSec and SSL/TLS. A new fingerprinting methodology is presented, several fingerprinting discriminants are identified, and test results are set forth, showing that endpoint identities can be uncovered, and that some of the contents of encrypted VPN tunnels can in fact be discerned. Dissertation (MSc (Computer Science)) [...] University of Pretoria, 2006. Computer Scienceunrestricte...|$|E
40|$|Passive <b>operating</b> <b>system</b> <b>fingerprinting</b> reveals {{valuable}} {{information to the}} defenders of heterogeneous private networks; at the same time, attackers can use fingerprinting to reconnoiter networks, so defenders need obfuscation techniques to foil them. We present an effective approach for passive fingerprinting that uses data features from TLS {{as well as the}} TCP/IP and HTTP protocols in a multi-session model, which is applicable whenever several sessions can be observed within a time window. In experiments on a real-world private network, our approach identified operating system major and minor versions with accuracies of 99. 4 % and 97. 5 %, respectively, and provided significant information gain. We also show that obfuscation strategies can often be defeated due to the difficulty of manipulating data features from all protocols, especially TLS, by studying how obfuscation affects our fingerprinting system. Because devices running unpatched operating systems on private networks create significant vulnerabilities, their detection is critical; our approach achieved over 98 % accuracy at this important goal. Comment: 10 pages, 5 figure...|$|E
40|$|Price {{differentiation}} {{describes a}} marketing strategy {{to determine the}} price of goods {{on the basis of}} a potential customer's attributes like location, financial status, possessions, or behavior. Several cases of online price differentiation have been revealed in recent years. For example, different pricing based on a user's location was discovered for online office supply chain stores and there were indications that offers for hotel rooms are priced higher for Apple users compared to Windows users at certain online booking websites. One potential source for relevant distinctive features are <b>system</b> <b>fingerprints,</b> i. e., a technique to recognize users' systems by identifying unique attributes such as the source IP address or system configuration. In this paper, we shed light on the ecosystem of pricing at online platforms and aim to detect if and how such platform providers make use of price differentiation based on digital <b>system</b> <b>fingerprints.</b> We designed and implemented an automated price scanner capable of disguising itself as an arbitrary system, leveraging real-world <b>system</b> <b>fingerprints,</b> and searched for price differences related to different features (e. g., user location, language setting, or <b>operating</b> <b>system).</b> This system allows us to explore price differentiation cases and expose those characteristic features of a system that may influence a product's price...|$|R
40|$|We {{present an}} {{application}} of Artificial Intelligence techniques {{to the field of}} Information Security. The problem of remote <b>Operating</b> <b>System</b> (OS) Detection, also called OS Fingerprinting, is a crucial step of the penetration testing process, since the attacker (hacker or security professional) needs to know the OS of the target host in order to choose the exploits that he will use. OS Detection is accomplished by passively sniffing network packets and actively sending test packets to the target host, to study specific variations in the host responses revealing information about its <b>operating</b> <b>system.</b> The first <b>fingerprinting</b> implementations were based on the analysis of differences between TCP/IP stack implementations. The next generation focused the analysis on application layer data such as the DCE RPC endpoint information. Even though more information was analyzed, some variation of the "best fit" algorithm was still used to interpret this new information. Our new approach involves an analysis of the composition of the information collected during the OS identification process to identify key elements and their relations. To implement this approach, we have developed tools using Neural Networks and techniques from the field of Statistics. These tools have been successfully integrated in a commercial software (Core Impact). Comment: 16 pages, 3 figures. Symposium sur la Sécurité des Technologies de l'Information et des Communications (SSTIC), Rennes, France, May 31 -June 2, 200...|$|R
40|$|Abstract — Network {{protocol}} <b>system</b> <b>fingerprinting</b> {{has been}} recognized as an important issue and {{a major threat to}} network security. Prevalent works rely largely on human experiences and insight of the protocol system specifications and implementations. Such ad-hoc approaches are inadequate in dealing with large complex protocol systems. In this paper we propose a formal approach for automated protocol <b>system</b> <b>fingerprinting</b> analysis and experiment. Parameterized Extended Finite State Machine is used to model protocol systems, and four categories of fingerprinting problems are formally defined. We propose and analyze algorithms for both active and passive fingerprinting and present our experimental results on Internet protocols. Furthermore, we investigate protection techniques against malicious fingerprinting and discuss the feasibility of two defense schemes, based on the protocol and application scenarios...|$|R
40|$|<b>Operating</b> <b>System</b> <b>fingerprinting</b> is a {{reconnaissance}} method {{which can}} be used by attackers or forensic investigators. It identifies a system's identity by observing its responses to targeted probes, or by listening on a network and passively observing its network ‘etiquette’. The increased deployment of encrypted tunnels and Virtual Private Networks (VPNs) calls for the formulation of new fingerprinting techniques, and poses the question: “How much information can be gleaned from encrypted tunnels?” This paper investigates IPSec VPN tunnel-establishment and tear-down on three IPSec implementations: Microsoft Windows 2003, Sun Solaris 9 x 86, and racoon on Linux 2. 6 kernel. By analysing each platform's Internet Key Exchange (IKE) messages, which negotiate the IPSec tunnel, we identify a number of discriminants, and show that each of these platforms can be uniquely identified by them. We also show that the nature of some encrypted traffic can be determined, thus giving the observer an idea of the type of communication that is taking place between the IPSec endpoints. Computer Scienc...|$|E
40|$|<b>Operating</b> <b>system</b> <b>fingerprinting</b> {{methods are}} {{well-known}} {{in the domain}} of static networks and managed environments. Yet few studies tackled this challenge in real networks, where users can bring and connect any device. We evaluate the performance of three OS fingerprinting methods on a large dataset collected from university wireless network. Our results show that method based on HTTP User-agents is the most accurate but can identify only low portion of the traffic. TCP/IP parameters method proved to be the opposite with high identification rate but low accuracy. We also implemented a new method based on detection of communication to OS-specific domains and its performance is comparable to the two established ones. After that, we discuss the impacts of traffic encryption and embracing new protocols such as IPv 6 or HTTP/ 2. 0 on OS fingerprinting. Our findings suggest that OS identification based on specific domain detection is viable and corresponds to the current directions of network traffic evolution, while methods based on TCP/IP parameters and User-agents will become ineffective in the future...|$|E
40|$|Remote <b>operating</b> <b>system</b> <b>fingerprinting</b> {{relies on}} {{implementation}} differences between OSs {{to identify the}} specific variant executing on a remote host. Because these differences can be subtle and difficult to find, most fingerprinting tools require expert manual effort to construct discriminative fingerprints and classification models. In prior work, Caballero et al. proposed a promising technique to eliminate manual intervention: the automatic generation of fingerprints using an approach similar to fuzz testing [6]. Their work evaluated the technique in a small-scale, carefully controlled test environment. In this paper, we re-examine automatic OS fingerprinting in a more challenging large-scale scenario {{to better understand the}} viability of the technique. In contrast to the prior work, we find that automatic fingerprint generation suffers from several limitations and technical hurdles that can limit its effectiveness, particularly in more demanding, realistic environments. We use machine learning algorithms from the well-known Weka [11] data mining toolkit to automatically generate fingerprints over 329 different machine instances, and we compare the accuracy of our automatically generated fingerprints to Nmap. Our results suggest that overfitting to non-OS-specific behavioral differences, the indistinguishability of different OS variants, the biasing of an automatic tool to the makeup of the training data, and the lack of ability of an automatic tool to exploit protocol and software semantics significantly limit the usefulness of this technique in practice. Automatic techniques can help identify candidate signatures, but our results suggest that manual expertise will remain an integral part of fingerprint generation...|$|E
40|$|Abstract- Virtualization enables {{installation}} and running of multiple virtual machines {{on the same}} computer <b>system.</b> <b>Operating</b> <b>system</b> that communicates directly with hardware {{is known as the}} host <b>operating</b> <b>system</b> whereas virtual <b>operating</b> <b>systems</b> have all the features of a real <b>operating</b> <b>system,</b> but they run inside the host <b>operating</b> <b>system.</b> A virtual machine is separated from the computer hardware resources and it runs on the emulated hardware. Performance of the virtual <b>operating</b> <b>system</b> running on the same computer system hardware depends on the performance of the host <b>operating</b> <b>system.</b> In this paper we study how different host <b>operating</b> <b>systems</b> influence virtual machine performance. Windows XP®, Windows Vista ™ and Windows 7 ™ are used as host <b>operating</b> <b>systems</b> using Windows Vista as a virtual <b>operating</b> <b>system.</b> Performance measurement of the virtual <b>operating</b> <b>system</b> is done in the same controlled conditions for all three host <b>operating</b> <b>systems</b> using benchmark applications. Performance measurement results show that the virtual <b>operating</b> <b>system</b> has the best performance when Windows 7 is used as the host <b>operating</b> <b>system...</b>|$|R
50|$|The Pick <b>operating</b> <b>system</b> was a {{complete}} <b>operating</b> <b>system.</b> Prime Information was not an <b>operating</b> <b>system,</b> but a 4GL system that ran from the Prime PRIMOS <b>operating</b> <b>system.</b>|$|R
50|$|For example, Solaris Zones {{supports}} multiple guest <b>operating</b> <b>systems</b> running {{under the}} same <b>operating</b> <b>system</b> such as Solaris 10. Guest <b>operating</b> <b>systems</b> can use the same kernel level with the same <b>operating</b> <b>system</b> version, or can be a separate copy of the <b>operating</b> <b>system</b> with a different kernel version using Solaris Kernel Zones. Solaris native Zones also requires that the host <b>operating</b> <b>system</b> is a version of Solaris; other <b>operating</b> <b>systems</b> from other manufacturers are not supported. However, Solaris Branded Zones {{would need to be}} used to have other <b>operating</b> <b>systems</b> as zones.|$|R
40|$|Mobile cloud {{computing}} {{becomes part of}} mobile usersdaily life transactions. Mobile devices with Internetcapabilities have increased the use of mobile clouding computing. Due to hardware limitations in mobiledevices, these devices can't install and run applications require heavy CPU processing or extensivememory. Cloud computing allows mobile users to synchronize their data with remote storage and utilizeapplications require heavy CPU processing or extensive memory such as Microsoft Office or AdobePhotoshop, as they run in a desktop computer. The combination of {{cloud computing}} and mobile computing introduces mobile cloud computing, which alsopresent new issues of security threats such as unauthorized access to resources exist in mobile cloud. Protecting mobile cloud computing from illegitimateaccess becomes an important concern to mobile users. This paper proposes and implements a new user authentication mechanism of mobile cloud computingusing <b>fingerprint</b> recognition <b>system.</b> <b>Fingerprint</b> images of mobile users can be captured and processedusing mobile phone camera to access mobile cloud computing. The implementation of the proposedsolution in different mobile <b>operating</b> <b>systems</b> anddevices show security enhancement in mobile cloudcomputing with accepted performance leve...|$|R
50|$|Because of {{the large}} number and variety of {{available}} Linux distributions, they are all grouped under a single entry; see comparison of Linux distributions for a detailed comparison. There are also a variety of BSD <b>operating</b> <b>systems</b> and DOS <b>operating</b> <b>systems,</b> covered in comparison of BSD <b>operating</b> <b>systems</b> and comparison of DOS <b>operating</b> <b>systems.</b> For information on views of each <b>operating</b> <b>system,</b> see <b>operating</b> <b>system</b> advocacy.|$|R
50|$|An {{embedded}} <b>operating</b> <b>system</b> is an <b>operating</b> <b>system</b> for {{embedded computer}} <b>systems.</b> These <b>operating</b> <b>systems</b> {{are designed to}} be compact, efficient at resource usage, and reliable, forsaking many functions that non-embedded computer <b>operating</b> <b>systems</b> provide, and which may not be used by the specialized applications they run. They are frequently also referred to as real-time <b>operating</b> <b>systems,</b> and the term RTOS is often used as a synonym for embedded <b>operating</b> <b>system.</b>|$|R
50|$|The first <b>operating</b> <b>systems</b> for the GEC 4000 series were COS (Core <b>Operating</b> <b>System)</b> and DOS (Disk <b>Operating</b> <b>System).</b> These were {{basically}} single-user multi-tasking <b>operating</b> <b>systems,</b> designed for developing and running Process control type applications.|$|R
40|$|This paper {{presents}} an architecture that allows multiple isolated commodity <b>operating</b> <b>systems</b> to run concurrently on a microkernel-based <b>operating</b> <b>system</b> without restricting the CPU architecture of guest <b>operating</b> <b>systems.</b> There are several systems that can execute multiple guest <b>operating</b> <b>systems</b> {{by using a}} virtual machine monitor or a microkernel-based <b>operating</b> <b>system.</b> Almost all of them, however, require that the CPU architecture of a guest <b>operating</b> <b>system</b> and a host <b>operating</b> <b>system</b> are identical and the guest <b>operating</b> <b>system</b> needs to be modified. Our architecture {{does not require the}} both of them and the prototype system that we have developed achieved the execution of multiple guest <b>operating</b> <b>systems</b> such as Linux and FreeBSD compiled for several CPU architecture without the modification of them. Since it involved decreasing the performance of a guest <b>operating</b> <b>system,</b> we propose several techniques to improve the performance in this paper. Future embedded system will become more complex, so our approach offers a new way to reuse existing applications and <b>operating</b> <b>systems.</b> 1...|$|R
40|$|In my thesis, I focus on the <b>operating</b> <b>system</b> Google Chrome OS, {{determination}} of its characteristics, definition of target {{group of the}} <b>operating</b> <b>system's</b> users and comparison of available applications with those available for other <b>operating</b> <b>systems.</b> In the theoretical part, historical development of Google is analysed first, followed by the issue of Google Chrome web browser and analyse of the <b>operating</b> <b>system</b> Google Chrome OS. The practical part starts with evaluation of survey on the <b>operating</b> <b>system</b> Google Chrome OS and is followed by multi-criteria analysis of variants comparing various categories of applications available for the <b>operating</b> <b>system</b> Google Chrome OS and other <b>operating</b> <b>systems,</b> in this case represented by the <b>operating</b> <b>system</b> Microsoft Windows 8. 1 and distribution of Linux <b>operating</b> <b>system</b> Ubuntu 14. 04 LTS...|$|R
