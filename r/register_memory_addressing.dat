0|2717|Public
5000|$|I : 16bit <b>register</b> (For <b>memory</b> <b>address)</b> (Similar to void pointer) ...|$|R
40|$|Modern X 86 Assembly Language Programming {{shows the}} {{fundamentals}} of x 86 assembly language programming. It focuses on the aspects of the x 86 instruction set that are most relevant to application software development. The book's structure and sample code {{are designed to help}} the reader quickly understand x 86 assembly language programming and the computational capabilities of the x 86 platform. Major topics of the book include the following: 32 -bit core architecture, data types, internal <b>registers,</b> <b>memory</b> <b>addressing</b> modes, and the basic instruction setX 87 core architecture, register stack, specia...|$|R
5000|$|... "High-level language" [...] {{refers to}} the higher level of {{abstraction}} from machine language. Rather than dealing with <b>registers,</b> <b>memory</b> <b>addresses</b> and call stacks, high-level languages deal with variables, arrays, objects, complex arithmetic or boolean expressions, subroutines and functions, loops, threads, locks, and other abstract computer science concepts, {{with a focus on}} usability over optimal program efficiency. Unlike low-level assembly languages, high-level languages have few, if any, language elements that translate directly into a machine's native opcodes. Other features, such as string handling routines, object-oriented language features, and file input/output, may also be present.|$|R
5000|$|Additionally, in {{assembly}} language, an operand is a value (an argument) {{on which}} the instruction, named by mnemonic, operates. The operand may be a processor <b>register,</b> a <b>memory</b> <b>address,</b> a literal constant, or a label. A simple example (in the x86 architecture) is ...|$|R
5000|$|For {{a typical}} {{instruction}} like , both argument operands come from explicitly named {{positions on the}} belt, {{and the result is}} dropped on the front, ready for the next instruction. Operations with multiple results simply drop more values at the belt front. Most belt instructions are encoded as just an operation code (opcode) and two belt positions, with no added fields to specify a result <b>register,</b> <b>memory</b> <b>address,</b> or literal constant. This encoding is easily extended to richer operations with more than two inputs or more than one result. Constant operands are dropped by separate [...] instructions. All access of program variables in main random-access memory (RAM) is segregated into separate [...] or [...] instructions containing one <b>memory</b> <b>address,</b> or some way to calculate that address from belt operands.|$|R
5000|$|The R1 {{had seven}} memory-mapped {{general-purpose}} processor registers, each 54 bits in size, {{in addition to}} a constant zero <b>register.</b> For <b>memory</b> <b>addressing,</b> seven 16-bit [...] "B-Registers" [...] were used. The program counter was also held in a writable [...] "B-Register". See the table below for conventions and hardware-enforced usage of these registers.|$|R
5000|$|Processor state (context), such as {{the content}} of <b>registers</b> and {{physical}} <b>memory</b> <b>addressing.</b> The state is typically stored in computer registers when the process is executing, and in memory otherwise.|$|R
50|$|A {{limited number}} of {{instructions}} operate on 16-bit register pairs. The lower-numbered register of the pair holds the least significant bits and must be even-numbered. The last three register pairs are used as pointer <b>registers</b> for <b>memory</b> <b>addressing.</b> They are known as X (R27:R26), Y (R29:R28) and Z (R31:R30). Postincrement and predecrement addressing modes are supported on all three. Y and Z also support a six-bit positive displacement.|$|R
5000|$|To {{handle the}} {{relatively}} {{large amounts of}} ROM and RAM, tenfold the 8502's 64 kB address space, the C128 uses the 8722 MMU chip to create different memory maps, in which different combinations of RAM and ROM would appear according to bit patterns written into the MMU's configuration <b>register</b> at <b>memory</b> <b>address</b> [...] Another feature of the memory management unit is to allow relocation of zero page and the stack.|$|R
40|$|International audienceThis talk {{introduces}} {{an efficient}} and portable approach for DIFT (Dynamic Information Flow Tracking) implementations on recon gurable chips. DIFT aims {{to track the}} application control flow by adding metadata (also known as tags) to information containers (e. g. <b>registers,</b> <b>memory</b> <b>addresses,</b> [...] .), propagating and checking it at runtime. These approaches have been successfully used against {{a wide range of}} attacks including bu er over ow, SQL injections and so on. Existing DIFT solutions are either hardly portable or bring unsatisfactory time overheads. For example, DIFT in software brings an overhead of at least 300 % and can rise up to 3700 %. Our chosen approach conists of using a dedicated coprocessor to decouple main computation (application) from tags computation. To efficiently retrieve information on executed instructions by the main CPU, ARM Coresight components are used to export CPU trace towards FPGA part of Zynq SoC. In addition to trace, static analysis {{needs to be done to}} get dependencies between information containers. This talk will present our chosen approach, ongoing work on first prototype and rst results. Existing DIFT approaches and ARM Coresight components will also be discussed...|$|R
50|$|In {{computer}} science, {{an integer}} is a datum of integral data type, a data type that represents some finite {{subset of the}} mathematical integers. Integral data types may be of different sizes and {{may or may not}} be allowed to contain negative values. Integers are commonly represented in a computer as a group of binary digits (bits). The size of the grouping varies so the set of integer sizes available varies between different types of computers. Computer hardware, including virtual machines, nearly always provide a way to represent a processor <b>register</b> or <b>memory</b> <b>address</b> as an integer.|$|R
40|$|AbstractThis {{work is a}} {{complementary}} part for what we proposed in [1]. In this paper, an undergraduate design experience for special purpose 4 -bit microprocessor using the skills learned from digital logic design and Microprocessors courses is presented. The experience started in [1] by designing the ALU using the hardware printed circuit board and we are following it by completing the design by the instruction set architecture and the microprogram code. Our microprocessor contains â€“ {{in addition to the}} ALU- six registers: A 4 -bit accumulator register, Flag register that holds only zero (Z) and carry (C) flags, Program counter <b>register</b> (PC), <b>Memory</b> <b>address</b> <b>register</b> (MAR), Instruction register (IR), and Buffer Register. All programs and data are stored in the 1 k RAM...|$|R
40|$|In {{optimized}} programs {{the location}} {{in which the}} current value of a single source variable may reside typically varies as the computation progresses. A debugger for optimized code needs to know all of the locations [...] both <b>registers</b> and <b>memory</b> <b>addresses</b> [...] in which a variable resides, and which locations are valid for which portions of the computation. Determining this information {{is known as the}} data location problem [3, 7]. Because optimizations frequently move variables around (between <b>registers</b> and <b>memory</b> or from one register to another) the compiler must build a table to keep track of this information. Such a table is known as a variable range table [3]. Once a variable range table has been constructed, finding a variable's current location reduces to the simple task of looking up the appropriate entry in the table. The difficulty lies in collecting the data for building the table. Previous methods for collecting this data depend on which optimizations the compiler performs and ho [...] ...|$|R
5000|$|The way {{in which}} the {{instruction}} is interpreted is defined by the CPU's instruction set architecture (ISA). Often, one group of bits (that is, a [...] "field") within the instruction, called the opcode, indicates which operation is to be performed, while the remaining fields usually provide supplemental information required for the operation, such as the operands. Those operands may be specified as a constant value (called an immediate value), or as the location of a value that may be a processor <b>register</b> or a <b>memory</b> <b>address,</b> as determined by some addressing mode.|$|R
5000|$|STOD [...] - [...] Store {{destructive}} (if {{the target}} word has an odd tag throw a memory protect interrupt, [...] - [...] {{store the value}} in the B <b>register</b> at the <b>memory</b> <b>addressed</b> by the A register. [...] - [...] Delete the value off the stack.STON [...] - [...] Store non-destructive (Same as STOD but value is not deleted [...] - [...] handy for F := G := H := J expressions).OVRD [...] - [...] Overwrite destructive, STOD ignoring read-only bit (for use in MCP only)OVRN [...] - [...] Overwrite non-destructive, STON ignoring read-only bit (for use in MCP only) ...|$|R
5000|$|Each ALU, {{called a}} PE slice, {{contains}} sixty four 32 bit registers {{that are used}} for both integer and floating point. The registers are, interestingly, bit and byte addressable. The floating point unit handles single precision and double precision arithmetic on IEEE format numbers. Each PE slice contains two <b>registers</b> for data <b>memory</b> <b>address,</b> and the data. Each PE also has two one-bit serial ports, one for inbound and one for outbound communication to its nearest neighbor. The direction of communication is controlled globally. The PEs also have inbound and outbound paths to a global router for I/O. A broadcast port allows a single instance of data to be [...] "promoted" [...] to parallel data. Alternately, global data can be 'or-ed' to a scalar result.|$|R
50|$|Binary {{arithmetic}} {{and logical}} operations are performed as register-to-register and as memory-to-register/register-to-memory {{as a standard}} feature. If the Commercial Instruction Set option was installed, packed decimal arithmetic could be performed as memory-to-memory with some memory-to-register operations. The Scientific Instruction Set feature, if installed, provided access to four floating point registers that could be programmed for either 32-bit or 64-bit floating point operations. The Models 85 and 195 could also operate on 128-bit extended-precision floating point numbers stored in pairs of floating point registers, and software provided emulation in other models. The System/360 used an 8-bit byte, 32-bit word, 64-bit double-word, and 4-bit nibble. Machine instructions had operators with operands, which could contain <b>register</b> numbers or <b>memory</b> <b>addresses.</b> This complex combination of instruction options resulted {{in a variety of}} instruction lengths and formats.|$|R
5000|$|All 2-operand 8-bit {{arithmetic}} {{and logical}} (ALU) operations {{work on the}} 8-bit accumulator (the A register). For two-operand 8-bit operations, the other operand can be either an immediate value, another 8-bit <b>register,</b> or a <b>memory</b> cell <b>addressed</b> by the 16-bit register pair HL. The only 8-bit ALU operations that can have a destination other than the accumulator are the unary incrementation or decrementation instructions, which can operate on any 8-bit <b>register</b> or on <b>memory</b> <b>addressed</b> by HL, as for two-operand 8-bit operations. Direct copying is supported between any two 8-bit registers and between any 8-bit register and a HL-addressed memory cell, using the MOV instruction. An immediate value can also be moved {{into any of the}} foregoing destinations, using the MVI instruction. Due to the regular encoding of the MOV instruction (using nearly a quarter of the entire opcode space) there are redundant codes to copy a register into itself (MOV B,B, for instance), which are of little use, except for delays. However, what would have been a copy from the HL-addressed cell into itself (i.e., MOV M,M) instead encodes the HLT instruction, halting execution until an external reset or unmasked interrupt occurs.|$|R
40|$|Most {{programs}} are repetitive, where similar {{behavior can be}} seen at different execution times. Proposed algorithms automatically group these similar intervals of execution into phases, where all the intervals in a phase have homogeneous behavior and similar resource requirements. In this paper we examine different program structures for capturing phase behavior. The goal is to compare the size and accuracy of these structures for performing phase classification. We focus on profiling the frequency of program level structures that are independent from underlying architecture performance metrics. This allows the phase classification to be used across different hardware designs that support the same instruction set (ISA). We compare using basic blocks, loop branches, procedures, opcodes, <b>register</b> usage, and <b>memory</b> <b>address</b> information for guiding phase classification. We compare these different structures in terms of their ability to create homogeneous phases, and evaluate the accuracy of using these structures to pick simulation points for SimPoint...|$|R
50|$|In 12 bits {{the mode}} of {{addressing}} and the address of a <b>register</b> in control <b>memory</b> are identified. Also an increment between 0 and 32 is specified. The main <b>memory</b> <b>address</b> is in the <b>register</b> in control <b>memory.</b> The processor will first obtain the main <b>memory</b> <b>address</b> from the <b>register,</b> then call for the word at that main <b>memory</b> <b>address.</b> Finally it will increase (increment) the register value by the amount specified. The 16 bit address from the register contains a bank address from 0 to 31 using 5 bits and a word in that bank using 11 bits. Incrementing was recommended only for addresses A and B.|$|R
5000|$|Each 48-bit word {{contained}} two 24-bit instructions. The {{instruction format}} was 6-3-15: six bits {{for the operation}} code, three bits for a [...] "designator" [...] (index <b>register</b> for <b>memory</b> access instructions, condition for jump (branch) instructions) and fifteen bits for a <b>memory</b> <b>address</b> (or shift count, for shift instructions).|$|R
5000|$|... # Any line {{starting}} with a number-sign is a comment # This is just a label, the ordinary way assemblers symbolically represent a [...] # <b>memory</b> <b>address.</b> InstructionJUMP: # To prepare for the next instruction, the instruction-decode microcode has already # moved the program counter to the <b>memory</b> <b>address</b> <b>register.</b> This instruction fetches # the target address of the jump instruction from the memory word following the # jump opcode, by copying from the <b>memory</b> data <b>register</b> to the <b>memory</b> <b>address</b> <b>register.</b> # This gives the memory system two clock ticks to fetch the next [...] # instruction to the <b>memory</b> data <b>register</b> {{for use by the}} instruction decode. # The sequencer instruction [...] "next" [...] means just add 1 to the control word address. MDR, NONE, MAR, COPY, NEXT, NONE # This places the address of the next instruction into the PC. # This gives the memory system a clock tick to finish the fetch started on the # previous microinstruction. # The sequencer instruction is to jump {{to the start of the}} instruction decode. MAR, 1, PC, ADD, JMP, InstructionDecode # The instruction decode is not shown, because it is usually a mess, very particular # to the exact processor being emulated. Even this example is simplified. # Many CPUs have several ways to calculate the address, rather than just fetching # it from the word following the op-code. Therefore, rather than just one # jump instruction, those CPUs have a family of related jump instructions.|$|R
40|$|We present X-Gen, a model-based {{test-case}} generator {{designed for}} systems and systems on a chip (SoCs). XGen {{provides a framework}} {{and a set of}} building blocks for system-level test-case generation. At the core of this framework lies a system model, which consists of component types, their configuration, and the interactions between them. Building blocks include commonly used concepts such as <b>memories,</b> <b>registers,</b> and <b>address</b> translation mechanisms. Once a system is modeled, X-Gen provides a rich language for describing test cases. Through this language, users can specify requests that cover the full spectrum between highly directed tests to completely random ones. XGen is currently in preliminary use at IBM for the verification of two different designs [...] -a high-end multi-processor server and a state-of-the-art SoC...|$|R
50|$|In computing, a {{physical}} address (also real address, or binary <b>address),</b> is a <b>memory</b> <b>address</b> that {{is represented in}} the form of a binary number on the address bus circuitry in order to enable the data bus to access a particular storage cell of main <b>memory,</b> or a <b>register</b> of <b>memory</b> mapped I/O device.|$|R
50|$|AVX-512 {{instruction}} are encoded {{with the}} new EVEX prefix. It allows 4 operands, 7 new 64-bit opmask <b>registers,</b> scalar <b>memory</b> mode with automatic broadcast, explicit rounding control, and compressed displacement <b>memory</b> <b>addressing</b> mode. The width of the register file is increased to 512 bits and total register count increased to 32 (registers ZMM0-ZMM31) in x86-64 mode.|$|R
50|$|This example {{illustrates}} {{well the}} crippling {{effect that the}} processorâ€™s lack of {{a sufficient number of}} registers has on performance. Indeed, this processor architecture presents an extreme example of this weakness. Because of this problem and the fact that this routine needs to update two active <b>memory</b> <b>addresses,</b> a dominant part of the codeâ€™s time is dealing with shuffling values between <b>registers</b> and <b>memory.</b>|$|R
5000|$|When clearing, reading, {{or writing}} to the EEPROM <b>memory,</b> the <b>address</b> and range are {{specified}} by a six-digit number, preceded by a non-zero number, in automatic mode: e.g. [...] specifies that [...] bytes are to be stored starting at <b>memory</b> <b>address</b> [...] A two-position data/program switch controls whether data (from the <b>registers)</b> or program <b>memory</b> is transferred; a three-position switch is used to select read, write, and clear operations.|$|R
50|$|In {{the context}} of these definitions, a byte is the {{smallest}} primitive; each <b>memory</b> <b>address</b> specifies a different byte. The <b>memory</b> <b>address</b> of the initial byte of a datum is considered the <b>memory</b> <b>address</b> (or base <b>memory</b> <b>address)</b> of the entire datum.|$|R
50|$|The Philippines {{currently}} has four <b>registered</b> <b>memories</b> in the Memory of the World Register {{out of the}} current 348 <b>registered</b> <b>memories</b> all over the world. The inscription of documentary heritage by UNESCO happens every odd year.|$|R
50|$|<b>Registered</b> <b>Memory</b> (Buffered Memory) Buffered {{memory is}} an older term for <b>registered</b> <b>memory.</b> Buffered {{refers to an}} {{electronic}} buffer placed between the memory and the memory controller. In general registered RAM won't fit in a slot for unregistered RAM, however it will with SDRAM.|$|R
5000|$|INP OUT // Initialize output [...] LOOP BRZ QUIT // If the {{accumulator}} {{value is}} 0, {{jump to the}} <b>memory</b> <b>address</b> labeled QUIT SUB ONE // Label this <b>memory</b> <b>address</b> as LOOP, The instruction will then subtract the value stored at address ONE from the accumulator OUT BRA LOOP // Jump (unconditionally) to the <b>memory</b> <b>address</b> labeled LOOP QUIT HLT // Label this <b>memory</b> <b>address</b> as QUIT ONE DAT 1 // Store the value 1 in this <b>memory</b> <b>address,</b> and label it ONE (variable declaration) ...|$|R
50|$|Examples of <b>register</b> <b>memory</b> {{architecture}} are IBM System/360, its successors, and Intel x86. Examples of <b>register</b> plus <b>memory</b> architecture are VAX and the Motorola 68000 family.|$|R
5000|$|Likewise, knowing D's <b>memory</b> <b>address,</b> {{it is easy}} {{to compute}} the <b>memory</b> <b>address</b> of B: ...|$|R
50|$|<b>Registered</b> <b>memory</b> {{is often}} more {{expensive}} because of the lower number of units sold and additional circuitry required, so it is usually found only in applications where the need for scalability and robustness outweighs {{the need for a}} low price for example, <b>registered</b> <b>memory</b> is usually used in servers.|$|R
5000|$|... {{knowing the}} <b>memory</b> <b>address</b> where the array starts, {{it is easy}} to compute the <b>memory</b> <b>address</b> of D: ...|$|R
50|$|Although most <b>registered</b> <b>memory</b> modules also feature error-correcting code memory (ECC), {{it is also}} {{possible}} for <b>registered</b> <b>memory</b> modules to not be error-correcting or vice versa. Unregistered ECC memory is, for example, supported and used in workstation or entry-level server motherboards that do not support very large amounts of memory.|$|R
