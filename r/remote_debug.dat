3|79|Public
50|$|The most {{interesting}} new development function of GPS from version 4.0 are remote edit, <b>remote</b> <b>debug</b> and cross-compilation capabilities for platforms for which GPS/GCC are not natively available.|$|E
5000|$|Also, {{there was}} a <b>remote</b> <b>debug</b> {{protocol}} for the world-swap debugger. [...] This protocol could, via the debugger [...] "nub", freeze a workstation and then peek and poke various parts of memory, change variables, and continue execution. If debugging symbols were available, a crashed machine could be remote debugged from anywhere on earth.|$|E
40|$|Rivet is {{the first}} fully-featured, browser-agnostic re-mote {{debugger}} for web applications. Using Rivet, de-velopers can inspect and modify the state of live web pages that are running inside unmodified end-user web browsers. This allows developers to explore real applica-tion bugs {{in the context of}} the actual machines on which those bugs occur. To make an application Rivet-aware, developers simply add the Rivet JavaScript library to the client-side portion of the application. Later, when a user detects a problem with the application, the user informs Rivet; in turn, Rivet pauses the application and notifies a <b>remote</b> <b>debug</b> server that a debuggable session is avail-able. The server can launch an interactive debugger front-end for a human developer, or use Rivet’s live patching mechanism to automatically install a fix on the client or run diagnostics for offline analysis. Experiments show that Rivet imposes negligible overhead during normal ap-plication operation. At debug time, Rivet’s network foot-print is small, and Rivet is computationally fast enough to support non-trivial diagnostics and live patches. ...|$|E
25|$|<b>Remote</b> <b>{{debugging}}</b> is {{the process}} of debugging a program running on a system different from the debugger. To start <b>remote</b> <b>debugging,</b> a debugger connects to a remote system over a network. The debugger can then control the execution of the program on the remote system and retrieve information about its state.|$|R
50|$|Later {{versions}} {{also supported}} <b>remote</b> <b>debugging</b> via an RS232 communication cable.|$|R
40|$|<b>Remote</b> <b>debugging</b> {{facilities}} are a technical necessity for devices that have limited computing power {{to run an}} IDE (e. g., smartphones), lack appropriate input/output interfaces (display, keyboard, mouse) for programming (e. g mobile robots) or are simply unreachable for local development (e. g cloud-servers). Yet <b>remote</b> <b>debugging</b> solutions can prove awkward to use due to their distributed nature. Empirical studies show us that on average 10. 5 minutes per coding hour (over five 40 -hour work weeks per year) are spend for re-deploying applications while fixing bugs or improving functionality. Moreover current solutions lack facilities {{that would otherwise be}} available in a local setting because its difficult to reproduce them remotely. Our work identifies three desirable properties that an ideal solution for <b>remote</b> <b>debugging</b> should exhibit, namely: run-time evolution, semantic instrumentation and adaptable distribution. Given these properties we propose and validate Mercury, a live <b>remote</b> <b>debugging</b> model and architecture for reflective OO languages...|$|R
5000|$|Examples are {{real-time}} support, <b>remote</b> <b>debugging</b> support, networking functionality and {{a choice}} of networking servers ...|$|R
5000|$|Local and <b>remote</b> <b>debugging</b> of SQL stored {{procedures}} on supported {{versions of}} Microsoft SQL Server.|$|R
5000|$|With the platform-independent {{open-source}} Winpdb debugger, one {{can perform}} <b>remote</b> <b>debugging</b> over TCP/IP, through encrypted connection.|$|R
5000|$|Workspace Agents: Each machine {{contains}} workspace agents {{which provide}} services like SSH access, monitoring and <b>remote</b> <b>debugging</b> for the user.|$|R
50|$|Xcode 2.0 — Xcode 2.0, Apple's Cocoa {{development}} tool now includes visual modelling, an integrated Apple Reference Library and graphical <b>remote</b> <b>debugging.</b>|$|R
50|$|Exclusive C++ <b>debugging</b> tools, {{including}} <b>remote</b> <b>debugging</b> for distributed development (COM and CORBA); multi-process and cross-process debugging with debug inspectors, dynamic watch windows, and debug tooltips.|$|R
50|$|MQX RTOS {{includes}} a TCP/IP stack (RTCS), embedded MS-DOS file system (MFS), USB Host/Device Stack, {{as well as}} Design, Task-Aware <b>debugging</b> (TAD), <b>Remote</b> <b>debugging</b> and performance analysis tools.|$|R
40|$|International audienceRemote {{debugging}} {{facilities are}} a technical necessity for devices that lack appropriate input/output interfaces (display, keyboard, mouse) for programming (e. g., smartphones, mobile robots) or are simply unreachable for local development (e. g., cloud-servers). Yet <b>remote</b> <b>debugging</b> solutions can prove awkward to use due to re-deployments. Empirical studies {{show us that}} on average 10. 5 minutes per coding hour (over five 40 -hour work weeks per year) are spent for redeploying applications (including re-deployments during debugging). Moreover current solutions lack facilities {{that would otherwise be}} available in a local setting because it is difficult to reproduce them remotely. Our work identifies three desirable properties that a <b>remote</b> <b>debugging</b> solution should exhibit, namely: run-time evolution, semantic instrumentation and adaptable distribution. Given these properties we propose and validate Mercury, a <b>remote</b> <b>debugging</b> model based on reflection. Mercury supports run-time evolution through a causally connected remote meta-level, semantic instrumentation through the reification of the underlying execution environment and adaptable distribution through a modular architecture of the debugging middleware...|$|R
50|$|Wakanda Server {{supports}} CommonJS modules, Web Workers, Web Storage, XMLHttpRequest, HTML5 File API, Blobs, Timers. It implements the Firebug Crossfire Debugger protocol, {{as well as}} the WebKit <b>remote</b> <b>debugging</b> protocol.|$|R
50|$|Because of its strict {{separation}} between interface and implementation, Mesa allows true incremental compilation and encourages architecture- and platform-independent programming. They also simplified source-level <b>debugging,</b> including <b>remote</b> <b>debugging</b> via the Ethernet.|$|R
50|$|It {{provides}} {{local and}} <b>remote</b> <b>debugging,</b> editing (with multiple key bindings, auto-completion, and auto-editing), code intelligence, multi-selection, source browser and code navigation, code refactoring, unit testing, version control, Pylint integration, project management, search abilities, and extensive documentation.|$|R
50|$|It {{supports}} debugging JavaScript, {{viewing the}} DOM, monitoring network traffic, previewing resources, editing colors, etc. It also supports <b>remote</b> <b>debugging,</b> which allows using {{the features of}} Dragonfly to be used when debugging a mobile phone, TV, or another desktop computer.|$|R
30|$|There are {{a number}} of {{applications}} to analyze the network behavior for different testing purposes, such as raw signal reconstruction and visualization, protocol verification, network performance evaluation and <b>remote</b> <b>debugging.</b> These applications access test data via a Publish-Subscribe Matrix to decouple related software components.|$|R
50|$|A {{debugger}} is {{a computer}} program {{that is used to}} debug (and sometimes test or optimize) other programs. GNU Debugger (GDB) {{is an example of a}} debugger used in open-source software development. This debugger offers <b>remote</b> <b>debugging,</b> what makes it especially applicable to open-source software development.|$|R
50|$|PyDev was {{originally}} created by Aleks Totic in July 2003, but Fabio Zadrozny became the project's main developer in January 2005. In September {{of that same}} year, PyDev Extensions was started as a commercial counterpart of PyDev, offering features such as code analysis and <b>remote</b> <b>debugging.</b>|$|R
50|$|Eclipse {{supports}} {{development for}} Tomcat, GlassFish {{and many other}} servers and is often capable of installing the required server (for development) directly from the IDE. It supports <b>remote</b> <b>debugging,</b> allowing a user to watch variables and step through the code of an application that is running on the attached server.|$|R
2500|$|... /CRASHDEBUG [...] Loads the kernel {{debugger}} at OS startup, but {{it remains}} inactive until a Stop error occurs. With this switch, the COM port {{can be used for}} normal operations while Windows is running. If Windows crashes, the switch converts the port to a debug port. (This action turns on <b>remote</b> <b>debugging.)</b> ...|$|R
50|$|Once PCD was {{integrated}} into the product, the final results showed reduced startup time and great improvements in the system’s robustness, reliability and availability. The <b>Debugging</b> and <b>remote</b> <b>debugging</b> capabilities were also improved due to the extended debug information which was available {{in case of a}} crash (Segmentation fault, bus error, or similar).|$|R
5000|$|... /CRASHDEBUG [...] - [...] Loads the kernel {{debugger}} at OS startup, but {{it remains}} inactive until a Stop error occurs. With this switch, the COM port {{can be used for}} normal operations while Windows is running. If Windows crashes, the switch converts the port to a debug port. (This action turns on <b>remote</b> <b>debugging.)</b> ...|$|R
40|$|One of the {{principal}} impediments to debugging and monitoring distributed systems is the difficulty of implementing the required infrastructure. If <b>remote</b> <b>debugging</b> and monitoring were universally available at low cost and with minimal implementation effort it might lead to increases in the integrity and robustness of distributed systems. We describe a technique that brings universal distributed debugging and monitoring within easy grasp. The fundamental observation is that the Hypertext Transport Protocol (HTTP), the enabling protocol of the World Wide Web (WWW), is just a general-purpose synchronous Remote Procedure Call (RPC) {{with the ability to}} carry arbitrary arguments and results. Consequently, by embedding a small web server in the runtime environment of any programming language, it is possible to implement, using standard HTTP and Hypertext Markup Language (HTML), the medium of expression of Web pages, powerful <b>remote</b> <b>debugging</b> and monitoring facilities that can be accessed by a [...] ...|$|R
25|$|Development changes: <b>remote</b> <b>debugging,</b> part of {{the browser}} layer has been {{implemented}} in Java, communicating {{with the rest of}} the Chromium and WebKit code through Java Native Bindings. The code of Chrome for Android is a fork of the Chromium project. It is a priority to upstream most new and modified code to Chromium and WebKit to resolve the fork.|$|R
50|$|Until September 2009, two {{versions}} of PyDev existed: an open source version, and a shareware version called PyDev Extensions. Certain advanced features such as code analysis, quick-fixes, and <b>remote</b> <b>debugging</b> were reserved for the non-free version. On September 3, 2009, Aptana announced PyDev version 1.5, a combined version of PyDev and PyDev Extensions, all available under the Eclipse Public License.|$|R
40|$|When {{programs}} fail in the field, {{developers are}} often left with limited information to diagnose the failure. Automated error reporting tools {{can assist in}} bug report generation but without precise steps from the end user {{it is often difficult}} for developers to recreate the failure. Advanced <b>remote</b> <b>debugging</b> tools aim to capture sufficient information from field executions to recreate failures in the lab, but have too much overhead to practically deploy. We present CHRONICLER, an approach to <b>remote</b> <b>debugging</b> that captures nondeterministic inputs to applications in a lightweight manner, guaranteeing faithful reproduction of client executions. We evaluated CHRONICLER by creating a Java implementation, CHRONICLERJ, and then by using a set of benchmarks mimicking real world applications and workloads, showing its runtime overhead to be under 10 % in most cases (worst case 86 %), while an existing tool showed overhead over 100 % in the same cases (worst case 2, 322 %) ...|$|R
40|$|Abstract—When {{programs}} fail in the field, {{developers are}} often left with limited information to diagnose the failure. Automated error reporting tools {{can assist in}} bug report generation but without precise steps from the end user {{it is often difficult}} for developers to recreate the failure. Advanced <b>remote</b> <b>debugging</b> tools aim to capture sufficient information from field executions to recreate failures in the lab but often have too much overhead to practically deploy. We present CHRONICLER, an approach to <b>remote</b> <b>debugging</b> that captures non-deterministic inputs to applications in a lightweight manner, assuring faithful reproduction of client executions. We evaluated CHRONICLER by creating a Java implementation, CHRONICLERJ, and then by using a set of benchmarks mimicking real world applications and workloads, showing its runtime overhead to be under 10 % in most cases (worst case 86 %), while an existing tool showed overhead over 100 % in the same cases (worst case 2, 322 %). Index Terms—Debugging aids, Software maintenance, Error handling and recovery, Maintainabilit...|$|R
40|$|This archive {{contains}} the Java implementation of our system, Chronicler, described below: When programs fail in the field, developers are often left with limited information to diagnose the failure. Automated error reporting tools {{can assist in}} bug report generation but without precise steps from the end user {{it is often difficult}} for developers to recreate the failure. Advanced <b>remote</b> <b>debugging</b> tools aim to capture sufficient information from field executions to recreate failures in the lab but often have too much overhead to practically deploy. We present CHRONICLER, an approach to <b>remote</b> <b>debugging</b> that captures non-deterministic inputs to applications in a lightweight manner, assuring faithful reproduction of client executions. We evaluated CHRONICLER by creating a Java implementation, CHRONICLERJ, and then by using a set of benchmarks mimicking real world applications and workloads, showing its runtime overhead to be under 10 % in most cases (worst case 8 ! 6 %), while an existing tool showed overhead over 100 % in the same cases (worst case 2, 322 %) ...|$|R
5000|$|Although not {{implemented}} as MPW tools, {{the package}} also came with several source-level debuggers through its history; SourceBug and SADE (Symbolic Application Debugging Environment) were used on MC680x0 systems, while the Power Mac Debugger (known during development as R2Db) provided {{both local and}} <b>remote</b> <b>debugging</b> services for PowerPC systems, the latter by using a server program known as a [...] "debugger nub" [...] on the computer being debugged.|$|R
50|$|Zend Platform is {{a product}} that runs on a web server, {{monitoring}} PHP applications and reporting on performance and possible problems. It also offers a PHP accelerator (often confused with the free Zend Optimizer), a content caching solution including an API for partial page caching, session clustering and numerous management tools. Zend Platform {{can be used in}} conjunction with Zend Studio to do <b>remote</b> <b>debugging</b> and profiling of PHP applications in their native server environment.|$|R
40|$|GNU debugger, gdb. 1 I {{discussed}} how its <b>remote</b> <b>debugging</b> feature {{could be used}} to debug code running in an embedded sys-tem connected to a PC by a serial cable, network connection, or some other means. While commercial prod-ucts with this capability are also avail-able, in my opinion the freely available gdb is the preferred solution because it provides portable, sophisticated debugging over a broad range of embedded systems, including devices with communications interfaces or resource constraints too restrictive for general commercial support. I also mentioned in that article that, to make <b>remote</b> <b>debugging</b> possi-ble, gdb requires the services of a debugging stub—a small library of code in the debugging target that manages registers and memory, responds to breakpoints, and reports application status to gdb via the com-munications link. That article con-tained excerpts from a debugging stub for the Hitachi SH- 2 microcontroller, but I didn’t actually put enough of the pieces together to show how a com-plete debugging stub would work. I’ll fix that this month by present-ing in detail the GDB Remote Serial Protocol—gdb’s standard remote communications protocol. Once you are comfortable with how your proces-sor handles breakpoint and othe...|$|R
40|$|Bug [LCGDM- 1816] - Xrootd {{instances}} are not correctly {{started on}} CentOS 7 [LCGDM- 1817] - xrootd@. service and cmsd@. service unit file and xrootd conf script [LCGDM- 1987] - Puppet should restart xrootd on certificate change Task [LCGDM- 1955] - Enable <b>remote</b> <b>debugging</b> for ATLAS FAX sites on puppet-xrootd [LCGDM- 1982] - Add LD_LIBRARY_PATH conf to override. conf file {{in case of}} HDFS installation on CC 7 [LCGDM- 1983] - add systemctl daemon-reload automatically when unit file are changed on CC 7 [LCGDM- 1996] - dpm-xrootd log and /var/run folder creation on CentOS...|$|R
40|$|The WebKit <b>Remote</b> <b>Debugging</b> API {{can be used}} {{to build}} custom tools, such as Web Development IDEs to aid in web design and development. In this presentation, source code walkthroughs and demos are {{presented}} to highlight the power of this API and show how it can be used in one’s own tools- 1) Pausing the debugger when an uncaught exception is thrown, 2) Inspecting the computed style of a node that is visually selected by the user. Developers are encouraged to create their own tools based on this API...|$|R
