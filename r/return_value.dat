468|4984|Public
25|$|JavaScript {{was changed}} due to {{concerns}} over the Y2K bug, and the <b>return</b> <b>value</b> for years changed and thus differed between versions from sometimes being a four digit representation and sometimes a two-digit representation forcing programmers to rewrite already working code to make sure web pages worked for all versions.|$|E
25|$|An {{example of}} the use of this {{operator}} in Haskell would be getLine >>= putStrLn, which reads a single line of text from standard input and echoes it to standard output. Note that the first operator, >>, is just a special case of this operator in which the <b>return</b> <b>value</b> of the first action is ignored and the selected second action is always the same.|$|E
25|$|Like in C and C++ {{there are}} {{functions}} that group reusable code. The main {{difference is that}} functions, just like in Java, have to reside inside of a class. A function is therefore called a method. A method has a <b>return</b> <b>value,</b> a name and usually some parameters initialized when it is called with some arguments. It can either belong to an instance of a class or be a static member.|$|E
5000|$|... {{function}} ReturnHandle takes {{handle h}} returns handle return h endfunction [...] function H2I takes handle h returns integer call ReturnHandle(h) //This sets the last <b>returned</b> <b>value</b> to 'h'. if false then return 0 //This can never occur, so the game uses the last <b>returned</b> <b>value</b> as this function's <b>returned</b> <b>value</b> instead. //It will even return the last <b>returned</b> <b>value</b> as a different type, {{in this case}} an integer. endif endfunction ...|$|R
50|$|The {{number of}} <b>return</b> <b>values</b> of an {{expression}} equals {{the difference between}} the number of operands in an expression and the total arity of the operators minus the total number of <b>return</b> <b>values</b> of the operators.|$|R
50|$|Subroutines may <b>return</b> <b>values.</b>|$|R
25|$|A state monad {{allows a}} {{programmer}} to attach state information {{of any type}} to a calculation. Given any value type, the corresponding type in the state monad is a function which accepts a state, then outputs a new state (of type s) along with a <b>return</b> <b>value</b> (of type t). This is similar to an environment monad, except that it also return a new state, and thus allows modeling a mutable environment.|$|E
25|$|The {{operations}} {{that define the}} monad must fulfil several properties to allow the correct composition of monadic functions (i.e. functions that use values from the monad as their arguments or <b>return</b> <b>value).</b> Because a monad can insert additional operations around a program's domain logic, monads {{can be considered a}} sort of aspect-oriented programming. The domain logic can be defined by the application programmer in the pipeline, while required aside bookkeeping operations can be handled by a pre-defined monad built in advance.|$|E
25|$|The {{following}} code {{defines a}} class named Person. In addition to initialize, the usual constructor {{to create new}} objects, it has two methods: one to override the <=> comparison operator (so Array#sort can sort by age) {{and the other to}} override the to_s method (so Kernel#puts can format its output). Here, attr_reader is an example of metaprogramming in Ruby: attr_accessor defines getter and setter methods of instance variables, but attr_reader only getter methods. The last evaluated statement in a method is its <b>return</b> <b>value,</b> allowing the omission of an explicit return statement.|$|E
50|$|The subtyping of mutable {{references}} {{is similar}} to the treatment of function arguments and <b>return</b> <b>values.</b> Write-only references (or sinks) are contravariant, like function arguments; read-only references (or sources) are covariant, like <b>return</b> <b>values.</b> Mutable references which act as both sources and sinks are invariant.|$|R
50|$|Translation of HRESULT <b>return</b> <b>values</b> into exceptions.|$|R
5000|$|... {{function}} quiescence_search(node, depth) if node appears quiet or node is {{a terminal}} node or depth = 0 <b>return</b> estimated <b>value</b> of node else [...] //One might use minimax or alpha-beta search here... search children of node using recursive applications of quiescence_search <b>return</b> estimated <b>value</b> of children [...] //...and here function normal_search(node, depth) if node is a terminal node <b>return</b> estimated <b>value</b> of node else if depth = 0 if node appears quiet <b>return</b> estimated <b>value</b> of node else <b>return</b> estimated <b>value</b> from quiescence_search(node, reasonable_depth_value) else search children of node using recursive applications of normal_search <b>return</b> estimated <b>value</b> of children ...|$|R
25|$|The {{quality of}} recyclate not only {{supports}} high-quality recycling, {{but it can}} also deliver significant environmental benefits by reducing, reusing and keeping products out of landfills. High-quality recycling can help support growth in the economy by maximizing the economic value of the waste material collected. Higher income levels from the sale of quality recyclates can <b>return</b> <b>value</b> which can be significant to local governments, households, and businesses. Pursuing high-quality recycling can also provide consumer and business confidence in the waste and resource management sector and may encourage investment in that sector.|$|E
25|$|More subtly, {{we should}} be able to {{determine}} our next action based on the results of previous actions. To do this, Haskell has an operator >>= (pronounced bind) with type IO a → (a → IOnbsp&b) → IOnbsp&b. That is, the operand on the left is an I/O action that returns a value of type a; the operand on the right is a function that can pick an I/O action based on the value produced by the action on the left. The resulting combined action, when performed, performs the first action, then evaluates the function with the first action's <b>return</b> <b>value,</b> then performs the second action, and finally returns the second action's value.|$|E
500|$|This {{declares}} {{the class}} member method where the program begins execution. The [...]NET runtime calls the [...] method. (Note: [...] {{may also be}} called from elsewhere, like any other method, e.g. from another method of [...]) The [...] keyword makes the method accessible without an instance of [...] Each console application's [...] entry point must be declared [...] Otherwise, the program would require an instance, but any instance would require a program. To avoid that irresolvable circular dependency, C# compilers processing console applications (like that above) report an error, {{if there is no}} [...] method. The [...] keyword declares that [...] has no <b>return</b> <b>value.</b>|$|E
5000|$|... #Subtitle level 3: Using {{a custom}} {{convention}} to interpret <b>return</b> <b>values</b> ...|$|R
5000|$|Structured programming—various block structures, named subroutines {{with local}} {{variables}} and <b>return</b> <b>values</b> ...|$|R
5000|$|... {{specify the}} names and data types of its {{parameters}} and <b>return</b> <b>values</b> ...|$|R
2500|$|The <b>return</b> <b>value</b> of the leafSearch {{is used in}} the {{modified}} siftDown routine: ...|$|E
2500|$|A {{function}} {{can be set}} up {{to return}} any number of values by using the special <b>return</b> <b>value</b> varargout. For example: ...|$|E
2500|$|If an exec {{function}} does {{return to}} the calling program, an error occurs, the <b>return</b> <b>value</b> is −1, and errno is set {{to one of the}} following values: ...|$|E
50|$|Expressions in Icon often <b>return</b> {{a single}} <b>value,</b> for instance, x < 5 will {{evaluate}} and succeed if {{the value of}} x is less than 5, or else fail. However several of the examples below rely {{on the fact that}} many expressions do not immediately return success or failure, <b>returning</b> <b>values</b> in the meantime. This drives the examples with every and to; every causes to to continue to <b>return</b> <b>values</b> until it fails.|$|R
2500|$|... left, right := partition(A, p, lo, hi) [...] // note: {{multiple}} <b>return</b> <b>values</b> ...|$|R
30|$|The <b>returned</b> <b>value</b> varies between -∞ (bad fit) to 1 (perfect fit) [50, 51].|$|R
2500|$|The {{monotonic}} connectives; {{changing the}} truth value of any connected variables from F to T without changing any from T to F never makes these connectives change their <b>return</b> <b>value</b> from T to F, e.g[...]|$|E
2500|$|We {{can think}} of a value of type IO as an action that takes as its {{argument}} {{the current state of the}} world, and will return a new world where the state has been changed according to the function's <b>return</b> <b>value.</b> For example, the functions doesFileExist and removeFile in the standard Haskell library have the following types ...|$|E
2500|$|The <b>return</b> <b>value</b> of a proc is {{the value}} of the last {{expression}} evaluated in the procedure. References to procedures (ref proc) are also permitted. Call-by-reference parameters are provided by specifying references (such as ref real) in the formal argument list. The following example defines a procedure that applies a function (specified as a parameter) to each element of an array: ...|$|E
2500|$|Examples of {{functions}} that <b>return</b> <b>values</b> {{of the type}} expected by the above writer monad: ...|$|R
50|$|In {{computer}} programming many functions <b>return</b> <b>values</b> of integer type due to simplicity of implementation.|$|R
5000|$|A stored {{procedure}} can <b>return</b> multiple <b>values</b> {{using the}} [...] parameter, or <b>return</b> no <b>value.</b>|$|R
2500|$|Implementations of {{alpha-beta pruning}} {{can often be}} {{delineated}} by whether they are [...] "fail-soft," [...] or [...] "fail-hard." [...] The pseudo-code illustrates the fail-soft variation. With fail-soft alpha-beta, the alphabeta function may return values (v) that exceed (v < α or v > β) the α and β bounds set by its function call arguments. In comparison, fail-hard alpha-beta limits its function <b>return</b> <b>value</b> into the inclusive range of α and β.|$|E
2500|$|In his 2004 textbook, David Watt uses Tennent's {{notion of}} {{sequencer}} {{to explain the}} similarity between multi-level breaks and return statements. Watt notes that a class of sequencers known as escape sequencers, defined as [...] "sequencer that terminates execution of a textually enclosing command or procedure", encompasses both breaks from loops (including multi-level breaks) and return statements. As commonly implemented, however, return sequencers may also carry a (<b>return)</b> <b>value,</b> whereas the break sequencer as implemented in contemporary languages usually cannot.|$|E
2500|$|The first operation, x→y, or Cxy, {{is called}} {{material}} implication. If x is true then {{the value of}} x→y is taken {{to be that of}} y. But if x is false then the value of y can be ignored; however the operation must return some truth value and there are only two choices, so the <b>return</b> <b>value</b> is the one that entails less, namely true. (Relevance logic addresses this by viewing an implication with a false premise as something other than either true or false.) ...|$|E
5000|$|Examples of {{functions}} that <b>return</b> <b>values</b> {{of the type}} expected by the above writer monad: ...|$|R
50|$|Pascal {{routines}} that <b>return</b> a <b>value</b> {{are called}} functions; routines that don't <b>return</b> a <b>value</b> are called procedures. All routines in C are called functions; C functions {{that do not}} <b>return</b> a <b>value</b> are declared with a return type of void.|$|R
50|$|If no reorderings are performed, and the read of y in Thread 2 <b>returns</b> the <b>value</b> 2, {{then the}} {{subsequent}} read of x should <b>return</b> the <b>value</b> 1, because the write to x was performed before the write to y. However, {{if the two}} writes are reordered, then the read of y can <b>return</b> the <b>value</b> 2, and the read of x can <b>return</b> the <b>value</b> 0.|$|R
