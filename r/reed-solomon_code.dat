333|1335|Public
25|$|The {{process is}} subject to both burst errors and random errors. Burst errors include those due to disc {{material}} (defects of aluminum reflecting film, poor reflective index of transparent disc material), disc production (faults during disc forming and disc cutting etc.), disc handling (scratches – generally thin, radial and orthogonal to direction of recording) and variations in play-back mechanism. Random errors include those due to jitter of reconstructed signal wave and interference in signal. CIRC (Cross-Interleaved <b>Reed–Solomon</b> <b>code)</b> {{is the basis for}} error detection and correction in the CD process. It corrects error bursts up to 3,500 bits in sequence (2.4nbsp&mm in length as seen on CD surface) and compensates for error bursts up to 12,000 bits (8.5nbsp&mm) that may be caused by minor scratches.|$|E
2500|$|In general, a -error {{correcting}} <b>Reed–Solomon</b> <b>code</b> over [...] can correct {{any combination}} of ...|$|E
2500|$|Certain {{families}} of codes, such as Reed–Solomon, operate on alphabet sizes larger than binary. This property awards such codes powerful burst error correction capabilities. Consider a code operating on [...] Each {{symbol of the}} alphabet can be represented by [...] bits. If [...] is an [...] <b>Reed–Solomon</b> <b>code</b> over , {{we can think of}} [...] as an [...] code over [...]|$|E
40|$|The {{research}} {{that led to}} this thesis was inspired by Sudan's breakthrough that demonstrated that <b>Reed-Solomon</b> <b>codes</b> can correct more errors than previously thought. This breakthrough can render the current state-of-the-art Reed-Solomon decoders obsolete. Much of the importance of <b>Reed-Solomon</b> <b>codes</b> stems from their ubiquity and utility. This thesis takes a few steps toward a deeper understanding of <b>Reed-Solomon</b> <b>codes</b> as well as toward the design of efficient algorithms for decoding them. After studying the binary images of <b>Reed-Solomon</b> <b>codes,</b> we proceeded to analyze their performance under optimum decoding. Moreover, we investigated the performance of <b>Reed-Solomon</b> <b>codes</b> in network scenarios when the code is shared by many users or applications. We proved that <b>Reed-Solomon</b> <b>codes</b> have many more desirable properties. Algebraic soft decoding of <b>Reed-Solomon</b> <b>codes</b> is a class of algorithms that was stirred by Sudan's breakthrough. We developed a mathematical model for algebraic soft decoding. By designing Reed-Solomon decoding algorithms, we showed that algebraic soft decoding can indeed approach the ultimate performance limits of <b>Reed-Solomon</b> <b>codes.</b> We then shifted our attention to products of <b>Reed-Solomon</b> <b>codes.</b> We analyzed the performance of linear product codes in general and <b>Reed-Solomon</b> product <b>codes</b> in particular. Motivated by these results we designed a number of algorithms, based on Sudan's breakthrough, for decoding <b>Reed-Solomon</b> product <b>codes.</b> Lastly, we tackled the problem of analyzing the performance of sphere decoding of lattice codes and linear <b>codes,</b> e. g., <b>Reed-Solomon</b> <b>codes,</b> with an eye on the tradeoff between performance and complexity...|$|R
5000|$|Prior to Folded <b>Reed-Solomon</b> <b>codes</b> being devised, {{the best}} Error-Correction Radius {{achieved}} was , by <b>Reed-Solomon</b> <b>codes</b> for all rates [...]|$|R
40|$|Interleaved <b>Reed-Solomon</b> <b>codes</b> {{are applied}} in {{numerous}} data processing, data transmission, and data storage systems. They are generated by interleaving several codewords of ordinary <b>Reed-Solomon</b> <b>codes.</b> Usually, these codewords are decoded independently by classical algebraic decoding methods. However, by collaborative algebraic decoding approaches, such interleaved schemes allow the {{correction of error}} patterns beyond half the minimum distance, provided that the errors in the received signal occur in bursts. In this work, collaborative decoding of interleaved <b>Reed-Solomon</b> <b>codes</b> by multi-sequence shift-register synthesis is considered and analyzed. Based on the framework of interleaved <b>Reed-Solomon</b> <b>codes,</b> concatenated code designs are investigated, which are obtained by interleaving several <b>Reed-Solomon</b> <b>codes,</b> and concatenating them with an inner block code. Comment: 20 pages, 7 figure...|$|R
2500|$|Next, these 24 message {{symbols are}} encoded using C2 (28,24,5) <b>Reed–Solomon</b> <b>code</b> {{which is a}} {{shortened}} RS code over [...] This is two-error-correcting, being of minimum distance 5. This adds 4 bytes of redundancy, [...] forming a new frame: [...] The resulting 28-symbol codeword is passed through a (28.4) cross interleaver leading to 28 interleaved symbols. These are then passed through C1 (32,28,5) RS code, resulting in codewords of 32 coded output symbols. Further regrouping of odd numbered symbols of a codeword with even numbered symbols of the next codeword is done to break up any short bursts that may still be present after the above 4-frame delay interleaving. Thus, for every 24 input symbols there will be 32 output symbols giving [...] Finally one byte of control and display information is added. Each of the 33 bytes is then converted to 17 bits through EFM (eight to fourteen modulation) and addition of 3 merge bits. Therefore, the frame of six samples results in 33 bytes times&nbsp&17 bits (561 bits) to which are added 24 synchronization bits and 3 merging bits yielding a total of 588 bits.|$|E
5000|$|Folded Reed-Solomon {{codes are}} {{basically}} the same as Reed Solomon codes, just viewed over a larger alphabet. To show how this might help, consider a folded <b>Reed-Solomon</b> <b>code</b> with [...] Decoding a <b>Reed-Solomon</b> <b>code</b> and folded <b>Reed-Solomon</b> <b>code</b> from the same fraction of errors [...] are tasks of almost of the same computational intensity: one can unfold the received word of the folded <b>Reed-Solomon</b> <b>code,</b> treat it as an received word of the original <b>Reed-Solomon</b> <b>code,</b> and run the Reed-Solomon list decoding algorithm on it. Obviously, this list will contain all the folded Reed-Solomon codewords within distance [...] of the received word, along with some extras, which we can expurgate.|$|E
50|$|In coding theory, the <b>Reed-Solomon</b> <b>code</b> {{belongs to}} the class of non-binary cyclic error-correcting codes. The <b>Reed-Solomon</b> <b>code</b> is based on {{univariate}} polynomials over finite fields.|$|E
40|$|This paper {{proposes a}} new class of multi-dimensional nonsystematic <b>Reed-Solomon</b> <b>codes</b> that are {{constructed}} based on the multi-dimensional Fourier transform over a finite field. The proposed codes are the extension of the nonsystematic <b>Reed-Solomon</b> <b>codes</b> to multi-dimension. This paper also discusses the performance of the multi-dimensional nonsystematic <b>Reed-Solomon</b> <b>codes.</b> Comment: 8 pages, 5 figure...|$|R
5000|$|In <b>coding</b> theory, folded <b>Reed-Solomon</b> <b>codes</b> {{are like}} <b>Reed-Solomon</b> <b>codes,</b> which are {{obtained}} by mapping [...] Reed-Solomon codewords over a larger alphabet by careful bundling of codeword symbols.|$|R
50|$|In 1977, <b>Reed-Solomon</b> <b>codes</b> were {{implemented}} in the Voyager program {{in the form of}} concatenated error correction codes. The first commercial application in mass-produced consumer products appeared in 1982 with the compact disc, where two interleaved <b>Reed-Solomon</b> <b>codes</b> are used. Today, <b>Reed-Solomon</b> <b>codes</b> are widely implemented in digital storage devices and digital communication standards, though they are being slowly replaced by more modern low-density parity-check (LDPC) codes or turbo <b>codes.</b> For example, <b>Reed-Solomon</b> <b>codes</b> are used in the Digital Video Broadcasting (DVB) standard DVB-S, but LDPC codes are used in its successor, DVB-S2.|$|R
5000|$|... #Caption: Folding of <b>Reed-Solomon</b> <b>code</b> with folding {{parameter}} m=3 ...|$|E
5000|$|In general, a -error {{correcting}} <b>Reed-Solomon</b> <b>code</b> over [...] can correct {{any combination}} of ...|$|E
5000|$|<b>Reed-Solomon</b> <b>code</b> - {{invented in}} 1960 by Prof. Irving S. Reed and Gustave Solomon ...|$|E
40|$|<b>Reed-Solomon</b> <b>codes</b> and Gabidulin codes have maximum Hamming {{distance}} and maximum rank distance, respectively. A general construction using skew polynomials, called skew <b>Reed-Solomon</b> <b>codes,</b> {{has already been}} introduced in the literature. In this work, we introduce a linearized version of such <b>codes,</b> called linearized <b>Reed-Solomon</b> <b>codes.</b> We prove that they have maximum sum-rank distance. Such distance is of interest in multishot network coding or in singleshot multi-network coding. To prove our result, we introduce new metrics defined by skew polynomials, which we call skew metrics, we prove that skew <b>Reed-Solomon</b> <b>codes</b> have maximum skew distance, and then we translate this scenario to linearized <b>Reed-Solomon</b> <b>codes</b> and the sum-rank metric. The theories of <b>Reed-Solomon</b> <b>codes</b> and Gabidulin codes are particular cases of our theory, and the sum-rank metric extends both the Hamming and rank metrics. We develop our theory over any division ring (commutative or non-commutative field). We also consider non-zero derivations, which give new maximum rank distance codes over infinite fields not considered before...|$|R
40|$|Abstract—Novel {{encoding}} scheme for algebraic codes, such as codes on algebraic curves, multidimensional cyclic codes, and hyperbolic cascaded <b>Reed–Solomon</b> <b>codes,</b> is proposed with numerical examples. We {{make use of}} the 2 -dimensional inverse discrete Fourier transform, which generalizes the Mattson–Solomon polynomial for <b>Reed–Solomon</b> <b>codes.</b> We also generalize the workings of the generator polynomial for <b>Reed–Solomon</b> <b>codes,</b> and realize a systematic encoding for various algebraic codes. ...|$|R
40|$|In {{this paper}} {{we present a}} {{modification}} of <b>Reed-Solomon</b> <b>codes</b> that beats the Guruwami-Sudan 1 -√(R) decoding radius of <b>Reed-Solomon</b> <b>codes</b> at low rates R. The idea is to choose <b>Reed-Solomon</b> <b>codes</b> U and V with appropriate rates in a (U| U+V) construction and to decode them with the Koetter-Vardy soft information decoder. We suggest to use a slightly more general version of these codes (but which has the same decoding performances as the (U| U+V) -construction) for code-based cryptography, namely to build a McEliece scheme. The point is here that these codes not only perform nearly as well (or even better in the low rate regime) as <b>Reed-Solomon</b> <b>codes,</b> their structure seems to avoid the Sidelnikov-Shestakov attack which broke a previous McEliece proposal based on generalized <b>Reed-Solomon</b> <b>codes...</b>|$|R
50|$|Justesen {{codes are}} derived as the code {{concatenation}} of a <b>Reed-Solomon</b> <b>code</b> and the Wozencraft ensemble.|$|E
50|$|The final {{level is}} a <b>Reed-Solomon</b> <b>code.</b> Reed-Solomon codes are optimal {{in terms of}} {{recovering}} from failures, but slow to generate and recover. Since each level has fewer blocks than the one before, the <b>Reed-Solomon</b> <b>code</b> has {{a small number of}} recovery blocks to generate and to use in recovery. So, even though Reed-Solomon is slow, it only has a small amount of data to handle.|$|E
5000|$|The {{generator}} polynomial [...] of a BCH code has coefficients from In general, a {{cyclic code}} over [...] with [...] as the generator polynomial {{is called a}} BCH code over The BCH code over [...] with [...] as the generator polynomial is called a <b>Reed-Solomon</b> <b>code.</b> In other words, a <b>Reed-Solomon</b> <b>code</b> is a BCH code where the decoder alphabet {{is the same as}} the channel alphabet.|$|E
5000|$|Because {{of their}} ubiquity and the nice {{algebraic}} properties they possess, list-decoding algorithms for <b>Reed-Solomon</b> <b>codes</b> were a {{main focus of}} researchers. The list-decoding problem for <b>Reed-Solomon</b> <b>codes</b> can be formulated as follows: ...|$|R
40|$|International audience—In {{this paper}} {{we present a}} {{modification}} of <b>Reed-Solomon</b> <b>codes</b> that beats the Guruswami-Sudan 1 − √ R decoding radius of <b>Reed-Solomon</b> <b>codes</b> at low rates R. The idea is to choose <b>Reed-Solomon</b> <b>codes</b> U and V with appropriate rates in a (U | U + V) construction and to decode them with the Koetter-Vardy soft information decoder. We suggest to use a slightly more general version of these codes (but which has the same decoding performance as the (U | U + V) -construction) for being used in code-based cryptography, namely to build a McEliece scheme. The point is here that these codes not only perform nearly as well (or even better in the low rate regime) as <b>Reed-Solomon</b> <b>codes,</b> but also that their structure seems to avoid the Sidelnikov-Shestakov attack which broke a previous McEliece proposal based on generalized <b>Reed-Solomon</b> <b>codes...</b>|$|R
40|$|We {{study the}} problem of {{classifying}} deep holes of <b>Reed-Solomon</b> <b>codes.</b> We show that this problem is equivalent to {{the problem of}} classifying MDS extensions of <b>Reed-Solomon</b> <b>codes</b> by one digit. This equivalence allows us to improve recent results on the former problem. In particular, we classify deep holes of <b>Reed-Solomon</b> <b>codes</b> of dimension greater than half the alphabet size. We also give a complete classification of deep holes of Reed Solomon codes with redundancy three in all dimensions...|$|R
5000|$|A rank code is an {{algebraic}} {{linear code}} over the finite field [...] similar to <b>Reed-Solomon</b> <b>code.</b>|$|E
5000|$|For frames coded by the CCSDS <b>Reed-Solomon</b> <b>code,</b> {{fewer than}} 1 in 40,000 {{erroneous}} frames can escape detection.|$|E
5000|$|... if {{and only}} if [...] is a code word of the <b>Reed-Solomon</b> <b>code</b> {{according}} to the second definition.|$|E
40|$|Determining deep holes is an {{important}} topic in decoding <b>Reed-Solomon</b> <b>codes.</b> In a previous paper [8], we showed that the received word $u$ is a deep hole of the standard <b>Reed-Solomon</b> <b>codes</b> $[q- 1, k]_q$ if its Lagrange interpolation polynomial {{is the sum of}} monomial of degree $q- 2 $ and a polynomial of degree at most $k- 1 $. In this paper, we extend this result by giving a new class of deep holes of the generalized <b>Reed-Solomon</b> <b>codes.</b> Comment: 5 page...|$|R
40|$|In this paper, We study upper bounds for {{separating}} codes. First, {{some new}} upper bound for restricted separating codes is proposed. Finally, we illustrate that the Upper Bound Conjecture for separating <b>Reed-Solomon</b> <b>codes</b> inherited from Silverberg’s question {{holds true for}} almost all <b>Reed-Solomon</b> <b>codes...</b>|$|R
40|$|International audienceIn {{this paper}} we {{investigate}} {{the structure of}} quasi-BCH codes. In {{the first part of}} this paper we show that quasi-BCH codes can be derived from <b>Reed-Solomon</b> <b>codes</b> over square matrices extending the known relation about classical BCH and <b>Reed-Solomon</b> <b>codes.</b> This allows us to adapt the Welch-Berlekamp algorithm to quasi-BCH codes. In the second part of this paper we show that quasi-BCH codes can be seen as subcodes of interleaved <b>Reed-Solomon</b> <b>codes</b> over finite fields. This provides another approach for decoding quasi-BCH codes...|$|R
5000|$|Using these facts, we have: [...] is a {{code word}} of the <b>Reed-Solomon</b> <b>code</b> {{according}} to the first definition ...|$|E
5000|$|Something to be {{observed}} {{here is that the}} folding operation demonstrated does not change the rate [...] of the original <b>Reed-Solomon</b> <b>code.</b>|$|E
50|$|The <b>Reed-Solomon</b> <b>code</b> is a k, code; {{in other}} words, it is a linear block code of length n (over F) with {{dimension}} k and minimum Hamming distance n &minus; k + 1. The <b>Reed-Solomon</b> <b>code</b> is optimal {{in the sense}} that the minimum distance has the maximum value possible for a linear code of size (n, k); this is known as the Singleton bound. Such a code is also called a maximum distance separable (MDS) code.|$|E
40|$|This paper {{presents}} an algorithmic improvement to Sudan’s list [...] decoding algorithm for <b>Reed-Solomon</b> <b>codes</b> and its generalization to algebraic-geometric codes from Shokrollahi and Wasserman. Instead of completely factoring the interpolation polynomial over the function field of thecurve, we computesufficiently many coefficients of aHenseldevelopmenttoreconstructthefunctionsthatcorrespondto codewords. We prove that these Hensel developments {{can be found}} efficiently using Newton’s method. We also describe the algorithm in the special case of <b>Reed-Solomon</b> <b>codes.</b> Keywords: List-decoding, algebraic-geometric <b>codes,</b> <b>Reed-Solomon</b> <b>codes,</b> polynomials over algebraic function fields, Hensel lifting, Newton’s method. ...|$|R
30|$|As {{mentioned}} in the introduction <b>Reed-Solomon</b> <b>codes</b> are used in a standalone mode to correct burst errors. The decoding of <b>Reed-Solomon</b> <b>codes</b> is carried out using list decoding algorithms [1, 6]. The list decoding algorithms offer enhanced performance over bounded distance algorithms when the code rates are low.|$|R
30|$|Even <b>Reed-Solomon</b> <b>codes</b> are {{not able}} to resist the hue attack if the force of the attack is {{increased}} (the changes in hue are increased) as the blocks of <b>Reed-Solomon</b> <b>codes</b> and the blocking effect of changes in hue do not cater for exactly the same wavelet color vectors.|$|R
