6|3949|Public
50|$|The {{concept of}} records and fields was central in some early file sorting and tabulating utilities, such as IBM's <b>Report</b> <b>Program</b> <b>Generator</b> (RPG).|$|E
50|$|Programming {{languages}} for the 1400 series included Symbolic Programming System (SPS, {{an assembly}} language), Autocoder (assembly language), COBOL, FORTRAN, <b>Report</b> <b>Program</b> <b>Generator</b> (RPG), and FARGO.|$|E
50|$|It {{has a long}} history, {{having been}} {{developed}} by IBM in 1959 as the <b>Report</b> <b>Program</b> <b>Generator</b> - a tool to replicate punched card processing on the IBM 1401 then updated to RPG II for the IBM System/3 in the late 1960s, and since evolved into an HLL equivalent to COBOL and PL/I.|$|E
50|$|Tab machine {{technicians}} {{were accustomed}} to plugging wires into control panels to implement input, output, control and counter operations (add, subtract, multiply, divide). Tab machines programs were executed by impulses emitted in a machine cycle; hence, FARGO and RPG emulated {{the notion of the}} machine cycle with the program cycle. RPG was superior to and rapidly replaced FARGO as the <b>report</b> <b>generator</b> <b>program</b> of choice.|$|R
40|$|Abstract. In {{this paper}} {{we argue that}} hand-writing a <b>program</b> <b>{{generator}}</b> generator {{has a number of}} advantages compared to generating a <b>program</b> <b>generator</b> generator by self-application of a partial evaluator. We show the basic principles of how to construct a <b>program</b> <b>generator</b> generator by presenting a <b>program</b> <b>generator</b> generator for a skeletal language, and we argue that it is not more difficult to use the direct approach than the indirect approach. Moreover, we report on some promising experiments made with a prototype implementation of a <b>program</b> <b>generator</b> generator for most of the Standard ML Core Language. To the best of our knowledge, our prototype is the first succesfully implemented hand-written <b>program</b> <b>generator</b> generator for a statically typed language. ...|$|R
40|$|We {{address the}} problem of {{rigorous}} testing of <b>program</b> <b>generators.</b> <b>Program</b> <b>generators</b> are software that take as input a model in a certain modeling language, and produce as output a program that captures the execution semantics of the input-model. In this sense, <b>program</b> <b>generators</b> are also <b>programs</b> and, at first sight, the traditional techniques for testing programs ought to be applicable to <b>program</b> <b>generators</b> as well. However, the rich semantic structure of the inputs and outputs of <b>program</b> <b>generators</b> poses unique challenges that have so far not been addressed sufficiently in the testing literature. We present a novel automatic testcase generation method for testing <b>program</b> <b>generators.</b> It is based on both syntax and semantics of the modeling language, and can uncover subtle semantic errors in the <b>program</b> <b>generator.</b> We demonstrate our method on flex, a prototypical lexical analyzer generator. 1...|$|R
50|$|RPG {{is one of}} the few {{languages}} {{created for}} punched card machines that are still in common use today. This is because the language has evolved considerably over time. It was originally developed by IBM in 1959. The name <b>Report</b> <b>Program</b> <b>Generator</b> was descriptive of the purpose of the language: generation of reports from data files, including matching record and sub-total reports.|$|E
5000|$|... 1961: IBM 7030 StretchIBM {{delivers}} {{its first}} 7030 Stretch supercomputer. Stretch {{falls short of}} its original design objectives, {{and is not a}} commercial success. But it is a visionary product that pioneers numerous revolutionary computing technologies which are soon widely adopted by the computer industry.1961: Thomas J. Watson Research CenterIBM moves its research headquarters from Poughkeepsie, NY to Westchester County, NY, opening the Thomas J. Watson Research Center which remains IBM's largest research facility, centering on semiconductors, computer science, physical science and mathematics. The lab which IBM establish at Columbia University in 1945 was closed and moved to the Yorktown Heights laboratory in 1970.1961: IBM Selectric typewriterIBM introduces the Selectric typewriter product line. Later Selectric models feature memory, giving rise to the concepts of word processing and desktop publishing. The machine won numerous awards for its design and functionality. Selectrics and their descendants eventually captured 75 percent of the United States market for electric typewriters used in business. IBM replaced the Selectric line with the IBM Wheelwriter in 1984 and transferred its typewriter business to the newly formed Lexmark in 1991.1961: Report Program GeneratorIBM offers its <b>Report</b> <b>Program</b> <b>Generator,</b> an application that allows IBM 1401 users to produce reports. This capability was widely adopted throughout the industry, becoming a feature offered in subsequent generations of computers. It {{played an important role in}} the successful introduction of computers into small businesses.1962: Basic beliefsDrawing on established IBM policies, Thomas J. Watson, Jr., codifies three IBM basic beliefs: respect for the individual, customer service, and excellence.1962: SABRETwo IBM 7090 mainframes formed the backbone of the SABRE reservation system for American Airlines. As the first airline reservation system to work live over phone lines, SABRE linked high speed computers and data communications to handle seat inventory and passenger records.1964: IBM System/360In the most important product announcement in company history to date, IBM introduces the IBM System/360: a new concept in computers which creates a [...] "family" [...] of small to large computers, incorporating IBM Solid Logic Technology (SLT) microelectronics and using the same programming instructions. The concept of a compatible [...] "family" [...] of computers transforms the industry.1964: Word processingIBM introduces the IBM Magnetic Tape Selectric Typewriter, a product which pioneered the application of magnetic recording devices to typewriting, and gave rise to desktop word processing. Referred to then as [...] "power typing," [...] the feature of revising stored text improved office efficiency by allowing typists to type at [...] "rough draft" [...] speed without the pressure of worrying about mistakes.1964: New corporate headquartersIBM moves its corporate headquarters from New York City to Armonk, New York.1965: Gemini space flightsA 59-pound onboard IBM guidance computer is used on all Gemini space flights, including the first spaceship rendezvous. IBM scientists complete the most precise computation of the Moon's orbit and develop a fabrication technique to connect hundreds of circuits on a silicon wafer.1965: New York World's FairThe IBM Pavilion at the New York World's Fair closes, having hosted more than 10 million visitors during its two-year existence.1966: Dynamic Random-Access Memory (DRAM)IBM invents one-transistor DRAM cells which permit major increases in memory capacity. DRAM chips become the mainstay of modern computer memory systems: the [...] "crude oil" [...] of the information age is born.1966: IBM System/4 PiIBM ships its first System/4Pi computer, designed to meet U.S. Department of Defense and NASA requirements. More than 9000 units of the 4Pi systems are delivered by the 1980s for use in the air, sea, and space.1966: IBM Information Management System (IMS)IBM designed the Information Management System (IMS) with Rockwell and Caterpillar starting in 1966 for the Apollo program, where it was used to inventory the very large bill of materials (BOM) for the Saturn V moon rocket and Apollo space vehicle.1967: Fractal geometryIBM researcher Benoit Mandelbrot conceives fractal geometry - the concept that seemingly irregular shapes can have identical structure at all scales. This new geometry makes it possible to mathematically describe the kinds of irregularities existing in nature. The concept greatly impacts the fields of engineering, economics, metallurgy, art, health sciences, and computer graphics and animation.1968: IBM Customer Information Control System (CICS)IBM introduces the CICS transaction monitor. CICS remains to this day the industry's most popular transactions monitor.|$|E
40|$|The {{purpose of}} this {{dissertation}} {{was to develop a}} learning instrument, to be used by programmers preparing for the Data Processing Management Association Test as a self study book, or by college business programming and computer science students who have completed a course in data processing and a course in programming a higher level language. The mathematical ability requirement was minimized by developing the algorithms in parallel with the programs. The learner should experience _emphasis in the following. areas: l. The type of activities required to pass the DPMA test (the programming part) 2. Data Structures 3. Fortran (at the level of the DPMA test) I 4. RPG (at the level of the DPMA test) 5. Flow chart reading and writing Fortran and RPG (<b>Report</b> <b>Program</b> <b>Generator)</b> languages were used, since their proficiency is required for the DPMA test; however a subset of IBM Basic Assembler language was used, because the author believed that a person who is more than superficially interested in computers should demonstrate a proficiency with a machine language. An important part of this method of presentation are the cassette recordings which allow the learner to progress outside the classroom. The recordings plus the hard copy of the actual programs, diminished in size, give the learner material which he can move to any location and study without the presence of the instructor...|$|E
40|$|International audienceThe use {{of program}} {{generation}} from graphical representations like UML is increasing in software projects. The notion of hypergenericity is being posited to improve <b>program</b> <b>generators.</b> This paper presents MetaScribe, a tool designed to build <b>program</b> <b>generators,</b> which provides guidelines to <b>program</b> <b>generator</b> designers and has enhanced facilities for reusability. An example illustrates {{the use of}} MetaScribe: the construction of <b>program</b> <b>generators</b> from UML class diagrams to C++ and Ada 95...|$|R
40|$|The use {{of program}} {{generation}} from graphical representations like UML is increasing in software pro-jects. The notion of hypergenericity is raising up to improve <b>program</b> <b>generators.</b> This paper presents MetaS-cribe, a tool designed to build <b>program</b> <b>generators</b> provi-ding guidelines to <b>program</b> <b>generator</b> designers and having enhanced facilities for reusability. An example illustrates {{the use of}} MetaScribe: the construction of pro-gram generators from UML Class diagrams to C++ and Ada 95...|$|R
40|$|Transcript, 43 pp. Software {{products}} industry pioneer John Cullinane {{begins by}} discussing his education {{and his first}} jobs in computer operations and programming at Arthur D. Little, C-E-I-R, and Philip Hankins & Company. He relates how these experiences led him to form a software products firm, Cullinane Corporation, and raise venture capital. He discusses the firm's development and marketing {{of a number of}} new software products, including Culprit, Library Update System, EDP Auditor, and IDMS, and IDMSDC, and relates how the Cullinane Corporation transitioned from selling individual <b>report</b> <b>generator</b> <b>programs</b> to suites of data processing systems that included database software and other applications. Much of the interview focuses on the firm's evolving management strategy that led to its long-term financial success. Cullinane also discusses some problems occurred after he left the active management of the company, the sale of Cullinet (the firm's new name) to Computer Associates, and his subsequent business and philanthropic activities...|$|R
40|$|When {{writing a}} <b>program</b> <b>generator</b> {{requires}} considerable intellectual effort, it is valuable to amortize that effort {{by using the}} generator to build more than one application. When a <b>program</b> <b>generator</b> serves multiple clients, however, the implementor must address pragmatic questions that implementors of single-use <b>program</b> <b>generators</b> can ignore. In how many languages should generated code be written? How should code be packaged? What should the interfaces to the client code look like? How should a user control variations? This paper elaborates on these questions by means of case studies of the New Jersey Machine-Code Toolkit, the λ-RTL Translator, and the ASDL <b>program</b> <b>generator.</b> It is hoped that the paper will stimulate the development of better techniques. Most urgently needed are a standard way to support multiple target languages and a simple, clear way to control interfaces to generated code. ...|$|R
40|$|Sam Kamin Computer Science Dept. University of Illinois at Urbana-Champaign 1304 W. Springfield Urbana, IL 61801 fkaming@cs. uiuc. edu Abstract The {{interpreter}} for {{the functional}} language JR has been constructed by a unique form of bootstrapping. The entire processor {{is written in}} C++, but much of that C++ is produced by <b>program</b> <b>generators.</b> These <b>program</b> <b>generators</b> [...] - a lexer generator, parser generator, etc. [...] - are programmed in JR itself by the method of "lightweight embedding. " This project is intended to demonstrate the viability of this method of constructing <b>program</b> <b>generators.</b> Because the method of embedding yields powerful languages at modest cost, we {{view it as a}} potentially advantageous approach to the production of <b>program</b> <b>generators,</b> which can in turn yield an entirely new method of achieving code reuse. Partially supported by NSF grant CCR 96 [...] 19644 1 Introduction The interpreter for the functional language JR has been constructed by a unique form of bootstrappi [...] ...|$|R
40|$|Abstract: In {{a program}} specializer, the Residual <b>Program</b> <b>Generator</b> (RPG) takes as input a source program {{decorated}} with annotations provided by its binding time analyzer and produces a specialized {{version of the}} source program. CILPE is a program specializer dealing with programs written in SOOL, a simple Stack Object-Oriented Language. The paper describes the residual <b>program</b> <b>generator</b> that {{is a part of}} CILPE. Note: Publication language:russia...|$|R
40|$|Abstract. We {{describe}} {{the design and}} implementation of a <b>program</b> <b>generator</b> that can produce extensions of Fortran that are specialized to support the programming of particular applications. Extensions are specified through parameter structures that {{can be referred to}} in Fortran programs to specify the dependency of program parts on these parameters. By providing parameter values, a parameterized Fortran program can be translated into a regular Fortran program. We describe as a real-world application of this <b>program</b> <b>generator</b> the implementation of a generic inverse ocean modeling tool. The <b>program</b> <b>generator</b> is implemented in Haskell and makes use of sophisticated features, such as multi-parameter type classes, existential types, and generic programming extensions and thus represents the application of an advanced applicative language to a real-world problem...|$|R
30|$|Customization of a {{software}} system varies with user requirements or target platform. Programmers employ preprocessor directives, command-line arguments, setup files, configuration files to customize {{a software}} system. Using product-line technology, {{it is possible}} to generate a program tailored to individual user requirements by using <b>program</b> <b>generators.</b> <b>Program</b> generation process leverage software system features where a feature is a visible behavior or characteristic of a software program [1]. According to product-line technology, any customizable option that can be selected during the compile or load time is called a feature of a <b>program.</b> <b>Program</b> <b>generator</b> generates a <b>program</b> depending on features selected by the user(s).|$|R
40|$|Abstract. Binding-time {{polymorphism}} {{enables a}} highly flexible binding-time analysis for offline partial evaluation. This work provides {{the tools to}} translate this flexibility into efficient program specialization {{in the context of}} a polymorphic language. Following the cogen-combinator approach, a set of combinators is defined in Haskell that enables the straightforward transcription of a binding-time polymorphic annotated program into the corresponding <b>program</b> <b>generator.</b> The typing of the combinators mimics the constraints of the binding-time analysis. The resulting <b>program</b> <b>generator</b> is safe, tag-free, and it has no interpretive overhead. ...|$|R
40|$|A recent {{trend in}} {{computing}} are domain-specific <b>program</b> <b>generators,</b> designed {{to alleviate the}} effort of porting and reoptimizing libraries for fast-changing and increasingly complex computing platforms. Examples include ATLAS, SPI-RAL, and the codelet generator in FFTW. Each of these generators produces highly optimized source code directly from a problem specification. In this paper, we extend this list by a <b>program</b> <b>generator</b> for the well-known Floyd-Warshall (FW) algorithm that solves the all-pairs shortest path problem, which is important {{in a wide range}} of engineering applications. As the first contribution, we derive variants of the FW algorithm that make it possible to apply many of the optimization techniques developed for matrix-matrix multiplication. The second contribution is the actual <b>program</b> <b>generator,</b> which uses tiling, loop unrolling, and SIMD vectorization combined with a hill climbing search to produce the best code (float or integer) for a given platform. Using the <b>program</b> <b>generator,</b> we demonstrate a speedup over a straightforward single-precision implementation of up to a factor of 1. 3 on Pentium 4 and 1. 8 on Athlon 64. Use of 4 -way vectorization further improves the performance by another factor of up to 5. 7 on Pentium 4 and 3. 0 on Athlon 64. For data type short integers, 8 -way vectorization provides a speed-up of up to 4. 6 on Pentium 4 and 5. 0 on Athlon 64 over the best scalar code...|$|R
40|$|A data {{dictionary}} {{system with a}} query compiler is implemented in a symbol manipulation language, separate from the underlying database system. The query compiler (or <b>program</b> <b>generator)</b> generates COBOL <b>programs</b> for database access. These programs are optimized at generation time using information from the {{data dictionary}}. The implementation technique {{makes it possible to}} combine pilot implementation with production implementation of database application programs. Furthermore, an example is given of how the architecture of the system is convertible to different underlying database systems. Key concepts: data dictionary, <b>program</b> <b>generator,</b> query language compilation, query language interpretation, non-procedural query language. I...|$|R
40|$|<b>Program</b> <b>generators</b> are {{languages}} whose programs produce {{programs in}} other languages. We show how <b>program</b> <b>generators</b> {{can be built}} easily as sets of definitions in a functional language. The method we present {{has the potential to}} be a useful application of functional languages in software development projects based on conventional languages. We illustrate the method with two examples: a top-down parser generator; and a version of the "Message Specification Language," developed at Oregon Graduate Institute. In the latter case, we are able to implement substantially the same language in 100 lines of Standard ML code, with no additional tools or optimizing compilers needed...|$|R
40|$|This paper {{describes}} {{a new technology}} for creating <b>program</b> <b>generators.</b> It is built upon research results {{in the theory of}} programming languages, formal semantics, program transformation and compilation. It comprises a suite of translation and transformation tools that constitute a design automation system for software engineering. In our method, the user's interface to a <b>program</b> <b>generator</b> is a language in which to specify each particular application for which a software module is required. We refer to this specification language as a domain-specific design language (DSDL), for it is tailored to the problem domain for which the generator is intended. A DSDL is a specialized, declarative language in which the important, high-level abstractions of the problem domain are directly expressible. Often, a DSDL is just a formalization of a tabular or graphical specification language that engineers in the problem domain have long been using to express detailed designs. For a DSDL to be used to express input to a <b>program</b> <b>generator,</b> it must have a computational semantics. The requirements that we impose upon the semantics definition for a DSDL are that it be (i) compositional, (ii) effectively computable, and (iii) total. The implementation of a <b>program</b> <b>generator</b> is derived from the semantics of a DSDL through several steps of translation and transformation to obtain satisfactory algorithmic performance and to tailor the implementation to a specific platform and software environment. Compositionality implies that an implementation can be assembled piecewise from the components of the semantics. Effective computability requires semanti...|$|R
40|$|Automatic program {{generation}} allows {{the construction of}} generic reusable software. It permits efficient execution of highly parameterized programs by specializing them with respect to parameters that are known in advance. Our approach turns such as program into a <b>program</b> <b>generator</b> that accepts the known parameters and generates the specialized program efficiently. We present a simple and general technique to derive <b>program</b> <b>generators</b> from specializers. The technique applies to higher-order functional programming languages. It factors specialization into standard evaluation and execution of a small set of combinators provided in a library. We introduce the technique with standard specializers and then apply it to continuation-based specializers and multi-level specializers. Using multi-level specialization we derive program-generator generators (PGGs) that deliver stand-alone <b>program</b> <b>generators.</b> These are comparable to earlier, ad-hoc constructed PGGs, but are correct by construction. Based on these techniques, we have designed and implemented a program-generator generator (PGG) for continuation-based- multi-level partial evaluation. We show excerpts of the actual implementation and give detailed performance measurements. (orig.) Available from TIB Hannover: RR 4367 (96 - 29) / FIZ - Fachinformationszzentrum Karlsruhe / TIB - Technische InformationsbibliothekSIGLEDEGerman...|$|R
5000|$|Screen Sculptor, SoftCode, UI Programmer, and Genifer are {{examples}} of pioneering <b>program</b> <b>generators</b> that arose during the mid-1980s through the early 1990s. They developed and advanced the technology of extendable, template based source code generators on a mass market scale.|$|R
40|$|Model {{transformation}} {{systems are}} graph transformation systems that perform translations between languages {{defined by a}} corresponding metamodel as the type graph. The current paper proposes a reflective method for the automatic generation of the implementation for such transformation systems derived from a high [...] level specification consisting {{of a set of}} graph transformation rules and a control flow graph. The <b>program</b> <b>generator</b> takes a UML profile tailored to model transformation systems as the input, and produces the output Prolog program by successive model transformation steps. In this respect, only the core of the <b>program</b> <b>generator</b> is implemented by hand, and afterwards, this core provides automation for additional features of the VIATRA model transformation system...|$|R
40|$|Abstract. We {{describe}} {{our efforts}} to use source-level rewriting to optimize run-time <b>program</b> <b>generators</b> written in Jumbo, a run-time program generation system for Java. Jumbo is a compiler written in compositional style, which brings the advantage that any program fragment can be abstracted out and compiled to an intermediate form. These forms can be put together at run-time to build complete programs. This principle provides {{a high level of}} flexibility in writing <b>program</b> <b>generators.</b> However, this comes at the price of inefficient run-time compilation. Using sourcelevel transformations, we optimize the run-time generation of byte code from fragments, achieving speedups of 5 – 15 %. We discuss the optimization process and give several examples. ...|$|R
40|$|This paper {{traces the}} {{evolution}} of simulation support tools and outlines ARGUS, a discrete event simulation <b>program</b> <b>generator</b> that targets mainly the area of queueing systems. ARGUS supports three levels of operation, depending on the user's needs and programming expertise. The system to be simulated can be speci ed using an integrated graphical editor or a textual description language. Objectoriented concepts such as encapsulation, inheritance and polymorphism are employed in both the speci cation process and the generated simulation programs are written in C++. Throughout the paper, the main characteristics of ARGUS are summarized and its capabilities are brie y presented. Keywords Discrete event simulation, object-oriented simulation, simulation <b>program</b> <b>generators,</b> graphical editors, queueing systems. ...|$|R
40|$|Part 14 : Computational Intelligence in Software Engineering (CISE) WorkshopInternational audienceIn {{the field}} of search based {{software}} engineering, evolutionary testing is a very popular domain in which test cases are automatically generated for a given piece of code using evolutionary algorithms. The techniques used in this domain usually are hard to compare {{since there is no}} standard testbed. In this paper we propose an automatic <b>program</b> <b>generator</b> to solve this situation. The <b>program</b> <b>generator</b> is able to create Java programs with the desired features. In addition, we can ensure that all the branches in the programs are reachable, i. e. a 100 % branch coverage is always possible. Thanks to this feature the research community can test and enhance their algorithms until a total coverage is achieved. The potential of the <b>program</b> <b>generator</b> is illustrated with an experimental study on a benchmark of 800 generated programs. We highlight the correlations between some static measures computed on the program and the code coverage when an evolutionary test case generator is used. In particular, we compare three techniques as the search engine for the test case generator: an Evolutionary Strategy, a Genetic Algorithm and a Random Search...|$|R
40|$|A good {{methodology}} for simulation experimentation {{can result in}} high efficiency in carrying out simulation experiments. To fully support a user {{to carry out a}} simulation experiment, a supportive and user friendly simulation experimentation environment is desirable. The <b>program</b> <b>generator</b> which generates the executable programs from a model expressed in a high-level simulation programming language is another important issue in simulation experimentation. This thesis presents a new {{methodology for}} simulation experimentation based on the model specification language Gest. A simulation experimentation environment which supports a user to carry out the simulation experiment based on the model written in Gest is implemented. A <b>program</b> <b>generator</b> which analyzes the model and generates an executable simulation program with simulation tables for the simulation experimentation environment is also discussed...|$|R
40|$|We {{present a}} program-generation {{approach}} {{to address a}} software-reuse challenge {{in the area of}} scientific computing. More specifically, we describe the design of a <b>program</b> <b>generator</b> for the specification of subroutines that can be generic in the dimensions of arrays, parameter lists, and called subroutines. We describe the application of that approach to a real-world problem in scientific computing, which requires the generic description of inverse ocean modeling tools. In addition to a compiler that can transform generic specifications into efficient Fortran code for models, we have also developed a type system that can identify possible errors already in the specifications. This type system is important for the acceptance of the <b>program</b> <b>generator</b> among scientists because it prevents a large class of errors in the generated code...|$|R
40|$|Simulation of {{automatically}} generated test {{programs is}} the main means for verifying complex hardware designs and random test <b>program</b> <b>generators</b> therefore {{play a major role}} in the verification process of micro-processors. The input for a test <b>program</b> <b>generator</b> is typically an abstract specification [...] -a template [...] -of the tests to be generated. Due to randomness, generators often encounter situations that were not anticipated when writing the test specification. In this paper, we introduce the concept of adaptive test program generation, whose goal is to deal with these unforeseen situations. We propose a technique, in which unexpected events can be defined together with their alternative program specifications. When an event is detected, its corresponding alternative specification is injected into the test program...|$|R
40|$|Measurement of {{fluorescence}} {{quantum yield}} {{has become an}} important tool {{in the search for}} new solutions in the development, evaluation, quality control and research of illumination, AV equipment, organic EL material, films, filters and fluorescent probes for bio-industry. Quantum yield is calculated as the ratio of the number of photons absorbed, to the number of photons emitted by a material. The higher the quantum yield, the better the efficiency of the fluorescent material. For the measurements featured in this video, we will use the Hitachi F- 7000 fluorescence spectrophotometer equipped with the Quantum Yield measuring accessory and <b>Report</b> <b>Generator</b> <b>program.</b> All the information provided applies to this system. Measurement of quantum yield in powder samples is performed following these steps: 1. Generation of instrument correction factors for the excitation and emission monochromators. This is an important requirement for the correct measurement of quantum yield. It has been performed in advance for the full measurement range of the instrument and will not be shown in this video due to time limitations. 2. Measurement of integrating sphere correction factors. The purpose of this step is to take into consideration reflectivity characteristics of the integrating sphere used for the measurements. 3. Reference and Sample measurement using direct excitation and indirect excitation. 4. Quantum Yield calculation using Direct and Indirect excitation. Direct excitation is when the sample is facing directly the excitation beam...|$|R
40|$|A {{few simple}} Expert-System {{techniques}} have been invaluable {{in developing a}} new test <b>program</b> <b>generator</b> for design verification of hardware processors. The new generator uses a formal declarative model of the processor architecture; it allows generation of test programs {{for a variety of}} processors without duplication of effort...|$|R
40|$|All {{commercial}} {{data processing}} installations include programs to detect errors in input data. There {{is a high}} degree of commonality in the editing (i e validating) of such input data throughout the data processing industry. This thesis defines a generalized editing package which will allow a user to specify the editing requirements for any set of input data. From the specifications a COBOL program will be created to carry out the required operations on the input file. Included as an introduction to this thesis, is a survey of editing needs, and a discussion on the merits of generalized software. The thesis emphasizes the methodology of the generation of a specific "tailor-made" editor program. Key Words: Editing EPG (Edit <b>Program</b> <b>Generator)</b> Generalized Software <b>Program</b> <b>Generator</b> Computing Review Category: 2. 0, 3. 50, 4. 12, 4. 4...|$|R
40|$|Existing {{methods for}} visual {{reasoning}} attempt to directly map inputs to outputs using black-box architectures without explicitly modeling the underlying reasoning processes. As a result, these black-box models often learn to exploit biases {{in the data}} rather than learning to perform visual reasoning. Inspired by module networks, this paper proposes a model for visual reasoning that consists of a <b>program</b> <b>generator</b> that constructs an explicit representation of the reasoning process to be performed, and an execution engine that executes the resulting program to produce an answer. Both the <b>program</b> <b>generator</b> and the execution engine are implemented by neural networks, and are trained {{using a combination of}} backpropagation and REINFORCE. Using the CLEVR benchmark for visual reasoning, we show that our model significantly outperforms strong baselines and generalizes better in a variety of settings...|$|R
40|$|<b>Program</b> <b>generators</b> and transformations {{are hard}} to {{implement}} cor-rectly, because the implementation needs to generically describe how to construct programs, for example, using templates or rewrite rules. We apply dynamic analysis to <b>program</b> <b>generators</b> {{in order to support}} developers in finding bugs and identifying the source of the bug. Our analysis focuses on syntactic language constraints and checks that generated programs are syntactically well-formed. To retain a language’s grammar as the unique specification of the lan-guage’s syntax, we devised mechanisms to derive the analysis from the grammar. Moreover, we designed a run-time system to support the modular activation/deactivation of the analysis, so that genera-tors do not require adaption. We have implemented the analysis for the Stratego term-rewriting language and applied it in case studies based on Spoofax and SugarJ...|$|R
