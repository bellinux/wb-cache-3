8|1|Public
5000|$|A <b>read-lock</b> {{does not}} block an {{intended}} read by another transaction. The respective <b>read-lock</b> for the intended read is acquired (shared {{with the previous}} read) immediately after the intended read is requested, and then the intended read itself takes place.|$|E
5000|$|A <b>read-lock</b> blocks an {{intended}} write {{by another}} transaction by blocking the respective write-lock.|$|E
5000|$|A write-lock blocks an {{intended}} (already requested/issued) read {{by another}} transaction by blocking the respective <b>read-lock</b> [...]|$|E
40|$|The B-tree and its {{variants}} {{have been}} found to be highly useful (both theoretically and in practice) for storing large amounts ofinformation, especially on secondary storage devices. We examine the problem of overcoming the inherent difficulty of concurrent operations on such structures, using a practical storage model. A single additional “link ” pointer in each node allows a process to easily recover from tree modifications performed by other concurrent processes. Our solution compares favorably with earlier solutions in that the locking scheme is simpler (no <b>read-locks</b> are used) and only a (small) constant number of nodes are locked by any update process at any given time. An informal correctness proof for our system is given...|$|R
50|$|<b>Read-lock</b> (shared lock) is {{associated}} with a database object by a transaction before reading (retrieving the state of) this object.|$|E
5000|$|... holds a <b>read-lock</b> on x and [...] holds read-locks on y. Thus [...] and [...] are {{blocked by}} the lock {{compatibility}} rules of SS2PL and cannot be executed. This is a distributed deadlock situation, {{which is also a}} voting-deadlock (see below) with a distributed (global) cycle of length 2 (number of edges, conflicts; 2 is the most frequent length). The local sub-transactions are in the following states: ...|$|E
5000|$|The data {{partition}} (x on A; y on B) is important since without it, for example, x {{can be accessed}} directly from B. If a transaction [...] is running on B concurrently with [...] and [...] and directly writes x, then, without a distributed lock manager the <b>read-lock</b> for x held by [...] on A is not visible on B and cannot block the write of [...] (or signal a materialized conflict for a non-blocking CO variant; see below). Thus serializability can be violated.|$|E
5000|$|A {{more general}} {{property}} than SS2PL exists (a schedule super-class), Strict commitment ordering (Strict CO, or SCO), which as well provides both serializability, strictness, and CO, and has similar locking overhead. Unlike SS2PL, SCO does not block upon a read-write conflict (a <b>read-lock</b> does not block acquiring a write-lock; both SCO and SS2PL {{have the same}} behavior for write-read and write-write conflicts) {{at the cost of}} a possible delayed commit, and upon such conflict type SCO has shorter average transaction completion time and better performance than SS2PL. While SS2PL obeys the lock compatibility table above, SCO has the following table: ...|$|E
40|$|TL 2 {{and similar}} STM {{algorithms}} deliver high scalability based on write-locking and invisible readers. In fact, no modern STM design locks to read along its common execution path because {{doing so would}} require a memory synchronization operation that would greatly hamper performance. In this paper we introduce TLRW, a new STM algorithm intended for the single-chip multicore systems that are quickly taking over a large fraction of the computing landscape. We make {{the claim that the}} cost of coherence in such single chip systems is down to a level that allows one to design a scalable STM based on readwrite locks. TLRW is based on byte-locks, a novel read-write lock design with a low <b>read-lock</b> acquisition overhead and the ability {{to take advantage of the}} locality of reference within transactions. As we show, TLRW has a painfully simple design, one that naturally provides coherent state without validation, implicit privatization, and irrevocable transactions. Providing similar properties in STMs based on invisible-readers (such as TL 2) has typically resulted in a major loss of performance. In a series of benchmarks we show that when running on a 64 way single-chip multicore machine, TLRW delivers surprisingly good performance (competitive with and sometimes outperforming TL 2). However, on a 128 -way 2 -chip system that has higher coherence costs across the interconnect, performance deteriorates rapidly. We believe our work raises the question of whether on single-chip multicore machines, read-write lock-based STMs are the way to go. 1...|$|E

