538|598|Public
25|$|This axiomatization is complete, {{meaning that}} every Boolean law s= t is provable in this system. One first shows by {{induction}} on {{the height of}} s that every Boolean law for which t is atomic is provable, using R1 for the base case (since distinct atoms are never equal) and A1 and R3 for the induction step (s an application). This proof strategy amounts to a <b>recursive</b> <b>procedure</b> for evaluating s to yield an atom. Then to prove s= t in the general case when t may be an application, use {{the fact that if}} s= t is an identity then s and t must evaluate to the same atom, call it u. So first prove s= u and t= u as above, that is, evaluate s and t using A1, R1, and R3, and then invoke R2 to infer s= t.|$|E
2500|$|Daylight, Edgar G.: Dijkstra's Rallying Cry for Generalization: The Advent of the <b>Recursive</b> <b>Procedure,</b> Late 1950s–Early 1960s. (The Computer Journal (2011) 54 (11): 1756-1772.) ...|$|E
2500|$|A {{short code}} in the Mathematica {{internal}} language: the <b>recursive</b> <b>procedure</b> SiPyramid generates a 3D pyramid of arbitrary order n as the displayable graphic object Graphics3D: ...|$|E
40|$|These therories {{describe}} Hoare logics for {{a number}} of imperative language constructs, from while-loops to mutually <b>recursive</b> <b>procedures.</b> Both partial and total correctness are treated. In particular a proof system for total correctness of <b>recursive</b> <b>procedures</b> in the presence of unbounded nondeterminism is presented...|$|R
5000|$|Use <b>recursive</b> <b>procedures</b> for recursively-defined data structures.|$|R
40|$|This paper {{presents}} {{sound and}} complete Hoare logics for partial and total correctness of <b>recursive</b> parameterless <b>procedures</b> {{in the context}} of unbounded nondeterminism. For total correctness, the literature so far has either restricted <b>recursive</b> <b>procedures</b> to be deterministic or has studied unbounded nondeterminism only in conjunction with loops rather than procedures. We consider both single procedures and systems of mutually <b>recursive</b> <b>procedures.</b> All proofs have been checked with the theorem prover Isabelle/HOL...|$|R
2500|$|To {{establish}} {{existence of}} the Kazhdan–Lusztig polynomials, Kazhdan and Lusztig gave a simple <b>recursive</b> <b>procedure</b> for computing the polynomials Pyw(q) in terms of more elementary polynomials denoted R'yw(q). defined by ...|$|E
2500|$|These {{expressions}} {{give rise}} to a <b>recursive</b> <b>procedure</b> called the deletion–contraction algorithm, which forms the basis of many algorithms for graph coloring. The running time satisfies the same recurrence relation as the Fibonacci numbers, so in the worst case the algorithm runs in time within a polynomial factor [...] of [...] for n vertices and m edges. The analysis can be improved to within a polynomial factor of the number [...] of spanning trees of the input graph.|$|E
2500|$|The {{expressions}} {{give rise}} to a <b>recursive</b> <b>procedure,</b> called the deletion–contraction algorithm, which forms the basis of many algorithms for graph coloring. The ChromaticPolynomial function in the computer algebra system Mathematica uses the second recurrence if the graph is dense, and the first recurrence if the graph is sparse. The worst case running time of either formula satisfies the same recurrence relation as the Fibonacci numbers, so in the worst case, the algorithm runs in time within a polynomial factor of ...|$|E
40|$|The weakest {{precondition}} semantics of <b>recursive</b> <b>procedures</b> {{with local}} variables are developed for an imperative language with demonic and angelic operators for unbounded nondeterminate choice. This {{does not require}} stacking of local variables. The formalism serves {{as a foundation for}} a proof rule for total correctness of (mutually) <b>recursive</b> <b>procedures</b> with local variables. This rule is illustrated by a simple example. Its soundness is proved for arbitrary well-founded variant functions. Keywords: predicate transformers, frames, <b>recursive</b> <b>procedures,</b> proof rule 1 Introduction Formalisms for weakest preconditions for imperative programs usually treat predicates as boolean functions on a single state space, cf. [BvW 90, DiS 90, Hes 92, Nel 89]. It follows that procedures cannot have local variables. For nonrecursive procedures, local variables can be made global by careful renaming. Actually, this is also possible for <b>recursive</b> <b>procedures</b> by means of methods analogous to those developed be [...] ...|$|R
40|$|AbstractThe weakest-precondition {{interpretation}} of <b>recursive</b> <b>procedures</b> is developed for a language {{with a combination}} of unbounded demonic choice and unbounded angelic choice. This compositional formal semantics is proved to be equal to a game-theoretic operational semantics. Two intermediate stages are exploited. One step consists of unfolding the declaration of the <b>recursive</b> <b>procedures.</b> Fixpoint induction is used to prove the validity of this step. The compositional semantics of the unfolded declaration is proved to be equal to a formal semantics of a stack implementation of the <b>recursive</b> <b>procedures.</b> After an introduction to boolean two-person games, this stack semantics is shown to correspond to a game-theoretic operational semantics...|$|R
40|$|This paper {{describes}} Hoare logics for {{a number}} of imperative language constructs, from while-loops via exceptions to mutually <b>recursive</b> <b>procedures.</b> Both partial and total correctness are treated. In particular a proof system for total correctness of <b>recursive</b> <b>procedures</b> in the presence of unbounded nondeterminism is presented. All systems are formalized and shown to be sound and complete in the theorem prover Isabelle/HOL...|$|R
2500|$|Stack {{overflow}} may {{be difficult}} to avoid when using recursive procedures, since many compilers assume that the recursion stack is a contiguous area of memory, and some allocate a fixed amount of space for it. [...] Compilers may also save more information in the recursion stack than is strictly necessary, such as return address, unchanging parameters, and the internal variables of the procedure. [...] Thus, the risk of stack overflow can be reduced by minimizing the parameters and internal variables of the <b>recursive</b> <b>procedure,</b> or by using an explicit stack structure.|$|E
5000|$|A {{classic example}} of a <b>recursive</b> <b>procedure</b> is the {{function}} {{used to calculate the}} factorial of a natural number: ...|$|E
5000|$|A <b>recursive</b> <b>procedure</b> to {{generate}} all the {{terms in the}} Magnus expansion utilizes the matrices , defined recursively throughwhich then furnish ...|$|E
5000|$|Lawrence Snyder (1973: An Analysis of Parameter Evalutation Mechanisms for <b>Recursive</b> <b>Procedures.</b> Carnegie Mellon University) ...|$|R
50|$|The other variant, , is {{designed}} to enable mutually <b>recursive</b> <b>procedures</b> to be bound to one another.|$|R
40|$|The weakest {{precondition}} semantics of <b>recursive</b> <b>procedures</b> {{with local}} variables are developed for an imperative language with demonic and angelic operators for unbounded nondeterminate choice. This {{does not require}} stacking of local variables. The formalism serves {{as a foundation for}} a proof rule for total correctness of (mutually) <b>recursive</b> <b>procedures</b> with local variables. This rule is illustrated by a simple example. Its soundness is proved for arbitrary well-founded variant functions. ...|$|R
5000|$|A {{short code}} in the Mathematica {{internal}} language: the <b>recursive</b> <b>procedure</b> SiPyramid generates a 3D pyramid of arbitrary order n as the displayable graphic object Graphics3D: ...|$|E
5000|$|Before {{discussing}} the <b>recursive</b> <b>procedure</b> {{for the general}} multiple-integrator case, it is instructive to study the recursion present in the two-integrator case. That is, consider the dynamical system ...|$|E
5000|$|Once a rule is {{selected}} and splits a node into two, {{the same process}} is applied to each [...] "child" [...] node (i.e. it is a <b>recursive</b> <b>procedure)</b> ...|$|E
40|$|This paper adds {{support for}} {{mutually}} <b>recursive</b> <b>procedures</b> {{on top of}} a predicate transformer semantics of imperative programs with pointers implemented in PVS theorem prover. We define and prove correct a collection of mutually <b>recursive</b> <b>procedures</b> which constructs the parsing tree of an expression generated by a context free grammar. We use separation logic to specify and verify these procedures; the parsing tree is represented in memory using pointers and the specification predicates are defined using separation logic...|$|R
40|$|Abstract. Speculative parallelisation {{represents}} a promising solution {{to speed up}} sequential programs {{that are hard to}} parallelise otherwise. Prior research has focused mainly on parallelising loops. <b>Recursive</b> <b>procedures,</b> which are also frequently used in real-world applications, have attracted much less attention. Moreover, the parallel threads in prior work are statically predicted and spawned. In this paper, we introduce a new compiler technique, called Speculative Parallelisation of <b>Recursive</b> <b>Procedures</b> (SPRP), to exploit speculative TLP (thread-level parallelism) in <b>recursive</b> <b>procedures.</b> SPRP combines a dynamic thread-spawning policy and a live-in prediction mechanism in a single helper thread that executes a distilled version of a procedure on a dedicated core. It serves to predict both the invocation order of recursive calls and their live-ins in concert and dispatches these calls to the other cores in a multicore system for parallel execution. To our knowledge, SPRP is the first compiler technique to speculatively parallelise <b>recursive</b> <b>procedures</b> this way. Compared with existing static thread prediction techniques, dynamic thread prediction reduces the number of useless threads spawned, and consequently, misspeculation overhead incurred. Our preliminary results demonstrate that this technique can speedup certain recursive benchmarks that are difficult to parallelise otherwise. ...|$|R
40|$|AbstractThe tcc {{paradigm}} is a formalism for timed concurrent constraint programming. Several tcc languages differing {{in their way}} of expressing infinite behavior have been proposed in the literature. In this work we study the expressive power {{of some of these}} languages. In particular, we show that: (1) <b>recursive</b> <b>procedures</b> with parameters can be encoded into parameterless <b>recursive</b> <b>procedures</b> with dynamic scoping, and viceversa. (2) replication can be encoded into parameterless <b>recursive</b> <b>procedures</b> with static scoping, and viceversa. (3) the languages from (1) are strictly more expressive than the languages from (2). Furthermore, we show that behavioral equivalence is undecidable for the languages from (1), but decidable for the languages from (2). The undecidability result holds even if the process variables take values from a fixed finite domain. (Joint work with Mogens Nielsen and Frank D. Valencia...|$|R
5000|$|To {{establish}} {{existence of}} the Kazhdan-Lusztig polynomials, Kazhdan and Lusztig gave a simple <b>recursive</b> <b>procedure</b> for computing the polynomials Pyw(q) in terms of more elementary polynomials denoted Ryw(q). defined by ...|$|E
5000|$|The error term {{is still}} {{restricted}} {{to be of}} an AR(1) type. If [...] is not known, a <b>recursive</b> <b>procedure</b> {{may be used to}} make the estimation feasible. See Cochrane-Orcutt estimation.|$|E
5000|$|Some authors {{classify}} recursion {{as either}} [...] "structural" [...] or [...] "generative". The distinction {{is related to}} where a <b>recursive</b> <b>procedure</b> gets the data that it works on, and how it processes that data: ...|$|E
40|$|AbstractUsing a {{predicate}} transformer semantics of programs, we introduce statements for heap {{operations and}} separation logic operators for specifying programs that manipulate pointers. We prove a powerful Hoare total correctness rule for mutually <b>recursive</b> <b>procedures</b> manipulating pointers. The rule combines earlier proof rules for (mutually) <b>recursive</b> <b>procedures</b> with the frame rule for pointer programs. The theory, including the proofs, is {{implemented in the}} theorem prover PVS. In this implementation program variables and addresses can store values of almost any type of the theorem prover...|$|R
50|$|The {{two major}} {{paradigms}} for constructing semantic software systems were procedural and logical. The procedural paradigm was epitomized by Lisp et al. which featured <b>recursive</b> <b>procedures</b> that operated on list structures.|$|R
5000|$|The {{examples}} {{in this section}} illustrate {{what is known as}} [...] "structural recursion". This term refers {{to the fact that the}} <b>recursive</b> <b>procedures</b> are acting on data that is defined recursively.|$|R
50|$|A call graph (also {{known as}} a call multigraph) is a control flow graph, which {{represents}} calling relationships between subroutines in a computer program. Each node represents a procedure and each edge (f, g) indicates that procedure f calls procedure g. Thus, a cycle in the graph indicates <b>recursive</b> <b>procedure</b> calls.|$|E
50|$|As seen in {{the example}} above, the result of {{repeated}} applications of the above <b>recursive</b> <b>procedure</b> from steps 4 to 10 can be a wheel list which spans any desired sieving range (to which it can be truncated) and the resulting list then includes only the multiples of primes higher than one past the last used base primes.|$|E
50|$|In the two-integrator case, {{the upper}} single-integrator {{subsystem}} was stabilized yielding a new single-integrator {{system that can}} be similarly stabilized. This <b>recursive</b> <b>procedure</b> can be extended to handle any finite number of integrators. This claim can be formally proved with mathematical induction. Here, a stabilized multiple-integrator system is built up from subsystems of already-stabilized multiple-integrator subsystems.|$|E
5000|$|<b>Recursive</b> <b>procedures</b> can be {{combined}} with [...] and [...] statements to create parallel recursive processes. The following example shows how a pipeline of processes can be recursively defined using a [...] statement.|$|R
40|$|Abstract. Adaptation rules {{adapt the}} pre-post {{specification}} of a procedure to contexts {{where it is}} called. Such rules are important for practical reasons, and are necessary for completeness of proof systems for languages with <b>recursive</b> <b>procedures.</b> A sharp rule is one that gives the weakest precondition {{with respect to a}} given postcondition. A number of rules have been proposed for simple imperative languages with <b>recursive</b> <b>procedures,</b> most unsound or incomplete or non-sharp. Taking an algebraic approach, we clarify and extend the applicability of previously proposed sharp rules for total correctness, and show how further rules may be found...|$|R
40|$|AbstractAn {{extension}} of the inductive assertion method allowing one to prove the partial correctness of an attribute grammar w. r. t. a specification is presented. It is complete in an abstract sense. It is also shown that the semantics of systems of <b>recursive</b> imperative <b>procedures</b> or of <b>recursive</b> applicative <b>procedures</b> computed with call-by-value or call-by-name can be expressed by an attribute grammar associating attributes with the nodes of the so-called trees of calls. Hence the proof methods for the partial correctness of attribute grammars {{can be applied to}} these <b>recursive</b> <b>procedures.</b> We show also how the proof method can be applied in logic programming...|$|R
