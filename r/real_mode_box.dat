0|715|Public
50|$|In x86 computing, unreal <b>mode,</b> also big <b>real</b> <b>mode,</b> huge <b>real</b> <b>mode,</b> or flat <b>real</b> <b>mode,</b> is {{a variant}} of <b>real</b> <b>mode,</b> in which one or more data segment {{registers}} have been loaded with 32-bit addresses and limits. Contrary to its name, {{it is not a}} separate addressing mode that the x86 processors can operate in. It is used in the 80386 and later x86 processors.|$|R
5000|$|<b>Real</b> Address <b>mode,</b> {{commonly}} called <b>Real</b> <b>mode,</b> is an operating mode of 8086 and later x86-compatible CPUs. <b>Real</b> <b>mode</b> {{is characterized by}} a 20-bit segmented memory address space (meaning that only 1 MiB of memory can be addressed - actually, slightly more), direct software access to peripheral hardware, and no concept of memory protection or multitasking at the hardware level. All x86 CPUs in the 80286 series and later start up in <b>real</b> <b>mode</b> at power-on; 80186 CPUs and earlier had only one operational mode, which is equivalent to <b>real</b> <b>mode</b> in later chips. (On the IBM PC platform, direct software access to the IBM BIOS routines is available only in <b>real</b> <b>mode,</b> since BIOS is written for <b>real</b> <b>mode.</b> However, this is not a characteristic of the x86 CPU but of the IBM BIOS design.) ...|$|R
5000|$|<b>Real</b> <b>mode,</b> {{also called}} <b>real</b> address <b>mode,</b> is an {{operating}} mode of all x86-compatible CPUs. <b>Real</b> <b>mode</b> {{is characterized by}} a 20-bit segmented memory address space (giving exactly 1 MiB of addressable memory) and unlimited direct software access to all addressable memory, I/O addresses and peripheral hardware. <b>Real</b> <b>mode</b> provides no support for memory protection, multitasking, or code privilege levels.|$|R
5000|$|New {{virtualization}} capability: [...] "VMX Unrestricted mode support," [...] {{which allows}} 16-bit guests to run (<b>real</b> <b>mode</b> and big <b>real</b> <b>mode).</b>|$|R
50|$|Before {{the release}} of the 80286, which {{introduced}} protected <b>mode,</b> <b>real</b> <b>mode</b> was the only available mode for x86 CPUs; and for backward compatibility, all x86 CPUs start in <b>real</b> <b>mode</b> when reset, though it is possible to emulate <b>real</b> <b>mode</b> on other systems when starting on other modes.|$|R
5000|$|... x86 {{processors}} {{that support}} protected <b>mode</b> boot into <b>real</b> <b>mode</b> for backward compatibility {{with the older}} 8086 class of processors. Upon power-on (a.k.a. booting), the processor initializes in <b>real</b> <b>mode,</b> and then begins executing instructions. Operating system boot code, which might be stored in ROM, may place the processor into the protected mode to enable paging and other features. The instruction set in protected mode {{is similar to that}} used in <b>real</b> <b>mode.</b> However, certain constraints that apply to <b>real</b> <b>mode</b> (such as not being able to use ax,cx,dx in addressing) do not apply in protected mode. Conversely, segment arithmetic, a common practice in <b>real</b> <b>mode</b> code, is not allowed in protected mode.|$|R
50|$|Intel {{introduced}} {{protected mode}} into the x86 family {{with the intention}} that operating systems which used it would run entirely in the new mode and that all programs running under a protected mode operating system would run in protected mode as well. Because of the substantial differences between <b>real</b> <b>mode</b> and even the rather limited 286 protected mode, programs written for <b>real</b> <b>mode</b> cannot run in protected mode without being rewritten. Therefore, with a wide base of existing <b>real</b> <b>mode</b> applications which users depended on, abandoning <b>real</b> <b>mode</b> posed problems for the industry, and programmers sought a way to switch between the modes at will. However, Intel, consistent with their intentions for the processor's usage, provided {{an easy way to}} switch into protected mode on the 80286 but no easy way to switch back to <b>real</b> <b>mode.</b> Before the 386 the only way to switch from protected <b>mode</b> back to <b>real</b> <b>mode</b> was to reset the processor; after a reset it always starts up in <b>real</b> <b>mode</b> to be compatible with earlier x86 CPUs back to the 8086. Resetting the processor does not clear the system's RAM, so this, while awkward and inefficient, is actually feasible. From protected mode, the processor's state is saved in memory, then the processor is reset, restarts in <b>real</b> <b>mode,</b> and executes some <b>real</b> <b>mode</b> code to restore the saved state from memory. It can then run other <b>real</b> <b>mode</b> code until the program is ready to switch back to protected mode. The switch to <b>real</b> <b>mode</b> is costly in terms of time, but this technique allows protected mode programs to use services such as BIOS, which runs entirely in <b>real</b> <b>mode</b> (having been designed originally for the 8088-based IBM Personal Computer model (machine type) 5150). This mode-switching technique is also the one used by DPMI (under real, not emulated, DOS) and DOS extenders like DOS/4GW to allow protected mode programs to run under DOS; the DPMI system or DOS extender switches to <b>real</b> <b>mode</b> to invoke DOS or BIOS calls, then switches back to return to the application program which runs in protected mode.|$|R
50|$|On IBM PC-compatible computers, the {{bootstrapping}} firmware (contained {{within the}} ROM BIOS) loads and executes the master boot record. The PC/XT (type 5160) used an Intel 8088 microprocessor. In order to remain compatible, all x86 architecture systems {{start with the}} microprocessor in an operating mode referred to as <b>real</b> <b>mode.</b> The BIOS reads the MBR from the storage device into physical memory, and then it directs the microprocessor {{to the start of}} the boot code. Since the BIOS runs in <b>real</b> <b>mode,</b> the processor is in <b>real</b> <b>mode</b> when the MBR program begins to execute, and so the beginning of the MBR is expected to contain <b>real</b> <b>mode</b> machine language instructions.|$|R
5000|$|... 32-bit x86 {{processors}} {{themselves have}} two legacy modes: <b>real</b> <b>mode</b> and virtual 8086 <b>mode.</b> <b>Real</b> <b>mode</b> causes the processor to mostly {{act as if}} it was an original 8086, while virtual 8086 mode allows the creation of a virtual machine to allow the running of programs that require <b>real</b> <b>mode</b> in order to run under a protected mode environment. Protected mode is the non-legacy mode of 32-bit x86 processors and the 80286.|$|R
5000|$|Windows ME {{restricted}} {{support for}} <b>real</b> <b>mode</b> MS-DOS. As a result, [...] in Windows ME disregards , [...] and [...] and directly executes [...] In its default configuration {{the system would}} neither boot into an MS-DOS command prompt nor exit to DOS from Windows; <b>real</b> <b>mode</b> drivers such as [...] could not be loaded and older applications that require <b>real</b> <b>mode</b> could not be run. Microsoft argued that the change improved the speed and reliability of the boot process.|$|R
50|$|VM86 mode uses a {{segmentation}} scheme {{identical to}} that of <b>real</b> <b>mode</b> (for compatibility reasons) which creates 20-bit linear addresses {{in the same manner}} as 20-bit physical addresses are created in <b>real</b> <b>mode,</b> but are subject to protected mode's memory paging mechanism.|$|R
50|$|The Intel 80386 {{featured}} three operating modes: <b>real</b> <b>mode,</b> {{protected mode}} and virtual mode. The protected mode which debuted in the 80286 {{was extended to}} allow the 80386 to address up to 4 GB of memory, the all new virtual 8086 mode (VM86) {{made it possible to}} run one or more <b>real</b> <b>mode</b> programs in a protected environment which largely emulated <b>real</b> <b>mode,</b> though some programs were not compatible (typically as a result of memory addressing tricks or using unspecified op-codes).|$|R
5000|$|To put an 80386 {{or higher}} {{microprocessor}} into unreal mode, a program must first enter protected mode, find {{or create a}} flat descriptor in the GDT or LDT, load some of the data segment registers with the respective protected mode [...] "selector", and then switch back to <b>real</b> <b>mode.</b> After returning to <b>real</b> <b>mode,</b> the processor will continue using the cached descriptors as established in protected mode, thus allowing access to 4 GiB of [...] "extended" [...] memory from <b>real</b> <b>mode.</b>|$|R
50|$|<b>Real</b> <b>mode</b> {{primarily}} existed {{as a way}} to run Windows 2.x applications. It {{was removed}} in Windows 3.1x. Almost all applications designed for Windows 3.0 had to be run in standard or 386 enhanced modes. (Microsoft Word 1.x and Excel 2.x would work in <b>real</b> <b>mode</b> as they were actually designed for Windows 2.x). However, it was necessary to load Windows 3.0 in <b>real</b> <b>mode</b> to run SWAPFILE.EXE, which allowed users to change virtual memory settings. Officially, Microsoft stated that an 8Mhz turbo 8086 was the minimum CPU needed to run Windows 3.0. It could be run on 4.77 MHz 8088 machines, but performance is so slow as to render the OS almost unusable. Up to 4 MB of EMS memory is supported in <b>real</b> <b>mode.</b>|$|R
50|$|In the 80386 {{microprocessor}} and later, virtual 8086 mode (also called virtual <b>real</b> <b>mode,</b> V86-mode or VM86) {{allows the}} execution of <b>real</b> <b>mode</b> applications that are incapable of running directly in protected mode while the processor is running a protected mode operating system. It is a hardware virtualization technique that allowed multiple 8086 processors to be emulated by the 386 chip; it emerged from the painful experiences with the 80286 protected mode, which by itself was not suitable to run concurrent <b>real</b> <b>mode</b> applications well.|$|R
50|$|Starting {{with the}} 80386, <b>real</b> <b>mode</b> {{programs}} {{can use the}} 32 bit registers with the Operand Size Override Prefix. This allows programs to use an address like DS:EAX. In normal <b>real</b> <b>mode,</b> a fault occurs if EAX exceeds 0xFFFF. In unreal mode, the access is allowed.|$|R
50|$|The {{processor}} runs in <b>real</b> <b>mode</b> {{immediately after}} power on, so an operating system kernel, or other program, must explicitly switch to another mode if it wishes {{to run in}} anything but <b>real</b> <b>mode.</b> Switching modes is accomplished by modifying certain bits of the processor's control registers after some preparation, and some additional setup may be required after the switch.|$|R
50|$|Windows 95, Windows 98, and Windows Me use native, {{protected}} mode 32-bit disk drivers during normal operation. However Safe <b>Mode</b> uses MS-DOS <b>real</b> <b>mode</b> disk drivers instead. <b>Real</b> <b>mode</b> MS-DOS drivers {{could also be}} used during normal operation for disk peripherals for which Windows did not have native drivers.|$|R
40|$|A {{technique}} to extract <b>real</b> <b>modes</b> from the identified complex modes {{is presented in}} this paper, which enables the normalized <b>real</b> <b>mode</b> shapes, modal masses, and full or reduced mass and stiffness matrices to be obtained. The theoretical derivation of the method is provided in detail. An 11 -DOF vibration system is used to validate the algorithm, and to analyze {{the effects of the}} number of modes utilized and measurement DOFs on the extraction results. Finally, the method is used to extract <b>real</b> <b>modes</b> from both experimental modal analysis and operational modal analysis...|$|R
50|$|Operating {{systems like}} OS/2 1.x try to switch the {{processor}} between protected and <b>real</b> <b>modes.</b> This is both slow and unsafe, because a <b>real</b> <b>mode</b> program can easily crash a computer. OS/2 1.x defines restrictive programming rules allowing a Family API or bound program {{to run in}} either <b>real</b> or protected <b>mode.</b> Some early Unix operating systems, OS/2 1.x, and Windows used this mode.|$|R
50|$|Windows 3.0 {{was able}} to run <b>real</b> <b>mode</b> {{programs}} in 16-bit protected mode; when switching to protected mode, it decided to preserve the single privilege level model {{that was used in}} <b>real</b> <b>mode,</b> which is why Windows applications and DLLs can hook interrupts and do direct hardware access. That lasted through the Windows 9x series. If a Windows 1.x or 2.x program is written properly and avoids segment arithmetic, it will run the same way in both <b>real</b> and protected <b>modes.</b> Windows programs generally avoid segment arithmetic because Windows implements a software virtual memory scheme, moving program code and data in memory when programs are not running, so manipulating absolute addresses is dangerous; programs should only keep handles to memory blocks when not running. Starting an old program while Windows 3.0 is running in protected mode triggers a warning dialog, suggesting to either run Windows in <b>real</b> <b>mode</b> or to obtain an updated version of the application. Updating well-behaved programs using the MARK utility with the MEMORY parameter avoids this dialog. It is not possible to have some GUI programs running in 16-bit protected mode and other GUI programs running in <b>real</b> <b>mode.</b> In Windows 3.1, <b>real</b> <b>mode</b> was no longer supported and could not be accessed.|$|R
50|$|In reality, {{almost all}} DOS {{application}} programs violated these rules. Due to these limitations, virtual 8086 mode was introduced with the 386. Despite such potential setbacks, Windows 3.0 and its successors {{can take advantage}} of the binary compatibility with <b>real</b> <b>mode</b> to run many Windows 2.x (Windows 2.0 and Windows 2.1x) applications, which run in <b>real</b> <b>mode</b> in Windows 2.x, in protected mode.|$|R
5000|$|RMSIZE (OS/2 only, ignored under DR-DOS 7.02 and higher) : Defines the <b>real</b> <b>mode</b> memory size.|$|R
50|$|The 80386 {{featured}} three operating modes: <b>real</b> <b>mode,</b> {{protected mode}} and virtual mode. The protected mode which debuted in the 286 {{was extended to}} allow the 386 to address up to 4 GB of memory. The all new virtual 8086 mode (or VM86) {{made it possible to}} run one or more <b>real</b> <b>mode</b> programs in a protected environment, although some programs were not compatible.|$|R
5000|$|... 384 KB of free {{conventional}} memory (<b>real</b> <b>mode),</b> 1 MB (Standard Mode), or 2 MB (Enhanced Mode) ...|$|R
5000|$|<b>Real</b> <b>mode,</b> {{intended}} for older computers with a CPU below Intel 80286, and corresponding to its real mode; ...|$|R
5000|$|Windows 95 {{included}} a new graphical shell called Windows Explorer and supported long filenames (LFN). Symantec released Norton Commander 5.51 to support long filenames using the standard Windows APIs. In {{order to preserve}} LFNs while working in <b>real</b> <b>mode,</b> Norton Commander 5.51 required {{the use of a}} Terminate and Stay Resident (TSR) utility. Norton Commander did not have native support for LFNs in <b>real</b> <b>mode</b> and would truncate them.|$|R
50|$|BIOS {{interrupt}} {{calls are}} {{a facility that}} operating systems and application programs use to invoke the facilities of the Basic Input/Output System on IBM PC compatible computers. Traditionally, BIOS calls are mainly used by MS-DOS programs and some other software such as boot loaders (including, mostly historically, relatively simple application software that boots directly and runs without an operating system - especially game software.) BIOS only runs in the <b>real</b> address <b>mode</b> (<b>Real</b> <b>Mode)</b> of the x86 CPU, so programs that call BIOS either must also run in <b>real</b> <b>mode</b> or must switch from protected <b>mode</b> to <b>real</b> <b>mode</b> before calling BIOS and then switch back again. For this reason, modern operating systems that use the CPU in Protected Mode generally do not use the BIOS to support system functions, although some of them use the BIOS to probe and initialize hardware resources during their early stages of booting.|$|R
40|$|We have {{computed}} {{the black}} body radiation spectra in κ-Minkowski space-time, using the quantum mechanical picture of massless scalar particles as well as effective quantum field theory picture. The {{black body radiation}} depends on how the field theory (and thus how the κ-Poincaré algebra) handles the ordering effect of the noncommutative space-time. In addition, there exists a natural momentum cut-off of the order κ, beyond which a new <b>real</b> <b>mode</b> takes its shape from a complex mode and the old <b>real</b> <b>mode</b> flows {{out to be a}} new complex mode. However, the new high momentum <b>real</b> <b>mode</b> should not be physical since its contributions to the black-body radiation spoils the commutative limit. Comment: 22 pages, No figure, some corrections, to appear in Phys. Rev. ...|$|R
25|$|LOADALL – Undocumented 80286/80386 {{instruction}} {{that could be}} used to gain access to all available memory in <b>real</b> <b>mode.</b>|$|R
50|$|This was an {{embedded}} {{version of}} the 80386SX which did not support <b>real</b> <b>mode</b> and paging in the MMU.|$|R
5000|$|Protected mode banking: Allows {{access to}} the framebuffer from {{protected}} mode without [...] "thunking" [...] down to <b>real</b> <b>mode.</b>|$|R
5000|$|... #Caption: The high {{memory area}} is {{available}} in <b>real</b> <b>mode</b> on 80286 processors if the A20 gate is not disabled.|$|R
50|$|The {{most common}} problem by running 8086 code from {{protected}} mode is memory addressing which is totally different between protected <b>mode</b> and <b>real</b> mode.As mentioned, by working under VM86 mode the segmentation mechanism is reconfigured to work just like under <b>real</b> <b>mode,</b> but the paging mechanism is still active, {{and it is}} transparent to the <b>real</b> <b>mode</b> code; thus, memory protection is still applicable, {{and so is the}} isolation of the address space.|$|R
50|$|The 286 {{maintained}} {{backwards compatibility}} with its precursor the 8086 by initially entering <b>real</b> <b>mode</b> on power up. <b>Real</b> <b>mode</b> functioned virtually identically to the 8086, allowing {{the vast majority}} of existing 8086 software to run unmodified on the newer 286. <b>Real</b> <b>mode</b> also served as a more basic mode in which protected mode could be set up, solving a sort of chicken-and-egg problem. To access the extended functionality of the 286, the operating system would set up some tables in memory that controlled memory access in protected mode, set the addresses of those tables into some special registers of the processor, and then set the processor into protected mode. This enabled 24 bit addressing which allowed the processor to access 224 bytes of memory, equivalent to 16 megabytes.|$|R
50|$|A <b>real</b> <b>mode</b> pointer {{is defined}} as a 16-bit segment and a 16-bit offset into that segment. The segment is {{expanded}} internally by the processor to 20 bits by shifting it 4 bits to the left, thus limiting <b>real</b> <b>mode</b> interrupt handlers to the first 1 megabyte of memory. The first 32 vectors are reserved for the processor's internal exceptions, and hardware interrupts may be mapped to any of the vectors by way of a programmable interrupt controller.|$|R
