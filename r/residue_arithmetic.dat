69|34|Public
40|$|Numerous {{architectures}} {{have been}} recently proposed for <b>residue</b> <b>arithmetic</b> components, {{each with its}} own speed, area and power consumption characteristics. In this paper, we present KoVer, a novel software tool that gives a designer the opportunity to explore several archi-tectures for implementing his <b>residue</b> <b>arithmetic</b> blocks, select the one that best suits his goals and instantly get the HDL level description of the selected architecture. 1...|$|E
40|$|Optical {{addition}} {{and storage}} units {{are described in}} this paper. These units are implemented using the Hughes Liquid Crystal Light Valve (LCLV) as a spatial light modulator using <b>residue</b> <b>arithmetic</b> for a numerical representation. The main hardware components of the design, besides the light valve, include an array of single-mode optical fibers that provide input information, a polarizing prism in combination with quarter-wave and half-wave retarders for <b>residue</b> <b>arithmetic</b> implementation in the adder, and a holographic array for spatial stability in the storage unit...|$|E
40|$|The {{objective}} of this thesis is to investigate the applicability of Field Programmable Gate Arrays (FPGAs) for <b>residue</b> <b>arithmetic</b> applications. FPGAs are programmable devices that can be directly configured by the end user {{without the use of}} an integrated circuit fabrication facility. They offer the designer the benefits of custom hardware, eliminating high development costs and manufacturing time. The Residue Number System (RNS) has often been proposed for custom hardware implementation of high throughput DSP algorithms. <b>Residue</b> <b>arithmetic</b> operations are easier to realize using small look-up tables, and since Xilinx FPGAs use look-up tables as configurable logic blocks, they are considered as an ideal choice for RNS based designs. Proper design techniques and effective logic optimization are the key to efficient FPGA implementation. Therefore this thesis proposes a new logic optimization algorithm for FPGA realization of <b>residue</b> <b>arithmetic</b> applications. The algorithm exploits the inherent redundancy present in representing finite rings operations using binary variables. The algorithm uses Binary Decision Diagrams to represent and manipulate logic functions. <b>Residue</b> <b>arithmetic</b> modules encoders, decoder/scalers are implemented in Xilinx FPGA with and without using the logic optimization algorithm. Comparison of results proves the effectiveness of the algorithm. The above modules are simulated and tested. Dept. of Electrical and Computer Engineering. Paper copy at Leddy Library: Theses 2 ̆ 6 Major Papers - Basement, West Bldg. / Call Number: Thesis 1994. V 46. Source: Masters Abstracts International, Volume: 34 - 02, page: 0839. Adviser: Graham A. Jullien. Thesis (M. A. Sc.) [...] University of Windsor (Canada), 1995...|$|E
40|$|Abstract—In this paper, a <b>residue</b> number <b>arithmetic</b> is used {{in direct}} {{sequence}} spread spectrum system, this system is evaluated and the bit error probability of this system is {{compared to that of}} non residue number system. The effect of channel bandwidth, PN sequences, multipath effect and modulation scheme are studied. A Matlab program is developed to measure the signal-to-noise ratio (SNR), and the bit error probability for the various schemes...|$|R
40|$|Abstract:- In this paper, the {{performance}} of image encryption using conventional pseudo random code generators as maximum length, gold code generators are analyzed and compared to that using chaotic sequence generator. Applicability {{of different types of}} generators is studied by examining their autocorrelation, cross-correlation performance, measuring the histogram of the spreaded image and the bit error probability for the received data in a communication system. A <b>residue</b> number <b>arithmetic</b> is added to the system; this system is evaluated and compared to that of non residue number system and measuring its performance...|$|R
40|$|An {{important}} {{problem in}} real-time DSP (digital signal-processing) systems with highly integrated components is {{the capability of}} automatic error detection and correction. The use of <b>residue</b> number <b>arithmetic</b> allows error detection and correction because of its unweighted nature. A single-error-correction procedure is proposed {{which is based on}} the use of redundant residue number systems (RRNS) and the base extension operation. The proposed method uses a small decision table and works in parallel mode; therefore it is suitable for high-speed VLSI circuit realization. A parallel architecture which realizes the method is also introduce...|$|R
40|$|Graduation date: 1966 The {{application}} of residue notation is another approach for {{solving the problem}} of carry propagation in arithmetic units. Most other methods for solving this problem are based on changes in adder design {{and the use of}} improved components. <b>Residue</b> <b>arithmetic</b> has the inherent property of requiring no carries between moduli. This results in <b>residue</b> <b>arithmetic</b> requiring {{only a fraction of the}} carries necessary with conventional weighted arithmetic. The basic operations of addition, subtraction, multiplication, and division are incorporated in the design of a 41 -bit <b>residue</b> <b>arithmetic</b> unit. Using only four moduli, addition and subtraction can be accomplished four times faster than conventional addition and subtraction using synchronous accumulators without carry-look-ahead techniques. Multiplication can be accomplished approximately sixteen times faster. In some cases, division is accomplished faster than conventional non-restoring division, On the average, however, residue division takes longer to accomplish than non-restoring conventional division. Detection of overflow in addition, subtraction, and multiplication is based on a slightly different approach for representing signed numbers. Monitoring multiplicative overflow after every multiplication reduces the speed of residue multiplication from sixteen to approximately twelve times faster than conventional multiplication...|$|E
40|$|In {{this paper}} it is shown that by {{suitably}} modifying Garner's algorithm for applying the Chinese Remainder Theorem to optimally employ the fast multiplication techniques of Schonhage and Strassen, one can often decrease the computing time of algebraic algorithms employing modular (congruence, <b>residue)</b> <b>arithmetic...</b>|$|E
40|$|AbstractUsing <b>residue</b> <b>arithmetic</b> and number-theoretic transforms, new {{algorithms}} of the one- and two-dimensional deconvolution are described. These algorithms {{work without}} round-off errors and yield the exact solution under natural conditions. By the same method, the exact {{value of the}} determinant of a circulant integer matrix is computed, too...|$|E
40|$|<b>Residue</b> number <b>arithmetic</b> is {{characterized}} by a non-weighted number system, where long integer numbers are split into several smaller numbers with restricted numerical range. This allows the computation of long words by several smaller words, which use almost identical circuits in a parallel structure. However, the non-weighted number representation complicates sign detection, the comparison of numbers and the division operation. In this work, circuits are presented to realize sign detection, a comparison of numbers and a division with fixed values. Furthermore, circuits implementing FFT, error correction and number system conversion are shown. The concepts are based on parametrical circuit elements for residue number systems like ABIP, HYBIP and IPSP. The complexity of these three elements is analyzed for a word length in the range of 2 to 7. To carry out an automated system implementation based on circuit structures of <b>residue</b> number <b>arithmetic,</b> a synthesis tool is created. This hardware compiler can be used through a command line or a graphical user interface. The hardware compiler makes complex circuit structures available in parametrical form. Using parameterized modules for the circuit description allows for designs to be easily reused, which allows for more complex circuits. The hardware compiler can simulate and create a VHDL netlist of a circuit. In this manner a link to other synthesis tools is available...|$|R
40|$|International audienceThis {{paper is}} {{a survey of}} Montgomery {{reduction}} {{in the context of}} <b>residue</b> number system <b>arithmetic.</b> We present the main variants of RNS Montgomery reduction, some efficient embedded hardware implementations, applications in asymmetric cryptography (RSA, ECC, pairing, lattices), to end with the use of RNS against side-channel analysis and fault attacks...|$|R
40|$|We {{develop a}} theory of <b>residues</b> for <b>arithmetic</b> surfaces, {{establish}} the reciprocity law around a point, and use the residue maps to explicitly construct the dualizing sheaf of the surface. These are generalisations of known results for surfaces over a perfect field. In an appendix, explicit local ramification theory is used to recover {{the fact that in}} the case of a local complete intersection the dualizing and canonical sheaves coincide. Comment: This is an update and correction to an earlier version of the paper, entitled "An explicit approach to residues on and canonical sheaves of arithmetic surfaces"; an erroneous lemma (lemma 5. 4) in the earlier version necessitated restructuring of the paper, though the main results are largely unchange...|$|R
40|$|We {{present a}} new RNS modular {{multiplication}} for very large operands. The algorithm {{is based on}} Montgomery's method adapted to <b>residue</b> <b>arithmetic.</b> By choosing the moduli of the RNS system reasonably large, an eect corresponding to a redundant high-radix implementation is achieved, due to the carry-free nature of <b>residue</b> <b>arithmetic.</b> The actual computation in the multiplication takes place in constant time, where the unit of time is a few simple residue operations. However, it is necessary twice to convert values from one residue system into another, operations which take O(n) time on O(n) processors, where n {{is the number of}} moduli in the RNS systems. Thus these conversions are the bottlenecks of the method, and any future improvements in RNS base conversions, or the use of particular residue systems, can immediately be applied...|$|E
40|$|Introduction and summary: Hardware {{capabilities}} for integer arithmetic generally include addition, multiplication, {{and division}} with precision k typically chosen as 16, 32 or 64. Multiplication and division are often implemented by recursive bit serial algorithms employing O(k) serial additions {{to avoid the}} size and power requirements of a large multiplier. The integer addition and multiplication operations realised are effectively `exact' <b>residue</b> <b>arithmetic</b> operations with modulo 2. Hardware support for applications where fast <b>residue</b> <b>arithmetic</b> computation is desirable is typically limited to only residue addition and multiplication. There {{is a need to}} find efficiently implementable algorithms for other fundamental residue operations for the `hardware friendly' modulus 2. Furthermore, for implementations where hardware support does not include a large multiplier, there is a particular need for additive bit-serial algorithms for these additional residue operations. The fund...|$|E
40|$|International audienceWe {{present a}} new RNS modular {{multiplication}} for very large operands. The algorithm {{is based on}} Montgomery's (1985) method adapted to <b>residue</b> <b>arithmetic.</b> By choosing the moduli of the RNS system reasonably large, an effect corresponding to a redundant high-radix implementation is achieved, due to the carry-free nature of <b>residue</b> <b>arithmetic.</b> The actual computation in the multiplication takes place in constant time, where the unit of time is a few simple residue operations. However, it is necessary twice to convert values from one residue system into another, operations which take O(n) time on O(n) processors, where n {{is the number of}} moduli in the RNS systems. Thus these conversions are the bottlenecks of the method, and any future improvements in RNS base conversions, or the use of particular residue systems, can immediately be applied...|$|E
40|$|International audienceWith {{the rapid}} size {{shrinking}} in electronic devices,radiation-induced soft-error {{has emerged as}} a major concern to the current circuit manufacturing. In this paper, we present a new error correction scheme based on the <b>residue</b> number <b>arithmetic</b> to cope with the single soft-error issue. The proposed technique called bidirectional redundant residue number system requires the redundant moduli to satisfy some constraints to achieve fast error correction. In this system, both the iterations for decoding the valid number and the error-correcting table that contains all combinations of erroneous digit, are not necessary. The detection and the diagnosis are simultaneously performed in plural parallel consistent-checking that has the capability of locating the corrupt digit. Finally, efficient pipeline architecture for the self-diagnosis decoder is detailed...|$|R
40|$|AbstractIn residue number systems many {{arithmetic}} operations, like addition and multiplication, {{can be done}} {{in constant}} time. But, among others, division is more complex. This paper introduces a division algorithm which is in its complexity comparable to the conventional integer division algorithm. The algorithm exhibits nice properties, especially for long integer arithmetic as it does not involve numbers with many significant digits, and is thus superior to comparable algorithms published recently. The algorithm copes well with parallel implementations of <b>residue</b> number systems' <b>arithmetic...</b>|$|R
40|$|Abstract—In this work, {{we propose}} a new {{algorithm}} for designing diminished- 1 modulo 2 n þ 1 multipliers. The {{implementation of the}} proposed algorithm requires n þ 3 partial products that are reduced by a tree architecture into two summands, which are finally added by a diminished- 1 modulo 2 n þ 1 adder. The proposed multipliers, compared to existing implementations, offer enhanced operation speed and their regular structure allows efficient VLSI implementations. Index Terms—Modulo 2 n þ 1 multipliers, computer <b>arithmetic,</b> <b>residue</b> number system, Fermat number transform, VLSI design...|$|R
40|$|A {{symmetric}} solution X {{satisfying the}} matrix equation XA = AtX {{is called a}} symmetrizer of the matrix A. A general algorithm to compute a matrix symmetrizer is obtained. A new multiple-modulus <b>residue</b> <b>arithmetic</b> called floating-point modular arithmetic is described and implemented on the algorithm to compute an error-free matrix symmetrizer...|$|E
40|$|In this paper, we derive a new {{computational}} algorithm for Barrett {{technique for}} modular polynomial multiplication, termed BA-P. BA-P is then {{applied to a}} new <b>residue</b> <b>arithmetic</b> based Barrett algorithm for modular polynomial multiplication (BA-MPM). The focus {{of the work is}} an algorithm that carries out the entire computation using only modular arithmetic without conversion to large degree polynomials. There are several parts to this work. First, we set up a new BA-P using polynomials other than u^alfa. Second, <b>residue</b> <b>arithmetic</b> based BA-MPM is described. A complete mathematical framework is described including proofs of the steps in the computations and the validity of results. Third, we present a computational procedure for BA-MPM. Fourth, the BA-MPM is used as a basis for algorithms for modular polynomial exponentiation (MPE). Applications are in areas of signal security and cryptography. Comment: 27 page...|$|E
40|$|The {{design and}} {{implementation}} of a digital (numerical) optical matrix-vector multiplier are presented. A Hughes liquid crystal light valve, the <b>residue</b> <b>arithmetic</b> representation, and a holographic optical memory are used to construct position coded optical look-up tables. All operations are performed in effectively one light valve response time with a potential for a high information density...|$|E
40|$|Abstract — A new modulo 2 k + 1 squarer {{architecture}} is proposed for operands {{in the normal}} representation. The novel {{architecture is}} derived by showing that all required correction factors can be merged into a single constant one and by treating this, partly as a partial product and partly by the final parallel adder. The proposed architecture utilizes a total of d k 2 e+ 1 partial products, each k bits wide and is built using an inverted end-around-carry, carry-save adder tree and a final parallel adder. Index Terms — Computer <b>arithmetic,</b> <b>residue</b> / modulo arith-metic, residue number system, modulo squarers. I...|$|R
40|$|Abstract – In this paper, the {{approach}} to the verification of current-mode circuits operating in the multiple-valued logics or <b>residue</b> number system <b>arithmetic,</b> and destined for the implementation in the reconfigurable devices is proposed. These circuits {{are based on the}} new type of elementary gates – the CMOS current-mode gates, and are characterized by lower hardware overheads in comparison with their functional prototypes, which consist of classical CMOS gates. The proposed approach is based on VHDL description of target circuits and uses the VHDL simulator Active-HDL, in which the new resolution table and the library of the current-mode elementary cells are included...|$|R
40|$|In {{this paper}} a new four-moduli set for even n is {{presented}} that has 4 n-bit dynamic range and contains wellformed moduli {{which makes it}} suitable for using in <b>residue</b> number system <b>arithmetic</b> unit. An efficient two-level reverse converter based on Chinese Remainder Theorem and Mixed Radix Conversion is designed. Hardware implementation of the reverse converter is mainly based on modulo adders and carry save adders. This proposed reverse converter is efficient in terms of area and delay in comparison with previously introduced four-moduli sets that has the same dynamic range with our proposed moduli set...|$|R
40|$|Introduction and background: The basic integer {{arithmetic}} {{operations of}} addition=subtraction, multiplication and division are implemented typically in hardware using k bits of precision with k usually 16, 32, or 64, {{and up to}} 1024 {{in the case of}} cryptography. Having a precision limited to k bits makes the arithmetic operations equivalent to their corresponding <b>residue</b> <b>arithmetic</b> modulo 2 operations along with appropriate overflow handling. When the hardware support does not include a large multiplier, there is a particular need for additive bit-serial algorithms for these and additional residue operations. In this Letter we present a bit-serial algorithm for the fundamental <b>residue</b> <b>arithmetic</b> operation of powering (or exponentiation). Following [1] we herein employ jnj j to denote the congruence relation n j (mod 2) with the residue j satisfying 0 1. When computing the exponentiation operation b (mod 2) of a basis b (our preferred case is b 3), usually some v...|$|E
40|$|AbstractAn {{algorithm}} is described for the exact computation of the coefficients of the {{characteristic polynomial of}} a matrix using <b>residue</b> <b>arithmetic.</b> The {{algorithm is}} in two phases. The first phase reduces the matrix to a Hessenberg form, and the second phase computes the coefficients using a recursive formula. Criteria for selecting the prime and computing the common denominator are described...|$|E
40|$|AbstractThe paper {{develops}} a method from which algorithms {{can be constructed}} to numerically compute an error-free reflexive generalized inverse of a matrix having rational entries. Multiple-modulus <b>residue</b> <b>arithmetic</b> is used to avoid error that is inherent in floating-point arithmetic. Some properties of finite fields of characteristic p, GF(p), are used to find nonsingular minors of the matrix over the field of rational numbers...|$|E
40|$|AbstractConstant folding is a {{well-known}} optimization of compilers which evaluates constant expressions already at compile time. Constant folding is valid only if the results computed by the compiler {{are exactly the same}} as the results which would be computed at run-time by the target machine arithmetic. We classify different arithmetics by deriving a general condition under which a target-machine arithmetic can be replaced by a compiler arithmetic. Furthermore, we consider integer arithmetics as a special case. They can be described by residue class arithmetics. We show that these arithmetics form a lattice. Using the order relation in this lattice, we establish a necessary and sufficient criterion under which constant folding can be done in a <b>residue</b> class <b>arithmetic</b> that is different from the one of the target machine. Concerning formal verification, we have formalized our proofs in the Isabelle/HOL system. As examples, we discuss the Java and C integer arithmetics and show which compiler arithmetics are valid for constant folding. This discussion reveals also potential sources of incorrect behavior of C compilers...|$|R
40|$|In {{this paper}} {{the design of}} a FIR filter with self {{checking}} capabilities based on the residue checking is analyzed. Usually the set of residues used to check the consistency {{of the results of the}} FIR filter are based of theoretic considerations about the dynamic range available with a chosen set of <b>residues,</b> the <b>arithmetic</b> characteristics of the errors caused by a fault and on the characteristic of the filter implementation. This analysis is often difficult to perform and, to obtain an acceptable fault coverage the set of chosen residues is overestimated. obtained result a and therefore requires that Instead, in this paper we show how using an exhaustive fault injection campaigns allows to efficiently select the best set of residues. Experimental results coming from fault injection campaigns on a 16 taps FIR filter demonstrated that by observing the occurred errors and the detection modules corresponding to different residue has been possible to reduce the number of detection module, while paying a small reduction of the percentage of SEUs that can be detected. I...|$|R
40|$|We {{present a}} scheme for robust multi-precision {{arithmetic}} over the positive integers, {{protected by a}} novel family of non-linear <b>arithmetic</b> <b>residue</b> codes. These codes {{have a very high}} probability of detecting arbitrary errors of any weight. Our scheme lends itself well for straightforward implementation of standard modular multiplication techniques, i. e. Montgomery or Barrett Multiplication, secure against active fault injection attacks. Due to the non-linearity of the code the probability of successfully injecting an error does not depend on the error pattern itself, but also on the data, which is not known to the adversary a priori. We give a proof of the robustness of these codes by providing an upper bound on the number of undetectable errors. ...|$|R
40|$|The use of correlators {{to detect}} pseudo random number {{sequences}} is widespread, and {{forms the basis}} of pervasive technologies such as GPS. The correlation function is subject to a trade-off between hardware cost and speed. In this paper we present a <b>residue</b> <b>arithmetic</b> based technique that can create a pseudo random number sequence correlator that has both low hardware cost and high speed...|$|E
40|$|Preface Design Process and Technology Theory {{of logic}} design Analysis and {{synthesis}} Implementation technologies Predictable technologies Contemporary CAD of logic networks Number Systems Positional numbers Counting in a positional number system Basic arithmetic operations in various number systems Binary arithmetic Radix-complement representations Techniques for conversion of numbers in various radices Overflow <b>Residue</b> <b>arithmetic</b> Other binary codes Redundancy and reliability Graphical Data Structures Graphs in discrete devices and systems design Basic definitions...|$|E
40|$|ORNS is a {{redundant}} Number System employing <b>residue</b> <b>arithmetic.</b> In {{contrast to}} the implementation of arithmetic by binary or multiple-valued logic circuits, arithmetic operations in this novel number system are performed by analog digit manipulation circuitry. The redundancy in an ensemble of Continuous Valued Digits that comprises a number provides tolerance to implementation imprecisions. Processing with these analog digits is performed by carry-free arithmetic structures with systematic circuit level redundancy. 1...|$|E
40|$|Conference Name: 2012 IEEE 18 th International On-Line Testing Symposium, IOLTS 2012. Conference Address: Sitges, Spain. Time:June 27, 2012 - June 29, 2012. IEEE Computer Society Test Technology Technical Council (TTTC) Relative to the Triple Modular Redundancy (TMR) scheme, the <b>arithmetic</b> <b>residue</b> codes based {{fault-tolerant}} DSP design consumes {{much less}} resources. However, {{the price for}} the low resource consumption is the fault missing problem. The basic tradeoff is that, smaller modulus used for the fault checking consumes fewer resources, but the fault missing rate is higher. The relationship between the value of modulus and the fault missing rate is analyzed theoretically in this paper for fault-tolerant FIR filter design, {{and the results are}} verified by FPGA implemented fault injections. 漏 2012 IEEE...|$|R
40|$|Abstract. We {{present a}} scheme for robust multi-precision {{arithmetic}} over the positive integers, {{protected by a}} novel family of non-linear <b>arithmetic</b> <b>residue</b> codes. These codes {{have a very high}} probability of detecting arbitrary errors of any weight. Our scheme lends itself well for straightforward implementation of standard modular multiplication techniques, i. e. Montgomery or Barrett Multiplication, secure against active fault injection attacks. Due to the non-linearity of the code the probability of detecting an error does not only depend on the error pattern, but also on the data. Since the latter is not usually known to the adversary a priori, a successful injection of an undetected error is highly unlikely. We give a proof of the robustness of these codes by providing an upper bound on the number of undetectable errors...|$|R
40|$|Hybrid Number systems (HNS 2 ̆ 7 s) {{represent}} a natural generalization of weighted and residue number systems. In HNS 2 ̆ 7 s, an integer {{is represented by}} using both weighted and <b>residue</b> notations; their <b>arithmetic</b> properties, wich have been investigated in depth, are strongly dependent on {{the ratio of the}} residue to weighted range of the representation. It is immediate that the ability of varying the residue-to-weighted-range ratio should enable to optimize the arithmetic performances of these systems. This paper shows that adding flexibility to hybrid systems is very simple and is equivalent to perform a number system conversion. A general procedure is proposed whose complexity is the same of the well known mixed radix converting algorithm. A VLSI architecture is presented and its area-time performances are evaluated according to VLSI theory assumptions...|$|R
