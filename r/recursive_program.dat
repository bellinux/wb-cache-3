147|616|Public
5000|$|... "The {{power of}} {{recursion}} evidently {{lies in the}} possibility of defining an infinite set of objects by a finite statement. In the same manner, an infinite number of computations can be described by a finite <b>recursive</b> <b>program,</b> even if this program contains no explicit repetitions." ...|$|E
50|$|Because of the {{similarity}} of loops and recursive programs, proving partial correctness of loops with invariants {{is very similar to}} proving correctness of recursive programs via induction. In fact, the loop invariant is often the same as the inductive hypothesis to be proved for a <b>recursive</b> <b>program</b> equivalent to a given loop.|$|E
50|$|The <b>recursive</b> <b>program</b> {{above is}} tail-recursive; it is {{equivalent}} to an iterative algorithm, and the computation shown above shows the steps of evaluation that would be performed by a language that eliminates tail calls. Below is {{a version of the}} same algorithm using explicit iteration, suitable for a language that does not eliminate tail calls. By maintaining its state entirely in the variables x and y and using a looping construct, the program avoids making recursive calls and growing the call stack.|$|E
40|$|The {{composition}} and decomposition of datalog program mappings are investigated {{for the purpose}} of optimization. Composability is studied using an algebraic axiom system. Also considered are (i) the decomposability of a subclass of linear <b>recursive</b> <b>programs</b> into single-rule programs; (ii) the structure of the class of prime programs; and the factorizability of bounded <b>recursive</b> <b>programs</b> into single-rule primes...|$|R
40|$|Abstract This paper {{presents}} a type-based analysis for inferring size-and cost-equations for recursive, higher-order and polymorphic func-tional programs without requiring user annotations or unusual syntax. Our type reconstruction algorithm {{is capable of}} inferring cost equations for a subset of <b>recursive</b> <b>programs</b> whose costs can be expressed using primitive recursion. We illustrate the approach with reference to some standard examples of <b>recursive</b> <b>programs.</b> ...|$|R
40|$|Abstract. Analysis of <b>recursive</b> <b>programs</b> in the {{presence}} of concurrency and shared memory is undecidable. In previous work, Qadeer and Rehof [23] showed that context-bounded analysis is decidable for <b>recursive</b> <b>programs</b> under a finite-state abstraction of program data. In this paper, we show that context-bounded analysis is decidable for certain families of infinite-state abstractions, and also provide a new symbolic algorithm for the finite-state case. ...|$|R
50|$|Research on the {{inductive}} {{synthesis of}} recursive functional programs {{started in the}} early 1970s and was brought onto firm theoretical foundations with the seminal THESIS system of Summers and work of Biermann.These approaches were split into two phases: first, input-output examples are transformed into non-recursive programs (traces) using a small set of basic operators; second, regularities in the traces are searched for and used to fold them into a <b>recursive</b> <b>program.</b> The main results until the mid 1980s are surveyed by Smith. Due to limited progress {{with respect to the}} range of programs that could be synthesized, research activities decreased significantly in the next decade.|$|E
40|$|Let h be any rapidly {{increasing}} function recursive in the halting problem. One {{can find a}} double <b>recursive</b> <b>program</b> of size n for a zero—one valued function of finite support whose smallest primitive <b>recursive</b> <b>program</b> is larger than h(n). One can find a general <b>recursive</b> <b>program</b> of size n for a zero—one valued function of finite support such that any general <b>recursive</b> <b>program</b> of size at most h(n) for the function runs extremely slowly on all large arguments...|$|E
40|$|Linearization of {{nonlinear}} recursive {{programs is}} an important issue in logic databases for both practical and theoretical reasons. If a nonlinear <b>recursive</b> <b>program</b> can be transformed into an equivalent linear <b>recursive</b> <b>program,</b> then it may be computed more efficiently than when the transformation is not possible. We provide a set of necessary and sufficient conditions for a simple doubly <b>recursive</b> <b>program</b> to be equivalent to a simple linear <b>recursive</b> <b>program.</b> The necessary and sufficient conditions can be verified effectively...|$|E
40|$|International audienceWe {{show how}} {{monotone}} interpretations – a termination analysis technique for term rewritingsystems – {{can be used}} to assess the inherent parallelism of <b>recursive</b> <b>programs</b> manipulatinginductive data structures. As a side effect, we show how monotone interpretations specify aparallel execution order, and how our approach extends naturally affine scheduling – a powerfulanalysis used in parallelising compilers – to <b>recursive</b> <b>programs.</b> This work opens new perspectivesin automatic parallelisation...|$|R
40|$|Abstract. We {{present a}} method for verifying <b>recursive</b> {{functional}} <b>programs.</b> We define a Verification Condition Generator (VCG) which covers the most frequent types of <b>recursive</b> <b>programs.</b> These programs may operate on arbitrary domains. Soundness and Completeness of the VCG are proven on the meta level, and this provides a warranty that any system based on our results will be sound. ...|$|R
50|$|Note the {{connection}} with denotational semantics, where the denotations of <b>recursive</b> <b>programs</b> is built up corecursively in this way.|$|R
40|$|We {{provide a}} {{transformation}} strategy for primitive <b>recursive</b> <b>program</b> schemes {{which is based}} on the three transformation relations splitting, sharing, and tupling, and which is provably semantic preserving. The transformation strategy works "without eureka". We can prove that there are infinitely many nontrivial primitive <b>recursive</b> <b>program</b> schemes for which the resulting <b>recursive</b> <b>program</b> scheme is strictly more efficient than the original one...|$|E
40|$|In {{this paper}} we present an {{approach}} to the induction of recursive structures from examples {{which is based on}} the notion of <b>recursive</b> <b>program</b> schemes. We separate induction from examples in two stages: (1) constructing initial programs from examples and (2) folding initial programs to <b>recursive</b> <b>program</b> schemes. By this separation, the induction of <b>recursive</b> <b>program</b> schemes can be reduced to a pattern-matching problem which can be handled by a generic algorithm. Construction of initial programs is performed with {{an approach to}} universal planning. "Background knowledge" is given in the form of operators and their conditions of application. Furthermore synthesizing <b>recursive</b> <b>program</b> schemes instead of programs in a predefined programming language enables us to combine program synthesis and analogical reasoning. A <b>recursive</b> <b>program</b> scheme represents the class of structural identical programs and can be assigned different semantics by interpretation. We believe that our appr [...] ...|$|E
40|$|A tail <b>{{recursive}}</b> <b>program</b> (with {{a single}} recursive call per case) {{is derived from}} a generic <b>recursive</b> <b>program</b> with two independent recursive calls, under no algebraic hypothesis whatsoever. The iterative version, fully verified, is immediate. The derivation is generalized to cover also nested and multiple recursion...|$|E
40|$|We {{propose a}} program {{analysis}} method for proving termination of <b>recursive</b> <b>programs.</b> The analysis {{is based on}} a reduction of termination to two separate problems: reachability of <b>recursive</b> <b>programs,</b> and termination of non-recursive programs. Our reduction works through a program transformation that modifies the call sites and removes return edges. In the new, non-recursive program, a procedure call may nondeterministically enter the procedure body (which means that it will never return) or apply a summary statement...|$|R
2500|$|Tower of Hanoi {{is often}} used to {{introduce}} <b>recursive</b> <b>programming</b> in computer science. This implementation uses Perl 6's multi-dispatch mechanism and parametric constraints: ...|$|R
40|$|This paper {{describes}} a formalization of the weakest precondition, wp, for general <b>recursive</b> <b>programs</b> using the type-theoretical proof assistant Coq. The formalization {{is a deep}} embedding using the computational power intrinsic to type theory. Since Coq accepts only structural recursive functions, the computational embedding of general <b>recursive</b> <b>programs</b> is non-trivial. To justify the embedding, an operational semantics is defined and the equivalence between wp and the operational semantics is proved. Three major healthiness conditions, namely: Strictness, Monotonicity and Conjunctivity are proved as well...|$|R
40|$|It is {{proved that}} a <b>recursive</b> <b>program</b> (without counters) {{is able to}} enumerate all {{elements}} in any Herbrand interpretation. It follows that all <b>recursive</b> <b>program</b> domains in a Herbrand interpretation can be defined by first-order formulas iff there are first-order formulas expressing integer arithmetic in that interpretation...|$|E
40|$|AbstractThis is a {{corrigendum}} for our paper [S. Milius, L. S. Moss, The category theoretic {{solution of}} <b>recursive</b> <b>program</b> schemes, Theoret. Comput. Sci. 366 (2006) 3 – 59]. The main results are correct, but we offer some {{changes to the}} definitions and proofs concerning interpreted <b>recursive</b> <b>program</b> schemes...|$|E
40|$|Abstract—Genetic {{programming}} {{has proven}} capable of evolving solutions {{to a wide}} variety of problems. However, the successes have largely been with programs without iteration or recursion; evolving recursive programs has turned out to be particularly challenging. The main obstacle to evolving recursive programs seems to be that they are particularly fragile to the application of search operators: a small change in a correct <b>recursive</b> <b>program</b> generally produces a completely wrong program. In this paper, we present a simple and general method that allows us to pass back and forth from a <b>recursive</b> <b>program</b> to an associated nonrecursive program. Finding a <b>recursive</b> <b>program</b> can be reduced to evolving non-recursive programs followed by converting the optimum non-recursive program found to the associated optimum <b>recursive</b> <b>program.</b> This avoids the fragility problem above, as evolution does not search the space of recursive programs. We present promising experimental results on a test-bed of recursive problems. I...|$|E
40|$|A {{mathematical}} programming problem is called <b>recursive</b> <b>programming</b> with monotonicity if both objective and constraint functions are recursive functions with monotonicity, i. e., either with nondecreasingness or with nonincreasingness (defined in Section 2) [12]. Thus <b>recursive</b> <b>programming</b> includes dynamic programming. This paper, {{viewed as a}} sequel to the previous one [9], studies systematically inequalities {{from the viewpoint of}} <b>recursive</b> <b>programming</b> with monotonicity. The theory of <b>recursive</b> <b>programming</b> is based upon two principles: the Bellman 2 ̆ 7 s Principle of Optimality and the Second Principle of Optimality. It is well known that the former is valid for the case when objective function is a recursive function with nondecreasingness, i. e., for dynamic programming [2, 14, 15]. On the other hand, it is shown that the latter is valid for the case when objective function is a recursive function with nonincreasingness [13; 15, p. 44]. However, both recursive and dynamic programmings are same in their spirits. We obtain inequalities between two recursive functions with strict monotonicity by direct applications of <b>recursive</b> <b>programming</b> like as we have done ones between two recursive functions with strict increasingness by applica tions of dynamic programming [9]. In Section 2 we consider six pairs of main and inverse problems with N -variable recursive functions with strict monotonicity and characterize them in terms of optimal-value function and optimal-point function. As corollaries inequalities between such recursive functions are established. Similar results for 2 -variable problems not belonging to above N -variable problems are obtained in Section 3. In Section 4 we give a <b>recursive</b> <b>programming</b> method to calculate a pair of optimal-value function and optimal-point function of the underlying problem. The method are based upon either the Bellman 2 ̆ 7 s Principle of Optimality or the Second Principle of Optimality. In Section 5 only a few theorems in Sections 2, 3 and 4 are proved in detail, since others can be proved in a similar manner. Finally, in the last section, we obtain some inequalities by immediate applications of the results in Sections 2, 3 and 4...|$|R
40|$|Writing <b>recursive</b> <b>programs</b> for {{fine-grained}} task-level execution on parallel architectures, such as {{the current}} generation of multi-core machines, often require the application of skilled parallelization knowledge to fully realize the potential of the hardware. This paper automates the process by using Grammatical Evolution (GE) to exploit the multi-cores through the evolution of natively parallel programs. We present Multi-core Grammatical Evolution (MCGE-II), which employs GE and OpenMP specific pragmatic information to automatically evolve task-level parallel <b>recursive</b> <b>programs.</b> MCGE-II is evaluated on six <b>recursive</b> C <b>programs,</b> and we show that it solves each of them using parallel code. We further show that MCGE-II significantly decreases the parallel computational effort as the number of cores increase, when tested on an Intel processor...|$|R
40|$|The {{problem of}} {{reasoning}} about <b>recursive</b> <b>programs</b> is considered. Utlbzing a simple analogy between iterative and <b>recursive</b> <b>programs</b> viewed as unfimte unions of finite terms, {{we carry out}} an investigation analogous to that carried out recently for iterative programs. The main results are the arlthmet!cal completeness of axiom systems for (1) context-free dynamic logic and (2) Its extension for dealing with infinite comflutatiorzs. Having the power of expression of these Iogics in mind, these results {{can be seen to}} supply (as corollaries) complete proof methods for the various kinds of correctness of <b>recursive</b> <b>programs.</b> A majority of the work done to date in reasoning about computer programs seems to be concerned with re. @ar programs (e. g. Wlziie programs or flowcharts etc.). Some of the better known examples are [6, 7, 8, 9, 10, 19, 21, 25, 281. When reading this and other relevant hterature it becomes apparent that when these programs are replaced by recur 5 ive programs (i. e context-free programs) the problems become much harder. For example, the Important paper of de Bakker and Meertens [3] seemed to indicate that Floyd-Hoare-hke methods for proving the partial correctness of <b>recursive</b> <b>programs</b> using invariant assertions, required infinitely many such assertions...|$|R
40|$|AbstractWe study transformations and equivalences of <b>recursive</b> <b>program</b> schemes. We give an {{optimization}} algorithm which recognizes and removes {{all parts of}} a program scheme which do not affect its final output. This result leads to a syntactic way of suppressing some erroneous loops in programs {{and can be used}} to prove that equivalence of <b>recursive</b> <b>program</b> schemes is solvable under particular conditions...|$|E
40|$|AbstractThis paper {{provides}} a general {{account of the}} notion of <b>recursive</b> <b>program</b> schemes, studying both uninterpreted and interpreted solutions. It can be regarded as the category-theoretic version of the classical area of algebraic semantics. The overall assumptions needed are small indeed: working only in categories with “enough final coalgebras” we show how to formulate, solve, and study <b>recursive</b> <b>program</b> schemes. Our general theory is algebraic and so avoids using ordered or metric structures. Our work generalizes the previous approaches which do use this extra structure by isolating the key concepts needed to study substitution in infinite trees, including second-order substitution. As special cases of our interpreted solutions we obtain the usual denotational semantics using complete partial orders, and the one using complete metric spaces. Our theory also encompasses implicitly defined objects which are not usually taken to be related to <b>recursive</b> <b>program</b> schemes. For example, the classical Cantor two-thirds set falls out as an interpreted solution (in our sense) of a <b>recursive</b> <b>program</b> scheme...|$|E
40|$|We {{consider}} primitive <b>recursive</b> <b>program</b> schemes with parameters {{together with}} the callby -value computation rule. The schemes are finite systems of functions which are defined by primitive (or: structural) recursion; simultaneous recursion and nesting of function calls is allowed. We present a transformation strategy which replaces primitive recursion by iteration. The transformation strategy which is fully automatic, takes as input a primitive <b>recursive</b> <b>program</b> scheme M with parameters and it computes a program scheme M 0 as output. We prove that, for every argument tuple, M 0 {{is at least as}} (time) efficient as M. We also prove that there are infinitely many nontrivial primitive <b>recursive</b> <b>program</b> schemes M with parameters for which the transformation yields a program scheme M 0 such that there are infinitely many argument tuples for which M 0 is more efficient than M. Moreover, we provide an algorithm which decides for an arbitrary given primitive <b>recursive</b> <b>program</b> scheme M [...] ...|$|E
5000|$|Euclid's {{algorithm}} may be formalized in the <b>recursive</b> <b>programming</b> style as: [...] In {{the imperative}} programming style, the same algorithm becomes, giving {{a name to}} each intermediate remainder: ...|$|R
5000|$|The {{problem to}} be solved is to provide denotations for <b>recursive</b> <b>programs</b> that are {{defined in terms of}} {{themselves}} such as the definition of the factorial function as ...|$|R
40|$|Abstract. Deadlock {{detection}} in <b>recursive</b> <b>programs</b> that admit dynamic resource {{creation is}} extremely complex and solutions either give imprecise answers {{or do not}} scale. We define an algorithm for detecting deadlocks of linear <b>recursive</b> <b>programs</b> of a basic model. The theory that underpins the algorithm is a generalization {{of the theory of}} permutations of names to so-called mutations, which transform tuples by introducing duplicates and fresh names. Our algorithm realizes the back-end of deadlock analyzers for objectoriented programming languages, once the association programs/basicmodel-programs has been defined as front-end. ...|$|R
40|$|This paper {{provides}} a general {{account of the}} notion of <b>recursive</b> <b>program</b> schemes, studying both uninterpreted and interpreted solutions. It can be regarded as the category-theoretic version of the classical area of algebraic semantics. The overall assumptions needed are small indeed: working only in categories with "enough final coalgebras" we show how to formulate, solve, and study <b>recursive</b> <b>program</b> schemes. Our general theory is algebraic and so avoids using ordered, or metric structures. Our work generalizes the previous approaches which do use this extra structure by isolating the key concepts needed to study substitution in infinite trees, including second-order substitution. As special cases of our interpreted solutions we obtain the usual denotational semantics using complete partial orders, and the one using complete metric spaces. Our theory also encompasses implicitly defined objects which are not usually taken to be related to <b>recursive</b> <b>program</b> schemes. For example, the classical Cantor two-thirds set falls out as an interpreted solution (in our sense) of a <b>recursive</b> <b>program</b> scheme. Comment: this version includes the corrections from the corrigendum in Theoret. Comput. Sci. 403 (2008), 409 - 41...|$|E
40|$|We {{present an}} {{approach}} to inductive synthesis of functional programs based on the detection of recurrence relations. A given term is considered as the kth unfolding of an unknown <b>recursive</b> <b>program.</b> If a recurrence relations can be identified in the term, it can be folded into a <b>recursive</b> <b>program</b> which (a) can reproduce the term and (b) generalizes over it. Our approach goes beyond Summers' classical approach in several aspects: It is language independent and works for terms belonging to an arbitrary term algebra; it allows induction of sets of recursive equations which are in some arbitrary `calls' relation; induced equations can be dependent {{on more than one}} input parameters and we can detect interdependencies of variable substitutions in recursive calls; the given input terms can represent incomplete unfoldings of an hypothetical <b>recursive</b> <b>program...</b>|$|E
40|$|AbstractB. Courcelle studied {{algebraic}} {{trees as}} precisely the solutions of all <b>recursive</b> <b>program</b> schemes {{for a given}} signature in Set. He proved that the corresponding monad is iterative. We generalize this to <b>recursive</b> <b>program</b> schemes over a given finitary endofunctor H of a “suitable” category. A monad is called second-order iterative if every guarded <b>recursive</b> <b>program</b> scheme has a unique solution in it. We construct two second-order iterative monads: one, called the second-order rational monad, SH, is {{proved to be the}} initial second-order iterative monad. The other one, called the context-free monad, CH, is a quotient of SH and in the original case of a polynomial endofunctor H of Set we prove that CH is the monad studied by B. Courcelle. The question whether these two monads are equal is left open...|$|E
40|$|Abstract: Disjunctive finitary {{programs}} are {{a class of}} logic programs admitting function symbols and hence infinite domains. They have very good computational properties, for example ground queries are decidable while in the general case the stable model semantics is Pi^ 1 _ 1 -hard. In this paper we prove that a larger class of <b>programs,</b> called finitely <b>recursive</b> <b>programs,</b> preserves most of the good properties of finitary programs under the stable model semantics, namely: (i) finitely <b>recursive</b> <b>programs</b> enjoy a compactness property; (ii) inconsistency checking and skeptical reasoning are semidecidable; (iii) skeptical resolution is complete for normal finitely <b>recursive</b> <b>programs.</b> Moreover, we show how to check inconsistency and answer skeptical queries using finite subsets of the ground program instantiation. We achieve this by extending the splitting sequence theorem by Lifschitz and Turner: We prove that if the input program P is finitely recursive, then the partial stable models determined by any smooth splitting omega-sequence converge to a stable model of P...|$|R
5000|$|The {{advent of}} logic {{programming}} {{brought a new}} elan but also a new direction in the early 1980s, especially due to the MIS system of Shapiro eventually spawning the new field of inductive logic programming (ILP). The early works of Plotkin, and his [...] "relative least general generalization (rlgg)", had an enormous impact in inductive logic programming. Most of ILP work addresses a wider class of problems, as the focus is not only on <b>recursive</b> logic <b>programs</b> but on machine learning of symbolic hypotheses from logical representations. However, there were some encouraging results on learning <b>recursive</b> Prolog <b>programs</b> such as quicksort from examples together with suitable background knowledge, for example with GOLEM. But again, after initial success, the community got disappointed by limited progress about the induction of <b>recursive</b> <b>programs</b> with ILP less and less focusing on <b>recursive</b> <b>programs</b> and leaning more and more towards a machine learning setting with applications in relational data mining and knowledge discovery.|$|R
40|$|Analysis of <b>recursive</b> <b>programs</b> in the {{presence}} of concurrency and shared memory is undecidable. A common approach is to remove the recursive nature of the program while dealing with concurrency. A different approach is to bound the number of context switches, which {{has been shown to be}} very useful for program analysis. In previous work, Qadeer and Rehof [36] showed that contextbounded analysis is decidable for <b>recursive</b> <b>programs</b> under a finitestate abstraction of program data. In this paper, we generalize their result to infinite-state abstractions, and also provide a new symbolic algorithm for the finite case. 1...|$|R
