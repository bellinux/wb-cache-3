11|9|Public
25|$|Among the {{significant}} enhancements {{introduced in the}} 6809 were the use of two 8-bit accumulators (A and B, which could be combined into a single 16-bit register, D), two 16-bit index registers (X, Y) and two 16-bit stack pointers. The index and stack registers allowed advanced addressing modes. Program counter relative addressing allowed for the easy creation of position-independent code, while a user stack pointer (U) facilitated the creation of <b>reentrant</b> <b>code.</b>|$|E
25|$|The 6809 {{design team}} {{believed}} that future system integrators would look to off-the-shelf code in ROMs to handle common tasks. Motorola's official programming manual contains the full listing of assist09, a so-called monitor, a miniature operating system {{intended to be}} burned in ROM. Another example of ROM code might be binary floating point arithmetic, which is a common requirement in many systems. In order to speed time to market, common code modules would be purchased, rather than developed in-house, and integrated into systems with code from other manufacturers. Since a CPU designer could hardly guarantee where this code would be located in a future system, the 6809 design focused heavily on support of position-independent, <b>reentrant</b> <b>code</b> that could be freely located anywhere in the memory map. This expectation was, in reality, never quite met: Motorola's only released example of a ROM'd software module was the MC6839 floating-point ROM. However, the decisions made by the design team made for a very powerful processor and made possible advanced operating systems like OS-9 and UniFlex, which {{took advantage of the}} position-independent, re-entrant nature of the 6809 to create multi-user multitasking operating systems.|$|E
50|$|<b>Reentrant</b> <b>code</b> may not modify its own code.|$|E
40|$|MBASIC is high-level, {{interactive}} {{computer language}} that reduces time of computer task programming. Outstanding features of MBASIC include: multiple assignments or statements in single instruction; conditional, assignment, and repetitive statement modifiers; and excellent string-handling capabilities. Two machine versions are available: UNIVAC (written in <b>reentrant</b> Assembler <b>code</b> for execution under EXEC 8) AND DEC- 10 (written in Assembler code for execution under TOPS- 10) ...|$|R
25|$|The 6809 was {{the first}} {{microprocessor}} able to use fully position-independent, or <b>reentrant,</b> or both, <b>code</b> {{without the use of}} difficult programming tricks. It also contained one of the first hardware-implementations of a multiplication instruction in an MPU, full 16-bit arithmetic, and an especially fast interrupt system.|$|R
5000|$|<b>Code</b> (<b>reentrant)</b> {{and data}} reside in {{separate}} variable-length segments, which are 32,768 [...] "halfwords" [...] (16-bit words) (or, 65,536 bytes). The operating system, known as MPE (for Multi-Programming Executive), loads code segments from program files and segmented Library (SL) files as needed, up to 256 segments in one process.|$|R
50|$|<b>Reentrant</b> <b>code</b> may {{not call}} non-reentrant {{computer}} programs or routines.|$|E
50|$|<b>Reentrant</b> <b>code</b> may {{not hold}} any static (or global) non-constant data.|$|E
5000|$|Software-implemented stacks are not efficient, {{so it is}} {{difficult}} to generate <b>reentrant</b> <b>code</b> and support local variables ...|$|E
50|$|The code above {{uses the}} BP (base pointer) {{register}} {{to establish a}} call frame, an area on the stack that contains all of the parameters and local variables for {{the execution of the}} subroutine. This kind of calling convention supports <b>reentrant</b> and recursive <b>code,</b> and has been used by most ALGOL-like languages since the late 1950s.|$|R
50|$|The example code {{uses the}} EBP (base pointer) {{register}} {{to establish a}} call frame, an area on the stack that contains all of the parameters and local variables for {{the execution of the}} subroutine. This kind of calling convention supports <b>reentrant</b> and recursive <b>code,</b> and has been used by Algol-like languages since the late 1950s. A flat memory model is assumed, specifically, that the DS and ES segments address the same region of memory.|$|R
2500|$|The {{subroutine}} {{establishes a}} call frame using register A6 as the frame pointer. This kind of calling convention supports <b>reentrant</b> and recursive <b>code</b> and is typically used by languages like C and C++. The subroutine then retrieves the parameters passed to it ( [...] and [...] ) from the stack. It then loops, reading an ASCII character (a single byte) from the [...] string, checking {{whether it is}} an alphabetic character, and if so, converting it into a lower-case character, then writing the character into the [...] string. Finally, it checks whether the character was a null character; if not, it repeats the loop, otherwise it restores the previous stack frame (and A6 register) and returns. Note that the string pointers (registers A0 and A1) are auto-incremented in each iteration of the loop.|$|R
50|$|Multiple {{levels of}} 'user/object/process priority' and/or {{multiprocessing}} usually complicate {{the control of}} <b>reentrant</b> <b>code.</b> It {{is important to keep}} track of any access and or side effects that are done inside a routine designed to be reentrant.|$|E
50|$|Among the {{significant}} enhancements {{introduced in the}} 6809 were the use of two 8-bit accumulators (A and B, which could be combined into a single 16-bit register, D), two 16-bit index registers (X, Y) and two 16-bit stack pointers. The index and stack registers allowed advanced addressing modes. Program counter relative addressing allowed for the easy creation of position-independent code, while a user stack pointer (U) facilitated the creation of <b>reentrant</b> <b>code.</b>|$|E
50|$|<b>Reentrant</b> <b>code</b> {{had to be}} thread safe (execute only); self-modifying {{code was}} not allowed. For other programs, modifying {{executable}} code during runtime was still an acceptable programming technique {{in the time of}} 1100-series computers, but users were encouraged not to do it because of the performance hit. Security benefits were touted but not highly valued because hacking most 1100-series applications would provide no benefit to anyone, and because few hackers were malevolent then.|$|E
50|$|The MC6801 was a single-chip {{microcomputer}} with a 6802 CPU with 128 bytes of RAM, a 2 KB ROM, a 16-bit timer, 31 programmable parallel I/O lines, and a serial port. It could {{also use the}} I/O lines as data and address buses to connect to standard M6800 peripherals. The 6801 would execute 6800 code but it had ten additional instructions and the execution time of key instructions was reduced. The two 8-bit accumulators could act as a single 16-bit accumulator for double precision addition, subtraction and multiplication. It was initially designed for automotive use with General Motors as the lead customer. The first application was a trip computer for the 1978 Cadillac Seville. This 35,000 transistor chip was too expensive for wide-scale adoption in automobiles so a reduced function MC6805 {{single-chip microcomputer}} was designed. The MC6809 was the most advanced 8-bit microprocessor Motorola produced. It had a new instruction set that {{was similar to the}} 6800 but abandoned op-code compatibility for improved performance and high-level language support; the two were software compatible in that assemblers could (and generally did) generate code which was equivalent to 6800 opcodes the 6809 did not directly emulate. In that sense, the 6809 was upward compatible with the 6800. The 6809 had many 16-bit operations, including the first 8-bit multiply instruction (generating a 16 bit product) in a microprocessor, two 16-bit index registers and stack pointers, and full support for both position independent (object code could run wherever it was loaded in memory) and <b>reentrant</b> (object <b>code</b> could be written to be reused by other routines), these last features previously seen only in much larger machines such as IBM 360 mainframes.|$|R
5000|$|The {{subroutine}} {{establishes a}} call frame using register A6 as the frame pointer. This kind of calling convention supports <b>reentrant</b> and recursive <b>code</b> and is typically used by languages like C and C++. The subroutine then retrieves the parameters passed to it ( [...] and [...] ) from the stack. It then loops, reading an ASCII character (a single byte) from the [...] string, checking {{whether it is}} an alphabetic character, and if so, converting it into a lower-case character, then writing the character into the [...] string. Finally, it checks whether the character was a null character; if not, it repeats the loop, otherwise it restores the previous stack frame (and A6 register) and returns. Note that the string pointers (registers A0 and A1) are auto-incremented in each iteration of the loop. In contrast, the code below is for a stand-alone function, even on the most restrictive version of AMS for the TI-89 series of calculators, being kernel-independent, with no values looked up in tables, files or libraries when executing, no system calls, no exception processing, minimal registers to be used, nor the need to save any. It is valid for historical Julian dates from 1 March 1 AD, or for Gregorian ones. In less than two dozen operations it calculates a day number compatible with ISO 8601 when called with three inputs stored at their corresponding LOCATIONS: ...|$|R
50|$|As a {{consequence}} of early pervasive design decisions {{taking advantage of the}} easily used reentrant object code capabilities of the 6809 processor, programs intended for OS-9 are required to be reentrant; compilers produce <b>reentrant</b> <b>code</b> automatically and assemblers for OS-9 offer considerable support for it. OS-9 also uses position-independent code and data because the 6809 also supported it directly; compilers and assemblers supported position independence. The OS-9 kernel loads programs (including shared code), and allocates data, wherever sufficient free space is available in the memory map. This allows the entire OS and all applications to be placed in ROM or Flash memory, and eases memory management requirements when programs are loaded into RAM and run. Programs, device drivers, and I/O managers under OS-9 are all 'modules' and can be dynamically loaded and unloaded (subject to link counts) as needed.|$|E
50|$|The 6809 {{design team}} {{believed}} that future system integrators would look to off-the-shelf code in ROMs to handle common tasks. Motorola's official programming manual contains the full listing of assist09, a so-called monitor, a miniature operating system {{intended to be}} burned in ROM. Another example of ROM code might be binary floating point arithmetic, which is a common requirement in many systems. In order to speed time to market, common code modules would be purchased, rather than developed in-house, and integrated into systems with code from other manufacturers. Since a CPU designer could hardly guarantee where this code would be located in a future system, the 6809 design focused heavily on support of position-independent, <b>reentrant</b> <b>code</b> that could be freely located anywhere in the memory map. This expectation was, in reality, never quite met: Motorola's only released example of a ROM'd software module was the MC6839 floating-point ROM. However, the decisions made by the design team made for a very powerful processor and made possible advanced operating systems like OS-9 and UniFlex, which {{took advantage of the}} position-independent, re-entrant nature of the 6809 to create multi-user multitasking operating systems.|$|E

