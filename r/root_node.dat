926|559|Public
5|$|The {{performance}} of binary search {{can be analyzed}} by reducing the procedure to a binary comparison tree, where the <b>root</b> <b>node</b> is the middle element of the array. The middle element of the lower half is the left child node of the root and the middle element of the upper half is the right child node of the root. The rest of the tree is built in a similar fashion. This model represents binary search; starting from the <b>root</b> <b>node,</b> {{the left or right}} subtrees are traversed depending on whether the target value is less or more than the node under consideration, representing the successive elimination of elements.|$|E
25|$|This {{also does}} not {{establish}} the order of children, but does fix a specific <b>root</b> <b>node.</b>|$|E
25|$|Starting at <b>root</b> <b>node</b> of the tree, select optimal child nodes until a {{leaf node}} is reached.|$|E
40|$|The 2 -rooted mini-max {{spanning}} forest {{problem is to}} find a {{spanning forest}} with two given <b>root</b> <b>nodes</b> on an undirected graph, such that the maximum tree cost in this forest is minimized. We introduce a branch-and-bound algorithm based on selecting nodes. On test instances up to 50 nodes the algorithm gives much better computational results than a known algorithm that is based on selecting edges. Furthermore the new algorithm can easily solve problem instances up to 80 nodes. We consider some alternative and polynomial criteria. Finally we discuss some generalizations, e. g., the problem without given <b>root</b> <b>nodes,</b> i. e., the <b>root</b> <b>nodes</b> have to be chosen. Combinatorial optimization Branch-and-bound Spanning forest Bottleneck criterion...|$|R
40|$|Abstract This paper {{addresses}} {{the issue of}} K-mutual exclusion in a distributed system. Our proposed algorithm divides a network into <b>root</b> <b>nodes</b> and regular <b>nodes.</b> The <b>root</b> <b>nodes</b> {{communicate with each other}} via a ring network and communicate directly with a set of regular nodes that they are assigned to. Mutual exclusion is achieved by using k tokens that are maintained by the <b>root</b> <b>nodes,</b> the collaboration of these roots to attain mutual exclusion instead of all the nodes reduces the communication costs. Furthermore, we use in our algorithm a new token passing strategy to minimize the message complexity, whereas the number of messages exchanged per critical section is between 0 and k+ 2. Key words Distributed systems, Mutual Exclusion, Token, Trees, Logical Ring...|$|R
5000|$|Input: A proof [...] (with {{a single}} root) and a queue [...] of <b>root</b> <b>nodes</b> [...] Output: A proof ...|$|R
25|$|The tree {{decomposition}} of a graph {{is far from}} unique; for example, a trivial tree decomposition contains all vertices of the graph in its single <b>root</b> <b>node.</b>|$|E
25|$|Separators may be {{combined}} into a separator hierarchy of a planar graph, a recursive decomposition into smaller graphs. A separator hierarchy may be represented by a binary tree in which the <b>root</b> <b>node</b> represents the given graph itself, and the two children of the root are the roots of recursively constructed separator hierarchies for the induced subgraphs formed from the two subsets A and B of a separator.|$|E
25|$|In depth-first order, {{we always}} attempt {{to visit the}} node {{farthest}} from the <b>root</b> <b>node</b> that we can, but with the caveat {{that it must be}} a child of a node we have already visited. Unlike a depth-first search on graphs, {{there is no need to}} remember all the nodes we have visited, because a tree cannot contain cycles. Pre-order is a special case of this. See depth-first search for more information.|$|E
3000|$|... pair. Once the <b>root</b> <b>nodes</b> are identified, {{we apply}} the {{framework}} by Cha et al., thus obtaining information cascades each labeled by a unique [...]...|$|R
50|$|The Collection Tree Protocol (CTP) is a routing {{protocol}} for wireless sensor networks. It {{is used for}} transferring data from one or more sensors {{to one or more}} <b>root</b> <b>nodes.</b>|$|R
40|$|The {{implications}} {{of the presence of}} a root, either at the parent node or at neighbour nodes, on branch formation of Trifolium repens (white clover) was investigated. Plants were freely rooted or rooting was restricted to every sixth or every twelfth node along the parent axis. The absence of a root at the parent node had little influence on the probability of the subtending axillary bud forming a branch but, on average, delayed the outgrowth of the bud. The probability that an axillary bud, emerging from a non-rooted parent node, developed to a lateral branch (branch with elongated internodes) decreased with decreasing proximity of the parent <b>node</b> to a <b>rooted</b> <b>node.</b> Lateral branches emerging from non-rooted parent nodes which were two nodes distal to a <b>rooted</b> <b>node</b> had a higher rate of node appearance, a greater mean internode length and area per leaf, and were more branched than lateral branches emerging from other non-rooted parent nodes. The dry mass of each single root and of branches grown at <b>rooted</b> parent <b>nodes</b> were significantly higher in plants with restricted rooting than in freely rooted plants. Restriction in the number of <b>rooted</b> <b>nodes</b> per plant increased the number of inflorescences. It is concluded that the whole plant response to restricted root formation was continuous growth of the parent axis and compensatory growth of the branch at the <b>rooted</b> <b>node.</b> In general, growth was slow for axillary buds whose development was dependent on the basipetal movement or cross-transport within the stolons of resources exported from root...|$|R
25|$|A rooted {{phylogenetic tree}} (see two {{graphics}} at top) is a directed tree {{with a unique}} node — the root — corresponding to the (usually imputed) most recent common ancestor of all the entities at {{the leaves of the}} tree. The <b>root</b> <b>node</b> does not have a parent node, but serves as the parent of all other nodes in the tree. The root is therefore a node of degree 2, whereas other internal nodes of the tree do have a minimum degree of 3.|$|E
25|$|At each node or edge, {{there are}} at most 2k sets S for which we need to {{calculate}} these values, so if k is a constant then the whole calculation takes constant time per edge or node. The size of the maximum independent set is the largest value stored at the <b>root</b> <b>node,</b> and the maximum independent set itself can be found (as is standard in dynamic programming algorithms) by backtracking through these stored values starting from this largest value. Thus, in graphs of bounded treewidth, the maximum independent set problem may be solved in linear time. Similar algorithms apply to many other graph problems.|$|E
25|$|If one forms {{a related}} type of {{hierarchy}} based on separations instead of separators, {{in which the}} two children of the <b>root</b> <b>node</b> are roots of recursively constructed hierarchies for the two subgraphs G1 and G2 of a separation of the given graph, then the overall structure forms a branch-decomposition instead of a tree decomposition. The width of any separation in this decomposition is, again, bounded by the sum of the sizes of the separators on a path from any node to the root of the hierarchy, so any branch-decomposition formed in this way has width O(√n) and any planar graph has branchwidth O(√n). Although many other related graph partitioning problems are NP-complete, even for planar graphs, it is possible to find a minimum-width branch-decomposition of a planar graph in polynomial time.|$|E
50|$|Because no {{operation}} requires {{random access}} to the <b>root</b> <b>nodes</b> of the binomial trees, {{the roots of the}} binomial trees can be stored in a linked list, ordered by increasing order of the tree.|$|R
40|$|Syntax Graph {{implement}} syntactic relationships, and referenceedges, which {{arise from}} semantic relationships. Documents are identi#ed by the subgraph whose node-set is the transitive closure of nodes reachable by aggregation edges from document <b>root</b> <b>nodes.</b> Nodes that cannot have out-going aggregation edges are called terminal nodes, {{for they are}} derived from terminal symbols of the underlying grammar. Those nodes that mayhave out-going aggregation edges shall be called non-terminal nodes...|$|R
5000|$|Via mutual recursion, {{a forest}} {{can be defined}} as a list of trees (represented by <b>root</b> <b>nodes),</b> where a node (of a tree) {{consists}} of a value and a forest (its children): f: [...] n: v f ...|$|R
25|$|For ZFS, data {{integrity}} {{is achieved by}} using a Fletcher-based checksum or a SHA-256 hash throughout the file system tree. Each block of data is checksummed and the checksum value is then saved in the pointer to that block—rather than at the actual block itself. Next, the block pointer is checksummed, with the value being saved at its pointer. This checksumming continues {{all the way up}} the file system's data hierarchy to the <b>root</b> <b>node,</b> which is also checksummed, thus creating a Merkle tree. In-flight data corruption or phantom reads/writes (the data written/read checksums correctly but is actually wrong) are undetectable by most filesystems as they store the checksum with the data. ZFS stores the checksum of each block in its parent block pointer so the entire pool self-validates.|$|E
25|$|Heapsort is a {{much more}} {{efficient}} version of selection sort. It also works by determining the largest (or smallest) element of the list, placing that at the end (or beginning) of the list, then continuing {{with the rest of the}} list, but accomplishes this task efficiently by using a data structure called a heap, a special type of binary tree. Once the data list has been made into a heap, the <b>root</b> <b>node</b> is guaranteed to be the largest (or smallest) element. When it is removed and placed at the end of the list, the heap is rearranged so the largest element remaining moves to the root. Using the heap, finding the next largest element takes O(log n) time, instead of O(n) for a linear scan as in simple selection sort. This allows Heapsort to run in O(n log n) time, and this is also the worst case complexity.|$|E
25|$|Internal nodes are all nodes {{except for}} leaf nodes and the <b>root</b> <b>node.</b> They are usually {{represented}} as an ordered set of elements and child pointers. Every internal node contains {{a maximum of}} U children and a minimum of L children. Thus, the number of elements is always 1 less {{than the number of}} child pointers (the number of elements is between L−1 and U−1). U must be either 2L or 2L−1; therefore each internal node is at least half full. The relationship between U and L implies that two half-full nodes can be joined to make a legal node, and one full node can be split into two legal nodes (if there’s room to push one element up into the parent). These properties make it possible to delete and insert new values into a B-tree and adjust the tree to preserve the B-tree properties.|$|E
50|$|If all {{the leaves}} of a PQ tree are {{connected}} directly to a <b>root</b> P <b>node</b> then all possible orderings are allowed. If all the leaves are connected directly to a <b>root</b> Q <b>node</b> then only one order and its reverse are allowed. If nodes a,b,c connect to a P node, which connects to a <b>root</b> P <b>node,</b> with all other leaf nodes connected directly to the root, then any ordering where a,b,c are contiguous is allowed.|$|R
40|$|Causal Probabilistic Networks (CPN), {{a method}} of {{reasoning}} using probabilities, has become popular {{over the last few}} years within the AI probability and uncertainty community. This paper begins with an introduction to this paradigm, followed by a presentation of some of the current approaches in the induction of the structure learning in CPN. The paper concludes with a concise presentation of alternative approaches to the problem, and the conclusions of this review. 1 Introduction From a informal perspective CPN, they are Directed Acyclic Graphs (DAGs), where the nodes are random variables, and the arcs specify the independence assumptions that must be hold between the random variables. To specify the probability distribution of a CPN, one must give the prior probabilities of all <b>root</b> <b>nodes</b> (nodes with no predecessors) and the conditional probabilities of all no <b>root</b> <b>nodes,</b> given all possible combinations of their direct predecessors. These numbers in conjunction with the DA [...] ...|$|R
3000|$|In the HPM, {{the pause}} {{duration}} is modeled by the syllable-juncture pause duration sub-model, [...] g(pd_n;α_B_n,L_n,η_B_n,L_n) [...]. The sub-model describes the variation of syllable-juncture pause duration influenced by some contextual linguistic features and break type and is organized into 7 break type-dependent decision trees (BDTs). For each break type, a decision tree {{is used to}} determine the probability density function (pdf) of syllable-juncture pause duration according to the contextual linguistic features. Here, all pdfs are assumed to be Gamma distributed. By an analysis on these 7 decision trees, it is found that the means of pdfs in the leaf nodes for the break types with very short pause duration (<[*] 0.03  s), i.e., B 0, B 1, B 2 – 1, and B 2 – 3, are very close to the pdfs of the <b>root</b> <b>nodes.</b> For the break types with pause durations, i.e., B 2 – 2, B 3, and B 4, the pdfs of leaf nodes have more sophisticated pause duration distributions. However, by an informal listening test, we found that the synthesized speeches with pause durations encoded by the pdfs of the <b>root</b> <b>nodes</b> sound almost the same as the ones encoded by the pdfs of the leaf nodes. The pause duration information, therefore, can be encoded solely by the pdfs of the <b>root</b> <b>nodes.</b> In other words, only the symbols of the break types need to be encoded and sent to the decoder. The means of the pdfs for the 7 break types are sent to the decoder as the side information. The decoder reconstructs the syllable-juncture pause duration as the means of the pdfs of the <b>root</b> <b>nodes</b> of the 7 break types.|$|R
2500|$|We {{assume that}} we find every [...] of all nodes [...] whose {{distance}} from the <b>root</b> <b>node</b> is {{less than or equal}} k, and now we are seeking the [...] of the node [...] whose distance from the <b>root</b> <b>node</b> is k +1. Its parent node is , and the letter represented by the node [...] and , is x. (1): If the next letter of the node [...] is x, we set the other node of this edge as , and =. (2): If all letters is not x by searching all edges between [...] and its child nodes, [...] is a suffix of [...] plus x. Because this suffix matches the STRING begin with the <b>root</b> <b>node</b> (similar to prefix), we can detect if there is x after [...] or not. And if not, continue this process until find x or find the <b>root</b> <b>node.</b>|$|E
2500|$|A [...] {{binary tree}} has a <b>root</b> <b>node</b> and every node has at most two children.|$|E
2500|$|... and [...] {{give the}} worst case height of a B-tree (where the <b>root</b> <b>node</b> is {{considered}} to have height 0) as ...|$|E
30|$|After the {{rewriting}} {{has been}} completed, two sub-trees of a binary tree are considered isomorphic (on depth X) if their <b>root</b> <b>nodes</b> {{share the same}} content and their descendants form an equal structure and relatively share the same content (up to depth X- 1).|$|R
25|$|The <b>root</b> <b>node’s</b> {{number of}} {{children}} has the same upper limit as internal nodes, but has no lower limit. For example, when there are fewer than L−1 elements in the entire tree, the root {{will be the only}} node in the tree with no children at all.|$|R
50|$|In {{this method}} two {{different}} priority queues for min and max are maintained. The same elements {{in both the}} PQs are shown {{with the help of}} correspondence pointers.Here, the minimum and maximum elements are values contained in the <b>root</b> <b>nodes</b> of min heap and max heap respectively.|$|R
2500|$|And we use [...] to {{represent}} the STRING which is connected from the <b>root</b> <b>node</b> to the node [...] We also use [...] {{to represent}} {{the length of the}} longest suffix(also, this suffix is the prefix of one of patterns in the set [...] ). Searching this prefix from the <b>root</b> <b>node</b> in the keyword tree, and the last node denoted by [...] when the search is over. When =0, [...] =K. The ordered pair ( [...] , [...] ) called a failure link.|$|E
2500|$|The {{number of}} nodes [...] {{in a full}} binary tree, is at least [...] and at most , where [...] is {{the height of the}} tree. A tree {{consisting}} of only a <b>root</b> <b>node</b> has a height of 0.|$|E
2500|$|Woon's {{recursive}} algorithm (for [...] ) starts by assigning to the <b>root</b> <b>node</b> [...] Given a node [...] of the tree, the left {{child of the}} node is [...] and the right child [...] A node [...] is written as [...] in the initial part of the tree represented above with ± denoting the sign of [...]|$|E
5000|$|The <b>root</b> <b>node’s</b> {{number of}} {{children}} has the same upper limit as internal nodes, but has no lower limit. For example, when there are fewer than L−1 elements in the entire tree, the root {{will be the only}} node in the tree with no children at all.|$|R
40|$|This paper {{describes}} a biased random-key genetic algorithm for a real-world wireless backhaul network design problem. This {{is a novel}} problem, closely related to variants of the Steiner tree problem and the facility location problem. Given a parameter h, we {{want to build a}} forest where each tree has at most h hops from the demand nodes, where traffic originates, to the <b>root</b> <b>nodes</b> where each tree is <b>rooted.</b> Candidate Steiner <b>nodes</b> do not have any demand but represent locations where we can install cellsites to cover the traffic and equipment to backhaul the traffic to the cellular core network. Each Steiner node can cover demand nodes within a given distance, subject to a capacity constraint. The aggregate set of constraints may make it impossible to cover or backhaul all demands. A revenue function computes the revenue associated with the total amount of traffic covered and backhauled to the <b>root</b> <b>nodes.</b> The objective of the problem is to build a forest that maximizes the difference between the total revenue and the cost associated with the installed equipment. Although we will have a forest when we consider only the backhaul links and <b>root</b> <b>nodes,</b> the addition of demand vertices can induce undirected cycles, resulting in a directed acyclic graph. We consider instances of this problem with several additional constraints that are motivated by the requirements of real-world telecommunication networks. (C) 2015 Elsevier B. V. All rights reserved...|$|R
40|$|Agenetic {{experiment}} was conducted using 80 full-sib families in irrigated and dryland treatments under the summer moisture stress {{conditions of the}} Northern Tablelands of New South Wales, over 3 years. This paper reports {{on the effects of}} climatic and soil moisture conditions, the genetic variation for stolon attributes and seasonal herbage yield, and the development of new recombinant genotypes in relation to the association between stolon attributes and herbage yield. Large components of variance were estimated for genotype-by-environment-by-year interactions for the attributes stolon density, number of branches, number of <b>nodes,</b> number of <b>rooted</b> <b>nodes,</b> stolon thickness, <b>root</b> diameter, internode length, and summer herbage yield. The combined analysis of variance across environments and years indicated the presence of genetic variation for the stolon attributes stolon density, number of branches, number of nodes, stolon thickness, internode length, and herbage yield. Crossing of the morphologically contrasting cultivars El Lucero x Tahora x Duron, and Barbian x El Lucero, resulted in generating genotypic recombinants with new associations between herbage yield and stolon density, number of branches, number of nodes, and number of <b>rooted</b> <b>nodes.</b> Evaluation of the full-sib families and check cultivars (cvv. Haifa and Huia) identified 5 full-sib families with relatively higher herbage yield, stolon density, number of branches, number of nodes, and number of <b>rooted</b> <b>nodes</b> than cultivars Haifa and Huia...|$|R
