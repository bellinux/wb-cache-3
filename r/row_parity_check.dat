0|1703|Public
5000|$|The <b>rows</b> of a <b>parity</b> <b>check</b> matrix are the {{coefficients}} of the <b>parity</b> <b>check</b> equations. That is, they show how linear combinations of certain digits (components) of each codeword equal zero. For example, the <b>parity</b> <b>check</b> matrix ...|$|R
40|$|Conference PaperThe major {{drawback}} of the LDPC codes {{versus the}} turbo-codes is their comparative low convergence speed: 25 - 30 iterations vs. 8 - 10 iterations for turbo-codes. Recently, Hocevar showed by simulations that the convergence {{rate of the}} LDPC decoder can be accelerated by exploiting a â turbo-schedulingâ applied on the bit-node messages (<b>rows</b> of the <b>parity</b> <b>check</b> matrix). In this paper, we show analytically that the convergence rate {{for this type of}} scheduling is about two times increased for most of the regular LDPC codes. Second we prove that â turbo-schedulingâ applied on the <b>rows</b> of the <b>parity</b> <b>check</b> matrix is identical belief propagation algorithm as standard message passing algorithm. Furthermore, we propose two new message passing schedules: 1) a turbo-scheduling is applied on the checknode messages (columns of the <b>parity</b> <b>check</b> matrix); 2) a hybrid version of both previous schedules where the turbo-effect is applied on both check-nodes and bit-nodes. Frame error rate simulations validate the effectiveness of the proposed schedules...|$|R
40|$|Abstract — In this paper, {{an idea of}} {{the cutting}} plane method is {{employed}} to improve the fractional distance of a given binary <b>parity</b> <b>check</b> matrix. The fractional distance is the minimum weight (with respect to ℓ 1 -distance) of vertices of the fundamental polytope. The cutting polytope is defined based on redundant <b>rows</b> of the <b>parity</b> <b>check</b> matrix and it plays a key role to eliminate unnecessary fractional vertices in the fundamental polytope. We propose a greedy algorithm and its efficient implementation for improving the fractional distance based on the cutting plane method. I...|$|R
40|$|In this paper, {{an idea of}} {{the cutting}} plane method is {{employed}} to improve the fractional distance of a given binary <b>parity</b> <b>check</b> matrix. The fractional distance is the minimum weight (with respect to l 1 -distance) of vertices of the fundamental polytope. The cutting polytope is defined based on redundant <b>rows</b> of the <b>parity</b> <b>check</b> matrix and it plays a key role to eliminate unnecessary fractional vertices in the fundamental polytope. We propose a greedy algorithm and its efficient implementation for improving the fractional distance based on the cutting plane method. Comment: 8 pages, To be presented at Turbo Coding 200...|$|R
40|$|Abstract — We {{propose a}} design {{criterion}} for serially concatenated LDGM codes which require a single decoder and a bitinterleaver. The inner LDGM code {{can be obtained}} by expanding the <b>rows</b> of the <b>parity</b> <b>check</b> matrix of the outer LDGM code. The resulting codes can be decoded using only the inner LDGM decoder with slight modification. Simulation results show that the performance of the proposed codes is almost {{the same as that of}} serially concatenated LDGM codes’s using both the inner and the outer decoders. Index Terms — Low-density generator matrix codes, concatenated schemes, belief-propagation algorithm...|$|R
40|$|International audienceIn this paper, {{a method}} to design regular (2, dc) - LDPC codes over GF(q) with both good {{waterfall}} and error floor properties is presented, based on the algebraic properties of their binary image. First, the algebraic properties of <b>rows</b> of the <b>parity</b> <b>check</b> matrix H associated with a code are characterized and optimized to improve the waterfall. Then the algebraic properties of cycles and stopping sets associated with the underlying Tanner graph are studied and linked to the global binary minimum distance of the code. Finally, simulations are presented to illustrate the excellent performance of the designed codes...|$|R
40|$|Abstract — In this paper, {{a method}} to design regular (2, dc) -LDPC codes over GF(q) with both good {{waterfall}} and error floor properties is presented, based on the algebraic properties of their binary image. First, the algebraic properties of <b>rows</b> of the <b>parity</b> <b>check</b> matrix H associated with a code are characterized and optimized to improve the waterfall. Then the algebraic properties of cycles and stopping sets associated with the underlying Tanner graph are studied and linked to the global binary minimum distance of the code. Finally, simulations are presented to illustrate the excellent performance of the designed codes. Index Terms — channel coding, error correction coding, nonbinary LDPC codes, iterative decoding, binary image. I...|$|R
40|$|AbstractThe celebrated Feng–Rao bound {{estimates}} the minimum distance of codes defined {{by means of}} their <b>parity</b> <b>check</b> matrices. From the Feng–Rao bound it is clear how to improve a large family of codes by leaving out certain <b>rows</b> in their <b>parity</b> <b>check</b> matrices. In this paper we derive a simple lower bound on the minimum distance of codes defined by means of their generator matrices. From our bound it is clear how to improve a large family of codes by adding certain rows to their generator matrices. The new bound is very much related to the Feng–Rao bound {{as well as to}} Shibuya and Sakaniwa's bound in [T. Shibuya, K. Sakaniwa, A dual of well-behaving type designed minimum distance, IEICE Trans. Fund. E 84 -A (2001) 647 – 652]. Our bound is easily extended to deal with any generalized Hamming weights. We interpret our methods into the setting of order domain theory. In this way we fill in an obvious gap in the theory of order domains...|$|R
40|$|Abstract—A Split {{decoding}} {{algorithm is}} proposed which divides each <b>row</b> of the <b>parity</b> <b>check</b> matrix into two or multiple nearly-independent simplified partitions. The proposed method significantly reduces the wire interconnect and decoder complexity and therefore results in fast, small, and high energy efficiency circuits. Three full-parallel decoder chips for a (2048, 1723) LDPC code compliant with the 10 GBASE-T standard using MinSum normalized, MinSum Split- 2, and MinSum Split- 4 methods are designed in 65 nm, 7 metal layer CMOS. The Split- 4 decoder occupies 6. 1 mm 2, operates at 146 MHz, delivers 19. 9 Gbps throughput, with 15 decoding iterations. At 0. 79 V, it operates at 47 MHz, delivers 6. 4 Gbps and dissipates 226 mW. Compared to MinSum normalized, the Split- 4 decoder chip is 3. 3 times smaller, has a clock rate and throughput 2. 5 times higher, is 2. 5 times more energy efficient, and has an error performance degradation of 0. 55 dB with 15 iterations. Index Terms—low density <b>parity</b> <b>check,</b> LDPC, iterative decoder, Split-Row, CMOS, 65 nm, 10 GBASE-T, VLSI. I...|$|R
40|$|In this paper, {{we propose}} a linear {{complexity}} encoding method for arbitrary LDPC codes. We start {{from a simple}} graph-based encoding method "label-and-decide. " We prove that the "label-and-decide" method is applicable to Tanner graphs with a hierarchical structure [...] pseudo-trees [...] and that the resulting encoding complexity is linear with the code block length. Next, we define a second type of Tanner graphs [...] the encoding stopping set. The encoding stopping set is encoded in linear complexity by a revised label-and-decide algorithm [...] the "label-decide-recompute. " Finally, we prove that any Tanner graph can be partitioned into encoding stopping sets and pseudo-trees. By encoding each encoding stopping set or pseudo-tree sequentially, we develop a linear complexity encoding method for general LDPC codes where the encoding complexity is proved {{to be less than}} 4 · M · (k - 1), where M is the number of independent <b>rows</b> in the <b>parity</b> <b>check</b> matrix and k represents the mean row weight of the <b>parity</b> <b>check</b> matrix. Comment: 36 pages, 13 figures, submitted to IEEE Transactions on Information Theor...|$|R
40|$|Abstract A Split {{decoding}} {{algorithm is}} proposed which divides each <b>row</b> of the <b>parity</b> <b>check</b> matrix into two or multiple nearly-independent simplified partitions. The proposed method significantly reduces the wire interconnect and decoder complexity and therefore results in fast, small, and high energy efficiency circuits. Three full-parallel decoder chips for a (2048, 1723) LDPC code compliant with the 10 GBASE-T standard using MinSum normalized, MinSum Split- 2, and MinSum Split- 4 methods are designed in 65 nm, seven metal layer CMOS. The Split- 4 decoder occupies 6. 1 mm 2, operates at 146 MHz, delivers 19. 9 Gbps throughput, with 15 decoding iterations. At 0. 79 V, it operates at 47 MHz, delivers 6. 4 Gbps and dissipates 226 mW. Compared to MinSum normalized, the Split- 4 decoder chip is 3. 3 times smaller, has a clock rate and throughput 2. 5 times higher, is 2. 5 times more energy efficient, and has an error performance degradation of 0. 55 dB with 15 iterations...|$|R
3000|$|The {{processing}} time per iteration {{can be reduced}} substantially if some means is employed to eliminate the inter-lane communications associated with performing <b>parity</b> <b>checks.</b> Consider an alternative approach to testing the correctness of code-symbol polarities in which the <b>parity</b> <b>checks</b> for a given block of rows are incorporated within the corresponding message-passing subiterations. At {{the end of each}} subiteration of the message-passing phase, the posteriors updated during the subiteration are used to determine if the corresponding subset of <b>parity</b> <b>checks</b> are satisfied. The current posterior values required for each <b>parity</b> <b>check</b> are already located in the stream-processor lane in which the <b>parity</b> <b>check</b> is performed since the updates of the same values have just been completed in the same lane. Thus the need for separate inter-lane communications for <b>parity</b> <b>checks</b> is eliminated. We refer to this non-standard schedule of <b>parity</b> <b>checks</b> as the integrated <b>parity</b> <b>check</b> (IPC). The decoding time for the IPC is shown in the second-row entry in Table 1. The {{processing time}} for the integrated message-passing-and-parity-check phase of an iteration is only [...]. 08 μ s greater than the message-passing phase alone in the standard schedule.|$|R
40|$|International audienceWe {{investigate}} {{the use of}} Low Rank <b>Parity</b> <b>Check</b> Codes, originally designed for cryptography applications {{in the context of}} Power Line Communication. Particularly, we propose a new code design and an efficient probabilistic decoding algorithm. The main idea of decoding Low Rank <b>Parity</b> <b>Check</b> Codes is based on calculations of vector spaces over a finite field math formula. Low Rank <b>Parity</b> <b>Check</b> Codes {{can be seen as the}} identical of Low Density <b>Parity</b> <b>check</b> codes. We compare the performance of this code against the Reed-Solomon Code through a Power Line Communication channel...|$|R
40|$|We propose several {{improvements}} for Linear Programming (LP) decoding algorithms for High Density <b>Parity</b> <b>Check</b> (HDPC) codes. First, {{we use the}} automorphism {{groups of}} a code to create <b>parity</b> <b>check</b> matrix diversity and to generate valid cuts from redundant <b>parity</b> <b>checks.</b> Second, we propose an efficient mixed integer decoder utilizing the branch and bound method. We further enhance the proposed decoders by removing inactive constraints and by adapting the <b>parity</b> <b>check</b> matrix prior to decoding according to the channel observations. Based on simulation results the proposed decoders achieve near-ML performance with reasonable complexity. Comment: Submitted to the IEEE Transactions on Communications, November 200...|$|R
5000|$|A {{generator}} matrix {{can be used}} {{to construct}} the <b>parity</b> <b>check</b> matrix for a code (and vice versa). If the generator matrix G is in standard form, [...] , then the <b>parity</b> <b>check</b> matrix for C is ...|$|R
50|$|Now part of RAID 6, double parity (sometimes {{known as}} <b>row</b> {{diagonal}} <b>parity)</b> features {{two sets of}} <b>parity</b> <b>checks,</b> like traditional RAID 6. Differently, the second set is not another set of points in the over-defined polynomial which characterizes the data. Rather, double parity calculates the extra parity against a different group of blocks. For example, in our graph both RAID 5 and 6 consider all A-labeled blocks to produce one or more parity blocks. However, it is fairly easy to calculate parity against multiple groups of blocks, one can calculate all A blocks and a permuted group of blocks.|$|R
5000|$|B1: Bit Error Monitoring. The B1 Byte {{contains}} {{the result of}} the <b>parity</b> <b>check</b> of the previous STM frame, after scrambling of the actual STM frame. This check is carried out with a Bit Interleaved <b>Parity</b> <b>check</b> (BIP-8).|$|R
5000|$|Static RAM {{consists}} of 16 / 24 / 32 / 40 KB general purpose with hardware <b>parity</b> <b>check,</b> 0 / 8 KB core coupled memory (CCM) with hardware <b>parity</b> <b>check,</b> 64 / 128 bytes battery-backed with tamper-detection erase.|$|R
3000|$|... of the <b>parity</b> <b>check</b> matrix is non-null. Decoding {{algorithms}} {{based on}} Tanner graphs are iterative, based on exchanging information between <b>parity</b> <b>check</b> nodes and variable nodes. Belief propagation {{is applied to}} Tanner graphs to efficiently decode LDPC codes [20, 21].|$|R
50|$|A {{fixed rate}} erasure code, usually {{with a fairly}} high rate, is applied as a 'pre-code' or 'outer code'. This pre-code may itself be a {{concatenation}} of multiple codes, for example in the code standardized by 3GPP a high density <b>parity</b> <b>check</b> code derived from the binary Gray sequence is concatenated with a simple regular low density <b>parity</b> <b>check</b> code. Another possibility would be a concatenation of a Hamming code with a low density <b>parity</b> <b>check</b> code.|$|R
5000|$|B2 : Bit Error Monitoring. The B2 Bytes {{contains}} {{the result of}} the <b>parity</b> <b>check</b> of the previous STM frame, except the RSOH, before scrambling of the actual STM frame. This check is carried out with a Bit Interleaved <b>Parity</b> <b>check</b> (BIP24) ...|$|R
40|$|In this paper, we {{investigate}} an efficient encoding approach for generalized low-density (GLD) <b>parity</b> <b>check</b> codes, a generalization of Gallager's low-density <b>parity</b> <b>check</b> (LDPC) codes. We propose a systematic approach to construct approximate upper triangular GLD <b>parity</b> <b>check</b> matrix which defines {{a class of}} efficientencoding GLD codes. It's shown that such GLD codes have equally good performance. By effectively exploiting the structure sharing in the encoding process, we also present a hardware/software codesign for the practical encoder implementation of these efficientencoding GLD codes...|$|R
40|$|A {{class of}} codes {{defined by the}} <b>parity</b> <b>check</b> matrix of a linear code of minimum {{distance}} at least t + 1 is examined {{and the number of}} <b>parity</b> <b>check</b> symbols is discussed. Determinants of this type are known as alternants (Muir and Metzler, 1930); codes corresponding to such a matrix are termed alternant codes. The <b>parity</b> <b>check</b> matrix is obtained by restricting some of its elements to subfields of GF(q to the m-th power). Minimum distance and redundancy bounds are established for these codes, and some interesting equivalence and invariance properties are derived...|$|R
3000|$|... {{and each}} {{independent}} <b>parity</b> <b>check</b> is tested. If all the <b>parity</b> <b>checks</b> are satisfied, decoding is terminated with a valid decoded code word, {{and the information}} bits are recovered by inverse mapping. If not, but {{the maximum number of}} iterations has been executed, a known decoding failure occurs. Otherwise, another iteration of the algorithm is performed. We use this schedule of updates and <b>parity</b> <b>checks</b> for the TDMP algorithm (with alternating message-passing and parity-check phases) as a benchmark in the article and refer to it as the TDMP algorithm with the standard schedule.|$|R
40|$|Simple {{arguments}} {{suggest that}} shortened codes must have distance properties {{equal to or}} better than those of their parent codes, {{and that they should}} be equally practical to decode. This relationship holds true in the case of low density generator codes and low density <b>parity</b> <b>check</b> codes. We investigate the properties of shortened turbo codes. I. Motivation for Shortening In our previous work on codes based on very sparse matrices we have observed that while codes with a low density generator matrix [1] are asymptotically bad, codes with a low density <b>parity</b> <b>check</b> matrix [2] are asymptotically good [3, 4, 5]. One way of viewing the relationship between low density generator matrix codes and low density <b>parity</b> <b>check</b> matrix codes is that one obtains a low density <b>parity</b> <b>check</b> matrix by taking the M Θ N <b>parity</b> <b>check</b> matrix [P IM] of a (N; K) low density generator matrix code and chopping off its right-most M columns (where M = N Γ K), to yield an M Θ K matrix [P], which [...] ...|$|R
40|$|Recently {{there has}} been {{interest}} {{in the construction of}} small <b>parity</b> <b>check</b> sets for iterative decoding of the Hamming code with the property that each uncorrectable (or stopping) set of size three is the support of a codeword and hence uncorrectable anyway. Here we reformulate and generalise the problem, and improve on this construction. First we show that a <b>parity</b> <b>check</b> collection that corrects all correctable erasure patterns of size m for the r-th order Hamming code (i. e, the Hamming code with codimension r) provides for all codes of codimension $r$ a corresponding ``generic'' <b>parity</b> <b>check</b> collection with this property. This leads naturally to a necessary and sufficient condition on such generic <b>parity</b> <b>check</b> collections. We use this condition to construct a generic <b>parity</b> <b>check</b> collection for codes of codimension r correcting all correctable erasure patterns of size at most m, for all r and m = 3 and r large enough. Finally we discuss some directions for further research. Comment: 13 pages, no figures. Submitted to IEEE Transactions on Information Theory, July 28, 200...|$|R
40|$|Error {{correcting}} codes prevent loss {{of integrity}} in data transmission. Low Density <b>Parity</b> <b>Check</b> codes are {{a family of}} codes that are specified by sparse matrices. Using the Nelder-Mead Downhill Simplex Evolution to design an irregular Low Density <b>Parity</b> <b>Check</b> code, we hope to improve upon the accuracy of decoding...|$|R
5000|$|... 4532624 <b>Parity</b> <b>checking</b> {{arrangement}} for a {{remote switching unit}} network ...|$|R
40|$|It is {{proposed}} {{a method for}} dynamically changing the low-density <b>parity</b> <b>check</b> code parameters in accordance with communication channel qualit y monitoring and device for storing, dynamic selection of <b>parity</b> <b>check</b> matrices and error-correcting encoding. Finally, results of the simulation codes characteristics and performance, which prove the effectiveness of proposed method, are presented...|$|R
40|$|A {{simple but}} {{effective}} decoding procedure, applicable to any (n,k) linear block code with symbols from GF(q), is described. The technique involves {{a transformation of}} the <b>parity</b> <b>check</b> equations which focuses the code's correction power on the soft symbol set while still retaining the capability to correct one symbol error from outside this set. The soft symbol set is defined to be the n-k least reliably detected code symbol positions whose <b>parity</b> <b>check</b> row-spaces are linearly independent. The process generates a number of error vector screening candidates, each {{a solution to the}} <b>parity</b> <b>check</b> equations, and the maximum-likelihood candidate is accepted...|$|R
40|$|The {{information}} hiding deals with distortion reduction using steganography and security enhancement using cryptography. Distortion reduction is done using Tree Based <b>Parity</b> <b>Check</b> which uses Majority vote strategy. The Tree Based <b>Parity</b> <b>Check</b> is very optimal for cloaking {{a message on}} image. The proposed majority vote strategy results in least distortion. The SHA- 1 algorithm is implemented for security enhancement. The result obtained in proposed method works effectively even with large payload. Codes to improve the computational complexity of wet paper codes derive d a hash function to efficiently obtain the stego object. Proposed a scheme called tree-based <b>parity</b> <b>check...</b>|$|R
30|$|To {{make the}} {{encoding}} and decoding of LDPC codes in DVB-T 2 more efficient, the sparse {{part of the}} <b>parity</b> <b>check</b> matrix {{is designed to be}} in a quasi-cyclic form [25, 26]. Thus, further efficient manipulation {{of the structure of the}} <b>parity</b> <b>check</b> matrix can make it suitable for layered decoding [27 – 29].|$|R
40|$|Abstract—Foward error {{correction}} (FEC) {{scheme based on}} low density <b>parity</b> <b>check</b> codes (LDPC) codes is presented in this paper. We show that LDPC codes provide a significant system performance enhancement {{with respect to the}} state-of-the-art FEC schemes employed in optical communication systems. Index Terms—Forward {{error correction}}, long-haul transmis-sion, low-density <b>parity</b> <b>check</b> codes, optical communications. I...|$|R
40|$|Till now {{communication}} is possible of 7 bit information data string by transmitting 11 bit data string in single frame {{due to this}} speed of communication system is very slow. And we can transmit very minimum number of configuration of data string. To increase the speed of communication system and increase the numbers of configuration data string author design some communication system by different methodologies of Hamming code. About all these communication systems all methodologies are discuss here. First, author design communication system to make communication by even <b>parity</b> <b>check</b> method for 25 bit information data string. In second paper, author design communication system to make communication by odd <b>parity</b> <b>check</b> method for 25 bit information data. In third paper, author again design communication system for 25 bit information data string by even parity and odd <b>parity</b> <b>check</b> method by using VHDL by single system. Till now, for 25 bit information data string {{communication is}} possible only in simplex mode. So that now author, design 25 bit hamming code transceiver to make communication possible in full duplex mode. Key word Hamming code, VHDL code, Xilinx ISE 10. 1 simulator, even <b>parity</b> <b>check,</b> odd <b>parity</b> <b>check,</b> transmitter, receiver, transceiver...|$|R
5000|$|... #Subtitle level 3: <b>Parity</b> <b>checking</b> {{limited to}} only 6 of 10 bits ...|$|R
50|$|In the Hagelbarger code, {{inserted}} <b>parity</b> <b>check</b> bits {{are spread}} out in time so that an error burst {{is not likely to}} affect more than one of the groups in which <b>parity</b> is <b>checked.</b>|$|R
