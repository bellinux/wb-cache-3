82|314|Public
50|$|The {{functions}} of the MINTERM {{are similar to those}} of the TACTERM; its updated design includes an improved modular architecture, and it has been reduced in size. The MINTERM is lightweight, low-power, single channel, half-duplex, narrowband/wideband/wireline terminal providing secure voice and data communications with full key distribution and remote <b>rekey</b> capabilities. The MINTERM is certified to secure traffic up to TOP SECRET.|$|E
50|$|Rekeying {{was first}} invented in 1836 by Solomon Andrews, a New Jersey locksmith. His lock had {{adjustable}} tumblers and keys, allowing the owner to <b>rekey</b> it at any time. Later in the 1850s, inventors Andrews and Newell patented removable tumblers {{which could be}} taken apart and scrambled. The keys had bits that were interchangeable, matching varying tumbler configurations. This arrangement later {{became the basis for}} combination locks.|$|E
50|$|So far 2,231 texts {{have been}} {{released}} free to the public through {{the work of the}} University of Michigan’s Text Creation Partnership. Rather than OCR, they <b>rekey</b> the texts and tag them with TEI. Their aim is to enable improved access to a fraction of the collection: they are making SGML/XML text editions for 10,000 books. In addition to the free version, subscription access is also offered.|$|E
40|$|IP {{multicast}} is {{an efficient}} solution for group communication over the Internet, {{as both the}} sender resources and the network bandwidth are relieved {{with the aid of}} this emerging technology. However, this superiority suffers, when the group communication must fulfill some security requirements. An essential issue relates to sharing the communication key. Particularly, this key must be updated and securely distributed, every time the group membership changes. This process, which is denoted as group <b>rekeying,</b> raises a scalability problem in large dynamic groups: <b>Rekeying</b> is based on computationally extensive cryptographic operations and on the dissemination of <b>rekeying</b> messages. Thus, the scalability problem presents itself by a computation overhead on both the sender and the receiver sides, and by a communication overhead in the network. Numerous architectures, algorithms, and protocols have been proposed in the literature to cope with this scalability problem. Related work on optimizing <b>rekeying</b> performance mostly concentrates on minimizing the number of required cryptographic operations and thus the length of the <b>rekeying</b> message. An accepted strategy to reduce <b>rekeying</b> costs utilizes batch processing of <b>rekeying</b> requests, which are summed up during a <b>rekeying</b> interval. However, a specification of the maximal length of this <b>rekeying</b> interval is not provided, so far. Too long <b>rekeying</b> intervals cause longer waiting times for new members and longer access times for removed ones. Consequently, a problem of QoS and security is associated with batch <b>rekeying.</b> Because of its novelty and complexity, the work on <b>rekeying</b> optimization lacks a unified way to estimate <b>rekeying</b> performance. In most cases, therefore, an evaluation of different algorithms is impossible. The presented dissertation addresses the above three problems of group <b>rekeying.</b> Firstly, an approach, denoted as Even-Driven Batch <b>Rekeying,</b> is proposed to tackle the QoS and security problems caused by long <b>rekeying</b> intervals in batch <b>rekeying.</b> Secondly, to enable a reliable evaluation of <b>rekeying</b> algorithms, a <b>Rekeying</b> Benchmark is introduced, which provides a unified way to estimate the performance of different <b>rekeying</b> algorithms on the system level. Thirdly, three novel hardware and hardware/software architectures are presented for optimizing the <b>rekeying</b> performance. In contrast to related work, these architectures, denoted as the Real-Time <b>Rekeying</b> Processor, the Batch <b>Rekeying</b> Processor, and the High-Flexibility <b>Rekeying</b> Processor, optimize <b>rekeying</b> not only on the <b>rekeying</b> algorithm level, but also on the cryptography and platform levels...|$|R
40|$|Scalable group <b>rekeying</b> schemes {{proposed}} in the literature can be classi ed into two categories, based on the keys used to encrypt the key encryption keys (KEK) and the group key. Logical key hierarchy (LKH) based approaches use KEKs sent in a <b>rekeying</b> message to encrypt the KEKs to be sent in the next <b>rekeying</b> message. Thus LKH is a stateful <b>rekeying</b> algorithm, with the disadvantage that a member that goes oine during a <b>rekeying</b> instance cannot recover any future keys. Stateless <b>rekeying</b> algorithms, such as subset dierence based member revocation (SDR) mechanism, {{on the other hand}} use keys sent during member registration to send KEKs and the group key. Thus members going of- ine can decrypt future KEKs without having to consult the group manager. SDR <b>rekeying</b> is dependent on the membership during an entire session whereas LKH <b>rekeying</b> is dependent on membership of the group during a <b>rekeying</b> instance...|$|R
40|$|Many {{emerging}} Web and Internet {{applications are}} based on a group communication model. Securing group communication is an important Internet design issue. A Key Graph approach has been used to implement the group key management and it is used to provide secure group communication. The group key management can be done in two ways: 1. Individual <b>rekeying</b> 2. Batch <b>rekeying.</b> Individual <b>Rekeying</b> is the process of <b>rekeying</b> after each join or leave request. The problem with individual <b>rekeying</b> is inefficiency and out-of- sync problem between keys and data. A batch <b>rekeying</b> using MARKING ALGORITHM can overcome the problems faced in the individual <b>rekeying.</b> The paper applies Batch <b>rekeying</b> by Marking Algorithm on the B- Tree (2 - 3 trees) and NSBHO (Non Splitting Balancing Higher Order) tree. The Analyzing done on the key server’s processing cost for batch <b>rekeying</b> in B-Tree and NSBHO tree. The proposed NSBHO (Non-Split Balancing High-Order) tree in which balancing tree after member joining does not involve node splitting. The implementation shows that the NSBHO tree has better average-case <b>rekeying</b> performance and far superior worst-case <b>rekeying</b> performance than a B-tree...|$|R
5000|$|Meanwhile, some mendacious and greedy {{civilian}} contractors for the Fleet {{have agreed}} {{to carry out a}} job for the barbarian space-warriors of the Bloodhorde: they would take a Fleet contract to <b>rekey</b> the command sequences of various missiles, and when they were aboard the specified massive Deep Space Repair vessel, covertly disable its self-destruct mechanism. This job would pave the way for the Bloodhorde boarding team. By a remarkable coincidence, it is this very same DSR, the Koskiuskos ("Kos" [...] for short) which Suiza is assigned to.|$|E
5000|$|Pins are {{manufactured}} in [...]003" [...] increments and [...]005" [...] increments, pin kits contain a array of pins organized by length. Lock manufacturers each use specific depth and spacing allowing organized master-key systems to be complex, large, and manageable. A standard pin kit offers the exact size variety needed. Using manufacturer depths permits easy keying, but often you must deviate slightly for optimum accuracy. Pin kits provide master- wafers, top- pins, and springs for a thorough cylinder rebuild. Replace any worn parts, <b>rekey,</b> lubricate, and reassemble. Check {{to see that}} the keys work well, check remaining customer keys if any and reinstall.|$|E
5000|$|At one time, several {{manufacturers}} made a [...] "crushable wafer tumbler" [...] {{for these}} locks, {{the idea being}} to simplify the task of rekeying for locksmiths and {{reduce the number of}} different wafers that needed to be manufactured and stocked. To <b>rekey</b> such a lock, the locksmith simply replaced all the wafers with identical [...] "crushable wafers", cut the new key, inserted the key into the plug, inserted the plug into a special [...] "crushing" [...] tool, and squeezed the handle of the tool, crushing the wafers to fit the key. It was quick and easy but had reliability problems: debris from the crushed wafers often remained in the plug causing wear and occasional jamming of wafers or the plug, and sometimes wafers crushed unevenly making them weak and causing them to break later in use. This system was eventually abandoned.|$|E
40|$|Rapid {{growth of}} Internet spawns many group {{oriented}} multicast applications like Internet pay TV, news dissemination and stock quote system. The fortes of these applications are {{the support of}} dynamic, scalable group membership and group members are geographically divergent. As {{members of the group}} move in and out, an imperative cryptographic <b>rekeying</b> model should be applied to preserve the confidentiality of the group. A symmetric key called as session key is employed to defend the group communication data during transit. Forward and backward secrecy is attained by updating the session key for every change in group membership. Depends on the application immediate <b>rekeying</b> or batch <b>rekeying</b> can be used employed. The problem with the batch <b>rekeying</b> algorithm is to determine the pertinent batch size and the optimal time for <b>rekeying</b> process. The main aim is to propose a mathematical model based on queuing theory principles by considering the request for <b>rekeying</b> as Poisson process, <b>rekeying</b> service as an exponential distribution. The performance of the proposed model is analyzed using Java based simulator. By varying the arrival rate and <b>rekeying</b> service rate the optimal batch size can be attained. The optimal <b>rekeying</b> interval improves the performance of the group when the group membership grows dynamically. Reduces the long waiting time of the <b>rekeying</b> requests and find the best batch size for the <b>rekeying.</b> Proposed mathematical model analyses the various control parameters for batch <b>rekeying</b> and locates the best values for the batch size and interval time using the M/M/ 1 /K model queues...|$|R
40|$|There {{are several}} group key {{management}} solutions to implement group <b>rekeying</b> in secure multicast communication. These solutions suffer from 1 affects all phenomena {{if they use}} centralized architecture or from data translation latency if they use decentalised architecture. Further, these group <b>rekeying</b> protocols add communication as well as computational overhead in every group member and in the group key controller (GKC) of the group. This proposed work develops an efficient group <b>rekeying</b> solution that follows an adaptive group <b>rekeying</b> architecture. This adaptive group <b>rekeying</b> architecture provides a good tradeoff between the one affects all phenomena and the data translation latency. This method uses an enhanced one way function tree (EOFT) algorithm based on the Chinese remainder theorem for group <b>rekeying.</b> EOFT has minimum computational overhead and communicational overhead particularly during the join of the members in the group. Key words: data translation latency, enhanced one way function tree, group key controller, <b>rekeying</b> the group ke...|$|R
40|$|This paper {{describes}} {{support for}} batch <b>rekeying</b> in Mykil, a {{key management system}} for supporting secure group multicast. Batch <b>rekeying</b> in Mykil allows for substantial reductions in the cost and complexity of <b>rekeying</b> operations, arguably the expensive portion of the system. By accumulating join and leave operations and utilizing an algorithmic approach to minimize the number of necessary <b>rekeying</b> messages, Mykil can achieve a marked reduction in the total number and size of messages and can significantly streamline the system’s operation...|$|R
50|$|EDI {{and other}} similar {{technologies}} save a company money by providing an alternative to, or replacing, information flows that require {{a great deal of}} human interaction and paper documents. Even when paper documents are maintained in parallel with EDI exchange, e.g. printed shipping manifests, electronic exchange and the use of data from that exchange reduces the handling costs of sorting, distributing, organizing, and searching paper documents. EDI and similar technologies allow a company {{to take advantage of the}} benefits of storing and manipulating data electronically without the cost of manual entry. Another advantage of EDI is the opportunity to reduce or eliminate manual data entry errors, such as shipping and billing errors, because EDI eliminates the need to <b>rekey</b> documents on the destination side. One very important advantage of EDI over paper documents is the speed in which the trading partner receives and incorporates the information into their system thus greatly reducing cycle times. For this reason, EDI can be an important component of just-in-time production systems.|$|E
50|$|To <b>rekey</b> a lock {{you have}} to first remove the lock {{cylinder}} from any housing it rests in. The lock cylinder must be disassembled, and the plug removed. Use a plug follower to avoid dropping master-wafers, top pins and springs. The plug has cylindrical chambers spaced according to manufacturer specifications. Pins are contained in these chambers where they are pushed down by springs or raised by a key. Each cut sits under a chamber of its own, each pin sits on a cut of its own. Place the correct pins in each chamber, bringing {{the top of each}} new pin flush with the shear-line. Check the upper chambers using a master-follower for old unused master wafers and remove any. If any springs are noticeably weak or the lock was especially dirty replace the springs. If the old pins are rounded from use or otherwise show excessive wear replace springs. Reinsert the plug taking care not to drop top pins into any unused chamber. Test key, make slight adjustments if needed and reassemble.|$|E
50|$|The {{basis of}} the attack is an {{extension}} of the WEP chop-chop attack. Because WEP uses a cryptographically insecure checksum mechanism (CRC32), an attacker can guess individual bytes of a packet, and the wireless access point will confirm or deny whether or not the guess is correct. If the guess is correct, the attacker will be able to detect the guess is correct and continue to guess other bytes of the packet. However, unlike the chop-chop attack against a WEP network, the attacker must wait for at least 60 seconds after an incorrect guess (a successful circumvention of the CRC32 mechanism) before continuing the attack. This is because although TKIP continues to use the CRC32 checksum mechanism, it implements an additional MIC code named Michael. If two incorrect Michael MIC codes are received within 60 seconds, the access point will implement countermeasures, meaning it will <b>rekey</b> the TKIP session key, thus changing future keystreams. Accordingly, attacks on TKIP will wait an appropriate amount of time to avoid these countermeasures. Because ARP packets are easily identified by their size, {{and the vast majority of}} the contents of this packet would be known to an attacker, the number of bytes an attacker must guess using the above method is rather small (approximately 14 bytes). Beck and Tews estimate recovery of 12 bytes is possible in about 12 minutes on a typical network, which would allow an attacker to transmit 3-7 packets of at most 28 bytes. Vanhoef and Piessens improved this technique by relying on fragmentation, allowing an attacker to transmit arbitrary many packets, each at most 112 bytes in size. The Vanhoef-Piessens attacks also can be used to decrypt arbitrary packets of the attack's choice.|$|E
40|$|Abstract—The {{problem of}} {{controlling}} access to multimedia multicasts requires {{the distribution and}} maintenance of keying information. Typically, the problem of key management is considered separately from the problem of distributing the <b>rekeying</b> messages. Multimedia sources provide two approaches to distributing the <b>rekeying</b> messages associated with securing group communication. The first, and more conventional, approach employs {{the use of a}} media-independent channel to convey <b>rekeying</b> messages. We propose, however, a second approach that involves the use of a media-dependent channel, and is achieved for multimedia by using data embedding techniques. Compared to a media-independent channel, the use of data embedding to convey <b>rekeying</b> messages provides enhanced security by masking the presence of <b>rekeying</b> operations. This covert communication makes it difficult for an adversary to gather information regardin...|$|R
40|$|The more {{wireless}} sensor networks grow, {{the more}} effective security mechanisms are needed. This paper suggests a cryptographic key-management protocol, Energy-Efficient Key-Management protocol. Using a location-based group key allocation, the proposed protocol provides the revocation of compromised nodes and energy-efficient <b>rekeying.</b> Our protocol is motivated by the observation that unicast-based <b>rekeying</b> does not satisfy the security requirements of periodic <b>rekeying</b> in {{wireless sensor networks}}. Our protocol provides broadcast-based <b>rekeying</b> for low-energy key management and high resilience. In addition, to increase the complexity of encryption keys, the protocol uses a dynamic composition key scheme. Our protocol provides group management protocols for secure group communication. We compared the energy efficiency of our protocol to other protocols with the <b>rekeying</b> and revocation messages and simulated them...|$|R
40|$|Many {{emerging}} web and Internet {{applications are}} based on a group communications model. Thus, securing group communications is an important Internet design issue. The key graph approach has been proposed for group key management. Key tree and key star are two important types of key graphs. Previous work has been focused on individual <b>rekeying,</b> i. e., <b>rekeying</b> after each join or leave request. In this paper, we first identify two problems with individual rekeying: inefficiency and an out-of-sync problem between keys and data. We then propose the use of periodic batch <b>rekeying</b> which can improve efficiency and alleviate the out-of-sync problem. We devise a marking algorithm to process a batch of join and leave requests. We then analyze the key server's processing cost for batch <b>rekeying.</b> Our results show that batch <b>rekeying,</b> compared to individual <b>rekeying,</b> saves server cost substantially. We also show that when the number of requests in a batch is not large, the best key tree degree is four; otherwise, key star (a special key tree with root degree equal to group size) outperforms small-degree key trees. Keywords: Secure group communications, group key management, <b>rekeying.</b> 1...|$|R
40|$|In secure group communications, {{there are}} both <b>rekey</b> and data traffic. We propose to use application-layer {{multicast}} to support concurrent <b>rekey</b> and data transport. <b>Rekey</b> traffic is bursty and requires fast delivery. It is desired to reduce <b>rekey</b> bandwidth overhead {{as much as}} possible since it competes for bandwidth with data traffic. Towards this goal, we propose a multicast scheme that exploits proximity in the underlying network. We further propose a <b>rekey</b> message splitting scheme to significantly reduce <b>rekey</b> bandwidth overhead at each user access link and network link. We formulate and prove correctness properties for the multicast scheme and <b>rekey</b> message splitting scheme. We have conducted extensive simulations to evaluate our approach. Our simulation results show that our approach can reduce <b>rekey</b> bandwidth overhead from several thousand encrypted new keys (encryptions, in short) to less than ten encryptions for more than 90 % of users in a group of 1024 users. ...|$|E
40|$|Abstract: Secure group {{communication}} {{has become an}} important network issue as more emerging network applications now are basedon a {{group communication}} model. In a dynamic network, a group membership can be changed dynamically. That is, new members can join and current members can leave at any time. Instead of individual rekeying, i. e., performinga <b>rekey</b> right aftereachjoin or leave request is received, periodic batch rekeying has been proposed to alleviate rekeying overhead in resourceconstrained wireless networks. The issue ofhow often <b>rekey</b> operations should be performed, however, has not been addressed. In this paper, we develop a Stochastic Petri Net (SPN) model to identify the optimal batch <b>rekey</b> interval to minimize periodic <b>rekey</b> overhead while satisfying application-specific constraints in <b>rekey</b> delay and secrecy violation. We develop three new threshold-based schemes, demonstrate the optimal <b>rekey</b> intervals for these three schemes, and identify the bestscheme that should be adopted forperiodic batch rekeying to minimize <b>rekey</b> overhead, when given a set ofparameter values characterizing the operational andenvironmental conditions. 1...|$|E
40|$|In secure group communications, {{users of}} a group share a common group key. A key server sends the group key to {{authorized}} new users as well as performs group rekeying for group users whenever the key changes. In this paper, we investigate scalability issues of reliable group rekeying, and provide a performance analysis of our group key management system (called keygem) based upon the use of key trees. Instead of rekeying after each join or leave, we use periodic batch rekeying to improve scalability and alleviate out-of-sync problems among <b>rekey</b> messages {{as well as between}} <b>rekey</b> and data messages. Our analyses show that batch rekeying can achieve large performance gains. We then investigate reliable multicast of <b>rekey</b> messages using proactive FEC. We observe that <b>rekey</b> transport has an eventual reliability and a soft real-time requirement, and that the <b>rekey</b> workload has a sparseness property, that is, each group user only needs to receive {{a small fraction of the}} packets that carry a <b>rekey</b> message sent by the key server. We also investigate tradeoffs between server and receiver bandwidth requirements versus group <b>rekey</b> interval, and show how to determine the maximum number of group users a key server can support. # Research sponsored in part by NSF grant no. ANI- 9977267 and NSA INFOSEC University Research Program grant no. MDA 904 - 98 -C-A 901. Experiments were performed on equipment procured with NSF grant no. CDA- 9624082. An abbreviated version of this report appears in Proceedings ACM SIGCOMM 2001, San Diego, August 2001. 1...|$|E
30|$|Next, we {{investigated}} {{the impact of}} the <b>rekeying</b> rate requested by the MNN in the signaling cost over the wireless link. In this case, as the HIP–NEMO protocol does not solve the situation where <b>rekeying</b> coincides with mobility, i.e., the MR is not in charge of <b>rekeying</b> the end-to-end association when a mobility event takes place, we assume that in the HIP–NEMO protocol the MNNs request <b>rekeying</b> at their own initiative with a higher frequency than in the NeMHIP protocol. This procedure is assumed because the policy of <b>rekeying</b> should be rapid enough to prevent vulnerabilities related to mobility events. The rationale behind this assumption is that MNNs are oblivious to mobility. By assuming this behavior, we can evaluate the performance of both protocols on equal terms with respect to security support.|$|R
40|$|An {{important}} {{problem for}} secure group communica-tion is key distribution. Most of the centralized group key management schemes employ high <b>rekeying</b> cost. Here we introduce {{a novel approach}} for computation efficient <b>rekeying</b> for multicast key distribution. This approach reduces the <b>rekeying</b> cost by employing a hybrid group key management scheme (involving both centralized and contributory key management schemes). The group controller uses the MDS Codes, a class of error control codes, to distribute the multicast key dynamically. In order to avoid frequent <b>rekeying</b> as and when the user leaves, a novel approach is introduced where clients recompute the new group key with minimal computation. This approach ensures forward secrecy as well as backward secrecy and significantly reduces the <b>rekeying</b> cost and communication cost. This scheme well suits wireless applications where portable devices require low computation...|$|R
40|$|An {{imperative}} {{issue for}} secure gathering openness {{is of the}} utmost importance dissemination. The majority of the incorporated gathering key administration plans utilize high <b>rekeying</b> expense. Here we present a novel methodology for calculation productive <b>rekeying</b> for multicast key conveyance. This methodology diminishes the <b>rekeying</b> expense by utilizing a mixture gathering key administration plan (including both concentrated and contributory key administration plans). The gathering controller uses the MDS Codes, a class of blunder control codes, to circulate the multicast key powerfully. Keeping in mind the end goal to maintain a strategic distance from successive <b>rekeying</b> as and when the client leaves, a novel methodology is presented where customers recompute the new gathering key with negligible calculation. This methodology guarantees forward mystery and additionally in reverse mystery and fundamentally lessens the <b>rekeying</b> expense and correspondence cost. This plan well suits remote applications where compact gadgets require low calculation...|$|R
40|$|The Logical Key Hierarchy (LKH) {{provides}} a scalable and {{efficient way to}} distribute session keys to authorized group members in secure group (multicast) communication. However, because multicast is a best-effort service, it requires additional mechanism to ensure that every member receives the <b>rekey</b> information. To solve this problem, several FEC-based schemes have been proposed. Although these schemes significantly enhance {{the reliability of the}} <b>rekey</b> transmissions, they require significant additional resources at the key server. In this paper we propose a distributed scheme for recovering lost <b>rekey</b> packets. Our scheme allows each member to contact other members to get the missing packets during <b>rekey</b> events, thus avoiding the extra computation and bandwidth resources at the key server. We compare our scheme with a well-known FEC scheme with respect to latencies experienced by receivers in reasonably large groups. Results show that our scheme yields lower average and 95 th-percentile latencies than the FEC-based scheme across several operating regimes...|$|E
40|$|Abstract: Logical Key Hierarchy (LKH) is a {{basic method}} in secure {{multicast}} group rekeying. LKH maintains a balanced tree which provide uniform cost of O(log N) for compromise recovery, where N is group size. However, it does not distinguish the behavior of group members {{even though they have}} different probabilities of join or leave. When members have diverse changing probability the gap between LKH and the optimal rekeying algorithm will become bigger. The Probabilistic optimization of LKH (PLKH) scheme, optimized <b>rekey</b> cost by organizing LKH tree with user <b>rekey</b> characteristic. In this paper, we concentrate on further reducing the <b>rekey</b> cost by organizing LKH tree with respect to compromise probabilities of members using new join and leave operations. Simulation results show that our scheme performs 18 % to 29 % better than PLKH and 32 % to 41 % better than LKH. ...|$|E
40|$|This report {{contains}} {{a discussion of}} the difficult problem of key management for multicast communication sessions. It focuses on two main areas of concern with respect to key management, which are, initializing the multicast group with a common net key and rekeying the multicast group. A <b>rekey</b> may be necessary upon the compromise of a user or for other reasons (e. g., periodic <b>rekey).</b> In particular, this report identifies a technique which allows for secure compromise recovery, while also being robust against collusion of excluded users. This is one important feature of multicast key management which has not been addressed in detail by most other multicast key management proposals [1, 2, 4]. The benefits of this proposed technique are that it minimizes the number of transmissions required to <b>rekey</b> the multicast group and it imposes minimal storage requirements on the multicast group...|$|E
40|$|Secure {{multicast}} provides efficient delivery {{which includes}} an identical {{data from a}} source to multiple receivers. A common solution is to apply a symmetric key {{that is used to}} encrypt the transmitted data. However, the heavy cost of the <b>rekeying</b> process is the main problem in large and dynamic multicast groups. The tree-based architecture is widely used to reduce the <b>rekeying</b> cost in terms of storage, transmission and computation. However, it usually requires extra overhead to keep key tree balance which is in order to achieve logarithmic <b>rekeying</b> cost. In this paper, we shall propose a new RSA-like multicast key management scheme to solve the <b>rekeying</b> problem. Our protocol applies a star-based architecture to eliminate the <b>rekeying</b> processes and provide the good performance when the membership changes in a multicast group. Furthermore, we also provide an extended multicast scheme, in which we combine public-key and symmetric-key cryptosystems to enhance the performance of multicast encryption...|$|R
40|$|Problem statement: Secure group {{communication}} {{is very important}} for many applications such as internet pay sites. It provides efficient delivery of identical data to only the customers in the group. In large and dynamic multicast groups, the group keys of members have to be changed frequently whenever the member leaves or joins. A common method is to apply a symmetric key that is used to encrypt the transmitted data. The <b>rekeying</b> cost scales linearly with the number of members in the group and cost of the <b>rekeying</b> process is the main issue. The tree-based architecture is commonly used to reduce the <b>rekeying</b> cost in terms of storage, transmission and computation. But it usually gives extra overhead to balance the tree which is in order to achieve logarithmic <b>rekeying</b> cost. Approach: The main aim was to use star topology based architecture to avoid the balancing and eliminate the <b>rekeying</b> processes and more over it was more secured by exchanging the secret key between only server and each group member. The features of proposed algorithm were that the private key was computed by individual member. Results: The burden of server was reduced and also there was no <b>rekeying</b> when a member leaves the group. The secret value of leaving member was not added in the encryption and so the private value could not be obtained after decryption. Conclusion: Proposed algorithm is simple and no <b>rekeying</b> when a member leaves and also reduces the computation and communication complexity...|$|R
40|$|Scalable group <b>rekeying</b> {{is one of}} {{the biggest}} {{challenges}} that need to be addressed to support secure communications for large and dynamic groups. In recent years, many group key management approaches based on the use of logical key trees have been proposed to address this issue. Using logical key trees reduces the complexity of group <b>rekeying</b> operation from O(N) to O(logN), where N is the group size. In this paper, we present two optimizations for logical key tree organizations that utilize information about the characteristics of group members to further reduce the overhead of group <b>rekeying.</b> First, we propose a partitioned key tree organization that exploits the temporal patterns of group member joins and departures to reduce the overhead of <b>rekeying.</b> Using an analytic model, we show that our optimization can achieve up to 31. 4 % reduction in key server bandwidth overhead over the un-optimized scheme. Second, we propose an approach under which the key tree is organized based on the loss probabilities of group members. Our analysis shows this optimization can reduce the <b>rekeying</b> overhead by up to 12. 1 %...|$|R
40|$|The Subset Difference Rekeying (SDR) method [8] is {{the most}} {{efficient}} stateless group rekeying method proposed in the literature. We study two important {{issues related to the}} SDR method. First, we address the issue of reliable <b>rekey</b> transport for SDR. We present a key distribution scheme, called FEC-BKR, that enables members to receive the current group key in a reliable and timely fashion despite packet losses in the network. Through simulation, we show that in most scenarios, FEC-BKR outperforms previously proposed schemes for reliable <b>rekey</b> transport. Second, we address the issue of self-healing key distribution for SDR. We present a group key recovery scheme that adds the self-healing property to SDR, i. e., our scheme enables a member that has missed up to a certain number m of previous <b>rekey</b> operations to recover the missing group keys without asking the key server for retransmission. The additional communication overhead imposed by our key recovery scheme is quite small (less than 3 m additional keys) ...|$|E
30|$|The {{demand of}} being MNNs {{oblivious}} to mobility events {{to simplify the}} handover procedures comes face-to-face {{with the need to}} <b>rekey</b> the end-to-end association when a mobility event that results in changing the IP address occurs. Since MNNs do not know that a mobility event has happened, they will not <b>rekey</b> the end-to-end associations, and so, security vulnerabilities related to mobility would still be present. A straightforward solution would be to inform the MNNs to conduct end-to-end SA updates, but this would result in an unmanageable signaling cost; i.e., the advantages of delegating signaling rights would be lost.|$|E
40|$|We {{present the}} design and {{specification}} of a protocol for scalable and reliable group rekeying together with performance evaluation results. The protocol {{is based upon the}} use of key trees for secure groups and periodic batch rekeying. At the beginning of each <b>rekey</b> interval, the key server sends a <b>rekey</b> message to all users consisting of encrypted new keys (encryptions, in short) carried in a sequence of packets. We present a scheme for identifying keys, encryptions, and users, and a key assignment algorithm that ensures that the encryptions needed by a user are in the same packet. Our protocol provides reliable delivery of new keys to all users eventually. It also attempts to deliver new keys to all users with a high probability {{by the end of the}} <b>rekey</b> interval. For each <b>rekey</b> message, the protocol runs in two steps: a multicast step followed by a unicast step. Proactive forward error correction (FEC) multicast is used to reduce delivery latency. Our experiments show that a small FEC block size can be used to reduce encoding time at the server without increasing server bandwidth overhead. Early transition to unicast, after at most two multicast rounds, further reduces the worst-case delivery latency as well as user bandwidth requirement. The key server adaptively adjusts the proactivity factor based upon past feedback information; our experiments show that the number of NACKs after a multicast round can be effectively controlled around a target number. Throughout the protocol design, we strive to minimize processing and bandwidth requirements for both the key server and users...|$|E
40|$|In this paper, {{we focus}} on {{tradeoffs}} between storage cost and <b>rekeying</b> cost for secure multicast. Specifically, we present a family of algorithms that provide a tradeoff {{between the number of}} keys maintained by users and the time required for <b>rekeying</b> due to revocation of multiple users. We show that some well known algorithms in the literature are members of this family. We show that algorithms in this family can be used to reduce the cost of <b>rekeying</b> by 43 % − 79 % when compared with previous solutions while keeping the number of keys manageable...|$|R
40|$|Abstract: In mobile {{multihop}} relay (MMR) networks, Relay multicast <b>rekeying</b> algorithm (RMRA) {{is meant}} to ensure secure multicast communication and selective updating of keys in MMR networks. However, in RMRA, the <b>rekeying</b> is carried out after a specific interval of time, which cannot ensure the security for multicast communication on joining the member. Secondly, the <b>rekeying</b> scheme generates a huge communication overhead on the serving multihop relay base station (MR-BS) on frequent joining of members. Lastly, there is nothing about when a member left the group communication. Thus, the <b>rekeying</b> scheme of RMRA fails to provide forward and backward secrecy and also is not scalable. To solve this problem, an improved <b>rekeying</b> scheme based on broadcasting a new seed value on joining and leaving of a member for updating the ongoing key management is proposed. The proposed scheme solves the issue of forward and backward secrecy and the scalability in a very simplified way. The forward and backward secrecy of the proposed scheme has been extensively validated by formal method using rank theorem. Furthermore, mathematical derivation showed that the proposed scheme out-performed the RMRA in terms of communication cost and complexity...|$|R
40|$|Group {{communication}} is a suitable and effective communication model for large-scale distributed systems. To be fully exploitable, group communication must be protected. This is normally achieved by providing members {{with a group}} key which is revoked and redistributed upon every member's joining (backward security) or leaving (forward security). Such a <b>rekeying</b> process must be efficient and highly scalable. In this paper, we present HISS, a highly scalable group <b>rekeying</b> scheme that efficiently <b>rekeys</b> the group into two broadcast <b>rekeying</b> messages. HISS features two novel contributions. First, it exhibits a <b>rekeying</b> cost which is constant and independent of the group size, thus being highly scalable {{with the number of}} users. At the same time, memory occupancy and computational overhead are affordable on customary platforms. Second, HISS considers collusion as a first-class attack and recovers the group {{in such a way that}} it does not require a total group recovery. Efficiency of collusion recovery gracefully decreases with the attack severity. We prove the correctness of HISS, analytically evaluate its performance and argue that it is deployable on customary platforms. Finally, we show that it is possible to practically contrast or even prevent collusion attacks by properly allocating users to subgroups...|$|R
