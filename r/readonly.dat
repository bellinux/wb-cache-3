72|0|Public
5000|$|Partial Class MyClass Public <b>Readonly</b> Property Name (...) As String Get Return _name End Get End PropertyEnd ClassWhen compiled, {{the result}} is the same as if the two files were written as one, like this:Class MyClass Private _name As String Public <b>Readonly</b> Property Name (...) As String Get Return _name End Get End PropertyEnd Class ...|$|E
5000|$|... {{namespace}} DesignPattern.Facade.Sample{ // The 'Subsystem ClassA' class class CarModel { public void SetModel (...) { Console.WriteLine(" [...] CarModel - SetModel"); } } /// [...] /// The 'Subsystem ClassB' class /// [...] class CarEngine { public void SetEngine (...) { Console.WriteLine(" [...] CarEngine - SetEngine"); } } // The 'Subsystem ClassC' class class CarBody { public void SetBody (...) { Console.WriteLine(" [...] CarBody - SetBody"); } } // The 'Subsystem ClassD' class class CarAccessories { public void SetAccessories (...) { Console.WriteLine(" [...] CarAccessories - SetAccessories"); } } // The 'Facade' class public class CarFacade { private <b>readonly</b> CarAccessories accessories; private <b>readonly</b> CarBody body; private <b>readonly</b> CarEngine engine; private <b>readonly</b> CarModel model; public CarFacade (...) { accessories = new CarAccessories (...) body = new CarBody (...) engine = new CarEngine (...) model = new CarModel (...) } public void CreateCompleteCar (...) { Console.WriteLine("******** Creating a Car **********"); model.SetModel (...) engine.SetEngine (...) body.SetBody (...) accessories.SetAccessories (...) Console.WriteLine("******** Car {{creation is}} completed. **********"); } } // Facade pattern demo class Program { static void Main(string args) { var facade = new CarFacade (...) facade.CreateCompleteCar (...) Console.ReadKey (...) } }} ...|$|E
5000|$|... {{namespace}} DesignPattern.Facade{ class SubsystemA { public string OperationA1 (...) {≈≠ return [...] "Subsystem A, Method A1\n"; } public string OperationA2 (...) { return [...] "Subsystem A, Method A2\n"; } } class SubsystemB {−← public string OperationB1 (...) {— return [...] "Subsystem B, Method B1\n"; } public string OperationB2 (...) { return [...] "Subsystem B, Method B2\n"; } } class SubsystemC { public string OperationC1 (...) { return [...] "Subsystem C, Method C1\n"; } public string OperationC2 (...) { return [...] "Subsystem C, Method C2\n"; } } public class Facade { private <b>readonly</b> SubsystemA a = new SubsystemA (...) private <b>readonly</b> SubsystemB b = new SubsystemB (...) private <b>readonly</b> SubsystemC c = new SubsystemC (...) public void Operation1 (...) { Console.WriteLine("Operation 1\n" [...] + a.OperationA1 (...) + b.OperationB1 (...) + c.OperationC1 (...) [...] ); } public void Operation2 (...) { Console.WriteLine("Operation 2\n" [...] + a.OperationA2 (...) + b.OperationB2 (...) + c.OperationC2 (...) [...] ); } }} ...|$|E
5000|$|C# {{has both}} a [...] and a [...] qualifier; its const {{is only for}} compile-time constants, while <b>readonly</b> {{can be used in}} constructors and other runtime applications.|$|E
5000|$|Public Class Animal Public Shared <b>ReadOnly</b> Empty As Animal = New AnimalEmpty (...) Public Overridable Sub MakeSound (...) Console.WriteLine("Woof!") End SubEnd ClassFriend NotInheritable Class AnimalEmpty Inherits Animal Public Overrides Sub MakeSound (...) ' [...] End SubEnd Class ...|$|E
5000|$|The memento pattern {{allows one}} to capture the {{internal}} state of an object without violating encapsulation such that later one can undo/revert the changes if required. Here one {{can see that the}} memento object is actually used to revert the changes made in the object.//original objectpublic class OriginalObject{ private Memento MyMemento; public string String1 { get; set; } public string String2 { get; set; } public OriginalObject(string str1, string str2) { this.String1 = str1; this.String2 = str2; this.MyMemento = new Memento(str1, str2); } public void Revert (...) { this.String1 = this.MyMemento.string1; this.String2 = this.MyMemento.string2; }} //Memento objectpublic class Memento{ public <b>readonly</b> string string1; public <b>readonly</b> string string2; public Memento(string str1, string str2) { this.string1 = str1; this.string2 = str2; }} ...|$|E
5000|$|The MBR {{register}} is a <b>readonly</b> register, and {{it contains}} 2 control lines. Since {{it is an}} 8-bit register, its output {{is connected to the}} least significant 8 bits of the B bus. It can be set to provide its output in 2 ways: ...|$|E
5000|$|... class Program { static void Main (...) { var player = new Player (...) player.Update (...) player.Collide (...) player.Draw (...) }}interface IVisible { void Draw (...)}class Invisible : IVisible { public void Draw (...) { Console.Write("I won't appear."); }}class Visible : IVisible { public void Draw (...) { Console.Write("I'm showing myself."); }}interface ICollidable { void Collide (...)}class Solid : ICollidable { public void Collide (...) { Console.Write("Bang!"); }}class NotSolid : ICollidable { public void Collide (...) { Console.Write("Splash!"); }}interface IUpdatable { void Update (...)}class Movable : IUpdatable { public void Update (...) { Console.Write("Moving forward."); }}class NotMovable : IUpdatable { public void Update (...) { Console.Write("I'm staying put."); }}abstract class GameObject : IVisible, IUpdatable, ICollidable { private <b>readonly</b> IVisible _v; private <b>readonly</b> IUpdatable _u; private <b>readonly</b> ICollidable _c; public GameObject(IVisible visible, IUpdatable updatable, ICollidable collidable) { _v = visible; _u = updatable; _c = collidable; } public void Update (...) { _u.Update (...) } public void Draw (...) { _v.Draw (...) } public void Collide (...) { _c.Collide (...) }}class Player : GameObject { public Player (...) : base(new Visible (...) , new Movable (...) , new Solid (...) [...] ) { }}class Cloud : GameObject { public Cloud (...) : base(new Visible (...) , new Movable (...) , new NotSolid (...) [...] ) { }}class Building : GameObject { public Building (...) : base(new Visible (...) , new NotMovable (...) , new Solid (...) [...] ) { }}class Trap : GameObject { public Trap (...) : base(new Invisible (...) , new NotMovable (...) , new Solid (...) [...] ) { }} ...|$|E
50|$|For ULA prefixes, SixXS used to {{maintain}} a voluntary registration database {{to reduce the risk}} of duplicates. As such a database is neither standardized nor mandated, it reduces the risk of duplicates, but it can never eliminate it altogether. When the SixXS services were discontinued per 6 June 2017, the database became <b>readonly.</b>|$|E
50|$|In C# a {{class is}} a {{reference}} type while a struct (concept {{derived from the}} struct in C language) is a value type. Hence an instance derived from a class definition is an object while an instance derived from a struct definition {{is said to be}} a value object (to be precise a struct can be made immutable to represent a value object declaring attributes as <b>readonly).</b>|$|E
50|$|New in Microsoft Dynamics CRM 4.0 are <b>readonly</b> licenses. Users that do {{not have}} to have write permissions can be {{assigned}} Read Only licenses. These licenses are cheaper because they do not allow any write operations on the records. If later a user should be able to perform a write operation, a step-up license can be bought to upgrade the Read-Only license to a Full Client Access License.|$|E
5000|$|A10 (Unvalidated redirects {{and forward}}s) : Web {{applications}} frequently redirect and forward users to other pages and websites, and use untrusted data {{to determine the}} destination pages. Without proper validation, attackers can redirect victims to phishing or malware sites, or use forwards to access unauthorized pages. This vulnerability is mainly related with the manipulation of <b>readonly</b> data or data generated previously at server side. HDIV controls all the data server by the server and does not allow the redirection to malicious web sites.|$|E
5000|$|... #include [...] "class.ch"//// This program prints://// Missy Meow!// Mr. Bojangles Meow!// Lassie Bark!// Press any key to continue.../////////////////////////////////PROCEDURE Main (...) /////////////////////////////// LOCAL aAnimals := Array(3) LOCAL i aAnimals1 := Cat (...) :New("Missy") aAnimals2 := Cat (...) :New("Mr. Bojangles") aAnimals3 := Dog (...) :New("Lassie") FOR i:=1 TO LEN(aAnimals) ? aAnimalsi:Name + [...] " [...] " [...] + aAnimalsi:Talk (...) NEXT i WAITRETURN///////////////////////////////CLASS Animal/////////////////////////////// EXPORTED: VAR Name <b>READONLY</b> METHOD Init DEFERRED CLASS METHOD TalkENDCLASSMETHOD Animal:Init( [...] cName [...] ) ::Name := cNameRETURN Self///////////////////////////////CLASS Dog FROM Animal/////////////////////////////// EXPORTED: METHOD TalkENDCLASSMETHOD Dog:Talk (...) RETURN [...] "Bark!"///////////////////////////////CLASS Cat FROM Animal/////////////////////////////// EXPORTED: METHOD TalkENDCLASSMETHOD Cat:Talk (...) RETURN [...] "Meow!" ...|$|E
5000|$|... public class CoffeeFlavour { private <b>readonly</b> string _flavour; public CoffeeFlavour(string flavour) { _flavour = flavour; } public string Flavour { get { return _flavour; } } public {{override}} bool Equals(object obj) { if (ReferenceEquals(null, obj)) return false; return obj is CoffeeFlavour && Equals((CoffeeFlavour)obj); } public bool Equals(CoffeeFlavour other) { return string.Equals(_flavour, other._flavour); } public override int GetHashCode (...) { return (_flavour != null ? _flavour.GetHashCode (...) : 0); } public static bool operator ==(CoffeeFlavour a, CoffeeFlavour b) { return Equals(a, b); } public static bool operator !=(CoffeeFlavour a, CoffeeFlavour b) { return !Equals(a, b); }} ...|$|E
5000|$|... 2. A dynaset is a {{temporary}} set of data taken from one or more tables in the underlying file. A dynaset may be a query that was defined in an Access database, a single table, a subset of a table, or the result of joining multiple tables. A dynaset can be updated if the file is not locked or opened for <b>ReadOnly.</b> The data in the dynaset are [...] "live" [...] i.e., any changes made to the data as a project (in Visual Basic) is executing {{will appear in the}} corresponding recordset. Note: Dynasets created from joining tables are typically non-updateable.|$|E
5000|$|... // compile as Console Application, {{requires}} C# 3.0 or higherusing System;using System.Linq;namespace MyExtensionWithExample { public static class StringExtensions { [...] public static int SafeGetLength(this string valueOrNull) { [...] return (valueOrNull ?? string.Empty).Length; [...] } } public static class Program { // define some strings static <b>readonly</b> string strings = new [...] { [...] "Mr X.", [...] "Katrien Duck", null, [...] "Q" [...] }; // {{write the}} total length {{of all the}} strings in the array public static void Main(string args) { var query = from text in strings select text.SafeGetLength (...) // no need to do any checks here Console.WriteLine(query.Sum (...) [...] ); } }}// The output will be:// 18 ...|$|E
5000|$|Additionally, {{one-dimensional}} {{arrays of}} these types (including unsafe fixed buffers) as well as complex types containing only instance fields (which includes <b>readonly</b> fields) {{of these types}} are blittable. The presence of static or const fields that are non-blittable does not cause the type to become non-blittable, because such fields play no part in marshalling. Complex types (that is structs or classes) must also have instance field layout of Sequential applied using the StructLayout attribute {{in order to be}} considered blittable by the [...]net marshaler. Structs have this attribute applied automatically by the compiler, but you must explicitly add it to a class definition if you want an otherwise blittable class to be blittable.|$|E
5000|$|Flyweight {{allows you}} to share bulky data that are common to each object. In other words, {{if you think that}} same data is repeating for every object, you can use this pattern to point to the single object and hence can easily save space. Here the FlyweightPointer creates a static member Company, which is used for every object of MyObject.// Defines Flyweight object that repeats itself.public class FlyWeight{ public string CompanyName { get; set; } public string CompanyLocation { get; set; } public string CompanyWebSite { get; set; } //Bulky Data public byte CompanyLogo { get; set; }}public static class FlyWeightPointer{ public static <b>readonly</b> FlyWeight Company = new FlyWeight { CompanyName = [...] "Abc", CompanyLocation = [...] "XYZ", CompanyWebSite = [...] "www.abc.com" [...] // Load CompanyLogo here };}public class MyObject{ public string Name { get; set; } public string Company { get { return FlyWeightPointer.Company.CompanyName; } }} ...|$|E
5000|$|... /* Null Object Pattern implementation: */using System;// Animal {{interface}} {{is the key}} to compatibility for Animal implementations below.interface IAnimal{ void MakeSound (...)}// Animal is {{the base}} case.abstract class Animal : IAnimal{ // A shared instance {{that can be used for}} comparisons public static <b>readonly</b> IAnimal Null = new NullAnimal (...) [...] // The Null Case: this NullAnimal class should be used in place of C# null keyword. private class NullAnimal : Animal { public override void MakeSound (...) { // Purposefully provides no behaviour. } } public abstract void MakeSound (...)}// Dog is a real animal.class Dog : IAnimal{ public void MakeSound (...) { Console.WriteLine("Woof!"); }}/* ========================= * Simplistic usage example in a Main entry point. */static class Program{ static void Main (...) { IAnimal dog = new Dog (...) dog.MakeSound (...) // outputs [...] "Woof!" [...] /* Instead of using C# null, use the Animal.Null instance. * This example is simplistic but conveys the idea that if the Animal.Null instance is used then the program * will never experience a [...]NET System.NullReferenceException at runtime, unlike if C# null were used. */ IAnimal unknown = Animal.Null; //<< replaces: IAnimal unknown = null; unknown.MakeSound (...) // outputs nothing, but does not throw a runtime exception [...] }} ...|$|E
5000|$|... using System.Runtime.InteropServices;namespace Hooks{ public class KeyHook { /* Member {{variables}} */ protected static int Hook; protected static LowLevelKeyboardDelegate Delegate; protected static <b>readonly</b> object Lock = new object (...) protected static bool IsRegistered = false; /* DLL imports */ DllImport("user32") private static extern int SetWindowsHookEx(int idHook, LowLevelKeyboardDelegate lpfn, int hmod, int dwThreadId); DllImport("user32") private static extern int CallNextHookEx(int hHook, int nCode, int wParam, KBDLLHOOKSTRUCT lParam); DllImport("user32") private static extern int UnhookWindowsHookEx(int hHook); /* Types & constants */ protected delegate int LowLevelKeyboardDelegate(int nCode, int wParam, ref KBDLLHOOKSTRUCT lParam); private const int HC_ACTION = 0; private const int WM_KEYDOWN = 0x0100; private const int WM_KEYUP = 0x0101; private const int WH_KEYBOARD_LL = 13; StructLayout(LayoutKind.Sequential) public struct KBDLLHOOKSTRUCT { public int vkCode; public int scanCode; public int flags; public int time; public int dwExtraInfo; } /* Methods */ static private int LowLevelKeyboardHandler(int nCode, int wParam, ref KBDLLHOOKSTRUCT lParam) { if (nCode == HC_ACTION) { if (wParam == WM_KEYDOWN) System.Console.Out.WriteLine("Key Down: [...] " [...] + lParam.vkCode); else if (wParam == WM_KEYUP) System.Console.Out.WriteLine("Key Up: [...] " [...] + lParam.vkCode); } return CallNextHookEx(Hook, nCode, wParam, lParam); } [...] public static bool RegisterHook (...) { lock (Lock) { if (IsRegistered) return true; Delegate = LowLevelKeyboardHandler; Hook = SetWindowsHookEx( [...] WH_KEYBOARD_LL, Delegate, Marshal.GetHINSTANCE( [...] System.Reflection.Assembly.GetExecutingAssembly (...) [...]GetModules (...) 0 [...] ).ToInt32 (...) , 0 [...] ); if (Hook != 0) return IsRegistered = true; Delegate = null; return false; } } public static bool UnregisterHook (...) { lock (Lock) { return IsRegistered = (UnhookWindowsHookEx(Hook) != 0); } } }} ...|$|E
40|$|This paper {{addresses}} {{the issue of}} ensuring consistency and currency of data items requested by wireless <b>readonly</b> transactions in data broadcast. To handle an inherent property in wireless data broadcast that data can only be accessed strictly sequential by users, a predeclaration-based query optimization is explored and a practical method, called PwA (Predeclaration with Autoprefetching), is devised for efficient wireless <b>readonly</b> transactions processing. The performance of the proposed method is also evaluated by an analytical study...|$|E
40|$|Javari is an {{extension}} of Java that supports reference immutability constraints. Pro-grammers write Javari type qualifiers, such as the <b>readonly</b> type qualifier, in their programs, and the Javari typechecker detects mutation errors (incorrect side effects) or verifies their absence. While case studies have demonstrated the practicality and value of Javari, a barrier to usability remains in the development process. A Javari program will not typecheck unless all the references in the APIs of libraries it uses are annotated with Javari type qualifiers. Manually converting existing Java libraries to Javari is both tedious and error-prone; the development process requires an auto-mated solution. This thesis presents an algorithm for statically inferring reference immutability in Javari. The flow-insensitive and context-sensitive algorithm is sound and produces a set of qualifiers that typecheck in Javari. The algorithm is precise in that it infers the most <b>readonly</b> qualifiers possible; adding any additional <b>readonly</b> qualifiers will caus...|$|E
40|$|A compiler-checked {{immutability}} guarantee provides useful doc-umentation, facilitates reasoning, and enables optimizations. This paper presents Immutability Generic Java (IGJ), a novel {{language extension}} that expresses immutability without changing Java’s syn-tax by building upon Java’s generics and annotation mechanisms. In IGJ, each class has one additional generic parameter that is Immutable, Mutable, or <b>ReadOnly.</b> IGJ guarantees both refer-ence immutability (only mutable references can mutate an object) and object immutability (an immutable reference {{points to an}} im-mutable object). IGJ is the first proposal for enforcing object im-mutability, and its reference immutability is more expressive than previous work. IGJ also permits covariant changes of generic ar-guments in a type-safe manner, e. g., a <b>readonly</b> list of integers is a subtype of a <b>readonly</b> list of numbers. IGJ extends Java’s type system with a few simple rules. We formalize this type system and prove it sound. Our IGJ compiler works by type-erasure and gen-erates byte-code that can be executed on any JVM without runtime penalty. 1...|$|E
40|$|Layered {{clustering}} offers cluster-like {{load balancing}} for unmodified NFS or CIFS servers. Read {{requests sent to}} a busy server can be offloaded to other servers holding replicas of the accessed files. This paper explores a key design question for this approach: which files should be replicated ? We find that the popular policy of replicating <b>readonly</b> files offers little benefit. A policy that replicates <b>readonly</b> portions of read-mostly files, however, implicitly coordinates with client cache invalidations and thereby allows almost all read operations to be offloaded. In a read-heavy trace, 75 % of all operations and 52 % of all data transfers can be offloaded...|$|E
40|$|Abstract. Javari is an {{extension}} of Java that supports reference immutability constraints. Programmers write <b>readonly</b> type qualifiers and other constraints, and the Javari typechecker detects mutation errors (incorrect side effects) or verifies their absence. While case studies have demonstrated the practicality and value of Javari, a barrier to usability remains. A Javari program will not typecheck unless all the references in the APIs of libraries it uses are annotated with Javari type qualifiers. Manually converting existing Java libraries to Javari is tedious and error-prone. We present an algorithm for inferring reference immutability in Javari. The flow-insensitive and context-sensitive algorithm is sound and produces a set of qualifiers that typecheck in Javari. The algorithm is precise in that it infers the most <b>readonly</b> qualifiers possible; adding any additional <b>readonly</b> qualifiers will cause the program to not typecheck. We have implemented the algorithm in a tool, Javarifier, that infers the Javari type qualifiers over a set of class files. Javarifier automatically converts Java libraries to Javari. Additionally, Javarifier eases the task of converting legacy programs to Javari by inferring the mutability of every reference in a program. In case studies, Javarifier correctly inferred mutability over Java programs of up to 110 KLOC. ...|$|E
40|$|Memory Management Units (MMUs) are {{traditionally}} used by operating systems to implement disk-paged virtual memory. Some operating systems allow user programs {{to specify the}} protection level (inaccessible, <b>readonly.</b> read-write) of pages, and allow user programs t. o handle protection violations. bur. these mechanisms are not. always robust, efficient, or well-mat. ched {{to the needs of}} applications...|$|E
40|$|We {{present a}} new static {{analysis}} to infer necessary field conditions for object-oriented programs. A necessary field condition is a property that should {{hold on the}} fields of a given object, for otherwise there exists a calling context leading to a failure due to bad object state. Our analysis also infers the provenance of the necessary condition, so that if a necessary field condition is violated then an explanation containing the sequence of method calls leading to a failing assertion can be produced. When the analysis is restricted to <b>readonly</b> fields, i. e., fields {{that can only be}} set in the initialization phase of an object, it infers object invariants. We provide empirical evidence on the usefulness of necessary field conditions by integrating the analysis into cccheck, our static analyzer for. NET. Robust inference of <b>readonly</b> object field invariants was the # 1 request from cccheck users...|$|E
40|$|Java’s type system {{provides}} programmers with strong guarantees of type and memory safety, {{but there are}} many important properties not captured by standard Java types. We describe JQual, a tool that adds user-defined type qualifiers to Java, allowing programmers to quickly and easily incorporate extra lightweight, application-specific type checking into their programs. JQual provides type qualifier inference, so that programmers need only add a few key qualifier annotations to their program, and then JQual infers any remaining qualifiers and checks their consistency. We explore two applications of JQual. First, we introduce opaque and enum qualifiers to track C pointers and enumerations that flow through Java code via the JNI. In our benchmarks we found that these C values are treated correctly, but there are some places where a client could potentially violate safety. Second, we introduce a <b>readonly</b> qualifier for annotating references that cannot be used to modify the objects they refer to. We found that JQual is able to automatically infer <b>readonly</b> in many places on method signatures. These results suggest that type qualifiers and type qualifier inference are a useful addition to Java. Categories and Subject Descriptors D. 2. 4 [Software Engineering]...|$|E
40|$|Memory Management Units (MMUs) are {{traditionally}} used by operating systems to implement disk-paged virtual memory. Some operating systems allow user programs {{to specify the}} protection level (inaccessible, <b>readonly,</b> read-write) of pages, and allow user programs to handle protection violations, but these mechanisms are not always robust, efficient, or well-matched {{to the needs of}} applications. We survey several user-level algorithms that make use of page-protection techniques, and analyze their common characteristics, in an attempt to answer the question, "What virtual-memory primitives should the operating system provide to user processes, and how well do today's operating systems provide them?"...|$|E
40|$|In {{database}} replication, primary-copy systems {{sort out}} easily {{the problem of}} keeping replicate data consistent by allowing only updates at the primary copy. While this kind of systems are very efficient with workloads dominated by read-only transactions, the update-everywhere approach is more suitable for heavy update loads. However, this approach adds a significant overload when working with <b>readonly</b> transactions. We propose a new database replication paradigm, halfway between primary-copy and update-everywhere approaches, which permits improving system performance adapting its configuration to the workload, thanks to a deterministic database replication protocol which ensures that broadcast writesets {{are always going to}} be committed...|$|E
40|$|SAS ® {{users can}} quickly and {{conveniently}} obtain useful {{information about their}} SAS session {{with a number of}} <b>readonly</b> SAS data views called DICTIONARY tables or DICTIONARY views. At any time during a SAS session, information about currently defined system options, libnames, table names, column names and attributes, formats, indexes, and more can be accessed and captured. This paper will explore the purpose of DICTIONARY tables and views, how they are accessed, and what information is available to SAS users. Attendees will learn how these important tables and views can be applied using real-world code examples...|$|E
40|$|The Java {{language}} {{lacks the}} important notions of ownership (an object owns its representation to prevent unwanted aliasing) and immutability (the division into mutable, immutable, and <b>readonly</b> data and references). Programmers {{are prone to}} design errors, such as representation exposure or violation of immutability contracts. This paper presents Ownership Immutability Generic Java (OIGJ), a backward-compatible purely-static language extension supporting ownership and immutability. We formally defined a core calculus for OIGJ, based on Featherweight Java, and proved it sound. We also implemented OIGJ and performed case studies on 33, 000 lines of code. Creation of immutable cyclic structures requires a “cooking phase ” in which the structure is mutated but the outsid...|$|E
40|$|One {{typically}} {{defines a}} read-only method {{as a method}} that does not perform any write operations; however, {{with respect to a}} multi-threaded program, we augment this interpretation and let a read-only method be one that does not write to a memory location visible to more than one thread. Such a method can execute concurrently with other read-only methods. With the relaxation of mutual exclusion in mind, we present a read-write analysis that employs the ideas of shape analysis and escape analysis to identify <b>readonly</b> methods in Java. Approximately 31 % of the methods in the JDK 1. 2 core libraries meets this definition of read-only [...] -nearly 50 % more than those that do not perform any write operations. ...|$|E
40|$|The JAVA {{language}} has no {{support for the}} important notions of ownership (an object owns its representation to prevent unwanted aliasing or modifications) and immutability (the division into mutable, immutable, and <b>readonly</b> data and references). Programmers are prone to design errors such as representation exposure or violation of immutability contracts. This paper presents Ownership Immutability Generic Java (OIGJ), a backward-compatible purely-static language extension supporting ownership and immutability. We formally defined the OIGJ typing rules and proved them sound. We also implemented OIGJ and performed case studies of 33, 000 lines of code. OIGJ is the first type system to unify the two main variants of ownership: owner-as-dominator, which restricts aliasing, and owner-as-modifier, which restricts modifications. Thus, the programmer has the flexibility to choose whether the representation of an object cannot leak (the object dominates the representation) or whether it may be freely shared as <b>readonly</b> (but only the owning object can modify it). OIGJ is easy for a programmer to use, and {{it is easy to}} implement (flow insensitive, using only 15 rules). Yet, OIGJ is more expressive than previous ownership languages, because it can type-check more good code. OIGJ can express the factory and visitor patterns, and OIGJ can type-check Sun’s java. util collections (excluding the clone method) without refactoring and with {{only a small number of}} annotations. Previous work required major refactoring of existing code in order to fit its ownership restrictions. Forcing refactoring of well-designed code is undesirable because it costs programmer effort, results in worse design, and hinders adoption in the mainstream community. [Copyright notice will appear here once ’preprint ’ option is removed. ...|$|E
40|$|Threshold voltage (Vth) {{behavior}} of nitride <b>readonly</b> memories (NROMs) was studied after irradiation with photons (γ- and X-rays), light and heavy ions. Both programmed and nonprogrammed single cells were investigated. The {{data suggest that}} two main physical phenomena are contributing to Vth variation and that the Vth loss and the variability can be modeled by a Weibull statistics with a shape parameter k 2. 2 regardless of the irradiation species and total dose. The same peculiarities were found in large memory arrays, confirming the results from single-cell studies but with significantly larger statistics. Hence, once the irradiation dose is known, the Vth loss distribution can be obtained, thus providing a predictive model of the radiation tolerance of NROM memory arrays...|$|E
40|$|Abstract In this paper, {{we propose}} an {{extensible}} architecture for database engines where satellite databases {{are used to}} scale out and implement additional functionality for a centralized database engine. The architecture uses a middleware layer that offers consistent views and a single system image over a cluster of machines with database engines. One of these engines acts as a master copy while the others are <b>readonly</b> snapshots which we call satellites. The satellites are lightweight DBMSs used for scalability and to provide functionality difficult or expensive to implement in the main engine. Our approach also supports the dynamic creation of satellites {{to be able to}} autonomously adapt to varying loads. The paper presents the architecture, discusses the research problems it raises, and validates its feasibility with extensive experimental results...|$|E
