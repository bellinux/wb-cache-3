42|140|Public
5000|$|It is more {{accurate}} (because the CRA doesn’t <b>re-key</b> the information, {{there is less}} chance of errors).|$|E
50|$|The {{different}} {{procedures for}} certificate application, issuance, acceptance, renewal, <b>re-key,</b> modification and revocation {{are a large}} part of the document. These procedures describe how each actor of the PKI has to act in order for the whole assurance level to be accepted.|$|E
5000|$|When {{cryptographic}} devices {{began to}} be used in large scale, those who had to update the key had to set a specific time to synchronize the <b>re-key.</b> This was accomplished at the hour (H) the Julian (J) Date changed, among crypto-accountants, managers and users the jargon [...] "HJ" [...] became the accepted term meaning it was time to change the crypto-key.|$|E
40|$|To enable secure Internet {{protocol}} (IP) multicasting, a scaleable {{and effective}} <b>re-keying</b> mechanism {{is required to}} safeguard the multicasted information. This paper presents a hybrid <b>re-keying</b> mechanism that combines {{the advantages of the}} centralized and distributed <b>re-keying</b> methods. Simulation results are presented to evaluate the performance in comparison with other <b>re-keying</b> methods. Department of ComputingOther conference pape...|$|R
40|$|This paper {{brings up}} a new concern {{regarding}} efficient <b>re-keying</b> of large groups with dynamic mem-bership: minimizing the overall {{time it takes for}} the key server and the group members to process the <b>re-keying</b> message. Specifically, we concentrate on <b>re-keying</b> algorithms based on the Logical Key Hier-archy (LKH), and minimize the longest sequence of encryptions and decryptions that need to be done in a <b>re-keying</b> operation. We first prove a lower bound on the time required to perform a <b>re-keying</b> opera-tion in this model, then we provide an optimal schedule of <b>re-keying</b> messages matching the above lower bound. In particular, we show that the optimal schedule can be found only when the ariety of the LKH key graph is chosen according to the available communication bandwidth and the users processing power. Our results show that key trees of ariety 3, commonly assumed to be optimal, are not optimal when used in high bandwidth networks, or networks of devices with low computational power like sensor networks. 1...|$|R
40|$|Problem statement: In {{this study}} we propose a group <b>re-keying</b> {{protocol}} based on modular polynomial arithmetic over Galois Field GF(2 n). Common secure group communications requires encryption/decryption for group <b>re-keying</b> process, especially when a group member is leaving the group. Approach: This study proposes secret keys multiplication protocol based on modular polynomial arithmetic (SKMP), which {{eliminates the need for}} the encryption/decryption during the group <b>re-keying.</b> Results: The implementation based on modular polynomial arithmetic over Galois Field GF(2 n) offers fast <b>re-keying</b> process (about 50 % faster than Secret Keys Multiplication Protocol (SKM) for 128 bit key) and compact key size representation against other secret keys multiplication protocols. Conclusion: With SKMP group <b>re-keying</b> is handled more efficiently through modular polynomial arithmetic manipulation rather than the expensive encryption/encryption which need to be done on every membership change...|$|R
50|$|Part of the {{popularity}} of American hardware stores is the range of services they provide. Most retail outlets only sell goods, while some hardware stores custom-make or repair a large variety of household items. It is common for a hardware store in the U.S. to repair broken windows and screens, repair power equipment such as lawn mowers, <b>re-key</b> entry locks, make copies of house keys and car keys, re-wire lamps and vacuum cleaners, sharpen knives and cutting tools, make minor repairs to faucet and shower parts, repair kerosene heaters and cut and thread plumbing pipe to sketch.|$|E
50|$|In {{order to}} use the new Prestel Mailbox service, the user went to page *7# which gave access to a set of frames where new “free format” {{messages}} could be created, or pre-formatted messages filled out and stored messages could be retrieved, and other related facilities were hosted. Many standard mailbox frames were available offering various designs for greetings cards or seasonal messages such as Valentine Cards. In order to compose a new message, a blank message frame, which could also be accessed directly via *77#, was displayed with the sender’s mailbox number pre-filled, leaving space for the recipient’s mailbox number and the text of the message itself. Messages could only occupy a single frame, so the main message text field could typically take up to a maximum of 100 words, depending upon how many other fields were required and what graphics were used on the frame. Mailbox frames were completed by entering relevant details and pressing the # key on each field. Completing the last, or only, of which lead to the request to “KEY 1 TO SEND KEY 2 NOT TO SEND”. Assuming all went well, this led to a subsequent final screen confirming successful dispatch, or if there were problems (such as a mistake in entering the Mailbox number) then an appropriate error frame was displayed. If it was desired to send the message to more than one recipient then it was necessary to <b>re-key</b> the message text into a fresh message frame, although some popular micro-computers of the time provided the facility to store the message so that it could be copied and pasted into a new message.|$|E
5000|$|Many {{standard}} mailbox frames {{were available}} offering various designs for greetings cards or seasonal messages such as Valentine Cards. Messages could only occupy a single frame, so the main message text field could typically {{take up to}} a maximum of 100 words, depending upon how many other fields were required and what graphics were used on the frame. Mailbox frames were completed by entering relevant details and pressing the # key on each field. Completing the last, or only, of which lead to the request to “KEY 1 TO SEND KEY 2 NOT TO SEND”. Assuming all went well, this led to a subsequent final screen confirming successful dispatch, or if there were problems (such as a mistake in entering the Mailbox number) then an appropriate error frame was displayed. If it was desired to send the message to more than one recipient then it was necessary to <b>re-key</b> the message text into a fresh message frame, although some popular micro-computers of the time provided the facility to store the message so that it could be copied and pasted into a new message.Special commands were also available. For example, to facilitate movement around the database it was possible to step back through a maximum of 3 frames or pages by use of the special key combination [...] "*#". In the event of corruption of a page in transmission it was possible to refresh the page by means of the code *00, which had the advantage of avoiding any page charge being raised again. Alternatively, if the user wished to update a page to see the latest information, for example of flight arrival times, the *09 command would retrieve the latest updates, at the same time re-billing any page display charge. If all else failed, a user could simply return to the first page which he saw after logging onto the system by use of the *0# combination, which brought up their default Main Index. Exceptionally, information could be hidden on a frame by an IP which could only be revealed by use of the ‘Reveal” key of the keypad (e.g., to show an answer to a quiz). The same 'Reveal' key was also used to hide the data once more.|$|E
40|$|Rather than use {{a shared}} key {{directly}} to cryptographically process (e. g. encrypt or authen-ticate) data {{one can use}} it as a master key to derive subkeys, and use the subkeys for the actual cryptographic processing. This popular paradigm is called <b>re-keying,</b> and the expectation is that it is good for security. In this paper we provide concrete security analyses of various <b>re-keying</b> mechanisms and their usage. We show that <b>re-keying</b> does indeed " security, eec-tively extending the lifetime of the master key and bringing signicant, provable security gains in practical situations. We quantify the security provided by dierent <b>re-keying</b> processes {{as a function of the}} security of the primitives they use, thereby enabling a user to choose betwee...|$|R
30|$|The caching {{of fresh}} pre-computed R 1 packet at LRVS optimizes the {{handover}} performance when <b>re-keying</b> is required {{because of a}} handover. Besides the <b>re-keying,</b> the HIP SA can be timeout. In both cases, the re-establishment of the HIP SA is required.|$|R
40|$|Abstract:- KQML {{is one of}} {{the most}} {{universal}} agent communication languages, but KQML have not defined security specifications to provide secure communication among agents. Firstly, this paper proposes a multi-agent secure communication protocol and three multi-agent group <b>re-keying</b> protocols. Secondly, it extends the base KQML to secure KQML which supports the secure communication protocol and multi-agent group <b>re-keying</b> protocols...|$|R
40|$|Abstract. This paper {{describes}} a secure multicast infrastructure for large-scale group communications in Mobile Internet and proposes a key management protocol {{based on the}} infrastructure. The multicast communication domain is logically divided into several administrative areas with a key server associated with each area. All the key servers participate in a Public Key Infrastructure (PKI) as trusted entities known by the subgroup members. Therefore, it’s efficient to minimize the <b>re-key</b> overhead implemented in the mobile host tier. The simulation {{results show that the}} proposed protocol has better performance compared to the centralized protocols without PKI support. The numbers of the real <b>re-key</b> messages and the <b>re-key</b> events are reduced to approximately 30 % and 65 %, respectively. ...|$|E
40|$|In this paper, {{we present}} two new {{centralized}} group key management protocols {{based on the}} Chinese Remainder Theorem (CRT). By shifting more computing load onto the key server we optimize the number of <b>re-key</b> broadcast messages, user-side key computation, and number of key storages. The first protocol is the base Chinese Remaindering Group Key (CRGK) protocol, which {{with a group of}} n users requires the key server to do O(n) XORs, additions, multiplications, and Extended Euclidean Algorithm computations and broadcast 1 <b>re-key</b> message; each individual user is required to do only 1 modulo arithmetic and 1 XOR operation for each group key update. The second protocol is the Fast Chinese Remaindering Group Key (FCRGK) protocol, which only requires the key server to do O(n) XORs, additions, and multiplications most of the times with no change to the number of <b>re-key</b> messages and user computation per group key update. For both protocols each user only needs to store 2 keys all the time. One special attraction for our FCRGK protocol is that it allows most of the re-keying computation to be done preemptively, which means when a user-join or user-leave event happens the response time for the key server to send out the new group key can be very short...|$|E
40|$|Abstract — Multicast is an {{efficient}} technique to deliver data {{to a large}} group of users. For some applications offering multicast security is an important issue. In such a system, a new member should not be able to decrypt the multicast data sent before its joining and a former member should not be able to decrypt the mulitcast data sent after its leaving. Traditional approaches generally focus on reducing the <b>re-key</b> messages for a single server. However, these approaches still lead to large exchange overhead when the group is large. In this paper, we consider a distributed server network in which the user pool is split into multiple groups and served by multiple servers. Given the user traffic, there is a trade-off between the amount of <b>re-key</b> messaging and the total data bandwidth needed. We present a simple model for the system and study how the total bandwidth (including the <b>re-key</b> messaging and data traffic) can be minimized by optimizing the number of servers in the network. As the underlying user traffic is dynamic, a server should be able to split and merge user groups to minimize its total bandwidth. We propose a scheme for such a purpose. We show that distributed server network is able to substantively reduce the total bandwidth required in the system as compared to the traditional scheme. Distributed Server Networks for Secure Multicast I...|$|E
40|$|In this paper, we {{describe}} {{a novel approach}} to scalable group <b>re-keying</b> for secure multicast. Our approach, which we call Kronos, {{is based upon the}} idea of periodic group <b>re-keying.</b> We first motivate our approach by showing that if a group is re-keyed on each membership change, as the size of the group increases and/or the rate at which members leave and join the group increases, the frequency of rekeying becomes the primary bottleneck for scalable group <b>re-keying.</b> In contrast, Kronos can scale to handle large and dynamic groups because the frequency of <b>re-keying</b> is independent of the size and membership dynamics of the group. Next, {{we describe}} how Kronos can be used in conjunction with distributed key management frameworks such as IGKMP [10], that use a single group-wide session key for encrypting communications between members of the group. Using a detailed simulation, we compare the performance tradeoffs between Kronos and other key management protocols. ...|$|R
40|$|This paper {{proposes a}} "Minimum Redundancy Tree" (MRT) for key {{distribution}} in secure multicast. The MRT is optimal {{in terms of}} minimum <b>re-keying</b> costs by keeping the minimum average number of keys to be updated for each member and maintaining minimum average tree height for each member. We also propose to combine MRT and subgrouping to generate multiple MRTs such that the <b>re-keying</b> costs can be further minimized when {{compared to that of}} other key management schemes...|$|R
40|$|Abstract. In a {{multicast}} communication system, {{group members}} possess a common group key and communicate using the key, F 0 r the communication between group members the group key must be managed securely and efficiently. Especially in a dynamic and large group {{the efficiency of}} the group key management is critical since the size of deleted or added members may be quite large. Most schemes proposed in the literature implicitly assume that members is constantly on-line, which is not realizable in many receiving devices. In the paper, we propose a hierarchical binary tree-based key management scheme for a dynamic large group with one group controller(GC), especially well suitable to stateless receivers, who do not update their state from session to session In our scheme, all <b>re-keying</b> messages except for unicast of a individual key are transmitted without any encryption, all computation needed for <b>re-keying</b> is O(log 2 n) applications of one-way hash function and XOR operation, and all information needed for <b>re-keying</b> is in the current blinded factors and the initial information The proposed scheme provides both backward and forward secrecy. If a bulletin board is used, each member can compute all needed keys without any <b>re-keying</b> messages...|$|R
40|$|Multicast is an {{efficient}} technique to deliver data {{to a large}} group of users. For some applications offering multicast security is an important Issue. In such a system, a new member should not be able to decrypt the multicast data sent before its Joining and a former member should not be able to decrypt the multicast data sent after its leaving. Traditional approaches generally focus on reducing the <b>re-key</b> messages for a single server. However, these approaches still lead to large exchange overhead when the group is Large. In this paper, we consider a distributed server network In which the user pool Is split Into multiple groups and served by multiple servers. Given the user traffic, there is n trade-off between the amount of <b>re-key</b> messaging and the total data bandwidth needed. We present a simple model for the system and study how the total bandwidth (including the <b>re-key</b> messaging and data traffic) can be minimized by optimizing the number of servers in the network. As the underlying user traffic is dynamic, a server should be able to split and merge user groups to minimize Its total bandwidth. We propose a scheme for such n purpose. We show that distributed server network IS able to substantively reduce the total bandwidth required In the system as compared to the traditional scheme...|$|E
40|$|We {{introduce}} {{and analyze}} a scalable re-keying scheme for implementing secure group communications IP multicast. We show that our scheme incurs constant processing, message, and storage overhead for a <b>re-key</b> operation when a single member joins or leaves the group, and logarithmic overhead for bulk simultaneous {{changes to the}} group membership. These bounds hold even when group dynamics are not known a-priori...|$|E
3000|$|One {{practical}} difficulty when {{relying on}} public keys as global identifiers {{is that their}} use is often transitory. A public key serves as an identifier (for its owner) {{for as long as}} the key is regarded as valid. If the (private) key is compromised, or if the owner decides to <b>re-key</b> then authorization certificates will have to be re-issued by all participants on delegation chains involving the permission. If K [...]...|$|E
5000|$|... #Caption: Euro profile locks, {{an example}} of a {{cylinder}} lock. These are commonly found on uPVC doors and commercial buildings where <b>re-keying</b> doors is common.|$|R
40|$|International audienceIn the paper, {{we study}} {{whether it is}} {{possible}} to construct an efficient leakage-resilient symmetric scheme using the AES block cipher. We aim at bridging the gap between the theoretical leakage-resilient symmetric primitives used to build encryption schemes and the prac-tical schemes that do not have any security proof against side-channel adversaries. Our goal is to construct an as efficient as possible leakage-resilient encryption scheme, but {{we do not want to}} change the crypto-graphic schemes already implemented. The basic idea consists in adding a leakage-resilient <b>re-keying</b> scheme on top of the encryption scheme and has been already suggested by Kocher to thwart differential power analy-sis techniques. Indeed, in such analysis, the adversary queries the encryp-tion box and from the knowledge of the plaintext/ciphertext, she can per-form a divide-and-conquer key recovery attack. The method consisting in changing the key for each or after a small number of encryption with the same key is known as <b>re-keying.</b> It prevents DPA adversaries but not SPA attacks which uses one single leakage trace. Here, we prove that using a leakage-resilient <b>re-keying</b> scheme on top of a secure encryption scheme in the standard model, leads to a leakage-resilient encryption scheme. The main advantage of the AES block cipher is that its implementations are generally heuristically-secure against SPA adversaries. This assump-tion is used in many concrete instantiations of leakage-resilient symmet-ric primitives. Consequently, if we use it and change the key for each new message block, the adversary will not be able to recover any key if the <b>re-keying</b> scheme is leakage-resilient. There is mainly two different techniques for <b>re-keying</b> scheme, either parallel or sequential, but if we want to avoid the adversary having access to many inputs/outputs, only the sequential method is possible. However, the main drawback of the latter technique is that in case of de-synchronization, many useless com-putations are required. In our <b>re-keying</b> scheme, we use ideas from the skip-list data structure to efficiently recover a specific key. Full version of the paper published in the proceedings of CHES 2013...|$|R
5000|$|Submit News—Allow {{visitors}} to submit news. Email notification is sent, but the submission {{is stored in}} the administrator control panel. Administrator can delete, edit, and/or post the article without <b>re-keying.</b>|$|R
40|$|The {{characterization}} of multielement acoustic arrays for diagnostic ultrasound {{has always been}} a thorny problem. techniques for determining the essential parameters of wideband multielement arrays. sponse of both the single elpent and full array, the acoustic cross-coupling between elements, the focusing properties of the array, and the acoustic field intensity. This paper describes optical These parameters which are measured are the spatial frequency <b>re-Key</b> words: Acoustic cross-coupling; acoustic intensity; acousto-optic dif-fraction; multielement acoustic arrays; spatial frequency. 1...|$|E
40|$|Wireless Sensor Network is a {{class of}} {{wireless}} ad hoc networks. Self organization is an important phase of a wireless sensor network. After deployment, sensors nodes are required to self organize themselves to form a network of their own. Security is an important aspect while forming the network. Only the authorized nodes {{should be allowed to}} join the network. For implementing security, such as confidentiality, integrity and authentication, keys are needed. How keys are handled is described in key management approach. Key management encompasses generation, storage, distribution, <b>re-key</b> and retirement of a key. It is observed that majority of the attacks are carried out during the key distribution phase itself. Hence, a proper key management is utmost important for implementing fool proof security in a Wireless Sensor Network. Depending upon the type of keys used, for example, symmetric or asymmetric key, key management techniques vary. In this paper an approach to key management for asymmetric key based security schemes of Wireless Sensor Network is proposed. The approach considers entire life of a ‘key’ and subsequently proposes algorithms/schemes for key (pre) distribution, <b>re-key</b> and revocation. We also discuss security planning steps for wireless sensor network in this paper...|$|E
40|$|This report {{describes}} all exploratory stlldy of a techllique which permits descriptiolls of llOusellOld purchases (or sales orders) to be trallsmitted {{from the}} home directly to a remote computer. Descriptive elltries were first ellcoded Illimerically alld thell subsequelltly tralls-mitted lISillg a 12 -key telephOlle halld set. For trallsmissiolls represelltillg 10 product categories, 98. 9 % ofthe data elltries were accurate, after olle opportllllity was givell to <b>re-key</b> allY entry rejected by the system; for trmlSlllissioll of 20 product categories the correspolldillg vallie was 97. 9 %...|$|E
40|$|This paper {{describes}} a secure multicast infrastructure for large-scale group communication in mobile Internet and proposes a key management protocol based on it. The hierarchical infrastructure logically divides the key management domain into several smaller administratively scoped areas {{with a key}} server associated with each area respectively. All the key servers located in every area participate in a Public Key Infrastructure (PKI) as trusted entities known by the subgroup members. Therefore, it is efficient to minimise the <b>re-keying</b> overhead implemented in the mobile host tier and simplify the <b>re-keying</b> relationships between the distributed key servers. Department of Computin...|$|R
40|$|Recently, {{the number}} of {{requests}} for multicast services through the wireless networks has been increased. However, for successful deployment, security and efficiency of content delivery must be provided at first. This paper presents a new approach for secure multicast in wireless networks. This approach, CRAW (Combination of <b>Re-keying</b> and Authentication in Wireless networks) combines member authentication procedure with group key management protocol to provide an efficient group <b>re-keying</b> process. One-time password is proposed for member authentication and CKC (Code for Key Calculation) is suggested for group key management in wireless networks. In fact, the combination of authentication with group key management in wireless networks results in a simple and secure mechanism both for authentication and group key management while mobile members join/leave a group or move inter-area. Simulation results show that CRAW reduces <b>re-keying</b> overhead at join from O(log 2 n+ 1) to O(1) while security requirements are saved. Also, CRAW introduces storing a main list to manage mobile members' location while they move intra-group inter-area. Comment: 22 pages, 16 figures, 7 table...|$|R
40|$|Abstract—Group key {{management}} (GKM) {{refers to the}} actions taken to update and distribute the group key upon members joining and leaving a multicast/broadcast group. The GKM scheme defined in the IEEE 802. 11 WLAN standards is not efficient because the <b>re-keying</b> latency grows linearly {{with the number of}} clients connected to an access point. In this paper, we apply the logical key hierarchy (LKH) and one-way function tree (OFT) algorithms to GKM in WLANs to improve its performance. Our numerical analyses show that the LKH and OFT algorithms reduce the <b>re-keying</b> latency of GKM in WLANs to logarithmic time. Index Terms—Group {{key management}}; logical key hierarchy; one-way function tree. I...|$|R
40|$|ABSTRACT The esophageal tonsil of {{the chicken}} is a novel, {{significant}} element of the gut-associated lymphoid tissue (GALT). Its stable location and histological organi-zation fulfills {{the meaning of the}} term “tonsil. ” The six-to-eight-isolated tonsillar units are located at the border of the esophagus and the proventriculus. The number of tonsillar units is identical with that of the esophageal folds. Each tonsillar unit consists of a crypt lined by lymphoepithelium and surrounded by dense lymphoid tissue, which is organized into T- and B-dependent <b>re-(Key</b> words: gut-associated lymphoid tissue, esophageal tonsil, chicken, lymphoepithelial tissue...|$|E
40|$|Abstract—In {{order to}} offer {{backward}} and forward secrecy for multicast applications (i. e., {{a new member}} cannot decrypt the multicast data sent before its joining and a former member cannot decrypt the data sent after its leaving), the data encryption key has to be changed whenever a user joins or leaves the system. Such a change {{has to be made}} known to all the current users. The bandwidth used for such <b>re-key</b> messaging can be high when the user pool is large. In this paper, we propose a distributed servers approach to minimize the overall system bandwidth (and complexity) by splitting the user pool into multiple groups each served by a (logical) server. After presenting an analytic model for the system based on a hierarchical key tree, we show that there is an optimal number of servers to achieve minimum system bandwidth. As the underlying user traffic fluctuates, we propose a simple dynamic scheme with low overhead where a physical server adaptively splits and merges its traffic into multiple groups each served by a logical server so as to minimize its total bandwidth. Our results show that a distributed servers approach is able to substantially reduce the total bandwidth required as compared with the traditional singleserver approach, especially for those applications with a large user pool, short holding time, and relatively low bandwidth of a data stream, as in the Internet stock quote applications. Index Terms—Distributed servers approach, key tree, multicast security, <b>re-key</b> messaging, split-and-merge scheme. I...|$|E
40|$|Abstract. This paper proves {{multicast}} management {{belongs to}} problems of HDP, provides the cost analytical model of multicast logical key tree which applies HDPT. Based on the above analysis, the author proposes an improved multicast logical key management scheme termed as L-R logical key tree management scheme. L-R logical key tree management scheme {{is a kind}} of imbalanced multicast logical key tree, which is based on periodic <b>re-key,</b> according member nodes ’ joining and leaving different probability, it employs different multicast key management strategy. The paper provides the design and calculation of the scheme, and realizes it in a simulation. By comparing this scheme with the typical LKH one, it shows clearly the scheme proposed in the paper is of high effect and low cost...|$|E
40|$|Abstract. Security-aware {{embedded}} systems are widespread nowadays and many applications, such as payment, pay-TV and automotive appli-cations rely on them. These devices are usually very resource constrained {{but at the}} same time likely to operate in a hostile environment. Thus, the implementation of low-cost protection mechanisms against physi-cal attacks is vital for their market relevance. An appealing choice, to counteract a large family of physical attacks with one mechanism, seem to be protocol-level countermeasures. At last year’s Africacrypt, a fresh <b>re-keying</b> scheme has been presented which combines the advantages of <b>re-keying</b> with those of classical countermeasures such as masking and hiding. The contribution of this paper is threefold: most importantly, the original fresh <b>re-keying</b> scheme was limited to one low-cost party (e. g. an RFID tag) in a two party communication scenario. In this paper we extend the scheme to n low-cost parties and show that the scheme is still secure. Second, one unanswered question in the original paper was the susceptibility of the scheme to algebraic SPA attacks. Therefore, we analyze this property of the scheme. Finally, we implemented the scheme on a common 8 -bit microcontroller to show its efficiency in software...|$|R
40|$|Side-channel {{attacks and}} in {{particular}} differential power analysis (DPA) attacks pose {{a serious threat to}} cryptographic implementations. One approach to counteract such attacks are cryptographic schemes based on fresh <b>re-keying.</b> In settings of pre-shared secret keys, such schemes render DPA attacks infeasible by deriving session keys and by ensuring that the attacker cannot collect side-channel leakage on the session key during cryptographic operations with different inputs. While these schemes can be applied to secure standard communication settings, current <b>re-keying</b> approaches are unable to provide protection in settings where the same input needs to be processed multiple times. In this work, we therefore adapt the <b>re-keying</b> approach and present a symmetric authenticated encryption scheme that is secure against DPA attacks and that does not have such a usage restriction. This means that our scheme fully complies with the requirements given in the CAESAR call and hence, can be used like other noncebased authenticated encryption schemes without loss of side-channel protection. Its resistance against side-channel analysis is highly relevant for several applications in practice, like bulk storage settings in general and the protection of FPGA bitfiles and firmware images in particular...|$|R
40|$|Security-aware {{embedded}} systems are widespread nowadays and many applications, such as payment, pay-TV and automotive applications rely on them. These devices are usually very resource constrained {{but at the}} same time likely to operate in a hostile environment. Thus, the implementation of low-cost protection mechanisms against physical attacks is vital for their market relevance. An appealing choice, to counteract a large family of physical attacks with one mechanism, seem to be protocol-level countermeasures. At last year’s Africacrypt, a fresh <b>re-keying</b> scheme has been presented which combines the advantages of <b>re-keying</b> with those of classical countermeasures such as masking and hiding. The contribution of this paper is threefold: most importantly, the original fresh <b>re-keying</b> scheme was limited to one low-cost party (e. g. an RFID tag) in a two party communication scenario. In this paper we extend the scheme to n low-cost parties and show that the scheme is still secure. Second, one unanswered question in the original paper was the susceptibility of the scheme to algebraic SPA attacks. Therefore, we analyze this property of the scheme. Finally, we implemented the scheme on a common 8 -bit microcontroller to show its efficiency in software...|$|R
