393|2089|Public
50|$|In computing, the Java <b>Remote</b> <b>Method</b> <b>Invocation</b> (Java RMI) is a Java API that {{performs}} <b>remote</b> <b>method</b> <b>invocation,</b> the object-oriented {{equivalent of}} remote procedure calls (RPC), with support for direct transfer of serialized Java classes and distributed garbage-collection.|$|E
5000|$|RMI - the <b>Remote</b> <b>Method</b> <b>Invocation</b> Protocol from Sun Microsystems ...|$|E
5000|$|The RS {{converts}} the <b>remote</b> <b>method</b> <b>invocation</b> into a SOAP message ...|$|E
40|$|Abstract. This paper {{describes}} three program transformations {{that extend}} {{the scope of}} model checkers for Java programs to include distributed programs, i. e., multi-process programs. The transformations combine multiple processes into a single process, replace <b>remote</b> <b>method</b> <b>invocations</b> (RMIs) with local <b>method</b> <b>invocations</b> that simulate RMIs, and replace cryptographic operations with symbolic counterparts. ...|$|R
40|$|We have {{developed}} a generic “Listener ” module in Java called SyDListener, or “System on Mobile Devices (SyD) Listener Module”. It is designed and implemented {{as part of a}} software package we developed that is called SyDKernel. SyDKernel is a middleware package {{that can be used in}} developing distributed collaborative software applications in a rapid and modular way. Its executable code has a small size to fit in small devices like PDAs. Application developers use SyDKernel to easily implement distributed elements of an application such as two-way communication, resource sharing, collaborative services, directory listing, search and discovery services, and <b>remote</b> <b>method</b> <b>invocations.</b> SyDListener is a central module in SyDKernel, it provides a set of interfaces and classes that allows distributed SyD-based application components to communicate via <b>remote</b> <b>method</b> <b>invocations</b> seamlessly. SyDListener is implemented using TCP sockets for <b>remote</b> <b>method</b> invocatins and Java/RMI for locating methods. This paper describes the functionality, design rationale, architecture, and implementation of SyDListener...|$|R
40|$|This paper {{presents}} the Esperanto Broker, a communication platform for nomadic computing applications. By using this broker, developers can model application components {{as a set}} of objects that are distributed over wireless devices and interact via <b>remote</b> <b>method</b> <b>invocations.</b> The Esperanto Broker is able to guarantee remote object interactions despite device movements and/or disconnections. We describe the conceptual model behind the architecture, discuss implementation issues, and present preliminary experimental results...|$|R
5000|$|Java's Java <b>Remote</b> <b>Method</b> <b>Invocation</b> (Java RMI) API {{provides}} similar functionality {{to standard}} Unix RPC methods.|$|E
5000|$|The [...] package {{provides}} Java <b>remote</b> <b>method</b> <b>invocation</b> {{to support}} remote procedure calls between two java applications running in different JVMs.|$|E
50|$|Response-request {{protocols}} date {{to early}} distributed computing {{in the late}} 1960s, theoretical proposals of remote procedure calls as the model of network operations date to the 1970s, and practical implementations date to the early 1980s. In the 1990s, with the popularity of object-oriented programming, the alternative model of <b>remote</b> <b>method</b> <b>invocation</b> (RMI) was widely implemented, such as in Common Object Request Broker Architecture (CORBA, 1991) and Java <b>remote</b> <b>method</b> <b>invocation.</b> RMIs in turn fell in popularity {{with the rise of}} the internet, particularly in the 2000s.|$|E
40|$|Distributed {{applications}} rely on middleware {{to enable}} interaction among remote components. Thus, the overall performance increasingly {{depends on the}} interplay between the implementation of application components and the features provided by the middleware. In this paper we analyze Java components interacting through the RMI middleware, and we discuss opportunities for optimizing <b>remote</b> <b>method</b> <b>invocations.</b> Specifically, we discuss how to optimize parameter passing in RMI by adapting fairly standard static program analysis techniques...|$|R
40|$|SDM is a Secure Delegation Model for Java-based {{distributed}} object environments. SDM extends current Java {{security features}} to support secure <b>remote</b> <b>method</b> <b>invocations</b> that may involve chains of delegated calls across distributed objects. The framework supports a control API for application developers to specify mechanisms and security policies surrounding simple or cascaded delegation. Delegation {{may also be}} disabled and optionally revoked. These policies may be controlled explicitly in application code, or implicitly via administrative tools...|$|R
40|$|The aim of {{this work}} is {{distributed}} genetic algorithm implementation (so called island algorithm) to accelerate the optimum searching process in space of solutions. Distributed genetic algorithm has also smaller chances to fall in local optimum. This conception depends on mutual cooperation of the clients which realize separate working of genetic algorithms on local machines. As a tool for implementation of distributed genetic algorithm, created to produce net's applications Java technology was chosen. In Java technology, there is a technique of <b>remote</b> <b>methods</b> <b>invocation</b> - Java RMI. By means of invoking <b>remote</b> <b>methods</b> it can send objects between clients and server RMI...|$|R
50|$|This {{approach}} of describing objects that {{can then be}} processed by other computers is similar to other systems such as CORBA, Java <b>remote</b> <b>method</b> <b>invocation</b> and Distributed Component Object Model.|$|E
5000|$|Distributed Ruby (DRb) allows Ruby {{programs}} {{to communicate with}} each other on the same machine or over a network. DRb uses <b>remote</b> <b>method</b> <b>invocation</b> (RMI) to pass commands and data between processes.|$|E
5000|$|For <b>remote</b> <b>method</b> <b>invocation</b> - {{can call}} a method {{on a remote}} object running on a web server, an {{alternative}} to Java RMI that does not need a stub compiler such as rmic ...|$|E
40|$|This paper {{presents}} linguistic primitives for publish/subscribe programming using {{events and}} objects. We integrate our primitives into a strongly typed objectoriented language through four mechanisms: (1) serialization, (2) multiple subtyping, (3) closures, and (4) deferred code evaluation. We illustrate our primitives through Java, showing {{how we have}} overcome its respective lacks. A precompiler transforms statements based on our publish/subscribe primitives into calls to specifically generated typed adapters, which resemble the typed stubs and skeletons generated by the rmic precompiler for <b>remote</b> <b>method</b> <b>invocations</b> in Java. ...|$|R
40|$|Details on Sockets {{later on}} by Jan Stöss For a better understanding: read Coulouris et al: “Distributed Systems: Concepts and Design”, ch. 4 + 5 © 2003 Universität Karlsruhe, System Architecture Group 2 Distributed Objects Objects that can receive <b>remote</b> <b>method</b> <b>invocations</b> are called “remote objects ” and they {{implement}} a remote interface Due to possibility of independent failures of invoker and invoked object RMIs differ from local invocations Code for marshalling etc. {{can be generated}} automatically by an IDL compiler from {{the definition of the}} remote interface...|$|R
40|$|International audienceThis paper {{provides}} a sound foundation for autonomous objects communicating by <b>remote</b> <b>method</b> <b>invocations</b> and futures. As a distributed extension of sigma-calculus, we define aspfun, a calculus of functional objects, behaving autonomously and communicating by a request-reply mechanism: requests are method calls handled asynchronously and futures represent awaited results for requests. This {{results in a}} well structured distributed object language enabling a concise representation of asynchronous <b>method</b> <b>invocations.</b> This paper first presents the aspfun calculus and its semantics. Secondly we provide a type system for aspfun, which guarantees the ``progress'' property. Most importantly, aspfun and its properties have been formalised and proved using the Isabelle theorem prover, and we consider it as a good step toward formalisation of distributed languages...|$|R
50|$|Java Remote Method Protocol or JRMP is the Java technology-specific {{protocol}} for {{looking up and}} referencing remote objects. It is a wire level protocol running at the level under Java <b>remote</b> <b>method</b> <b>invocation</b> (RMI) and over TCP/IP.|$|E
5000|$|Remote access framework: configurative remote {{procedure}} call (RPC)-style marshalling of Java objects over networks supporting Java <b>remote</b> <b>method</b> <b>invocation</b> (RMI), CORBA (Common Object Request Broker Architecture) and HTTP-based protocols including Web services (SOAP (Simple Object Access Protocol)) ...|$|E
50|$|While J++ {{conformed}} to the Java language specification, Microsoft did not implement certain {{features of the}} official Sun Java implementation in its Visual J++ product line. <b>Remote</b> <b>Method</b> <b>Invocation</b> (Java RMI) and Java Native Interface (JNI) are such examples.|$|E
40|$|Abstract — We {{outline the}} design of a platform, called PALATIN, that allows easy {{development}} and reliable and efficient execution of concurrent algorithms in a distributed, potentially unreliable environment. The platform consists of three parts: a basic philosophy of how to write code for concurrent data structures and algorithms, a C++ library called Spheres supporting this philosophy, and the design principles of the PALATIN platform itself that allows programs written in the Spheres environment to interact with each other across multiple sites. This is done by organizing the PALATIN platforms of these sites into a peer-to-peer system allowing programs to find and communicate with each other via <b>remote</b> <b>method</b> <b>invocations.</b> I...|$|R
40|$|An {{introductory}} {{treatment of}} the distributed systems and programming. Topics range from the distributed and object models of computation to advanced concepts, such as <b>remote</b> <b>method</b> <b>invocations,</b> object brokers, object services, open systems, and future trends for distributed information systems. Course Goals The student who completes this course: · Will {{be able to write}} Java programs involving exception handling, multithreading, networking, and GUI. · Will be able to write programs that use simple network communications primitives. · Will be able to implement distributed applications using one or more higher level network programming paradigms, · Will understand the relationship between basic network protocols, network programming primitives and higher level distributed programming paradigms...|$|R
40|$|Fortran is {{the most}} widely used {{programming}} language for high-performance scientific computing applications, yet in the past the Legion system has not supported objects implemented in Fortran. This paper describes the design and interface of the Legion Basic Fortran Support (BFS) system. This system consists of compiler and runtime library that allow the description of Legion object interfaces in a Fortran-like Interface Description Language (IDL), and the implementation of Legion objects using Fortran. The system also supports <b>remote</b> <b>method</b> <b>invocations</b> on Legion objects through the use of pseudo-comments: Legion BFS directives embedded in normal Fortran comment lines. These <b>method</b> <b>invocations</b> are processed using a macro-dataflow model similar to that provided by the Mentat Programming Language, thus allowing both inter- and intra-method parallelism. 1. Introduction Fortran {{is the most}} widely used programming language for high-performance scientific computing applications. In the high [...] ...|$|R
50|$|Java Message Service is an {{asynchronous}} communication mechanism in the distributed system field. It is {{very helpful in}} the situation where the distributed components are loosely coupled. Another popular distributed communication technology is <b>Remote</b> <b>Method</b> <b>Invocation</b> (RMI), which is tightly coupled and requires an application to know a remote application's methods.|$|E
50|$|Skeleton {{programs}} are utilized in the template method design pattern used in object-oriented programming. In object-oriented programming, dummy code corresponds to an abstract method, a method stub or a mock object. In the Java <b>remote</b> <b>method</b> <b>invocation</b> (Java RMI) nomenclature, a stub communicates on the client-side with a skeleton on the server-side.|$|E
5000|$|Like its {{family members}} and similar {{technologies}} such as Common Object Request Broker Architecture (CORBA) and Java's <b>remote</b> <b>method</b> <b>invocation</b> (RMI), [...]NET Remoting is complex, yet its essence is straightforward. With the assistance of operating system and network agents, a client process {{sends a message to}} a server process and receives a reply.|$|E
40|$|In {{distributed}} object systems, one generates local surrogate {{objects to}} achieve transparent <b>remote</b> <b>method</b> <b>invocations.</b> These surrogates intercept <b>method</b> <b>invocations,</b> transfer the invocations {{to the actual}} (remote) object, and invoke the respective method by using so-called stub code. We describe a method which automatically generates surrogate and stub code. The actual generation is delayed until run time, which allows late adaptations to current needs and restrictions. Objects using this mechanism are not necessarily derived from a common base class. 1 Introduction Today's highly interconnected systems put more and more emphasis on the exploitation of the advantages inherent to a network, i. e. increased fault tolerance, better availability, and easier scalability. However, network systems have their disadvantages as well, {{and it is not}} easy to actually exploit their advantages. Independent failure modes, which have to be handled when dealing with several computers, increase the com [...] ...|$|R
40|$|We present {{middleware}} for a Client Development Environment {{that facilitates}} live development of client applications for SOAP or CORBA servers. We use JPie, a tightly integrated programming environment for live software construction in Java, as the target platform for our design. JPie provides dynamic classes whose signature and implementation {{can be modified}} at run time, with changes taking effect immediately upon existing instances of the class. We extend this model to automate addition, mutation, and deletion of dynamic server methods within dynamic clients. Our implementation simplifies distributed application development by masking technical differences between local and <b>remote</b> <b>method</b> <b>invocations.</b> Moreover, the live development model allows server-side changes to be dynamically integrated into a running client to support simultaneous live development of both the client and server. 1...|$|R
40|$|Babylon is {{composed}} of class libraries which are written entirely in Java and that run on any standard compliant Java virtual machine. These class libraries implement and combine several key features that are essential to supporting distributed and parallel computing using Java. Such features include the ability to: iv ffl easily create objects, which require no special programming, on remote hosts and interact with those objects through either synchronous or asynchronous <b>remote</b> <b>method</b> <b>invocations,</b> ffl freely migrate objects to heterogeneous hosts {{at any point in}} time, ffl request console, file or socket input and/or output on the originating host, regardless of the location of the object, ffl seamlessly handle the arrivals and departures of compute servers to and from the system...|$|R
5000|$|RMI-IIOP (read as [...] "RMI over IIOP") {{denotes the}} Java <b>Remote</b> <b>Method</b> <b>Invocation</b> (RMI) {{interface}} over the Internet Inter-Orb Protocol (IIOP), which delivers Common Object Request Broker Architecture (CORBA) distributed computing capabilities to the Java platform. It was initially {{based on two}} specifications: the Java Language Mapping to OMG IDL, and CORBA/IIOP 2.3.1.|$|E
50|$|An ESB {{service is}} {{designed}} and configured with Oracle JDeveloper and Oracle ESB Control user interfaces. It is then registered to an ESB Server. The ESB Server supports multiple protocol bindings for message delivery, including HTTP/SOAP, JMS, JCA, WSIF and Java, using synchronous/, request/reply or publish/subscribe models. Currently, the ESB Server {{does not support}} <b>Remote</b> <b>Method</b> <b>Invocation.</b>|$|E
50|$|Babel is an {{open source}} {{middleware}} system serving the scientific computing community. As a language interoperability tool, Babel enables the arbitrary mixing of software libraries written in C/C++, Fortran, Python, and Java. As a distributed computing platform, Babel provides a language-neutral <b>Remote</b> <b>Method</b> <b>Invocation</b> (RMI) scheme similar to Java's RMI which allows third-party plug-ins to specify custom data encodings and network protocols.|$|E
40|$|High level beam {{dynamics}} applications typically require {{access to}} several distributed components, among which the hardware control system and an accelerator simulation model are crucial. A CORBA Application Program Interface (API) provides clients {{with the necessary}} objects with which to develop even the most complex of applications. This is exemplified by the global orbit feedback system at the SLS which is both a consumer to event generated data and a party to <b>remote</b> <b>method</b> <b>invocations</b> {{on a variety of}} servers. In particular, use is made of methods provided by the Portable Object Adapter (POA) to create and activate persistent objects, the Implementation Repository (IMR) for the automatic reactivation of servers and the Event Service for the propagation of controls and physics data...|$|R
40|$|In {{the recent}} past, {{a plethora of}} mobile {{computing}} middleware are developed. Actually, {{most of them do}} not cope with terminals mobility at each level of the network protocols stack. We presents a new communication platform which implements a Broker for nomadic computing environments, named the Esperanto Broker. By using the proposed platform, developers model application components as a set of objects that are distributed over wireless domains and interact via <b>remote</b> <b>method</b> <b>invocations.</b> The Esperanto Broker is able to guarantee remote object interactions despite terminals movements and/or disconnections. We believe that the proposed platform acts as a building block for the realization of mobile-enabled middleware services. We describe the conceptual model behind the architecture, discuss implementation issues, and present preliminary experimental results. WP...|$|R
40|$|Abstract. In this paper, {{we present}} a {{peer-to-peer}} (P 2 P) system with <b>remote</b> <b>method</b> <b>invocations,</b> combining RMIX and JXTA technologies, and underpinning the H 2 O distributed resource sharing platform. We show that the integration of RMIX and JXTA was possible due to extensibility of the former, which allowed to plug in the JXTA-based socket implementations. The result of this integration is a fully operational RMI implementation running {{on top of the}} JXTA P 2 P network, where methods can be invoked on remote objects located behind firewalls or NATs. We present results of tests showing that our implementation can be used to connect peers in different LANs that cannot interact directly, while in the case of direct connection the performance is comparable to that of RMI using standard sockets...|$|R
