140|0|Public
25|$|Purely {{functional}} {{programs can}} use monads to structure procedures that include sequenced operations like {{those found in}} structured programming. Many common programming concepts {{can be described in}} terms of a monad structure without losing the beneficial property of <b>referential</b> <b>transparency,</b> including side effects such as input/output, variable assignment, exception handling, parsing, nondeterminism, concurrency, continuations, or domain-specific languages. This allows these concepts to be defined in a purely functional manner, without major extensions to the language's semantics. Languages like Haskell provide monads in the standard core, allowing programmers to reuse large parts of their formal definition and apply in many different libraries the same interfaces for combining functions.|$|E
2500|$|Linear types, {{based on}} the theory of linear logic, and closely related to {{uniqueness}} types, are types assigned to values having the property that they have one and only one reference to them at all times. These are valuable for describing large immutable values such as files, strings, and so on, because any operation that simultaneously destroys a linear object and creates a similar object (such as 'str= str + [...] "a"') can be optimized [...] "under the hood" [...] into an in-place mutation. Normally this is not possible, as such mutations could cause side effects on parts of the program holding other references to the object, violating <b>referential</b> <b>transparency.</b> They are also used in the prototype operating system Singularity for interprocess communication, statically ensuring that processes cannot share objects in shared memory {{in order to prevent}} race conditions. The Clean language (a Haskell-like language) uses this type system in order to gain a lot of speed (compared to performing a deep copy) while remaining safe.|$|E
5000|$|... #Subtitle level 3: Vagaries of {{reference}} and <b>referential</b> <b>transparency</b> ...|$|E
50|$|In {{mathematics}} all function {{applications are}} referentially transparent, by {{the definition of}} what constitutes a mathematical function. However, this is not always the case in programming, where the terms procedure and method are used to avoid misleading connotations. In functional programming only referentially transparent functions are considered. Some programming languages provide means to guarantee <b>referential</b> <b>transparency.</b> Some functional programming languages enforce <b>referential</b> <b>transparency</b> for all functions.|$|E
5000|$|Now [...] {{reads the}} next line from the file using an OS-level system call which has the side effect of {{changing}} the current position in the file. But this violates <b>referential</b> <b>transparency</b> because calling it multiple times with the same argument will return different results each time as the current position in the file gets moved. This in turn makes [...] violate <b>referential</b> <b>transparency</b> because it calls [...]|$|E
50|$|The {{concepts}} {{that are used}} to explain this concept are extensionality, definiteness, substitutivity of identity, unfoldability, and <b>referential</b> <b>transparency.</b>|$|E
50|$|Absence of {{side effects}} is a necessary, but not sufficient, {{condition}} for <b>referential</b> <b>transparency.</b> <b>Referential</b> <b>transparency</b> means that an expression (such as a function call) can be replaced with its value; this requires that the expression has no side effects and is pure (always returns the same results on the same input). A function without side effects may be impure, for example if its output depends {{on the value of}} a global variable.|$|E
50|$|As <b>referential</b> <b>transparency</b> {{requires}} {{the same results}} for any given set of inputs {{at any point in}} time, a referentially transparent expression is therefore deterministic.|$|E
5000|$|On {{the other}} hand, {{hygienic}} macro systems preserve the lexical scoping of all identifiers (such as [...] "if" [...] and [...] "not") automatically. This property is called <b>referential</b> <b>transparency.</b>|$|E
50|$|Therefore, <b>referential</b> <b>transparency</b> {{allows us}} to reason about our code which {{will lead to more}} robust programs, the {{possibility}} of finding bugs that we couldn't hope to find by testing, and the possibility of seeing opportunities for optimization.|$|E
50|$|The way {{to avoid}} the {{problems}} associated with action at a distance are a proper design, which avoids global variables and alters data only in a controlled and local manner, or usage of a pure functional programming style with <b>referential</b> <b>transparency.</b>|$|E
50|$|Functional {{programming}} {{is very different}} from imperative programming. The most significant differences stem from the fact that functional programming avoids side effects, which are used in imperative programming to implement state and I/O. Pure functional programming completely prevents side-effects and provides <b>referential</b> <b>transparency.</b>|$|E
50|$|Meanwhile, {{languages}} such as Scheme {{that use}} hygienic macros prevent accidental capture and ensure <b>referential</b> <b>transparency</b> automatically {{as part of}} the macro expansion process. In cases where accidental capture is desired, some systems allow the programmer to explicitly violate the hygiene mechanisms of the macro system.|$|E
5000|$|The Scheme dialect of Lisp {{provides}} a macro-writing system which provides the <b>referential</b> <b>transparency</b> that eliminates {{both types of}} capture problem. This type of macro system is sometimes called [...] "hygienic", in particular by its proponents (who regard macro systems which do not automatically solve this problem as unhygienic).|$|E
50|$|The {{importance}} of <b>referential</b> <b>transparency</b> {{is that it}} allows the programmer and the compiler to reason about program behavior as a rewrite system. This can help in proving correctness, simplifying an algorithm, assisting in modifying code without breaking it, or optimizing code by means of memoization, common subexpression elimination, lazy evaluation, or parallelization.|$|E
5000|$|If a pure {{function}} is called with arguments that cause no side-effects, {{the result is}} constant with respect to that argument list (sometimes called <b>referential</b> <b>transparency),</b> i.e. if the pure {{function is}} again called with the same arguments, the same result will be returned (this can enable caching optimizations such as memoization).|$|E
50|$|In {{imperative}} programming languages, values can {{generally be}} accessed or changed at any time. In pure functional and logic languages, variables {{are bound to}} expressions and keep a single value during their entire lifetime due {{to the requirements of}} <b>referential</b> <b>transparency.</b> In imperative languages, the same behavior is exhibited by constants, which are typically contrasted with normal variables.|$|E
50|$|The primary {{disadvantage}} of languages that enforce <b>referential</b> <b>transparency</b> {{is that they}} make the expression of operations that naturally fit a sequence-of-steps imperative programming style more awkward and less concise. Such languages often incorporate mechanisms to make these tasks easier while retaining the purely functional quality of the language, such as definite clause grammars and monads.|$|E
5000|$|Side effects {{caused by}} the time taken for an {{operation}} to execute are usually ignored when discussing side effects and <b>referential</b> <b>transparency.</b> There are some cases, such as with hardware timing or testing, where operations are inserted specifically for their temporal side effects e.g. [...] or [...] These instructions do not change state other than taking {{an amount of time}} to complete.|$|E
50|$|<b>Referential</b> <b>transparency</b> and {{referential}} opacity are {{properties of}} parts of computer programs. An expression {{is said to be}} referentially transparent if it can be replaced with its corresponding value without changing the program's behavior. As a result, evaluating a referentially transparent function gives the same value for same arguments. Such functions are called pure functions. An expression that is not referentially transparent is called referentially opaque.|$|E
5000|$|Idempotence (UK: US: [...] ) is the {{property}} of certain operations in mathematics and computer science, {{that can be applied}} multiple times without changing the result beyond the initial application. The concept of idempotence arises in a number of places in abstract algebra (in particular, in the theory of projectors and closure operators) and functional programming (in which it is connected to {{the property}} of <b>referential</b> <b>transparency).</b>|$|E
50|$|In {{stateful}} languages, closures {{can thus}} be used to implement paradigms for state representation and information hiding, since the closure's upvalues (its closed-over variables) are of indefinite extent, so a value established in one invocation remains available in the next. Closures used in this way no longer have <b>referential</b> <b>transparency,</b> and are thus no longer pure functions; nevertheless, they are commonly used in impure functional languages such as Scheme.|$|E
5000|$|Imperative {{procedures}} with {{side effects}} violate <b>referential</b> <b>transparency</b> and therefore are not cleanly composable. However {{if you consider}} the [...] "state of the world" [...] before and after running the code as its input and output, you get a clean function. Composition of such functions corresponds to running the procedures one after the other. The Monads formalism uses this idea to incorporate side effects and I/O into functional languages.|$|E
50|$|In computing, {{a unique}} type {{guarantees}} that an object {{is used in}} a single-threaded way, with at most a single reference to it. If a value has a unique type, a function applied to it can be optimized to update the value in-place in the object code. Such in-place updates improve the efficiency of functional languages while maintaining <b>referential</b> <b>transparency.</b> Unique types {{can also be used}} to integrate functional and imperative programming.|$|E
50|$|In contrast, {{imperative}} programming changes {{state with}} commands in the source code, the simplest example being assignment. Imperative programming does have functions—not in the mathematical sense—but {{in the sense}} of subroutines. They can have side effects that may change the value of program state. Functions without return values therefore make sense. Because of this, they lack <b>referential</b> <b>transparency,</b> i.e. the same language expression can result in different values at different times depending {{on the state of the}} executing program.|$|E
5000|$|The [...] {{declaration}} specifies {{that the}} type of [...] is unique; that is to say that [...] may never be referred to again by the caller of [...] after [...] returns, and this restriction is enforced by the type system. And since [...] does not return [...] itself but rather a new, different file object , this means that it's impossible for [...] to be called with [...] as an argument ever again, thus preserving <b>referential</b> <b>transparency</b> while allowing for side effects to occur.|$|E
5000|$|Reference equality: Given the impracticality of {{implementing}} extensional and intensional equality, most languages supporting testing functions for equality use reference equality. All functions or closures are assigned a unique identifier (usually {{the address of}} the function body or the closure) and equality is decided based on equality of the identifier. Two separately defined, but otherwise identical function definitions will be considered unequal. Referential equality implies intensional and extensional equality. Referential equality breaks <b>referential</b> <b>transparency</b> and is therefore not supported in pure languages, such as Haskell.|$|E
5000|$|In many {{programming}} languages a function, {{and hence}} an expression containing a function, may have side effects. An expression with side effects does not normally have {{the property of}} <b>referential</b> <b>transparency.</b> In many languages (e.g. C++), expressions may be ended with a semicolon (...) to turn the expression into an expression statement. This asks the implementation to evaluate the expression for its side-effects only and to disregard {{the result of the}} expression (e.g. [...] "x+1;") unless it is a part of an expression statement that induces side-effects (e.g. [...] "y=x+1;" [...] or [...] "func1(func2 (...) [...] );").|$|E
5000|$|In the mid-eighties, {{a number}} of papers {{introduced}} the notion of hygienic macro expansion (syntax-rules), a pattern-based system where the syntactic environments of the macro definition and the macro use are distinct, allowing macro definers and users not to worry about inadvertent variable capture (cf. <b>referential</b> <b>transparency).</b> Hygienic macros have been standardized for Scheme in both the R5RS and R6RS standards. The upcoming R7RS standard will also include hygienic macros. A number of competing implementations of hygienic macros exist such as , , explicit renaming, and syntactic closures. Both [...] and [...] have been standardized in the Scheme standards.|$|E
50|$|Purely {{functional}} {{programs can}} use monads to structure procedures that include sequenced operations like {{those found in}} structured programming. Many common programming concepts {{can be described in}} terms of a monad structure without losing the beneficial property of <b>referential</b> <b>transparency,</b> including side effects such as input/output, variable assignment, exception handling, parsing, nondeterminism, concurrency, continuations, or domain-specific languages. This allows these concepts to be defined in a purely functional manner, without major extensions to the language's semantics. Languages like Haskell provide monads in the standard core, allowing programmers to reuse large parts of their formal definition and apply in many different libraries the same interfaces for combining functions.|$|E
5000|$|Analytica is {{a visual}} {{software}} package developed by Lumina Decision Systems for creating, analyzing and communicating quantitative decision models. [...] As a modeling environment, {{it is interesting}} {{in the way it}} combines hierarchical influence diagrams for visual creation and view of models, intelligent arrays for working with multidimensional data, Monte Carlo simulation for analyzing risk and uncertainty, and optimization, including linear and nonlinear programming. Its design, especially its influence diagrams and treatment of uncertainty, is based on ideas from the field of decision analysis. As a computer language, it is notable in combining a declarative (non-procedural) structure for <b>referential</b> <b>transparency,</b> array abstraction, and automatic dependency maintenance for efficient sequencing of computation.|$|E
5000|$|OOP doctrines {{such as the}} use of {{accessor}} {{methods to}} read data members are not enforced in Python. Just as Python offers functional-programming constructs but does not attempt to demand <b>referential</b> <b>transparency,</b> it offers an object system but does not demand OOP behavior. Moreover, it is always possible to redefine the class using properties so that when a certain variable is set or retrieved in calling code, it really invokes a function call, so that [...] might really invoke [...] This nullifies the practical advantage of accessor functions, and it remains OOP because the property [...] becomes a legitimate part of the object's interface: it need not reflect an implementation detail.|$|E
5000|$|Assignments {{typically}} allow {{a variable}} to hold different values {{at different times}} during its life-span and scope. However, some languages (primarily strictly functional) do not allow that kind of [...] "destructive" [...] reassignment, as it might imply changes of non-local state. The purpose is to enforce <b>referential</b> <b>transparency,</b> i.e. functions that do {{not depend on the}} state of some variable(s), but produce the same results for a given set of parametric inputs at any point in time. Modern programs in other languages also often use similar strategies, although less strict, and only in certain parts, in order to reduce complexity, normally in conjunction with complementing methodologies such as data structuring, structured programming and object orientation.|$|E
5000|$|Linear types, {{based on}} the theory of linear logic, and closely related to {{uniqueness}} types, are types assigned to values having the property that they have one and only one reference to them at all times. These are valuable for describing large immutable values such as files, strings, and so on, because any operation that simultaneously destroys a linear object and creates a similar object (such as [...] ) can be optimized [...] "under the hood" [...] into an in-place mutation. Normally this is not possible, as such mutations could cause side effects on parts of the program holding other references to the object, violating <b>referential</b> <b>transparency.</b> They are also used in the prototype operating system Singularity for interprocess communication, statically ensuring that processes cannot share objects in shared memory {{in order to prevent}} race conditions. The Clean language (a Haskell-like language) uses this type system in order to gain a lot of speed (compared to performing a deep copy) while remaining safe.|$|E
50|$|Generally, certain blocks {{are defined}} to create {{bindings}} whose lifetime is the execution {{time of the}} block; this adds some features of static scoping to the dynamic scoping process. However, since a section of code can be called from many different locations and situations, {{it can be difficult}} to determine at the outset what bindings will apply when a variable is used (or if one exists at all). This can be beneficial; application of the principle of least knowledge suggests that code avoid depending on the reasons for (or circumstances of) a variable's value, but simply use the value according to the variable's definition. This narrow interpretation of shared data can provide a very flexible system for adapting the behavior of a function to the current state (or policy) of the system. However, this benefit relies on careful documentation of all variables used this way as well as on careful avoidance of assumptions about a variable's behavior, and does not provide any mechanism to detect interference between different parts of a program. Dynamic scoping also voids all the benefits of <b>referential</b> <b>transparency.</b> As such, dynamic scoping can be dangerous and few modern languages use it. Some languages, like Perl and Common Lisp, allow the programmer to choose static or dynamic scoping when defining or redefining a variable. Examples of languages that use dynamic scoping include Logo, Emacs Lisp, and the shell languages bash, dash, and PowerShell.|$|E
50|$|In Chapter 4 of Word and Object, Quine {{looks at}} the indeterminacies of {{reference}} that are inherent to the (English) language system. A term is vague if the boundaries of its reference are not clear. For a singular term {{this means that the}} boundaries of the object it refers to are not clear, e.g. with the ‘mountain’: for two neighboring mountains it is not clear where the first mountain stops and the second one begins. General terms can be vague in this same way, but also in yet another way, namely that there are some objects of which {{it is not clear whether}} or not they should be included in the reference of the term. For example, the term ‘blue’ is vague insofar as it is not clear whether or not some objects are blue or green. A second vagary of reference is ambiguity. Ambiguity differs from vagueness in that for a vague term the (boundaries of) its reference are unsettled, whereas ambiguous terms do refer to clearly to objects, however they are clearly true and clearly false of the same objects. For example, the term ‘light’ is clearly true of a dark feather, but at the same time clearly false of it. Quine also introduces the term <b>referential</b> <b>transparency.</b> Quine wants to make explicit the ambiguities in language, and to show different interpretations of sentences, therefore, he has to know where the terms in a sentence refer to. A term is used in purely referential position if its only purpose is to specify its object so that the rest of the sentence can say something about it. If a term is used in purely referential position, it is subject to substitivity of identity: the term can be substituted by a coextensive term (a term true of the same objects) without changing the truth-value of the sentence. In the sentence, ‘Amsterdam rhymes with Peter Pan’ you cannot substitute ‘Amsterdam’ with ‘the capital of the Netherlands’. A construction, a way in which a singular term or a sentence is included in another singular term or sentence, has referential transparency: it is either referentially transparent or referentially opaque. A construction is referentially transparent if it is the case that if an occurrence of a term is purely referential in a sentence then it is purely referential also in the containing sentence. However, Quine's goal is to make clear which positions in a sentence are referentially transparent, not to make them all transparent.|$|E
