58|325|Public
5000|$|Maya Hardware - {{a legacy}} GPU <b>rasterize</b> {{renderer}} in Maya 2017 or earlier.|$|E
50|$|It is also {{possible}} {{to use the same}} concept to <b>rasterize</b> a parabola, ellipse, or any other two-dimensional curve.|$|E
5000|$|FurryBall - Advanced {{real-time}} GPU {{production quality}} final frame renderer using raytrace {{as well as}} <b>rasterize</b> - based on Nvidia OptiX ...|$|E
50|$|Defining {{standardized}} events, and 2D <b>rasterizing</b> functions.|$|R
5000|$|... #Subtitle level 3: Calculation of bitmap fonts (<b>rasterizing</b> 1975) ...|$|R
5000|$|FreeType has {{replaced}} the code that scales and <b>rasterizes</b> fonts.|$|R
50|$|Pen {{plotters}} became obsolete {{with the}} adoption of ink-jet printers, and processors fast enough to <b>rasterize</b> complex images. Houston Instrument and other manufacturers would follow with similar plotters.|$|E
50|$|A {{line drawing}} {{algorithm}} is a graphical algorithm for approximating a line segment on discrete graphical media. On discrete media, such as pixel-based displays and printers, line drawing requires such an approximation (in nontrivial cases). Basic algorithms <b>rasterize</b> lines in one color. A better representation with multiple color gradations requires an advanced process, spatial anti-aliasing.|$|E
50|$|Some basic, {{inexpensive}} {{laser printers}} {{do not support}} PostScript, instead coming with drivers that simply <b>rasterize</b> the platform's native graphics formats rather than converting them to PostScript first. When PostScript support is needed for such a printer, Ghostscript can be used. There are also a number of commercial PostScript interpreters, such as TeleType Co.'s T-Script.|$|E
5000|$|The {{code that}} scales and <b>rasterizes</b> fonts uses open source FreeType ...|$|R
40|$|Ray-tracing {{achieves}} impressive effects such as realistic {{reflections on}} complex surfaces {{but is also}} more computationally expensive than classic rasterization. <b>Rasterized</b> ray-tracing methods can accelerate ray-tracing {{by taking advantage of}} the massive parallelization available in the rasterization pipeline on the GPU. In this paper, we propose a selective <b>rasterized</b> raytracing method that optimizes the <b>rasterized</b> ray-tracing by selectively allocating computational resources to reflective regions in the image. Our experiments suggest that the method can speed-up the computation by up to 4 times and also reduce the memory footprint by almost 66 % without affecting the image quality. We demonstrate the effectiveness of our method using complex scenes and animations...|$|R
50|$|Depending on the {{hardware}} and software components and configurations, RIPs can experience problems <b>rasterizing</b> the image data contained in PostScript or PDF files. If there is a failure in <b>rasterizing</b> the image, it can be costly, as output systems (printers, plate-setters, etc.) consume expensive supplies, can require extensive amounts of time to process complex image data, and require skilled labor to operate.|$|R
50|$|The {{fact that}} the PDF {{transparency}} model is so complicated means {{that it is not}} well supported. This means that RIPs and printers often have problems printing PDFs with transparency. The solution to this is either to <b>rasterize</b> the image or to apply vector transparency flattening to the PDF. However vector transparency flattening is extremely complex and only supported by a few specialist packages.|$|E
50|$|In 1976, the {{inkjet printer}} was invented with the {{increase}} in use of personal computers. The inkjet printer is now the cheapest and most versatile option for everyday digital color output. Raster Image Processing (RIP) is typically built into the printer or supplied as a software package for the computer; it is required to achieve the highest quality output. Basic inkjet devices do not feature RIP. Instead, they rely on graphic software to <b>rasterize</b> images. The laser printer, though more expensive than the inkjet, is another affordable output device available today.|$|E
5000|$|Significant further {{development}} of xfs is unlikely. One of the original motivations behind xfs was the single-threaded nature of the X server — a user’s X session could seem to [...] "freeze up" [...] while the X server {{took a moment to}} <b>rasterize</b> a font. This problem with the X server (which remains single-threaded in all popular implementations to this day) has been mitigated on two fronts: machines have gotten much faster, and client-side font rendering (particularly via the Xft library) has become the norm in contemporary software.|$|E
5000|$|Digital {{differential}} analyzer (graphics algorithm), {{a simple and}} general method for <b>rasterizing</b> lines and triangles ...|$|R
5000|$|Triangulated {{irregular}} network, a vector {{source for}} topography data, often <b>rasterized</b> as a (raster) digital elevation model.|$|R
50|$|Multiple signals {{processed}} {{in this way}} are lined up together and interpolated and <b>rasterized</b> into a readable image.|$|R
50|$|The usual method {{starts with}} edges of {{projected}} polygons inserted into buckets, one per scanline; the rasterizer maintains an active edge table (AET). Entries maintain sort links, X coordinates, gradients, and {{references to the}} polygons they bound. To <b>rasterize</b> the next scanline, the edges no longer relevant are removed; new edges from the current scanlines' Y-bucket are added, inserted sorted by X coordinate. The active edge table entries have X and other parameter information incremented.Active edge table entries are maintained in an X-sorted list by bubble sort, effecting a change when 2 edges cross.After updating edges, the active edge table is traversed in X order to emit only the visible spans, maintaining a Z-sorted active Span table, inserting and deleting the surfaces when edges are crossed.|$|E
50|$|On January 22, 1997, id Software {{released}} GLQuake. This {{was designed}} to use the OpenGL 3D API to access hardware 3D graphics acceleration cards to <b>rasterize</b> the graphics, rather than having the computer's CPU fill in every pixel. In addition to higher framerates for most players, GLQuake provided higher resolution modes and texture filtering. GLQuake also experimented with reflections, transparent water, and even rudimentary shadows. GLQuake came with a driver enabling the subset of OpenGL used by the game to function on the 3dfx Voodoo Graphics card, the only consumer-level card at the time capable of running GLQuake well. Previously, John Carmack had experimented with a version of Quake specifically written for the Rendition Vérité chip used in the Creative Labs PCI 3D Blaster card. This version had met with only limited success, and Carmack decided to write for generic APIs in the future rather than tailoring for specific hardware.|$|E
50|$|The drawing model {{utilized}} by Quartz 2D {{is based on}} PDF specification 1.4. Drawing takes place using a Cartesian coordinate system, where text, vectors, or bitmap images are placed on a grid. However, drawing output is not sent directly to the output device. Quartz 2D uses graphics contexts, environments in which drawing takes place. Each graphics context defines how the drawing should be presented: in a window, sent to a printer, an OpenGL layer, or off-screen. Each context rasterizes the drawing at the desired resolution without altering the data that defines the drawing. Thus, contexts are the mechanism by which Quartz 2D employs resolution- and device-independence. For example, a window context may <b>rasterize</b> an object to the appropriate screen resolution to create actual graphics on the display. The same object {{can be sent to}} a printing context at a much higher resolution. This permits the same graphics commands to yield output on any device using the most appropriate resolution.|$|E
30|$|The {{study area}} was <b>rasterized</b> into the {{smallest}} raster cells to be considered. A square covering Georgia was <b>rasterized</b> into 4096 x 4096 raster cells. The {{number of cells}} must be a power of two for the quadtree algorithm to work. Population data was then disaggregated to this raster. Population and employment were allocated proportionally to each cell based on the area percentage of the various intersecting zones.|$|R
40|$|An {{automated}} {{system has been}} developed to generate grid DTM data from a <b>rasterized</b> topographic map. Conventional methods used are based on either "raster-vector conversion " or "line following " and {{require a lot of}} manual input and computing time. The system developed here is based on automated recognition of color contour lines from a <b>rasterized</b> topographic map and automated tracing of the sectional heights of the recognized lines...|$|R
40|$|The {{standard}} procedure for wireframe drawing with {{hidden line removal}} on a graphics card has not changed for a long time: First the filled polygons are drawn, laying down the depth buffer. Next, the polygon edges are drawn as lines with a small depth offset to ensure that polygons do not occlude their own edges. The depth offset is required because the procedure for <b>rasterizing</b> lines is {{not exactly the same}} as the one for <b>rasterizing</b> polygons. Consequently, when <b>rasterizing</b> a polygon edge as a line, a given fragment may have a depth value that is different from when the corresponding polygon itself is <b>rasterized.</b> This leads to stippling artefacts. However, adding an offset is not an ideal solution since this offset can result in disocclusions of lines that should be hidden. Moreover, there is usually stippling in any case near steep slopes in the mesh where a very large offset is sometimes required. The only real fix is a slope dependent offset but that tends to make disocclusio...|$|R
50|$|Raster {{images are}} stored in a {{computer}} {{in the form of}} a grid of picture elements, or pixels. These pixels contain the image's color and brightness information. Image editors can change the pixels to enhance the image in many ways. The pixels can be changed as a group, or individually, by the sophisticated algorithms within the image editors. This article mostly refers to bitmap graphics editors, which are often used to alter photographs and other raster graphics. However, vector graphics software, such as Adobe Illustrator, CorelDRAW, Xara Designer Pro, PixelStyle Photo Editor, Inkscape or Vectr, are used to create and modify vector images, which are stored as descriptions of lines, Bézier curves, and text instead of pixels. It is easier to <b>rasterize</b> a vector image than to vectorize a raster image; how to go about vectorizing a raster image is the focus of much research in the field of computer vision. Vector images can be modified more easily, because they contain descriptions of the shapes for easy rearrangement. They are also scalable, being rasterizable at any resolution.|$|E
5000|$|In the 1980s, {{the small}} and {{lightweight}} HP 7470 introduced the [...] "grit wheel" [...] mechanism, {{eliminating the need for}} perforations along the edges, unlike the Calcomp plotters two decades earlier. The grit wheels at opposite edges of the sheet press against resilient polyurethane-coated rollers and form tiny indentations in the sheet. As the sheet is moved back and forth, the grit wheels keep the sheet in proper registration due to the grit particles falling into the earlier indentations, much like the teeth of two gears meshing. The pen is mounted on a carriage that moves back and forth in a line between the grit wheels, representing the orthogonal axis. These smaller [...] "home-use" [...] plotters became popular for desktop business graphics and in engineering laboratories, but their low speed meant they were not useful for general printing purposes, and different conventional printer would be required for those jobs. One category, introduced by Hewlett Packard's MultiPlot for the HP 2647, was the [...] "word chart", which used the plotter to draw large letters on a transparency. This was the forerunner of the modern Powerpoint chart. With the widespread availability of high-resolution inkjet and laser printers, inexpensive memory and computers fast enough to <b>rasterize</b> color images, pen plotters have all but disappeared. However, the grit wheel mechanism is still found in inkjet-based, large format engineering plotters.|$|E
40|$|Two {{programs}} have been written in C++ to greatly automate the process of computer simulation visualization inmost cases. These programs, <b>rasterize.</b> C and tracker. C, {{can be used to}} generate numerous images {{in order to create a}} video or still ties. In order to limit the amount of time and work involved in visualizing simulations, both of these {{programs have}} their own specific output formats. The first output format, from <b>rasterize.</b> C, is best suited for those who need only to visualize the actions of a single element, or elements that work on roughly the same time scale. The second format, from tracker. C, is best suited for simulations which involve multiple elements that work on different time scales and thus must be represented in a manner other than straight forward visualization...|$|E
5000|$|The {{front cover}} {{image is a}} monochrome, heavily <b>rasterized</b> excerpt of the cover image on In Gorbachev We Trust.|$|R
50|$|In another variant, an ID buffer is <b>rasterized</b> in an {{intermediate}} step, allowing deferred shading {{of the resulting}} visible pixels.|$|R
50|$|Solid layers are {{generated}} by following a <b>rasterizing</b> motion where {{the roads are}} deposited side by side within an enveloping domain boundary.|$|R
40|$|This term {{project is}} aimed on {{analysis}} of graphic pipeline which can <b>rasterize</b> required picture. Document is specialized to drawing algorithms {{that are used}} in rasterization block. Major aim of this project is describing of rasterization algorithms that can be implemented on hardware. Type of aimed hardware is field-programmable gate array FPGA...|$|E
40|$|This article {{suggests}} {{a new approach}} to visualize implicit surfaces by using discrete Ray-Tracing. A preprocessing phase to <b>rasterize</b> the implicit surface is necessary to make use of this kind of Ray-Tracing. Several methods were proposed to subdivide an implicit surface. We extend their ideas to visualize this kind of surface directly into the voxel space...|$|E
40|$|We {{implement}} a tile based sort-middle rasterizer in CUDA and study its performance characteristics when {{used as a}} backend for adaptive tessellation down to micropolygons. Tessellation and bucketing map very well to the data-parallel paradigm of CUDA, {{and the majority of}} time is spent with rasterization. Despite this, our fastest implementation is able to reach 30 - 50 % of the hardware rasterization performance of an Nvidia GTX 280. Overall we are able to <b>rasterize</b> 4 M textured and Phong shaded microquads into a 1600 x 1200 framebuffer at 10 - 12 fps. Categories and Subject Descriptors (according to ACM CCS) : Generation—Graphics processors, Parallel processin...|$|E
50|$|Another Bitstream {{product is}} Font Fusion, a font <b>rasterizing</b> engine {{developed}} jointly with Type Solutions, Inc., which was later owned entirely by Bitstream.|$|R
5000|$|Bitmap (<b>rasterized)</b> overlay {{graphics}} and text {{may be present}} in unused high bits of the pixel data or in a separate attribute (deprecated) ...|$|R
5000|$|... 1843: fax machine: a scanning, <b>rasterized,</b> digital {{replacement}} for the vectorized, analog telautograph."The Secret Life of the Fax Machine" [...] by Tim Hunkin ...|$|R
