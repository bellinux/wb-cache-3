1573|2207|Public
5|$|Perl 2, {{released}} in 1988, featured a better <b>regular</b> <b>expression</b> engine. Perl 3, {{released in}} 1989, added support for binary data streams.|$|E
5|$|The Perl {{languages}} borrow features {{from other}} programming languages including C, shell script (sh), AWK, and sed. They provide powerful text processing facilities without the arbitrary data-length limits of many contemporary Unix commandline tools, facilitating easy manipulation of text files. Perl 5 gained widespread {{popularity in the}} late 1990s as a CGI scripting language, {{in part due to}} its then unsurpassed <b>regular</b> <b>expression</b> and string parsing abilities.|$|E
25|$|NFAs can be {{constructed}} from any <b>regular</b> <b>expression</b> using Thompson's construction algorithm.|$|E
40|$|AbstractTimed <b>regular</b> <b>expressions</b> are an {{extension}} of <b>regular</b> <b>expressions</b> that capture a notion of time. Roughly speaking, timed <b>regular</b> <b>expressions</b> {{can be used to}} represent timed sequences of events, with new operators to control the duration of those sequences. These timed <b>regular</b> <b>expressions</b> correspond to a form of timed automaton equipped with clocks, of the kind introduced by Alur and Dill. We develop a coalgebraic treatment of such timed <b>regular</b> <b>expressions,</b> {{along the lines of the}} coalgebraic treatment of <b>regular</b> <b>expressions</b> based on deterministic automata. This yields a coinductive proof principle, that can be used to establish equivalence of a class of timed <b>regular</b> <b>expressions...</b>|$|R
40|$|We {{improve on}} some recent results on lower bounds for {{conversion}} problems for <b>regular</b> <b>expressions.</b> In particular {{we consider the}} conversion of planar deterministic finite automata to <b>regular</b> <b>expressions,</b> study {{the effect of the}} complementation operation on the descriptional complexity of <b>regular</b> <b>expressions,</b> and the conversion of <b>regular</b> <b>expressions</b> extended by adding intersection or interleaving to ordinary <b>regular</b> <b>expressions.</b> Almost all obtained lower bounds are optimal, and the presented examples are over a binary alphabet, which is best possible...|$|R
50|$|<b>Regular</b> <b>Expressions</b> covers {{extension}} {{elements and}} functions that provide facilities {{to do with}} <b>regular</b> <b>expressions.</b>|$|R
25|$|Bash 3.0 {{supports}} in-process <b>regular</b> <b>expression</b> matching using a syntax {{reminiscent of}} Perl. man page.|$|E
25|$|The {{language}} of M {{can be described}} by the regular language given by the <b>regular</b> <b>expression</b> (0|1)*1.|$|E
25|$|An {{extended}} {{context-free grammar}} (or regular right part grammar) {{is one in}} which the right-hand side of the production rules is allowed to be a <b>regular</b> <b>expression</b> over the grammar's terminals and nonterminals. Extended context-free grammars describe exactly the context-free languages.|$|E
5000|$|<b>Regular</b> <b>expressions</b> {{manipulation}} support using scheme <b>regular</b> <b>expressions,</b> {{a little}} languages {{approach to the}} capabilities; ...|$|R
40|$|The {{equivalence}} of non-deterministic finite automata (NFA 1), deterministic finite automata (DFA), <b>regular</b> <b>expressions</b> (RE), {{and parallel}} finite automata (PFA) with augmented <b>regular</b> <b>expressions</b> (PRE) {{is used to}} relate parallel finite automata to the shuffle operation on regular languages. Our goal is {{to capitalize on the}} equivalence of <b>regular</b> <b>expressions</b> and augmented <b>regular</b> <b>expressions</b> to increase parallelization efficiency. We use the existing automated transformation algorithms for the various finite automata listed above, as well as one of our own, to inform a transformation from augmented <b>regular</b> <b>expressions</b> to minimized deterministic finite automata (DF Amin). We then discuss the serialization of augmented <b>regular</b> <b>expressions,</b> and present a brief summary of potential applications, related research, and future directions. 1...|$|R
40|$|We {{study the}} {{membership}} problem for <b>regular</b> <b>expressions</b> extended with operators for unordered concatenation and numerical constraints. The unordered concatenation {{of a set}} of <b>regular</b> <b>expressions</b> denotes all sequences consisting of exactly one word denoted by each of the expressions. Numerical constraints are an extension of <b>regular</b> <b>expressions</b> used in many applications, e. g. text search (e. g., UNIX grep), document formats (e. g. XML Schema). <b>Regular</b> <b>expressions</b> with unordered concatenation and numerical constraints denote the same languages as the classical <b>regular</b> <b>expressions,</b> but, in certain important cases, exponentially more succinct. We show that the membership problem for <b>regular</b> <b>expressions</b> with unordered concatenation (without numerical constraints) is already NP-hard. We show a polynomial-time algorithm for the membership problem for <b>regular</b> <b>expressions</b> with numerical constraints and unordered concatenation, when restricted to a subclass called strongly 1 -unambiguous. The original publication is available at www. springerlink. co...|$|R
25|$|JavaScript syntax defines several native {{data types}} {{that are not}} {{included}} in the JSON standard: Map, Set, Date, Error, <b>Regular</b> <b>Expression,</b> Function, Promise, and undefined. type was left out of the JSON standard, and one finds suggestions that null be used instead.|$|E
25|$|They use a syntax {{based on}} <b>regular</b> <b>expression</b> syntax, {{inherited}} from SGML, {{to describe the}} schema. Typical XML APIs such as SAX do not attempt to offer applications a structured representation of the syntax, so it is less accessible to programmers than an element-based syntax may be.|$|E
25|$|Optionally, the hunk range can be {{followed}} by the heading of the section or function that the hunk is part of. This is mainly useful to make the diff easier to read. When creating a diff with GNU diff, the heading is identified by <b>regular</b> <b>expression</b> matching.|$|E
40|$|Abstract. An {{original}} algorithm for {{transformation of}} finite automata to <b>regular</b> <b>expressions</b> is presented. This algorithm {{is based on}} effective graph algorithms and gives a transparent new proof of equivalence of <b>regular</b> <b>expressions</b> and finite automata. Key words: regular sets, finite automata, construction of <b>regular</b> <b>expressions.</b> 1...|$|R
50|$|The IEEE POSIX {{standard}} {{has three}} sets of compliance: BRE (Basic <b>Regular</b> <b>Expressions),</b> ERE (Extended <b>Regular</b> <b>Expressions),</b> and SRE (Simple <b>Regular</b> <b>Expressions).</b> SRE is deprecated, in favor of BRE, as both provide backward compatibility. The subsection below covering the character classes applies to both BRE and ERE.|$|R
40|$|We give {{characterizations}} of strong determinism for <b>regular</b> <b>expressions</b> with counting, based {{on which we}} present an O(|Σ E ∥E|) time algorithm to check whether an expression E with counting is strongly deterministic where Σ E is the set of distinct symbols in E. It improves the previous upper bound of O(|E| 3) time on the same decision problems for both standard <b>regular</b> <b>expressions</b> and <b>regular</b> <b>expressions</b> with counting. As a natural result of our work we derive a characterization of weak determinism for <b>regular</b> <b>expressions</b> with counting, {{which leads to a}} new O(|Σ E ∥E|) time algorithm for deciding weak determinism of <b>regular</b> <b>expressions</b> with counting. © 2012 Springer-Verlag. National Taiwan University; National Science Council; Ministry of Education; Academia Sinica; European Association for Theoretical Computer ScienceWe give {{characterizations of}} strong determinism for <b>regular</b> <b>expressions</b> with counting, based on which we present an O(|Σ E ∥E|) time algorithm to check whether an expression E with counting is strongly deterministic where Σ E is the set of distinct symbols in E. It improves the previous upper bound of O(|E| 3) time on the same decision problems for both standard <b>regular</b> <b>expressions</b> and <b>regular</b> <b>expressions</b> with counting. As a natural result of our work we derive a characterization of weak determinism for <b>regular</b> <b>expressions</b> with counting, which leads to a new O(|Σ E ∥E|) time algorithm for deciding weak determinism of <b>regular</b> <b>expressions</b> with counting. © 2012 Springer-Verlag...|$|R
25|$|Perl's <b>regular</b> <b>expression</b> and string-processing {{support has}} always been one of its {{defining}} features. Since Perl's pattern-matching constructs have exceeded the capabilities of regular language expressions for some time, Perl 6 documentation will exclusively refer to them as regexen, distancing the term from the formal definition.|$|E
25|$|JavaScriptCore is a {{framework}} that provides a JavaScript engine for WebKit implementations, and provides this type of scripting in other contexts within macOS. JavaScriptCore is originally derived from KDE's JavaScript engine (KJS) library (which {{is part of the}} KDE project) and the PCRE <b>regular</b> <b>expression</b> library. Since forking from KJS and PCRE, JavaScriptCore has been improved with many new features and greatly improved performance.|$|E
25|$|Just-in-time compilers {{can produce}} {{customized}} machine code based on run-time data, {{at the cost}} of compilation overhead. This technique dates to the earliest <b>regular</b> <b>expression</b> engines, and has become widespread with Java HotSpot and V8 for JavaScript. In some cases adaptive optimization may be able to perform run time optimization exceeding the capability of static compilers by dynamically adjusting parameters according to the actual input or other factors.|$|E
50|$|ORO: ORO {{was a set}} of text-processing Java {{classes that}} provide Perl5 {{compatible}} <b>regular</b> <b>expressions,</b> AWK-like <b>regular</b> <b>expressions,</b> glob expressions, and utility classes for performing substitutions, splits, filtering filenames, etc.|$|R
50|$|<b>Regular</b> <b>expressions</b> were {{incorporated}} starting with NoteTab Light 5.4. The general syntax of NoteTab <b>regular</b> <b>expressions</b> {{uses the same}} rules as Perl.|$|R
40|$|We dene {{algebraic}} systems called concurrent <b>regular</b> <b>expressions</b> {{which provide}} a modular description of languages of Petri nets. Concurrent <b>regular</b> <b>expressions</b> are extension of <b>regular</b> <b>expressions</b> with four operators- interleaving, interleaving closure, synchronous composition and renaming. This alternative characterization of Petri net languages {{gives us a}} exible way of specifying concurrent systems. Concurrent <b>regular</b> <b>expressions</b> are modular and hence easier to use for specication. The proof of equivalence also provides a natural decomposition method for Petri nets. ...|$|R
25|$|In the 1960s, Thompson {{also began}} work on regular expressions. Thompson had {{developed}} the CTSS version of the editor QED, which included regular expressions for searching text. QED and Thompson's later editor ed (the standard text editor on Unix) contributed greatly to the eventual popularity of regular expressions, and regular expressions became pervasive in Unix text processing programs. Almost all programs that work with regular expressions today use some variant of Thompson's notation. He also invented Thompson's construction algorithm used for converting <b>regular</b> <b>expression</b> into nondeterministic finite automaton {{in order to make}} expression matching faster.|$|E
25|$|The C++ {{standard}} {{consists of}} two parts: the core language and the standard library. C++ programmers expect the latter on every major implementation of C++; it includes vectors, lists, maps, algorithms (find, for_each, binary_search, random_shuffle, etc.), sets, queues, stacks, arrays, tuples, input/output facilities (iostream, for reading from and writing to the console and files), smart pointers for automatic memory management, <b>regular</b> <b>expression</b> support, multi-threading library, atomics support (allowing a variable to be read or written to by at most one thread at a time without any external synchronisation), time utilities (measurement, getting current time, etc.), a system for converting error reporting that doesn't use C++ exceptions into C++ exceptions, a random number generator and a slightly {{modified version of the}} C standard library (to make it comply with the C++ type system).|$|E
25|$|An {{example of}} the focused {{crawlers}} are academic crawlers, which crawls free-access academic related documents, such as the citeseerxbot, which is the crawler of CiteSeerX search engine. Other academic search engines are Google Scholar and Microsoft Academic Search etc. Because most academic papers are published in PDF formats, such kind of crawler is particularly interested in crawling PDF, PostScript files, Microsoft Word including their zipped formats. Because of this, general open source crawlers, such as Heritrix, must be customized to filter out other MIME types, or a middleware is used to extract these documents out and import them to the focused crawl database and repository. Identifying whether these documents are academic or not is challenging and can add a significant overhead to the crawling process, so this is performed as a post crawling process using machine learning or <b>regular</b> <b>expression</b> algorithms. These academic documents are usually obtained from home pages of faculties and students or from publication page of research institutes. Because academic documents takes {{only a small fraction}} in the entire web pages, a good seed selection are important in boosting the efficiencies of these web crawlers. Other academic crawlers may download plain text and HTML files, that contains metadata of academic papers, such as titles, papers, and abstracts. This increases the overall number of papers, but a significant fraction may not provide free PDF downloads.|$|E
40|$|Perl <b>regular</b> <b>expressions</b> {{allow you}} to locate {{patterns}} in a string. Many of the string processing tasks in SAS can be done using Perl <b>regular</b> <b>expressions.</b> These tasks can also be performed using traditional string functions in SAS. But, Perl <b>regular</b> <b>expressions</b> can sometimes provide a much more compact solution to a much more complicated string manipulation task. Here we will give some examples to show {{the usefulness of the}} Perl <b>regular</b> <b>expressions</b> in SAS programs...|$|R
40|$|AbstractWe define {{algebraic}} systems called concurrent <b>regular</b> <b>expressions</b> {{which provide}} a modular description of languages of Petri nets. Concurrent <b>regular</b> <b>expressions</b> are extension of <b>regular</b> <b>expressions</b> with four operators - interleaving, interleaving closure, synchronous composition and renaming. This alternative characterization of Petri net languages {{gives us a}} flexible way of specifying concurrent systems. Concurrent <b>regular</b> <b>expressions</b> are modular and, hence, easier to use for specification. The proof of equivalence also provides a natural decomposition method for Petri nets...|$|R
40|$|We {{investigate}} {{the complexity of}} several predicates on regular sets. In particular, we show: 1) the equivalence and emptiness problem for <b>regular</b> <b>expressions</b> using only the operators -, ∪,., and ∩ are p-complete. 2) the emptiness problem for <b>regular</b> <b>expressions</b> using the operators -, ∪,., ∩ and * is tape-hard; 3) the emptiness problem for <b>regular</b> <b>expressions</b> using the operators -, ∪,., ∩ and 2 is tape-hard; 4) the equivalence problem for <b>regular</b> <b>expressions</b> using the operators -, ∪,., ∩ and * is not polynomial in tape; and 5) the equivalence problem for <b>regular</b> <b>expressions</b> using the operators -, ∪,., ∩ and 2 requires exponential time...|$|R
2500|$|... simulates DFAs, NFAs and ε-NFAs, {{including}} {{generated by}} <b>regular</b> <b>expression.</b>|$|E
2500|$|...grep_v(regexp) {{which will}} match all {{negative}} {{examples of a}} given <b>regular</b> <b>expression</b> {{in addition to other}} new features.|$|E
2500|$|The regular {{language}} of unary strings {{of a given}} character, say 'a' (the <b>regular</b> <b>expression</b> a*), has the unambiguous grammar: ...|$|E
40|$|AbstractWe {{consider}} {{the use of}} state elimination to construct shorter <b>regular</b> <b>expressions</b> from finite-state automata (FAs). Although state elimination is an intuitive method for computing <b>regular</b> <b>expressions</b> from FAs, the resulting <b>regular</b> <b>expressions</b> are often very long and complicated. We examine the minimization of FAs to obtain shorter expressions first. Then, we introduce vertical chopping based on bridge states and horizontal chopping based on the structural properties of given FAs. We prove {{that we should not}} eliminate bridge states until we eliminate all non-bridge states to obtain shorter <b>regular</b> <b>expressions.</b> In addition, we suggest heuristics for state elimination that leads to shorter <b>regular</b> <b>expressions</b> based on vertical chopping and horizontal chopping...|$|R
40|$|<b>Regular</b> <b>expressions</b> {{provide a}} {{powerful}} tool for textual search in computers. The language of <b>regular</b> <b>expressions</b> forms the basis for many applications and languages in computers, including vi, sed, awk, and perl. In this article, I’ll present the use of <b>regular</b> <b>expressions</b> to perform search and replace operations, using vi, sed, and awk as the applications. ...|$|R
40|$|This {{cookbook}} {{provides more}} than 100 recipes {{to help you}} crunch data and manipulate text with <b>regular</b> <b>expressions.</b> Every programmer can find uses for <b>regular</b> <b>expressions,</b> but their power doesn't come worry-free. Even seasoned users often suffer from poor performance, false positives, false negatives, or perplexing bugs. <b>Regular</b> <b>Expressions</b> Cookbook offers step-by-step instructions {{for some of the}} most common tasks involving this tool, with recipes for C#, Java, JavaScript, Perl, PHP, Python, Ruby, and VB. NET. With this book, you will: Understand the basics of <b>regular</b> <b>expressions</b> through...|$|R
