2|5|Public
5000|$|Declaring a savearea statically in the called routine {{makes it}} non-reentrant and non-recursive; a <b>reentrant</b> <b>program</b> uses a dynamic savearea, {{acquired}} {{either from the}} operating system and freed upon returning, or in storage passed by the calling program.|$|E
50|$|It is usual to {{associate}} a single process with a main program, and child processes with any spin-off, parallel processes, which behave like asynchronous subroutines. A process {{is said to}} own resources, of which an image of its program (in memory) is one such resource. However, in multiprocessing systems many processes may run off of, or share, the same <b>reentrant</b> <b>program</b> at the same location in memory, but each process is said to own its own image of the program.|$|E
5000|$|Other terms {{used for}} <b>reentrant</b> <b>programs</b> include [...] "pure procedure" [...] or [...] "sharable code".|$|R
50|$|The {{software}} {{developed by}} {{the staff of the}} University of Michigan's academic Computing Center for the operation of the IBM S/360-67, S/370, and compatible computers can be described as a multiprogramming, multiprocessing, virtual memory, time-sharing supervisor (University of Michigan Multiprogramming Supervisor or UMMPS) that handles a number of resident, <b>reentrant</b> <b>programs.</b> Among them is a large subsystem, called MTS (Michigan Terminal System), for command interpretation, execution control, file management, and accounting. End-users interact with the computer's resources through MTS using terminal, batch, and server oriented facilities.|$|R
40|$|Abstract. In {{object-oriented}} <b>programming,</b> <b>reentrant</b> method invocations {{and shared}} references {{make it difficult}} to achieve adequate encapsulation for sound modular reasoning. This tutorial paper surveys recent progress using auxiliary state (ghost fields) to describe and achieve encapsulation. Encapsulation is assessed in terms of modular reasoning about invariants and simulations. ...|$|R
40|$|In {{object-oriented}} <b>programming,</b> <b>reentrant</b> method invocations {{and shared}} references {{make it difficult}} to achieve adequate encapsulation for sound modular reasoning. This tutorial paper surveys recent progress using auxiliary state (ghost fields) to describe and achieve encapsulation. It also compares this technique with encapsulation in the forms provided by separation logic. Encapsulation is assessed in terms of modular reasoning about invariants and simulations...|$|R
5000|$|With severe memory {{constraints}} and real time use, keeping {{only a single}} copy of code loaded into core was a requirement. Since the 1108 was designed for multitasking, the system was fully [...] "reentrant" [...] (thread safe). Each <b>reentrant</b> module accessed <b>program</b> data through a single memory [...] "base address", which was different for each instance of run data. Switching execution contexts {{could be done in}} a single instruction merely by setting a different base address in a single register. The system used fine-grained locking to protect shared data structures. The executive, compilers, utilities, and even sophisticated user applications that might have multiple copies running concurrently were written so that their code could be shared. This required loading only one copy into memory, saving both space and the time it took to load the code.|$|R

