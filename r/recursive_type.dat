77|631|Public
5000|$|The object-depending-on-object {{can also}} be {{declared}} as a constant {{as part of a}} <b>recursive</b> <b>type.</b> An example of a <b>recursive</b> <b>type</b> is: ...|$|E
5000|$|To better see the {{relationship}} between the <b>recursive</b> <b>type</b> and its anamorphism, note that Tree and List can be defined thus: ...|$|E
50|$|An anamorphism can {{be defined}} for any <b>recursive</b> <b>type,</b> {{according}} to a generic pattern, generalizing the second version of ana for lists.|$|E
40|$|We study <b>recursive</b> <b>types</b> from a {{syntactic}} perspective. In particular, {{we compare}} the formulations of <b>recursive</b> <b>types</b> {{that are used}} in programming languages and formal systems. Our main tool is a new syntactic explanation of type expressions as functors. We also introduce a simple logic for programs with <b>recursive</b> <b>types</b> in which we carry out our proofs. 1 Introduction <b>Recursive</b> <b>types</b> are common in both programming languages and formal systems. By now, there is a deep and well-developed semantic theory of <b>recursive</b> <b>types.</b> The syntactic aspects of <b>recursive</b> <b>types</b> are also well understood in some special cases. In particular, there is an important body of knowledge about covariant <b>recursive</b> <b>types,</b> which include datatypes like natural numbers, lists, and trees. Beyond the covariant case, however, the syntactic understanding of <b>recursive</b> <b>types</b> becomes rather spotty. Consequently, the relations between various alternative formulations of <b>recursive</b> <b>types</b> are generally unclear. Furthermore, th [...] ...|$|R
40|$|Abstract We study <b>recursive</b> <b>types</b> from a {{syntactic}} perspective. In particular, {{we compare}} the formulations of <b>recursive</b> <b>types</b> {{that are used}} in programming languages and formal systems. Our main tool is a new syntactic explanation of type expressions as functors. We also introduce a simple logic for programs with <b>recursive</b> <b>types</b> in which we carry out our proofs. 1 Introduction <b>Recursive</b> <b>types</b> are common in both programming languages and formal systems. By now, there is a deep and well-developed semantic theory of <b>recursive</b> <b>types.</b> The syntactic aspects of <b>recursive</b> <b>types</b> are also well understood in some special cases. In particular, there is an important body of knowledge about covariant <b>recursive</b> <b>types,</b> which include datatypes like natural numbers, lists, and trees. Beyond the covariant case, however, the syntactic understanding of <b>recursive</b> <b>types</b> becomes rather spotty. Consequently, the relations between various alternative formulations of <b>recursive</b> <b>types</b> are generally unclear. Furthermore, the syntactic counterparts {{to some of the most}} basic semantic results are unknown...|$|R
40|$|Abstract. <b>Recursive</b> <b>types</b> are {{ubiquitous}} in modern programming languages, as they occur when typing constructs such as datatype definitions. Any typetheoretic framework must effectively deal with <b>recursive</b> <b>types</b> if it purports {{to be applicable}} to real languages such as ML and Haskell. Intensional Type Analysis [1] and Certified Binaries [2] are two such type-theoretic frameworks. Previous work in these areas, however, has not adequately supported <b>recursive</b> <b>types.</b> In this paper we present a new formulation of <b>recursive</b> <b>types</b> which subsumes the traditional one. We show that intensional analysis over these <b>types</b> (including higher-kinded <b>recursive</b> <b>types)</b> can be supported via inductive elimination. Our solution is simple, general, and extensible; the typing rules for higher-kinded <b>recursive</b> <b>types</b> are concise and very easy to understand. ...|$|R
50|$|A general {{algebraic}} {{data type}} is a possibly recursive sum {{type of product}} types. Each constructor tags a product type to separate it from others, or if {{there is only one}} constructor, the data type is a product type. Further, the parameter types of a constructor are the factors of the product type. A parameterless constructor corresponds to the empty product. If a datatype is recursive, the entire sum of products is wrapped in a <b>recursive</b> <b>type,</b> and each constructor also rolls the datatype into the <b>recursive</b> <b>type.</b>|$|E
50|$|In type theory, a <b>recursive</b> <b>type</b> has {{the general}} form μα.T where the type {{variable}} α may {{appear in the}} type T and stands for the entire type itself.|$|E
50|$|There are {{two forms}} of {{recursive}} types: the so-called isorecursive types, and equirecursive types. The two forms differ in how terms of a <b>recursive</b> <b>type</b> are introduced and eliminated.|$|E
40|$|We study <b>recursive</b> <b>types</b> from a {{syntactic}} perspective. In particular, {{we compare}} the formulations of <b>recursive</b> <b>types</b> {{that are used}} in programming languages and formal systems. Our main tool is a new syntactic explanation of type expressions as functors. We also introduce a simple logic for programs with <b>recursive</b> <b>types</b> in which we carry out our proofs...|$|R
40|$|Although {{theories}} of equivalence or subtyping for <b>recursive</b> <b>types</b> have been extensively investigated, sophisticated interaction between <b>recursive</b> <b>types</b> and abstract types has gained little attention. The key idea behind <b>type</b> theories for <b>recursive</b> <b>types</b> {{is to use}} syntactic contractiveness, meaning every µ-bound variable occurs only under a type constructor such as → or ∗. This syntactic contractiveness guarantees {{the existence of the}} unique solution of recursive equations and thus has been considered necessary for designing a sound theory for <b>recursive</b> <b>types.</b> However, in an advanced type system, such as OCaml, with <b>recursive</b> <b>types,</b> type parameters, and abstract types, we cannot easily define the syntactic contractiveness of types. In this paper, we investigate a sound <b>type</b> system for <b>recursive</b> <b>types,</b> type parameters, and abstract types. In particular, we develop a new semantic notion of contractiveness for types and signatures using mixed induction and coinduction, and show that our type system is sound with respect to the standard call-by-value operational semantics, which eliminates signature sealings. Moreover we show that while non-contractive types in signatures lead to unsoundness of the type system, they may be allowed in modules. We have also formalized the whole system and its type soundness proof in Coq...|$|R
40|$|Efficient {{storage of}} types within a {{compiler}} {{is necessary to}} avoid large blowups in space during compilation. <b>Recursive</b> <b>types</b> in particular are important to consider, as naive representations of <b>recursive</b> <b>types</b> may be arbitrarily larger than necessary through unfolding. Hash-consing {{has been used to}} efficiently store non-recursive types [7]. Deterministic finite automata techniques have been used to efficiently perform various operations on <b>recursive</b> <b>types</b> [4]. We present a new system for storing <b>recursive</b> <b>types</b> combining hash-consing and deterministic finite automata techniques. The space requirements are linear in the number of distinct types. Both update and lookup operations take polynomial time and linear space and type equality can be checked in constant time once both types are in the system...|$|R
50|$|F-bounded {{quantification}} or recursively bounded quantification, {{introduced in}} 1989, allows for more precise typing of functions that are applied on recursive types. A <b>recursive</b> <b>type</b> {{is one that}} includes a function that uses it as a type for some argument or its return value.|$|E
5000|$|For the {{purposes}} of the List example, these two formulations are not significantly different; but the second form allows expressing so-called nested data types, i.e., those where the <b>recursive</b> <b>type</b> differs parametrically from the original. (For more information on nested data types, see the works of Richard Bird, Lambert Meertens, and Ross Paterson.) ...|$|E
5000|$|With isorecursive types, the <b>recursive</b> <b>type</b> [...] and its {{expansion}} (or unrolling) [...] (Where {{the notation}} indicates that all instances of Z are replaced with Y in X) are distinct (and disjoint) types with special term constructs, usually called roll and unroll, that form an isomorphism between them. To be precise: [...] and , {{and these two}} are inverse functions.|$|E
40|$|We study subtype {{checking}} for <b>recursive</b> <b>types</b> in system kernel Fun, a typed λ-calculus with subtyping and bounded second-order polymorphism. Along {{the lines of}} [AC 93], we define a subtype relation over kernel Fun <b>recursive</b> <b>types,</b> and prove it to be transitive. We then show that the natural extension of the algorithm introduced in [AC 93] to compare first-order <b>recursive</b> <b>types</b> yields a non complete algorithm. Finally, we prove the completeness and correctness of a different algorithm, which lends itself to efficient implementations...|$|R
40|$|This note {{proposes a}} {{generalization}} of the Hylo-shift law for functional program calculation. The generalization allows to handle transformations involving <b>recursive</b> <b>types</b> generated by polynomials where other <b>recursive</b> <b>types</b> occur (for instance, lists of binary trees). Presidência do Conselho de Ministros - POSI/ICHS/ 44304 / 2002...|$|R
40|$|AbstractWe study subtype {{checking}} for <b>recursive</b> <b>types</b> in system kernel Fun, a typed λ-calculus with subtyping and bounded second-order polymorphism. Along {{the lines of}} [ACM Transactions on Programming Languages and Systems, 15 (4), (1993) 575], we define a subtype relation over kernel Fun <b>recursive</b> <b>types,</b> and prove it to be transitive. We then show that the natural extension of the algorithm introduced in [loc. cit] to compare first-order <b>recursive</b> <b>types</b> yields a non complete algorithm. Finally, we prove the completeness and correctness of a different algorithm, which lends itself to efficient implementations...|$|R
50|$|The complex types, schematizable as X/Y and X\Y, denote functor {{types that}} take an {{argument}} of type Y and return an object of type X. A forward slash denotes that the argument should appear to the right, while a backslash denotes that the argument should appear on the left. Any type can stand in for the X and Y here, making syntactic types in CCG a <b>recursive</b> <b>type</b> system.|$|E
5000|$|This {{is because}} type synonyms, like typedefs in C, are {{replaced}} with their definition at compile time. (Type synonyms are not [...] "real" [...] types; {{they are just}} [...] "aliases" [...] for convenience of the programmer.) But {{if you try to}} do this with a <b>recursive</b> <b>type,</b> it will loop infinitely because {{no matter how many times}} you substitute it, it still refers to itself, e.g. [...] "Bad" [...] will grow indefinitely: (Int, (Int, (Int, ...|$|E
5000|$|The Haskell List datatype {{can also}} be {{represented}} in type theory {{in a slightly different}} form, thus:.(Note how the [...] and [...] constructs are reversed relative to the original.) The original formation specified a type function which body was a <b>recursive</b> <b>type.</b> The revised version specifies a recursive function on types. (The type variable [...] is used to suggest a function rather than a base type like , since [...] is like a Greek f.) The function must also now be applied [...] to its argument type [...] {{in the body of the}} type.|$|E
40|$|We give an {{analysis}} of classes of <b>recursive</b> <b>types</b> by presenting two extensions of the simply-typed lambda calculus. The first language only allows <b>recursive</b> <b>types</b> with built-in principles of well-founded induction, while the second allows more general <b>recursive</b> <b>types</b> which permit non-terminating computations. We discuss the expressive power of the languages, examine the properties of reduction-based operational semantics for them, and give examples of their use in expressing iteration over large ordinals and in simulating both call-by-name and call-by-value versions of the untyped lambda calculus. The motivations for this wor...|$|R
40|$|In {{this paper}} we study {{decision}} problems and invertibility for two notions of equivalence of <b>recursive</b> <b>types.</b> In particular, for <b>recursive</b> <b>types</b> presented {{by means of}} a recursion operator µ, we describe an algorithm showing that the natural equivalence generated by finitely many steps of folding and unfolding of -types is decidable. For <b>recursive</b> <b>types</b> presented by finite systems of recursive equations, we give a thoroughly coinductive characterization of the equivalence induced by their interpretation as infinite (regular) trees, from which the decidability of this equivalence follows. A formal proof of the former result, to our knowledge, has never appeared in the literature. The latter result, on the contrary, is well known but we present here a new proof obtained as an application of general coalgebraic facts to the theory of <b>recursive</b> <b>types.</b> From these results invertibility is easily proved for both equivalences...|$|R
40|$|The {{problem of}} {{defining}} and checking a subtype relation between <b>recursive</b> <b>types</b> was studied in [3] {{for a first}} order type system, but for second order systems, which combine subtyping and parametric polymorphism, only negative results are known [17]. This paper studies the problem of subtype checking for <b>recursive</b> <b>types</b> in system kernel Fun, a typed λ-calculus with subtyping and bounded second order polymorphism. Along the lines of [3], we study {{the definition of a}} subtype relation over kernel Fun <b>recursive</b> <b>types,</b> and then we present a subtyping algorithm which is sound and complete with respect to this relation. We show that the natural extension of the techniques introduced in [3] to compare first order <b>recursive</b> <b>types</b> gives a non complete algorithm. We prove the completeness and correctness of a different algorithm, which also admits an efficient implementation...|$|R
5000|$|Under equirecursive rules, a <b>recursive</b> <b>type</b> [...] and its {{unrolling}} [...] {{are equal}} -- that is, those two type expressions are understood to denote the same type. In fact, most theories of equirecursive types go further and essentially stipulate that any two type expressions {{with the same}} [...] "infinite expansion" [...] are equivalent. As {{a result of these}} rules, equirecursive types contribute significantly more complexity to a type system than isorecursive types do. Algorithmic problems such as type checking and type inference are more difficult for equirecursive types as well. Since direct comparison does not make sense on an equirecursive type, they can be converted into a canonical form in O(n log n) time, which can easily be compared.|$|E
40|$|In {{this paper}} we {{describe}} the construction in hol of the inductive type of arbitrarily branching labeled trees. Such a type is characterized by an initiality theorem similar to that for finitely branching labeled trees. We discuss how to use this type to extend the system of simple <b>recursive</b> <b>type</b> specifications automatically definable in hol to ones including a limited class of functional arguments. The work discussed here {{is a part of}} a larger project to expand the recursive types package of hol which is nearing completion. All work described in this paper has been completed. 1 A Broader Class of <b>Recursive</b> <b>Type</b> Definitions The work described in this paper forms the foundation of a project to expand the class of <b>recursive</b> <b>type</b> specifications for which hol is capable of automatically defining the types specified and proving the initiality theorem, which acts as an axiomatization for the defined types. The full class of specifications the project aims to handle are those BNF- [...] ...|$|E
40|$|AbstractRelational {{interpretations of}} type systems {{are useful for}} {{establishing}} properties of programming languages. For languages with recursive types {{it is difficult to}} establish the existence of a relational interpretation. The usual approach is to pass to a domain-theoretic model of the language and, exploiting the structure of the model, to derive relational properties of it. We investigate the construction of relational interpretations of recursive types in a purely operational setting, drawing on recent ideas from domain theory and operational semantics as a guide. We prove syntactic minimal invariance for an extension of PCF with a <b>recursive</b> <b>type,</b> a syntactic analogue of the minimal invariance property used by Freyd and Pitts to characterize the domain interpretation of a <b>recursive</b> <b>type.</b> As Pitts has shown in the setting of domains, syntactic minimal invariance suffices to establish the existence of relational interpretations. We give two applications of this construction. First, we derive a notion of logical equivalence for expressions of the language that we show coincides with experimental equivalence and which, by virtue of its construction, validates useful induction and coinduction principles for reasoning about the <b>recursive</b> <b>type.</b> Second, we give a relational proof of correctness of the continuation-passing transformation, which is used in some compilers for functional languages...|$|E
40|$|A typed lambda {{calculus}} with categorical type constructors is introduced. It has a uniform category theoretic mechanism to declare new types. Its type structure includes categorical objects like products and coproducts {{as well as}} <b>recursive</b> <b>types</b> like natural numbers and lists. It also allows duals of <b>recursive</b> <b>types,</b> i. e. lazy types, like infinite lists. It has generalized iterators for <b>recursive</b> <b>types</b> and duals of iterators for lazy types. We will give reduction rules for this simply typed {{lambda calculus}} and {{show that they are}} strongly normalizing even though it has infinite things like infinite lists. ...|$|R
40|$|Inheritance in {{the form}} of subtyping is {{considered}} in the framework of a polymorphic type discipline with records, variants, and <b>recursive</b> <b>types.</b> We give a denotational semantics based on the paradigm that interprets subtyping as explicit coercion. The main technical result gives a coherent interpretation for a strong rule for deriving inheritances between <b>recursive</b> <b>types...</b>|$|R
40|$|Abstract. We {{present a}} model of Linear Abadi and Plotkin Logic for parametricity [8] based on the {{operational}} semantics of LILY, a polymorphic linear lambda calculus endowed with an operational semantics [3]. We use it to formally prove definability of general <b>recursive</b> <b>types</b> in LILY and to derive reasoning principles for the <b>recursive</b> <b>types.</b> ...|$|R
40|$|Abstract. Using methods {{drawn from}} Game Semantics, we build a sound and {{computationally}} adequate {{model of a}} simple calculus that includes both subtyping and recursive types. Our model solves <b>recursive</b> <b>type</b> equations up to equality, and is shown to validate a subtyping rule for recursive types proposed by Amadio and Cardelli...|$|E
40|$|This thesis describes:  * a {{mechanism}} for structuring and indexing a design space, where  * {{the elements of the}} space are functional decompositions, and  * the generative operators are <b>recursive</b> <b>type</b> constraints.   The goal is to produce an index for design space that is based on cataloguing design decisions...|$|E
40|$|Using methods {{drawn from}} Game Semantics, we build a sound and {{computationally}} adequate {{model of a}} simple calculus that includes both subtyping and recursive types. Our model solves <b>recursive</b> <b>type</b> equations up to equality, and is shown to validate a subtyping rule for recursive types proposed by Amadio and Cardelli...|$|E
40|$|This report {{provides}} a necessary formal apparatus for discussing the redundancy of <b>recursive</b> <b>types</b> {{in the presence}} of high-order polymorphism. It also clarifies the relation of the general concepts involved to the well-known situations of natural numbers and lists, and to the not-so-well-known area of trees. 2 <b>Recursive</b> <b>types,</b> structural induction, and the universal embeddin...|$|R
40|$|Abstract. Inheritance in {{the form}} of subtyping is {{considered}} in the framework of a polymorphic type discipline with records, variants, and <b>recursive</b> <b>types.</b> We give a denotational semantics based on the paradigm that interprets subtyping as explicit coercion. The main technical result gives a coherent interpretation for a strong rule for deriving inheritances between <b>recursive</b> <b>types.</b> ...|$|R
40|$|Abstract The {{problem of}} {{defining}} and checking a subtype relationbetween <b>recursive</b> <b>types</b> was studied in [3] {{for a first}} order type system, but for second order systems, which combinesubtyping and parametric polymorphism, only negative results are known [17]. This paper studies the problem of subtype checking for <b>recursive</b> <b>types</b> in system kernel Fun, a typed *-calculuswith subtyping and bounded second order polymorphism. Along the lines of [3], we study {{the definition of a}} sub-type relation over kernel Fun <b>recursive</b> <b>types,</b> and then we present a subtyping algorithm which is sound and completewith respect to this relation. We show that the natural extension of the techniques introduced in [3] to compare firstorder <b>recursive</b> <b>types</b> gives a non complete algorithm. We prove the completeness and correctness of a different algo-rithm, which also admits an efficient implementation. Keywords: type theory and type systems, subtyping, recur-sive types, kernel Fun...|$|R
