1|9619|Public
40|$|End user {{computing}} environments, e. g. web browsers and PC operating systems, are {{the target}} {{of a large number of}} attacks, both online and offline. The nature of these attacks varies from simple online attacks, such as user tracking using cookies, to more sophisticated attacks on security protocols and cryptographic algorithms. Other methods of attack exist that target end user applications that utilise and interact with cryptographic functions provided by the PC operating system. After providing a general introduction to the security techniques and protocols used in this thesis, a review of possible threats to end user computing environments is given, followed by a discussion of the countermeasures needed to combat these threats. The contributions of this thesis include three new approaches for enhancing the security of end user systems, together with an analysis and a prototype implementation of an end user security enhancement tool. The following paragraphs summarise the three main contributions of this thesis. Digitally signing a digital document is a straightforward procedure; however, when the digital document contains dynamic content, the digital signature may remain valid but the viewed document may not be the same as the document when viewed by the signer. A new solution is proposed to solve the problem; the main idea behind the solution is to make the application aware of the sensitive cryptographic function being requested. In order to verify a digital signature computed on a document or any other object (e. g. an executable), access to the public key corresponding to the private key used to sign the document is required. Normally, the public part of the key is made available in a digital 'certificate', which is made up of the public key of the signer, the name of the signer, and other data, all signed using the private signing key of a trusted third party known as a Certification Authority (CA). To verify such a certificate, and thereby obtain a trusted copy of the document signer's public key, a trusted copy of the CA's public key is required. If a malicious party can insert a fake CA public key into the list of CA public keys stored in a PC, then this party could potentially do considerable harm to that PC, since this malicious party could then forge signatures apparently created by other entities. A method of achieving such an attack without attracting the user's attention is presented in this thesis. Countermeasures that can be deployed to prevent the insertion of a fake <b>root</b> <b>public</b> <b>key</b> are discussed. A suggested solution that can be used to detect and remove such fake keys is presented, and a prototype implementation of this solution is described. SSL/TLS supports mutual authentication, i. e. both server and client authentication, using public key certificates. However, this optional feature of SSL/TLS is not widely used because most end users do not have a certified public key. Certain attacks rely on this fact, such as web spoofing and phishing attacks. A method for supporting client-side SSL authentication using trusted computing platforms is proposed. The proposed approach makes a class of phishing attacks ineffective; moreover, the proposed method can also be used to protect against other online attacks...|$|E
40|$|Abstract: As has {{recently}} been demonstrated, a malicious third party could insert a self-issued CA <b>public</b> <b>key</b> into the list of trusted <b>root</b> CA <b>public</b> <b>keys</b> stored on an end user PC. As a consequence, the malicious third party could potentially do severe damage to the end user computing environment. In this paper, we discuss the problem of fake <b>root</b> <b>public</b> <b>keys</b> and suggest a solution {{that can be used}} to detect and remove them. We further describe a prototype implementation of this solution...|$|R
40|$|Abstract. If a {{malicious}} {{party can}} insert a self-issued CA <b>public</b> <b>key</b> into {{the list of}} <b>root</b> <b>public</b> <b>keys</b> stored in a PC, then this party could potentially do considerable harm to that PC. In this paper, we present a way to achieve such an attack for the Internet Explorer web browser root key store, which avoids attracting the user’s attention. A realisation of this attack is also described. Finally, countermeasures that can be deployed to prevent such an attack are outlined. ...|$|R
50|$|A website {{operator}} {{can choose}} to either pin the <b>root</b> certificate <b>public</b> <b>key</b> of a particular root certificate authority, allowing only that certificate authority (and all intermediate authorities signed by its key) to issue valid certificates for the website's domain, and/or to pin the key(s) {{of one or more}} intermediate issuing certificates, or to pin the end-entity <b>public</b> <b>key.</b>|$|R
50|$|Before fully booting into iOS, {{there is}} {{low-level}} code {{that runs from}} the Boot ROM. Its task is to verify that the Low-Level Bootloader is signed by the Apple <b>Root</b> CA <b>public</b> <b>key</b> before running it. This process {{is to ensure that}} no malicious or otherwise unauthorized software can be run on an iOS device. After the Low-Level Bootloader finishes its tasks, it runs the higher level bootloader, known as iBoot. If all goes well, iBoot will then proceed to load the iOS kernel as well {{as the rest of the}} operating system.|$|R
50|$|On Unix-like systems, {{the list}} of {{authorized}} <b>public</b> <b>keys</b> is typically stored in the home directory of the user that is allowed to log in remotely, in the file ~/.ssh/authorized_keys. This file is respected by SSH {{only if it is}} not writable by anything apart from the owner and <b>root.</b> When the <b>public</b> <b>key</b> is present on the remote end and the matching private key is present on the local end, typing in the password is no longer required (some software like Message Passing Interface (MPI) stack may need this password-less access to run properly). However, for additional security the private key itself can be locked with a passphrase.|$|R
5000|$|This is {{an example}} of a self-signed root {{certificate}} representing a certificate authority. Its issuer and subject fields are the same, and its signature can be validated with its own <b>public</b> <b>key.</b> Validation of the trust chain has to end here. If the validating program has this root certificate in its trust store, the end-entity certificate can be considered trusted for use in a TLS connection. Otherwise, the end-entity certificate is considered untrusted. Certificate: Data: Version: 3 (0x2) Serial Number: 04:00:00:00:00:01:15:4b:5a:c3:94 Signature Algorithm: sha1WithRSAEncryption Issuer: C=BE, O=GlobalSign nv-sa, OU=Root CA, CN=GlobalSign Root CA Validity Not Before: Sep 1 12:00:00 1998 GMT Not After : Jan 28 12:00:00 2028 GMT Subject: C=BE, O=GlobalSign nv-sa, OU=Root CA, CN=GlobalSign <b>Root</b> CA Subject <b>Public</b> <b>Key</b> Info: <b>Public</b> <b>Key</b> Algorithm: rsaEncryption Public-Key: (2048 bit) Modulus: 00:da:0e:e6:99:8d:ce:a3:e3:4f:8a:7e:fb:f1:8b: ... Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Key Usage: critical Certificate Sign, CRL Sign X509v3 Basic Constraints: critical CA:TRUE X509v3 Subject Key Identifier: [...] 60:7B:66:1A:45:0D:97:CA:89:50:2F:7D:04:CD:34:A8:FF:FC:FD:4B Signature Algorithm: sha1WithRSAEncryption d6:73:e7:7c:4f:76:d0:8d:bf:ec:ba:a2:be:34:c5:28:32:b5: ...|$|R
40|$|<b>Public</b> <b>Key</b> Validation (PKV) {{consists}} of arithmetic tests that {{help ensure that}} the components of a candidate <b>public</b> <b>key</b> conform to the key generation requirements of a standard. If an invalid <b>public</b> <b>key</b> is used, any intended security may be void. Each user in the <b>Public</b> <b>Key</b> Infrastructure (PKI) is responsible {{to decide whether to}} seek assurance regarding the validity of a candidate <b>public</b> <b>key</b> or to accept the risks of using an possibly invalid <b>public</b> <b>key.</b> A CA may provide this assurance to its clients as part of its <b>public</b> <b>key</b> certification process...|$|R
40|$|<b>Public</b> <b>key</b> {{cryptography}} is {{a relatively}} new branch of cryptography, with the first cryptosystems published in the 1970 s. Despite its youth, much of our modern information infrastructure relies on <b>public</b> <b>key</b> cryptography for efficient security. <b>Public</b> <b>key</b> cryptosystems are built on computationally infeasible mathematical problems. The two most common problems are factoring large composite integers and computing discrete logarithms. It is well known that the problems of factoring a composite integer N, and computing a square root modulo N, are equivalent, with several cryptosystems designed from this hard problem. A lesser known equivalency exists between the discrete logarithm and qth <b>root</b> problems. <b>Public</b> <b>key</b> cryptosystems have been based on the difficulty of the qth root problem, including a key exchange provably secure against the man-in-the-middle attack. If q is prime integer, and G is a finite cyclic group such that q^ 2 divides the order of G, then computing a qth root in G appears to be equivalent to computing a discrete logarithm of an element of order q. No known qth root algorithms for groups G exist which do not require discrete logarithm computation. Earlier work proved that if a 'well-behaved' qth root algorithm existed, then discrete logarithms of elements of order q in these groups could be computed with 2 log_ 2 (q) calls to the qth root algorithm. All known qth root algorithms in G can be reduced to a single algorithm, described in the thesis. It requires a single logarithm computation whenever q^ 2 divides the order of the group. However, one specialized algorithm is known which does not require a discrete logarithm computation: Cipolla's algorithm. This algorithm only works if G is the multiplicative group of a finite field. If Cipolla's algorithm were more efficient than discrete logarithm computation this would show that with current technology the qth root problem is easier than the discrete logarithm problem in finite fields. If it was 'well-behaved' then it would give an efficient discrete logarithm algorithm when combined with earlier work. However in its current form Cipolla's algorithm is computationally more expensive than finding a discrete logarithm using exhaustion and does not have the 'well-behaved' property needed to find discrete logarithms. Cipolla's algorithm was originally designed to compute square roots when large powers of 2 divided the order of the group and has not been analyzed for larger primes. If the algorithm could be modified such that its computational requirements were less than a discrete logarithm or it were given the 'well-behaved' property needed to compute a discrete logarithm, then the balance between the two problems would be upset, a least in the multiplicative groups of finite fields. We will show that Cipolla's algorithm does not upset the balance of the qth root and discrete logarithm problems. If the computational requirements could be minimized with respect to q, then this implies pre-knowledge of the qth root. While Cipolla's algorithm itself gives no further insight into the qth root or discrete logarithm problems, the research indicates new directions for future work on these problems...|$|R
5000|$|<b>Public</b> <b>key</b> {{transport}} key: <b>Public</b> <b>key</b> transport <b>keys</b> are the <b>public</b> <b>keys</b> of {{asymmetric key}} pairs {{that are used}} to encrypt <b>keys</b> using a <b>public</b> <b>key</b> algorithm. These keys are used to establish keys (e.g., key wrapping keys, data encryption keys or MAC keys) and, optionally, other keying material (e.g., Initialization Vectors).|$|R
50|$|One {{disadvantage}} {{of this is}} that the identity information no longer forms the entire <b>public</b> <b>key.</b> Meaning, the user's <b>public</b> <b>key</b> is not discoverable from only the user's identity string and the KGC's <b>public</b> <b>key.</b> Thus, the user's <b>public</b> <b>key</b> must be published or otherwise obtained by other users. One advantage of the system, is {{that it is possible to}} verify that any such obtained <b>public</b> <b>key</b> belongs to the stated identity string. (In other words, the method of distributing the user's <b>public</b> <b>key</b> does not have to be secure.) The identity string and the KGC's <b>public</b> <b>key</b> can be used to verify that the obtained <b>public</b> <b>key</b> belongs to the identity string. (It can be verified that the obtained <b>public</b> <b>key</b> was generated from the identity string, the KGC's private key and some unknown value). Note that multiple <b>public</b> / private <b>key</b> pairs can be generated for any identity string, but attackers would not have access to the KGC's private key in the creation process.|$|R
40|$|Proxy blind signature, which {{combines}} {{the properties of}} both proxy signature and blind signature, is useful in e-cash and e-commerce. In this paper, we present a verifiable self-certified <b>public</b> <b>key</b> scheme and a proxy blind signature scheme using the verifiable self-certified <b>public</b> <b>key.</b> The self-certified <b>public</b> <b>key</b> has an advantage which can withstand <b>public</b> <b>key</b> substitution attacks. As far as we know, {{this is the first}} scheme that satisfies the security properties of both the proxy blind signature and verifiable self-certified <b>public</b> <b>key.</b> Another advantage is that the proposed verifiable self-certified <b>public</b> <b>key</b> scheme overcomes the weakness of repudiability of the self-certified <b>public</b> <b>key.</b> Analysis shows that our scheme are secure and efficient...|$|R
40|$|Abstract: The <b>key</b> {{management}} of <b>public</b> <b>key</b> defines two aspects {{first one is}} the distribution of <b>public</b> <b>key</b> and the second one {{is the use of}} <b>public</b> <b>key</b> to distribute secret keys for encryption. In this paper we are presenting the <b>public</b> <b>key</b> authentication framework. The distribution of <b>public</b> <b>key</b> can be done by many ways but in this paper we are presenting the two schemes known as the <b>public</b> <b>key</b> authority without certification authority (PKAw CA) and <b>public</b> <b>key</b> authority with certification authority (CA) or certification authority. In this paper we have compared both the schemes with respect to security, availability and their support and prepare a comparison chart for them...|$|R
3000|$|... will {{verify the}} message {{integrity}} using ECDSA with <b>public</b> <b>key</b> of the gateways and compares the received <b>public</b> <b>key</b> with its pre-loaded one. Note that verifying {{the authenticity of}} the <b>public</b> <b>key</b> of a gateway is finding out whether the attached <b>public</b> <b>key</b> of the gateway {{is the same as the}} one embedded in the memory of a sensor node. If the received <b>public</b> <b>key</b> does not match the pre-loaded one, sensor node [...]...|$|R
50|$|To encrypt {{a message}} to another user, three pieces of {{information}} are needed: 1) the recipient's <b>public</b> <b>key</b> and 2) identity string, and also 3) the KGC's <b>public</b> information (<b>public</b> <b>key).</b> The identity string and the KGC's <b>public</b> <b>key</b> are used to verify that the recipient's <b>public</b> <b>key</b> belongs to the recipient (was generated from the identity string and the KGC's <b>public</b> <b>key).</b> To decrypt, a user just needs to use their private key.|$|R
30|$|Since {{the system}} {{is based on a}} <b>Public</b> <b>Key</b> Infrastructure, it is {{required}} to perform management functions, such as the validating of the efficiency of <b>public</b> <b>keys</b> and the discarding of <b>public</b> <b>keys.</b> However, an Identity Based Encryption system utilizes identifiable information. Therefore, it does not require validating of the efficiency of <b>public</b> <b>keys.</b>|$|R
40|$|Abstract: Both a self-certified <b>public</b> <b>key</b> and a verifiable self-certified <b>public</b> <b>key</b> {{need not}} be {{accompanied}} with a certificate to be authenticated by other users. To validate these <b>public</b> <b>keys,</b> it is required that <b>key</b> generation center’s <b>public</b> <b>key</b> trusted by users. If all users trust same <b>key</b> generation center, <b>public</b> <b>key</b> can be validated simply. But among users in different domains, trusty relationship between two key generation centers must be accomplished. In this paper we propose the inter-domain usable self-certified <b>public</b> <b>key</b> that can be validated without certificate among users under key generation centers whose trusty relationship is accomplished. Also we present the execution of signature between users under key generation centers use different <b>public</b> <b>key</b> parameters. Key-Words: self-certified, verifiable self-certified, trusty relationship, inter-domain, interoperabilit...|$|R
40|$|Abstract — hosen {{ciphertext}} security (CCA security) hosen ciphertext security (CCA security) C is now {{a widely}} accepted necessary security notion for <b>public</b> <b>key</b> encryption. CCA secure <b>public</b> verifiable <b>public</b> <b>key</b> encryption has many applications such as threshold <b>public</b> <b>key</b> encryption and proxy re-encryption etc. Furthermore, these years “random oracle model ” has seen risen criticize by many cryptographers. Hence, researchers give great effort to pursue <b>public</b> <b>key</b> <b>public</b> <b>key</b> encryption with publicly verifiability in the standard model. However, all the existing CCA secure publicly verifiable <b>public</b> <b>key</b> encryption in the standard model relies on costly bilinear pairing. In this paper, based on Hanaoka and Kurosawa’s efficient CCA secure <b>public</b> <b>key</b> encryption under Computational Diffle-Hellman assumption proposed in Asiacrypt’ 08 and the famous Cramer-Shoup encryption scheme, we try to construct a CCA secure <b>public</b> verifiable <b>public</b> <b>key</b> encryption without pairing in the standard model. As {{a result of its}} application, we achieve a CCA secure public verifiable threshold <b>public</b> <b>key</b> encryption without pairing in the standard model, a CCA secure unidirectional proxy re-encryption without pairing in the standard model...|$|R
30|$|In 1984, Shamir {{suggested}} first {{cipher system}} called IBE (Identity Based Encryption, {{which was a}} solution for the weak point of <b>public</b> <b>key</b> systems: managing <b>public</b> <b>keys</b> effectively (Shamir 1984; Bellovin and Merritt 1993; Boneh et al. 2001; Cramer and Shoup 2002; Boldyreva 2003). In other words, unlike existing <b>public</b> <b>key</b> systems using random bit strings as <b>public</b> <b>keys,</b> the IBE uses the same attribute value as the Identity, which does not require additional memory to save <b>public</b> <b>keys</b> (Zhang et al. 2004).|$|R
40|$|In {{this paper}} we propose an {{efficient}} multivariate <b>public</b> <b>key</b> cryptosystem. <b>Public</b> <b>key</b> of our cryptosystem contains polynomials of total degree three in plaintext and ciphertext variables, two in plaintext variables and one in ciphertext variables. However, {{it is possible to}} reduce the <b>public</b> <b>key</b> size by writing it as two sets of quadratic multivariate polynomials. The complexity of encryption in our <b>public</b> <b>key</b> cryptosystem is O(n 3), where n is bit size, which is equivalent to other multivariate <b>public</b> <b>key</b> cryptosystems. For decryption we need only four exponentiations in the binary field. Our <b>Public</b> <b>key</b> algorithm is bijective and can be used for encryption as well as for signatures...|$|R
40|$|Identity-based <b>public</b> <b>key</b> {{encryption}} facilitates easy {{introduction of}} <b>public</b> <b>key</b> cryptography by allowing an entity's <b>public</b> <b>key</b> to {{be derived from}} an arbitrary identification value, such as name or email address. The main practical benefit of identity-based cryptography is in greatly reducing the need for, and reliance on, <b>public</b> <b>key</b> certificates. Although some interesting identity-based techniques have been developed in the past, none are compatible with popular <b>public</b> <b>key</b> encryption algorithms (such as El Gamal and RSA). This limits the utility of identity-based cryptography as a transitional step to full-blown <b>public</b> <b>key</b> cryptography. Furthermore, it is fundamentally difficult to reconcile finegrained revocation with identity-based cryptography...|$|R
40|$|Since <b>public</b> <b>key</b> {{cryptography}} is {{a fundamental}} technology for electronic commerce, people have often argued that <b>public</b> <b>key</b> infrastructures and corresponding certification services are the gold-mines of the information age. Contrary to these relatively high expectations, <b>public</b> <b>key</b> infrastructures have not really taken off and many certification service providers have even gone out of business. In this paper, we overview and discuss the technical, economical, legal, and social reasons why <b>public</b> <b>key</b> infrastructures have failed so far, summarize the lessons learnt, and give our expectations about the future development of the field. Keywords: <b>Public</b> <b>key</b> certificates, digital certificates, <b>public</b> <b>key</b> infrastructures, certification service provider...|$|R
50|$|This is {{what the}} {{certificate}} authority mechanism is intended to prevent. A certificate authority (CA) is an organization that stores <b>public</b> <b>keys</b> and their owners, and every party in a communication trusts this organization (and knows its <b>public</b> <b>key).</b> When the user's web browser receives the <b>public</b> <b>key</b> from www.bank.example it also receives a digital signature of the key (with some more information, in a so-called X.509 certificate). The browser already possesses the <b>public</b> <b>key</b> of the CA and consequently can verify the signature, trust the certificate and the <b>public</b> <b>key</b> in it: since www.bank.example uses a <b>public</b> <b>key</b> that the certification authority certifies, a fake www.bank.example can only use the same <b>public</b> <b>key.</b> Since the fake www.bank.example does not know the corresponding private key, it cannot create the signature needed to verify its authenticity.|$|R
30|$|MS, PLC known AS’s {{identity}} certificate <b>public</b> <b>key</b> A_AIK_Pub {{and bound}} <b>public</b> <b>key</b> KA_Pub.|$|R
5000|$|A [...] "questionable {{encryption}} scheme", is {{an attack}} tool in cryptovirology. Informally speaking, a questionable encryption scheme is a <b>public</b> <b>key</b> cryptosystem (3-tuple of algorithms) with two supplementary algorithms, forming a 5-tuple of algorithms. It includes a deliberately bogus yet carefully designed key pair generation algorithm that produces a [...] "fake" [...] <b>public</b> <b>key.</b> The corresponding private key (witness of non-encryption) cannot be used to decipher data [...] "encrypted" [...] using the fake <b>public</b> <b>key.</b> By supplying the key pair to an efficient verification predicate (the 5th algorithm in the 5-tuple) it is proven whether the <b>public</b> <b>key</b> is real or fake. When the <b>public</b> <b>key</b> is fake, it follows {{that no one can}} decipher data [...] "enciphered" [...] using the fake <b>public</b> <b>key.</b> A questionable encryption scheme has the property that real <b>public</b> <b>keys</b> are computationally indistinguishable from fake <b>public</b> <b>keys</b> when the private key is not available. The private key forms a poly-sized witness of decipherability or indecipherability, whichever may be the case.|$|R
50|$|<b>Public</b> <b>Key</b> Cryptography is {{a common}} form of a forward {{anonymous}} system. It is used to pass encrypted messages, preventing any information about the message from being discovered if the message is intercepted by an attacker. It uses two <b>keys,</b> a <b>public</b> <b>key</b> and a private <b>key.</b> The <b>public</b> <b>key</b> is published, and is used by anyone to encrypt a plaintext message. The Private key is not well known, and is used to decrypt cyphertext. <b>Public</b> <b>key</b> cryptography is known as an asymmetric decryption algorithm because of different keys being used to perform opposing functions. <b>Public</b> <b>key</b> cryptography is popular because, while it is computationally easy to create a pair of keys, {{it is extremely difficult}} to determine the private key knowing only the <b>public</b> <b>key.</b> Therefore, the <b>public</b> <b>key</b> being well known does not allow messages which are intercepted to be decrypted. This is a forward anonymous system because one compromised <b>key</b> (the <b>public</b> <b>key)</b> does not compromise the anonymity of the system.|$|R
30|$|The {{so-called}} BSU attack {{means that}} anyone can substitute the current <b>public</b> <b>key</b> with the previous one. As noted above, anyone is allowed to update the <b>public</b> <b>key.</b> Therefore, if the client does not locally store {{a copy of the}} public key; it is difficult for him to distinguish the past <b>public</b> <b>key</b> from the latest one. On the other hand, even if the client has stored the latest <b>public</b> <b>key,</b> it is still to be difficult for the client to prove that the locally stored <b>public</b> <b>key</b> is the latest one.|$|R
40|$|ABSTRACT- This paper {{proposes a}} novel <b>public</b> <b>key</b> {{management}} service for mobile ad hoc networks. The scheme is called Trustworthy Key Management for Mobile Ad Hoc Networks (AdHocTKM). AdHocTKM takes {{the advantages of}} threshold cryptography and certificate chaining and integrates it with self-certified <b>public</b> <b>keys</b> and self-certificates to yield a key management service that is secure, trustworthy and highly available to users. The paper also proposes a novel cryptographic key issuing protocol that allows negotiation between a single entity and a distributed authority for an implicit self-certified <b>public</b> <b>key,</b> without the authority gaining knowledge of the corresponding private key. This algorithm is called, threshold self-certified <b>public</b> <b>keying.</b> The authors give {{an overview of the}} most relevant proposals for mobile ad hoc network key management services to date. Indexed Terms – Mobile ad hoc networks, security, <b>public</b> <b>key</b> management, <b>key</b> authentication, <b>public</b> <b>key</b> cryptography, threshold cryptography, PGP, self-certified <b>public</b> <b>key,</b> self-certificate. I...|$|R
40|$|<b>Public</b> <b>key</b> {{cryptography}} {{allows a}} user to digitally sign messages {{with a private}} signature key so that recipients in possession of the corresponding <b>public</b> verification <b>key</b> can check the correctness of the signature. The main problem with this method is to authenticate <b>public</b> <b>keys</b> in order {{to know that the}} digital signature is authentic. A <b>Public</b> <b>Key</b> Infrastructure refers to a network where the authenticity of <b>public</b> <b>keys</b> is certified by Certification Authorities in a hierarchy, and it is believed that this will be an important element in the development of electronic commerce. Certification services are already available from commercial Certification Authorities, and we are starting to see the emergence of national and international <b>public</b> <b>key</b> infrastructures. This paper describes <b>public</b> <b>key</b> infrastructures in general and discusses Norwegian as well as some international implementation efforts...|$|R
40|$|<b>Public</b> <b>Key</b> Validation (PKV) {{consists}} of arithmetic tests that {{help ensure that}} the components of a candidate <b>public</b> <b>key</b> conform to the key generation requirements of a standard. If an invalid <b>public</b> <b>key</b> is used, any intended security may be void. Each user in the <b>Public</b> <b>Key</b> Infrastructure (PKI) is responsible {{to decide whether to}} seek assurance regarding the validity of a candidate <b>public</b> <b>key</b> or to accept the risks of using an possibly invalid <b>public</b> <b>key.</b> A CA may provide this assurance to its clients as part of its <b>public</b> <b>key</b> certification process. The Players Alice and Bob are typical users of the <b>Public</b> <b>Key</b> Infrastructure (PKI). Eve is an adversary trying to gain an unfair advantage, commit fraud, etc. Dim is a typical user of the PKI also, but is perhaps too trusting. The Certificate Authority (CA) is a trusted third party that issues a certificate that binds the identity of individuals with their public key; in doing this, the CA has issued a Certificate Practice Statement (CPS) t [...] ...|$|R
50|$|Key servers play an {{important}} role in <b>public</b> <b>key</b> cryptography.In <b>public</b> <b>key</b> cryptography an individual is able to generate a key pair, where one of the keys is kept privatewhile the other is distributed publicly. Knowledge of the <b>public</b> <b>key</b> does not compromise the security of <b>public</b> <b>key</b> cryptography. Anindividual holding the <b>public</b> <b>key</b> of a key pair can use that key to carry out cryptographic operations that allow secret communications with or strong authentication of the holder of the matching private key. Theneed to have the <b>public</b> <b>key</b> of a key pair in order to startcommunication or verify signatures is a bootstrapping problem. Locating keyson the web or writing to the individual asking them to transmit their publickeys can be time consuming and insecure. Key servers act as central repositories toalleviate the need to individually transmit <b>public</b> <b>keys</b> and can act as the root of a chain of trust.|$|R
50|$|EPKE {{consists}} of a two-stage process that includes both <b>Public</b> <b>Key</b> Encryption (PKE) and a digital signature. Both <b>Public</b> <b>Key</b> Encryption and digital signatures make up the foundation of Enveloped <b>Public</b> <b>Key</b> Encryption (these two processes are described in full in their own sections).|$|R
5000|$|The <b>public</b> <b>key</b> [...] is {{the root}} of the tree, [...] The {{individual}} <b>public</b> <b>keys</b> [...] can be made public without breaking security. However, as they are not needed in the <b>public</b> <b>key,</b> it is more practical to keep them secret to minimize its size.|$|R
50|$|Typically Robot CAs {{are set up}} to {{validate}} that the <b>public</b> <b>key</b> belonging to an e-mail address does actually belong to the e-mail address. This is achieved by the Robot CA signing each uid on the <b>public</b> <b>key</b> and sending the signed copy to the e-mail address, encrypted with the <b>public</b> <b>key.</b> If the <b>public</b> <b>key</b> belongs to whoever reads the e-mail address, they receive the signed copy, can decrypt it and then publish it to the <b>public</b> <b>key</b> servers. If the <b>public</b> <b>key</b> {{does not belong to}} whoever reads the e-mail address, they are unable to decrypt the encrypted key, but the accompanying message gives them sufficient information {{to let them know that}} someone is attempting to impersonate them.|$|R
40|$|Abstract- We {{consider}} {{a system where}} each user has a <b>public</b> <b>key</b> and a private key. In this system, a certificate is a data item that is issued by one user u and contains the <b>public</b> <b>key</b> of another user v. A third user w that knows the <b>public</b> <b>key</b> of u can verify that this certificate has not been corrupted (by an adversary) since it was issued by u, and so can accept the <b>public</b> <b>key</b> ini the certificate as the correct <b>public</b> <b>key</b> of v. User w can use this accepted <b>public</b> <b>key</b> of v in two ways. First, w can securely communicate with v. Second, w can obtain more <b>public</b> <b>keys</b> of other users, as it used the <b>public</b> <b>key</b> of u to obtain the <b>public</b> <b>key</b> of v. However, {{the safety of the}} second use is questionable if u, the issuer of the certificate, has concluded that it cannot trust v enough to accept a <b>public</b> <b>key</b> merely because v accepts it. To solve this problem, we propose that each certificate should have a "rating". The rating of a certificate describes how much trust the issuer puts on the subject concerning key acceptance. We present an algorithm for computing a subgraph G. dst(src) of a certificate graph G, for a user src to find the correct <b>public</b> <b>key</b> of another user dst in G. The time complexity of this algorithm is 0 (e), where e is the number of certificates in the system. This algorithm meets the lower bound of the worst case complexity. I...|$|R
30|$|In EABA, we {{adopt the}} <b>public</b> <b>key</b> {{cryptography}} for message authentication. Note {{that different from}} classical <b>public</b> <b>key</b> cryptosystems, all legitimate vehicles in M share the same <b>public</b> <b>key,</b> while each vehicle has a unique private key, and the private key is known only to the vehicle itself. This public-key-private-key distribution is made possible thanks {{to the presence of}} the TA. In our scheme, the TA is in charge of initializing authentication settings (i.e., choosing the prime number for <b>public</b> <b>key),</b> and keys are generated and assigned to vehicles when they register at the TA. As a result, we can easily let all vehicles have the same <b>public</b> <b>key.</b>|$|R
