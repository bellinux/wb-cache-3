261|1285|Public
25|$|<b>Race</b> <b>condition,</b> {{where the}} {{computer}} does not perform tasks {{in the order}} the programmer intended.|$|E
25|$|While {{involved}} with the L0pht, Mudge contributed significantly to disclosure and education on information and security vulnerabilities. In addition to pioneering buffer overflow work, the security advisories he released contained early examples of flaws in the following areas: code injection, <b>race</b> <b>condition,</b> side-channel attack, exploitation of embedded systems, and cryptanalysis of commercial systems. He was the original author of the password cracking software L0phtCrack.|$|E
25|$|Another {{category}} of bug {{is called a}} <b>race</b> <b>condition</b> that may occur when programs have multiple components executing at the same time. If the components interact in a different order than the developer intended, they could interfere {{with each other and}} stop the program from completing its tasks. These bugs may be difficult to detect or anticipate, since they may not occur during every execution of a program.|$|E
40|$|We {{address the}} problem of testing and {{debugging}} concurrent, distributed Erlang applications. In concurrent programs, <b>race</b> <b>conditions</b> are a common class of bugs and are very hard to find in practice. Traditional unit testing is normally unable to help finding all <b>race</b> <b>conditions,</b> because their occurrence depends so much on timing. Therefore, <b>race</b> <b>conditions</b> are often found during system testing, where due to the vast amount of code under test, it is often hard to diagnose the error resulting from <b>race</b> <b>conditions.</b> We present three tools (Quick Check, PULSE, and a visualizer) that in combination can be used to test and debug concurrent programs in unit testing with a much better possibility of detecting <b>race</b> <b>conditions.</b> We evaluate our method on an industrial concurrent case study and illustrate how we find and analyze the <b>race</b> <b>conditions...</b>|$|R
50|$|File locking is {{a common}} {{technique}} for preventing <b>race</b> <b>conditions</b> for a single file, {{but it does not}} extend to the file system namespace and other metadata, and cannot prevent TOCTTOU <b>race</b> <b>conditions.</b>|$|R
50|$|<b>Race</b> <b>conditions</b> {{arise in}} {{software}} when an application {{depends on the}} sequence or timing of processes or threads for it to operate properly. As with electronics, there are critical <b>race</b> <b>conditions</b> that result in invalid execution and bugs. Critical <b>race</b> <b>conditions</b> often happen when the processes or threads depend on some shared state. Operations upon shared states are critical sections that must be mutually exclusive. Failure to obey this rule opens up the possibility of corrupting the shared state.|$|R
25|$|In {{the example}} above, a {{potential}} <b>race</b> <b>condition</b> exists when C is 1 and D is 0, A is 1, and B changes from 1 to 0 (moving {{from the blue}} state to the green state). For this case, the output is defined to remain unchanged at 1, but because this transition is not covered by a specific term in the equation, a potential for a glitch (a momentary transition of the output to 0) exists.|$|E
25|$|Karnaugh {{maps are}} useful for {{detecting}} and eliminating race conditions. Race hazards are very easy to spot using a Karnaugh map, because a <b>race</b> <b>condition</b> may exist when moving between any pair of adjacent, but disjoint, regions circumscribed on the map. However, {{because of the nature}} of Gray coding, adjacent has a special definition explained above - we're in fact moving on a torus, rather than a rectangle, wrapping around the top, bottom, and the sides.|$|E
500|$|If {{instruction}} 1B is executed between 1A and 3A, or if instruction 1A is executed between 1B and 3B, {{the program}} will produce incorrect data. This {{is known as a}} <b>race</b> <b>condition.</b> The programmer must use a lock to provide mutual exclusion. A lock is a programming language construct that allows one thread to take control of a variable and prevent other threads from reading or writing it, until that variable is unlocked. The thread holding the lock is free to execute its critical section (the section of a program that requires exclusive access to some variable), and to unlock the data when it is finished. Therefore, to guarantee correct program execution, the above program can be rewritten to use locks: ...|$|E
40|$|Since {{detecting}} <b>race</b> <b>conditions</b> in a multithreaded or multiprocess {{program is}} an NP-complete problem, {{there is no}} efficient algorithm that can help detect <b>race</b> <b>conditions</b> in a program. As such, there are no easyto -use pedagogical tools. Most operating systems and concurrent programming textbooks only provide a formal definition and some trivial examples. This is insufficient for students {{to learn how to}} detect <b>race</b> <b>conditions.</b> This paper attempts to fill this gap by presenting a set of wellorganized examples, each of which contains one or more <b>race</b> <b>conditions,</b> for instructors to use in the classroom. This set of materials has been classroom tested for two years and the student's reaction has been very positive. 1...|$|R
50|$|In {{the context}} of file system TOCTTOU <b>race</b> <b>conditions,</b> the {{fundamental}} challenge is ensuring that the file system cannot be changed between two system calls. In 2004, an impossibility result was published, showing {{that there was no}} portable, deterministic technique for avoiding TOCTTOU <b>race</b> <b>conditions.</b>|$|R
5000|$|ParaSailâ€”object-oriented, parallel, free of pointers, <b>race</b> <b>conditions</b> ...|$|R
2500|$|L0pht Watch: A {{tool for}} {{filesystem}} <b>race</b> <b>condition</b> attacks, Jan 1999 ...|$|E
2500|$|<b>Race</b> <b>Condition</b> in Rational Systems ClearCase source control system, Jan 1998 ...|$|E
2500|$|Some bugs are {{revealed}} by inputs {{that may be}} difficult for the programmer to re-create. [...] One cause of the Therac-25 radiation machine deaths was a bug (specifically, a <b>race</b> <b>condition)</b> that occurred only when the machine operator very rapidly entered a treatment plan; it took days of practice to become able to do this, so the bug did not manifest in testing or when the manufacturer attempted to duplicate it. [...] Other bugs may disappear when the program is run with a debugger; these heisenbugs (humorously named after the Heisenberg uncertainty principle).|$|E
5000|$|Helgrind and DRD, detect <b>race</b> <b>conditions</b> in {{multithreaded code}} ...|$|R
5000|$|... #Subtitle level 3: Threading problems, {{vulnerability}} to <b>race</b> <b>conditions</b> ...|$|R
40|$|Introduction Concurrent {{programs}} contain both sequential and concurrent errors. While deadlock and <b>race</b> <b>conditions</b> {{are unique}} to concurrent programs, there also exist algorithmic design errors, such as inhibiting concurrency, which are unknown in the sequential domain. Recently, {{there has been a}} large effort in debugging <b>race</b> <b>conditions</b> [16], both statically [8] and dynamically [7], and to a lesser extent, deadlock [13]. Our experience shows that concurrent errors occur with diminishing frequency in the order: traditional sequential errors, algorithmic design errors, deadlock, <b>race</b> <b>conditions.</b> However, the difficulty in determining and fixing these errors grows exponentially from sequential errors to <b>race</b> <b>conditions.</b> Our experience also shows that the frequency of deadlock and race-conditions diminishes significantly when high-level concurrency constructs (e. g., task, monitor, actor, etc.) are used, versus thread and lock programming. We believe the best way to improve concur...|$|R
5000|$|The <b>race</b> <b>condition</b> {{is removed}} by adding in logic redundancy, which is {{contrary}} to the aims of using a k-map in the first place.Both minterm race conditions are covered by addition of the yellow term [...](The maxterm <b>race</b> <b>condition</b> is covered by addition of the green-bordered grey term [...]) ...|$|E
5000|$|... #Subtitle level 3: Timing, {{latching}} {{and avoiding}} a <b>race</b> <b>condition</b> ...|$|E
5000|$|L0pht Watch: A {{tool for}} {{filesystem}} <b>race</b> <b>condition</b> attacks, Jan 1999 ...|$|E
50|$|Rounds {{marked with}} light blue {{background}} were under wet <b>race</b> <b>conditions.</b>|$|R
5000|$|Accuracy: Identify memory {{corruption}} and <b>race</b> <b>conditions</b> to eliminate erroneous results ...|$|R
5000|$|Risk of {{introducing}} difficult to debug synchronization bugs and <b>race</b> <b>conditions.</b>|$|R
5000|$|<b>Race</b> <b>Condition</b> in Rational Systems ClearCase source control system, Jan 1998 ...|$|E
50|$|When in <b>race</b> <b>condition,</b> Dodds weighed 148 lb {{and stood}} 5 ft tall.|$|E
5000|$|CVE-2004-0794, Signal <b>race</b> <b>condition</b> in FTP server, {{affecting}} NetBSD and Mac OS X.|$|E
5000|$|Rounds {{marked with}} light blue {{background}} were under wet <b>race</b> <b>conditions.</b>|$|R
5000|$|... #Subtitle level 3: <b>Race</b> <b>conditions,</b> mutual exclusion, synchronization, and {{parallel}} slowdown ...|$|R
50|$|In 2012 the <b>race</b> <b>conditions</b> {{changed from}} {{handicap}} to Weight for Age.|$|R
50|$|A static <b>race</b> <b>condition</b> {{occurs when}} a signal and its {{complement}} are combined together.|$|E
5000|$|... ===Official lap record=== The fastest laps at each {{different}} circuit configuration. (Set under <b>race</b> <b>condition).</b>|$|E
5000|$|<b>Race</b> <b>condition,</b> {{where the}} {{computer}} does not perform tasks {{in the order}} the programmer intended.|$|E
5000|$|... #Caption: 1932 racebook showing <b>race</b> <b>conditions</b> & winner - Holdfast (3rd time) ...|$|R
40|$|We {{address the}} problem of {{detecting}} <b>race</b> <b>conditions</b> in programs that use semaphores for synchronization. Netzer and Miller showed that it is NP-complete to detect <b>race</b> <b>conditions</b> in programs that use many semaphores. We show in this paper that it remains NP-complete even if only two semaphores are used in the parallel programs. For the tractable case, [...] ...|$|R
40|$|This paper investigates an {{approach}} for statically preventing <b>race</b> <b>conditions</b> in an object-oriented language. The setting {{of this work}} is a variant of Gordon and Hankin's concurrent object calculus. We enrich that calculus with a form of dependent object types that enables us to verify that threads invoke and update methods only after acquiring appropriate locks. We establish that well-typed programs do not have <b>race</b> <b>conditions.</b> 1 Introduction Concurrent object-oriented programs su#er {{from many of the}} errors common in concurrent programs of other sorts. In particular, the use of objects does not diminish the importance of careful synchronization. With objects or without them, improper synchronization may lead to <b>race</b> <b>conditions</b> (that is, two processes accessing a shared resource simultaneously) and ultimately to incorrect behavior. A standard approach for eliminating <b>race</b> <b>conditions</b> consists in protecting each shared resource with a lock, requiring that a process acquires the corres [...] ...|$|R
