1422|2970|Public
5000|$|EIRENE Functional <b>Requirements</b> <b>Specification</b> EIRENE System <b>Requirements</b> <b>Specification</b> ...|$|E
50|$|<b>Requirements</b> <b>specification</b> - Requirements are {{documented}} {{in a formal}} artifact called <b>Requirements</b> <b>Specification</b> (RS). Nevertheless, it will become official only after validation. A RS can contain both written and graphical (models) information if necessary. Example: Software <b>requirements</b> <b>specification</b> (SRS).|$|E
50|$|A System <b>Requirements</b> <b>Specification</b> (abbreviated SyRS when {{need to be}} {{distinct}} from a Software <b>Requirements</b> <b>Specification</b> SRS) is a structured collection of information that embodies the requirements of a system.|$|E
40|$|Abstract. Assuring {{the quality}} of {{software}} <b>requirement</b> <b>specifications</b> is critical. Poor <b>requirement</b> <b>specifications</b> may make costly errors during the development process. Therefore methods and techniques for verification and validation of software <b>requirement</b> <b>specifications</b> are fundamentally important. This survey presents taxonomy of verification and validation of <b>requirements</b> and <b>specifications</b> that represents the “flow ” from <b>requirements</b> to <b>specifications...</b>|$|R
50|$|System {{testing is}} {{performed}} on the entire system {{in the context of}} a Functional <b>Requirement</b> <b>Specification(s)</b> (FRS) and/or a System <b>Requirement</b> <b>Specification</b> (SRS). System testing tests not only the design, but also the behaviour and even the believed expectations of the customer. It is also intended to test up to and beyond the bounds defined in the software/hardware <b>requirements</b> <b>specification(s).</b>|$|R
40|$|Abstract: The {{challenges}} of object-oriented design are {{to identify the}} objects and classes needed to implement the software, and to define the behaviors and the attributes of the objects from <b>requirement</b> <b>specification.</b> These are very complicated challenges because of there dependence on heuristic. Formal <b>requirement</b> <b>specification</b> have the additional advantage over informal <b>requirement</b> <b>specification</b> because they are amenable to machine analysis and manipulation. The greatest benefit of applying a formal <b>requirement</b> <b>specification</b> is that system designers gain {{a deeper understanding of}} the specified system, because they have forced to be more abstract and precise about desired properties. Another important application of formal specification is that they can be used as a base to reason about the behavior of the desired system. Formal <b>requirement</b> <b>specification</b> will be first important step for solving the difficulties and ill-defined tasks in the object model creation process, including identification of objects, attributes, behaviors and organization of objects with inheritance. In this paper, we propose methodological support for object identification from formal <b>requirement</b> <b>specification...</b>|$|R
50|$|A {{functional}} specification (also, functional spec, specs, {{functional specification}}s document (FSD), functional <b>requirements</b> <b>specification)</b> in systems engineering and software {{development is a}} document that specifies the functions that a system or component must perform (often part of a <b>requirements</b> <b>specification)</b> (ISO/IEC/IEEE 24765-2010).|$|E
5000|$|... #Article: Comprehensive & Robust <b>Requirements</b> <b>Specification</b> Process ...|$|E
5000|$|Functional {{system failure}} {{analysis}} and derived <b>requirements</b> <b>specification</b> ...|$|E
40|$|The QUIS <b>requirement</b> <b>specification</b> of a next {{generation}} e-learning system {{was one of}} the main outcomes of the European project QUIS (2005 - 06). The article summarizes the <b>requirement</b> <b>specification</b> and provides examples of functional requirements and use cases. The article also describes the experiences and the conclusions from the work of the <b>requirement</b> <b>specification,</b> with the aim of providing advice to system developers, content providers and researchers within the field of e-learning...|$|R
40|$|<b>Requirement</b> <b>Specifications</b> {{are very}} {{difficult}} to define. Due to lack of information and differences in interpretation, software engineers are faced with the necessity to redesign and iterate. This imperfection in software <b>requirement</b> <b>specifications</b> is commonly addressed by incremental design. In this paper, we advocate an approach where the imperfect <b>requirements</b> in <b>requirement</b> <b>specifications</b> are modeled by fuzzy sets. By supporting this approach with a requirement tracing and an optimization approach, the necessity for design iteration can be reduced...|$|R
30|$|<b>Requirement</b> <b>Specification</b> don’t know “when {{user can}} send e-mail”,“where user can send e-mail”, “how user can send e-mail”. But the <b>requirement</b> <b>specification</b> editor which we {{developed}} not only divide a complicated requirement sentence into individual requirements, but also can know “when user can send e-mail”,“where user can send e-mail”, “how user can send e-mail”. This means that student can send e-mail “any time” and “anywhere”. And that is, Student can send e-mail not only inside campus, and also outside campus. The <b>requirement</b> <b>specification</b> editor which we developed can express detail of Requirement. And This XML have tag of <must>[*]</must>. This tag means {{the degree of}} requirement. <must>[*]</must> means the requirement which must be attained. <b>Requirement</b> <b>specification</b> can not express degree of requirement. Software test check satisfaction of customer requirement. Generally, customer have many kind of requirement. for example, requirement which customer must satisfy, and so on. The <b>requirement</b> <b>specification</b> editor which we developed can express degree of requirement.|$|R
5000|$|Requirements {{analysis}} {{resulting in}} a software <b>requirements</b> <b>specification</b> ...|$|E
5000|$|Use (load) studies, {{component}} stress analysis, and derived <b>requirements</b> <b>specification</b> ...|$|E
5000|$|This is {{followed}} by a safety <b>requirements</b> <b>specification</b> which is concerned with identifying safety-critical functions (functional <b>requirements</b> <b>specification)</b> and the safety integrity level for each of these functions. [...] The specification may either describe how the software should behave to minimize the risk or might require that the hazard should never arise.|$|E
40|$|Abstract. <b>Requirement</b> <b>Specification</b> {{is gaining}} {{increasingly}} attention {{as a critical}} phase of software systems development. As requirement descriptions evolve, they quickly become error-prone and difficult to understand. Thus, the development of techniques and tools to support <b>requirement</b> <b>specification</b> development, understanding, testing, maintenance and reuse becomes an important issue. This paper extends the well-known technique of program slicing to Functional <b>Requirement</b> <b>Specification</b> based on Use Case Maps notation. This new application of slicing, called UCM Requirement Slicing is useful to aid requirement comprehension and maintenance. In contrast to traditional program slicing, requirement slicing is designed to operate on the <b>requirement</b> <b>specification</b> of a system, rather than the source code of a program. The resulting requirement slice provides knowledge about high-level structure of a system, rather than its low-level implementation details. In order to compute a UCM Requirement slice, we provide a three steps slicing algorithm. Key words: Functional <b>requirement</b> <b>specification,</b> program slicing, use case maps, comprehension, maintenance. ...|$|R
40|$|Abstract. <b>Requirement</b> <b>Specifications</b> {{are very}} {{difficult}} to define concisely and unambiguously. Due to lack of information and differences in interpretation, software engineers are frequently faced with the necessity to redesign and iterate. The imperfection in software <b>requirement</b> <b>specifications</b> that causes these problems has lead to for example iterative approaches and incremental design. In this paper, we advocate an approach where the imperfect <b>requirements</b> in <b>requirement</b> <b>specifications</b> are modeled by fuzzy sets. By supporting this approach with a requirement tracing and optimization approach, the necessit...|$|R
40|$|Abstract. Developing new {{software}} based on <b>requirements</b> <b>specifications</b> created by business analysts {{often leads to}} misunderstanding and lack of comprehension, because of the different background of the involved persons. If the <b>requirements</b> <b>specifications</b> instead have a clearly defined structure and comprehensive semantics, this obstacle can be resolved. Therefore, we propose to structure the <b>requirements</b> <b>specifications</b> using existing linguistic modeling methods and annotate the used terms with ontologies {{in order to enhance}} the understanding and reuse of these documents during the whole software engineering process. 1...|$|R
5000|$|Interface <b>Requirements</b> <b>Specification</b> (IRS) - The {{requirements}} {{for one or}} more interfaces ...|$|E
5000|$|User <b>Requirements</b> <b>Specification</b> validation: User {{requirements}} {{as stated}} in a document called User <b>Requirements</b> <b>Specification</b> are validated by checking if they indeed represent the will and goals of the stakeholders. This {{can be done by}} interviewing them and asking them directly (static testing) or even by releasing prototypes and having the users and stakeholders to assess them (dynamic testing).|$|E
50|$|The {{customer}} (<b>requirements)</b> <b>specification</b> is {{answered by}} the contractor by a design-to specification.|$|E
40|$|For {{documenting the}} groundwork pitch of requirements, {{many types of}} <b>requirement</b> <b>specification</b> {{template}} are available containing some specific requirement parameter which eventually recites the root requirement for constructing the design, {{but they are not}} good enough to make the template reliable <b>requirement</b> <b>specification.</b> In this paper a reliable <b>requirement</b> <b>specification</b> template has been proposed having some reliable parameter which will assess the reliability of the individual requirement before finalizing the requirement documentation which reflects the reliability of requirements at early stage of software development...|$|R
40|$|Validation of <b>requirements</b> <b>specifications</b> is undoubtly an {{integral}} and indispensable part of requirements engineering. Validation {{is the process}} of checking whether <b>requirements</b> <b>specifications</b> meet the intentions and expectations of the stakeholders. One approach to support the process of validation is based on simulation/execution and animation of system (behaviour) models that are derived from initial <b>requirements</b> <b>specifications.</b> However, the benefit of executable models is determined by the capabilities of the corresponding simulation tools. This paper presents a survey on simulation and animation capabilities of ten modern software/system engineering tools...|$|R
40|$|<b>Requirement</b> <b>specifications</b> {{written in}} natural {{language}} might cause miscommunication among developers {{depending on how}} they are understood. Without removing any ambiguities, we cannot construct systems satisfying the need for software safety. Removing ambiguities should be performed in early steps during the development. In this paper, Requirement Analysis Support Tool (RAST) will be introduced. RAST system analyzes <b>requirement</b> <b>specifications</b> based on linguistic information. By using RAST system, we can expect that requirement engineers can {{communicate with each other}} in common notations, and use logical expressions rather than using <b>requirement</b> <b>specifications</b> written in natural language...|$|R
50|$|Compliance and {{mutually}} consistent requirements will be integrated and formatted into a <b>requirements</b> <b>specification</b> document.|$|E
5000|$|Inherent (system) Design Reliability Analysis and derived <b>requirements</b> <b>specification</b> {{for both}} Hardware and Software design ...|$|E
5000|$|The {{product of}} {{this stage is}} a {{complete}} <b>requirements</b> <b>specification</b> document which is made up of: ...|$|E
5000|$|In many <b>requirement</b> <b>specifications,</b> {{particularly}} involving software, {{the words}} shall {{and will have}} special meanings. Most <b>requirement</b> <b>specifications</b> use the word shall to denote something that is required, while reserving the will for simple statement about the future (especially since [...] "going to" [...] is typically seen as too informal for legal contexts). However, some documents deviate from this convention and use the words shall, will, and should to denote {{the strength of the}} <b>requirement.</b> Some <b>requirement</b> <b>specifications</b> will define the terms {{at the beginning of the}} document.|$|R
40|$|The Unified Modeling Language (UML) {{is widely}} used by {{software}} engineers {{as the basis of}} analysis and design in software development. However, UML ignores human factors in the course of software development because of its strong emphasis on the internal structure and functionality of the application. This thesis presents a method of mapping human-computer interaction (HCI) <b>requirement</b> <b>specifications</b> generated by usability engineering (UE) methodologies (e. g. Putting Usability First (PUF)) into UML specifications. These two sets of <b>requirement</b> <b>specification</b> are specified, using Extensible Markup Language (XML) so that HCI <b>requirement</b> <b>specifications</b> can be integrated into UML ones. A Mapping Tool was developed to facilitate the creation of mappings between PUF XML tags and XMI tags. The Mapping Tool was used to create mappings between PUF and UML <b>requirement</b> <b>specifications.</b> This mapping process and its outputs were evaluated to demonstrate that the tool worked. The results of the evaluation show that the HCI <b>requirement</b> <b>specification</b> represented by the PUF XML tags can improve the UML specification by adding them into the XMI tags...|$|R
5000|$|Developing <b>requirements</b> <b>specifications</b> for {{web sites}} and web {{applications}} ...|$|R
5000|$|Operator <b>Requirements</b> <b>Specification</b> (Defining {{services}} {{requirements and}} infrastructure deployment issues. Protecting digital content is also addressed.) ...|$|E
5000|$|... 2011: {{publication}} of a System <b>Requirements</b> <b>Specification</b> document defining machine consciousness in terms of specification objectives.|$|E
50|$|Developing {{the product}} <b>requirements</b> <b>specification</b> for the {{individual}} product and reuse the requirements from the preceding phase.|$|E
40|$|All rights reserved. This Business <b>Requirement</b> <b>Specification</b> is confidential. It is copyrighted © and {{the sole}} {{property}} of Mecklenburg County. It {{may not be}} reproduced in any form or by any means, without the written permission of Mecklenburg County. This Business <b>Requirement</b> <b>Specification</b> (BRS) was produced using the PowerPlus Americ...|$|R
40|$|Rupp and Götz {{observe that}} some, but not all, <b>requirement</b> <b>specification</b> {{sentences}} involving universal quantification, are dangerous {{because they are}} usually not true. Jackson and Zave provide a classification of <b>requirement</b> <b>specification</b> sentences into indicative and optative sentences. It is observed that the dangerous sentences involving universal quantifiers are all indicative...|$|R
40|$|Abstract—System {{testing is}} {{actually}} {{done to the}} entire system against the Functional <b>Requirement</b> <b>Specification</b> and/or the System <b>Requirement</b> <b>Specification.</b> Moreover, it is an investigatory testing phase, where the focus is to have almost a destructive attitude and test not only the design, but also the behavior and even the believed expectations of the customer. It is also intended to test up to and beyond the bounds defined in the software/hardware <b>requirements</b> <b>specifications.</b> In Motorola ®, Automated Testing {{is one of the}} testing methodologies uses by GSG-iSGT (Global Software Group- iDEN TM Subcriber Group-Test) to increase the testing volume, productivity I...|$|R
