18|10000|Public
25|$|From {{the point}} of view of the author of a routine, <b>raising</b> <b>an</b> <b>exception</b> is a useful way to signal that a routine could not execute {{normally}} - for example, when an input argument is invalid (e.g. value is outside of the domain of a function) or when a resource it relies on is unavailable (like a missing file, a hard disk error, or out-of-memory errors). In systems without exceptions, routines would need to return some special error code. However, this is sometimes complicated by the semipredicate problem, in which users of the routine need to write extra code to distinguish normal return values from erroneous ones.|$|E
2500|$|... {{undefined}} - a standards reports procedure <b>raising</b> <b>an</b> <b>exception</b> in the runtime system.|$|E
5000|$|... {{after the}} base {{semantics}} for the join point. When the join point {{corresponds to the}} execution of a method, an after advice can be executed after the method returned or after <b>raising</b> <b>an</b> <b>exception</b> ...|$|E
5000|$|... def func(filename): f = open(filename) g(f) # Do {{something}} with f that may <b>raise</b> <b>an</b> <b>exception.</b> f.close (...) If the intervening code <b>raises</b> <b>an</b> <b>exception,</b> the function exits early and the file is never closed, so the resource is leaked.|$|R
50|$|Dereferences of null {{pointers}} lead to undefined {{values and}} usually <b>raise</b> <b>an</b> <b>exception</b> immediately.|$|R
50|$|The {{occurrence}} of an underflow may set a ('sticky') status bit, <b>raise</b> <b>an</b> <b>exception,</b> at the hardwarelevel generate an interrupt, or may cause {{some combination of}} these effects.|$|R
5000|$|A {{fundamental}} {{problem is that}} having a resource {{is no longer a}} class invariant (the resource is held from object creation until it is disposed, but the object is still live at this point), so the resource may not be available when the object tries to use it, for example trying to read from a closed file. This means that all methods on the object that use the resource potentially fail, concretely usually by returning an error or <b>raising</b> <b>an</b> <b>exception.</b> In practice this is minor, as use of resources can usually fail for other reasons as well (for example, trying to read past the end of a file), so these methods already might fail, and not having a resource just adds another possible failure. A standard way to implement this is to add a boolean field to the object, called , which is set to true by , and checked by a guard clause to all methods (that use the resource), <b>raising</b> <b>an</b> <b>exception</b> (such as [...] in [...]NET) if the object has been disposed.|$|E
50|$|If {{creation}} or destruction fail, error reporting (often by <b>raising</b> <b>an</b> <b>exception)</b> can be complicated: {{the object}} or related objects {{may be in}} an inconsistent state, {{and in the case}} of destruction - which generally happens implicitly, and thus in an unspecified environment - it may be difficult to handle errors. The opposite issue - incoming exceptions, not outgoing exceptions - is whether creation or destruction should behave differently if they occur during exception handling, when different behavior may be desired.|$|E
50|$|Some {{languages}} (like Pascal and Modula) perform {{bounds checking}} on every access, <b>raising</b> <b>an</b> <b>exception</b> or aborting the program when any index {{is out of}} its valid range. Compilers may allow these checks to be turned off to trade safety for speed. Other languages (like FORTRAN and C) trust the programmer and perform no checks. Good compilers may also analyze the program to determine the range of possible values that the index may have, and this analysis may lead to bounds-checking elimination.|$|E
5000|$|The error {{handling}} of the functions in the C standard library is not consistent and sometimes confusing. According to the Linux manual page , [...] "The current (version 2.8) situation under glibc is messy. Most (but not all) functions raise exceptions on errors. Some also set errno. A few functions set errno, but don't <b>raise</b> <b>an</b> <b>exception.</b> <b>A</b> very few functions do neither." ...|$|R
5000|$|Lookup: {{find the}} value (if any) that {{is bound to}} a given key. The {{argument}} to this operation is the key, and the value is returned from the operation. If no value is found, some associative array implementations <b>raise</b> <b>an</b> <b>exception.</b>|$|R
40|$|We {{present an}} {{extension}} of System F with call-by-name exceptions. The type system is enriched with two syntactic constructs: a union type for programs whose execution may <b>raise</b> <b>an</b> <b>exception</b> at top level, and a corruption type for programs that may <b>raise</b> <b>an</b> <b>exception</b> in any evaluation context (not necessarily at top level). We present the syntax and reduction rules of the system, {{as well as its}} typing and subtyping rules. We then study its properties, such as confluence. Finally, we construct a realizability model using orthogonality techniques, from which we deduce that well-typed programs are weakly normalizing and that the ones who have the type of natural numbers really compute a natural number, without raising exceptions. Comment: 25 page...|$|R
5000|$|... skip, [...] "~" [...] or [...] "?"C - an {{undefined}} value always syntactically valid, empty - {{the only}} value admissible to void, needed for selecting void in a union, void - syntactically like a mode, but not one, nil or [...] "○" [...] - a name not denoting anything, of an unspecified reference mode, (...) or specifically 1:0int - a vacuum is an empty array (here specifically of mode int). undefined - a standards reports procedure <b>raising</b> <b>an</b> <b>exception</b> in the runtime system. ℵ - Used in the standards report to inhibit introspection of certain types. e.g. sema ...|$|E
50|$|From {{the point}} of view of the author of a routine, <b>raising</b> <b>an</b> <b>exception</b> is a useful way to signal that a routine could not execute {{normally}} - for example, when an input argument is invalid (e.g. value is outside of the domain of a function) or when a resource it relies on is unavailable (like a missing file, a hard disk error, or out-of-memory errors). In systems without exceptions, routines would need to return some special error code. However, this is sometimes complicated by the semipredicate problem, in which users of the routine need to write extra code to distinguish normal return values from erroneous ones.|$|E
5000|$|Further, it is {{possible}} to call [...] on an object more than once. While this may indicate a programming error (each object holding a resource must be disposed exactly once), it is simpler, more robust, and thus usually preferable for [...] to be idempotent (meaning [...] "calling multiple times is the same as calling once"). This is easily implemented by using the same boolean [...] field and checking it in a guard clause at the start of , in that case returning immediately, rather than <b>raising</b> <b>an</b> <b>exception.</b> Java distinguishes disposable types (those that implement AutoCloseable) from disposable types where dispose is idempotent (the subtype Closeable).|$|E
5000|$|For systems {{implementing}} signed zero, infinities, or Not a Number (for example, IEEE floating point), it {{is common}} to implement reasonable extensions which may extend the range of values produced to include − and −0. These also may return NaN or <b>raise</b> <b>an</b> <b>exception</b> when given <b>a</b> NaN argument.|$|R
25|$|In {{computer}} science a partial function corresponds to <b>a</b> subroutine that <b>raises</b> <b>an</b> <b>exception</b> or loops forever. The IEEE floating point standard defines a not-a-number value which is returned when a floating point operation is undefined and exceptions are suppressed, e.g. when the square root {{of a negative}} number is requested.|$|R
5000|$|In {{this case}} if the {{division}} has no finite representation, as when one computes e.g. 1/3=0.33333..., the divide (...) method can <b>raise</b> <b>an</b> <b>exception</b> if no rounding mode is defined for the operation.Hence the library, {{rather than the}} language, guarantees that the object respects the contract implicit in the class definition.|$|R
40|$|Motivated by a {{concrete}} goal, namely to extend Erlang {{with the ability}} to employ user-defined guards, we developed a parameterized static analysis tool called Purity, that classifies functions as referentially transparent (i. e., side-effect free with no dependency on the execution environment and never <b>raising</b> <b>an</b> <b>exception),</b> side-effect free with no dependencies but possibly raising exceptions, or side-effect free but with possible dependencies and possibly raising exceptions. We have applied Purity on a large corpus of Erlang code bases and report experimental results showing the percentage of functions that the analysis definitely classifies in each category. Moreover, we discuss how our analysis has been incorporated on a development branch of the Erlang/OTP compiler in order to allow extending the language with user-defined guards. © 2011 Springer-Verlag...|$|E
40|$|Abstract. In {{concurrent}} programs <b>raising</b> <b>an</b> <b>exception</b> in one thread {{does not}} prevent others from operating on an inconsistent shared state. Instead, exceptions should ideally be handled in coordination by all the threads that are affected by their cause. In this paper, we propose a Java language extension for coordinated exception handling where a named abox (atomic box) is used to demarcate a region of code that must execute atomically and in isolation. Upon an exception raised inside an abox, threads executing in dependent aboxes, roll back their changes, and execute their recovery handler in coordination. We provide a dedicated compiler framework, CXH, to evaluate experimentally our atomic box construct. Our evaluation indicates that, in addition to enabling recovery, an atomic box executes a reasonably small region of code {{twice as fast as}} when using a failbox, the existing coordination alternative that has no recovery support...|$|E
40|$|The {{extension}} of the language Oberon- 2 [1] with exception handling, read-only parameters and local procedures as arguments to called procedures is described. An informal description of its semantics is given. Dierences with existing mechanisms are discussed. A global overview of the implementation of exception handling and its consequences for runtime data structures and compilation are given. Keywords: Exception Handling, constant parameters, Oberon- 2 1 Exceptions The Groningen Oberon Compiler has been equipped with facilities for exception handling. The usefulness of this extension followed naturally from experiences with the ModPas Compiler [4] and systems. There are basically two relevant aspects to exception handling: 1. Exceptions {{can be associated with}} hard- or software detected errors, and form a standard way of dealing with such errors by " an exception when an error is detected. A fundamental aspect of <b>raising</b> <b>an</b> <b>exception</b> is that the program code is not continued [...] ...|$|E
50|$|A common {{argument}} for error hiding {{is the desire}} to hide complexity from the user. Frequently best practice is to <b>raise</b> <b>an</b> <b>exception</b> to the user to hide a complex error message but to save the full error message to an error log which a support engineer can access to resolve the problem.|$|R
50|$|In Delphi and Free Pascal on Microsoft Windows, the safecall calling {{convention}} encapsulates COM (Component Object Model) error handling, thus exceptions aren't leaked {{out to the}} caller, but are reported in the HRESULT return value, as required by COM/OLE. When calling a safecall function from Delphi code, Delphi also automatically checks the returned HRESULT and <b>raises</b> <b>an</b> <b>exception</b> if necessary.|$|R
50|$|When {{a program}} was running in 'problem state', using a privileged {{instruction}} or an invalid memory address {{would cause the}} hardware to <b>raise</b> <b>an</b> <b>exception</b> condition. By trapping these conditions, CP could simulate the appropriate behavior, e.g. performing I/O or paging operations. A guest operating system, which would run in 'supervisor state' on a bare machine, was run in 'problem state' under CP.|$|R
40|$|A {{systematic}} way to introduce fault-tolerant and time-dependent properties into a complex software system is presented. The approach {{is based on}} an extended Petri Net model, called the G-Net, enhanced with the deterministic timing scheme. In Timed G-Net (TGN) model, exception handling and time-out mechanism,is used to introduce the fault tolerance properties. The basic idea is to avoid the timing error propagation from a faulty object to an object that interacts with it via a time-out mechanism, and also to allow an object to treat a timing error by <b>raising</b> <b>an</b> <b>exception</b> and triggering some corrective actions. Using TGNs as basic building block, we further refine the model into Smart Object (SMO) model. In each SMO, an object can associated with a knowledge structure, which enable the object to dynamic change its behavior to react the changes of environment. We use examples to show that the a simplified real-time distributed Air Traffic Control System can be modeled effectively using th [...] ...|$|E
40|$|International audienceComputational {{effects may}} often be {{interpreted}} in the Kleisli category of a monad or in the coKleisli category of a comonad. The duality between monads and comonads corresponds, in general, to a symmetry between construction and observation, for instance between <b>raising</b> <b>an</b> <b>exception</b> and looking up a state. Thanks to the properties of adjunction one may go one step further: the coKleisli-on-Kleisli category of a monad provides a kind of observation {{with respect to a}} given construction, while dually the Kleisli-on-coKleisli category of a comonad provides a kind of construction with respect to a given observation. In the previous examples this gives rise to catching an exception and updating a state. However, the interpretation of computational effects is usually based on a category which is not self-dual, like the category of sets. This leads to a breaking of the monad-comonad duality. For instance, in a distributive category the state effect has much better properties than the exception effect. This remark provides a novel point of view on the usual mechanism for handling exceptions. The aim {{of this paper is to}} build an equational semantics for handling exceptions based on the coKleisli-on-Kleisli category of the monad of exceptions. We focus on n-ary functions and conditionals. We propose a programmer's language for exceptions and we prove that it has the required behaviour with respect to n-ary functions and conditionals...|$|E
40|$|Dynamically typed {{programming}} languages like R allow programmers {{to write}} generic, flexible and concise code and {{to interact with}} the language using an interactive Read-eval-print-loop (REPL). However, this flexibility has its price: As the R interpreter has no information about the expected variable type, many base functions automatically convert the input instead of <b>raising</b> <b>an</b> <b>exception.</b> Unfortunately, this frequently leads to runtime errors deeper down the call stack which obfuscates the original problem and renders debugging challenging. Even worse, unwanted conversions can remain undetected and skew or invalidate the results of a statistical analysis. As a resort, assertions can be employed to detect unexpected input during runtime and to signal understandable and traceable errors. The package "checkmate" provides a plethora of functions to check the type and related properties of the most frequently used R objects and variable types. The package is mostly written in C to avoid any unnecessary performance overhead. Thus, the programmer can conveniently write concise, well-tested assertions which outperforms custom R code for many applications. Furthermore, checkmate simplifies writing unit tests using the framework "testthat" by extending it with plenty of additional expectation functions, and registered C routines are available for package developers to perform assertions on arbitrary SEXPs (internal data structure for R objects implemented as struct in C) in compiled code...|$|E
40|$|Programmers are not perfect>! Write {{programs}} that perform out-of-bounds references>! All {{of these are}} questionable; some are malicious •! Technology for avoiding out-of-bounds references is easy>! Bounds check each reference>! 1970 s compilers could insert such checks (PL/I) •! Code with checking runs slowly>! Obvious opportunity for optimization>! We need compilers that implement this kind of checking!! Buffer overflow attacks & other subtle bugs •! PL. 8 philosophy: check everything & optimize checks COMP 512, Spring 2009 ! 2 ! Obvious Solution Add a dynamic check to each reference … " a[i] check(a,i) … " a[i] Assume a[1 : 100], so Min(a) is 1 and Max(a) is 100 •! check(a,i) performs two tests>! Min(a) ! i <b>raises</b> <b>an</b> <b>exception</b> (lbcheck(a,i)) >! i! Max(a) <b>raises</b> <b>an</b> <b>exception</b> (ubcheck(a,i)) •! In a loop, the compiler {{may be able to}} move one or both tests based on knowledge of the induction variable’s behavior •! Same abstraction fits structures of arrays, arrays of structures, … PL/I Checkout compiler implemented “check...|$|R
50|$|A {{number of}} {{networking}} and threading libraries are available, such as EiffelNet and EiffelThreads. A concurrency model for Eiffel, {{based on the}} concepts of design by contract, is SCOOP, or Simple Concurrent Object-Oriented Programming, not yet part of the official language definition but available in EiffelStudio.CAMEO is an (unimplemented) variation of SCOOP for Eiffel.Concurrency also interacts with exceptions. Asynchronous exceptions can be troublesome (where <b>a</b> routine <b>raises</b> <b>an</b> <b>exception</b> after its caller has itself finished).|$|R
5000|$|For {{returning}} a {{value of}} one of several types, a tagged union can be used instead; the most common cases are nullable types (option types), where the return value can be null to indicate failure. For exception handling, one can return a nullable type, or <b>raise</b> <b>an</b> <b>exception.</b> For example, in Python one might have either:result = Parse(s)if result is None: # exception handlingor, more idiomatically:try: result = Parse(s)except ParseError: # exception handling ...|$|R
40|$|Computational {{effects may}} often be {{interpreted}} in the Kleisli category of a monad or in the coKleisli category of a comonad. The duality between monads and comonads corresponds, in general, to a symmetry between construction and observation, for instance between <b>raising</b> <b>an</b> <b>exception</b> and looking up a state. Thanks to the properties of adjunction one may go one step further: the coKleisli-on-Kleisli category of a monad provides a kind of observation {{with respect to a}} given construction, while dually the Kleisli-on-coKleisli category of a comonad provides a kind of construction with respect to a given observation. In the previous examples this gives rise to catching an exception and updating a state. However, the interpretation of computational effects is usually based on a category which is not self-dual, like the category of sets. This leads to a breaking of the monad-comonad duality. For instance, in a distributive category the state effect has much better properties than the exception effect. This remark provides a novel point of view on the usual mechanism for handling exceptions. The aim {{of this paper is to}} build an equational semantics for handling exceptions based on the coKleisli-on-Kleisli category of the monad of exceptions. We focus on n-ary functions and conditionals. We propose a programmer's language for exceptions and we prove that it has the required behaviour with respect to n-ary functions and conditionals. Comment: arXiv admin note: substantial text overlap with arXiv: 1310. 060...|$|E
40|$|PyPI: [URL] Docs: [URL] Performance Optimizations Change wiggle_interval {{to return}} success bool instead of <b>raising</b> <b>an</b> <b>exception.</b> This allows the implicitization {{approach}} {{to use it}} without having to use exceptions for flow-control. (Fixes # 22.) Switching Fortran speedups from f 2 py to Cython (this is because f 2 py artificially limits the feature set of Fortran, i. e. user defined types) Moving some more code to Fortran (e. g. bbox_line_intersect() 3 dcf 640) New Features Making Fortran features available outside of Python (see Native Libraries) C headers for each Fortran module (via bezier. get_include()) Cython. pxd declarations for all Fortran modules libbezier static library (via bezier. get_lib()) Implementing bezier_roots() polynomial root solver for polynomials written in Bernstein basis. (0 dd 6369) Miscellany Getting bezier published in the Journal of Open Source Science (JOSS). See review. (e 6 c 4536 and 975 ac 6 b) Updating error message for locate() methods and adding a note that locate() / evaluate*() are (essentially) inverses. H/T to @pdknsk # 36 Using Fortran-contiguous arrays in _check_non_simple(). (b 06 c 78 e) Moving most of Curve. subdivide() and Surface. subdivide() logic into helpers. This {{is part of an}} effort to make all helpers take low-level data types rather than Curves, Surfaces, etc. (34515 bd and 1 fc 80 e 5) Split speedup. f 90 into submodules curve. f 90, surface. f 90, etc. (75349 b 7, dfd 6 bba, 7096 a 9 d, c 326 c 00) Adding BEZIER_JOURNAL option to setup. py. This stores a record of compiler commands invoked during installation. See Native Libraries for more details. (3 d 832 e 7 and c 64 a 97 a...|$|E
40|$|This release, {{named after}} Karlsruhe, {{one of the}} home cities of live coding, is mainly a {{maintenance}} release with a strong focus on both performance, stability and documentation. This is therefore the fastest and most stable release of Sonic Pi ever with a massive 10 % performance improvement on the original Raspberry Pi 1. It also ships with new translations in Polish, Japanese and French. Many of these improvements (such as the complete rewrite of the OSC stack) are not documented in this release list but can instead {{be found in the}} commit logs over on Github. However, not to go unnoticed are a number of exciting new features. For example we now have a new Band EQ FX, the ability to use MIDI note names such as :e 5 as values for opts such as cutoff:, and new powerful cutoff envelopes on the sampler. Breaking Changes Shortcuts for switching buffers have changed. They are now M-{ and M-} for switching left and right respectively. sync no longer inherits BPM by default. Set the bpm_sync: opt to true to enable BPM inheritance. Random seed generation for new threads is now reset on calls to use_random_seed. New Fns octs - returns a ring of successive octaves. assert - for <b>raising</b> <b>an</b> <b>exception</b> if the argument is not true. assert_equal - for <b>raising</b> <b>an</b> <b>exception</b> if the two arguments are not equal. bt - converts the specified time w. r. t. the current BPM. inspect - similar to print but prints the inspected version of the argument. GUI New translations for Polish, Japanese and French. Improve efficiency of logging panel. M-RET is now a duplicate shortcut for running the code. Log title bar is now hidden in full-screen mode. Log - don't display └ or ├ if the line is blank, instead display │ Add sample name autocompletion to more fns such as sample_duration. Documentation New tutorial section on ring chains (chainable functions for modifying rings) Tilburg 2 example slightly tweaked for Raspberry Pi 1 compatibility. Many minor tweaks and improvements in all areas. Synths & FX New FX - Band EQ for attenuating or boosting a specific frequency band. New synth - DPulse - a detuned pulse wave. Sampler now has a cutoff envelope which can be accessed via new opts which mirror the standard envelope opts but with a cutoff_ prefix (such as cutoff_attack, cutoff_decay_level and friends). Sampler now correctly handles samples with different sample rates. Bitcrusher FX now has an internal low pass filter modifiable via a new cutoff opt. Panslicer now correctly honours min and max pan values. New default opt on: for both sample and synth. This acts like if but ensures all the opt vals are evaluated (useful if wanting to keep the consumption of random streams or ticks consistent even when not triggering a synth. MIDI opts such as cutoff: can now accept note names such as :c 4. FX learned the global slide: opt to match synths. Improvements Massive performance improvements. Teach play_pattern_timed to handle rings. current_transpose now returns 0 if there is no current transposition. BPM scaling is now honoured when controlling synths and FX All with_fx* fns now return the result of their block. spark now handles rings correctly. spark now treats booleans as 1 s and 0 s so you can now spark rings of bools. puts, print and mc_message now handle multiple message arguments Bug Fixes Ensure with_fx doesn't swallow TL modifications such as transposition, current synth etc. Ensure with_fx doesn't affect random seed. Improve reliability of boot process on Mac and Windows. The FX pre_amp: opt is no longer scaled w. r. t. the current BPM. Fixed GUI side of update checking system...|$|E
5000|$|Sometimes error hiding {{is a valid}} activity, {{for example}} {{accessing}} {{the contents of a}} file that does not exist in Java version 1.3 or older would result in an [...] message without any reference to the missing file. In this case it would be sensible to hide the error and <b>raise</b> <b>an</b> <b>exception</b> based on what the application was trying to do at the time, giving what extra information can be obtained.|$|R
2500|$|Software {{exception}} handling {{and the support}} provided by software tools differs somewhat from what is understood under exception in hardware, but similar concepts are involved. In programming language mechanisms for {{exception handling}}, the term exception is typically used in a specific sense to denote a data structure storing information about an exceptional condition. One mechanism to transfer control, or <b>raise</b> <b>an</b> <b>exception,</b> is known as <b>a</b> throw. The <b>exception</b> {{is said to be}} thrown. Execution is transferred to a [...] "catch".|$|R
50|$|Fakes are {{lightweight}} {{objects that}} mock actual objects' interface. In order {{to test a}} class in isolation, usually some test doubles or anonymous objects are used in place of integrated classes with required methods stubbed in it. But {{there is a problem}} with this approach, If the class is changed in between, those changes are not reflected in mock objects and tests run without any integration exceptions. Fakes resolve this problem as they will have exact interface of real collaborator and will <b>raise</b> <b>an</b> <b>exception</b> whenever the actual class is modified.|$|R
