0|358|Public
50|$|Chapter 4: <b>Reversing</b> <b>Tools.</b>|$|R
6000|$|... "I don't mean to call mine hopeless," [...] said Hans, with {{provoking}} coolness, {{laying down}} his <b>tools,</b> <b>thrusting</b> his thumbs into his belt, and moving away a little, {{as if to}} contemplate his picture more deliberately.|$|R
6000|$|... "No, it can't," [...] said Hans, impetuously, {{throwing}} {{down his}} <b>tools,</b> <b>thrusting</b> {{his hands into}} his coat-pockets, and turning round to face Deronda, who drew back a little and looked at him with amazement. Hans went on in the same tone-- ...|$|R
40|$|Plasmodium falciparummalaria {{imposes a}} seriouspublichealthconcern {{throughout}} the tropics. Although genetic tools are principally important to fully investigatemalaria parasites, currently available forward and <b>reverse</b> <b>tools</b> are fairly limited. It is expected thatparasiteswithahighmutation ratecan readilyacquirenove...|$|R
40|$|By using <b>reverse</b> {{engineering}} <b>tools,</b> {{the software}} developer {{is able to}} generate {{the structure of a}} software system in graphical reports such as hierarchy trees, call graphs, flow charts, class diagrams and then export reports into various formats such as HTML, XML, XMI (Xml Metadata Interchange) or the formats of other <b>reverse</b> engineering <b>tools.</b> C++ programming language supports object-oriented programming and there are more <b>reverse</b> engineering <b>tools</b> supporting this language than other languages such as C# and Java. However, {{there have been a few}} evaluation works in comparing, contrasting and thoroughly identifying the capabilities of <b>reverse</b> engineering <b>tools</b> for C++ applications. Therefore, in this thesis, four widely used <b>reverse</b> engineering <b>tools</b> which support C++ are chosen to be examined, namely Rigi, Columbus/CAN, Imagix 4 D, and Understand. The tools are evaluated by using them to examine two different types of C++ application: a small game and a large library written in Visual C++. After evaluating them and considering other related research work on evaluation, I outline and comment on the features and capabilities of the tools, along with their strengths and limitations. Last but not least, I provide the reader with some suggestions for designing and implementing an efficient <b>reverse</b> engineering <b>tool</b> for C++ applications. Keywords: Reverse Engineering, C++, CASE tools, Software quality management, Software maintenance, Reusabilit...|$|R
40|$|Software maintainers {{often use}} <b>reverse</b> {{engineering}} <b>tools</b> {{to aid in}} the extremely difficult task of understanding unfamiliar code, especially within large, complex software systems. While traditional program analysis can provide detailed information for reverse engineering, often this information is not sufficient to assist the user with high-level program understanding tasks. To bridge the gap between current <b>reverse</b> engineering <b>tools</b> and the high-level questions that software maintainers want answered, we propose supplementing traditional program analysis with natural language analysis of program source code. This paper presents a case study where we have augmented an existing <b>reverse</b> engineering <b>tool,</b> an aspect miner, to complement the existing traditional programanalysis-based miner with natural language analysis of method names, class names, and comments. Our quantitative and qualitative results strongly suggest that supplementing traditional program analysis with natural language analysis is a promising approach to raising the level of effectiveness of <b>reverse</b> engineering <b>tools...</b>|$|R
40|$|One of the {{challenges}} of reverse engineering is the extraction of a specification from source code. Our work proposes a singular approach {{to the construction of}} <b>reverse</b> engineering <b>tools.</b> Using a transformation based software machine we have built two languages designed to help the construction of <b>reverse</b> engineering <b>tools.</b> Each one of these languages embodies an important domain in reverse engineering. This approach is {{based on the idea that}} reuse in a high level of abstraction is possible, if a domain is written for a class of problems. This is the premise of the Draco paradigm, a reuse based strategy for software construction. We also demostrate the use of these languages, by writing a <b>reverse</b> engineering <b>tool</b> that was able to derive a specification from a system built by others and of which we had no previous knowledge. This paper explains how we have built the languages and how they were reused for building a <b>reverse</b> engineering <b>tool.</b> 1...|$|R
40|$|In {{this paper}} {{we present a}} {{proposal}} for a novel approach to facilitating transparent interoperability among <b>reverse</b> engineering <b>tools.</b> We characterize the architectural and operational characteristics of <b>reverse</b> engineering <b>tools</b> and demonstrate that many similarities exist among them. Taking full advantage of these similarities, we outline an approach for creating a domain ontology of operational and representational concepts for a given set of tools. A special adapter is proposed that makes use of this ontology to facilitate transparent interoperability among them...|$|R
40|$|Abstract. Dry {{drilling}} {{of aluminum}} is environmentally friendly machining technique; {{in the meanwhile}} {{it is difficult to}} carry out due to aluminums gummy behavior and its tendency to adhere to cutting tools which diminishes hole quality. In spite of recent developments in cutting tool technology, HSS tools are still a cost effective choice due to relatively high toughness and feasibility to manufacture complex geometries of HSS drills besides its low price, make this tool a common choice for drilling soft materials such as aluminum. In this study effect of <b>tool</b> wear on <b>thrust</b> force and torque analyzed and hole quality assessed with respect to tool wear along tool life. Dry drilling on aluminum 2024, performed using HSS and HSCo drills at constant feed rate of 0. 04 mm/rev and two cutting speeds of 28 and 94 m/min. Results revealed that the abrasive wear on flank face and BUE on chisel edge, margin and cutting lips were dominant mechanisms in all drills. It was found that with propagating the wear land on <b>tool,</b> <b>thrust</b> force and torque increased in both tools...|$|R
40|$|AbstractAfter {{adopting}} a standard format such as GXL to exchange graphs of artifacts for <b>reverse</b> engineering <b>tools,</b> {{the next logical}} step is to define an appropriate schema for the information contained in the graphs. Various researchers have developed schemas, but in practice, it is still hard to choose an existing one. Typically, researchers end up needing to implement new schemas for the particulars of their tools or case studies. In the paper, we discuss a potential scenario for integrating schemas, with the aim of improving the interoperability among <b>reverse</b> engineering <b>tools...</b>|$|R
40|$|As large systems evolve, their {{architectural}} integrity {{tends to}} decay. <b>Reverse</b> engineering <b>tools,</b> such as PBS [7, 19], Rigi [15], and Acacia [5], {{can be used}} to acquire an understanding of a system's "as-built" architecture and in so doing regain control over the system. A problem that has impeded the widespread adoption of <b>reverse</b> engineering <b>tools</b> is the tight coupling of their subtools, including source code "fact" extractors, visualization engines, and querying mechanisms; this coupling has made it difficult, for example, for users to employ alternative extractors that might have different strengths or understand different source languages. The TAXFORM project has sought to investigate how different <b>reverse</b> engineering <b>tools</b> can be integrated into a single framework by providing mappings to and from common data schemas for program "facts" [2]. In this paper, we describe how we successfully integrated the Acacia C and C++ fact extractors into the PBS system, and how we were then a [...] ...|$|R
40|$|In {{software}} re-engineering projects {{very often}} {{you have the}} source code of an application but you miss its programmer, the design and the documentation. In order to understand these systems you need <b>reverse</b> engineering <b>tools.</b> UMLDesignExtractor is the prototype of a <b>reverse</b> engineering <b>tool</b> generating UML class diagrams from object-oriented code. UMLDesignExtractor is built on top of MOOSE and is written in SMALLTALK. For the graphical output it uses the API of Rational Rose, a professional UML modeler. In the following chapters you find a survey on the involved technologies and architectures {{as well as a}} detailed description of the application UMLDesignExtractor, illustrated with four case studies...|$|R
60|$|Leigh did not reply. The mystery {{seemed to}} thicken, {{and he was}} unable to form any supposition, whatever, that would account for the man's proceedings. The latter carried his burden up to the cannon, then he laid it down, and took up some long <b>tool</b> and <b>thrust</b> it into the mouth of one of the cannon.|$|R
50|$|Multi-jackbolt {{tensioners}} (MJTs), registered {{under the}} trademark Superbolt or Supernut, {{are designed to}} decrease the torque required to tighten large bolted joints. One of the major problems associated with traditional bolt tightening methods is as {{the diameter of the}} bolt increases, the amount of torque required to tighten it increases in the third power of the diameter. Because of this, the largest size bolt a person can typically tighten by hand is 1".Multi-jackbolt tensioners reduce the amount of torque required to clamp the joint by using multiple jackbolts threaded through the nut or bolt head.The jackbolts, which are small enough to be tightened by simple hand <b>tools,</b> <b>thrust</b> against a hardened washer and generate clamping force on the joint. Loads up to 20,000,000 pounds and greater are attainable using only hand tools. MJTs and related products are produced by Superbolt, Inc. in Carnegie, PA.|$|R
50|$|Because {{the details}} of the CryptGenRandom {{algorithm}} are not public, Dorrendorf's team used <b>reverse</b> engineering <b>tools</b> to discern how the algorithm works. Their paper is the first published record of how the Windows cryptographic random number generator operates.|$|R
40|$|International audienceFor {{more than}} three decades, reverse {{engineering}} {{has been a major}} issue in industry wanting to capitalise on legacy systems. Lots of companies have developed <b>reverse</b> engineering <b>tools</b> in order to help developers in their work. However, those tools have been focusing on traditional information systems. Working on a time critical embedded system we found that the solutions available focus either on software behaviour structuring or on data extraction from the system. None of them seem to be clearly using both approaches in a complementary way. In this paper, based on our industrial experiment, we list the requirements that such a tool should fulfil. We also present a short overview of existing <b>reverse</b> engineering <b>tools</b> and their features...|$|R
40|$|Maintenance and {{evolution}} of complex software systems (such as mobile telephones) involves activities such as reverse engineering and software visualisation. Reverse engineering provides a conceptual framework for de-scribing the software understanding and concept abstrac-tion processes. This framework is implemented up to different degrees by several <b>reverse</b> engineering <b>tools.</b> However, we found the architecture of most of these tools hard {{to adapt to the}} domain and problem specific require-ments posed by our current practice in Nokia. We be-lieve that the architecture of a <b>reverse</b> engineering <b>tool</b> should reflect the logical steps of the conceptual frame-work. We propose such an architecture and present a con-crete reverse engineering toolkit that implements it. The toolkit provides a flexible way to build reverse engineer-ing scenarios by subclassing and composition of a few basic software components. We pay special attention to the visual and interactive requirements of the reverse en-gineering process. We compare our toolkit with other ex-isting <b>reverse</b> engineering visual <b>tools</b> and outline the dif-ferences. We show our plans to use it for further research on visualising the complex software structures that we extract from our products. ...|$|R
50|$|About {{the year}} 1920 during {{building}} excavation work, a whole underground maze of passageways some 1.8 m high with peaked ceilings, well preserved inside a cliff, was unearthed. The walls showed {{no trace of}} any work done with the customary striking tools, but rather they had been painstakingly hewn out of the stone with <b>thrusting</b> <b>tools.</b> Here and there, narrow shafts {{leading up to the}} surface had been bored, through which spoil might have been lifted in leather sacks. The apparent use of <b>thrusting</b> <b>tools</b> has given rise to the supposition that this maze of tunnels might have been the Romans’ work.|$|R
40|$|This paper {{examines}} {{the exchange of}} software representations among <b>reverse</b> engineering <b>tools.</b> Background information on maintenance related activities and their importance in the software development lifecycle are outlined. An overview of tool support for software maintenance demonstrates {{the need for a}} standardized means for facilitating the exchange of information among <b>reverse</b> engineering <b>tools.</b> A variety of techniques for exchanging software representations are examined with respect to their relative advantages and disadvantages. The characteristics of a number of software exchange formats are summarized among various taxonomies. Four different types of exchange are characterized. Each is evaluated on how it satisfies the requirements for a standard exchange format. The paper concludes {{with a look at the}} direction research efforts are taking towards enabling the exchange of software representation...|$|R
50|$|In November 1995, Protosoft was {{acquired}} by Platinum Technology for 40 million U.S. dollars. Protosoft was founded by Dr. Anthony Lekkos and Erick Rivas in 1990 to develop and market Paradigm Plus, an object-oriented analysis and design (OOAD) modeling product and associated code generation and <b>reverse</b> engineering <b>tools.</b>|$|R
5000|$|The Metabolic Networks Department studies a wide set of {{physiological}} {{processes involved in}} orchestrating photosynthetic carbon metabolism, nitrogen and phosphate utilization, growth, and storage. Systems biology will be emphasized and forward and <b>reverse</b> genetic <b>tools</b> will often be used. Under Mark Stitt, the department currently has four research groups: ...|$|R
40|$|We {{present a}} web-based portal site for reverse {{engineering}} software systems called REportal. REportal enables authorized users to upload their code to a secure {{web site and}} then, through the guide of wizards, browse and analyze their code. Currently the portal services include code analysis, browsing, querying, and design extraction for C, C++, and Java programs. The REportal services are implemented by several <b>reverse</b> engineering <b>tools</b> that our team has developed over the years. With this work, we aim to assist professional software engineers, educators, and other researchers who need to analyze code. Specifically, we present a technology that provides a simple and easily accessible user inteace {{to a number of}} <b>reverse</b> engineering <b>tools.</b> More importantly, this technology saves the user from the time and effort required to install, administer, and integrate these tools...|$|R
40|$|Software Engineering {{research}} and industry {{recognize the need}} for practical <b>tools</b> to support <b>reverse</b> engineering activities. Most of the well-known CASE-tools nowadays support reverse engineering in some way or other. Reverse engineering is first step towards software Architecture recovery. The most commonly used standard today is Unified Modeling Language to depict the architecture and design of an application. An UML class diagram describes the architecture of object oriented programs. Class diagram captures the essence of its design. Most of the existing systems do not have reliable software architecture and some legacy systems are designed without software architecture design phase. By using <b>reverse</b> engineering <b>tools</b> we can generate class diagram as part of software architecture recovery. In this paper we assess capabilities of software <b>reverse</b> engineering <b>tools</b> to generate class diagram from java source code...|$|R
40|$|Software {{maintenance}} (SM) {{for large}} legacy systems {{is a very}} inefficient process; on average, 70 % of software costs are spent on maintenance [Swanson 89]. The inefficiency of SM has been related to the difficulty comprehending software systems; therefore program comprehension {{is considered to be}} a key bottleneck of SM. <b>Reverse</b> engineering <b>tools</b> have been used to alleviate this bottleneck with lower than expected success. We present a cognitively based approach for <b>reverse</b> engineering <b>tool</b> development. We use ideas from cognitive psychology and other disciplines to formulate the approach. We also describe a case study in which we applied the approach in a telecommunication company. The case study resulted in the development of DynaSee, a <b>reverse</b> engineering <b>tool</b> which helps software engineers analyze dynamic program information. DynaSee reads routine call traces, and provides several processing and visualization features that make the use of traces much more useful for software maintenance and program comprehension. Next, we describe and evaluate the various features of DynaSee that compress, abstract and augment traces to make them comprehensible and useful for SM tasks. Finally, based on our experience in developing DynaSee, we generalize the aspects of our findings and techniques that are based on psychology by relating them to the mainstream psychological literature and to other disciplines where similar techniques have been used...|$|R
40|$|Most {{traditional}} <b>reverse</b> engineering <b>tools</b> {{focus on}} abstraction {{and analysis of}} source code, presenting a visual representation of the software architecture. This approach can be both helpful and cost effective in software maintenance tasks. However, where large software teams are concerned, with moderate levels of employee turnover, traditional <b>reverse</b> engineering <b>tools</b> can be inadequate. To address this issue, we examine the use of software process data, such as software artifact change history and developer activities. We propose the application of this data confers additional information developers need to better understand, maintain and develop software in large team settings. To explore this hypothesis, we evaluate {{the use of a}} tool, Xia, in the navigation of both software artifacts and their version history. This paper introduces Xia, reveals the results of our evaluation and proposes directions for future research in this area. 1...|$|R
40|$|The reverse {{engineering}} capabilities of a software tool system {{are essential for}} the process of analyzing and understanding complex software systems during its maintenance, re-engineering and re-architecturing phases. There are several commercial <b>reverse</b> engineering <b>tools</b> on the market providing dierent capabilities. We evaluated the TDE/Columbus system in terms of {{reverse engineering}} issues. For the assessment criteria an existing evaluation work has been taken as the basis. Our evaluation {{results show that the}} subject system has some interesting features comparing to the existing <b>reverse</b> engineering <b>tools</b> on the market. Keywords <b>Tool</b> evaluation, <b>reverse</b> engineering, source code parsing, large-scale software systems 1 INTRODUCTION One of the most critical issues in large-scale software development and maintenance is the rapidly growing size and complexity of the systems. The Software Technology Laboratory of Nokia Research Center has developed a software product|the Telec [...] ...|$|R
40|$|Recently, {{the reverse}} {{engineering}} research {{community has been}} investigating mechanisms for exchanging data and partial results between <b>reverse</b> engineering <b>tools</b> [10, 7]. Among the many subproblems inherent in implementing a standard exchange format (SEF) is the design of schemas that represent views of source code at various levels of abstraction. In this paper, w...|$|R
5000|$|... 3. Searching. The search tools on {{many sites}} allow members to filter {{searches}} by destination, date, number of rooms {{and number of}} travelers. Additional criteria might include home amenities and local attractions. <b>Reverse</b> search <b>tools,</b> which allow users to search for members interested in visiting their specific area, are {{the most effective way}} of finding a match.|$|R
40|$|A domain model {{specifies}} interaction {{logic and}} relationships between system objects. As technologies are improving rapidly, changes in existing models are also required. Manual creation or improvement of models is time-consuming, increases expenses and reduces efficiency, that’s why automation {{of this process}} could be useful. The paper presents a short overview of reverse engineering principles, Topological Functioning Modeling for Model Driven Architecture (TFM 4 MDA), and eight <b>reverse</b> engineering <b>tools</b> used for converting software source code {{in order to obtain}} a domain model within TFM 4 MDA. The scientific papers, presentations, reports, and tool owner websites were used for finding <b>reverse</b> engineering <b>tools</b> and their characteristics. The more attention was devoted to those tools which have the detailed specification, support Eclipse platform and create UML diagrams or similar. All of the overviewed tools support creation of at least UML class diagram from Java, C and C++ code...|$|R
40|$|Recovering the {{architecture}} of legacy systems requires more than just <b>reverse</b> engineering <b>tools</b> to generate some higherlevel descriptions of the system under study. Design decisions and logical groupings of functions have to be balanced with informal domain knowledge, domain standards and coding guidelines of the developers. Therefore, we combine domain aspects with coding aspects and use <b>reverse</b> engineering <b>tools</b> as one means of recovering the requested information to reason about the underlying architecture of the system. This reasoning is an alternating top-down and bottom-up approach. The architecture recovery process we introduce is {{one part of the}} ESPRIT project ARES (Architectural Reasoning for Embedded Systems). 1 1 Introduction and Motivation Reverse engineering techniques are usually applied if information about an existing software system is required, for example, in case of corrective or adaptive maintenance. 2 The recovery of architectural information is different in t [...] ...|$|R
40|$|Abstract: Nowadays the {{development}} without model-based approaches are hardly imaginable, because models {{are not only}} closer to human thinking but also help the communication between developers. During a long development process the initial model becames inconsistent with the code that can be synchronised manually or automatically by <b>tools.</b> <b>Reverse</b> engineering <b>tools</b> have been created to help developers achieving that the design and the implementation harmonize again. This work examines {{the importance of the}} model-based development and gives an overview of the state-of-the-art reverse engineering methods and tools. Round-trip engineering is a more advanced approach of software development than reverse engineering, because the changes that affect the design are made not in the code but in the model, hereby better software quality can be achieved...|$|R
40|$|Virus-induced gene {{silencing}} (VIGS) {{is an alternative}} <b>reverse</b> genetics <b>tool</b> for silencing of genes in some plants, which are difficult to transform. The pea early-browning virus (PEBV) has been developed as a VIGS vector and used in pea for functional analysis of several genes. However, the available PEBV-VIGS protocols are inadequate for studying genes involved in the symbiosis with arbuscular mycorrhizal fungi (AMF) ...|$|R
40|$|Source model {{extraction}} [...] -the automated {{extraction of}} information from system artifacts [...] -is a common phase in <b>reverse</b> engineering <b>tools.</b> One of the major challenges of this phase is creating extractors that can deal with irregularities in the artifacts that are typical for the reverse engineering domain (for example, syntactic errors, incomplete source code, language dialects and embedded languages). This pape...|$|R
40|$|We {{demonstrate}} how the data management techniques known as On [...] Line Analytical Processing, or OLAP, {{can be used}} to enhance the sophistication and range of software <b>reverse</b> engineering <b>tools.</b> This is the first comprehensive examination of the similarities and differences in these tasks both in how OLAP techniques meet (or fail to meet) the needs of reverse engineering and in how reverse engineering can be recast using data analysis. To permit the seamless integration of these technologies, we extend a multidimensional data model to manage dynamically changing dimensions (over which data can be aggregated). We use a case study of the Apache web server to show how our solutions permit an integrated view of data ranging from low level program analysis information to abstract, aggregate information. These high [...] level abstractions may be provided either by humans (perhaps using a visualization tool) or directly from <b>reverse</b> engineering <b>tools</b> or data mining techniques...|$|R
40|$|Object state {{behavior}} {{implies that}} the effect of an operation on an object may depend on the states of the object and other objects. It may cause state changes to more than one object. Thus, the combined or composite effects of the object operations must be analyzed and tested. We show that certain object state behavior errors cannot be detected readily by conventional testing methods. We describe an object state test method consisting of an object state model, a <b>reverse</b> engineering <b>tool,</b> and a composite object state testing tool. The object state test model is an aggregation of hierarchical, concurrent, communicating state machines envisioned mainly for object state testing. The <b>reverse</b> engineering <b>tool</b> produces an object state model from any C++ program. The composite object state testing tool analyzes the object state behaviors and generates test cases for testing object state interactions. We show the detection of several composite object state behavior errors that exist in a well- [...] ...|$|R
40|$|Reverse Engineering is {{a process}} fraught with imperfec-tions. The {{importance}} of dealing with non-precise, possi-bly inconsistent data explicitly when interacting with the re-verse engineer has been pointed out before. In this paper, we go one step further: we argue that the complete reverse engineering process must be augmented with a formal representation model capable of modeling imperfections. This includes automatic as well as human-centered tools. We show how this {{can be achieved by}} merging a fuzzy set-theory based knowledge representation model with a re-verse engineering repository. Our approach is not only ca-pable of modeling a wide range of different kinds of im-perfections (uncertain as well as vague information), but also admits robust processing models by defining explicit degrees of certainty and their modification through fuzzy be-lief revision operators. The repository-centered approch is proposed as the foun-dation {{for a new generation of}} <b>reverse</b> engineering <b>tools.</b> We show how various RE tasks can benefit from our ap-proach and state first design ideas for fuzzy <b>reverse</b> engi-neering <b>tools.</b> 1...|$|R
