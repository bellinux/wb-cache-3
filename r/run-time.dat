10000|253|Public
5|$|The type dynamic {{allows for}} <b>run-time</b> method binding, {{allowing}} for JavaScript-like method calls and <b>run-time</b> object composition.|$|E
5|$|Developments in AspectJ have {{revealed}} {{the potential to}} incorporate just-in-time compilation into the execution of aspect-oriented code to address performance demands. At <b>run-time,</b> an aspect weaver could translate aspects in a more efficient manner than traditional, static weaving approaches. Using AspectJ on a Java Virtual Machine, dynamic weaving of aspects at <b>run-time</b> {{has been shown to}} improve code performance by 26%. While some implementations of just-in-time virtual machines implement this capability through a new virtual machine, some implementations can be designed to use features that already exist in current virtual machines. The requirement of a new virtual machine is contrary to one of the original design goals of AspectJ.|$|E
5|$|Perl has a Turing-complete grammar because parsing can be {{affected}} by <b>run-time</b> code executed during the compile phase. Therefore, Perl cannot be parsed by a straight Lex/Yacc lexer/parser combination. Instead, the interpreter implements its own lexer, which coordinates with a modified GNU bison parser to resolve ambiguities in the language.|$|E
40|$|This paper 1 {{describes}} {{our experience}} using the stack pro-cessing algorithm [6] for estimating {{the number of}} cache misses in scientic programs. By using a new data structure and various optimization techniques we obtain instrumented <b>run-times</b> within 50 to 100 times the original optimized <b>run-times</b> of our benchmarks...|$|R
2500|$|The {{individual}} original BBC2 episode <b>run-times</b> of the Bodyline mini-series were: ...|$|R
5000|$|Cross Language: {{works on}} and between {{different}} programming languages and <b>run-times.</b>|$|R
5|$|Aspect weavers' {{performance}}, {{as well as}} {{the performance}} of the code that they produce, has been a subject of analysis. It is preferable that the improvement in modularity supplied by aspect weaving does not impact <b>run-time</b> performance. Aspect weavers are able to perform aspect-specific optimizations. While traditional optimizations such as the elimination of unused special variables from aspect code can be done at compile-time, some optimizations can only be performed by the aspect weaver. For example, AspectJ contains two similar but distinct keywords, thisJoinPoint, which contains information about this particular instance of woven code, and thisJoinPointStaticPart, which contains information common to all instances of code relevant to that set of advice. The optimization of replacing thisJoinPoint with the more efficient and static keyword thisJoinPointStaticPart can only be done by the aspect weaver. By performing this replacement, the woven program avoids the creation of a join point object on every execution. Studies have shown that the unnecessary creation of join point objects in AspectJ can lead to a performance overhead of 5% at <b>run-time,</b> while performance degradation is only approximately 1% when this object is not created.|$|E
25|$|<b>Run-time</b> evaluation: JavaScript {{includes}} an eval function that can execute statements provided as strings at <b>run-time.</b>|$|E
25|$|C++ {{supports}} {{several kinds}} of static (resolved at compile-time) and dynamic (resolved at <b>run-time)</b> polymorphisms, supported by the language features described above. Compile-time polymorphism {{does not allow for}} certain <b>run-time</b> decisions, while runtime polymorphism typically incurs a performance penalty.|$|E
5000|$|The {{individual}} original BBC2 episode <b>run-times</b> of the Bodyline mini-series were: ...|$|R
2500|$|... Put in the cron time/date {{values and}} get back a list of future <b>run-times.</b>|$|R
5000|$|The TVD solver is {{designed}} to better represent rapid changes in the water surface profile, but results in longer <b>run-times.</b>|$|R
25|$|When {{originally}} {{shown on}} Channel 10 Australia in July 1984 over 4 consecutive nights - including extensive advert-breaks - the <b>run-time</b> was approx. 10 hours. Excluding advert breaks: the actual <b>run-time</b> is 7 hours 16 minutes. IMDb and Amazon give the total <b>run-time</b> {{of the official}} extensively cut, re-edited and picture-cropped - from the original 4:3 picture ratio to a 16:9 picture ratio - widescreen presentation DVD version as 330 minutes – 5 hours 30 minutes – 7 episodes of approx. 47 minutes each - a total of 329 minutes.|$|E
25|$|The Racket <b>run-time</b> system provies the 80-bit extflonum datatype on x86 systems.|$|E
25|$|In computing, rpath designates the <b>run-time</b> search path {{hard-coded}} in an {{executable file}} or library. Dynamic linking loaders use the rpath to find required libraries.|$|E
25|$|Modern {{operating}} systems extend {{the concepts of}} application preemption to device drivers and kernel code, so that the operating system has preemptive control over internal <b>run-times</b> as well.|$|R
30|$|Experimental {{evidence}} suggests that in this setting of randomized matrices such homogenization to one singular value represents the most reasonable choice; different Γ display similar behavior with overall longer <b>run-times.</b>|$|R
40|$|LazySorted is a Python C {{extension}} {{implementing a}} partially and lazily sorted list data structure. It solves {{a common problem}} faced by programmers, in which they need just part of a sorted list, like its middle element (the median), but sort the entire list to get it. LazySorted presents them with the abstraction that they are working with a fully sorted list, while actually only sorting the list partially with quicksort partitions to return the requested sub-elements. This enables programmers to use naive "sort first" algorithms but nonetheless attain linear <b>run-times</b> when possible. LazySorted {{may serve as a}} drop-in replacement for the built-in sorted function in most cases, and can sometimes achieve <b>run-times</b> more than 7 times faster...|$|R
25|$|For example, Pascal {{and many}} other {{imperative}} languages have long supported passing subprograms as arguments to other subprograms through the mechanism of function pointers. However, function pointers are not a sufficient condition for functions to be first class datatypes, because a function is a first class datatype {{if and only if}} new instances of the function can be created at <b>run-time.</b> And this <b>run-time</b> creation of functions is supported in Smalltalk, JavaScript, and more recently in Scala, Eiffel ("agents"), C# ("delegates") and C++11, among others.|$|E
25|$|A view in {{the default}} {{configuration}} of Rails is an erb file, which is evaluated and converted to HTML at <b>run-time.</b> Alternatively, many other templating systems {{can be used for}} views.|$|E
25|$|The Fibonacci {{numbers are}} {{important}} in the computational <b>run-time</b> analysis of Euclid's algorithm to determine the greatest common divisor of two integers: the worst case input for this algorithm {{is a pair of}} consecutive Fibonacci numbers.|$|E
30|$|Anemic {{female and}} male {{trainees}} had longer initial average run times, fewer push-ups and fewer sit-ups than non-anemic trainees (p[*]<[*] 0.001); that statistical difference persisted {{through the end of}} training especially for <b>run-times,</b> but less discrepancy was seen for push-up and sit-up values.|$|R
40|$|This paper {{describes}} {{our experience}} using the stack processing algorithm [6] for estimating {{the number of}} cache misses in scientific programs. By using a new data structure and various optimization techniques we obtain instrumented <b>run-times</b> within 50 to 100 times the original optimized runtimes of our benchmarks...|$|R
40|$|By {{harvesting}} {{energy from}} their local environment, sensor networks can achieve much greater <b>run-times,</b> years not months, with potentially lower cost and weight. At Australia's Commonwealth Scientific and Industrial Research Organisation (CSIRO), we are developing tools to help sensor network designers power sensor networks for prolonged periods of time...|$|R
25|$|In duck typing, a {{statement}} calling a method m on an object does {{not rely on}} the declared type of the object; only that the object, of whatever type, must supply an implementation of the method called, when called, at <b>run-time.</b>|$|E
25|$|JEP 282: jlink: The Java Linker: Create a {{tool that}} can {{assemble}} and optimize a set of modules and their dependencies into a custom <b>run-time</b> image. It effectively allows to produce a fully usable executable including the JVM to run it.|$|E
25|$|Dynamic typing {{typically}} makes metaprogramming {{easier to}} use. For example, C++ templates are typically more cumbersome to write than the equivalent Ruby or Python code since C++ has stronger rules regarding type definitions (for both functions and variables). This forces a developer to write more boilerplate code for a template than a Python developer would need to. More advanced <b>run-time</b> constructs such as metaclasses and introspection are often harder {{to use in}} statically typed languages. In some languages, such features may also be used e.g. to generate new types and behaviors on the fly, based on <b>run-time</b> data. Such advanced constructs are often provided by dynamic programming languages; {{many of these are}} dynamically typed, although dynamic typing need not be related to dynamic programming languages.|$|E
40|$|In {{this second}} {{portion of a}} two-part {{analysis}} of a scalable computa- tional approach to stochastic unit commitment, we focus on solving stochastic mixed-integer programs in tractable <b>run-times.</b> Our solution technique is based on Rockafellar and Wets 2 ̆ 7 progressive hedging algorithm, a scenario-based decomposi- tion strategy for solving stochastic programs. To achieve high-quality solutions in tractable <b>run-times,</b> we describe critical, novel customizations of the progressive hedging algorithm for stochastic unit commitment. Using {{a variant of the}} WECC- 240 test case with 85 thermal generation units, we demonstrate the ability of our approach to solve realistic, moderate-scale stochastic unit commitment problems with reasonable numbers of scenarios in no more than 15 minutes of wall clock time on commodity compute platforms. Further, we demonstrate that the result- ing solutions are high-quality, with costs typically within 1 - 2. 5...|$|R
40|$|A {{method is}} given for {{choosing}} the relative counting times, for the sample-in- container and empty container {{parts of a}} fixed-duration scattering experiment, in order to minimise the statistical error on the container-corrected intensity. The method is applied to angular-dispersive diffraction experiments, and {{the effect on the}} fractional error of misestimating the relative <b>run-times</b> is considered...|$|R
40|$|International audienceWe {{study the}} multidimensional {{knapsack}} problem, present some {{theoretical and empirical}} results about its structure, and evaluate different Integer Linear Programming (ILP) based, metaheuristic, and collaborative approaches for it. We start by considering the distances between optimal solutions to the LP-relaxation and the original problem and then introduce a new core concept for the MKP, which we study extensively. The empirical analysis is then used to develop new concepts for solving the MKP using ILP-based and memetic algorithms. Different collaborative combinations of the presented methods are discussed and evaluated. Further computational experiments with longer <b>run-times</b> are also performed in order to compare the solutions of our approaches to the best known solutions of another so far leading approach for common MKP benchmark instances. The extensive computational experiments show {{the effectiveness of the}} proposed methods, which yield highly competitive results in significantly shorter <b>run-times</b> than previously described approaches...|$|R
25|$|A {{stand-alone}} executable of {{compact size}} is required that must execute without recourse to the <b>run-time</b> components or libraries {{associated with a}} high-level language; {{this is perhaps the}} most common situation. For example, firmware for telephones, automobile fuel and ignition systems, air-conditioning control systems, security systems, and sensors.|$|E
25|$|Most {{operating}} systems that support dynamically linked libraries also support dynamically loading such libraries via a <b>run-time</b> linker API. For instance, Microsoft Windows uses the API functions LoadLibrary, LoadLibraryEx, FreeLibrary and GetProcAddress with Microsoft Dynamic Link Libraries; POSIX based systems, including most UNIX and UNIX-like systems, use dlopen, dlclose and dlsym. Some development systems automate this process.|$|E
25|$|Variable {{pointers}} {{and references}} to a base class type in C++ can also refer to objects of any derived classes of that type. This allows arrays {{and other kinds}} of containers to hold pointers to objects of differing types (references cannot be directly held in containers). This enables dynamic (<b>run-time)</b> polymorphism, where the referred objects can behave differently depending on their (actual, derived) types.|$|E
40|$|MethylAid is {{specially}} designed for quality control of large sets of DNA methylation data e. g., epigenomewide association studies (EWAS). Extracting intensities from IDAT files {{can be done}} in batches and/or in parallel to reduce memory load and/or overcome long <b>run-times.</b> It requires two function calls in go-ing from IDAT files to launch the interactive web application; summarize and visualize. For mor...|$|R
40|$|Optimal {{aircraft}} ground scheduling is a {{well known}} NP-Hard problem and hence many heuristics are used to generate schedules within realistic <b>run-times.</b> These heuristics are designed to run fast, but often do not promise any guarantee about the solution quality. Inspired from the railway scheduling algorithms by D’Ariano et al. [1] and Mannino et al. [2], this paper introduces a Branch & Bound based aircraft routing and scheduling approach with guaranteed global optimality; as a real-time decision support tool for Air Traffic Controllers. The performance of the algorithm has been benchmarked against various others such as the Mixed Integer Linear Programming (MILP) approach by Roling et al. [3], Bacterial Foraging heuristic by Baijal et al. [4]. The configuration agnostic design of the algorithm makes it suitable for applications to unconventional airport designs, such as the cross-runway map of the Mumbai International Airport. The globally optimal nature of the solution exhibits a distinct improvement over the respective solutions while maintaining minimal <b>run-times.</b> I...|$|R
40|$|Asymmetric {{cryptography}} {{is required}} to start encrypted communications. Most protocols are based on modular operations over integer's rings. Many are vulnerable to sub-exponential attacks or by using a quantum computer. Cryptography based on non-commutative algebra is a growing trend arising as a solid choice that strengthens these protocols. In particular, Hecht (2009) has presented a key exchange model based on the Diffie-Hellman protocol using matrices of order four with elements in Z 256, that provides 128 -bits keys also to devices with low computing power. Quaternions are four-component's vectors. These also form non-commutative rings structures, with compact notation and lower <b>run-times</b> in many comparable operations. Kamlofsky et al (2015) presented a model using quaternions with elements in Z 256. To provide a 128 -bit key is required 4 rounds of 32 -bits. However, a gain of 42 % was obtained. This paper presents an improvement of this cipher that reduces even more the <b>run-times.</b> V Workshop de Seguridad Informática...|$|R
