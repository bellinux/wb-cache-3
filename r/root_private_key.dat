3|3274|Public
40|$|We {{introduce}} {{the concept of}} hierarchical identity-based encryption (HIBE) schemes, give precise de nitions of their security and mention some applications. A two-level HIBE (2 -HIBE) scheme consists of a <b>root</b> <b>private</b> <b>key</b> generator (PKG), domain PKGs and users, {{all of which are}} associated with primitive IDs (PIDs) that are arbitrary strings...|$|E
40|$|Hierarchical Identity-Based Encryption (HIBE) is a {{generalization}} of identity-based encryption that mirrors an organizational hierarchy, {{and allows the}} <b>root</b> <b>Private</b> <b>Key</b> Generator (PKG) to distribute the workload of key generations to lower-level PKGs. In Indocrypt 2 ̆ 708, Ren and Gu proposed a new HIBE scheme, and claimed that their scheme is fully chosen-ciphertext secure in the standard model. However, by giving a concrete attack, we show that Ren-Gu 2 ̆ 7 s HIBE is even not chosen-plaintext secure...|$|E
40|$|Abstract. We {{introduce}} {{the concept of}} hierarchical identity-based encryption (HIBE) schemes, give precise definitions of their security and mention some applications. A two-level HIBE (2 -HIBE) scheme consists of a <b>root</b> <b>private</b> <b>key</b> generator (PKG), domain PKGs and users, {{all of which are}} associated with primitive IDs (PIDs) that are arbitrary strings. A user’s public key consists of their PID and their domain’s PID (in whole called an address). In a regular IBE (which corresponds to a 1 -HIBE) scheme, there is only one PKG that distributes private keys to each user (whose public keys are their PID). In a 2 -HIBE, users retrieve their private key from their domain PKG. Domain PKGs can compute the private key of any user in their domain, provided they have previously requested their domain secret key from the root PKG (who possesses a master secret). We can go beyond two levels by adding subdomains, subsubdomains, and so on. We present a two-level system with total collusion resistance at the upper (domain) level and partial collusion resistance at the lower (user) level, which has chosen-ciphertext security in the random-oracle model. ...|$|E
50|$|The SSL/TLS chain-of-trust {{relies on}} trusted root {{certificate}} authorities. In a workplace setting where {{the client is}} managed by the organization, trust might be granted to a <b>root</b> certificate whose <b>private</b> <b>key</b> is known to the proxy. Consequently, a root certificate generated by the proxy is installed into the browser CA list by IT staff.|$|R
5000|$|In public-key {{cryptography}} and computer security, a root key ceremony is a procedure where a unique pair {{of public and}} <b>private</b> <b>root</b> <b>keys</b> is generated. Depending on the certificate policy, the generation of the root keys may require notarization, legal representation, witnesses and [...] "key holders" [...] to be present, as {{the information on the}} system is a responsibility of the parties. A commonly recognized best practice is to follow the SAS 70 standard for root key ceremonies.|$|R
30|$|Asymmetric {{cryptography}} {{is used in}} this model. Two different keys, {{a secret}} key d and a public key e are defined. The public key e is used for encryption i.e. for converting adjacency matrix of S to adjacency matrix of L^k(S) which is balanced for some ‘k’. Since we have a unique method for encryption, therefore, it can be published. Further, the secret <b>private</b> <b>key</b> d is used for decryption of adjacency matrix of L^k(S) to adjacency matrix of S. Since we have many line root sigraphs of a given sigraph {{and we have to}} restrict our networks to obtain a unique line <b>root</b> sigraph, therefore, <b>private</b> <b>key</b> is used. Also, if labelling of vertices can be done by Lehot (1974), then only we obtain unique line root sigraph. The following model is used as an application to above algorithms.|$|R
50|$|Note: It {{should be}} {{difficult}} for Alice to solve for Bobs <b>private</b> <b>key</b> or for Bob to solve for Alices <b>private</b> <b>key.</b> If {{it is not difficult}} for Alice to solve for Bobs <b>private</b> <b>key</b> (or vice versa), Eve may simply substitute her own <b>private</b> / public <b>key</b> pair, plug Bobs public <b>key</b> into her <b>private</b> <b>key,</b> produce a fake shared secret key, and solve for Bobs <b>private</b> <b>key</b> (and use that to solve for the shared secret key. Eve may attempt to choose a public / <b>private</b> <b>key</b> pair that will make it easy for her to solve for Bobs <b>private</b> <b>key).</b>|$|R
30|$|<b>Private</b> <b>Key</b> {{generation}} On input {{the system}} public key PK, the master key MK, and an attribute set {A_i}, <b>private</b> <b>key</b> generator (PKG) outputs D_i as the user’s attribute <b>private</b> <b>key.</b> To distinguish {{the role of}} signers and receivers, in this paper, we define the <b>private</b> <b>key</b> of signer as D_s while the <b>private</b> <b>key</b> of receiver as D_r.|$|R
5000|$|... 2D Key (2-Dimensional Key) is a 2D matrix-like key {{input method}} having the key styles of {{multiline}} passphrase, crossword, ASCII/Unicode art, with optional textual semantic noises, to create big password/key beyond 128 bits {{to realize the}} MePKC (Memorizable Public-Key Cryptography) using fully memorizable <b>private</b> <b>key</b> upon the current <b>private</b> <b>key</b> management technologies like encrypted <b>private</b> <b>key,</b> split <b>private</b> <b>key,</b> and roaming <b>private</b> <b>key.</b>|$|R
30|$|Many {{studies on}} {{protection}} of the <b>private</b> <b>key</b> from unauthorized access have been conducted or are under way. When a certificate and a <b>private</b> <b>key</b> are stored, the secure key store system encrypts the <b>private</b> <b>key</b> using the encryption key dependent on the device and saves it securely [25]. Even {{in the event that}} a <b>private</b> <b>key</b> is leaked, the leaked <b>private</b> <b>key</b> cannot be utilized on other devices. There is also a study on the use of a graphical password to enhance password security when protecting the <b>private</b> <b>key</b> derived from the password [26]. There is another proposed scheme in which mobile agents can create non-detachable digital signatures with the forward security of the original signer’s <b>private</b> <b>key</b> [27]. It is not necessary for mobile agents to transport the <b>private</b> <b>key</b> in order to create digital signatures, and the <b>private</b> <b>key</b> will not be compromised.|$|R
5000|$|A key {{generation}} algorithm that selects a <b>private</b> <b>key</b> uniformly at random from {{a set of}} possible <b>private</b> <b>keys.</b> The algorithm outputs the <b>private</b> <b>key</b> and a corresponding public key.|$|R
5000|$|All public <b>key</b> / <b>private</b> <b>key</b> cryptosystems depend {{entirely on}} keeping the <b>private</b> <b>key</b> secret. A <b>private</b> <b>key</b> {{can be stored}} on a user's computer, and {{protected}} by a local password, but this has two disadvantages: ...|$|R
3000|$|... (5) {{by using}} the <b>private</b> <b>key</b> that is saved in the secure zone securely, concatenates the data, {{attaches}} the CertM as the certificate of the TMZ system, and transmits the message M 2 to the authentication server (6). It {{is the most important}} to keep the user’s <b>private</b> <b>key</b> securely. If the user fails to maintain the <b>private</b> <b>key</b> securely, it may result in an attacker masquerading as the user {{by using the}} user’s <b>private</b> <b>key</b> to sign the authentication token. The <b>private</b> <b>key</b> is safe because it is encrypted and stored in the secure zone, the integrity of the <b>private</b> <b>key</b> is checked after decrypting, and the SignM(R [...]...|$|R
50|$|Identity-based systems {{allow any}} party to {{generate}} a public key from a known identity value such as an ASCII string. A trusted third party, called the <b>Private</b> <b>Key</b> Generator (PKG), generates the corresponding <b>private</b> <b>keys.</b> To operate, the PKG first publishes a master public key, and retains the corresponding master <b>private</b> <b>key</b> (referred to as master key). Given the master public key, any party can compute a public key corresponding to the identity by combining the master public key with the identity value. To obtain a corresponding <b>private</b> <b>key,</b> the party authorized to use the identity ID contacts the PKG, which uses the master <b>private</b> <b>key</b> to generate the <b>private</b> <b>key</b> for identity ID.|$|R
3000|$|... {{before making}} Initial <b>private</b> <b>key</b> {{generation}} query, Temporal <b>private</b> <b>key</b> generation query and Decrypt query to Simulator.|$|R
30|$|If the <b>private</b> <b>key</b> {{is managed}} {{in the normal}} zone where {{numerous}} threats exist, the possibility of leakage of the <b>private</b> <b>key</b> is very high because the <b>private</b> <b>key</b> file can be copied easily. As such, the trusted platform of the TMZ system provides a separate structure that increases {{the strength of the}} security. The <b>private</b> <b>key</b> is stored in the secure zone isolated from the normal zone after encrypting it through the white-box cryptography table stored in the secure zone, and the signature data are also created in the secure zone using the <b>private</b> <b>key</b> that was decrypted through the white-box cryptography table. The <b>private</b> <b>key</b> is safe because the encryption key exists with the algorithm of the white-box cryptography table in the secure zone, and the <b>private</b> <b>key</b> is stored after encrypting it through the white-box cryptography table in the secure zone.|$|R
30|$|Second, only {{legitimate}} {{group member}} owns <b>private</b> <b>key</b> issued by GM to generate legitimate group signature. Adversary cannot compute legitimate group signature {{if he does}} not know group member’s <b>private</b> <b>key.</b> As a result, group signature is unforgeable on the basis of <b>private</b> <b>key’s</b> security.|$|R
3000|$|During {{the process}} of the {{challenge}} game, the responses of Initial <b>Private</b> <b>key</b> generation query, Temporal <b>private</b> <b>key</b> [...]...|$|R
3000|$|... (2) There {{exists a}} {{potential}} danger {{that only one}} fixed <b>private</b> <b>key</b> is utilized to generate the verification tags of all the version files. As it is discussed in attack model, a group of users in a project development team share a <b>private</b> <b>key.</b> In this case, any sloppy user can reveal the <b>private</b> <b>key</b> so that the attacker can obtain the <b>private</b> <b>key</b> and forge the verification proofs to deceive the TPV.|$|R
5000|$|It {{allows the}} {{possibility}} of keeping the CA <b>private</b> <b>key,</b> or other <b>private</b> <b>keys,</b> in external files or devices (as USB drives) ...|$|R
5000|$|... {{after the}} <b>private</b> <b>key</b> is {{distributed}} to the user, the <b>private</b> <b>key</b> is not regenerated by the TC for other purposes (spying).|$|R
3000|$|<b>Private</b> <b>key</b> {{generation}} For signer’s attribute set {A_j}, PKG chooses u ∈ Z_p^* and calculates its <b>private</b> <b>key</b> {D_s, 1,D_s, 2,D_s, 3 } = {g^u + α_j H_ 1 ([...] j [...]),g^α + u,ê([...] g,g)^u}. Likewisely, for receiver’s attribute set {A_i} PKG chooses h ∈ Z_p^* calculates its <b>private</b> <b>key</b> {D_r, 1,D_r, 2,D_r, 3 } = {g^α_i H_ 1 ([...] i [...]) + h,g^α + h,ê([...] g,g)^h}. PKG transfers the <b>private</b> <b>key</b> to each user through secure channels.|$|R
40|$|In most forward-secure {{signature}} constructions, {{a program}} that updates a user's <b>private</b> signing <b>key</b> must have full access to the <b>private</b> <b>key.</b> Unfortunately, these schemes are incompatible with several security architectures including Gnu Privacy Guard (GPG) and S/MIME, where the <b>private</b> <b>key</b> is encrypted under a user password as a "second factor" of security, in case the <b>private</b> <b>key</b> storage is corrupted, but the password is not...|$|R
30|$|Challenger {{can obtain}} user’s initial <b>private</b> <b>key</b> D_γ,TP_ 0 by running Initial <b>private</b> <b>key</b> {{generation}} algorithm and returns the result back to Adversary.|$|R
5000|$|<b>Private</b> <b>key</b> {{transport}} key: <b>Private</b> <b>key</b> transport <b>keys</b> are the <b>private</b> <b>keys</b> of {{asymmetric key}} pairs {{that are used}} to decrypt keys that have been encrypted with the associated public key using a public key algorithm. Key transport keys are usually used to establish keys (e.g., key wrapping keys, data encryption keys or MAC keys) and, optionally, other keying material (e.g., initialization vectors).|$|R
30|$|Our {{future work}} {{should focus on}} the {{attribute}} revocation and key refreshing in the attribute based encryption. Since users with the same set of attributes share the same <b>private</b> <b>key,</b> once a single user’s <b>private</b> <b>key</b> has been leaked, a group of users’ privacy and privilege will be damaged. Consequently, protecting users’ privacy and refreshing <b>private</b> <b>keys</b> at a lower cost when <b>private</b> <b>key</b> leakage happens is a problem urgently to be solved and should be taken into our future research direction.|$|R
50|$|A {{variation}} of the public key cryptography system is a Web of trust, where each user has both a public and <b>private</b> <b>key.</b> Messages sent are encrypted using the intended recipients public key, and only this recipients <b>private</b> <b>key</b> will decrypt the message. They are also signed with the senders <b>private</b> <b>key.</b> This creates added security where it becomes more difficult for an attacker {{to pretend to be}} a user, as the lack of a <b>private</b> <b>key</b> signature indicates a non-trusted user.|$|R
3000|$|P) to user. T {{presents}} {{the life cycle}} of the <b>private</b> <b>key.</b> User needs to update the <b>private</b> <b>key</b> if T is expired. (S [...]...|$|R
40|$|AbstractIn the {{traditional}} identity-based cryptography, when a user holds multiple identities as its public keys, {{it has to}} manage {{an equal number of}} <b>private</b> <b>keys.</b> The recent advances of identity-based cryptography allow a single <b>private</b> <b>key</b> to map multiple public keys (identities) that are selectable by the user. This approach simplifies the <b>private</b> <b>key</b> management. Unfortunately, the existing schemes have a heavy computation overhead, since the <b>private</b> <b>key</b> generator has to authenticate all identities in order to generate a resultant <b>private</b> <b>key.</b> In particular, it has been considered as a drawback that the data size for a user is proportional to the number of associated identities. Moreover, these schemes do not allow dynamic changes of user identities. When a user upgrades its identities, the <b>private</b> <b>key</b> generator (PKG) has to authenticate the identities and generate a new <b>private</b> <b>key.</b> To overcome these problems, in this paper we present an efficient dynamic identity-based key exchange protocol with selectable identities, and prove its security under the bilinear Diffie–Hellman assumption in the random oracle model...|$|R
40|$|In the {{traditional}} identity-based cryptography, when a user holds multiple identities as its public keys, {{it has to}} manage {{an equal number of}} <b>private</b> <b>keys.</b> The recent advances of identity-based cryptography allow a single <b>private</b> <b>key</b> to map multiple public keys (identities) that are selectable by the user. This approach simplifies the <b>private</b> <b>key</b> management. Unfortunately, the existing schemes have a heavy computation overhead, since the <b>private</b> <b>key</b> generator has to authenticate all identities in order to generate a resultant <b>private</b> <b>key.</b> In particular, it has been considered as a drawback that the data size for a user is proportional to the number of associated identities. Moreover, these schemes do not allow dynamic changes of user identities. When a user upgrades its identities, the <b>private</b> <b>key</b> generator (PKG) has to authenticate the identities and generate a new <b>private</b> <b>key.</b> To overcome these problems, in this paper we present an efficient dynamic identity-based key exchange protocol with selectable identities, and prove its security under the bilinear DiffieHellman assumption in the random oracle model. © 2011 Elsevier Ltd. All rights reserved...|$|R
50|$|The Skype server has a <b>private</b> <b>key,</b> and {{distributes}} that key's public counterpart {{with every}} {{copy of the}} software. As part of user registration, the user selects a desired username and password. Skype locally generates public and <b>private</b> <b>keys.</b> The <b>private</b> <b>key</b> and a hash of the password are stored on the user's computer.|$|R
3000|$|Temporal <b>private</b> <b>key</b> {{generation}} query: Simulator {{maintains a}} list L_t{A_i,γ,TP_n,TD_γ,TP_n}. When Adversary asks a Temporal <b>private</b> <b>key</b> generation query for γ, Simulator responds as follows: [...]...|$|R
5000|$|The <b>private</b> <b>key</b> {{must remain}} private: If the <b>private</b> <b>key</b> becomes known {{to any other}} party, that party can produce perfect digital {{signatures}} of anything whatsoever.|$|R
40|$|We {{show that}} for low public {{exponent}} RSA, given {{a quarter of}} the bits of the <b>private</b> <b>key</b> an adversary can recover the entire <b>private</b> <b>key.</b> Similar results (though not as strong) are obtained for larger values of e. For instance, when e is a prime in the range [N^(1 / 4), N^(1 / 2) ], half the bits of the <b>private</b> <b>key</b> suffice to reconstruct the entire <b>private</b> <b>key.</b> Our results point out the danger of partial key exposure in the rsa public key system...|$|R
30|$|First, only TR can {{generate}} DM’s warrant. Adversary cannot compute legitimate warrant {{if he does}} not know TR’s <b>private</b> <b>key.</b> Only DM who obtain warrant form TR can compute WMN group’s warrant. Adversary cannot compute legitimate warrant {{if he does not}} know DM’s <b>private</b> <b>key.</b> Hence, warrant is unforgeable on the basis of <b>private</b> <b>key’s</b> security.|$|R
5000|$|<b>Private</b> <b>key</b> {{security}} - An attacker cannot {{learn the}} user's static <b>private</b> <b>key</b> {{even if he}} is able to learn all session specific secrets in any compromised session.|$|R
