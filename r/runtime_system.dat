1878|852|Public
5|$|PHP 5 {{introduced}} {{private and}} protected member variables and methods, along with abstract classes, final classes, abstract methods, and final methods. It also introduced a standard way of declaring constructors and destructors, {{similar to that}} of other object-oriented languages such as C++, and a standard exception handling model. Furthermore, PHP 5 added interfaces and allowed for multiple interfaces to be implemented. There are special interfaces that allow objects to interact with the <b>runtime</b> <b>system.</b> Objects implementing ArrayAccess can be used with array syntax and objects implementing Iterator or IteratorAggregate can be used with the foreach language construct. There is no virtual table feature in the engine, so static variables are bound with a name instead of a reference at compile time.|$|E
5|$|To {{reduce the}} storage {{footprint}} {{of the operating}} system, Windows 10 automatically compresses system files. The system can reduce the storage footprint of Windows by approximately 1.5GB for 32-bit systems and 2.6GB for 64-bit systems. The level of compression used is dependent on a performance assessment performed during installations or by OEMs, which tests how much compression can be used without harming operating system performance. Furthermore, the Refresh and Reset functions use <b>runtime</b> <b>system</b> files instead, making a separate recovery partition redundant, allowing patches and updates to remain installed following the operation, and further {{reducing the amount of}} space required for Windows 10 by up to 12GB. These functions replace the WIMBoot mode introduced on Windows 8.1 Update, which allowed OEMs to configure low-capacity devices with flash-based storage to use Windows system files out of the compressed WIM image typically used for installation and recovery. Windows 10 also includes a function in its Settings app that allows users to view a breakdown of how their device's storage capacity is being used by different types of files, and determine whether certain types of files are saved to internal storage or an SD card by default.|$|E
25|$|In 2006, native {{symmetric}} multiprocessing support {{was added to}} the <b>runtime</b> <b>system</b> and virtual machine.|$|E
30|$|Associated to the {{programming}} model issues, {{a set of}} challenges concern the design of <b>runtime</b> <b>systems</b> that in exascale computing systems must be tightly integrated with {{the programming}} tools level. The main challenges for <b>runtime</b> <b>systems</b> obviously include parallelism exploitation, limited data communication, data dependence management, data-aware task scheduling, processor heterogeneity, and energy efficiency. However, together with those main issues, other aspects are addressed in <b>runtime</b> <b>systems</b> like storage/memory hierarchies, storage and processor heterogeneity, performance adaptability, resource allocation, performance analysis, and performance portability. In addressing those issues the currently used approaches aim at providing simplified abstractions and machine models that allow algorithm developers and application programmers to generate code that can run and scale {{on a wide range}} of exascale computing systems.|$|R
50|$|<b>Runtime</b> <b>systems</b> {{refers to}} the {{development}} of programming language runtime environments and their components, including virtual machines, garbage collection, and foreign function interfaces.|$|R
5000|$|Parallel and {{distributed}} software, including parallel programming languages and compilers, <b>runtime</b> <b>systems,</b> operating systems, resource management, middleware, libraries, data mining, and programming environments and tools.|$|R
25|$|The term Erlang is used interchangeably with Erlang/OTP, or OTP, which {{consists}} of the Erlang <b>runtime</b> <b>system,</b> a number of ready-to-use components mainly written in Erlang, {{and a set of}} design principles for Erlang programs.|$|E
2500|$|... {{undefined}} - a standards reports procedure {{raising an}} exception in the <b>runtime</b> <b>system.</b>|$|E
2500|$|Erlang ( [...] ) is a general-purpose, concurrent, {{functional}} programming language, {{as well as}} a garbage-collected <b>runtime</b> <b>system.</b>|$|E
50|$|In computing, the KOMPILER {{was one of}} {{the first}} {{language}} compilation and <b>runtime</b> <b>systems</b> for International Business Machines' IBM 701, the fastest commercial U.S. computer available in 1955.|$|R
40|$|This paper {{describes}} {{the development of}} fast (less than 10 times real-time) large vocabulary continuous speech recognition (LVCSR) systems based on technology developed for unlimited <b>runtime</b> <b>systems</b> assembled for participation in recent DARPA/NIST LVCSR evaluations. A general system structure for 10 times real-time systems is proposed and two specific systems that have been built for Broadcast News (BN) and Conversational Telephone Speech (CTS) recognition are described. The systems were evaluated in the DARPA/NIST April 2003 Rich Transcription evaluation. Results are reported and contrasted with unlimited <b>runtime</b> <b>systems</b> and previous fast systems...|$|R
40|$|International audienceTo {{face the}} advent of {{multicore}} processors and the ever increasing complexity of hardware architectures, programming models based on DAG parallelism regained popularity in the high performance, scientific computing community. Modern <b>runtime</b> <b>systems</b> offer a programming interface that complies with this paradigm and powerful engines for scheduling the tasks into which the application is decomposed. These tools have already proved their effectiveness {{on a number of}} dense linear algebra applications. This paper evaluates the usability of <b>runtime</b> <b>systems</b> for complex applications, namely, sparse matrix multifrontal factorizations which constitute extremely irregular workloads, with tasks of different granularities and characteristics and with a variable memory consumption. Experimental results on real-life matrices show {{that it is possible to}} achieve the same efficiency as with an ad hoc scheduler which relies on the knowledge of the algorithm. A detailed analysis shows the performance behavior of the resulting code and possible ways of improving the effectiveness of <b>runtime</b> <b>systems...</b>|$|R
2500|$|The Erlang <b>runtime</b> <b>system</b> {{is known}} for its designs that are well suited for systems with the {{following}} characteristics: ...|$|E
2500|$|The {{representation}} of NaNs {{specified by the}} standard has some unspecified bits {{that could be used}} to encode the type or source of error; but there is no standard for that encoding. [...] In theory, signaling NaNs could be used by a <b>runtime</b> <b>system</b> to flag uninitialized variables, or extend the floating-point numbers with other special values without slowing down the computations with ordinary values, although such extensions are not common.|$|E
2500|$|The second scheme, {{and the one}} {{implemented}} in many production-quality C++ compilers, is a table-driven approach. This creates static tables at compile time and link time that relate ranges of the program counter to the program state with respect to exception handling. [...] Then, if an exception is thrown, the <b>runtime</b> <b>system</b> looks up the current instruction location in the tables and determines what handlers are in play and {{what needs to be}} done. This approach minimizes executive overhead for the case where an exception is not thrown. This happens at the cost of some space, but this space can be allocated into read-only, special-purpose data sections that are not loaded or relocated until an exception is actually thrown. [...] This second approach is also superior in terms of achieving thread safety.|$|E
40|$|Although platform-independent <b>runtime</b> <b>systems</b> for {{parallel}} programming languages are desirable, {{the need for}} low-level optimizations usually precludes their existence. This is because most optimizations involve some combination of low-level communication and low-level threading, the product of which is almost always platform-dependent. We propose {{a solution to the}} threading half of this dilemma by using a thread package, that allows fine-grain control over the behavior of the threads while still providing performance comparable to hand-tuned, machine-dependent thread packages. This makes it possible to construct platform-independent thread modules for parallel <b>runtime</b> <b>systems</b> and, more importantly, to optimize them. ...|$|R
40|$|I am broadly {{interested}} {{in the area of}} parallel systems, including, multicore architectures, parallel program-ming models and <b>runtime</b> <b>systems,</b> operating systems and the interactions of hardware (micro-) architecture with systems. My Ph. D. thesis addresses the challenges in efficiently executing parallel programs that arise from the growing (static and dynamic) system diversity and heterogeneity...|$|R
40|$|We present GC-as-a-Service (GaS), a cross-runtime, crosslanguage garbage {{collection}} (GC) library {{that can be}} used to simplify the implementation of <b>runtime</b> <b>systems,</b> and that exploits available multicore technologies. GaS decouples GC from other runtime components and exposes a fine-grain API for use by GC-cooperative runtimes of different programming languages for heap memory management. GaS provides concurrent, on-the-fly GC and avoids moving objects for use as a precise or conservative collector. We integrate GaS within production-quality <b>runtime</b> <b>systems</b> for Python and Java. Our experimental evaluation shows that using GaS as an alternative to tightly integrated GC introduces modest overhead and that GaS reduces pause times significantly for Python and Java programs...|$|R
2500|$|The {{implementation}} of exception handling in programming languages typically involves {{a fair amount}} of support from both a code generator and the <b>runtime</b> <b>system</b> accompanying a compiler. (It was the addition of exception handling to C++ that ended the useful lifetime of the original C++ compiler, Cfront.) [...] Two schemes are most common. The first, dynamic registration, generates code that continually updates structures about the program state in terms of exception handling. [...] Typically, this adds a new element to the stack frame layout that knows what handlers are available for the function or method associated with that frame; if an exception is thrown, a pointer in the layout directs the runtime to the appropriate handler code. This approach is compact in terms of space, but adds execution overhead on frame entry and exit. It was commonly used in many Ada implementations, for example, where complex generation and runtime support was already needed for many other language features. Dynamic registration, being fairly straightforward to define, is amenable to proof of correctness.|$|E
5000|$|Every {{programming}} language specifies an execution model, and many implement {{at least part}} of that model in a <b>runtime</b> <b>system.</b> One, debatable, way to define a <b>runtime</b> <b>system</b> is that any behavior that is not directly the work of a program is <b>runtime</b> <b>system</b> behavior. This definition includes as part of the <b>runtime</b> <b>system</b> things such as putting parameters onto the stack before a function call, the behavior of disk [...] I/O, and parallel execution related behaviors.|$|E
50|$|Higher-level {{behaviors}} {{implemented by}} a <b>runtime</b> <b>system</b> may include {{tasks such as}} drawing text on the screen or making an Internet connection. It {{is often the case}} that operating systems provide these kinds of behaviors as well, and when available, the <b>runtime</b> <b>system</b> is implemented as an abstraction layer that translates the invocation of the <b>runtime</b> <b>system</b> into an invocation of the operating system. This hides the complexity or variations in the services offered by different operating systems. This also implies that the OS kernel can itself be viewed as a <b>runtime</b> <b>system,</b> and that the set of OS calls that invoke OS behaviors may be viewed as interactions with a <b>runtime</b> <b>system.</b>|$|E
50|$|Kathryn S. McKinley is an American {{computer}} scientist noted for her research on compilers, <b>runtime</b> <b>systems,</b> and computer architecture. She {{is also known}} for her leadership in broadening participation in computing. McKinely was co-chair of CRA-W from 2011 to 2014.|$|R
40|$|Theory, design, and {{implementation}} of programming systems, including languages, pro-gram logics, static and dynamic program analyses, <b>runtime</b> <b>systems,</b> and mechanized verifiers. My research focuses on programming systems that deliver greater performance and resilience by changing the underlying semantics {{of the program in}} ways that are still sound and principled...|$|R
40|$|This Annex {{provides}} {{detailed information}} on work carried out on <b>runtime</b> <b>systems</b> during the first 18 months of the TENCompetence projectThe work on this publication has been sponsored by the TENCompetence Integrated Project that is funded by the European Commission's 6 th Framework Programme, priority IST/Technology Enhanced Learning. Contract 027087 [[URL]...|$|R
50|$|Eclipse uses {{plug-ins}} {{to provide}} all the functionality within {{and on top of}} the <b>runtime</b> <b>system.</b> Its <b>runtime</b> <b>system</b> is based on Equinox, an implementation of the OSGi core framework specification.|$|E
50|$|After {{implementing}} the CODESYS Control <b>Runtime</b> <b>System,</b> intelligent devices can be programmed with CODESYS. A charged-for toolkit provides this <b>runtime</b> <b>system</b> {{as a source}} and object code. It can be ported to different platforms.|$|E
5000|$|ManKai Common Lisp (MKCL) : A {{branch of}} ECL. MKCL emphasises reliability, {{stability}} and overall code quality through a heavily reworked, natively multi-threaded, <b>runtime</b> <b>system.</b> On Linux, MKCL features a fully POSIX compliant <b>runtime</b> <b>system.</b>|$|E
40|$|AbstractThis paper {{describes}} {{the design of}} the <b>runtime</b> <b>systems</b> of two variants of the SAC- 2 computer algebra library: SACLIB and PACLIB. SACLIB is a C version of SAC- 2, supporting automatic garbage collection and embeddability. PACLIB is a parallel version of SACLIB, supporting light-weight concurrency, non-determinism, virtual tasks, and parallel garbage collection...|$|R
40|$|RESEARCH INTERESTS My {{research}} broadly {{falls into}} the general areas of parallel and distributed computing. Specifically, I focus on the following areas: (i) parallel programming models and <b>runtime</b> <b>systems</b> (MPI, global address space models, task parallel models); (ii) parallel computing architectures (Blue Gene, Cray, multi-core systems, GPUs, Intel MIC, and other accelerators), (iii) high...|$|R
40|$|Abstract — Performance {{gain for}} {{computer}} systems through Moore’s Law is jeopardized by {{the limitations of}} clock rate growth due to power considerations and the limitations in instruction-level parallelism improvement from processor core computer architecture experienced over the last decade. High performance computer architectures are addressing this challenge through multicore processors that combine many processing units on a single chip. For this class of machines, conventional programming and execution practices, while still effective for some application algorithms, are suffering in scalability for many others. Multithreaded <b>runtime</b> <b>systems</b> offer convenient many-tasking execution model implementations that show increased efficiency and scalability through exploiting medium-grained thread parallelism. This paper {{provides an overview of}} the existing <b>runtime</b> <b>systems</b> and libraries used for many-tasking computation. They are empirically examined in terms of overheads and the potential impact resulting on application performance. Intra-node performance aspects are investigated using synthetic benchmarks...|$|R
50|$|By this definition, {{essentially}} every {{language has}} a <b>runtime</b> <b>system,</b> including compiled languages, interpreted languages, and embedded domain-specific languages. Even API invoked stand alone execution models such as Pthreads have a <b>runtime</b> <b>system</b> {{that is the}} implementation of execution model's behavior.|$|E
50|$|A <b>runtime</b> <b>system,</b> {{also called}} {{run-time}} system, primarily implements portions of an execution model. This {{is in contrast}} to the runtime lifecycle phase of a program, during which the <b>runtime</b> <b>system</b> is in operation. Most languages have some form of <b>runtime</b> <b>system,</b> which implements control over the order in which work that was specified in terms of the language gets performed. Over the years, the meaning of the term 'runtime system' has been expanded to include nearly any behaviors that are dynamically determined during execution.|$|E
50|$|The static {{choices are}} most often {{implemented}} inside a compiler, {{in which case the}} order of work is represented by the order in which instructions are placed into the executable binary. The dynamic choices would then be implemented inside the language's <b>runtime</b> <b>system.</b> The <b>runtime</b> <b>system</b> may be a library, which is called by instructions inserted by the compiler, or the <b>runtime</b> <b>system</b> may be embedded into the executable directly, such as by inserting branch instructions, which make dynamic choices about which work to perform next.|$|E
40|$|This {{bibliography}} cites {{and comments}} almost 400 publications on the parallel functional programming {{research of the}} last 15 years. It focuses on the software aspect of this area i. e. on languages, compile-time analysis techniques (in particular for strictness and weight analysis), code generation, and <b>runtime</b> <b>systems.</b> Excluded from this bibliography are publications on special architectures and on garbage collection unless they contain aspects interesting for above areas. Most bibliographic items are listed inclusive their full abstracts. Supported by the Austrian Science Foundation (FWF) contract S 5302 -PHY "Parallel Symbolic Computation". 2 CONTENTS Contents 1 Introduction to the 2 nd Edition 3 2 Introduction 3 3 General Work 6 4 Streams, Process Networks, and Operating Systems 7 5 Distributed Data Structures 10 6 Para-Functional Programming 11 7 Non-Determinism 17 8 Program Analysis 20 9 Parallelization and Compilation 27 10 Abstract Machines and <b>Runtime</b> <b>Systems</b> 31 11 Dynamic Pr [...] ...|$|R
40|$|We {{report in}} this paper on our {{experience}} {{in the design and}} implementation of a tool for migrating reFL ect code to OCaml. Migration proceeds by translating program parts to pure OCaml code, and binding the rest of the reFL ect program as OCaml primitives. Linking both reFL ect and OCaml <b>runtime</b> <b>systems</b> into a single executable allows running partially translated applications. 1...|$|R
40|$|International audienceIn this talk, we {{will present}} recent {{advances}} on PaStiX, a supernodal sparse direct solver, {{which has been}} enhanced {{by the introduction of}} Block Low-Rank compression. We will describe different strategies leading to memory consumption gain and/or time-to-solution reduction. Finally, the implementation on top of <b>runtime</b> <b>systems</b> (Parsec, StarPU), will be compared with the static scheduling used in previous experiments...|$|R
