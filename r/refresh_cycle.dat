40|53|Public
2500|$|The no {{operation}} command is always permitted, while the load mode register command requires that all banks be idle, and a delay afterward for {{the changes to}} take effect. [...] The auto refresh command also requires that all banks be idle, and takes a <b>refresh</b> <b>cycle</b> time tRFC to return the chip to the idle state. [...] (This time is usually equal to tRCD+tRP.) [...] The only other command that is permitted on an idle bank is the active command. [...] This takes, as mentioned above, tRCD before the row is fully open and can accept read and write commands.|$|E
50|$|Other {{interfaces}} {{include the}} product chart {{that has a}} <b>refresh</b> <b>cycle</b> of once per 10 minutes and various administrative interfaces for viewing and managing product and user data.|$|E
50|$|The refresh {{circuitry}} must {{perform a}} <b>refresh</b> <b>cycle</b> {{on each of}} the rows on the chip within the refresh time interval, to make sure that each cell gets refreshed.|$|E
5000|$|Distributed <b>refresh</b> - <b>refresh</b> <b>cycles</b> are {{performed}} at regular intervals, interspersed with memory accesses.|$|R
50|$|Most systems use {{multiple}} buffering {{and some}} means of synchronization of display and video memory <b>refresh</b> <b>cycles.</b>|$|R
5000|$|Burst refresh - {{a series}} of <b>refresh</b> <b>cycles</b> are {{performed}} one after another until all the rows have been refreshed, after which normal memory accesses occur until the next refresh is required ...|$|R
50|$|Vertical {{synchronization}} is {{an option}} in most systems, wherein the video card is prevented from doing anything visible to the display memory until after the monitor finishes its current <b>refresh</b> <b>cycle.</b>|$|E
5000|$|... "Hidden refresh" [...] - This is an {{alternate}} {{version of the}} CBR <b>refresh</b> <b>cycle</b> which can be combined with a preceding read or write cycle. [...] The refresh is done in parallel during the data transfer, saving time.|$|E
5000|$|... "an ideal {{approach}} {{should provide}} a single, extensible, long-term solution that can be designed {{once and for all}} and applied uniformly, automatically, and in synchrony (for example, at every future <b>refresh</b> <b>cycle)</b> to all types of documents and all media, with minimal human intervention." ...|$|E
5000|$|The <b>refresh</b> <b>cycles</b> are {{distributed}} {{across the entire}} refresh interval {{in such a way}} that all rows are refreshed within the required interval. To refresh one row of the memory array using [...] Only Refresh, the following steps must occur: ...|$|R
50|$|The {{system used}} vacuum tube logic {{circuitry}} and electrostatic storage, consisting of 72 Williams tubes with {{a capacity of}} 1024 bits each, giving a total memory of 2048 words of 36 bits each. Each of the 72 Williams tubes was 3 inches in diameter. Memory could be expanded {{to a maximum of}} 4096 words of 36 bits by the addition of a second set of 72 Williams tubes or (later) by replacing the entire memory with magnetic core memory. The Williams tube memory and later core memory each had a memory cycle time of 12 microseconds. The Williams tube memory required periodic refreshing, mandating the insertion of <b>refresh</b> <b>cycles</b> into the 701's timing. An addition operation required five 12-microsecond cycles, two of which were <b>refresh</b> <b>cycles,</b> while a multiplication or division operation required 38 cycles (456 microseconds).|$|R
40|$|Compared to quantum logic gates, quantum {{memory has}} {{received}} far less attention. Here, we explore the prognosis for a solid-state, scalable quantum dynamic {{random access memory}} (Q-DRAM), where the qubits are encoded by the spin orientations of single quantons in exchange-decoupled quantum dots. We address, in particular, various possibilities for implementing <b>refresh</b> <b>cycles.</b> Corresponding author...|$|R
5000|$|The {{fraction}} {{of time the}} memory spends on refresh, the refresh overhead, can be calculated from the system timing: [...] For example, a recent SDRAM chip has 213 = 8,192 rows, a refresh interval of 64 ms, the memory bus runs at 133 MHz, and the <b>refresh</b> <b>cycle</b> takes 4 clock cycles. [...] The time for a <b>refresh</b> <b>cycle</b> is So less than 0.4% of the memory chip's time will be taken by refresh cycles. In SDRAM chips, the memory in each chip is divided into banks which are refreshed in parallel, saving further time. So the number of refresh cycles needed {{is the number of}} rows in a single bank, given in the specifications, which in recent (2012) generations of chips has been frozen at 8,192.|$|E
5000|$|Given {{support of}} -before- refresh, it is {{possible}} to deassert [...] while holding [...] low to maintain data output. If [...] is then asserted again, this performs a CBR <b>refresh</b> <b>cycle</b> while the DRAM outputs remain valid. Because data output is not interrupted, this is known as hidden refresh.|$|E
50|$|In {{magnetic}} core memory, each memory cell can retain data indefinitely {{even with the}} power turned off, but reading the data from any memory cell erases its contents. As a consequence, the memory controller typically added a <b>refresh</b> <b>cycle</b> after each read cycle {{in order to create}} the illusion of a non-destructive read operation.|$|E
5000|$|... "CAS before RAS refresh" [...] (CBR) - In {{this mode}} the on-chip counter {{keeps track of}} the row to be {{refreshed}} and the external circuit merely initiates the <b>refresh</b> <b>cycles.</b> [...] This mode uses less power because the memory address bus buffers don't have to be powered up. It is used in most modern computers.|$|R
5000|$|In {{the latest}} (2012) {{generation}} of chips the [...] "RAS only" [...] mode has been eliminated, {{and the internal}} counter is used to generate refresh. The chip has an additional [...] "sleep mode", for use when the computer is in hibernation, in which an on-chip oscillator generates internal <b>refresh</b> <b>cycles</b> so that the external clock can be shut down.|$|R
5000|$|There {{were several}} forms of {{electrostatic}} memory tubes in existence in 1949. The best known {{today is the}} Williams tube, developed in England, {{but there were a}} number of others that had been developed independently by various research labs. The Whirlwind engineers considered the Williams tube, but determined that the dynamic nature of the storage and the need for frequent <b>refresh</b> <b>cycles</b> was incompatible with the design goals for Whirlwind I. Instead, they settled on a design that was being developed at the MIT Radiation Laboratory. This was a dual-gun electron tube. One gun produced a sharply-focused beam to read or write individual bits. The other gun was a [...] "flood gun" [...] that sprayed the entire screen with low-energy electrons. As a result of the design, this tube was more of a static RAM that did not require <b>refresh</b> <b>cycles,</b> unlike the dynamic RAM Williams tube.|$|R
50|$|Burst refresh {{results in}} long periods when the memory is unavailable, so {{distributed}} refresh {{has been used}} in most modern systems, particularly in real time systems. In distributed refresh, the interval between refresh cycles isFor example, the current generation of chips (DDR SDRAM) has a refresh time of 64 ms and 8,192 rows, so the <b>refresh</b> <b>cycle</b> interval is 7.8 μs.|$|E
5000|$|In a DRAM chip, each bit {{of memory}} data is stored as the {{presence}} or absence of an electric charge on a small capacitor on the chip. [...] As time passes, the charges in the memory cells leak away, so without being refreshed the stored data would eventually be lost. To prevent this, external circuitry periodically reads each cell and rewrites it, restoring the charge on the capacitor to its original level. Each memory <b>refresh</b> <b>cycle</b> refreshes a succeeding area of memory cells, thus repeatedly refreshing all the cells in a consecutive cycle. This process is conducted automatically, in the background, by the memory circuitry, while the computer is on, and is transparent to the user. [...] While a <b>refresh</b> <b>cycle</b> is occurring the memory is not available for normal read and write operations, but in modern memory this [...] "overhead" [...] time is not large enough to significantly slow down memory operation.|$|E
5000|$|LPDDR4 also {{includes}} a mechanism for [...] "targeted row refresh" [...] to avoid corruption due to [...] "row hammer" [...] on adjacent rows. A special sequence of three activate/precharge sequences specifies the row which was activated more often than a device-specified threshold (200,000 to 700,000 per <b>refresh</b> <b>cycle).</b> Internally, the device refreshes physically adjacent rows rather than the one specified in the activate command.|$|E
50|$|UltraBattery {{can operate}} without a refresh charge for {{extended}} periods. For stationary cycling {{applications such as}} renewable energy or grid support, this may be between one and four months depending on workload; standard VRLA batteries in the same applications need refreshing every one to two weeks if performing daily cycles - and performance deteriorates rapidly even with weekly <b>refresh</b> <b>cycles.</b>|$|R
50|$|While {{the memory}} is operating, each memory cell must be {{refreshed}} repetitively, within the maximum interval between refreshes {{specified by the}} manufacturer, which is usually in the millisecond region. Refreshing does not employ the normal memory operations (read and write cycles) used to access data, but specialized <b>cycles</b> called <b>refresh</b> <b>cycles</b> which are generated by separate counter circuits in the memory circuitry and interspersed between normal memory accesses.|$|R
50|$|Hobbyists, {{specifically}} homebuilt processor enthusiasts, often prefer SRAM due to {{the ease}} of interfacing. It {{is much easier to}} work with than DRAM as there are no <b>refresh</b> <b>cycles</b> and the address and data buses are directly accessible rather than multiplexed. In addition to buses and power connections, SRAM usually requires only three controls: Chip Enable (CE), Write Enable (WE) and Output Enable (OE). In synchronous SRAM, Clock (CLK) is also included.|$|R
50|$|An {{alternative}} approach to event driven architectures {{is to increase}} the <b>refresh</b> <b>cycle</b> of an existing data warehouse to update the data more frequently. These real-time data warehouse systems can achieve near real-time update of data, where the data latency typically is in the range from minutes to hours. The analysis of the data is still usually manual, so the total latency is significantly different from event driven architectural approaches.|$|E
50|$|As 3dfx {{focused more}} on the retail {{graphics}} card space, further inroads into the OEM space were limited. A significant requirement of the OEM business was the ability to consistently produce new products on the six-month product <b>refresh</b> <b>cycle</b> the computer manufacturers required; 3dfx {{did not have the}} methodology nor the mindset to focus on this business model. In the end, 3dfx opted to be a retail distribution company manufacturing their own branded products.|$|E
5000|$|... #Caption: A {{depiction}} of 5 display refresh cycles with {{what may be}} shown during a micro stuttering case. Each colored section {{represents one of the}} GPU's frame buffer and each color change represents a frame buffer swap. Assuming a 60 Hz refresh rate, a benchmark tool may report this as 144 frames per second. However, the user will perceive less due to some frames existing for a tiny fraction of a display's <b>refresh</b> <b>cycle.</b>|$|E
5000|$|... {{on board}} bit mapped colour {{graphics}} (no [...] "text" [...] mode), with timing {{provided by a}} Motorola 6845 CRT controller. The video could produce 320x200 in 16 colours, or 640x200 in a palette of 4 colours out of 16, with a later modification providing a 960x512 monochrome mode. The frame buffer resided in system memory and video refresh provided DRAM <b>refresh</b> <b>cycles.</b> The video output was able to drive CGA, EGA, MGA and multisync monitors.|$|R
25|$|Timings: CAS latency (CL), {{clock cycle}} time (tCK), row <b>cycle</b> time (tRC), <b>refresh</b> row <b>cycle</b> time (tRFC), row active time (tRAS).|$|R
25|$|Finally, if CKE {{is lowered}} {{at the same}} time as an auto-refresh command is sent to the SDRAM, the SDRAM enters self-refresh mode. This is like power down, but the SDRAM uses an on-chip timer to {{generate}} internal <b>refresh</b> <b>cycles</b> as necessary. The clock may be stopped during this time. While self-refresh mode consumes slightly more power than power-down mode, it allows the memory controller to be disabled entirely, which commonly more than makes up the difference.|$|R
5000|$|The storage cells on {{a memory}} chip {{are laid out}} in a {{rectangular}} array of rows and columns. The read process in DRAM is destructive and removes the charge on the memory cells in an entire row, so there is a row of specialized latches on the chip called sense amplifiers, one for each column of memory cells, to temporarily hold the data. During a normal read operation, the sense amplifiers after reading and latching the data, rewrite the data in the accessed row before sending the bit from a single column to output. So the normal read electronics on the chip has the ability to refresh an entire row of memory in parallel, significantly speeding up the refresh process. A normal read or write cycle refreshes a row of memory, but normal memory accesses cannot be relied on to hit all the rows within the necessary time, necessitating a separate refresh process. Rather than use the normal read cycle in the refresh process, to save time an abbreviated cycle called a <b>refresh</b> <b>cycle</b> is used. The <b>refresh</b> <b>cycle</b> is similar to the read cycle, but executes faster for two reasons: ...|$|E
50|$|Simple {{activation}} of the watchdog and regular resets of the timer do not make optimal use of a watchdog. For best results, the <b>refresh</b> <b>cycle</b> of the timer must be set as short as possible and called from the main function, so a reset can be performed before damage is caused or an error occurred. If a microcontroller {{does not have an}} internal watchdog, a similar functionality can be implemented by the use of a timer interrupt or an external device.|$|E
5000|$|Some {{graphics}} systems let {{the software}} perform its memory accesses {{so that they}} stay {{at the same time}} point relative to the display hardware's <b>refresh</b> <b>cycle.</b> In this case, the software writes to the areas of the display that have just been updated, staying just behind the monitor's active refresh point. This allows for copy routines or rendering engines with less predictable throughput, as long as the rendering engine can [...] "catch up" [...] with the monitor's active refresh point when it falls behind.|$|E
5000|$|GE {{produced}} the basic Porta-Color design {{well into the}} 1970s, even after most companies had moved to solid state designs when transistors with the required power capabilities were introduced. The Porta Color II was their attempt at a solid state version, but did not see widespread sales. The basic technology, however, was copied into GE's entire lineup as product <b>refresh</b> <b>cycles</b> allowed. By the early 1970s most companies had introduced the [...] "slot-mask" [...] designs, including RCA.|$|R
50|$|Since most {{implementations}} of MSX use RAM memory disposed in a 256×256 bytes block, two cycles {{are required}} to set the address for the fetch. The R800 avoids this by remembering the last known state of the higher 8-bits. If the next instruction {{is in the same}} 256-byte boundaries, the higher 8-bits are not set, and a cycle is saved. However, on the Z80, the <b>refresh</b> <b>cycles</b> destroy the information on the higher bits, so a workaround was needed.|$|R
50|$|Palm OS 1.0 {{does not}} {{differentiate}} between RAM and file system storage. Applications are installed directly into RAM and executed in place. As no dedicated file system is supported, {{the operating system}} depends on constant RAM <b>refresh</b> <b>cycles</b> to keep its memory. The OS supports 160x160 monochrome output displays. User input is generated through the Graffiti handwriting recognition system or optionally through a virtual keyboard. The system supports data synchronization to another PC via its HotSync technology over a serial interface. The latest bugfix release is version 1.0.7.|$|R
