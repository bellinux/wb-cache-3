43|10000|Public
5000|$|SMART Business requirements: are (manually) {{gathered}} and documented using the <b>requirements</b> <b>specification</b> <b>language</b> SMART notation. This is a Domain-specific language {{that can be}} used to define information based end results that business or organizations would want to produce.|$|E
40|$|This paper {{presents}} {{a pilot study}} to test plans for an empirical study, which will compare the comprehensibility of two specifications: a formal specification and an informal specification. The two documents used in the pilot study implemented the same logic, namely {{a portion of the}} Irish Electoral system. The “informal specification” was taken directly from the legal definition of the count rules for Irish elections. A formal <b>requirements</b> <b>specification</b> <b>language</b> was not employed for the pilot study. In place of a formal <b>requirements</b> <b>specification</b> <b>language,</b> the java programming language was used. Our main motivation for using the java programming language is based on an empirical study carried out in [19]...|$|E
40|$|A partial {{requirement}} specification for an Advanced Subsonic Civil Transport (ASCT) Flight Control System is described. The example was adopted from requirements given in a NASA Contractor report. The language {{used to describe}} the requirements, <b>Requirements</b> <b>Specification</b> <b>Language</b> (RSL), is described in a companion document...|$|E
40|$|This {{document}} {{describes a}} general purpose <b>Requirement</b> <b>Specification</b> <b>Language</b> (RSL). RSL is {{a hybrid of}} features found in several popular <b>requirement</b> <b>specification</b> <b>languages.</b> The purpose of RSL is to describe precisely the external structure of a system comprised of hardware, software, and human processing elements. To overcome the deficiencies of informal <b>specification</b> <b>languages,</b> RSL includes facilities for mathematical specification. Two RSL interface tools are described. The Browser view contains a complete document with all details of the objects and operations. The Dataflow view is a specialized, operation-centered depiction of a specification that shows how specified operations relate in terms of inputs and outputs...|$|R
50|$|Gray-box {{testing is}} based on {{requirement}} test case generation because it presents all the conditions before the program is tested by using the assertion method. A <b>requirement</b> <b>specification</b> <b>language</b> is used {{to make it easy}} to understand the requirements and verify its correctness.|$|R
40|$|It is a {{frequently}} reported effect of applying <b>requirements</b> <b>specification</b> <b>languages</b> that the formalization of informal requirements {{leads to the}} detection of defects such as omissions, conflicts, and ambiguities. However, there is little quantitative data available on this effect. This paper presents an empirical study with <b>requirements</b> <b>specification</b> <b>languages,</b> which addresses two research questions. First, which types of defects are detected by a requirements engineer during {{the development of a}} requirements model, and second, what happen to those defects that are not detected? The results indicate that ambiguities require special care during formalization, because they are less {{frequently reported}} than other types of defects. Instead, ambiguities tend to become often disambiguated unconsciously, which is a serious problem, because implicit assumptions are more likely than in our study to be wrong when the system is more complex. Moreover, ambiguities are misinterpreted more often than other types of defects. Finally, ambiguities, if noticed, require immediate clarification. 1...|$|R
40|$|A {{requirements}} {{determination method}} {{is a combination}} of a set of modeling constructs (in general referred to as the <b>requirements</b> <b>specification</b> <b>language)</b> and an accompanying (set of) procedure(s) that ‘prescribe ’ how this language must be applied in practice. In this chapter a way of working and a way of controlling for natura...|$|E
40|$|Requirements Engineering is {{more and}} more {{considered}} as a central phase in {{the development and implementation of}} computer systems. Within the context of CIM, the CIMOSA project proposes a set of models based on adequate concepts for expressing requirements. In this paper, we suggest how these models can be supported by the use of a fully formal <b>requirements</b> <b>specification</b> <b>language</b> called ALBERT and based on an agent-oriented real-time temporal logic framework...|$|E
40|$|This {{report is}} a Reference Manual for a {{general-purpose}} <b>Requirements</b> <b>Specification</b> <b>Language,</b> RSL. The purpose of RSL is to specify precisely the external {{structure of a}} mechanized system and to define requirements that the system must meet. A system can be comprised of a mixture of hardware, software, and human processing elements. RSL is a hybrid of features found in several popular requirements specification languages and includes constructs for formal mathematical specification...|$|E
40|$|Creating {{complex systems}} by {{combining}} smaller component services {{is one of}} the fundamental concepts in Service Oriented Architecture. Service compositions are built by combining loosely coupled services that are, usually, offered and operated by different service providers. While this approach offers several benefits, it makes the implementation and representation of the security requirements difficult. This paper reviews several <b>requirement</b> <b>specification</b> <b>languages</b> and analyses their suitability for composite services. A set of requirements is identified and a comparison between different <b>specification</b> <b>languages</b> is presented along with some conclusion on the suitability of each language in expressing security requirements for composite services...|$|R
40|$|A {{run-time}} {{monitoring technique}} {{has become a}} promising methodology for higher system assurance by validating a current execution trace with regard to a given <b>requirement</b> <b>specification.</b> To formalize and understand the computational nature of run-time monitoring {{is a key to}} utilize this valuable technique. In this paper, we formalize the notion of run-time monitoring of reactive systems in terms of ω-languages. Then, we introduce our prototype for run-time analysis of reactive systems, called Monitoring and Checking (MaC) architecture. Finally, we show that the class of languages specified by MEDL, which is a <b>requirement</b> <b>specification</b> <b>language</b> of the MaC architecture, is exactly the class of monitorable languages...|$|R
40|$|We {{describe}} the motivation and concepts of a validation driven software development process (PTAH). It extends the use-case driven approach defined by Jacobsen et al. (1992) and the unified process described by Jacobsen et al. (1999) by actively integrating end users into the <b>requirements</b> <b>specification</b> and its direct evaluation. Our experience in software projects {{clearly shows that}} even graphical <b>requirements</b> <b>specification</b> <b>languages</b> are not adequate for end-users to actively describe formal system requirements. Therefore, we present use cases and scenarios as functional prototypes (simulations of the system) and let users manipulate, critique, configure, annotate and enhance those prototypes. In order to empower end-users to develop an...|$|R
40|$|Abstract. Requirements {{engineering}} {{is widely considered}} to be an essential activity for the successful development of information systems. This paper briefly presents a new initiative called “ProjectIT-Requirements ” and describes the results achieved in the definition of a <b>requirements</b> <b>specification</b> <b>language,</b> called “ProjectIT-RSL”, and the implementation of a prototype using VisualStudio. NET. This is the first step of a process that will enable the automatic generation of UML models and programming code, based on the MDD approach. ...|$|E
40|$|In recent years, UML {{has become}} a {{standard}} language for modeling software requirements and design. In this paper we investigate the suitability of UML as a semiformal <b>requirements</b> <b>specification</b> <b>language.</b> Using the Teleservices and Remote Medical Care (TRMCS) case study as an example, we identify and demonstrate various problems and deficiencies of UML, particularly concerning use case models and system decomposition. We also investigate whether and how the deficiencies can be overcome and how potential alternatives could look...|$|E
40|$|This report {{documents}} {{a prototype}} tool developed {{to investigate the}} use of visualization and virtual reality technologies for improving software surety confidence. The tool is utilized within the execution phase of the software life cycle. It provides a capability to monitor an executing program against prespecified requirements constraints provided in a program written in the <b>requirements</b> <b>specification</b> <b>language</b> SAGE. The resulting Software Attribute Visual Analysis Tool (SAVAnT) also provides a technique to assess the completeness of a software specification...|$|E
40|$|KAOS is {{a popular}} and useful goal {{oriented}} requirements engineering (GORE) language, {{which can be used}} in business <b>requirements</b> modelling, <b>specification,</b> and analysis. Currently, KAOS is being used in areas such as business process modelling, and enterprise architecture (EA). But, an incomplete or malformed KAOS model can result to incomplete and erroneous requirements analysis, which in turn can lead to overall systems failure. Therefore, it is necessary to check that a <b>requirements</b> <b>specification</b> in KAOS <b>language</b> are complete and well formed. The contribution at hand is to provide an automated technique for checking the completeness and well-formed-ness of a <b>requirements</b> <b>specification</b> in KAOS <b>language.</b> Such a technique can be useful, especially to business or requirements analysts in industries and research, to check that <b>requirements</b> <b>specification</b> in KAOS <b>language</b> is well formed...|$|R
40|$|It {{has been}} {{recognised}} that formal methods are {{useful as a}} modelling tool in <b>requirements</b> engineering. <b>Specification</b> <b>languages</b> such as Z permit the precise and unambiguous modelling of system properties and behaviour. However some system problems, particularly those drawn from the IS problem domain, {{may be difficult to}} model in crisp or precise terms...|$|R
40|$|This report {{describes}} a textual <b>requirement</b> <b>specification</b> <b>language,</b> called ReqSpec, for the Architecture Analysis 2 ̆ 6 Design Language (AADL). It {{is based on}} the draft Requirements Definition and Analysis Language Annex, which defines a meta-model for <b>requirement</b> <b>specification</b> as an-notations to AADL models. A set of plug-ins to the Open Source AADL Tool Environment (OSATE) toolset supports the ReqSpec language. Users can follow an architecture-led <b>requirement</b> <b>specification</b> process that uses AADL models to represent the system in its operational con-text as well as the architecture of the system of interest. ReqSpec {{can also be used to}} represent existing stakeholder and system requirement documents. Requirement documents represented in the Requirements Interchange Format can be imported into OSATE to migrate such documents into an architecture-centric virtual integration process. Finally, ReqSpec is an element of an architecture-led, incremental approach to system assurance. In this approach, <b>requirements</b> <b>specifications</b> are complemented with verification plans. When executed, these plans produce evidence that a system implementation satisfies the requirements. This report introduces the ReqSpec notation and illustrates its use on an example...|$|R
40|$|Parallel {{processing}} is a {{very important}} technique for improving the performance of various software development and maintenance activities. The purpose of this book is to introduce important techniques for parallel executation of high-level specifications of software systems. These techniques are very useful for the construction, analysis, and transformation of reliable large-scale and complex software systems. Contents: Current Approaches; Overview of the New Approach; FRORL <b>Requirements</b> <b>Specification</b> <b>Language</b> and Its Decomposition; Rewriting and Data Dependency, Control Flow Analysis of a L...|$|E
40|$|This book {{provides}} a coherent methodology for Model-Driven Requirements Engineering which stresses the systematic treatment of requirements {{within the realm}} of modelling and model transformations. The underlying basic assumption is that detailed requirements models are used as first-class artefacts playing a direct role in constructing software. To this end, the book presents the <b>Requirements</b> <b>Specification</b> <b>Language</b> (RSL) that allows precision and formality, which eventually permits automation of the process of turning requirements into a working system by applying model transformations and c...|$|E
40|$|Distributed {{communications}} are {{an essential}} part of many current and proposed real-time systems. However, no existing <b>requirements</b> <b>specification</b> <b>language</b> provides explicit and general support for distributed real-time communication (DRTC). After a brief discussion of DRTC issues and characteristics, we describe our approach to specifying the many kinds of send and receive actions, communication channels, and message types within a real-time framework. The specification scheme is currently under development and is an extension of a state machine language that has been used successfully for some large applications...|$|E
40|$|Although {{there is}} a {{substantial}} amount of work on formal requirements for two and three-party key distribution protocols, very little has been done on requirements for group protocols. However, since the latter have security requirements that can differ in important but subtle ways, we believe that a rigorous expression of these requirements can be useful in determining whether a given protocol can satisfy an application's needs. In this paper we make a first step in providing a formal understanding of security requirements for group key distribution by using the NPATRL <b>language,</b> a temporal <b>requirement</b> <b>specification</b> <b>language</b> for use with the NRL Protocol Analyzer. We specify the requirements for GDOI, a protocol being proposed as an IETF standard, which we are formally specifying and verifying in cooperation with the MSec working group...|$|R
40|$|The {{concept of}} Open GIS depends on precise {{definitions}} of data, operations and interfaces. This paper argues {{for the use}} of functional programming <b>languages</b> as <b>specification</b> and prototyping tools for Open GIS components. It shows how functional programming languages fulfill the key <b>requirements</b> for formal <b>specification</b> <b>languages</b> and allow for rapid prototyping in addition. So far, it has never been possible to integrate specification and prototyping in a single, easy to use environment. Most existing specification methods lack appropriate tools for checking and prototyping, while existing tools lack either sound semantics or usability or both. The paper discusses the role of <b>specifications</b> in GIS, <b>requirements</b> for <b>specification</b> <b>languages,</b> and a survey of algebraic specifications as well as of functional languages. It then describes how functional languages can be used for writing and executing algebraic specifications. A brief example of a GIS data type specification in a functional la [...] ...|$|R
40|$|A {{hierarchy}} of models that capture realistic aspects of reactive, realtime, and hybrid systems is introduced. On the most abstract level, the qualitative (non-quantitative) model of reactive systems captures the temporal precedence aspect of time. A more refined model {{is that of}} real-time systems, which represents the metric aspect of time. The third and most detailed model is that of hybrid systems, which allows the incorporation of continuous components into a reactive system. For {{each of the three}} levels, we present a computational model, a <b>requirement</b> <b>specification</b> <b>language</b> based on extensions of temporal logic, system description languages based on Statecharts and a textual programming language, proof rules for proving validity of properties, and examples of such proofs. Keywords: Temporal logic, reactive systems, real-time, specification, verification, hybrid systems, proof rules, statecharts. Contents 1 Introduction 0 2 Reactive Systems 2 2. 1 Computational Model: Fair Tra [...] ...|$|R
40|$|Requirements and user {{interfaces}} specifications are often seperated {{from each other}} and do not fit together. We integrate them in a newly defined <b>requirements</b> <b>specification</b> <b>language</b> (RSL). In particular, RSL allows explicit linking of requirements artefacts with elements of the user interface specification. Some of these elements are modality-independent, while others {{can be viewed as a}} prototype of the "look" of the user interface. This integration along the representation dimension is supposed to facilitate combined work on requirements and {{user interfaces}} along the process dimension as well...|$|E
40|$|Work-centered {{software}} systems {{function as}} inherent work-aiding systems. Based {{on the design}} concept for a work-centered support system (WCSS), these software systems support user tasks and goals through both direct and indirect aiding methods within the interface client. In order to ensure the coherent development and delivery of work-centered software products, WCSS visual interface requirements must be specified in order to capture the cognitive and work-aiding aspects of the user interface design. Without the ability to specify such original requirements, the probability of creating an accurate and effective work-centered software system is significantly reduced. A new visual <b>requirements</b> <b>specification</b> <b>language</b> based on the User Interface Markup Language (UIML) is proposed as an effective solution to bridging this gap between cognitive systems engineering and software engineering. In this paper, a new visual <b>requirements</b> <b>specification</b> <b>language</b> that can capture and describe work-centered visual requirements within a semi-formal syntax is introduced and explained. The proposed language is also shown to be easily integrated into a UML object model via the use of UML 2 ̆ 7 s extensibility features. Such a specification language for visual requirements could be employed by cognitive engineers and design teams to help convey requirements in a comprehensible format that is suitable for a software engineer. This solution provides coherency in the software modeling process of developing work-centered software systems and contributes towards the specification of unique visual software requirements...|$|E
40|$|Abstract: The lack {{of quality}} {{results in the}} {{development}} of information systems is certainly a good reason to justify the presentation of new research proposals, especially those that address the most critical areas of that process, such as the requirements specification task. In this paper, we describe how linguistic patterns can be used {{to improve the quality of}} requirements specifications, using them as the basis for a new <b>requirements</b> <b>specification</b> <b>language,</b> called ProjectIT-RSL, and how a series of validation mechanisms can be applied to guarantee the consistency and correctness of the written requirements with the syntactic and semantic rules of the language. ...|$|E
40|$|Abstract. [Context and motivation] Requirements {{form the}} {{foundation}} of soft-ware systems. The quality of the requirements influences {{the quality of the}} de-veloped software. [Question/problem] One of the main requirement issues is inconsistency, particularly onerous when the requirements concern temporal con-straints. Manual checking whether temporal requirements are consistent is te-dious and error prone and may be prohibitively expensive when the number of requirements is large. [Principal ideas/results] We show that answer-set pro-gramming tools (ASP) can be successfully applied to detect inconsistencies in software and system requirements. Our assumption is that these requirements are given in a formal <b>requirement</b> <b>specification</b> <b>language</b> called Temporal Ac-tion Language (TeAL). [Contribution] We present a translation from TeAL to the ASP language format accepted by clingcon. We show that clingcon can an-alyze requirements for several real software systems, verifying their consistency or identifying inconsistencies. We also examine the performance of the clingcon translation...|$|R
40|$|This {{paper is}} {{addressed}} to potential users of HyTech, the Cornell Hybrid Technology Tool, an automatic tool for analyzing hybrid systems. We review the formal technologies {{that have been}} incorporated into HyTech, and we illustrate the use of HyTech with three nontrivial case studies. 1 Introduction Hybrid systems are digital real-time systems that interact with the physical world through sensors and actuators. Due to the rapid development of digital processor technology, hybrid systems directly control {{much of what we}} depend on in our daily lives. Many hybrid systems, ranging from automobiles to aircraft, operate in safety-critical situations, and therefore call for rigorous analysis techniques. HyTech 3 is a symbolic model checker for linear hybrid systems. The underlying system model is hybrid automata, an extension of finite automata with continuous variables that are governed by differential equations [ACHH 93]. The <b>requirement</b> <b>specification</b> <b>language</b> is the integrator computat [...] ...|$|R
40|$|Abstract In {{this paper}} 1, we {{describe}} how the real-time verification tool UPPAAL {{has been extended}} to support automatic generation of time-optimal test suites for conformance testing. Such test suites are derived from a network of timed automata specifying the expected behaviour of the system under test and its environment. To select test cases, we use coverage criteria specifying structural criteria to be fulfilled by the test suite. The result is optimal {{in the sense that}} the set of test cases in the test suite requires the shortest possible accumulated time to cover the given coverage criterion. The main contributions of this paper are: (i) a modified reachability analysis algorithm in which the coverage of given criteria is calculated in an on-the-fly manner, (ii) a technique for efficiently manipulating the sets of covered elements that arise during the analysis, and (iii) an extension to the <b>requirement</b> <b>specification</b> <b>language</b> used in UPPAAL, making it possible to express a variety of coverage criteria. ...|$|R
40|$|Developing an {{alternative}} {{design for a}} requirements determination method In {{the second part of}} this thesis (chapters 5 and 6) we will develop {{an alternative}} design for a requirements determination method. In chapter 5 we will focus on the way of modeling by describing what should be contained in a requirements determination method. In chapter 6 we will focus on the way of working and way of controlling by precisely describing how the model elements in the <b>requirements</b> <b>specification</b> <b>language</b> can be instantiated in a specific application subject area and how the overall requirements determination process must be controlled when using this method...|$|E
40|$|In {{the present}} thesis we propose a new method {{to design a}} high level {{architecture}} of a software system that guarantees the satisfaction of its requirements. We give {{an overview of the}} concepts of goal oriented requirements specifications and of architectural prescriptions; we summarize the characteristics of KAOS, the goal oriented <b>requirements</b> <b>specification</b> <b>language</b> that is used by our process, and we introduce Preskriptor, our Prescription Specification Language (APL); we illustrate our methodology for transforming requirements to an architectural prescription and provide practical examples; finally, we discuss related work and indicate further directions of our research...|$|E
40|$|The Unified Modeling Language (UML) {{has been}} in the past years {{established}} as an industry standard for object - oriented modeling. Its ability, however, to serve as an efficient requirements specification tool is highly debated. In this paper, an attempt is made to present an overview of the language focused on use case modeling, which is the language's technique for capturing the system requirements. The usefulness, drawbacks and possible solutions or alternatives to the deficiencies of UML use case modeling are discussed. In addition, the question of whether or not UML should be thought of (and therefore criticized) as a semiformal <b>requirements</b> <b>specification</b> <b>language</b> is addressed...|$|E
40|$|Concerning {{data and}} object modeling, {{conceptual}} predesign proved useful in overcoming the impedance mismatch between conventional requirements analysis based on natural language and conceptual design. Within this contribution we will present first results {{on how the}} conceptual predesign model KCPM (Klagenfurt conceptual predesign model) {{may be used for}} the collection and mapping of dynamic <b>requirements</b> <b>specifications</b> (natural <b>language</b> text) to a state chart. This mapping is based on identifying specific requirements patterns within a predesign scheme that may be transformed into state diagram patterns. 1...|$|R
40|$|International audienceCurrent Cloud Service Level Agreements (SLAs) do {{not cover}} {{security}} requirements. Some consortiums have proposed {{standards for the}} evaluation of security offered by the Cloud Providers (CP). Cloud Brokers (CB) can then generate Security Level Agreement (SecLA) contracts between customers and providers to fit users' requirements. However, the SecLAs do not provide enough details for complex customers' situations, such as sharing resources with other users/companies, or set up specific Access Controls and Security Properties (ACSP). In this paper, we tackle this issue, by introducing a general <b>Requirement</b> <b>Specification</b> <b>Language</b> (ACSP-RSL) to allow the customers to express their needs in term of ACSP. The underlying formal model, on which is based RSL, is partially presented. The global SecLA definition and negotiation process is thus extended with our proposal. RSL indeed also allows to express Security Requirements currently existing in SecLAs. The negotiation phase between CB and the CPs is discussed. We show how the RSL specifications expressed by the customer can be projected into a generic detection/protection policy expressed as an extension of RSL. A complete use-case for a healthcare system with multi-tenancy for users and services deployed is given. Its security requirements are analyzed, modeled, expressed and discussed...|$|R
40|$|Quartz is {{a formal}} {{software}} development method for concurrent real-time systems, currently being devised by the Software Verification Research Centre. It {{is a program}} refinement theory that supports systematic production of verified real-time code from a formal specification. Its model encompasses {{a broad range of}} development steps from abstract <b>requirements</b> <b>specification,</b> through high-level <b>language</b> programs, down to executable assembler code with verified timing behaviour. This article illustrates the method via a detailed case study...|$|R
