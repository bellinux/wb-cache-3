2|2270|Public
50|$|LLVM {{can also}} {{generate}} <b>relocatable</b> <b>machine</b> <b>code</b> at compile-time or link-time or even binary machine code at run-time.|$|E
50|$|Program {{translation}} {{has been}} {{divided into four}} subproblems: compiler, assembler, link editor, and loader. As a result, the translation software is layered as well, allowing the software layers to be designed independently. Noting that the ways to conquer the complexity of program translation could readily be applied to protocols because of the analogy between programming languages and protocols, the designers of the TCP/IP protocol suite were keen on imposing the same layering on the software framework. This {{can be seen in}} the TCP/IP layering by considering the translation of a pascal program (message) that is compiled (function of the application layer) into an assembler program that is assembled (function of the transport layer) to object code (pieces) that is linked (function of the Internet layer) together with library object code (routing table) by the link editor, producing <b>relocatable</b> <b>machine</b> <b>code</b> (datagram) that is passed to the loader which fills in the memory locations (ethernet addresses) to produce executable code (network frame) to be loaded (function of the network interface layer) into physical memory (transmission medium). To show just how closely the analogy fits, the terms between parentheses in the previous sentence denote the relevant analogs and the terms written cursively denote data representations. Program translation forms a linear sequence, because each layer's output is passed as input to the next layer. Furthermore, the translation process involves multiple data representations. We see the same thing happening in protocol software where multiple protocols define the data representations of the data passed between the software modules.|$|E
50|$|An object file is a file {{containing}} object <b>code,</b> meaning <b>relocatable</b> format <b>machine</b> <b>code</b> that {{is usually}} not directly executable. There are various formats for object files, and the same object code can be packaged in different object files. An object file may also work like a shared library.|$|R
50|$|John Mauchly's Short Code, {{proposed}} in 1949, {{was one of}} the first high-level languages ever developed for an electronic computer. Unlike <b>machine</b> <b>code,</b> Short Code statements represented mathematical expressions in understandable form. However, the program had to be translated into <b>machine</b> <b>code</b> every time it ran, making the process much slower than running the equivalent <b>machine</b> <b>code.</b>|$|R
5000|$|... #Caption: Representation of {{the process}} of {{bootstrapping}} a C compiler written in C, by compiling it using another compiler written in <b>machine</b> <b>code.</b> To explain, the lefthand T is a C compiler written in C that produces <b>machine</b> <b>code.</b> The righthand T is a C compiler written in <b>machine</b> <b>code</b> that produces (the same) <b>machine</b> <b>code.</b> The diagram illustrates that this can be used to bootstrap the left T by using it to compile the compiler written in C.|$|R
50|$|The HP project Dynamo was an {{experimental}} JIT compiler where the 'bytecode' format and the <b>machine</b> <b>code</b> format were the same; the system turned PA-6000 <b>machine</b> <b>code</b> into PA-8000 <b>machine</b> <b>code.</b> Counterintuitively, {{this resulted in}} speed ups, in some cases of 30% since doing this permitted optimizations at the <b>machine</b> <b>code</b> level, for example, inlining code for better cache usage and optimizations of calls to dynamic libraries and many other run-time optimizations which conventional compilers {{are not able to}} attempt.|$|R
50|$|<b>Machine</b> <b>code</b> is {{generally}} different than bytecode (also known as p-code), which is either executed by an interpreter or itself compiled into <b>machine</b> <b>code</b> for faster (direct) execution. An exception {{is when a}} processor is designed to use a particular bytecode directly as its <b>machine</b> <b>code,</b> such {{as is the case}} with Java processors.|$|R
50|$|PowerBuilder {{applications}} are typically compiled to p-code, {{which is then}} interpreted by the PowerBuilder run time. Although it can be compiled to <b>machine</b> <b>code</b> (called c-code), a typical business application does not run a lot faster. However, applications which do an unusually large amount of computations (I/O, DBMS interaction, etc.) are likely to benefit up to 4,000x faster from compiling to <b>machine</b> <b>code.</b> The main reason why compiling to <b>machine</b> <b>code</b> was not used is {{an enormous amount of}} errors in PowerBuilder especially in <b>machine</b> <b>code</b> generation.|$|R
50|$|Different micro-architectures {{typically}} require different <b>machine</b> <b>code</b> to {{hit their}} maximum power. Examples of such <b>machine</b> <b>code</b> {{do not appear}} to be distributed in CPU reference materials.|$|R
50|$|Object code is {{a portion}} of <b>machine</b> <b>code</b> {{that has not yet}} been linked into a {{complete}} program. It is the <b>machine</b> <b>code</b> for one particular library or module that will make up the completed product. It may also contain placeholders or offsets, not found in the <b>machine</b> <b>code</b> of a completed program, that the linker will use to connect everything together. Whereas <b>machine</b> <b>code</b> is binary code that can be executed directly by the CPU, object code has the jumps partially parameterized so that a linker can fill them in.|$|R
50|$|An {{assembler}} is used {{to convert}} assembly <b>code</b> into <b>machine</b> <b>code</b> (object code). A linker links several object (and library) files to generate an executable. Assemblers can also assemble directly to <b>machine</b> <b>code</b> executable files without the object intermediary step.|$|R
5000|$|<b>Machine</b> <b>code</b> is invoked {{with the}} [...] function. The first {{parameter}} is {{the address of}} the <b>machine</b> <b>code</b> routine and the following values are parameters. For example, if the <b>machine</b> language <b>code</b> is stored in a string named [...] it can be called with parameters as [...]|$|R
50|$|<b>Machine</b> <b>code</b> compilers which {{generate}} directly executable, platform-specific <b>machine</b> <b>code,</b> are an exception. When using static linking, the compiler {{can safely}} assume that methods and variables computable at compile-time may be inlined.|$|R
40|$|Sometimes <b>machine</b> <b>code</b> {{turns out}} to be a better target for {{verification}} than source <b>code.</b> RISC <b>machine</b> <b>code</b> is especially advantaged with respect to source code in this regard because it has only two instructions that access memory. That architecture forms the basis here for an inference system that can prove <b>machine</b> <b>code</b> safe against `hardware aliasing', an effect that occurs in embedded systems. There are programming memes that ensure code is safe from hardware aliasing, but we want to certify that a given <b>machine</b> <b>code</b> is provably safe. Comment: First submitted to SEFM 2013 as "Towards Proving RISC <b>Machine</b> <b>Code</b> not Risky with respect to Memory Aliasing" (15 p+ 4 p Appendix), Resubmitted to and accepted for OpenCert 2013, co-located with SEFM 2013 (16 p+ 6 p Appendix...|$|R
50|$|Rather {{than making}} an {{interpretation}} of straightforwardly into <b>machine</b> <b>code,</b> cutting edge compilers mean a <b>machine</b> independent intermediate <b>code</b> to improve compactness of the compiler and minimise outline endeavours (Yin, et al., 2012). The transitional dialect characterises a virtual machine that can execute all projects written in the intermediate dialect (a machine is characterised by its dialect and the other way around). The intermediate code guidelines are interpreted into identical <b>machine</b> <b>code</b> arrangements by a code generator to make executable code. It is likewise conceivable to avoid the era of <b>machine</b> <b>code</b> by really executing the virtual <b>machine</b> in <b>machine</b> <b>code</b> (Mathur, Miles, & Du, 2015). This virtual machine usage is called a mediator, {{in light of the}} fact that it peruses in the intermediate code guidelines one by one and after every read executes the proportionate <b>machine</b> <b>code</b> successions (the translation) of the read halfway guideline straightforwardly.|$|R
2500|$|Compilers {{are used}} to {{translate}} source code from a programming language into either object <b>code</b> or <b>machine</b> <b>code.</b> [...] Object code needs further processing to become <b>machine</b> <b>code,</b> and <b>machine</b> <b>code</b> consists of the central processing unit's native instructions, ready for execution. Compiled computer programs are {{commonly referred to as}} executables, binary images, or simply as binariesâ€“ a reference to the binary file format used to store the executable code.|$|R
40|$|When an {{application}} generates code at run time, {{the time to}} produce executable code has to be short. The use of assemblers is convenient but usually too slow. To generate <b>machine</b> <b>code</b> `by hand' is difficult and boring, not to mention, unportable. It would be desirable to combine the facility to use symbolic instructions, as in an assembly language, with the speed to use direct <b>machine</b> <b>code,</b> as in hand written <b>machine</b> <b>code.</b> What is needed is a tool that provides a way to specify a computer architecture and how its instruction set is coded. From a specification the tool would generate code that resembles the instructions specified and emits <b>machine</b> <b>code</b> when executed. The tool would be simple to use and provide a quick and correct way to generate <b>machine</b> <b>code.</b> It {{could also be used}} {{for a wide variety of}} computer architectures. We have implemented a prototype of such a tool, the Uppsala University <b>Machine</b> <b>Code</b> Toolkit (UUMCT- 95), for the specification of RISC-machines. The [...] ...|$|R
50|$|GCJ compiles Java {{source code}} to Java Virtual Machine {{bytecode}} or to <b>machine</b> <b>code</b> {{for a number}} of CPU architectures. It could also compile class files and whole JARs that contain bytecode into <b>machine</b> <b>code.</b>|$|R
50|$|The LLVM <b>machine</b> <b>code</b> (MC) subproject is LLVM's {{framework}} for translating machine instructions between textual forms and <b>machine</b> <b>code.</b> Formerly, LLVM {{relied on the}} system assembler, or one provided by a toolchain, to translate assembly into <b>machine</b> <b>code.</b> LLVM MC's integrated assembler supports most LLVM targets, including x86, x86-64, ARM, and ARM64. For some targets, including the various MIPS instruction sets, integrated assembly support is usable but still in the beta stage.|$|R
50|$|All {{practical}} programs {{today are}} written in higher-level languages or assembly language. The source code is then translated to executable <b>machine</b> <b>code</b> by utilities such as compilers, assemblers, and linkers, with the important exception of interpreted programs, which are not translated into <b>machine</b> <b>code.</b> However, the interpreter itself, which {{may be seen as}} an executor or processor, performing the instructions of the source code, typically consists of directly executable <b>machine</b> <b>code</b> (generated from assembly or high-level language source code).|$|R
40|$|The {{purpose of}} this {{research}} was to investigate the generation of <b>machine</b> <b>code</b> from high-level programming language. The following steps were undertaken: 1) Choose a high-level programming language as the source language and a computer as the target computer. 2) Examine all stages during the compiling of a high-level programming language and all data sets involved in the compilation. 3) Discover the mechanism for generating <b>machine</b> <b>code</b> and the mechanism to generate more efficient <b>machine</b> <b>code</b> from the language. 3) Construct an algorithm for generating <b>machine</b> <b>code</b> for the target computer. The results suggest that compiler is best implemented in a high-level programming language, and that SCANNER and PARSER should be independent of target representations, if possible...|$|R
50|$|With proof-carrying code, the kernel {{publishes a}} {{security}} policy specifying properties that any packet filter must obey: for example, will not access memory {{outside of the}} packet and its scratch memory area. A theorem prover is used {{to show that the}} <b>machine</b> <b>code</b> satisfies this policy. The steps of this proof are recorded and attached to the <b>machine</b> <b>code</b> which is given to the kernel program loader. The program loader can then rapidly validate the proof, allowing it to thereafter run the <b>machine</b> <b>code</b> without any additional checks. If a malicious party modifies either the <b>machine</b> <b>code</b> or the proof, the resulting proof-carrying code is either invalid or harmless (still satisfies the security policy).|$|R
5000|$|The UMDs [...] and [...] do not output <b>machine</b> <b>code,</b> {{but instead}} LLVM IR. From here on, LLVM does {{optimizations}} and the compilation to <b>machine</b> <b>code.</b> This does mean, {{that a certain}} minimum version of LLVM has to be installed as well.|$|R
50|$|The {{structure}} of VPCode, the Virtual Processor's <b>machine</b> <b>code,</b> {{is intended to}} be able to represent the constructs required when compiling languages such as C, C++ and Java, and to allow efficient translation into the <b>machine</b> <b>code</b> of any real 32- or 64-bit CPU.|$|R
5000|$|<b>Machine</b> <b>code</b> {{generation}} : Some compilers compile source <b>code</b> {{directly into}} <b>machine</b> <b>code.</b> This {{is the original}} mode of compilation, and languages that are directly and completely transformed to machine-native code in this way may be called [...] "truly compiled" [...] languages. See assembly language.|$|R
50|$|Instead of {{translating}} {{directly into}} <b>machine</b> <b>code,</b> modern compilers translate to a <b>machine</b> independent intermediate <b>code</b> {{in order to}} enhance portability of the compiler and minimize design efforts. The intermediate language defines a virtual machine that can execute all programs written in the intermediate language (a machine is defined by its language and vice versa). The intermediate code instructions are translated into equivalent <b>machine</b> <b>code</b> sequences by a code generator to create executable code. It is also possible to skip the generation of <b>machine</b> <b>code</b> by actually implementing an interpreter or JIT for the virtual machine.|$|R
40|$|The Build System {{comprises}} the software tools and procedures creating the flight memory load for the Space Shuttle Backup Flight System. The system has six functions: (1) configuration management, which insures that the memory load contains the proper modules, all clearly marked; (2) source translation, which translates the source <b>code</b> into a <b>relocatable</b> <b>machine</b> code; (3) module integration, which combines and assigns memory locations {{to all the}} object modules produced in source translation; (4) static code analysis, which verifies the integration process; (5) deliverables generation, which yields release documentation and deliverable items; and (6) release maintenance, which controls all system patches subsequent to release. Further developments will include more automation in the producing of patches from source-code updates and system requirements for tracking...|$|R
25|$|Shellcode is {{commonly}} written in <b>machine</b> <b>code.</b>|$|R
5000|$|Slower {{execution}} {{compared to}} direct native <b>machine</b> <b>code</b> execution on the host CPU. A technique {{used to improve}} performance is just-in-time compilation which converts frequently executed sequences of interpreted instruction to host <b>machine</b> <b>code.</b> JIT is most often combined with compilation to byte-code as in Java.|$|R
40|$|In {{a virtual}} <b>machine</b> interpreter, the <b>code</b> for each virtual machine {{instruction}} has similarities to code for other instructions. We present an interpreter generator that automatically generates code for the virtual machine instructions from simple instruction descriptions; it generates code for the virtual machine interpreter, for generating virtual <b>machine</b> <b>code,</b> for virtual <b>machine</b> <b>code</b> disassembly, for tracing, and for profiling...|$|R
50|$|AOT {{produces}} <b>machine</b> optimized <b>code,</b> {{just like}} a standard native compiler. The difference is that AOT transforms the bytecode of an extant virtual machine (VM) into <b>machine</b> <b>code.</b>|$|R
50|$|ACK {{comes with}} a generic linker and {{librarian}} capable of manipulating files in the ACK's own a.out-based format; it will work on files containing EM code as well as native <b>machine</b> <b>code.</b> However, EM code cannot be linked to native <b>machine</b> <b>code</b> without translating the EM binary first.|$|R
40|$|In {{the article}} {{a method of}} {{preparation}} operands at the synthesis of <b>machine</b> <b>code</b> commands in compilers is discussed. A generalization of the data model for information resources is proposed. It?s developed a fundamentally new scheme of the synthesis of optimal <b>machine</b> <b>code</b> programs for the target computer...|$|R
5000|$|... (A) Program SUBR is {{compiled}} {{to produce}} object file (B), shown as both <b>machine</b> <b>code</b> and assembler. The compiler may start the compiled code at an arbitrary location, often location zero as shown. Location 13 contains the <b>machine</b> <b>code</b> for the jump instruction to statement ST in location 5.|$|R
40|$|Abstract. In {{the recent}} times {{the authors of}} this paper have been doing {{research}} on possibility of developing programming language, which would be neither compiler, nor interpreter. The concept is based on holding complete program in native <b>machine</b> <b>code,</b> while the specialized editor can decompile <b>machine</b> <b>code</b> and display it in high level language. The displayed code can be reedited and saved again as pure <b>machine</b> <b>code.</b> This paper investigates the possibility of optimizing generated code, while still retaining decompilability features. Rather then traditional approach for converting programs from high level languages to <b>machine</b> <b>code</b> using compilers and interpreters, {{the authors of this}} paper presented one more approach, in [1] and [2], where the source code does not exist as separate entity from executable (similarly to interpreted languages), while the program is executed in native <b>machine</b> <b>code</b> without aid of additional interpreter (similarity with compiled languages). The role of editor, compiler and decompiler is given to only one program, which displays the high level program representation from native code program. ASCII representation exists only during editing process...|$|R
50|$|The game runs in both BASIC and <b>machine</b> <b>code.</b>|$|R
