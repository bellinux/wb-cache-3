2|4|Public
5000|$|A common {{application}} {{convention is}} to use a new line delimiter to separate or terminate records, commonly CR,CRLF or LF. Unfortunately the CPU time required to parse for the <b>record</b> <b>delimiter</b> is significant and the exclusion of the <b>record</b> <b>delimiter</b> pattern from the data is frequently undesirable.|$|E
5000|$|Delimiter {{collision}} is {{a problem}} that occurs when an author or programmer introduces delimiters into text without actually intending them to be interpreted as boundaries between separate regions. In the case of XML, for example, this can occur whenever an author attempts to specify an angle bracket character. In most file types there is both a field delimiter and a <b>record</b> <b>delimiter,</b> both of which are subject to collision. In the case of comma-separated values files, for example, field collision can occur whenever an author attempts to include a comma as part of a field value (e.g., salary = [...] "$30,000"), and <b>record</b> <b>delimiter</b> collision would occur whenever a field contained multiple lines. Both record and field delimiter collision occur frequently in text files.|$|E
50|$|Field and <b>Record</b> <b>delimiters</b> (See also, ASCII, Control character).|$|R
50|$|Field delimiters {{separate}} data fields. <b>Record</b> <b>delimiters</b> separate {{groups of}} fields.|$|R
50|$|The use of ASCII 31 Unit {{separator}} as a {{field separator}} and ASCII 30 Record separator solves the problem of both field and <b>record</b> <b>delimiters</b> that appear in a text data stream.|$|R
40|$|Client-server {{protocols}} such as HTTP over a TCP {{transport layer}} may {{be implemented in}} a relatively straightforward manner, as is often given in 'textbook' examples. Many of these examples do not scale well to a full implementation across anything but a localhost connection with minimal data payload. Furthermore, such implementations are invariably less than optimal in terms of performance, robustness to differing remote client configurations, processor time utilization, and bandwidth usage. It is suggested that the examples often given in texts are overly simplified, {{to the point of}} being misleading. In this note, we examine some of these issues, resulting from the implementation of HTTP clients and servers using Unix (Berkeley) sockets, Windows NT (Winsock), and Java. Issues addressed include efficient send/receive buffering to minimizing kernel and user data copying, and robustness to variability in <b>record</b> <b>delimiters...</b>|$|R

