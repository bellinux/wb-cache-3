1224|2281|Public
25|$|Flora-2 is an {{object-oriented}} {{knowledge representation}} and <b>reasoning</b> <b>system</b> based on F-logic and incorporates HiLog, Transaction logic, and defeasible reasoning.|$|E
500|$|In 1986, SRI.com {{became the}} 8th {{registered}} [...] ".com" [...] domain. [...] The Artificial Intelligence Center developed the Procedural <b>Reasoning</b> <b>System</b> (PRS) {{in the late}} 1980s and into the early 1990s. [...] PRS launched the field of BDI-based intelligent agents. [...] In the 1990s, SRI developed a letter sorting system for the United States Postal Service and several education and economic studies.|$|E
50|$|An {{opportunistic}} <b>reasoning</b> <b>system</b> may combine {{elements of}} both forward and backward reasoning. It is useful {{when the number of}} possible inferences is very large and the <b>reasoning</b> <b>system</b> must be responsive to new data that may become known.|$|E
40|$|We {{present an}} {{integrated}} proof language for guiding {{the actions of}} multiple <b>reasoning</b> <b>systems</b> as they work together to prove complex correctness properties of imperative programs. The language operates {{in the context of}} a program verification system that uses multiple <b>reasoning</b> <b>systems</b> to discharge generated proof obligations. It is designed to 1) enable developers to resolve key choice points in complex program correctness proofs, thereby enabling automated <b>reasoning</b> <b>systems</b> to successfully prove the desired correctness properties; 2) allow developers to identify key lemmas for the <b>reasoning</b> <b>systems</b> to prove, thereby guiding the <b>reasoning</b> <b>systems</b> to find an effective proof decomposition; 3) enable multiple <b>reasoning</b> <b>systems</b> to work together productively to prove a single correctness property by providing a mechanism that developers can use to divide the property into lemmas, each of which is suitable fo...|$|R
40|$|Contents Project Summary................. Introduction................... Our {{previous}} work in mechanized <b>reasoning</b> <b>systems.......</b> Existing <b>reasoning</b> <b>systems...............</b> Existing logical frameworks.............. Open mechanized <b>reasoning</b> <b>systems............</b> Project Description................. References................................................................. Accomplishments of Previous NSF Support.......... Budget Pages................... Biography of McCarthy................ Biography of Giunchiglia............... Biography of Talcott................ i 1. Project summary There {{is a growing}} interest in the interconnection and integration of <b>reasoning</b> modules and <b>systems.</b> For example, developers of hardware ver...|$|R
40|$|A {{number of}} {{ontology}} <b>reasoning</b> <b>systems</b> {{have been developed}} for reasoning and querying the semantic web. Since they implement different reasoning algorithms and optimization techniques, they differ in a number of ways. Previous attempts at comparing performance of ontology <b>reasoning</b> <b>systems</b> have mainly considered performances of individual query requests. In this paper, we present the results of testing four of the most popular ontology <b>reasoning</b> <b>systems</b> on query sequences that reflect real world use cases. We believe that using query sequences is a more effective way to evaluate ontology <b>reasoning</b> <b>systems...</b>|$|R
5000|$|Distributed Multi-Agent <b>Reasoning</b> <b>System</b> (dMARS), a {{platform}} for intelligent agents ...|$|E
5000|$|Flora-2, an object-oriented, {{rule-based}} knowledge-representation and <b>reasoning</b> <b>system.</b> (Flora-2, Apache 2.0) ...|$|E
5000|$|Procedural <b>Reasoning</b> <b>System</b> (PRS) ongoing {{development}} {{and application of}} PRS in collaboration with SRI International ...|$|E
40|$|We {{present an}} {{integrated}} proof language for guiding {{the actions of}} multiple <b>reasoning</b> <b>systems</b> as they work together to prove complex correctness properties of imperative programs. The language operates {{in the context of}} a program verification system that uses multiple <b>reasoning</b> <b>systems</b> to discharge generated proof obligations. It is designed to 1) enable developers to resolve key choice points in complex program correctness proofs, thereby enabling automated <b>reasoning</b> <b>systems</b> to successfully prove the desired correctness properties; 2) allow developers to identify key lemmas for the <b>reasoning</b> <b>systems</b> to prove, thereby guiding the <b>reasoning</b> <b>systems</b> to find an effective proof decomposition; 3) enable multiple <b>reasoning</b> <b>systems</b> to work together productively to prove a single correctness property by providing a mechanism that developers can use to divide the property into lemmas, each of which is suitable for a different reasoning system; and 4) enable developers to identify specific lemmas that the <b>reasoning</b> <b>systems</b> should use when attempting to prove other lemmas or correctness properties, thereby appropriately confining the search space so that the <b>reasoning</b> <b>systems</b> can find a proof in an acceptable amount of time. The language includes a rich set of declarative proof constructs that enables developers to direct the <b>reasoning</b> <b>systems</b> as little or as much as they desire. Because the declarative proof statements are embedded into the program as specialized comments, they also serve as verified documentation and are a natural extension of the assertion mechanism found in most program verification systems. We have implemented our integrated proof language {{in the context of a}} program verification system for Java and used the resulting system to verify a collection of linked data structure implementations. Our experience indicates that our proof language makes it possible to successfully prove complex program correctness properties that are otherwise beyond the reach of automated <b>reasoning</b> <b>systems.</b> Swiss National Science FoundationNational Science FoundationDARP...|$|R
40|$|In this {{discussion}} we outline {{an approach to}} reasoning about hybrid <b>reasoning</b> <b>systems.</b> We believe that following this approach allows theoretical results to be obtained rapidly, allows {{a high level of}} understanding about the relationship between different hybrid <b>reasoning</b> <b>systems,</b> and allows advantage to be taken of results about classical systems. There are two aspects to the approach we propose. First, we suggest that we should treat hybrid <b>reasoning</b> <b>systems</b> in as much generality as possible. Second, although we acknowledge that unification is of central importance in hybrid <b>reasoning</b> <b>systems,</b> we think it can be a mistake to centre theoretical treatments of hybrid <b>reasoning</b> <b>systems</b> on unification itself. Instead we suggest that one should consider proof systems without unification and then introduce unification as a purely syntactic measure to improve efficiency...|$|R
40|$|There is {{a growing}} {{interest}} in the integration of mechanized <b>reasoning</b> <b>systems</b> such as automated theorem provers, computer algebra systems, and model checkers. State-of-the-art <b>reasoning</b> <b>systems</b> {{are the result of}} many man-years of careful development and engineering, and usually they provide a high degree of sophistication in their respective domain. Yet they often perform poorly when applied outside the domain they have been designed for. The problem of integrating mechanized <b>reasoning</b> <b>systems</b> is therefore being perceived as an important issue in automated reasoning. In this paper we present the Logic Broker Architecture, a framework which provides the needed infrastructure for making mechanized <b>reasoning</b> <b>systems</b> interoperate. The architecture provides location transparency, a way to forward requests for logical services to appropriate <b>reasoning</b> <b>systems</b> via a simple registration/subscription mechanism, and a translation mechanism which ensures the transparent and provably sound exchange of logical services. ...|$|R
5000|$|In {{contrast}} in a diagnostic <b>reasoning</b> <b>system</b> knowledge would be represented through diagnostic rules such as: ...|$|E
50|$|In {{artificial}} intelligence, the distributed multi-agent <b>reasoning</b> <b>system</b> (dMARS) is {{a platform}} for intelligent software agents developed at the AAII that makes uses of the belief-desire-intention software model (BDI). The design for dMARS {{is an extension of}} the intelligent agent cognitive architecture developed at SRI International called procedural <b>reasoning</b> <b>system</b> (PRS). The most recent incarnation of this framework is the JACK Intelligent Agents platform.|$|E
50|$|Flora-2 is an {{object-oriented}} {{knowledge representation}} and <b>reasoning</b> <b>system</b> based on F-logic and incorporates HiLog, Transaction logic, and defeasible reasoning.|$|E
40|$|The ESHOL {{sessions}} of the PAAR workshop focussed {{on the use}} of higher-order <b>reasoning</b> <b>systems.</b> A particular focus was on means to evaluate higher-order <b>reasoning</b> <b>systems.</b> The notion of higher-order included, but was not limited to, ramified type theory, simple type theory, intuitionistic and constructive typ...|$|R
40|$|Many {{case studies}} have shown that the {{combination}} of specialised <b>reasoning</b> <b>systems</b> can lead to synergetic effects and can widen the problem solving horizon of stand-alone <b>reasoning</b> <b>systems.</b> In the last few years we have further developed the MathWeb Software Bus (short MathWeb-SB) for the combination of <b>reasoning</b> <b>systems</b> on the system level. Despite the fact that the MathWeb-SB has been successfully used in many applications, we currently face some problems that are hard to solve without significant changes of the MathWeb-SB’s architecture. Building on many years of experience with with the integration of <b>reasoning</b> <b>systems,</b> we are currently developing a new framework for reasoning agents to solve these problems. In this paper, we present first ideas on how to realise our framework in the agent development environment JADE. ...|$|R
40|$|The {{integration}} of symbolic <b>reasoning</b> <b>systems</b> based on logic and connectionist systems {{based on the}} functioning of living neurons is a vivid research area in computer science. In the literature, one can found many e orts where di erent <b>reasoning</b> <b>systems</b> based on di erent logics are linked to classic arti cial neural networks. In this paper, we study {{the relation between the}} semantics of <b>reasoning</b> <b>systems</b> based on propositional logic and the connectionist model in the framework of membrane computing, namely, spiking neural P systems. We prove that the xed point semantics of deductive databases and the immediate consequence operator can be implemented in the spiking neural P systems model...|$|R
50|$|JACK Intelligent Agents is a {{framework}} in Java for multi-agent system development. JACK Intelligent Agents {{was built by}} Agent Oriented Software Pty. Ltd. (AOS) and is a third generation agent platform building on {{the experiences of the}} Procedural <b>Reasoning</b> <b>System</b> (PRS) and Distributed Multi-Agent <b>Reasoning</b> <b>System</b> (dMARS). JACK {{is one of the few}} multi-agent systems that uses the BDI software model and provides its own Java-based plan language and graphical planning tools.|$|E
50|$|In fact, mivar {{networks}} {{allow us}} to develop production approach (cause-effect dependencies “If-then”) and create an automated trained logically <b>reasoning</b> <b>system.</b>|$|E
5000|$|Distributed Multi-Agent <b>Reasoning</b> <b>System</b> (dMARS) an agent-oriented {{development}} and implementation environment for building complex, distributed, time-critical systems. Developed as a C++ extension to PRS.|$|E
40|$|Commonsense {{reasoning}} {{has proven}} exceedingly difficult both to model and to implement in artificial <b>reasoning</b> <b>systems.</b> This paper discusses {{some of the}} features of human reasoning that may account for this difficulty, surveys a number of <b>reasoning</b> <b>systems</b> and formalisms, and offers an outline of active logic, a non-classical paraconsistent logic that may be of some use in implementing commonsense reasoning...|$|R
40|$|Case-based <b>Reasoning</b> <b>systems</b> {{constitute}} {{sector of}} “Lazy” Machine Learning systems. They reach the learning with {{the storage of}} older experiences and during the recent years they have known big growth. The use of a similarity function, which {{is used for the}} retrieval of most similar case from the Case Base, is a critical point for the operation of Case-based <b>Reasoning</b> <b>systems.</b> Classic resemblance metric that is used in the established Case-based <b>Reasoning</b> <b>systems</b> include the Euclidean distance and its variants. Alternative methods can be applied in connection with the nature of data and the particularities of the problem. In this thesis we present and study non established techniques of resemblance that they can be used in systems based on cases. Such approaches, which include using fuzzy logic and the edit distance function, are described and experiments are executed with systems that use them. Combination of use of more than one techniques in case based <b>reasoning</b> <b>systems</b> is also proposed. ...|$|R
40|$|AbstractWe are {{interested}} in developing a methodology for integrating mechanized <b>reasoning</b> <b>systems</b> such as Theorem Provers, Computer Algebra Systems, and Model Checkers. Our approach {{is to provide a}} framework for specifying mechanized <b>reasoning</b> <b>systems</b> and to use specifications {{as a starting point for}} integration. We build on the work presented by Giunchigliaet al. (1994) which introduces the notion of Open Mechanized <b>Reasoning</b> <b>Systems</b> (OMRS) as a specification framework for integrating <b>reasoning</b> <b>systems.</b> An OMRS specification consists of three components: the logic component, the control component, and the interaction component. In this paper we focus on the control level. We propose to specify the control component by first adding control knowledge to the data structures representing the logic by means of annotations and then by specifying proof strategies via tactics. To show the adequacy of the approach we present and discuss a structured specification of constraint contextual rewriting as a set of cooperating specialized reasoning modules...|$|R
50|$|A <b>reasoning</b> <b>system</b> {{combines}} annotations to {{make sure}} they are coherent. For example, on an image, a sky region is supposed to be above a rock region.|$|E
5000|$|In a model-based <b>reasoning</b> <b>system</b> {{knowledge}} can be represented using causal rules. For example, in a medical diagnosis system the knowledge base may contain the following rule: ...|$|E
5000|$|Mark d’Inverno, Michael Luck, Michael Georgeff, David Kinny and Michael Wooldridge, The dMARS architecture: A {{specification}} of the distributed multi-agent <b>reasoning</b> <b>system,</b> Autonomous Agents and Multi-Agent Systems, 9(1-2):5-53, 2004.|$|E
40|$|In {{the last}} years, {{the vision of}} the Semantic Web fostered the {{interest}} in reasoning over large and very large sets of assertional statements in knowledge bases. Traditional tableau-based <b>reasoning</b> <b>systems</b> perform bad answering queries over large data sets, because these <b>reasoning</b> <b>systems</b> are based on efficient use of main memory data structures. Increasing expressivity and worstcase complexity further tighten the memory burden. The purpose of our work is to investigate how to release the main memory burden from tableau-based <b>reasoning</b> <b>systems</b> and perform efficient instance checking over SHI-knowledge bases. The key idea is to reduce instance checking for an individual in a knowledge base to smaller subsets of relevant axioms. Modularization techniques are introduced and further refined in order to increase the granularity of modules. For evaluation purposes, experiments on benchmark and real world knowledge bases are carried out. The principal conclusion is that the main memory burden for instance checking can be released from tableau-based <b>reasoning</b> <b>systems</b> for semi-expressive Description Logics, by using modularization techniques...|$|R
40|$|We are {{interested}} in developing a methodology for integrating mechanized <b>reasoning</b> <b>systems</b> such as Theorem Provers, Computer Algebra Systems, and Model Checkers. Our approach {{is to provide a}} framework for specifying mechanized <b>reasoning</b> <b>systems</b> and to use specifications {{as a starting point for}} integration. We build on top of the work presented in Giunchiglia et al. (1994) which introduces the notion of Open Mechanized <b>Reasoning</b> <b>Systems</b> (OMRS) as a specification framework for integrating <b>reasoning</b> <b>systems.</b> An OMRS specification consists of three components: the logic component, the control component, and the interaction component. In this paper we focus on the control level. We propose to specify the control component by first adding control knowledge to the data structures representing the logic by means of annotations and then by specifying proof strategies via tactics. To show the adequacy of the approach we present and discuss a structured specification of constraint contextual rewriting as a set of cooperating specialized reasoning modules...|$|R
5000|$|Intelligent systems usually rely on hybrid <b>reasoning</b> <b>systems,</b> {{which include}} induction, deduction, {{abduction}} and {{reasoning by analogy}} ...|$|R
50|$|Logtalk {{has been}} used to process STEP data models used to {{exchange}} product manufacturing information. It has also been used to implement a <b>reasoning</b> <b>system</b> that allows preference reasoning and constraint solving.|$|E
50|$|This section {{provides}} a non-exhaustive and informal categorisation of common types of <b>reasoning</b> <b>system.</b> These categories are not absolute. They overlap {{to a significant}} degree and share a number of techniques, methods and algorithms.|$|E
50|$|In {{information}} technology a <b>reasoning</b> <b>system</b> is a software system that generates conclusions from available knowledge using logical {{techniques such as}} deduction and induction. Reasoning systems {{play an important role}} in the implementation of artificial intelligence and knowledge-based systems.|$|E
50|$|Many <b>reasoning</b> <b>systems</b> employ {{deductive}} <b>reasoning</b> to draw inferences from available knowledge. These inference engines support {{forward reasoning}} or backward reasoning to infer conclusions via modus ponens. The recursive reasoning methods they employ are termed ‘forward chaining’ and ‘backward chaining’, respectively. Although <b>reasoning</b> <b>systems</b> widely support deductive inference, some systems employ abductive, inductive, defeasible {{and other types}} of reasoning. Heuristics may also be employed to determine acceptable solutions to intractable problems.|$|R
50|$|De Bruijn {{indices are}} {{commonly}} used in higher-order <b>reasoning</b> <b>systems</b> such as automated theorem provers and logic programming systems.|$|R
50|$|<b>Reasoning</b> <b>systems</b> may {{employ the}} closed world {{assumption}} (CWA) or open world assumption (OWA). The OWA {{is often associated with}} ontological knowledge representation and the Semantic Web. Different systems exhibit a variety of approaches to negation. As well as logical or bitwise complement, systems may support existential forms of strong and weak negation including negation-as-failure and ‘inflationary’ negation (negation of non-ground atoms). Different <b>reasoning</b> <b>systems</b> may support monotonic or non-monotonic reasoning, stratification and other logical techniques.|$|R
