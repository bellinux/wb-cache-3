0|60|Public
5000|$|They copied {{themselves}} to <b>read-write</b> <b>memory</b> before execution, or ...|$|R
5000|$|Many Harvard {{architecture}} microcontrollers cannot execute {{instructions in}} <b>read-write</b> <b>memory,</b> but only instructions in memory that it cannot write to, ROM or non-self-programmable flash memory.|$|R
40|$|Causal {{consistency}} {{is one of}} {{the most}} adopted consistency criteria for distributed implementations of data structures. It ensures that operations are executed at all sites according to their causal precedence. We address the issue of verifying automatically whether the executions of an implementation of a data structure are causally consistent. We consider two problems: (1) checking whether one single execution is causally consistent, which is relevant for developing testing and bug finding algorithms, and (2) verifying whether all the executions of an implementation are causally consistent. We show that the first problem is NP-complete. This holds even for the <b>read-write</b> <b>memory</b> abstraction, which is a building block of many modern distributed systems. Indeed, such systems often store data in key-value stores, which are instances of the <b>read-write</b> <b>memory</b> abstraction. Moreover, we prove that, surprisingly, the second problem is undecidable, and again this holds even for the <b>read-write</b> <b>memory</b> abstraction. However, we show that for the <b>read-write</b> <b>memory</b> abstraction, these negative results can be circumvented if the implementations are data independent, i. e., their behaviors do not depend on the data values that are written or read at each moment, which is a realistic assumption. Comment: extended version of POPL 201...|$|R
40|$|The wait-free <b>read-write</b> <b>memory</b> {{model has}} been {{characterized}} as an iterated Immediate Snapshot (IS) task. The IS task is affine  it {{can be defined as}} a (sub) set of simplices of the standard chromatic subdivision. In this paper, we highlight the phenomenon of a "natural" model that can be captured by an iterated affine task and, thus, by a subset of runs of the iterated immediate snapshot model. We show that the <b>read-write</b> <b>memory</b> model in which, additionally, k-set-consensus objects can be used is "natural" by presenting the corresponding simple affine task captured by a subset of 2 -round IS runs. As an "unnatural" example, the model using the abstraction of Weak Symmetry Breaking (WSB) cannot be captured by a set of IS runs and, thus, cannot be represented as an affine task. Our results imply the first combinatorial characterization of models equipped with abstractions other than <b>read-write</b> <b>memory</b> that applies to generic tasks...|$|R
40|$|Holographic {{storage and}} {{retrieval}} using photorefractive media (electro-optic ferroelectric materials), particularly iron-doped lithium niobate with its enhanced sensitivity, are discussed. Refractive index changes induced {{by exposure to}} light render the materials useful for <b>read-write</b> <b>memories</b> and <b>read-write</b> <b>memory</b> simulation. Resolution, dark storage time, write and erase times, reversibility, and noise levels of the materials are examined. The laser source, deflection system, hololens, page composer, and detector array of the holographic memory system are described. High SNR and two orders of magnitude improvement in speed are reported over earlier experimental prototypes, but the system is still too slow to meet practical needs...|$|R
50|$|Since the {{emergence}} of microcontrollers, many different memory technologies have been used. Almost all microcontrollers {{have at least two}} different kinds of memory, a non-volatile memory for storing firmware and a <b>read-write</b> <b>memory</b> for temporary data.|$|R
50|$|In a Harvard architecture, {{there is}} no need to make the two {{memories}} share characteristics. In particular, the word width, timing, implementation technology, and memory address structure can differ. In some systems, instructions for pre-programmed tasks can be stored in read-only memory while data <b>memory</b> generally requires <b>read-write</b> <b>memory.</b> In some systems, there is much more instruction memory than data memory so instruction addresses are wider than data addresses.|$|R
2500|$|In DOS memory management, {{conventional}} memory, {{also called}} base memory, {{is the first}} 640 kilobytes (...) of the memory on IBM PC or compatible systems. It is the <b>read-write</b> <b>memory</b> directly addressable by the processor {{for use by the}} operating system and application programs. As memory prices rapidly declined, this design decision became a limitation in the use of large memory capacities until the introduction of operating systems and processors that made it irrelevant.|$|R
5000|$|In modern diesel trucks, EDRs are {{triggered}} by electronically sensed {{problems in the}} engine (often called faults), or a sudden change in wheel speed. One {{or more of these}} conditions may occur because of an accident. Information from these devices can be collected after a crash and analyzed to help determine what the vehicles were doing before, during and after the crash or event. The term generally refers to a simple, tamper-proof, <b>read-write</b> <b>memory</b> device.|$|R
5000|$|<b>Read-write</b> <b>memory</b> {{is a type}} of {{computer}} memory that may be relatively easily written to as well as read from, that is, using electrical signalling normally associated with running software, and without other physical processes (unlike ROM or [...] "read-only memory" [...] and distinct from EEPROM). The related term RAM (for [...] "random access memory") means something different; it refers to memory that can access any memory location in a constant amount of time.|$|R
40|$|Sequential <b>read-write</b> <b>memories</b> (SRWMs) are RAMs {{without an}} address decoder. A shift {{register}} {{is used instead}} to point at subsequent memory locations. SRWMs consume less power than RAMs of the same size. Algorithms are presented to check whether a set of storage values fits in a single SRWM and to automatically map storage values in as few SRWMs as possible. Benchmark results show that good assignments can be obtained {{in spite of the}} limited addressing capabilitie...|$|R
50|$|In DOS memory management, {{conventional}} memory, {{also called}} base memory, {{is the first}} 640 kilobytes (640 × 1024 bytes) of the memory on IBM PC or compatible systems. It is the <b>read-write</b> <b>memory</b> directly addressable by the processor {{for use by the}} operating system and application programs. As memory prices rapidly declined, this design decision became a limitation in the use of large memory capacities until the introduction of operating systems and processors that made it irrelevant.|$|R
40|$|Four {{combinatorial}} optimization problems {{occurring in the}} memory-mapping subtask of high-level synthesis {{turn out to be}} intractable as is proven here. The first problem is cyclic register assignment in which repetitive read-write patterns of storage values have to be stored in a minimal number of locations situated in a register file with random access (RAM). The second problem is to partition a set of storage values in as few RAMs as possible. The remaining problems concern the counterparts of the RAM problems for sequential <b>read-write</b> <b>memories...</b>|$|R
50|$|Engineers {{normally}} {{write the}} microcode during the design {{phase of a}} processor, storing it in a read-only memory (ROM) or programmable logic array (PLA) structure, or in a combination of both. However, machines also exist that have some or all microcode stored in SRAM or flash memory. This is traditionally denoted as writeable control store {{in the context of}} computers, which can be either read-only or <b>read-write</b> <b>memory.</b> In the latter case, the CPU initialization process loads microcode into the control store from another storage medium, with the possibility of altering the microcode to correct bugs in the instruction set, or to implement new machine instructions.|$|R
40|$|Real-time {{data storage}} and {{processing}} using optical techniques have been considered in recent years. Of particular interest are photosensitive electro-optic crystals which permit volume storage {{in the form of}} phase holograms, by means of a charge transfer process. A survey {{of the state of the}} art of such holographic memories is presented. The physical mechanism responsible for the formation of phase holograms in such crystals is discussed. Attention is focused on various aspects of materials characterization, development and utilization. Experimental reversible holographic <b>read-write</b> <b>memory</b> systems with fast random access and high storage capacity employing this new class of photosensitive materials have already been demonstrated...|$|R
40|$|The {{asynchronous}} computability theorem (ACT) uses concepts from combinatorial topology {{to characterize}} which tasks have wait-free solutions in <b>read-write</b> <b>memory.</b> A task {{can be expressed}} as a relation between two chromatic simplicial complexes. The theorem states that a task has a protocol (algorithm) {{if and only if}} there is a certain chromatic simplicial map compatible with that relation. While the original proof of the ACT relied on an involved combinatorial argument, Borowsky and Gafni later proposed an alternative proof that relied on a algorithmic construction, termed the "convergence algorithm". The description of this algorithm was incomplete, and presented without proof. In this paper, we give the first complete description, along with a proof of correctness. Comment: 16 pages, 2 figure...|$|R
40|$|The design, development, and {{implementation}} of a prototype, partially populated, million bit <b>read-write</b> holographic <b>memory</b> system using state-of-the-art components are described. The system employs an argon ion laser, acoustooptic beam deflectors, a holographic beam splitter (hololens), a nematic liquid crystal page composer, a photoconductor-thermoplastic erasable storage medium, a silicon P-I-N photodiode array, with lenses and electronics of both conventional and custom design. Operation of the prototype memory system was successfully demonstrated. Careful attention {{is given to the}} analysis from which the design criteria were developed. Specifications for the major components are listed, along with the details of their construction and performance. The primary conclusion resulting from this program is that the basic principles of <b>read-write</b> holographic <b>memory</b> system are well understood and are reducible to practice...|$|R
40|$|Describes a new {{associative}} memory cell in which MNOS transistors {{are used as}} storage elements. The memory can perform functions as a read-only memory {{and at the same}} time as a <b>read-write</b> <b>memory.</b> The cell can be read as a random-access memory or as a content-addressable memory. As a CAM certain bits can be masked out, i. e., not compared with the stored bits. The comparison can also be controlled from the memory by the stored words. Since the word length or combinations of normal words can be stored in one word of the memory, fewer memory cells are needed than in an ordinary memory. Searches for groups of words (prime implicands) can be performed. Memory cells with an area of 5000 -m- have been built to demonstrate the feasibility of the MNOS-CAM...|$|R
30|$|Two subdomains can {{be updated}} {{independently}} {{of each other}} {{as long as they}} do not share a boundary. On shared boundaries there is a risk of <b>read-write</b> <b>memory</b> interferences [42]. To avoid any collision between read and write operations, all subdomains are padded with a layer of ghost nodes [43]. Ghost nodes are local copies of nodes belonging to subdomains that are immediate neighbours. After a subdomain has been computed, ghost nodes in surrounding subdomains must be updated with the most recently computed values. This is done in a synchronisation step that follows the computation of a subdomain. The boundary condition for a subdomain is then based on the values that are synchronised from the neighbouring subdomains. Subdomains surrounded by ghost nodes are further discussed in Appendix  2. Any algorithm can be used to compute new values within a subdomain.|$|R
50|$|The {{original}} System/360 {{models of}} IBM mainframe had read-only control store, but later System/360, System/370 and successor models loaded part {{or all of}} their microprograms from floppy disks or other DASD into a writable control store consisting of ultra-high speed random-access <b>read-write</b> <b>memory.</b> The System/370 architecture included a facility called Initial-Microprogram Load (IML or IMPL) that could be invoked from the console, as part of Power On Reset (POR) or from another processor in a tightly coupled multiprocessor complex. This permitted IBM to easily repair microprogramming defects in the field. Even when {{the majority of the}} control store is stored in ROM, computer vendors would often sell writable control store as an option, allowing the customers to customize the machine's microprogram. Other vendors, e.g., IBM, use the WCS to run microcode for emulator features and hardware diagnostics.|$|R
40|$|A {{heterodyne}} readout {{technique for}} <b>read-write</b> holographic <b>memory</b> systems that reconstruct a virtual image wavefront is described and demonstrated. The conventionally recorded hologram is illuminated simultaneously with a suitable combination of temporally modulated reference and modified object waves for readout. Best performance is obtained for temporal phase modulation. The coupling of the illuminating wavefronts by the hologram is analyzed...|$|R
40|$|In a {{parallel}} processing computer system with multiple processing units and shared memory, a method is disclosed for uniformly balancing the aggregate computational load in, and utilizing minimal memory by, a network having identical computations {{to be executed}} at each connection therein. Read-only and <b>read-write</b> <b>memory</b> are subdivided into a plurality of process sets, which function like artificial processing units. Said plurality of process sets is iteratively merged and reduced {{to the number of}} processing units without exceeding the balance load. Said merger is based upon the value of a partition threshold, which {{is a measure of the}} memory utilization. The turnaround time and memory savings of the instant method are functions of the number of processing units available and the number of partitions into which the memory is subdivided. Typical results of the preferred embodiment yielded memory savings of from sixty to seventy five percent...|$|R
40|$|This report {{describes}} the design, implementation and performance {{evaluation of a}} virtual shared memory server for the Mach operating system. The server provides unrestricted sharing of <b>read-write</b> <b>memory</b> between tasks running on either strongly coupled or loosely coupled architectures, and any mixture thereof. A number of memory coherency algorithms have been implemented and evaluated, including a new distributed algorithm that is shown to outperform centralized ones. Some {{of the features of}} the server include support for machines with multiple page sizes, for heterogeneous shared memory, and for fault tolerance. Extensive performance measures of applications are presented, and the intrinsic costs evaluated. 2 1. Introduction Shared memory multiprocessors are becoming increasingly available, and with them a faster way to program applications and system services via the use of shared memory. Currently, the major limitation in using shared memory {{is that it is not}} extensible network-wi [...] ...|$|R
25|$|AGC {{software}} {{was written in}} AGC assembly language and stored on rope memory. The bulk of the {{software was}} on read-only rope memory and thus couldn't be changed in operation, but some key parts of the software were stored in standard <b>read-write</b> magnetic-core <b>memory</b> and could be overwritten by the astronauts using the DSKY interface, as was done on Apollo 14.|$|R
40|$|Abstract. All {{consensus}} hierarchies in {{the literature}} assume that we have, in addition to copies of a given object, an unbounded number of registers. But why {{do we really need}} these registers? This paper considers what would happen if one attempts to solve consensus using various objects but without any registers. We show that under a reasonable assumption, objects like queues and stacks cannot emulate the missing registers. We also show that, perhaps surprisingly, initialization, shown to have no computational consequences when registers are readily available, is crucial in determining the synchronization power of objects when no registers are allowed. Finally, we show that without registers, the number of available objects affects the level of consensus that can be solved. Our work thus {{raises the question of whether}} consensus hierarchies which assume an unbounded num-ber of registers truly capture synchronization power, and begins a line of research aimed at better understanding the interaction between <b>read-write</b> <b>memory</b> and the powerful synchronization opera-tions available on modern architectures. ...|$|R
40|$|Question Answering (QA) is {{fundamental}} to natural language processing in that most nlp problems can be phrased as QA (Kumar et al., 2015). Current weakly supervised memory network models that have been proposed so far struggle at answering questions that involve relations among multiple entities (such as facebook's bAbi qa 5 -three-arg-relations in (Weston et al., 2015)). To address this problem of learning multi-argument multi-hop semantic relations {{for the purpose of}} QA, we propose a method that combines the jointly learned long-term <b>read-write</b> <b>memory</b> and attentive inference components of end-to-end memory networks (MemN 2 N) (Sukhbaatar et al., 2015) with distributed sentence vector representations encoded by a Skip-Thought model (Kiros et al., 2015). This choice to append Skip-Thought Vectors to the existing MemN 2 N framework is motivated by the fact that Skip-Thought Vectors have been shown to accurately model multi-argument semantic relations (Kiros et al., 2015). Comment: Removed by arXiv administrators because submission violated the terms of arXiv's license agreemen...|$|R
40|$|Sequential <b>read-write</b> <b>memories</b> (SRWMs) {{could be}} used as an {{alternative}} to register files in data-path synthesis. They can be considered RAMs without address decoder. A shift register is used instead to sequentially point at memory locations for read or write. Although SRWMs behave similarly to the memory structures recently proposed by Aloqeely and Chen, they are more interesting because of their lower power consumption. Algorithms are presented to check whether a set of storage value fit in a single SRWM (exactly by means of branch-and-bound) and to automatically map storage values in as few SRWMs as possible (by means of heuristics). As opposed to Aloqeely and Chen, also good benchmark results have been obtained for applications with a low degree of "regularity". 1 Introduction High-level synthesis, the automatic mapping of an algorithmic description of some computation to a description at the register-transfer level, is normally tackled by dividing the problem into a number of subpr [...] ...|$|R
5000|$|In {{contemporary}} usage, [...] "memory" [...] {{is usually}} semiconductor storage <b>read-write</b> random-access <b>memory,</b> typically DRAM (dynamic RAM) {{or other forms}} of fast but temporary storage. [...] "Storage" [...] consists of storage devices and their media not directly accessible by the CPU (secondary or tertiary storage), typically hard disk drives, optical disc drives, and other devices slower than RAM but non-volatile (retaining contents when powered down).|$|R
40|$|We {{present a}} number of {{streaming}} algorithms for a basic clustering problem for massive data sets. In this problem, we are given a set of n points drawn randomly according to a mixture of k uniform distributions, and wish to approximate the density function of the mixture. The points are placed in a datastream (possibly in adversarial order), which may only be read sequentially by the algorithm. We argue that this realistically models, among others, the datastream produced by a national census of the incomes of all citizens. Our algorithms conform to the pass-efficient model of computation; thus {{one of them has}} the novelty that it may make several passes over the data. The power of this approach is made apparent by the following property of our main algorithm: If the algorithm is allotted 2 l passes, it will produce an approximation with error at most ɛ l, using at most O ∗ (k 3 /ɛ 2) <b>read-write</b> <b>memory,</b> the most critical resource for streaming computation. Thus, we demonstrate that more passes allow much sharper approximations, holding the amount of RAM used constant...|$|R
40|$|We {{propose a}} novel memory network model named <b>Read-Write</b> <b>Memory</b> Network (RWMN) to perform {{question}} and answering tasks for large-scale, multimodal movie story understanding. The key {{focus of our}} RWMN model is to design the read network and the write network that consist of multiple convolutional layers, which enable memory read and write operations to have high capacity and flexibility. While existing memory-augmented network models treat each memory slot as an independent block, our use of multi-layered CNNs allows the model {{to read and write}} sequential memory cells as chunks, which is more reasonable to represent a sequential story because adjacent memory blocks often have strong correlations. For evaluation, we apply our model to all the six tasks of the MovieQA benchmark, and achieve the best accuracies on several tasks, especially on the visual QA task. Our model shows a potential to better understand not only the content in the story, but also more abstract information, such as relationships between characters and the reasons for their actions. Comment: Accepted paper at ICCV 201...|$|R
40|$|All {{consensus}} hierarchies in {{the literature}} assume that we have, in addition to copies of a given object, an unbounded number of registers. But why {{do we really need}} these registers? This paper considers what would happen if one attempts to solve consensus using various objects but without any registers. We show that under a reasonable assumption, objects like queues and stacks cannot emulate the missing registers. We also show that, perhaps surprisingly, initialization, shown to have no computational consequences when registers are readily available, is crucial in determining the synchronization power of objects when no registers are allowed. Finally, we show that without registers, the number of available objects affects the level of consensus that can be solved. Our work thus {{raises the question of whether}} consensus hierarchies which assume an unbounded number of registers truly capture synchronization power, and begins a line of research aimed at better understanding the interaction between <b>read-write</b> <b>memory</b> and the powerful synchronization operations available on modern architectures. Comment: 12 pages, 0 figure...|$|R
40|$|In this paper, a new {{memory element}} {{that can be}} used as an {{alternative}} to register files in data-path synthesis, is proposed. This is the sequential <b>read-write</b> <b>memory</b> (SRWM). Its organization {{is similar to that of}} a standard random access memory (RAM), with the difference that the address decoder has been replaced by a shift-register-like structure. It is used to sequentially point at the memory locations for read or write. Once sufficiently large, this new memory element needs less chip area and consumes less power than a standard RAM (of the same size). However, the problem of assigning a set of storage values to a set of memory locations becomes much more difficult. In this paper algorithms are presented to check whether a set of storage values fit in a single SRWM (exactly, by means of branch-and-bound) and to automatically map storage values in as few SRWMs as possible (by means of heuristics). By using these algorithms, the memory assignment problem for SRWMs can be solved. Severa [...] ...|$|R
5000|$|The AGC was a 15-bit plus parity {{machine with}} a 1 MHz clock. It was about one cubic foot in volume and weighed about 80 pounds. It used {{integrated}} circuit NOR gates, two to a package, but integrated RAM and ROM devices {{had not been}} developed yet. It had 2,000 words of magnetic ferrite core <b>read-write</b> <b>memory</b> and maybe 24 thousand words of read-only memory {{in the form of}} magnetic core ropes. These cores used metal tape magnetic cores. With such limited computing resources, the software had to be extremely tightly written in assembly code. These computers were designed with extremely long mean times to failure. Fifty were built by Raytheon, and none failed during several years of life. The human interface was a keyboard with ten digit keys and a few auxiliary keys for such things as [...] "+" [...] and [...] "-" [...] and [...] "enter", and a display with three numbers of 5 decimal/octal digits, a two-digit program number, and a two-digit verb and a two-digit noun. The astronauts used it for all phases of command.|$|R
5000|$|The Intel 4004 is {{generally}} regarded as the first commercially available microprocessor, and cost [...] The first known advertisement for the 4004 is dated November 15, 1971 and appeared in Electronic News. The project that produced the 4004 originated in 1969, when Busicom, a Japanese calculator manufacturer, asked Intel to build a chipset for high-performance desktop calculators. Busicom's original design called for a programmable chip set consisting of seven different chips. Three of the chips were to make a special-purpose CPU with its program stored in ROM and its data stored in shift register <b>read-write</b> <b>memory.</b> Ted Hoff, the Intel engineer assigned to evaluate the project, believed the Busicom design could be simplified by using dynamic RAM storage for data, rather than shift register memory, and a more traditional general-purpose CPU architecture. Hoff {{came up with a}} four-chip architectural proposal: a ROM chip for storing the programs, a dynamic RAM chip for storing data, a simple I/O device and a 4-bit central processing unit (CPU). Although not a chip designer, he felt the CPU could be integrated into a single chip, but as he lacked the technical know-how the idea remained just a wish for the time being.|$|R
5000|$|The 8088 {{processor}} of the IBM PC and IBM PC/XT {{could address}} one Megabyte (MB or 220 bytes) of memory. It inherited this limit from the 20-bit {{external address bus}} of the Intel 8086. The designers of the PC allocated the lower 640 kB (655,360 bytes) of address space for <b>read-write</b> program <b>memory</b> (RAM), called [...] "conventional memory", and the remaining 384 kB of memory space was reserved for uses such as the system BIOS, video memory, and memory on expansion peripheral boards.|$|R
25|$|The Apollo Guidance Computer (AGC) is {{a digital}} {{computer}} produced for the Apollo {{program that was}} installed on board each Apollo Command Module (CM) and Lunar Module (LM). The AGC provided computation and electronic interfaces for guidance, navigation, {{and control of the}} spacecraft. The AGC had a 16-bit word length, with 15 data bits and one parity bit. Most of the software on the AGC was stored in a special read only memory known as core rope memory, fashioned by weaving wires through magnetic cores, though a small amount of <b>read-write</b> core <b>memory</b> was provided.|$|R
