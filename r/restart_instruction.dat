2|7|Public
50|$|So {{for example}} a JTAG host might HALT the core, {{entering}} Debug Mode, and then read CPU registers using ITR and DCC. After saving processor state, it could write those registers with whatever values it needs, then execute arbitrary algorithms on the CPU, accessing memory and peripherals to help characterize the system state. After the debugger performs those operations, {{the state may}} be restored and execution continued using the <b>RESTART</b> <b>instruction.</b>|$|E
50|$|Writing {{assembler}} code programs {{under the}} new OS was rather different {{than it had been}} on the Model III. This was because the Model 4 was completely RAM-based, whereas the earlier TRS-80's memory maps were occupied by both RAM and ROM. No longer would assember programs issue CALL instructions to absolute addresses in ROM; TRSDOS 6 provided a standard interface to its service routines with its Supervisor Calls (SVCs). The code of the requested SVC was loaded into the Z-80 accumulator, any required parameters were loaded into their specified Z-80 general purpose registers (or needed regions of RAM set up as required, such as File Control Blocks), and a Z-80 <b>restart</b> <b>instruction</b> was issued (RST 40). TRSDOS then fetched from a table the absolute address of the needed service routine and branched to it. This indirect method made it possible to revise the operating system and build in additional features, which was done in major ways some half-dozen times throughout the active life of the OS. Four SVC codes were left unassigned and reserved for applications programmer's own uses. Four Z-80 restart vectors were similarly left unassigned.|$|E
5000|$|<b>Restart</b> the <b>instruction</b> {{that was}} {{interrupted}} by the operating system trap.|$|R
50|$|In {{high-level}} languages it {{is often}} {{thought to be a}} good idea that functions which return a result should not have side effects (lack of side effects makes program understanding and validation much easier). This addressing mode has a side effect in that the base register is altered. If the subsequent memory access causes an error (e.g. page fault, bus error, address error) leading to an interrupt, then <b>restarting</b> the <b>instruction</b> becomes much more problematic since one or more registers may need to be set back to the state they were in before the instruction originally started.|$|R
50|$|A {{worst case}} can be {{imagined}} on IBM System/370 and comparable mainframes. An execute instruction crossing a page boundary could point to a move instruction that also crosses a page boundary, which is set to move data from a source that crosses a page boundary to a target that crosses a page boundary. This single instruction references eight pages; if not all are in RAM, it will cause a page fault. If the operating system could not allocate eight pages to this program, then remedying the page fault would discard another page the instruction needs, and any <b>restart</b> of the <b>instruction</b> would fault again.|$|R
50|$|The {{original}} 32016 had a 16-bit external databus, a 24-bit external address bus, {{and a full}} 32-bit instruction set. It {{also included}} a coprocessor interface, allowing coprocessors such as FPUs and MMUs to be attached as peers to the main processor. The MMU was based on demand paging Virtual Memory, which was the most unusual feature compared to the segmented memory approach used by competition, and has become the standard for how microprocessors are designed today. The architecture supported an <b>instruction</b> <b>restart</b> mechanism on a page fault, which was much cleaner than the Motorola approach to dump the internal status on a page fault, {{which had to be}} read back, before the instruction was continued.Again, the Series 32000 approach has become the standard behavior.|$|R
50|$|When {{physical}} {{memory is}} not full {{this is a}} simple operation; the page is written back into physical memory, the page table and TLB are updated, and the <b>instruction</b> is <b>restarted.</b> However, when physical memory is full, one or more pages in physical memory {{will need to be}} paged out {{to make room for the}} requested page. The page table needs to be updated to mark that the pages that were previously in physical memory are no longer there, and to mark that the page that was on disk is now in physical memory. The TLB also needs to be updated, including removal of the paged-out page from it, and the <b>instruction</b> <b>restarted.</b> Which page to page out is the subject of page replacement algorithms.|$|R
5000|$|The Intel 8086 and {{subsequent}} processors in the x86 series had an HLT (halt) instruction, opcode F4, which stopped instruction execution {{and placed the}} processor in a HALT state. An enabled interrupt, a debug exception, the BINIT signal, the INIT signal, or the RESET signal resumed execution, which meant the processor could always be restarted. Some of the early Intel DX4 chips {{had a problem with}} the HLT instruction and could not be <b>restarted</b> after this <b>instruction</b> was used, which disabled the computer and turned HLT into more of an HCF instruction. The Linux kernel added a [...] "no-hlt" [...] option telling Linux to run an infinite loop instead of using HLT, which allowed users of these broken chips to use Linux.|$|R
50|$|In {{virtual memory}} systems, {{thrashing}} {{may be caused}} by programs or workloads that present insufficient locality of reference: if the working set of a program or a workload cannot be effectively held within physical memory, then constant data swapping, i.e., thrashing, may occur. The term was first used during the tape operating system days to describe the sound the tapes made when data was being rapidly written to and read.An example of this sort of situation occurred on the IBM System/370 series mainframe computer, in which a particular instruction could consist of an execute instruction (which crosses a page boundary) that points to a move instruction (which itself also crosses a page boundary), targeting a move of data from a source that crosses a page boundary, to a target of data that also crosses a page boundary. The total number of pages thus being used by this particular instruction is eight, and all eight pages must be present in memory at the same time. If the operating system allocates fewer than eight pages of actual memory, when it attempts to swap out some part of the instruction or data to bring in the remainder, the instruction will again page fault, and it will thrash on every attempt to <b>restart</b> the failing <b>instruction.</b>|$|R

