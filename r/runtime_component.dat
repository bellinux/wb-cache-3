53|150|Public
50|$|In SAPI 5 however, {{applications}} and engines do not directly {{communicate with each}} other. Instead, each talks to a <b>runtime</b> <b>component</b> (sapi.dll). There is an API implemented by this component which applications use, and another set of interfaces for engines.|$|E
50|$|Database Web Services (DBWS) {{facilitates}} {{access to}} relational databases {{with the help}} of web service. A database access can be made without the need to write a Java code. The XML SOAP Messages and the databases are connected by the <b>runtime</b> <b>component</b> of DBWS which uses EclipseLink.|$|E
5000|$|Another {{restriction}} is {{that any}} public classes or interfaces you expose can’t be generic. Polymorphism isn’t available to WinRT types, and the closest you can come is implementing WinRT interfaces; you must declare as sealed any classes that are publicly exposed by your Windows <b>Runtime</b> <b>Component.</b>|$|E
5000|$|Windows <b>Runtime</b> <b>Components</b> - Windows <b>Runtime</b> <b>Components</b> in a [...]NET World ...|$|R
50|$|<b>Runtime</b> <b>components</b> - e.g. sapi.dll.|$|R
50|$|This {{consists}} of the <b>runtime</b> <b>components</b> for business rules and business events.|$|R
50|$|The <b>runtime</b> <b>component</b> of TopLink is {{provided}} by the EclipseLink Core. This API provides direct access to the runtime, which is embedded into the application. Persistence behavior is enabled by making application calls that invoke EclipseLink API to perform these functionalities which provides safe access to shared databases.|$|E
50|$|BIRT has {{two main}} {{components:}} a visual report designer within the Eclipse IDE for creating BIRT Reports, and a <b>runtime</b> <b>component</b> for generating reports {{that can be}} deployed to any Java environment. The BIRT project also includes a charting engine that is both fully integrated into the report designer {{and can be used}} standalone to integrate charts into an application.|$|E
5000|$|Avoids lock-in: Roo can be rapidly {{removed from}} a user project, which is useful to protect against vendor lock-in. This is {{possible}} {{because there is no}} <b>runtime</b> <b>component</b> to remove, @Roo annotations are [...] "source retention" [...] only (ensuring they are not preserved in compiled *.class files) and Roo's AspectJ inter-type declarations can be [...] "pushed in" [...] to standard *.java compilation units.|$|E
50|$|It {{integrates}} and certifies both tooling and <b>runtime</b> <b>components</b> {{by combining}} Eclipse, Eclipse Tooling, and the JBoss Enterprise Application Platform.|$|R
25|$|MDAC 1.5c: fixed {{issues with}} ADO {{threading}} and ODBC Connection Pooling and was distributed via the Microsoft website. It only {{came with the}} ADO/MDAC <b>runtime</b> <b>components.</b>|$|R
50|$|Sun Java {{application}} server 9.1(GlassFish V2) {{is used as}} Java CAPS runtime environment and its admin console {{can be used for}} management and administration of Java CAPS <b>runtime</b> <b>components.</b>|$|R
50|$|Propel's primary {{function}} {{is to provide a}} mapping between PHP classes and database tables. To accomplish this Propel includes a generator component which uses source code generation to build PHP classes based on a datamodel definition written in XML. Propel also includes a <b>runtime</b> <b>component</b> which manages connections, transactions, and any idiosyncratic rules that describe the workings of the RDBMS being used with Propel.|$|E
50|$|The Colony Framework is an {{open source}} plugin {{framework}} specification. Implementations of the specification offer a <b>runtime</b> <b>component</b> model, that allows for plugins to be installed, started, stopped, updated and uninstalled without requiring the application container to be stopped. The specification relies heavily on the Inversion of control principle, {{in order to make}} it easier for application components to discover and interact with each other.|$|E
50|$|Typically in SAPI 5 {{applications}} issue calls {{through the}} API (for example to load a recognition grammar; start recognition; or provide text to be synthesized). The sapi.dll <b>runtime</b> <b>component</b> interprets these commands and processes them, where necessary {{calling on the}} engine through the engine interfaces (for example, the loading of a grammar from a file {{is done in the}} runtime, but then the grammar data is passed to the recognition engine to actually use in recognition). The recognition and synthesis engines also generate events while processing (for example, to indicate an utterance has been recognized or to indicate word boundaries in the synthesized speech). These pass in the reverse direction, from the engines, through the runtime dll, and on to an event sink in the application.|$|E
5000|$|Windows Phone 8.1 uses {{a version}} of the Windows Runtime named the Windows Phone Runtime. It enables {{developing}} applications in C# and VB.NET, and Windows <b>Runtime</b> <b>components</b> in C++/CX.|$|R
5000|$|No runtime: Roo {{does not}} provide a runtime API or require {{specific}} <b>runtime</b> <b>components.</b> This ensures there is no Roo-related CPU, memory and disk storage resource consumption at runtime. Roo code is optimized for small-footprint cloud deployment and high scalability use cases.|$|R
40|$|In {{the present}} work we {{put forward a}} {{proposal}} on how to deconstruct a SOFA 2 <b>component</b> <b>runtime</b> environment. The {{first part of the}} text is dedicated to description of its logical parts fand their interconnections. It includes description of the subsidiary program parts (repository, dock manager, global connector manager, dock) essential for launching an arbitrary component architecture which binds additional <b>runtime</b> <b>components</b> (component content, microcomponents, connectors) described further on in the text. The second part deals with the question of how a specific component architecture influences presence of these <b>runtime</b> <b>components.</b> Their constitution, bindings and dependencies are investigated based on observations of various component applications. Common traits are captured in a unifying concept which will open the door to making the target runtime environment for concrete component architecture more configurable and lightweight. The third part of the text proves the feasibility of the proposed concept. OSGi bundles are used to implement the runtime environments of the component applications investigated {{in the second part of}} the text demonstrating correctness of the proposed concept. The final part summarises the results of the text and presents possible ways how to continue in this work...|$|R
50|$|There are current {{efforts to}} include dynamic terrain {{capabilities}} in One Semi-Automated Forces (OneSAF). The OneSAF Environment <b>Runtime</b> <b>Component</b> (ERC) updates {{presented in the}} 2009 OneSAF Users Conference mention that OneSAF 4.0 will include support for terrain deformation such as craters, tank defilades, infantry trenches, and breach holes in walls. OneSAF's dynamic terrain implementation will use a server to resolve dynamic terrain requests. The U.S. Army Research, Development, and Engineering Command (RDECOM) Simulation and Training Technology Center (STTC) is sponsoring {{the development of the}} Shared Architecture for Dynamic Environment (SHADE). SHADE will provide a framework to receive events, calculate effects, and transmit dynamic environment changes to participating applications. These efforts will seek to address the dynamic terrain capability gap in modeling and simulation identified by the U.S. Army Training And Doctrine Command (TRADOC) Intelligence Support Activity (TRISA).|$|E
40|$|Online modular {{adaptation}} and self-adaptation techniques have demonstrated significant benefits in coarse-grained software, enabling agile and high-performance deployments. We {{are studying the}} same kinds of runtime adaptation applied to fine-grained software such as graphical user interfaces and web server implementations. However, this kind of software is defined by pervasive use of behaviourally-driven structure. Existing <b>runtime</b> <b>component</b> models fail to capture this necessity due to their exclusive reliance on externally-driven structural composition. In this paper we present a novel <b>runtime</b> <b>component</b> model that both satisfies the need to externally manage software structure, enabling runtime {{adaptation and}} self-adaptation, while also satisfying the need for fine-grained software to create elements of its own structure based on application-specific system behaviour. We present the key details of our model along with an initial evaluation...|$|E
40|$|In this paper, we {{describe}} an Aspect Oriented extension to the verification tool Java Monitoring and Checking (Java-MaC) [1]. This approach generates AspectJ aspects from Java-MaC specifications. We then use these aspects {{to monitor the}} program during execution [2]. To demonstrate the described approach, we apply it to a “benchmark ” from formal methods research [3], a safety-critical railroad crossing system composed of a train, a gate and a controller. In this system, the gate must be down while the train is crossing and up when no train is crossing. The Java-MaC framework allows users to specify system states to be monitored, define high-level events based on run-time system states, and describe correctness properties in terms of high-level events. The framework uses a <b>runtime</b> <b>component</b> called a filter to track the collection of probes inserted into the target program and a separate <b>runtime</b> <b>component</b> called an event recognizer to detect events from the state information received from the filter. The Meta-Event Definition Language (MEDL) {{is based on an}} extension of linear-time temporal logic and is used to express a large subset of safety properties of systems, including real-time properties such as “when a train is crossing, th...|$|E
2500|$|Windows Workflow Foundation is a Microsoft {{technology}} for defining, executing and managing workflows. This technology {{is part of}} [...]NET Framework 3.0 and therefore targeted primarily for the Windows Vista operating system. The Windows Workflow Foundation <b>runtime</b> <b>components</b> provide common facilities for running and managing the workflows and can be hosted in any CLR application domain.|$|R
50|$|Windows Phone 8 {{has limited}} support for {{developing}} and consuming Windows <b>Runtime</b> <b>components</b> through Windows Phone Runtime. Many of the Windows Runtime APIs in Windows 8 that handle core operating system functions have been ported to Windows Phone 8. Support for developing native games using C++/CX and DirectX has been added, by {{request from the}} game development industry.|$|R
40|$|This thesis has {{developed}} a Temporal Meta-Model Framework for semi-automated Enterprise System Development, which can help drastically reduce the time and cost to develop, deploy and maintain Enterprise Information Systems throughout their lifecycle. It proposes that the analysis and requirements gathering can also perform {{the bulk of the}} design phase, stored and available in a suitable model which would then be capable of automated execution with the availability of a set of specific <b>runtime</b> <b>components...</b>|$|R
40|$|OpenCOM v 2 is our {{experimental}} language-independent component-based systems-building technology. OpenCOM {{offers more}} than merely a component-based programming model. First, it is a <b>runtime</b> <b>component</b> model and supports dynamic runtime reconfiguration of systems (i. e. one can load, unload, bind, and rebind components at runtime). Second, it explicitly supports the deployment of the model {{in a wide range}} of `deployment environments' (e. g. operating systems, PDAs, embedded devices, network processors). Third, it allows the particularities of different deployment environments to be selectively hidden from/ made visible to the OpenCOM programmer without inherent performance overhead...|$|E
40|$|In this demonstration, we {{showcase}} {{an integrated}} approach for event-driven process monitoring in the Internet of Services. Our business-oriented development methodology for Complex Event Processing (CEP) utilizes {{the idea of}} the Zachman framework with modeling on different perspectives. Starting with the Business Motivation Model (BMM) on a strategic perspective, an Event Hierarchy with key performance indicators (KPIs), objectives, noticeable situations and reactions is successively built in a top-down approach. The demonstration includes an Eclipse-based prototype for modeling and a <b>runtime</b> <b>component</b> using the open source CEP engine Esper with a seamless integration...|$|E
40|$|This paper {{presents}} {{a new approach}} to building software for embedded systems, based on the use of components in combination with contracts. The contracts specify the non-functional (resource) requirements of the different components in the system. This is especially important in embedded systems, since these systems are resource-constrained. Our approach includes tool support for building embedded software and runtime support using a component system. The tool enables the construction of applications by connecting components and associating contracts to them. The <b>runtime</b> <b>component</b> system is responsible for contract management...|$|E
40|$|Developing {{high-quality}} {{software for}} a modern computer system is no easy task. Performance-critical applications are likely to execute for quadrillions of instructions and operate in a complex environment with multiple <b>runtime</b> <b>components.</b> Moreover, they are increasingly responsible for managing various architectural resources, including power and hardware threads. To battle this complexity, application developers depend increasingly on sophisticated software analysis tools. Although developers can perform mixed static-dynamic analysis completely in software through binary instrumentation, the amount of analysi...|$|R
50|$|DirectX Media <b>runtime</b> <b>components</b> were {{distributed}} {{as part of}} Internet Explorer. DirectX Media SDK and DirectX SDK existed as two separate SDKs until DirectX 6.0. Later on, Microsoft deprecated DirectX Media and integrated DirectShow, the key part of DirectX Media, into DirectX. As of April 2005, DirectShow was removed from DirectX {{and moved to the}} Microsoft Platform SDK instead. DirectX is, however, still required to build the DirectShow samples. DirectShow and its components are to be gradually deprecated in favor of the newer Media Foundation.|$|R
2500|$|Windows Store apps run {{within a}} new set of APIs known as Windows Runtime, which {{supports}} programming languages such as C, C++, Visual Basic [...]NET, C#, along with HTML5 and JavaScript. If written in some [...] "high-level" [...] languages, apps written for Windows Runtime can be compatible with both Intel and ARM versions of Windows, otherwise they are not binary code compatible. Components may be compiled as Windows <b>Runtime</b> <b>Components,</b> permitting consumption by all compatible languages. To ensure stability and security, apps run within a sandboxed environment, and require permissions to access certain functionality, such as accessing the Internet or a camera.|$|R
40|$|Achieving a clean {{separation}} of concerns {{is a well}} known approach to improving system adaptability and evolution. We propose to apply this principle to run-time reconfigurable component models for networked embedded systems. By separating configuration properties from <b>runtime</b> <b>component</b> instances, we achieve: (i) improved support for concurrent component use, (ii) optimized resource use, and (iii) reduced effort in runtime configuration management. We demonstrate how this approach can be seamlessly implemented on existing component models for wireless sensor networks without imposing additional constraints and without changes to their API or coordination model. Furthermore, significant memory savings are achieved in concurrent scenarios. status: publishe...|$|E
40|$|Towards {{automatic}} {{mediation of}} OWL-S process models ∗ The framework for automatic mediation of two process models composed of semantically annotated web services is presented. Process mediation is hard because of many possible mismatches between process models. We introduce algorithms {{for the process}} models analysis to find possible mappings between provider’s and requester’s process models, or to identify incompatibilities that cannot be reconciled with given set of available data mediators and external services. Results of the analysis phase {{are used in the}} mediator <b>runtime</b> <b>component.</b> In particular, we show how the workflow and dataflow mismatches can be resolved. ...|$|E
40|$|These server {{applications}} provide runtime {{support for}} IMS-LD Units of Learning, widget based services for Units of Learning, and IMS-QTI. Available under the three clause BSD licence, Copyright TENCompetence Foundation. The used CopperCore service has a GPL license. This is release 1. 3 of the TENCompetence Learning Design Toolkit <b>runtime</b> <b>component.</b> It consists three parts: a) CopperCore service integration layer, including APIS; b) the SLeD player; c) the Wookie Widget server. The source code {{is available from}} SourceForge. The work on this publication has been sponsored by the TENCompetence Integrated Project that is funded by the European Commission's 6 th Framework Programme, priority IST/Technology Enhanced Learning. Contract 027087 [[URL]...|$|E
50|$|The VxWorks Core Platform {{consists}} {{of a set of}} <b>runtime</b> <b>components</b> and development tools. The run time components are an operating system (UP and SMP; 32- and 64-bit), software for applications support (file system, core network stack, USB stack and inter-process communications) and hardware support (architecture adaptor, processor support library, device driver library and board support packages). VxWorks core development tools are compilers such as Diab, GNU, and Intel C++ Compiler (ICC)) and its build and config tools. The system also includes productivity tools such as its Workbench development suite and Intel tools and development support tools for asset tracking and host support.|$|R
5000|$|Windows Store apps run {{within a}} new set of APIs known as Windows Runtime, which {{supports}} programming languages such as C, C++, Visual Basic [...]NET, C#, along with HTML5 and JavaScript. If written in some [...] "high-level" [...] languages, apps written for Windows Runtime can be compatible with both Intel and ARM versions of Windows, otherwise they are not binary code compatible. Components may be compiled as Windows <b>Runtime</b> <b>Components,</b> permitting consumption by all compatible languages. To ensure stability and security, apps run within a sandboxed environment, and require permissions to access certain functionality, such as accessing the Internet or a camera.|$|R
30|$|In a {{previous}} work (Sanchez et al. 2013), we presented a heuristic search algorithm called CSA (Configuration Selection Algorithm) 1 for solving the optimization problem resulting from selecting a valid configuration {{of a system}} based on feature models. This algorithm offers different strategies for leveraging execution efficiency and optimality, and allows us to define different objective functions for comparing configurations and optimizing multiple attributes simultaneously, while adhering to resource restrictions and feature model constraints. However, this algorithm requires an infrastructure with capabilities for: monitoring context changes, activating and assembling (at <b>runtime)</b> <b>components</b> that implement specific features, and gathering suitable metrics for system properties, so as to assess various configuration alternatives.|$|R
