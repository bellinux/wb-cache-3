314|27|Public
50|$|<b>Relational</b> <b>calculus</b> {{consists}} of two calculi, the tuple <b>relational</b> <b>calculus</b> and the domain <b>relational</b> <b>calculus,</b> {{that are part of}} the relational model for databases and provide a declarative way to specify database queries. This in contrast to the relational algebra, which is also part of the relational model but provides a more procedural way for specifying queries.|$|E
5000|$|The <b>relational</b> <b>calculus</b> would {{formulate}} a descriptive, declarative way: ...|$|E
5000|$|DES - An {{educational}} {{tool for}} working with Domain <b>Relational</b> <b>Calculus</b> and other formal languages ...|$|E
40|$|Up to a {{few years}} ago, the {{approaches}} taken to check whether a hardware component works as expected could be classified under one of two styles: hardware engineers in the industry would tend to exclusively use simulation to (empirically) test their circuits, whereas computer scientists would tend to advocate an approach based almost exclusively on formal verification. This thesis proposes a unified approach to hardware design in which both simulation and formal verification can co-exist. <b>Relational</b> Duration <b>Calculus</b> (an extension of Duration Calculus) is developed and used to define the formal semantics of Verilog HDL (a standard industry hardware description language). <b>Relational</b> Duration <b>Calculus</b> is a temporal logic which can deal with certain {{issues raised by the}} behaviour of typical hardware description languages and which are hard to describe in a pure temporal logic. These semantics are then used to unify the simulation of Verilog programs, formal verification and the use of algebraic laws during the design stage...|$|R
40|$|Abstract. Hardware {{description}} languages usually include features {{which do}} not have a direct hardware interpretation. Recently, synthesis algorithms allowing some of these features to be compiled into circuits have been developed and implemented. Using a formal semantics of Verilog based on <b>Relational</b> Duration <b>Calculus,</b> we give a number of algebraic laws which Verilog programs obey, using which, we then prove the correctness of a hardware compilation procedure. ...|$|R
50|$|For example, in the {{relational}} model, the structural part {{is based on}} a modified concept of the mathematical relation; the integrity part is expressed in first-order logic and the manipulation part is expressed using the <b>relational</b> algebra, tuple <b>calculus</b> and domain calculus.|$|R
50|$|<b>Relational</b> <b>calculus</b> is {{essentially}} equivalent to first-order logic, and indeed, Codd's Theorem {{had been known}} to logicians since the late 1940s.|$|E
50|$|In {{computer}} science, domain <b>relational</b> <b>calculus</b> (DRC) is a calculus {{that was}} introduced by Michel Lacroix and Alain Pirotte as a declarative database query language for the relational data model.|$|E
50|$|Codd's Theorem {{is notable}} since it {{establishes}} the equivalence of two syntactically quite dissimilar languages: relational algebra is a variable-free language, while <b>relational</b> <b>calculus</b> {{is a logical}} language with variables and quantification.|$|E
40|$|We {{introduce}} a historical relational data {{model in which}} N 1 NF relations are used and 1 -level of nesting is allowed. Attributes can either be atomic or temporal atom. An atomic attribute represents a time invariant attribute. A temporal atom consists of two components, a value and a temporal set, which {{is a set of}} times denoting the validity period of the value. We define a <b>relational</b> tuple <b>calculus</b> for this model. We follow a comparative approach towards completeness of historical query languages...|$|R
40|$|The {{theoretical}} {{study of}} query languages began with Codd's {{introduction of the}} <b>relational</b> algebra and <b>calculus</b> for at <b>relational</b> databases (Codd 72). It was however quickly real-ized and formally established that many natural queries could not be formulated in these languages (Aho 79). These limitations of rst-order query languages led to the additio...|$|R
40|$|Abstract. In this paper, {{we present}} an ongoing work bridg-ing {{the gap between}} pattern mining, SQL and SAT for a {{particular}} class of patterns. We extend the work presented in [2] that proposes a logical query language for rule patterns satisfying Armstrong’s axioms. Our contributions are the fol-lowing: firstly, we allow {{a large part of}} the <b>relational</b> tuple <b>calculus</b> (SQL) to be used in the specification of queries. Sec-ondly, we propose a boolean encoding of the query that can be used to compute answers even in the case of non Armstrong-compliant queries. Some experiments have been performed on top of Derby (embedded Java DBMS) and a modified version of MiniSat to show the feasibility of the approach. ...|$|R
5000|$|The domain {{independent}} <b>relational</b> <b>calculus</b> {{queries are}} precisely those <b>relational</b> <b>calculus</b> queries that are invariant under choosing domains of values beyond those {{appearing in the}} database itself. That is, queries that may return different results for different domains are excluded. An {{example of such a}} forbidden query is the query [...] "select all tuples other than those occurring in relation R", where R is a relation in the database. Assuming different domains, i.e., sets of atomic data items from which tuples can be constructed, this query returns different results and thus is clearly not domain independent.|$|E
50|$|The {{relational}} algebra and the <b>relational</b> <b>calculus</b> are essentially logically equivalent: for any algebraic expression, {{there is an}} equivalent expression in the calculus, and vice versa. This result is known as Codd's theorem.|$|E
50|$|Codd's theorem, {{a result}} proven in his seminal {{work on the}} {{relational}} model, equates the expressive power of relational algebra and <b>relational</b> <b>calculus</b> (both of which, lacking recursion, are strictly less powerful than first-order logic).|$|E
40|$|This paper {{describes}} {{an approach to}} On Line Analytical Processing (OLAP), expresed in the declarative programming paradigm. We define a collection of functions that capture some of the functionality currently provided by multidimensional database product. This is done by defining operations which allow for classifying and reducing relations (tables). Suitably combined, these operations will make possible {{to carry out the}} multidimensional analysis of a relational database, and make possible the declarative specification and optimization of multidimensional database queries. The library works over an abstract model of the <b>relational</b> database <b>calculus</b> as defined by Maier, written in the style of model-oriented formal specification in the functional language Haskell (details can be found in [8]...|$|R
40|$|AbstractWe {{consider}} a while loop on some space S {{and we are}} interested in deriving the function that this loop defines between its initial states and its final states (when it terminates). Such a capability is useful {{in a wide range of}} applications, including reverse engineering, software maintenance, program comprehension, and program verification. In the absence of a general theoretical solution to the problem of deriving the function of a loop, we explore engineering solutions. In this paper we use a <b>relational</b> refinement <b>calculus</b> to approach this complex problem in a systematic manner. Our approach has many drawbacks, some surmountable and some not (being inherent to the approach); nevertheless, it offers a way to automatically derive the function of loops or an approximation thereof, under some conditions...|$|R
40|$|We {{consider}} {{the representation of}} temporal data based on tuple and attribute timestamping. We identify the requirements in modeling temporal data and elaborate on their implications in the expressive power of temporal query languages. We introduce a temporal relational data model where N 1 NF relations and attribute timestamping are used and one level of nesting is allowed. For this model, a nested <b>relational</b> tuple <b>calculus</b> (NTC) is defined. We follow a comparative approach in evaluating the expressive power of temporal query languages, using NTC as a metric and comparing it with the existing temporal query languages. We prove that NTC subsumes the expressive power of these query languages. We also demonstrate how various temporal relational models {{can be obtained from}} our temporal relations by NTC and give equivalent NTC expressions for their languages. Furthermore, we show the equivalence of intervals and temporal elements (sets) as timestamps in our model. © 1997 IEEE...|$|R
50|$|The {{relational}} model, {{as expressed}} through <b>relational</b> <b>calculus</b> and relational algebra, does {{not distinguish between}} primary keys {{and other kinds of}} keys. Primary keys were added to the SQL standard mainly as a convenience to the application programmer.|$|E
50|$|Codd's theorem {{states that}} {{relational}} algebra and the domain-independent <b>relational</b> <b>calculus</b> queries, two well-known foundational query languages for the relational model, are precisely equivalent in expressive power. That is, a database query can be formulated in one language if {{and only if}} it can be expressed in the other.|$|E
50|$|Conjunctive queries without {{distinguished}} {{variables are}} called boolean conjunctive queries. Conjunctive queries where all variables are distinguished (and no variables are bound) are called equi-join queries, {{because they are}} the equivalent, in the <b>relational</b> <b>calculus,</b> of the equi-join queries in the relational algebra (when selecting all columns of the result).|$|E
40|$|Traditional {{database}} query {{languages are}} based on set theory and crisp logic. Many applications, however, need similarity or retrieval-like queries producing results with truth values from the interval [0, 1]. Such truth values {{can be regarded as}} continuous membership values of tuples expressing how strongly a query is matched. Formulating queries by applying existing similarity relational algebras means to express the user’s need in a procedural manner. In order to support a declarative way of formulating queries, we generalize the classical <b>relational</b> domain <b>calculus</b> by incorporating fuzzy operations and user weights. Besides defining syntax and semantics we show how to map any calculus expression onto a corresponding similarity algebra expression. In this way, we present a theoretical foundation for a declarative query language combining retrieval functionality and Queries in multimedia databases often need a combination of information retrieval mechanisms and traditional database query language constructs. Retrieval functionality is required if a query contains a similarity predicate, e. g. the query: ≫Retrieve all images that are simila...|$|R
40|$|We {{show how}} and why {{it makes sense to}} use a {{relational}} formalisation instead of the usual functional one in the treatment of term graphs. Special attention is paid to term graphs with bound variables, that have, to our knowledge, never been formalised with such a generality before. Besides the novel treatment of term graphs themselves, we present an innovative relational homomorphism concept {{that for the first time}} allows to consider terms, resp. term trees as a special case of term graphs and still have the full power of (second-order) substitution available. Keywords : Term graph rewriting, <b>relational</b> matching, relation <b>calculus,</b> #-calculus...|$|R
40|$|Abstract. Recently {{there has}} been much {{interest}} in using ontologies to facilitate knowledge representation, integration, and reasoning. Correspondingly, the extent of the information embodied by an ontology is increasing beyond the conventional is_a and part_of relationships. To address these requirements, a vast amount of digitally available information may need to be considered when building ontologies, prompting a desire for software tools to automate {{at least part of the}} process. The main efforts in this direction have involved textual information retrieval and extraction methods. For some domains extension of the basic relationships could be enhanced further by the analysis of 2 D and/or 3 D images. For this type of media, image processing algorithms are more appropriate than textual analysis methods. Herein we present an algorithm that, given a collection of 3 D image files, utilizes Qualitative Spatial Reasoning (QSR) to automate the creation of an ontology for the objects represented by the images, relating the objects in terms of is_a and part_of relationships and also through unambiguous <b>Relational</b> Connection <b>Calculus</b> (RCC) relations...|$|R
5000|$|Queries {{made against}} the {{relational}} database, and the derived relvars {{in the database}} are expressed in a <b>relational</b> <b>calculus</b> or a relational algebra. In his original relational algebra, Codd introduced eight relational operators in two groups of four operators each. The first four operators {{were based on the}} traditional mathematical set operations: ...|$|E
50|$|Originally {{based upon}} {{relational}} algebra and tuple <b>relational</b> <b>calculus,</b> SQL {{consists of a}} data definition language, data manipulation language, and data control language. The scope of SQL includes data insert, query, update and delete, schema creation and modification, and data access control. Although SQL is often described as, and {{to a great extent}} is, a declarative language (4GL), it also includes procedural elements.|$|E
50|$|Rascal is an {{experimental}} domain specific language for metaprogramming, such as static code analysis, program transformation {{and implementation of}} domain specific languages. It is a general meta language {{in the sense that}} it does not have a bias for any particular software language. It includes primitives from <b>relational</b> <b>calculus</b> and term rewriting. Its syntax and semantics are based on procedural (imperative) and functional programming.|$|E
40|$|The {{sort-merge}} {{technique for}} evaluating <b>relational</b> algebra and <b>calculus</b> expressions was advocated very early {{and is a}} very widely used implementation technique. We present an algorithm for query analysis prior to execution {{with the aim of}} determining sort orders for every subexpression {{in such a way that}} resorting can be avoided during the actual evaluation. We prove that our algorithm will find such a sohltion, if one exists. In that case, we get tile additional benefit of perfect pipelining, which implies that we do not have to save temporary resuits of evaluating subexpressions. Tile algorithm's running time is quadratic in the size of the expression...|$|R
40|$|Abstract. The <b>relational</b> algebra and <b>calculus</b> do {{not take}} the {{semantics}} of terms into account when answering queries. As a consequence, not all tuples that should be returned {{in response to a}} query are always returned, leading to low recall. In this paper, we propose the novel notion of a constrained probabilistic ontology (CPO). We developed the concept of a CPO-enhanced relation in which each attribute of a relation has an associated CPO. These CPOs describe relationships between terms occurring in the domain of that attribute. We show that the relational algebra can be extended to handle CPO-enhanced relations. This allows queries to yield sets of tuples, each of which has a probability of being correct. ...|$|R
40|$|Codd [Codd 1970] {{wrote the}} first paper in which the model of a {{relational}} database was proposed. Adleman [Adleman 1994] {{wrote the first}} paper in which DNA strands in a test tube were used to solve an instance of the Hamiltonian path problem. From [Adleman 1994], it is obviously indicated that for storing information in molecules of DNA allows for an information density of approximately 1 bit per cubic nm (nanometer) and a dramatic improvement over existing storage media such as video tape which store information at a density of approximately 1 bit per 1012 cubic nanometers. This paper demonstrates that biological operations {{can be applied to}} construct bio-molecular databases where data records in relational tables are encoded as DNA strands. In order to achieve the goal, DNA algorithms are proposed to perform eight operations of <b>relational</b> algebra (<b>calculus)</b> on bio-molecular <b>relational</b> databases, which include Cartesian product, union, set difference, selection, projection, intersection, join and division. Furthermore, this work presents clear evidence of the ability of molecular computing to perform data retrieval operations on bio-molecular relational databases. Comment: The article includes 35 pages, several tables and figure...|$|R
50|$|A first {{declarative}} {{query language}} suitable for multiple dimensions {{and with an}} algebra-based semantics has been published by Baumann, together with a scalable architecture. Another array database language, constrained to 2-D, has been presented by Marathe and Salem. Seminal theoretical work has been accomplished by Libkin et al.; in their model, called NCRA, they extend a nested <b>relational</b> <b>calculus</b> with multidimensional arrays; among the results are important contributions on array query complexity analysis. A map algebra, suitable for 2-D and 3-D spatial raster data, has been published by Mennis et al.|$|E
5000|$|A {{substantial}} {{fragment of}} SQL (namely {{that which is}} effectively relational algebra) is based on first-order logic (more precisely can be translated in domain <b>relational</b> <b>calculus</b> by means of Codd's theorem), as the following example illustrates: Think of a database table [...] "GIRLS" [...] with the columns [...] "FIRST_NAME" [...] and [...] "LAST_NAME". This corresponds to a binary relation, say G(f, l) on FIRST_NAME X LAST_NAME. The FO query {l : G('Judy', l)}, which returns all the last names where the first name is 'Judy', would look in SQL like this: ...|$|E
5000|$|A view can {{be defined}} by an {{expression}} using the operators of the relational algebra or the <b>relational</b> <b>calculus.</b> Such an expression operates on one or more relations and when evaluated yields another relation. The result is {{sometimes referred to as}} a [...] "derived" [...] relation when the operands are relations assigned to database variables. A view is defined by giving a name to such an expression, such that the name can subsequently be used as a variable name. (Note that the expression must then mention at least one base relation variable.) ...|$|E
40|$|Several {{proposals}} for extending the relational data model {{to incorporate the}} temporal dimension of data {{have appeared in the}} past several years. These proposals have differed considerably {{in the way that the}} temporal dimension has been incorporated both into the structure of the extended relations that are defined as part of these extended model, and into the operations of the extended <b>relational</b> algebra or <b>calculus</b> component of the models. Because of these differences it has been difficult to compare the proposed models and to make judgements as to which of them is "better" or indeed, the "best. " In this paper we propose a notion of historical relational completeness, analogous to Codd's notion of relational completeness, and examine several historical relational proposals in light of this standard. ...|$|R
40|$|Abstract-The {{purpose of}} this {{correspondence}} is to present an approach for verifying that explicitly stated integrity constraints are not violated by certain transactions. We utilize a relational model wherein constraints are given in a language based on fthe first-order predicate calculus. Transactions are written {{in terms of a}} Pascal-likehost language with embedded first-order predicate calculus capabilities allowing queries and updates. The technique for proving consistency of the transactions is based upon the Hoare axiomatic approach. We illustrate the method by means of an explicit example of a database updated by four types of transaction. A generalized transaction consistency verifier embodying this approach would considerably enhance transaction programming in a relational database management system. Index Terms-Consistency, correctness proof, integrity constraint, predicate <b>calculus,</b> <b>relational</b> database, transaction. I...|$|R
50|$|Tuple {{calculus}} is a calculus {{that was}} introduced by Edgar F. Codd {{as part of the}} relational model, in order to provide a declarative database-query language for this data model. It formed the inspiration for the database-query languages QUEL and SQL, of which the latter, although far less faithful to the original <b>relational</b> model and <b>calculus,</b> is now the de facto standard database-query language; a dialect of SQL is used by nearly every relational-database-management system. Lacroix and Pirotte proposed domain calculus, which is closer to first-order logic and together with Codd showed that both of these calculi (as well as relational algebra) are equivalent in expressive power. Subsequently, query languages for the relational model were called relationally complete if they could express at least all of these queries.|$|R
