11|246|Public
50|$|The <b>RAM</b> <b>Block</b> 2 is an {{upgraded}} {{version of the}} RAM missile aimed at more effectively countering more maneuverable anti-ship missiles through a four-axis independent control actuator system, increased rocket motor capability, an improved passive radio frequency seeker and upgraded components of the infrared seeker, and advanced kinematics. On 8 May 2007, the US Navy awarded Raytheon Missile Systems a $105 million development contract; development {{was expected to be}} completed by December 2010. LRIP began in 2012. 51 missiles were initially ordered. On 22 October 2012, the <b>RAM</b> <b>Block</b> 2 completed its third guided test vehicle flight, firing two missiles in a salvo and directly hitting the target, to verify the system's command and control capabilities, kinematic performance, guidance system, and airframe capabilities. Raytheon was scheduled to deliver 25 Block 2 missiles during the program's integrated testing phase. The Block 2 RAM was delivered to the U.S. Navy in August 2014, with 502 missiles to be acquired from 2015 to 2019. Initial Operational Capability (IOC) for the Block 2 RAM was achieved on 15 May 2015.|$|E
50|$|On 23 March 2011, BOEMRE and the Coast Guard {{published}} the forensic examination report prepared by U.S. Det Norske Veritas (DNV) Columbus, the contractor that performed the examination. The report {{concluded that the}} primary cause of failure was that the blind shear rams failed to fully close and seal due to a portion of drill pipe trapped between the shearing blocks. This happened because the drill pipe elastically buckled within the wellbore due to forces induced on the drill pipe during loss of well control, consequently, drill pipe in process of shearing was deformed outside the shearing blade surfaces, and, consequently, the blind shearing rams were not able to move the entire pipe cross section into the shearing surfaces of the blades. Therefore, oil continued to flow through the drill pipe trapped between the <b>ram</b> <b>block</b> faces and subsequently through the gaps between the ram blocks. Since the pipe buckled when well control was lost, the blind shear rams would have failed to function as planned no matter when they were made active.|$|E
40|$|A Josephson 256 -word x 16 -bit RAM that {{includes}} a power circuit has been developed to enable high-frequency clock operation. This RAM consists of a 4 x 4 matrix array of 256 RAM blocks, impedance matching lines, and signal amplifiers. A power-supply circuit, composed of a transformer and a Josephson regulator, is included in each 256 <b>RAM</b> <b>block.</b> Fail bit maps for the 256 <b>RAM</b> <b>block</b> were measured, and perfect operation with a 100 % bit yield was obtained. The 256 <b>RAM</b> <b>block</b> functioned up to a clock frequency of 1. 07 GHz. We succeeded in feeding a large high-frequency current of more than 2 A into the entire 256 -word x 16 -bit RAM. The 256 -word x 16 -bit RAM therefore functioned up to a clock frequency of 620 MHz. I. INTRODUCTION Many Josephson RAMs have been developed [1]-[6]. However, RAM operation at a clock frequency of about 1 GHz has not been actually realized, because high-frequency powering for large currents reaching several amperes is very difficult. Therefore, a powering circuit suppl [...] ...|$|E
50|$|<b>Rams,</b> or <b>ram</b> <b>blocks,</b> are of four common types: pipe, blind, shear, {{and blind}} shear.|$|R
40|$|A Low-Density Parity-Check Convolutional Code (LPDCCC) decoder (10) for partial {{parallel}} decoding of low-density parity-check convolutional codes, the decoder having: {{a plurality}} of pipeline processors (11) to receive channel messages and edge-messages; each processor (11) having: {{a plurality of}} block processing units (BPUs) (13), each BPU (13) having a plurality of check node processors (CNPs) (14) to process check nodes that enter into the processor (11) and a plurality of variable node processors (VNPs) (15) to process variable nodes that are about to leave the processor (11); and a plurality of Random Access Memory (<b>RAM)</b> <b>blocks</b> (30) for dynamic message storage of the channel messages and the edge-messages; wherein in each processor (11), the VNPs (15) are directly connected to corresponding <b>RAM</b> <b>blocks</b> (30), and the CNPs (14) are directly connected to corresponding <b>RAM</b> <b>blocks</b> (30) such that the connections from the VNPs (15) and CNPs (14) to the corresponding <b>RAM</b> <b>blocks</b> (30) are pre-defined and fixed according to a parity-check matrix of an unterminated time-varying periodic LDPCCC. Department of Electronic and Information EngineeringUS 8671323; US 8671323 B 2; US 8671323 B 2; US 8, 671, 323; US 8, 671, 323 B 2; 8671323; Appl. No. 13 / 371, 067 U...|$|R
5000|$|The <b>RAM</b> <b>blocked</b> a {{road near}} El Maitén, and were {{dispersed}} by the Argentine National Gendarmerie. Santiago Maldonado, {{a member of}} this organization, was reported missing after that. The group made then their first attack in Buenos Aires, vandalizing the [...] "Casa de Chubut" [...] building.|$|R
30|$|The CBC, block 7 of {{the model}} is simply a bridge that connects the L 2 shared cache to the FSB [13]. This FSB then {{continues}} the link to the <b>RAM</b> (<b>block</b> 9) from which accesses are made and the data/instruction read {{is sent to the}} core that requested the data. The CBC model is developed using the VisualSim scripting language and simulates the exact functionality of a typical controller.|$|E
30|$|In {{the above}} model, the two large blocks {{numbered}} 4 and 5, respectively, are the Processor cores connected via bus ports (blocks 6) to the System Request Queue (block 7), {{and then to}} the Crossbar switch (block 8). The Crossbar switch connects the cores to the <b>RAM</b> (<b>block</b> 9) and is programmed to route the incoming data structure to the specified destination and then send the reply back to the requesting core.|$|E
40|$|This paper {{describes}} architectural enhancements in the Altera Stratix-V ™ FPGA architecture, {{built on}} a 28 nm TSMC process, together with the data supporting those choices. Among the key features are time borrowing flip-flops, a doubling {{of the number of}} flip-flops per LUT compared to previous Stratix architectures, a simplified embedded 20 kb dual-port <b>RAM</b> <b>block,</b> and error correction that can correct up to 8 adjacent errors. Arithmetic performance is significantly improved using a fast adder with two levels of multi-bit skip. We also describe how the routing architecture and layout is optimized for the 28 nm process {{to take advantage of a}} wider range of wire thicknesses offered on the different layers, and improvements in performance and routability are obtained without dramatic changes to the repeated floorplan of the logic plus routing fabric...|$|E
40|$|Developers {{accelerating}} applications on FPGAs {{or other}} reconfigurable logic {{have nothing but}} raw memory devices in their standard toolkits. Each project typically includes tedious development of single-use memory management. Software developers expect a programming environment to include automatic memory management. Virtual memory provides the illusion of very large arrays and processor caches reduce access latency without explicit programmer instructions. LEAP scratchpads for reconfigurable logic dynamically allocate and manage multiple, independent, memory arrays in a large backing store. Scratchpad accesses are cached automatically in multiple levels, ranging from shared on-board, RAM-based, set-associative caches to private caches stored in FPGA <b>RAM</b> <b>blocks.</b> In the LEAP framework, scratchpads share the same interface as on-die <b>RAM</b> <b>blocks</b> and are plug-in replacements. Additional libraries support heap management within a storage set. Like software developers, accelerator authors using scratchpads may focus more on core algorithms and less on memory management. Two uses of FPGA scratchpads are analyzed: buffer management in an H. 264 decoder and memory management within a processor microarchitecture timing model. CORRECTION: The authors for entry [4] in the references should have been "E. S. Chung, J. C. Hoe, and K. Mai"...|$|R
40|$|Abstract—This paper {{proposes a}} low power {{commutator}} architecture {{for the implementation}} of radix- 4 based pipelined Fast Fourier Transform processor. The architecture is based on dual port <b>RAM</b> <b>blocks</b> and exploits the interconnection topology among these blocks for low power implementation. The paper presents the commutator architecture, describes the design methodology and evaluation environment, and provides implementation results showing that the new commutator achieves up to 58 % power saving for 256 -point and 128 -point FFTs as compared to previous commutator architectures. I...|$|R
40|$|The use {{of static}} {{random access memory}} (SRAM) -based field {{programmable}} gate arrays (FPGAs) in harsh radiation environments has grown in recent years. These types of programmable devices require special mitigation techniques targeting the configuration memory, the user logic, and the embedded <b>RAM</b> <b>blocks.</b> This article provides a comprehensive survey of the literature published in this rich research field during the past 10 years. Furthermore, it can also serve as a tutorial for space engineers, scientists, and decision makers who need an introduction to this topic. Peer-reviewedPost-prin...|$|R
40|$|Abstract—In this paper, two {{different}} FPGA implementa-tions of the lightweight cipher PRESENT are proposed. The main design strategy for both designs is {{the utilization of}} existing RAM blocks in FPGAs for the storage of internal states, thereby reducing the slice count. In the first design, S-boxes are realized within the slices, while in the second design they are also integrated into the same <b>RAM</b> <b>block</b> used for state storage. Both designs are well suited for lightweight applications, which are implemented on low-cost FPGA/CPLD devices. Besides low-area, a reasonable throughput is also obtained {{even though it is}} not the first concern. In addition to a single block RAM, the two designs occupy only 83 and 85 slices and produce a throughput of 6. 03 and 5. 13 Kbps at 100 KHz system clock on a Xilinx Spartan XC 3 S 50 device, respectively...|$|E
30|$|The {{windmill}} extraction {{was performed}} in oil windmill ‘t Pink (anno 1620) {{in the town of}} Koog aan de Zaan, which has existed in its present form since 1751. Before pressing the flaxseed cultivar Sofie, the windmill was thoroughly cleaned to avoid contamination from earlier pressed linseeds. The expression started with crushing the seeds under the ‘Kollergang’. The crushed seeds (the so-called ‘meal’) were then collected and heated on an iron stove plate (peat bog fuelled), {{with the addition of a}} little water, under constant stirring until the meal was lukewarm. Then the meal was gathered in filter cloths and wrapped in leather sheaths, lined with braided horse hair and placed in the wedge press. The pressing wedge was hammered by the <b>ram</b> <b>block,</b> to build up a pressure between 200 and 300  bar. The oil was then recovered in a stainless-steel container and transferred into one litre transparent glass jars. An approximate volume of 28  l of oil was obtained.|$|E
40|$|Symbol timing {{recovery}} (STR) {{is required in}} every digital synchronous communications receiver, since {{the output of the}} demodulator must be sampled periodically at symbol rate, at the precise sampling time instants in order to correctly recover the transmitted data. The major objective of this thesis is to present, analyze and prove feasibility of the new, low complexity, digital implementation structures for STR. The first presented digital structure is a feedback (FB) symbol {{timing recovery}} technique, which is based on the Costas loop principle. This technique requires only 5 constant multipliers and 7 adders, and has very low jitter feature, which is very desirable for high level modulation techniques. The structure, with its error tracking capabilities, is perfectly applicable for continuous mode communication systems, however, the required long acquisition time, makes this feedback STR not suitable for short burst mode communication systems. The feedforward (FF) STR techniques, have very short acquisition time, thus they are the perfect candidates for the short burst mode communication systems, and two such FF techniques are presented in this thesis as well. The first presented FF technique uses relatively high symbol over-sampling (16 samples per symbol) to achieve low implementation complexity (2 unsigned adders, 1 <b>RAM</b> <b>block,</b> and 1 serial magnitude comparator), and acceptable jitter, with the help of only 4 symbols long training preamble. Due to high over-sampling rate, the technique is only applicable to communication systems with relatively low bit rate. In order to expand the applicability of this new over-sampling, technique to higher bit rate systems, an optional "add-on" interpolation technique is presented, which can effectively reduce the over-sampling rate to a minimum of 3 samples per symbol. The cost for the improved performance is in the increased implementation complexity (additional 3 summers and 1 divider...|$|E
5000|$|Battering <b>Ram</b> (Diving {{shoulder}} <b>block,</b> sometimes while slingshotting) ...|$|R
40|$|Multi-ported RAMs are {{essential}} for high-performance parallel computation systems. VLIW and vector processors, CGRAs, DSPs, CMPs and other processing systems often rely upon multi-ported memories for parallel access, hence higher performance. Although memories {{with a large number}} of read and write ports are important, their high implementation cost means they are used sparingly in designs. As a result, FPGA vendors only provide dual-ported <b>block</b> <b>RAMs</b> to handle the majority of usage patterns. In this paper, a novel and modular approach is proposed to construct multi-ported memories out of basic dual-ported <b>RAM</b> <b>blocks.</b> Like other multi-ported RAM designs, each write port uses a different RAM bank and each read port uses bank replication. The main contribution of this work is an optimization that merges the previous live-value-table (LVT) and XOR approaches into a common design that uses a generalized...|$|R
40|$|A {{technique}} {{estimated to}} decrease risk when developing complex digital ASICs is presented. Specification errors {{as well as}} discrepancy between the product and the specification are addressed. The CMS ECAL FENIX ASIC development [1] is presented as an example. The ASIC features a fully synthesizable and highly testable implementation of triple-redundancy. The <b>RAM</b> <b>blocks</b> are individually tested by a built in self test, and an error correction code is protecting the data integrity during normal operation. The ASIC has been irradiated during operation together with the complete CMS ECAL front end system, and a preliminary result is presented. I...|$|R
40|$|This Master Thesis {{describe}} how DVB-S 2 Forward Error Correction (FEC) encoding {{can be implemented}} in hardware like a FPGA. It include the design, simulation, verification and synthesis of a complete encoder for the DVB-S 2 FEC system. First the Thesis gives a introduction to the history behind DVB-S 2 and the FEC system. It describe shortly the theory behind the error correcting codes used in the FEC, BCH and LDPC codes. To get an effective implementation in hardware {{it was necessary to}} studies different papers and articles for efficient encoding of BCH and LDPC codes. Since the SystemC simulator for DVB-S 2 FEC Encoder that was developed in a earlier project assignment contained errors it was necessary to fix that but also include some expansion. It was necessary to do a more detailed verification of the simulator as well. The main contribution in this Thesis is the design, simulation and verification of a DVB-S 2 FEC Encoder described in VHDL code. It gives a description {{for each of the three}} modules (BCH, LDPC and Interleaver) that is included and the result from the simulation and verification. The final step in this Thesis was to synthesis the encoder and confirm that it should be possible to be implemented in a FPGA. The DVB-S 2 FEC encoder has been designed using VHDL code in a way that the author thinks is the most effective way from the available papers and articles. The encoder is verified by simulation in Modelsim where the result is compared with a reference created in the SystemC simulator. During the simulation of the encoder several frames (up to 100 frames per rate) where encoded and compared with a reference and no dissimilarities where found. Almost all modules in the encoder is not platform specific except one sub module in LDPC Encoder (Lookup Table). That lead to that only one FPGA vendor is used during simulation/verification and synthesis. The chosen vendor is Xilinx since that was the type FPGA the author is most familiar with. When compare the synthesis result for this encoder against other available encoders on the marked the areal (slices) this encoder uses is half of what the other encoders use but when comparing RAM usage this encoder is not so effective as the others. The maximal clock frequency for the encoder implemented into a Virtex 4 FPGA from Xilinx is achieve when using ISE as a synthesis tool. The result was 227 MHz with the speedgrade set to - 12 (the best speedgrade) and when using a Virtex 5 FPGA the maximal clock frequency was even higher (290 MHz). Since the encoder is capable to encode one bit per clock cycle the bitrate become the same as maximal clock frequency. It must be mention that the maximal clock frequency is only a estimate after synthesis, for accurate timing information Place and Route must be performed. The one thing that not have been done according to the problem description is testing on FPGA hardware. Due to limited time and shortage of FPGA evaluation kits this was not possible to be executed. As a final conclusion the author means that the implementation was successful although it was not physical tested in a FPGA. The speed requirement is fulfilled and the required slice areal is half of what other encoders use but the <b>RAM</b> <b>Block</b> usage is higher. </p...|$|E
40|$|Lee Chi-wai. Thesis (M. Phil.) [...] Chinese University of Hong Kong, 2002. Includes bibliographical {{references}} (leaves 191 - 196). Abstracts in English and Chinese. Abstract of {{this thesis}} entitled: [...] - p. i摘要 [...] - p. iiiAcknowledgements [...] - p. vTable of Contents [...] - p. viiList of Tables [...] - p. xList of Figures [...] - p. xiChapter Chapter 1 [...] - Introduction [...] - p. 1 Chapter 1. 1 [...] - Synchronous Design [...] - p. 1 Chapter 1. 2 [...] - Asynchronous Design [...] - p. 2 Chapter 1. 3 [...] - Discrete Cosine Transform [...] - p. 4 Chapter 1. 4 [...] - Motivation [...] - p. 5 Chapter 1. 5 [...] - Organization of the Thesis [...] - p. 6 Chapter Chapter 2 [...] - Asynchronous Design Methodology [...] - p. 7 Chapter 2. 1 [...] - Overview [...] - p. 7 Chapter 2. 2 [...] - Background [...] - p. 8 Chapter 2. 3 [...] - Past Designs [...] - p. 10 Chapter 2. 4 [...] - Micropipeline [...] - p. 12 Chapter 2. 5 [...] - New Asynchronous Architecture [...] - p. 15 Chapter Chapter 3 [...] - DCT/IDCT Processor Design Methodology [...] - p. 24 Chapter 3. 1 [...] - Overview [...] - p. 24 Chapter 3. 2 [...] - Hardware Architecture [...] - p. 25 Chapter 3. 3 [...] - DCT Algorithm [...] - p. 26 Chapter 3. 4 [...] - Used Architecture and DCT Algorithm [...] - p. 30 Chapter 3. 4. 1 [...] - Implementation on Programmable DSP Processor [...] - p. 31 Chapter 3. 4. 2 [...] - Implementation on Dedicated Processor [...] - p. 33 Chapter Chapter 4 [...] - New Techniques for Operating Dynamic Logic in Low Frequency [...] - p. 36 Chapter 4. 1 [...] - Overview [...] - p. 36 Chapter 4. 2 [...] - Background [...] - p. 37 Chapter 4. 3 [...] - Traditional Technique [...] - p. 39 Chapter 4. 4 [...] - New Technique - Refresh Control Circuit [...] - p. 40 Chapter 4. 4. 1 [...] - Principle [...] - p. 41 Chapter 4. 4. 2 [...] - Voltage Sensor [...] - p. 42 Chapter 4. 4. 3 [...] - Ring Oscillator [...] - p. 43 Chapter 4. 4. 4 [...] - "Counter, Latch and Comparator" [...] - p. 46 Chapter 4. 4. 5 [...] - Recalibrate Circuit [...] - p. 47 Chapter 4. 4. 6 [...] - Operation Monitoring Circuit [...] - p. 48 Chapter 4. 4. 7 [...] - Overall Circuit [...] - p. 48 Chapter Chapter 5 [...] - DCT Implementation on Programmable DSP Processor [...] - p. 51 Chapter 5. 1 [...] - Overview [...] - p. 51 Chapter 5. 2 [...] - Processor Architecture [...] - p. 52 Chapter 5. 2. 1 [...] - Arithmetic Unit [...] - p. 53 Chapter 5. 2. 2 [...] - Switching Network [...] - p. 56 Chapter 5. 2. 3 [...] - FIFO Memory [...] - p. 59 Chapter 5. 2. 4 [...] - Instruction Memory [...] - p. 60 Chapter 5. 3 [...] - Programming [...] - p. 62 Chapter 5. 4 [...] - DCT Implementation [...] - p. 63 Chapter Chapter 6 [...] - DCT Implementation on Dedicated DCT Processor [...] - p. 66 Chapter 6. 1 [...] - Overview [...] - p. 66 Chapter 6. 2 [...] - DCT Chip Architecture [...] - p. 67 Chapter 6. 2. 1 [...] - ID DCT Core [...] - p. 68 Chapter 6. 2. 1. 1 [...] - Core Architecture [...] - p. 74 Chapter 6. 2. 1. 2 [...] - Flow of Operation [...] - p. 76 Chapter 6. 2. 1. 3 [...] - Data Replicator [...] - p. 79 Chapter 6. 2. 1. 4 [...] - DCT Coefficients Memory [...] - p. 80 Chapter 6. 2. 2 [...] - Combination of IDCT to 1 D DCT core [...] - p. 82 Chapter 6. 2. 3 [...] - Accuracy [...] - p. 85 Chapter 6. 3 [...] - Transpose Memory [...] - p. 87 Chapter 6. 3. 1 [...] - Architecture [...] - p. 89 Chapter 6. 3. 2 [...] - Address Generator [...] - p. 91 Chapter 6. 3. 3 [...] - <b>RAM</b> <b>Block</b> [...] - p. 94 Chapter Chapter 7 [...] - Results and Discussions [...] - p. 97 Chapter 7. 1 [...] - Overview [...] - p. 97 Chapter 7. 2 [...] - Refresh Control Circuit [...] - p. 97 Chapter 7. 2. 1 [...] - Implementation Results and Performance [...] - p. 97 Chapter 7. 2. 2 [...] - Discussion [...] - p. 100 Chapter 7. 3 [...] - Programmable DSP Processor [...] - p. 102 Chapter 7. 3. 1 [...] - Implementation Results and Performance [...] - p. 102 Chapter 7. 3. 2 [...] - Discussion [...] - p. 104 Chapter 7. 4 [...] - ID DCT/IDCT Core [...] - p. 107 Chapter 7. 4. 1 [...] - Simulation Results [...] - p. 107 Chapter 7. 4. 2 [...] - Measurement Results [...] - p. 109 Chapter 7. 4. 3 [...] - Discussion [...] - p. 113 Chapter 7. 5 [...] - Transpose Memory [...] - p. 122 Chapter 7. 5. 1 [...] - Simulated Results [...] - p. 122 Chapter 7. 5. 2 [...] - Measurement Results [...] - p. 123 Chapter 7. 5. 3 [...] - Discussion [...] - p. 126 Chapter Chapter 8 [...] - Conclusions [...] - p. 130 Appendix [...] - p. 133 Operations of switches in DCT implementation of programmable DSP processor [...] - p. 133 C Program {{for evaluating the}} error in DCT/IDCT core [...] - p. 135 Pin Assignments of the Programmable DSP Processor Chip [...] - p. 142 Pin Assignments of the 1 D DCT/IDCT Core Chip [...] - p. 144 Pin Assignments of the Transpose Memory Chip [...] - p. 147 Chip microphotograph of the 1 D DCT/IDCT core [...] - p. 150 Chip Microphotograph of the Transpose Memory [...] - p. 151 Measured Waveforms of 1 D DCT/IDCT Chip [...] - p. 152 Measured Waveforms of Transpose Memory Chip [...] - p. 156 Schematics of Refresh Control Circuit [...] - p. 158 Schematics of Programmable DSP Processor [...] - p. 164 Schematics of 1 D DCT/IDCT Core [...] - p. 180 Schematics of Transpose Memory [...] - p. 187 References [...] - p. 191 Design Libraries - CD-ROM [...] - p. 19...|$|E
40|$|Abstract. This paper {{discusses}} {{the design and}} implementation of finite state machines (FSM) with combinational circuits that are built primarily from <b>RAM</b> <b>blocks.</b> It suggests a novel state assignment technique, based on fuzzy codes, that is combined with the replacement (encoding) of the FSM input vectors. It also shows how FSMs with dynamically modifiable functionality can be constructed and then implemented in commercially available FPGAs. The results of experiments have shown that FSMs with the proposed architecture can be implemented using less hardware resources, such {{as the number of}} FPGA configurable logic blocks (CLB), {{while at the same time}} extending their functional capabilities. ...|$|R
5000|$|... iCE65 and iCE40 {{devices are}} {{constructed}} as {{an array of}} programmable logic blocks (PLBs), where a PLB is a block of eight logic cells. Each logic cell consists of a four-input lookup table (sometimes called a 4-LUT or LUT4) with the output connected to a D flip-flop (a 1-bit storage element). Within a PLB, each logic cell {{is connected to the}} following and preceding cell by carry logic, intended to improve the performance of constructs such as adders and subtractors. Interspersed with PLBs are <b>blocks</b> of <b>RAM,</b> each four kilobits in size. The number of <b>RAM</b> <b>blocks</b> varies depending on the device.|$|R
50|$|Contemporary field-programmable gate arrays (FPGAs) {{have large}} {{resources}} of logic gates and <b>RAM</b> <b>blocks</b> to implement complex digital computations. As FPGA designs employ very fast I/Os and bidirectional data buses, {{it becomes a}} challenge to verify correct timing of valid data within setup time and hold time. Floor planning enables resource allocation within FPGAs to meet these time constraints. FPGAs {{can be used to}} implement any logical function that an ASIC could perform. The ability to update the functionality after shipping, partial re-configuration of a portion of the design and the low non-recurring engineering costs relative to an ASIC design (notwithstanding the generally higher unit cost), offer advantages for many applications.|$|R
40|$|Most current {{square root}} {{implementations}} for FP-GAs use a digit recurrence algorithm which {{is well suited}} to their LUT structure. However, recent computing-oriented FPGAs include embedded multipliers and <b>RAM</b> <b>blocks</b> which {{can also be used}} to implement quadratic convergence algorithms, very high radix digit recurrences, or polynomial approximation algorithms. The cost of these solutions is evaluated and compared, and a complete implementation of a polynomial approach is presented within the open-source FloPoCo framework. This polynomial approach allows a shorter latency and higher frequency than the digit recurrence approach, and improves over previous multiplicative approaches. However, the cost of IEEE-compliant correct rounding is shown to be very high...|$|R
40|$|Modern FPGAs have multi-millions of {{gates and}} future generations of FPGAs {{will be even more}} complex. This means {{floorplanning}} tools will soon be extremely important for the physical design of FPGAs. Due to the heterogeneous logic and routing resources on an FPGA, FPGA floorplanning {{is very different from the}} traditional floorplanning for ASICs. This paper presents the first FPGA floorplanning algorithm targeted for FPGAs with heterogeneous resources (e. g., Xilinx’s Spartan 3 chips consisting of columns of CLBs, <b>RAM</b> <b>blocks,</b> and multiplier blocks). Our algorithm can generate floorplans for Xilinx’s XC 3 S 5000 architecture (largest of the Spartan 3 family) in a few minutes...|$|R
50|$|The Dragoon ASV (Armored Security Vehicle), {{also known}} as the Patroller, is the version of the Dragoon APC that is in service with several US law {{enforcement}} agencies. The vehicle is a little higher to allow standing, and the weapon mount is replaced with a rotating box that carries the surveillance equipment. The windows are larger, as are the firing ports and vision blocks. The vehicle is equipped with several surveillance devices, including a low-light TV, VCR, computer, shotgun microphone, and night vision gear. Many of these vehicles are equipped with pole-mounted <b>ramming</b> <b>blocks</b> mounted on the nose of the vehicle. Sirens and flashing lights complete the modifications.|$|R
50|$|The greenskins {{have invented}} or stolen many contraptions over time. These include war {{machines}} such as catapults and spear chukkas (bolt throwers). The most interesting inventions are the pump wagon and the doom diver catapult. The pump wagon {{is a large}} wagon ridden by snotlings. The snotlings on the pump wagon will often insult and throw rocks at any foes surrounding them but the real damage {{is done by the}} wagon itself. <b>Ramming</b> <b>blocks</b> of enemy soldiers it cuts and squishes those before it with large rotating blades. The Doom Diver catapult is an oversize sling that launches goblins (with home-made wings) towards the enemy troops.|$|R
5000|$|Súrsaðir hrútspungar, the {{testicles}} of <b>rams</b> {{pressed in}} <b>blocks,</b> boiled and cured in lactic acid.|$|R
40|$|International audienceMost current {{square root}} {{implementations}} for FPGAs use a digit recurrence algorithm which {{is well suited}} to their LUT structure. However, recent computing-oriented FPGAs include embedded multipliers and <b>RAM</b> <b>blocks</b> which {{can also be used}} to implement quadratic convergence algorithms, very high radix digit recurrences, or polynomial approximation algorithms. The cost of these solutions is evaluated and compared, and a complete implementation of a polynomial approach is presented within the open-source FloPoCo framework. It allows a much shorter latency and a higher frequency than the classical approach. The cost of IEEE-compliant correct rounding using such approximation algorithms is shown to be very high, and faithful (last-bit accurate) operators are advocated in this case...|$|R
40|$|The paper {{presents}} a new efficient method for {{implementation of the}} AES byte substitution function (S-box). It is aimed at the AES implementation in non-volatile FPGAs featuring volatile embedded <b>RAM</b> <b>blocks.</b> The method uses a pair of linear feedback shift registers to generate substitution tables into embedded RAMs. The proposed solution requires less space and is faster than the one implementing whole S-boxes in the logic area, and it is especially suited to a power-aware AES implementation. The complete AES cipher implemented in the Actel Igloo family and employing the proposed solution consumes two times less total power and more than 150 -times less static power than the same cipher implemented in a competing volatile FPGA technology. 1...|$|R
40|$|Whereas various {{approaches}} {{exist for}} high-level synthesis of algorithms onto increasingly complex embedded Systems-on-Chips (SoCs), communication semantics in general do not exceed signal or FIFO communication thus making system design complicated. This paper presents a new communication primitive for parallel out-of-order communication in image processing. Its hardware implementation performs efficient address generation and fill-level control and permits to trade throughput against resource requirements. This helps to quickly explore the design {{space of a}} considered system. Corresponding synthesis results from a Motion-JPEG decoder illustrate {{the benefits of the}} proposed approach. In particular, high achievable clock frequencies together with the capability {{to reduce the number of}} required <b>RAM</b> <b>blocks</b> by efficient memory mapping simplify the design of high-performance stream based systems...|$|R
40|$|Stratix ® II devices {{contain a}} {{two-dimensional}} row- and column-based architecture to implement custom logic. A series of column and row interconnects of varying length and speed provides signal interconnects between logic array blocks (LABs), memory block structures (M 512 RAM, M 4 K <b>RAM,</b> and M-RAM <b>blocks),</b> and {{digital signal processing}} (DSP) blocks. Each LAB consists of eight adaptive logic modules (ALMs). An ALM is the Stratix II device family’s basic building block of logic providing efficient implementation of user logic functions. LABs are grouped into rows and columns across the device. M 512 <b>RAM</b> <b>blocks</b> are simple dual-port memory blocks with 512 bits plus parity (576 bits). These blocks provide dedicated simple dual-port or single-port memory up to 18 -bits wide at up to 500 MHz. M 512 blocks are grouped into columns across the device in between certain LABs. M 4 K <b>RAM</b> <b>blocks</b> are true dual-port memory blocks with 4 K bits plus parity (4, 608 bits). These blocks provide dedicated true dual-port, simple dual-port, or single-port memory up to 36 -bits wide at up to 550 MHz. These blocks are grouped into columns across the device in between certain LABs. M-RAM blocks are true dual-port memory blocks with 512 K bits plus parity (589, 824 bits). These blocks provide dedicated true dual-port, simple dual-port, or single-port memory up to 144 -bits wide at up to 420 MHz. Several M-RAM blocks are located individually in the device's logic array. DSP blocks can implement up to either eight full-precision 9 × 9 -bit multipliers, four full-precision 18 × 18 -bit multipliers, or one full-precision 36 × 36 -bit multiplier with add or subtract features. The DSP blocks support Q 1. 15 format rounding and saturation in the multiplier and accumulator stages. These blocks also contain shift registers for digital signal processing applications, including finite impulse response (FIR) and infinite impulse response (IIR) filters. DSP blocks are grouped into columns across the device and operate at up t...|$|R
5000|$|<b>RAM</b> drive a <b>block</b> of random-access {{memory that}} the {{operating}} system treats {{as if it were}} secondary storage ...|$|R
40|$|This paper {{presents}} a novel methodology {{that allows a}} systematic availability analysis of satellite payload data processing systems implemented on static random-access memory-based field-programmable gate arrays. The methodology allows 1) comparison of different fault detection, isolation, and recovery schemes and 2) prediction of the expected system availability in a particular radiation environment. Furthermore, it advances {{the state of the}} art by analyzing embedded <b>block</b> <b>RAMs</b> and employing a novel fault injection algorithm that enables more complex stochastic models. The applicability of the method is demonstrated by a case study representing a high-availability payload data processing application. Since <b>block</b> <b>RAMs</b> are also taken into account, the availability prediction precision is greatly increased. It is shown that the reliability prediction for two border cases in which the <b>block</b> <b>RAMs</b> are either ignored or assumed to be fully susceptible can differ as much as 75 %. With the proposed <b>block</b> <b>RAM</b> profiling tool, it is possible to determine a realistic reliability figure that is eventually required for the accurate estimation of the system availability. Peer-reviewedPost-prin...|$|R
40|$|International audienceDreamCam is a modular smart camera {{constructed}} {{with the use}} of an FPGA like main processing board. The core of the camera is an Altera Cyclone-III associated with a CMOS imager and six private <b>Ram</b> <b>blocks.</b> The main novel feature of our work consists in proposing a new smart camera architecture and several modules (IP) to efficiently extract and sort the visual features in real time. In this paper, extraction is performed by a Harris and Stephen filtering associated with customized modules. These modules extract, select and sort visual features in real-time. As a result, DreamCam (with such a configuration) provides a description of each visual feature in the form of its position and the grey-level template around it...|$|R
40|$|Abstract — This {{paper is}} {{concerned}} with the application of formal optimisation methods to the design of mixed-granularity FPGAs. In particular, we investigate the appropriate mix and floorplan of heterogeneous elements: multipliers, RAMs, and LUT-based logic, in order to maximise the performance of a set of DSP benchmark applications, given a fixed silicon budget. A mathematical programming framework is introduced, along with a set of heuristics, capable of providing upper-bounds on the achievable reconfigurable-to-fixed-logic performance ratio. Moreover, we use linear-programming bounding procedures from the operations research community to provide lower-bounds on the same quantity. Our results provide, for the first time, quantifications of the optimal performance/area-enhancing capability of multipliers and <b>RAM</b> <b>blocks</b> within a system context. The approach detailed provides a formal mechanism to explore future technology nodes...|$|R
