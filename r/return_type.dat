154|521|Public
5|$|PHP 7 also {{introduced}} new language features, including <b>return</b> <b>type</b> declarations for functions, which complement the existing parameter type declarations, {{and support for}} the scalar types (integer, float, string, and boolean) in parameter and <b>return</b> <b>type</b> declarations.|$|E
5|$|With the {{introduction}} of templates into the C++ programming language, {{and the advent of}} generic programming techniques pioneered by the Standard Template Library, the need for a mechanism for obtaining the type of an expression, commonly referred to as typeof, was recognized. In generic programming, it is often difficult or impossible to express types that depend on template parameters, in particular the <b>return</b> <b>type</b> of function template instantiations.|$|E
25|$|Within {{functions}} that define a non-void <b>return</b> <b>type,</b> failure {{to return a}} value before control reaches {{the end of the}} function results in undefined behaviour (compilers typically provide the means to issue a diagnostic in such a case). The sole exception to this rule is the main function, which implicitly returns a value of zero.|$|E
40|$|Abstract. Software {{development}} in scientific computing typically {{deals with a}} large number of algorithms. An algorithm can have different implementations due to specializations for certain cases. These specializations may result in different <b>return</b> <b>types.</b> If the <b>return</b> <b>types</b> are not known a-priori, meaning, the types cannot be derived during compile-time, run-time techniques are required. This topic is generally referred to as covariant <b>return</b> <b>types</b> and is typically related to the object-oriented programming domain. Common approaches are based on dynamic polymorphism techniques which result in run-time overhead. We present an approach to handle non-a-priori known <b>return</b> <b>types</b> without the need of dynamic polymorphism techniques, hence, increasing run-time efficiency. The approach is discussed in detail based on an example in the field of computational geometry...|$|R
50|$|Although {{it would}} be {{possible}} to infer procedure parameter and <b>return</b> <b>types</b> by examining where the procedure is called, S-algol does require parameter and <b>return</b> <b>types</b> to be specified. This is a practical decision, since it should be possible to understand a procedure without examining its calls.|$|R
5000|$|Function <b>return</b> <b>types</b> (...) - {{determines the}} type of a call expression.|$|R
25|$|In {{all of the}} overloads, {{the first}} {{parameter}} to the operator new function is of type , which when the function is called will be passed as an argument specifying the amount of memory, in bytes, to allocate. All of the functions must <b>return</b> <b>type</b> , which is a pointer to the storage that the function allocates.|$|E
500|$|These {{semantics}} {{were designed}} to fulfill the needs of generic library writers, {{while at the same}} time being intuitive for novice programmers, because the <b>return</b> <b>type</b> of decltype always matches the type of the object or function exactly as declared in the source code. More formally, Rule 1 applies to unparenthesized id-expressions and class member access expressions. Example: ...|$|E
2500|$|A {{continuation}} monad with <b>return</b> <b>type</b> [...] maps type [...] into {{functions of}} type [...] It {{is used to}} model continuation-passing style. The return and bind functions are as follows: ...|$|E
50|$|Parameter and <b>return</b> <b>types</b> follow, as in Pascal, {{rather than}} precede as in C.|$|R
5000|$|... bool adjacent(long x, long y); func2 = &adjacent; // OK - Parameters and <b>return</b> <b>types</b> are convertible.|$|R
40|$|This report {{contains}} {{estimates of}} frequencies of taxpayer entries and estimates of monetary amounts recorded on the applicable {{lines of the}} forms and schedules filed as part of corporation tax returns {{as shown in the}} 2008 Statistics of Income (SOI) Complete Report. The estimates of counts and monetary amounts on 1120 Series forms are categorized by the <b>return</b> <b>types</b> included in the SOI statistical sample. <b>Return</b> <b>types</b> included in the SOI sample are...|$|R
6000|$|... 80. To-day, then, I believe verily for {{the first}} time, I {{have been able to}} put before you some means of {{guidance}} to understand the beauty of the bird which lives with you in your own houses, and which purifies for you, from its insect pestilence, the air that you breathe. Thus the sweet domestic thing has done, for men, at least these four thousand years. She has been their companion, not of the home merely, but of the hearth, and the threshold; companion only endeared by departure, and showing better her loving-kindness by her faithful <b>return.</b> <b>Type</b> sometimes of the stranger, she has softened us to hospitality; type always of the suppliant, she has enchanted us to mercy; and in her feeble presence, the cowardice, or the wrath, of sacrilege has changed into the fidelities of sanctuary. Herald of our summer, she glances through our days of gladness; numberer of our years, she would teach us to apply our hearts to wisdom;--and yet, so little have we regarded her, that this very day, scarcely able to gather from all I can find told of her enough to explain so much as the unfolding of her wings, I can tell you nothing of her life--nothing of her journeying: I cannot learn how she builds, nor how she chooses the place of her wandering, nor how she traces the path of her return. Remaining thus blind and careless to the true ministries of the humble creature whom God has really sent to serve us, we in our pride, thinking ourselves surrounded by the pursuivants of the sky, can yet only invest them with majesty by giving them the calm of the bird's motion, and shade of the bird's plume:--and after all, it is well for us, if, when even for God's best mercies, and in His temples marble-built, we think that, [...] "with angels and archangels, and all the company of Heaven, we laud and magnify His glorious name"--well for us, if our attempt be not only an insult, and His ears open rather to the inarticulate and unintended praise, of [...] "the Swallow, twittering from her straw-built shed." ...|$|E
5000|$|In {{order to}} induce <b>return</b> <b>type</b> deduction, the {{function}} must be declared with [...] as the <b>return</b> <b>type,</b> {{but without the}} trailing <b>return</b> <b>type</b> specifier in C++11: ...|$|E
5000|$|The [...] syntax {{can also}} be used with <b>return</b> <b>type</b> deduction, by using [...] syntax instead of [...] for the function's <b>return</b> <b>type</b> deduction.|$|E
5000|$|In a {{language}} which allows covariant <b>return</b> <b>types,</b> a derived class can override the [...] method {{to return a}} more specific type: ...|$|R
5|$|C# has {{explicit}} {{support for}} covariance and contravariance in generic types, unlike C++ which has {{some degree of}} support for contravariance simply through the semantics of <b>return</b> <b>types</b> on virtual methods.|$|R
50|$|A {{structure}} {{can also}} be assigned as a unit to another structure of the same type. Structures (and pointers to structures) may {{also be used as}} function parameter and <b>return</b> <b>types.</b>|$|R
50|$|More specifically, {{covariant}} (wide to narrower) or contravariant (narrow to wider) <b>return</b> <b>type</b> {{refers to}} {{a situation where the}} <b>return</b> <b>type</b> of the overriding method is changed to a type related to (but different from) the <b>return</b> <b>type</b> of the original overridden method. The relationship between the two covariant return types is usually one which allows substitution of the one type with the other, following the Liskov substitution principle. This usually implies that the return types of the overriding methods will be subtypes of the <b>return</b> <b>type</b> of the overridden method. The above example specifically illustrates such a case. If substitution is not allowed, the <b>return</b> <b>type</b> is invariant and causes a compile error.|$|E
50|$|PHP 7 also {{introduced}} new language features, including <b>return</b> <b>type</b> declarations for functions, which complement the existing parameter type declarations, {{and support for}} the scalar types (integer, float, string, and boolean) in parameter and <b>return</b> <b>type</b> declarations.|$|E
5000|$|Function prototype: functionName (parameter(s)) : <b>return</b> <b>type</b> ...|$|E
50|$|C# has {{explicit}} {{support for}} covariance and contravariance in generic types, unlike C++ which has {{some degree of}} support for contravariance simply through the semantics of <b>return</b> <b>types</b> on virtual methods.|$|R
50|$|Functions that deduce their <b>return</b> <b>types</b> can be forward declared, {{but they}} {{cannot be used}} until they have been defined. Their {{definitions}} must {{be available to the}} translation unit that uses them.|$|R
50|$|The Objective-C runtime {{maintains}} {{information about}} the argument and <b>return</b> <b>types</b> of methods. However, this information {{is not part of}} the name of the method, and can vary from class to class.|$|R
5000|$|... the <b>return</b> <b>type</b> is int. The {{program can}} {{therefore}} {{rely on the}} method returning a value of type int. Various mechanisms are used for the case where a subroutine does not return any value, e.g., a <b>return</b> <b>type</b> of void is used in some programming languages: ...|$|E
5000|$|C++11 allowed lambda {{functions}} to deduce the <b>return</b> <b>type</b> {{based on the}} type of the expression given to the return statement. C++14 provides this ability to all functions. It also extends these facilities to lambda functions, allowing <b>return</b> <b>type</b> deduction for functions that are not of the form [...]|$|E
5000|$|In {{computer}} programming, the <b>return</b> <b>type</b> (or result type) defines and constrains {{the data}} type {{of the value}} returned from a subroutine or method. [...] In many programming languages (especially statically-typed programming languages such as C, C++, Java) the <b>return</b> <b>type</b> must be explicitly specified when declaring a function.|$|E
50|$|Code {{comments}} {{are associated with}} symbols in the code, and Ddoc uses the semantic and syntactic information available from the D compiler to fill in routine information such as parameters and <b>return</b> <b>types</b> automatically.|$|R
5000|$|Xtend {{provides}} type inference, i.e. {{the type}} of [...] and the <b>return</b> <b>types</b> of the methods can be inferred from the context. Classes and methods are [...] by default, fields [...] Semicolons are optional.|$|R
30|$|Module {{persists}} {{class and}} interface names. Method persists method names, signature, and <b>return</b> <b>types.</b> Import persists application imports. Package persists application packages. ModuleProperty persists class properties and its type. MethodProperty persists variables belonging to methods.|$|R
5000|$|Polymorphic table {{functions}}: table functions without predefined <b>return</b> <b>type</b> ...|$|E
5000|$|... auto Correct(int i) { if (i == 1) return i; // <b>return</b> <b>type</b> deduced as int else return Correct(i-1)+i; // ok {{to call it}} now}auto Wrong(int i) { if (i != 1) return Wrong(i-1)+i; // Too soon to call this. No prior return statement. else return i; // <b>return</b> <b>type</b> deduced as int} ...|$|E
5000|$|Creation {{procedures}} have no explicit <b>return</b> <b>type</b> (by definition of procedure).|$|E
5000|$|In the Java {{programming}} language, {{a method}} signature is the method {{name and the}} number and type of its parameters. <b>Return</b> <b>types</b> and thrown exceptions are {{not considered to be}} a part of the method signature. methodName(parameters) {...}; ...|$|R
5000|$|... a {{function}} declaration for {{a function}} [...] which returns {{an object of}} type [...] and has a single (unnamed) parameter which is a pointer to function <b>returning</b> <b>type</b> [...] (and taking no input). (See Function object#In C and C++) ...|$|R
50|$|Like multimethods, multi-parameter type classes support calling {{different}} implementations of {{a method}} {{depending on the}} types of multiple arguments, and indeed <b>return</b> <b>types.</b> Multi-parameter type classes do not require searching for the method to call on every call at runtime; rather the method to call is first compiled and stored in the dictionary of the type class instance, just as with single-parameter type classes.|$|R
