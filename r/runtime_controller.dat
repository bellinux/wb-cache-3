7|13|Public
5000|$|... local <b>runtime</b> <b>controller,</b> {{integrating}} {{between different}} protocols, and managing automation rules ...|$|E
5000|$|... {{control panels}} (apps, webview) {{used in a}} local network or when {{accessing}} a <b>runtime</b> <b>controller</b> from a remote location via a remote proxy service.|$|E
50|$|A {{second choice}} they made {{was to have}} the {{integration}} and automation logic of devices and sensors, organized by a local <b>runtime</b> <b>controller.</b> The rationale is based on organizing an intrinsically stable and responsive system, meaning independence at the lowest level possible with the least dependency of higher level systems. An internet connection is only required for communication to (sub)systems outside the own network, or during configuration of the system. The presence of non IP based wired or wireless protocols, is another reason of requiring a local controller.|$|E
40|$|The {{requirements}} and specification of a protocol for low level {{communication between the}} run-time systems in a distributed Ada environment is presented. This allows an Ada system to be separated into software resources and <b>runtime</b> <b>controllers.</b> Calls to the local run-time system of a node, concerning task management,are transformed into remote calls to the controller, that schedules all tasksin the application. The calls to the run-timesystemtogetherwith all messages, requests and replies, that are triggered as aconsequence, are described. The controller will be implemented in hardware separate from the processors. Communication between processors and controllers are bymeans of high speed (Gigabit) networks. In the proposed system, partitioning and distribution of Ada programs can fully utilize the inherent and strong type checking in Ada. 1 Introduction The complex tasking model of Ada requires an extensive run-time system, RTS. As the need for efficiency and speed contin [...] ...|$|R
30|$|To {{test the}} system, the choice {{has been made}} to reconfigure the Scrambler, Interleaver, FEC, and IFFT blocks in order to perform {{vertical}} handover during <b>runtime.</b> The configuration <b>controller</b> reconfigures these modules according to the VHA requests.|$|R
50|$|AES70 {{includes}} complete {{support for}} managing the configurations of reconfigurable DSP devices, i.e. software-based devices whose signal processing topologies can be defined and redefined at <b>runtime</b> by external <b>controllers.</b> For such devices, AES70 supports creation, configuration, and deletion of signal processing elements and the internal signal paths that connect them.|$|R
30|$|Queueing-model based {{techniques}} {{employ a}} QNM to predict user-level SLO metrics such as throughput and response {{time of the}} application being managed. This performance model is usually embedded within a <b>runtime</b> <b>controller</b> that controls resource allocations to the managed application so as to satisfy its SLO targets. These techniques {{are based on the}} assumption that the application system being controlled is in a steady state and as a result they have been shown to be effective for decisions spanning medium term time horizons, e.g., 30 min [21].|$|E
40|$|Heterogeneous {{architectures}} nowadays {{are becoming}} very at-tractive in the embedded and mobile markets {{thanks to the}} possibility to exploit the best computational resource to op-timize the performance per Watt figure of merit. Unfortu-nately, deciding the right resource to use and its operating frequency is a difficult problem {{that depends on the}} actual conditions in which the system is operating. This work aims at proposing a <b>runtime</b> <b>controller,</b> integrated in Linux Oper-ating System (OS), for optimizing the power efficiency of a running application deciding the system configuration. Our experimental results over a set of applications from the Poly-bench suite on the Odroid XU 3 board show that our con-troller is able to obtain a power efficiency of more than 90 % of the one achievable via offline profiling...|$|E
40|$|We {{introduce}} a new design metric called system-resiliency which characterizes the maximum unpredictable external stresses that any hard-real-time performance mode can withstand. Our proposed systemresiliency framework addresses resiliency determination for real-time systems with physical and hardware limitations. Furthermore, our framework advises the system designer about the feasible trade-offs between external system resources for the system operating modes on a real-time system that operates in a multi-parametric resiliency environment. Modern multi-modal real-time systems degrade the system’s operational modes {{as a response to}} unpredictable external stimuli. During these mode transitions, real-time systems should demonstrate a reliable and graceful degradation of service. Many control-theoretic-based system design approaches exist. Although they permit real-time systems to operate under various physical constraints, none of them allows the system designer to predict the system-resiliency over multi-constrained operating environment. Our framework fills this gap; the proposed framework consists of two components: the design-phase and runtime control. With the design-phase analysis, the designer predicts the behavior of the real-time system for variable external conditions. Also, the <b>runtime</b> <b>controller</b> navigates the system to the best desired target using advanced control-theoretic techniques. Further, our framework addresses the system resiliency of both uniprocessor and multicore processor systems. As a proof of concept, we first {{introduce a}} design metric called thermal-resiliency, which characterizes the maximum external thermal stress that any hard-real-time performance mode can withstand. We verify the thermal-resiliency for the external thermal stresses on a uniprocessor system through a physical testbed. We show how to solve some of the issues and challenges of designing predictable real-time systems that guarantee hard deadlines even under transitions between modes in an unpredictable thermal environment where environmental temperature may dynamically change using our new metric. We extend the derivation of thermal-resiliency to multicore systems and determine the limitations of external thermal stress that any hard-real-time performance mode can withstand. Our control-theoretic framework allows the system designer to allocate asymmetric processing resources upon a multicore proiii cessor and still maintain thermal constraints. In addition, we develop real-time-scheduling sub-components that are necessary to fully implement our framework; toward this goal, we investigate the potential utility of parallelization for meeting real-time constraints and minimizing energy. Under malleable gang scheduling of implicit-deadline sporadic tasks upon multiprocessors, we show the non-necessity of dynamic voltage/frequency regarding optimality of our scheduling problem. We adapt the canonical schedule for DVFS multiprocessor platforms and propose a polynomial-time optimal processor/frequency-selection algorithm. Finally, we verify the correctness of our framework through multiple measurable physical and hardware constraints and complete our work on developing a generalized framework...|$|E
40|$|International audienceThis paper {{presents}} a {{design of a}} custom architecture for a Minimum Mean Square Error Interference Cancellation (MMSE-IC) Linear Equalizer (LE) used in iterative MIMO turbo receiver using NO Instruction Set Computer (NISC) design approach. The proposed processor has a datapath, memory, and a simple controller with no instruction set or instruction decoder. NISC compiler schedules statically all operations and generates control values that must be driven to datapath components at every clock cycle and loads them in the memory. At <b>runtime</b> the <b>controller</b> only loads the control words and applies them to the datapath. The datapath consists of a computational unit, a storage unit and multiplexing unit. The allocation of hardware resources considered the required flexibility concerning the number of used antennas and the time selectivity of the channel. The design supports the MIMO use in 2 × 2, 3 × 3, and 4 × 4 spatial multiplexing configuration for block, quasi-static, and fast fading channel models...|$|R
40|$|Aggressive {{technology}} scaling {{has enabled}} the fabrication of many-core architectures while triggering challenges such as limited power budget and increased reliability issues, like aging phenomena. Dynamic power management and runtime mapping strategies can be utilized in such systems to achieve optimal performance while satisfying power constraints. However, lifetime reliability is generally neglected. We propose a novel lifetime reliability/performance-Aware resource co-management approach for many-core architectures {{in the dark}} silicon era. The approach {{is based on a}} two-layered architecture, composed of a long-Term <b>runtime</b> reliability <b>controller</b> and a short-Term runtime mapping and resource management unit. The former evaluates the cores' aging status w. r. t. a target reference specified by the designer, and performs recovery actions on highly stressed cores by means of power capping. The aging status is utilized in runtime application mapping to maximize system performance while fulfilling reliability requirements and honoring the power budget. Experimental evaluation demonstrates the effectiveness of the proposed strategy, which outperforms most recent state-of-The-Art contributions...|$|R
40|$|This paper {{presents}} a {{design of a}} custom architecture for a Minimum Mean Square Error Interference Cancellation (MMSE-IC) Linear Equalizer (LE) used in iterative MIMO turbo receiver using NO Instruction Set Computer (NISC) design approach. The proposed processor has a datapath, memory, and a simple controller with no instruction set or instruction decoder. NISC compiler schedules statically all operations and generates control values that must be driven to datapath components at every clock cycle and loads them in the memory. At <b>runtime</b> the <b>controller</b> only loads the control words and applies them to the datapath. The datapath consists of a computational unit, a storage unit and multiplexing unit. The allocation of hardware resources considered the required flexibility concerning the number of used antennas and the time selectivity of the channel. The design supports the MIMO use in 2 × 2, 3 × 3, and 4 × 4 spatial multiplexing configuration for block, quasi-static, and fast fading channel models...|$|R
40|$|Smart {{roads are}} an {{electronically}} enriched form of highways that aim {{to maximize the}} throughput and safety of traffic. If a vehicle is not complying with its instructions, then an appropriate reaction such as a fine is required. This gives us two basic tasks for a smart road. On the one hand {{does it have to}} monitor the traffic {{in order to determine the}} instructions for vehicles and whether they comply with their instructions, on the other hand does it have to process the violations of instructions. In this thesis we view the tasks of a smart road as an example of the more generic task of making sure that agents behave according to preset guidelines. A specification of how agents ought to behave and the measures when they fail to comply, is what we call a norm. In our traffic example we may consider a norm to be comparable with a traffic rule. The task of a smart road can be reformulated as `the enforcement of one or more norms'. The traffic situation on one road may affect the situation on another. Therefore, it is often appropriate to consider norms not in the context of a single smart road but in a network of them. Smart roads have to collaborate in such cases in order to enforce the norms. We call this decentralized enforcement. We are particularly interested in the limitations and possibilities of decentralized norm enforcement when we want to apply it in an application. To this end, we focus specifically on decentralized runtime norm enforcement. Our main conclusions and contributions are as follows. Decentralized runtime norm enforcement is composed of monitoring and control. Monitoring for decentralized runtime norm enforcement can be equated to verifying whether a system satisfies a linear temporal logic (LTL) formula. Several proposals exist for runtime LTL verification, to which we have added two complementary proposals. We also discussed security and robustness for a decentralized monitor. The control task of decentralized runtime norm enforcement is comparable to the control of discrete event systems. We took a <b>runtime</b> <b>controller</b> model from the literature of discrete event control systems and have shown how this model can be reapplied for norm enforcement. A typical property of decentralized enforcement is that multiple controllers can operate in a concurrent manner, such as multiple smart roads that are coordinating traffic concurrently. We describe how the model for controllers can be expanded to the concurrent application of controllers, which results in a collaborative controller. It is important to consider conventional programming paradigms in order to promote the development of agent systems with norm enforcement. We proposed design patterns for object-oriented programming which capture often reoccurring solutions in the agent programming literature. We also showed how an object-oriented implementation can be expanded with norm enforcement using aspect-oriented programming. Finally, we made an example simulation of a smart roads scenario. This simulation illustrates how we may view the task of a smart road as the decentralized runtime enforcement of norms...|$|E
40|$|In this paper, {{we propose}} a new method to compose physically-based {{character}} controllers in low dimensional latent space. Source controllers {{are created by}} gradually updating the task parameter such as the external force applied to the body. During the optimization, instead of only saving the optimal controllers, we also keep {{a large number of}} non-optimal controllers. These controllers provide knowledge about the stable area in the controller space, and are then used as samples to construct a low dimensional manifold that represents stable <b>controllers.</b> During <b>runtime,</b> we interpolate <b>controllers</b> in the low dimensional space and create stable controllers to cope with the irregular external forces. Our method is best to be applied for real-time applications such as computer games...|$|R
40|$|Partially {{reconfigurable}} FPGAs can {{be shared}} among multiple independent tasks. When partial reconfiguration is possible at <b>runtime</b> the FPGA <b>controller</b> can decide on-line were to place new tasks on the FPGA. Since on [...] line allocation suffers from fragmentation, tasks can end up waiting despite there being sufficient, albeit non [...] contiguous resources available to service them. Rearranging {{a subset of the}} tasks executing on the FPGA often allows the next pending task to be processed sooner. In this paper we study the problem of placing and rearranging tasks that are supplied by input streams which have constant data rates. When such tasks are rearranged, the arriving input data have to be buffered while the execution is suspended. We describe and evaluate a genetic algorithm for identifying and scheduling feasible rearrangements when moving tasks are reloaded from off [...] chip and buffer size is limited. ...|$|R
40|$|Autonomic {{management}} {{of quality of}} service attributes by dynamic resource allocation {{is one of the}} requirements in cloud computing environments. In order to provide these requirements in a flexible way existing cloud providers expose static rule /threshold/heuristic based decision implementation frameworks to their consumers. These rule /threshold/heuristic based methods are relatively easy to design and develop. However, they suffer from lack of well-founded design process to decide important design parameters (e. g. : thresholds, the number of instances to add/remove, calm time) and difficulty of dynamically adjusting to different conditions. In addition, incorrect/non-adaptable rule settings could cause long term instabilities leading to service outages. The feedback control {{has been shown to be}} useful for performance management and resource allocation in many complex software systems. In this work, we investigate the advantages and limitations of applying feedback controllers in cloud platforms. In addition, we illustrate the suitability of standard feedback controllers depending on the consumer requirements/applications. Finally, we propose a novel platform as a service architecture to design, develop, integrate and <b>runtime</b> manage feedback <b>controllers</b> for the cloud consumer applications...|$|R
40|$|Abstract — Three-dimensional (3 D) {{circuits}} reduce communication de-lay in multicore SoCs, {{and enable}} efficient integration of cores, memories, sensors, and RF devices. However, vertical integration of layers exacer-bates {{the reliability and}} thermal problems, and cooling efficiency becomes a limiting factor. Liquid cooling is a solution to overcome the accelerated thermal problems imposed by multi-layer architectures. In this paper, we first provide a 3 D thermal simulation model including liquid cooling, supporting both fixed and variable fluid injection rates. Our model has been integrated in HotSpot to study the impact on multicore SoCs. We design and evaluate several dynamic management policies that complement liquid cooling. Our results for 3 D multicore SoCs, {{which are based on}} 3 D versions of UltraSPARC T 1, show that thermal management approaches that combine liquid cooling with proactive task allocation are extremely effective in preventing temperature problems. Our proactive management technique provides an additional 75 % average reduction in hot spots in comparison to applying only liquid cooling. Furthermore, for systems capable of varying the coolant flow rate at <b>runtime,</b> our feedback <b>controller</b> increases the improvement to 95 % on average. I...|$|R
40|$|In {{applications}} such as mining, space exploration, and toxic waste cleanup, mobile robots are often required to move within a common environment and to share resources. This introduces {{the need for a}} means of coordinating their behaviours. Also, due to the unpredictable nature of the worksite, {{there is a need to}} accommodate changes in a dynamic environment. [...] A general framework for group robotics was developed in response to this need. The framework includes a discrete event controller for on-line control and runtime monitoring, the focus of the current research. [...] A Petri net based discrete event formalism has been investigated as a basis for the development of an on-line controller, ftom a high-level task description, a set of rules have been used to automatically generate a Petri net structure that provides coordinated behaviour. The Petri net can then be executed to send instructions to robots and to incorporate feedback from the robots at <b>runtime.</b> This on-line <b>controller</b> has been used to control mobile robots in a proof-of-concept demonstration. In a laboratory setting, the Petri net controller was able to coordinate the behaviour of two robots in marker-based navigation tasks. [...] Although the work completed to date has provided promising results, many research challenges remain. Some suggestions for future work are presented...|$|R
40|$|Thesis (M. Eng.) [...] Memorial University of Newfoundland, 2000. Engineering and Applied ScienceBibliography: leaves 74 - 79. In {{applications}} such as mining, space exploration, and toxic waste cleanup, mobile robots are often required to move within a common environment and to share resources. This introduces {{the need for a}} means of coordinating their behaviours. Also, due to the unpredictable nature of the worksite, {{there is a need to}} accommodate changes in a dynamic environment. [...] A general framework for group robotics was developed in response to this need. The framework includes a discrete event controller for on-line control and runtime monitoring, the focus of the current research. [...] A Petri net based discrete event formalism has been investigated as a basis for the development of an on-line controller, ftom a high-level task description, a set of rules have been used to automatically generate a Petri net structure that provides coordinated behaviour. The Petri net can then be executed to send instructions to robots and to incorporate feedback from the robots at <b>runtime.</b> This on-line <b>controller</b> has been used to control mobile robots in a proof-of-concept demonstration. In a laboratory setting, the Petri net controller was able to coordinate the behaviour of two robots in marker-based navigation tasks. [...] Although the work completed to date has provided promising results, many research challenges remain. Some suggestions for future work are presented...|$|R
40|$|Humans {{adjust their}} {{movements}} {{in advance to}} prepare for the forthcoming action, resulting in efficient and smooth transi-tions. However, traditional computer animation approaches such as motion graphs simply concatenate a series of actions without taking into account the following one. In this paper, we propose a new method to produce preparation behaviors using reinforcement learning. As an offline process, the system learns the optimal way to approach a target and to prepare for interaction. A scalar value called the level of preparation is introduced, which represents the degree of transition from the initial action to the interacting action. To synthesize the movements of preparation, we propose a customized motion blending scheme based on the level of preparation, which is followed by an optimization framework that adjusts the pos-ture to keep the balance. During <b>runtime,</b> the trained <b>controller</b> drives the character to move to a target with the appropriate level of preparation, resulting in a humanlike behavior. We create scenes in which the character has to move in a complex environment and to interact with objects, such as crawling under and jumping over obstacles while walking. The method is useful not only for computer animation but also for real-time applications such as computer games, in which the characters need to accomplish a series of tasks in a given environment. Copyright © 2013 John Wiley & Sons, Ltd. KEYWORDS preparation behavior; motion synthesis; reinforcement learning; motion blending; posture optimization Supporting information may be found in the online version of this article...|$|R

