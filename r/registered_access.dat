1|373|Public
40|$|It {{is vital}} to achieve a {{disaster}} recovery system that allows a backup site {{to take over a}} primary site’s IT services while the primary site is down. We propose a flexible replication mechanism based on service requirements such as system performance, recovery time objective (RTO), and recovery point objective (RPO). For high flexibility, the mechanism controls the replication schedule by monitoring the application’s database accesses in the database connection library and matching the accesses with previously <b>registered</b> <b>access</b> patterns. In our experiments, we confirmed that the proposed mechanism outperforms other existing mechanisms, especially in situations with network delays and packet losses. 1...|$|E
5000|$|Indirect <b>{{register}}</b> <b>access</b> (address <b>register,</b> {{data register}} in mapped memory) ...|$|R
40|$|Large {{register}} {{file with}} multiple ports {{is a critical}} component of a high-performance processor. A large number of registers are necessary for processing a larger number of in-flight instructions to exploit higher instruction level parallelism (ILP). Multiple ports for a register file are necessary to support execution of multiple instructions each cycle. These necessities lead to a larger <b>register</b> <b>access</b> time. However, <b>register</b> <b>access</b> time has to be minimal to enable design of high frequency processors. Analysis of lifetime of a logical to physical register mapping reveals that there are long latencies between the times a physical register is allocated, consumed, and released. In this paper, we propose a dual bank register file organization that exploits such long latencies, resulting in a large bandwidth with a reduced <b>register</b> <b>access</b> time. Implementation of one flavor of the proposed register file organization, as compared to a conventional monolithic register file, in an 8 -wide out-of-order issue superscalar processor enhanced instructions per cycle (IPC) throughput up to 6 % for Spec 2000 applications while reducing <b>register</b> <b>access</b> time up to 22 %. Another flavor of the register file organization, with a similar access time as the conventional monolithic register file, enhanced the IPC up to 15 %. Thus a trade-off between <b>register</b> <b>access</b> time and ILP exploitation is shown. ...|$|R
40|$|In this paper, a {{register}} allocation technique that translates memory <b>accesses</b> to <b>register</b> <b>accesses</b> {{is presented to}} enhance embedded software performance. In the proposed method, a source code is profiled to generate a memory trace. From the profiling results, target functions with high dynamic call counts are selected, and the proposed register allocation technique is applied only to the target functions to save the compilation time. The memory trace of the target functions is searched for the memory accesses that result in cycle count reduction when replaced by <b>register</b> <b>accesses,</b> and they are translated to <b>register</b> <b>accesses</b> by modifying the intermediate code and allocating promotion registers. The experiments on MediaBench and DSPstone benchmark programs show that the proposed method increases the performance by 14 and 18 % on the average for ARM and MCORE, respectively. q 2004 Elsevier B. V. All rights reserved...|$|R
40|$|Abstract — Large {{register}} {{file with}} multiple ports {{is a critical}} component of a high-performance processor. A large number of registers are necessary for processing a larger number of in-flight instructions to exploit higher instruction level parallelism (ILP). And, multiple ports for a register file are necessary to support execution of multiple instructions each cycle. These necessities lead to a larger <b>register</b> <b>access</b> time. However, <b>register</b> <b>access</b> time has to be minimal to enable design of high frequency processors. A register file organization that meets the above requirements effectively enhances processor’s performance. Analysis of lifetime of a logical to physical register mapping reveals that there are long latencies between the times a physical register is allocated, consumed, and released. In this paper, we propose an effective register file organization, that exploits such long latencies, resulting in a large bandwidth with a reduced <b>register</b> <b>access</b> time. Implementation of one flavor of the proposed register file organization, as compared to a conventional monolithic register file, in an 8 -wide out-of-order issue superscalar processor enhanced instructions per cycle (IPC) throughput up to 6 % for Spec 2000 applications while reducing <b>register</b> <b>access</b> time up to 22 %. Another flavor of the register file organization, with a similar access time as the conventional monolithic register file, enhanced the IPC up to 15 %. Thus a trade-off between <b>register</b> <b>access</b> time and ILP exploitation is shown. The proposed register file organization is adaptable to other processors designed to be applicationspecific, by suitably performing register life time analysis of such processors in similar methodology as this paper...|$|R
50|$|The MTA uses many {{register}} sets, thus each <b>register</b> <b>access</b> is slow. Although concurrency (running other threads) typically hides latency, slow <b>register</b> file <b>access</b> limits performance {{when there}} are few runable threads. In existing MTA implementations, single-thread performance is 21 cycles per instruction, so performance suffers {{when there are}} fewer than 21 threads per CPU.|$|R
50|$|Study {{descriptions}} and online documentation, including questionnaires, of datasets {{can be accessed}} online free of charge and without <b>registering.</b> <b>Access</b> to data requires registration and uses federated access management (shibboleth) user authentication. Registered users can also download and explore/analyse online a large and growing number of datasets.|$|R
40|$|Abstract- We {{investigate}} programmable processor architecture {{for internet}} protocol processing and use IP packet forward {{as a case}} study. We focus on exible <b>register</b> <b>access</b> capability to support packet analysis and encapsulation. Compared to general-purpose superscalar microprocessors at least two-fold performance is achieved just with this improvement. I...|$|R
40|$|Large {{register}} {{file with}} multiple ports, {{but with a}} mini-mal access time, is a critical component in a superscalar processor. Analysis of the lifetime of a logical to physi-cal register mapping reveals that there are long latencies between the times a physical register is allocated, con-sumed, and released. In this paper, we propose a TriB-ank register file, a novel register file organization that exploits such long latencies, resulting in a larger register bandwidth and a smaller <b>register</b> <b>access</b> time. Imple-mentation of the TriBank register file organization, as compared to a conventional monolithic register file in an 8 -wide out-of-order issue superscalar processor reduced the <b>register</b> <b>access</b> time up to 34 %, even while enhancing the throughput in instructions per cycle (IPC) by 3 % and 14 %, for SpecInt 2000 and SpecFP 2000, respectively. ...|$|R
40|$|This {{paper is}} a {{supplement}} to a paper submitted to ISPASS' 03. In that paper various intervals associated with <b>register</b> and memory <b>accesses</b> were explored. This paper primarily provides additional data that was not presented in that paper. Detail about the three <b>register</b> <b>access</b> intervals {{for each of the}} benchmark programs examined is presented. Additionally, new data is presented for all of the benchmarks on the read and write access frequencies for the registers by register address. ...|$|R
50|$|The {{improved}} interface {{reduces the}} number of needed APIC <b>register</b> <b>access</b> for sending Inter-processor interrupts (IPIs). Because of this advantage, QEMU can and does emulate x2APIC for older processors that do not physically support it, going back to Conroe and even for AMD Opteron G-series processors (neither of which natively support x2APIC).|$|R
40|$|Data {{dependence}} analysis (DDA) on {{assembly code}} {{is a frequent}} problem in compilers and program analysis tools. The fundamentals of a DDA on code for simple processors are well understood. We propose a DDA method, that is applicable for {{a wider range of}} processors. This includes VLIW processors and processors with delayed branches and delayed <b>register</b> <b>accesses.</b> For these architectures, the instruction order may no longer match the order of <b>register</b> <b>accesses,</b> which necessitates a new analysis technique. The result of our analysis method is an instruction dependence graph (IDG), which also contains information on minimal instruction distances. For the mentioned architectures and allocated registers, the IDG may be cyclic. We discuss this phenomenon and outline an algorithm to reschedule such IDGs. We successfully implemented the DDA method and a respective scheduler in our compiler for the CoreVA VLIW architecture. 1...|$|R
40|$|The article {{explores the}} concept of {{simulating}} the abstraction of a shared memory in message passing systems, despite the existence of failures. This abstraction provides an atomic <b>register</b> <b>accessed</b> with read and write operations. This article describes the Attiya, Bar-Noy and Dolev simulation, its origins and generalizations, {{as well as its}} applications in theory and practice...|$|R
50|$|The YMF288, a.k.a. OPN3, is a {{development}} of the YM2608, used in later NEC PC-9801 computer soundcards. It removes the YM2608's GPIO ports, CSM-mode and the ADPCM Sound Source. It also reduces the wait times on <b>register</b> <b>access,</b> and adds a low-power standby mode. The YMF288 also came in a much smaller physical 28-pin SOP and 64-pin QFP packages.|$|R
5000|$|... #Caption: Growth of <b>registered</b> public <b>access</b> defibrillators in King County from 1999 to 2006 ...|$|R
50|$|The {{computer}} designs {{based on}} this theory were called reduced instruction set computing (RISC). RISCs usually had larger numbers of <b>registers,</b> <b>accessed</b> by simpler instructions, with a few instructions specifically to load and store data to memory. The result was a very simple core CPU running at very high speed, supporting the sorts of operations the compilers were using anyway.|$|R
25|$|T.R. Horton (editor) (1900): , Shropshire Parish <b>Register</b> Society. <b>Accessed</b> 26 May 2014 at Internet Archive.|$|R
5000|$|Before a <b>register</b> <b>access,</b> PHY devices {{generally}} {{require a}} preamble of 32 ones {{to be sent}} by the MAC on the MDIO line. The access consists of 16 control bits, followed by 16 data bits. The control bits consist of 2 start bits, 2 access type bits (read or write), the PHY address (5 bits), the register address (5 bits), and 2 [...] "turnaround" [...] bits.|$|R
50|$|There were no index <b>registers,</b> to <b>access</b> {{sequential}} {{data in a}} loop {{you used}} address modification in the instructions.|$|R
40|$|With {{the trend}} towards wider {{instruction}} issue and larger instruction windows, register les grow {{both in terms}} of size and number of read/write ports. However, large multi-ported register les consume a substantial amount of power, and may also limit the cycle time of a processor. This work attempts to address these issues by taking advantage of the facts that many <b>register</b> <b>accesses</b> show extremely good temporal locality, and that many register values are very short-lived...|$|R
50|$|The NVMe device {{interface}} {{has been designed}} from the ground up, capitalizing on the low latency and parallelism of PCI Express SSDs, and complementing the parallelism of contemporary CPUs, platforms and applications. At a high level, the basic advantages of NVMe over AHCI relate to its ability to exploit parallelism in host hardware and software, manifested by the differences in command queue depths, efficiency of interrupt processing, the number of uncacheable <b>register</b> <b>accesses,</b> etc., resulting in various performance improvements.|$|R
40|$|Current-generation {{microprocessors}} {{are designed}} to process instructions with one and two source operands at equal cost. Handling two source operands requires multiple ports for each instruction in structures [...] such as the register file and wakeup logic [...] which are often in the processor critical timing paths. We argue that these structures are overdesigned since {{only a small fraction}} of instructions require two source operands to be processed simultaneously. [n this paper, we propose the half-price architecture that judiciously removes this overdesign by restricting the processor capability to handle two source operands in certain timing-critical cases. Two techniques are proposed and evaluated: one for the wakeup logic is sequential wakeup, which decouples half of the tag matching logic from the wakeup bus to reduce the load capacitance of the bus. The other technique for the register file is sequential <b>register</b> <b>access,</b> which halves the register read ports by sequentially accessing two values using a single port when needed. We show that a pipeline that optimizes scheduling and <b>register</b> <b>access</b> for a single operand achieves nearly the same performance as an ideal base machine that fully handles two operands, with 2. 2 % (worst case 4. 8 %) IPC degradation...|$|R
50|$|The RDY pin is not {{included}} on all other 28-pin cut-down versions of the 6502. Within the Atari 2600, RDY is used to synchronise the CPU to the television video frame. This function {{is essential for the}} 'racing the beam' method used by the 6502 and Atari Television Interface Adaptor chip to generate the television video signal. In response to a specific <b>register</b> <b>access,</b> the TIA will assert RDY to extend that bus cycle {{until the end of the}} current video scan line.|$|R
50|$|In stop/step mode debugging, the core/microcontroller {{is stopped}} {{through the use}} of breakpoints. This can be used to “step” through the code. If the other cores/microcontrollers of the SoC are stopped synchronously, the overall state of the system can be {{examined}} without worrying that things may change underfoot. Stop/step mode debugging includes control/configure techniques (as given previously), run control of a core/microcontroller, start-/stop synchronization with other cores, memory and <b>register</b> <b>access</b> and additional debug features such as performance counter, run-time memory access.|$|R
50|$|Although Netprimer is {{provided}} without charge, {{it is not}} free software. Users must <b>register</b> for <b>access</b> and thereby receive advertising of Primier Biosoft's other products.|$|R
40|$|The {{register}} file is {{a critical}} component in a modern superscalar processor. It must {{be large enough to}} accommodate the results of all in-flight instructions. It must also have enough ports to allow simultaneous issue and writeback of many values each cycle. However, this makes {{it one of the most}} energy-consuming structures within the processor with a high access latency. As technology scales, there comes a point where <b>register</b> <b>accesses</b> are the bottleneck to performance and so must be pipelined over several cycles. This increases the pipeline depth, lowering performance. To overcome these challenges, we propose a novel use of compiler analysis to aid register caching. Adding a register cache allows us to preserve single-cycle <b>register</b> <b>accesses,</b> maintaining performance and reducing energy consumption. We do this by passing information to the processor using free bits in a real ISA, allowing us to cache only the most important registers. Evaluating the register cache over a variety of sizes and associativities and varying the read ports into the cache, our best scheme achieves an energy-delay-squared (EDD) product of 0. 81, with a performance increase of 11 %. Another configuration saves 13 % of register system energy. Using four register cache read ports brings both performance gains and energy savings, consistently outperformin...|$|R
50|$|In the Berkeley RISC design, {{only eight}} {{registers}} {{out of a}} total of 64 are visible to the programs. The complete set of registers are known as the register file, and any particular set of eight as a window. The file allows up to eight procedure calls to have their own register sets. As long as the program does not call down chains longer than eight calls deep, the registers never have to be spilled, i.e. saved out to main memory or cache which is a slow process compared to <b>register</b> <b>access.</b>|$|R
50|$|Fast {{access is}} also useful for interpreters. Most {{register}} interpreters specify their registers by number. But a host machine's <b>registers</b> can't be <b>accessed</b> in an indexed array, so a memory array is allotted for virtual registers. Therefore, the instructions of a register interpreter must use memory for passing generated {{data to the}} next instruction. This forces register interpreters to be much slower on microprocessors made with a fine process rule (i.e. faster transistors without improving circuit speeds, such as the Haswell x86). These require several clocks for memory access, but only one clock for <b>register</b> <b>access.</b> In {{the case of a}} stack machine with a data forwarding circuit instead of a register file, stack interpreters can allot the host machine's registers for the top several operands of the stack instead of the host machine's memory.|$|R
50|$|Clocking {{changes on}} TMS steps through a {{standardized}} JTAG state machine. The JTAG state machine can reset, <b>access</b> an instruction <b>register,</b> or <b>access</b> data {{selected by the}} instruction register.|$|R
50|$|Godard quotes {{research}} {{claiming that}} during {{operation of a}} standard register machine, values in processor <b>registers</b> are <b>accessed</b> with a frequency of: 80% once, 14% more than once, and 6% never.|$|R
30|$|We {{also present}} a generic model which {{makes use of}} each of these seed pools to modify the seed value and {{generate}} new random numbers per clock cycle. Now on each seed pool the two stages of the MT 19937 presented in Figure 3 work together to modify each seed value and generate a new one. This is illustrated in Figure 3 (b). From a point of view of circuit speed and complexity, no register is shared by more than two reading channels and one writing channel. The consequence is that <b>register</b> <b>access</b> logic is simpler, smaller, and faster.|$|R
40|$|This {{application}} note describes a reference system illustrating {{how to build}} an embedded MicroBlaze ™ system using the On-Chip Peripheral Bus Ethernet Media Access Controller (OPB EMAC) processor IP core. This reference system has all the main performance enhancing features of OPB EMAC enabled. Features such as Scatter/Gather DMA, hardware data realignment engine (DRE), and checksum offloading (CSO) are all enabled. This reference system also includes a self-test application {{that can be used}} to verify the functionality of the OPB EMAC core. This application includes <b>register</b> <b>accesses,</b> verifying DMA capabilities, and transmitting/receiving packets in loopback mode. This reference system is targeted for th...|$|R
30|$|Other {{bypassing}} {{strategies are}} possible, including pre-register allocation bypassing [28], recursively bypassing chain of operations on critical path, bypassing after the block is fully scheduled without changing schedule to reduce only <b>register</b> file <b>accesses,</b> etc.|$|R
50|$|The main axis of {{development}} was to avoid special built-in functions and procedures to interface hardware registers. These <b>registers</b> are <b>accessed</b> directly as variables, {{there are no}} wrapper functions, and emitted code is quite compact.|$|R
40|$|Transient {{errors are}} one of the major reasons for system {{downtime}} in many systems. While prior research has mainly focused on the impact of transient errors on datapath, caches and main memories, the register file has largely been neglected. Since the <b>register</b> file is <b>accessed</b> very frequently, the probability of transient errors is high. In addition, errors in it can quickly spread to different parts of the system, and cause application crash or silent data corruption. This paper addresses the reliability of register files in superscalar processors. Particularly, we propose to duplicate actively used physical registers in unused physical registers. The rationale behind this idea is that if the protection mechanism (parity or ECC) used for the primary copy indicates an error, the duplicate can provide the data {{as long as it is}} not corrupted. We implement two types of strategies based on this register duplication idea. In the “conservative strategy, ” we limit ourselves with the given register usage behavior, and duplicate register contents only on otherwise unused registers. Consequently, there is no impact on the original performance when there is no error, except for the protection mechanism used for the primary copy. Our experiments with two different versions of this strategy show that, with the more powerful conservative scheme, 78 % of the accesses are to the physical registers with duplicates. The “aggressive strategy ” sacrifices some performance to increase the number of <b>register</b> <b>accesses</b> with duplicates. It does so by marking the registers not used for a long time as “dead ” and using them for duplicating actively used registers. The experiments with this strategy indicate that it takes the fraction of the reliable <b>register</b> <b>accesses</b> to 84 %, and degrades the overall performance by only 0. 21 % on the average...|$|R
50|$|As you can see, this {{is quite}} inefficient just to access a variable. With D {{register}}s, the D2 register points {{at the base of}} the lexical level 2 environment, and all we need to do to generate the address of the variable is to add its offset from the stack frame base to the frame base address in the D register. (There is an efficient linked list search operator LLLU, which could search the stack in the above fashion, but the D register approach is still going to be faster.) With D <b>registers,</b> <b>access</b> to entities in outer and global environments is just as efficient as local variable access.|$|R
