524|739|Public
25|$|The setup or {{programming}} of {{motions and}} sequences for an industrial robot is typically taught by linking the <b>robot</b> <b>controller</b> to a laptop, desktop computer or (internal or Internet) network.|$|E
25|$|Software: The {{computer}} is installed with corresponding interface software. The {{use of a}} computer greatly simplifies the programming process. Specialized robot software is run either in the <b>robot</b> <b>controller</b> or in the computer or both depending on the system design.|$|E
2500|$|For a given robot {{the only}} {{parameters}} necessary to completely locate {{the end effector}} (gripper, welding torch, etc.) of the robot are the angles {{of each of the}} joints or displacements of the linear axes (or combinations of the two for robot formats such as SCARA). However, there are many different ways to define the points. The most common and most convenient way of defining a point is to specify a Cartesian coordinate for it, i.e. the position of the 'end effector' in mm in the X, Y and Z directions relative to the robot's origin. In addition, depending on the types of joints a particular robot may have, the orientation of the end effector in yaw, pitch, and roll and the location of the tool point relative to the robot's faceplate must also be specified. For a jointed arm these coordinates must be converted to joint angles by the <b>robot</b> <b>controller</b> and such conversions are known as Cartesian Transformations which may need to be performed iteratively or recursively for a multiple axis robot. The mathematics of the relationship between joint angles and actual spatial coordinates is called kinematics. See robot control ...|$|E
40|$|Industrial Robots {{are complex}} systems with hard real time, high safety, {{reliability}} and availability requirements. <b>Robot</b> <b>Controllers</b> are part of these systems and they are complex hard real time computers, which control a robot's mechanical parts. To be useful, <b>Robot</b> <b>Controllers</b> must be programmable by end customers. This is typically done through a domain and vendor specific programming languages...|$|R
5000|$|Module for ABB Robotics IRC5 and S4 <b>robot</b> <b>controllers.</b> Contains robotic motion {{programs}} {{written in}} the language RAPID.|$|R
30|$|TMS_RC: nodes for {{executing}} robot motions. TMS_RC contains various <b>robot</b> <b>controllers</b> {{including a}} humanoid-type robot and a wheel chair robot.|$|R
5000|$|... 1983: Development the company's own <b>robot</b> <b>controller</b> - ROBOTstar ...|$|E
5000|$|A new <b>robot</b> <b>controller</b> {{based on}} the PIC18F8722 instead of the PIC18F8520 ...|$|E
50|$|The <b>robot</b> <b>controller</b> {{programs}} can be written in C, C++, Java, Python and MATLAB using a simple API.|$|E
40|$|In {{order to}} evolve large <b>robot</b> <b>controllers</b> for {{increasingly}} complex tasks, fully connected neural networks are not feasible. However, manually designing sparse neural connectivity is not intuitive, and thus {{should be placed}} under evolutionary control. Here I show how spontaneous structural modularity can arise in the connectivity of evolved <b>robot</b> <b>controllers</b> if the controllers are boolean networks, and are selected to converge on point attractors that correspond to successful robot behaviors. Categories and Subject Descriptor...|$|R
40|$|This report {{follows the}} {{development}} and analysis of four dynamical networks evolved for controlling a simulated <b>robot.</b> The <b>controllers</b> were evolved to perform the task of catching a series of falling balls, based {{on a set of}} experiments developed by Beer (1996) to test the cognitive ability of <b>robot</b> <b>controllers...</b>|$|R
40|$|We {{explore the}} concept of {{development}} without programming by children. Especially, {{we look at the}} case of developing robot control systems. The evolutionary robotics approach has shown that in some cases, given a mathematically described fitness function, it is possible to achieve an automatic development of <b>robot</b> <b>controllers.</b> However, it is questionable how one is to construct the mathematical fitness function. So we applied an interactive genetic algorithm to the problem of developing <b>robot</b> <b>controllers</b> and achieved an evolutionary robotics approach that allows children without any programming knowledge to develop <b>controllers</b> for LEGO <b>robots.</b> We used neural networks as <b>robot</b> <b>controllers,</b> and found that combining the interactive genetic algorithm with a kind of reinforcement learning [...] development at the evolutionary time scale combined with life-time development [...] reduces the development time drastically. Hence, we overcome one of the major drawbacks of the interactive genetic algor [...] ...|$|R
50|$|During {{the years}} 1980-1989, several <b>robot</b> <b>controller</b> cars were {{produced}} and a 3D robot-simulation engine for PC. Several smaller robots were built.|$|E
5000|$|... #Caption: The XBC <b>robot</b> <b>controller.</b> The Game Boy Advance, Game Boy Micro, or Game Boy Advance SP can be {{used with}} the XBC.|$|E
50|$|In the 2015-2016 FTC Res-q season, the NXT bricks {{that were}} used {{previously}} as the <b>robot</b> <b>controller</b> were replaced by Android phones running Android KitKat (4.4).|$|E
40|$|International audienceThe {{implementation}} of high-performance <b>robot</b> <b>controllers</b> for complex control {{tasks such as}} playing autonomous robot soccer is tedious, error-prone, and a never ending programming task. In this paper we propose programmers to write autonomous controllers that optimize and automatically adapt themselves to changing circumstances of task execution using explicit perception, dynamics and action models. To this end we develop ROLL (Robot Learning Language), a control language allowing for model-based robot programming. ROLL provides language constructs for specifying executable code pieces of how to learn and update these models. We are currently using ROLL's mechanisms for implementing a rational reconstruction of our soccer <b>robot</b> <b>controllers...</b>|$|R
50|$|INTERBUS is {{a serial}} bus system which transmits data between control systems (e.g., PCs, PLCs, VMEbus computers, <b>robot</b> <b>controllers</b> etc.) and {{spatially}} distributed I/O modules that {{are connected to}} sensors and actuators (e.g., temperature sensors, position switches).|$|R
40|$|Abstract: A skill {{transfer}} and improvement framework {{was designed and}} implemented to transfer skills to a simulated robot {{without the help of}} a robotics expert. A skill expert learns first how to perform the desired task by maneuvering the robot and giving actuator commands using the keyboard. The framework is then used to transfer the expert’s skills to a robot by teaching the <b>robot’s</b> <b>controller</b> how to perform the skill. CMAC neural networks are responsible for learning skills. Learning is accomplished using imitation of the demonstrated movements that are mapped to a set of primitives. After transferring a skill, the expert can give advice to the <b>robot’s</b> <b>controller</b> to improve the robot’s performance. 1...|$|R
50|$|The EZ80L92 is {{the primary}} {{processor}} in the ST Robotics <b>robot</b> <b>controller,</b> clocked at 50MHz. It has 128Kb of external RAM and 128Kb of external flash memory.|$|E
5000|$|RoboDK - A robot {{development}} kit {{platform to}} simulate industrial robots. RoboDK {{allows you to}} program any robot using Python and handles brand-specific syntax depending on your <b>robot</b> <b>controller.</b>|$|E
50|$|The setup or {{programming}} of {{motions and}} sequences for an industrial robot is typically taught by linking the <b>robot</b> <b>controller</b> to a laptop, desktop computer or (internal or Internet) network.|$|E
40|$|In {{traditional}} evolutionary robotics, <b>robot</b> <b>controllers</b> are {{evolved in}} a separate design phase preceding actual deployment; we call this off-line evolution. Alternatively, <b>robot</b> <b>controllers</b> can evolve while the robots perform their proper tasks, during the actual operational phase; we call this on-line evolution. In this paper we describe three principal categories of on-line evolution for developing <b>robot</b> <b>controllers</b> (encapsulated, distributed, and hybrid), present an evolutionary algorithm belonging to the first category (the (l ? 1) ON-LINE algorithm), and perform an extensive study of its behaviour. In particular, we use the Bonesa parameter tuning method to explore its parameter space. This delivers near-optimal settings for our algorithm {{in a number of}} tasks and, even more importantly, it offers profound insights into the impact of our algorithm’s parameters and features. Our experimental analysis of (l ? 1) ON-LINE shows that it seems preferable to try many alternative solutions and spend little effort on refining possibly faulty assessments; that there is no single combination of parameters that performs well on all problem instances and that the most influential parameter of this algorithm—and therefore the prime candidate for a control scheme—is the evaluation length s...|$|R
5000|$|TekBots are {{centered}} on the Atmel microcontroller platform. This is the [...] "brain" [...] of the robot as it controls the robot's two motorized wheels allowing it to move. The <b>robot's</b> <b>controller</b> boards, wheels and all other peripherals are housed in an aluminum base.|$|R
40|$|In {{this paper}} we present our {{experience}} {{in the development of}} real-time <b>controllers</b> for special <b>robots,</b> designed to perform maintenance operations in nuclear power plants. The evolution of computer hardware and software technology has made the requirements of the embedded <b>robot</b> <b>controllers</b> to also evolve. In addition to the usual concurrent software and real-time constraints, today our robots require advanced features such as network communications, file systems, and graphical user interfaces. To meet all these requirements we not only need a reliable concurrent programming language such as Ada, but we also need to use services provided by real-time operating systems. In this paper we want to present our successful {{experience in the}} development of <b>robot</b> <b>controllers</b> using the Ada language and a POSIX real-time operating system...|$|R
50|$|The TU58 is {{also used}} with other computers, such as the Automatix Autovision machine vision system and AI32 <b>robot</b> <b>controller.</b> TU58 driver {{software}} is available for modern PCs running DOS.|$|E
50|$|The Automatix AI-32 <b>robot</b> <b>controller</b> {{used the}} same processor, bus and RAIL {{language}} as the AV II, IV and 5, allowing frame grabber and processing boards to be added for integrated machine vision.|$|E
50|$|Software: The {{computer}} is installed with corresponding interface software. The {{use of a}} computer greatly simplifies the programming process. Specialized robot software is run either in the <b>robot</b> <b>controller</b> or in the computer or both depending on the system design.|$|E
40|$|In {{evolutionary}} robotics {{methods of}} evolutionary computation {{are applied to}} evolve <b>robot</b> <b>controllers</b> [1]. Evolutionary robotics is also our method of choice in the EU-funded project flora robotica [6, 8], which pushes research towards {{the evolution of a}} broad variety of artifacts and contraptions [4]. W...|$|R
50|$|The {{mechanical}} components used in Botball are Lego Technic bricks. The electrical components have included {{a variety of}} <b>robot</b> <b>controllers,</b> of which each team's kit contains two (enabling them to build two fully autonomous robots out of each kit), {{as well as a}} number of different sensors and motors.|$|R
40|$|We applied Reinforcement Learning (RL) {{on a real}} {{robot arm}} {{actuated}} by two pneumatic artificial muscles that expose a highly nonlinear behaviour. To facilitate learning, we developed an empirical model based on real robot observations. Using the learned simulation model, reinforcement learning was able to quickly learn good <b>robot</b> <b>controllers.</b> 1...|$|R
50|$|Data {{and program}} usually reside in {{separate}} {{sections of the}} <b>robot</b> <b>controller</b> memory. One can change the data without changing the program and vice versa. For example, one can write a different program using the same Jig1 or one can adjust the position of Jig1 without changing the programs that use it.|$|E
50|$|RNA are {{the sole}} {{agents in the}} UK & Ireland for the SVIA range of Vision Guided Robotic Systems. All systems have a Robotic arm for {{handling}} and manipulating the product, a camera system and share the same pc based control system {{and in most cases}} integrated with a standard ABB <b>robot</b> <b>controller.</b>|$|E
50|$|Nadine’s {{platform}} is implemented {{as a classic}} Perception-Decision-Action architecture. The perception layer is composed of a Microsoft Kinect V2 and a microphone. The perception includes face recognition, gestures recognition and some understanding of social situations. In regards to decision, the platform includes emotion and memory models {{as well as social}} attention. Finally, the action layer consists of a dedicated <b>robot</b> <b>controller</b> which includes emotional expressions, lips synchronization and online gaze generation.|$|E
50|$|Orchestra for Open <b>Robot</b> <b>Controllers</b> {{allows the}} {{feasibility}} of innovative industrial robot algorithms to be tested. It can integrate advanced sensors and functions. Its interface with a personal computer is via OrchestraCore. Its function is generally one of realization of movement rather than the logic of control and the generation of trajectory.|$|R
40|$|International audienceIn many {{applications}} {{the performance of}} learned <b>robot</b> <b>controllers</b> drags behind those of the respective hand-coded ones. In our view, this situation is caused not mainly by deficiencies of the learning algorithms but rather by an insufficient embedding of learning in robot control programs. This paper presents {{a case study in}} which ROLL, a robot control language that allows for explicit representations of learning problems, is applied to learning robot navigation tasks. The case study shows that ROLL's constructs for specifying learning problems (1) make aspects of autonomous robot learning explicit and controllable; (2) have an enormous impact on the performance of the learned controllers and therefore encourage the engineering of high performance learners; (3) make the learning processes repeatable and allow for writing bootstrapping <b>robot</b> <b>controllers.</b> Taken together the approach constitutes an important step towards engineering controllers of autonomous learning robots...|$|R
40|$|Abstract Wireless {{communication}} is an enabling factor in multiple mobile robot systems. There is significant interaction between <b>robot</b> <b>controllers</b> and communications subsystems. We present {{a method for}} evaluating combined robot control/communication strategies for a team of wireless-networked robots performing a resource transportation task. Two alternative controller designs are compared under established communication and radio propagation models. For each we measure the overall performance of the robot team including the cost of communication. The study illustrates how our evaluation tools {{can be used for}} designing <b>controllers</b> for <b>robots</b> operating in wireless communication environments. 1 Introduction Successful control and coordination of a group of wireless-networked robots relies on effective inter-robot communication. Conventional <b>robot</b> <b>controllers</b> should be robust with respect to uncertainty and variation in sensing and actuation; controllers that exploit information distributed over a wireless network must also contend with imperfect communication...|$|R
