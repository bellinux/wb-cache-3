94|10000|Public
5000|$|The {{function}} always {{evaluates the}} same <b>result</b> <b>value</b> {{given the same}} argument value(s). The function <b>result</b> <b>value</b> cannot depend on any hidden information or state that may change while program execution proceeds or between different executions of the program, nor can it depend on any external input from I/O devices (usually—see below).|$|E
5000|$|<b>Result</b> (<b>value</b> {{that goes}} to {{destination}} or indication of a (un)successful jump) ...|$|E
5000|$|With | as separator, some {{functions}} return {{wrapped the}} <b>result</b> <b>value</b> with {{an evaluation of}} predicates ...|$|E
30|$|Once pairing {{process is}} complete, {{authentication}} module returns <b>result</b> <b>values</b> to a relevant module. The <b>results</b> <b>values</b> are module ID, the creation {{time of the}} <b>results</b> <b>value,</b> module name, module version, and checked flag. They are encrypted with a manufacturer’s public key before being transmitted. If authentication successes, checked flag has “Permitted”; if authentication fails, it has “not permitted”. Authentication module saves <b>result</b> <b>values.</b> After that, if the same module is inserted, the module checks checked flag of the <b>result</b> <b>values,</b> and, if “not Permitted”, it makes an authentication request again.|$|R
5000|$|In simple settings, the <b>resulting</b> <b>value</b> {{is usually}} one of various {{primitive}} types, such as numerical, string, and logical; in more elaborate settings, {{it can be}} an arbitrary complex data type. In functional programming, the <b>resulting</b> <b>values</b> are often functions or expressions, which can themselves be further evaluated.|$|R
5000|$|... /* C {{function}} to change endianness for byte swap in an unsigned 32-bit integer */uint32_t ChangeEndianness(uint32_t value){ uint32_t result = 0; <b>result</b> |= (<b>value</b> & 0x000000FF) << 24; <b>result</b> |= (<b>value</b> & 0x0000FF00) << 8; <b>result</b> |= (<b>value</b> & 0x00FF0000) >> 8; <b>result</b> |= (<b>value</b> & 0xFF000000) >> 24; return result;} ...|$|R
5000|$|Due to {{the nature}} of {{histogram}} equalization, the <b>result</b> <b>value</b> of a pixel under AHE is proportional to its rank among the pixels in its neighbourhood. This allows an efficient implementation on specialist hardware that can compare the center pixel with all other pixels in the neighbourhood. [...] An unnormalized <b>result</b> <b>value</b> can be computed by adding 2 for each pixel with a smaller value than the center pixel, and adding 1 for each pixel with equal value.|$|E
5000|$|PHP4Delphi {{also allows}} {{executing}} the PHP scripts within the Delphi program directly from file or memory. You can {{read and write}} global PHP variables and set the <b>result</b> <b>value.</b>|$|E
50|$|It {{is a more}} {{convenient}} version of catamorphism in that it gives the combining step function immediate access {{not only to the}} <b>result</b> <b>value</b> recursively computed from each recursive subobject, but the original subobject itself as well.|$|E
2500|$|Compute {{histogram}} of the <b>resulting</b> <b>values,</b> called {{signature of}} the image; ...|$|R
50|$|The <b>resulting</b> <b>value</b> of rh will {{range between}} −1 and +1.|$|R
5000|$|Compute {{histogram}} of the <b>resulting</b> <b>values,</b> called {{signature of}} the image; ...|$|R
50|$|Some numbers {{may have}} several {{representations}} {{in the model}} that has just been described. For instance, if b=10 and p=7, −12.345 can be represented by −12345×10−3, −123450×10−4, and −1234500×10−5. However, for most operations, such as arithmetic operations, the <b>result</b> (<b>value)</b> {{does not depend on}} the representation of the inputs.|$|E
50|$|In {{register}} machines, {{a common}} subexpression (a subexpression {{which is used}} multiple times with the same <b>result</b> <b>value)</b> can be evaluated just once and its result saved in a fast register. The subsequent reuses have no time or code cost, just a register reference. This optimization speeds simple expressions (for example, loading variable X or pointer P) as well as less-common complex expressions.|$|E
50|$|In the function-level {{style of}} programming, a program is built {{directly}} from {{programs that are}} given at the outset, by combining them with program-forming operations or functionals. Thus, {{in contrast with the}} value-level approach that applies the given programs to values to form a succession of values culminating in the desired <b>result</b> <b>value,</b> the function-level approach applies program-forming operations to the given programs to form a succession of programs culminating in the desired result program.|$|E
50|$|The <b>resulting</b> <b>value</b> for the Sun is 6.87 steradians. The <b>resulting</b> <b>value</b> for the Moon is 6.67 steradians. In {{terms of}} the total {{celestial}} sphere, the Sun and the Moon subtend fractional areas of 0.000546% (Sun) and 0.000531% (Moon). On average, the Sun is larger in the sky than the Moon {{even though it is}} much, much farther away.|$|R
3000|$|... (c)Blood {{perfusion}} {{feature extraction}} and <b>resulting</b> <b>values</b> were statistically evaluated between different irradiated groups.|$|R
5000|$|To encrypt a message, add each {{keystream}} {{value to}} its corresponding {{character in the}} plaintext, rolling over back to 1 if the <b>resulting</b> <b>value</b> exceeds 26 (modulo 26 arithmetic). To decrypt, subtract each keystream value from its corresponding character in the ciphertext, rolling back up to 26 if the <b>resulting</b> <b>value</b> should be lower than 1. (In mathematics this is called modular arithmetic.) ...|$|R
50|$|The <b>result</b> <b>value</b> {{need not}} depend on all (or any) of the {{argument}} values. However, it must depend on nothing other than the argument values. The function may return multiple result values and these conditions must apply to all returned values for the function to be considered pure. If an argument is passed by reference, any parameter mutation will alter {{the value of the}} argument outside the function, which will render the function impure.|$|E
50|$|The action memory {{model is}} based on a {{variable}} store, and does not make use of registers or a stack. With the exception of one predefined, internal <b>result</b> <b>value</b> variable, all variables are preallocated (and typed) at compilation time. These variables are represented {{in the form of a}} table referred to as an augmented reference table, where the content of the table is initialized at compilation time, then stored and mutated at runtime by an ETV User Agent.|$|E
50|$|Following the {{description}} of the measurement procedure and the laying down of the complete model equation, the knowledge of all input variables (values, distribution function, standard uncertainties) can be illustrated in the uncertainty budget.From this it is then possible to determine the <b>result</b> <b>value</b> and its standard uncertainty-, the expansion factor and the specification of the expanded measurement uncertainty.For series of measurements (continually sampled measurement sequences), distinction must be made between two cases: constant measurement uncertainty budget and changeable measurement uncertainty budget.|$|E
5000|$|Decrement: A (or B) is {{decreased}} {{by one and}} the <b>resulting</b> <b>value</b> appears at Y.|$|R
5000|$|If [...] {{apply this}} {{algorithm}} to [...] and , and apply Property 2 to the <b>resulting</b> <b>value.</b>|$|R
40|$|In this study, Lagrange {{interpolation}} technique {{which could}} be an alternative modeling passing to exactly all data points with respect to linear or nonlinear models was applied to experimental data by using Maple 6 packaged software. Since this model is a polynomial function, researcher could easily find extremum points and turning points (if exist) or he/she could easily find the <b>result</b> <b>values</b> of the interpolation values of a factor or the interpolation <b>values</b> of the <b>result</b> <b>values</b> of a factor. The standard errors of the <b>result</b> <b>values</b> mentioned above could be found with Lagrange interpolation method. Confidence bounds were determined according to statistical significance level. For that reason, density of the sowing of cotton variety Ersan- 92 belonging to {{the first year of}} the experiment data is used...|$|R
5000|$|An {{example of}} Rebol's dialecting {{abilities}} {{can be seen}} with the word [...] In the data exchange dialect [...] is just a word not having any specific meaning. In the do dialect, [...] is a global variable referring to a native function passing back a function <b>result</b> <b>value.</b> In the visual interface dialect (VID), [...] is a keyword causing the layout engine to simulate a carriage return, moving the [...] "rendering pen" [...] down {{to the beginning of}} the next line.|$|E
50|$|The World Editor tool {{includes}} a graphical script editor {{designed to be}} accessible to artists and level designers as well as programmers. The script editor allows the user to place various “methods” into a directed graph connected by “fibers” representing action dependencies and the order of execution. Scripts support loops {{through the creation of}} cycles in the graph structure, and conditional execution is supported by marking fibers to be followed or not followed based on the <b>result</b> <b>value</b> output by the methods at which they start.|$|E
50|$|Furthermore, the {{reservation}} station scheme has four places (Future File, Reservation Station, Reorder Buffer and Architectural File) where a <b>result</b> <b>value</b> can be stored, whereas the tag-indexed scheme has just one (the physical register file). Because {{the results from}} the functional units, broadcast to all these storage locations, must reach a much larger number of locations in the machine than in the tag-indexed scheme, this function consumes more power, area, and time. Still, in machines equipped with very accurate branch prediction schemes and if execute latencies are a major concern, reservation stations can work remarkably well.|$|E
5000|$|For {{a typical}} of aCWmin=15 and aCWmax=1023, as used, for example, by OFDM (802.11a) and MIMO (802.11n), the <b>resulting</b> <b>values</b> are as following: ...|$|R
50|$|The <b>resulting</b> <b>value</b> of B1 is in {{the range}} 0 - 249. The special value 254 is used to return to ASCII {{encoding}} mode.|$|R
5000|$|... #Caption: PCA (a linear {{dimensionality}} reduction algorithm) is used {{to reduce}} this same dataset into two dimensions, the <b>resulting</b> <b>values</b> are not so well organized.|$|R
50|$|The void type, {{in several}} {{programming}} languages derived from C and Algol68, {{is the type}} for {{the result of a}} function that returns normally, but does not provide a <b>result</b> <b>value</b> to its caller. Usually such functions are called for their side effects, such as performing some task or writing to their output parameters. The usage of the void type in such context is comparable to procedures in Pascal and syntactic constructs which define subroutines in Visual Basic. It is also similar to the unit type used in functional programming languages and type theory. See Unit type#In programming languages for a comparison.|$|E
5000|$|... {{extension}} Integer { // Convert any {{integer type}} to any base (2—36) func toBase(_ b: Int) -> String { guard (2...36).contains(b) else { fatalError("Base out of range; 2 — 36 supported") } let digits = [...] "a","b","c","d","e","f","g","h","i","j", [...] "k","l","m","n","o","p","q","r","s","t", [...] "u","v","w","x","y","z" [...] var result = [...] "" [...] if let v = self as? Int { var value = abs(v) repeat { result = digits% b + <b>result</b> <b>value</b> = value / b } while (value > 0) } return self > 0 ? result : [...] "-" [...] + result }}// Swift 3 built-inString(myInt, radix: 36) ...|$|E
50|$|In {{computational}} fluid dynamics, the PLOT3D {{file format}} {{is a standard}} file format used for storing grid and results data. PLOT3D was created by NASA Ames Research Center in 1982 by Pieter Buning and remains an often used file format. It can only store a structured grid. The structured grid allows random access, that is by knowing the block number, i location, j location, and k location, any grid point value or <b>result</b> <b>value</b> may be extracted. Additionally, given the location of any value, the block number, i location, j location, and k location may be determined. This makes it simple to iterate {{through a series of}} volumetric elements and calculate all required properties for the purpose of a CFD analysis.|$|E
5000|$|The {{calculation}} method is optimized for paper schemas. In contrast to APACHE II, the <b>resulting</b> <b>value</b> {{is much better}} at comparing patients with different diseases [...]|$|R
5000|$|The {{magic is}} in the Applicative and Functor {{instances}} of the data type FormResult, where (<*>) collects the error messages for the case of [...] <b>result</b> <b>values</b> ...|$|R
3000|$|SBOX (...) : Also {{known as}} a {{substitution}} box, it has series of generated numbers in a lookup table that are indexed by the <b>resulting</b> <b>values</b> in KeyAddition (...) [...].|$|R
