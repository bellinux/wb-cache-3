88|0|Public
2500|$|The runtime {{bottleneck}} of Shor's {{algorithm is}} quantum modular exponentiation, which {{is by far}} slower than the quantum Fourier transform and classical pre-/post-processing. There are several approaches to constructing and optimizing circuits for modular exponentiation. The simplest and (currently) most practical approach is to mimic conventional arithmetic circuits with reversible gates, starting with <b>ripple-carry</b> adders. Knowing the base and the modulus of exponentiation facilitates further optimizations. Reversible circuits typically use {{on the order of}} [...] gates for [...] qubits. Alternative techniques asymptotically improve gate counts by using quantum Fourier transforms, but are not competitive with less than 600 qubits due to high constants.|$|E
5000|$|... #Subtitle level 2: Example: an {{asynchronous}} <b>ripple-carry</b> adder ...|$|E
5000|$|... #Caption: A 4-bit <b>ripple-carry</b> {{adder-subtractor}} {{based on}} a 4-bit adder that performs two's complement on [...] when [...] to yield ...|$|E
50|$|The {{layout of}} a <b>ripple-carry</b> adder is simple, which allows fast design time; however, the <b>ripple-carry</b> adder is {{relatively}} slow, since each full adder must {{wait for the}} carry bit to be calculated from the previous full adder.The gate delay can easily be calculated by inspection of the full adder circuit.Each full adder requires three levels of logic. In a 32-bit <b>ripple-carry</b> adder, there are 32 full adders, so the critical path (worst case) delay is 3 × 31 (from input to later adder) + 2 (in later adder) = 95 gate delays. The general equation for the worst-case delay for a n-bit carry-ripple adder isThe delay from bit position 0 to the carry-out is a little different:The carry-in must travel through n XOR-gates in adders and n carry-generator blocks {{to have an effect}} on the carry-out.A design with alternating carry polarities and optimized AND-OR-Invert gates can be about twice as fast.|$|E
50|$|A carry-skip adder (also {{known as}} a carry-bypass adder) is an adder {{implementation}} that improves on the delay of a <b>ripple-carry</b> adder with little effort compared to other adders. The improvement of the worst-case delay is achieved by using several carry-skip adders to form a block-carry-skip adder.|$|E
50|$|The {{net effect}} {{is that the}} carries start by {{propagating}} slowly through each 4-bit group, just as in a <b>ripple-carry</b> system, but then move four times as fast, leaping from one lookahead carry unit to the next. Finally, within each group that receives a carry, the carry propagates slowly within the digits in that group.|$|E
5000|$|It is {{possible}} to create a logical circuit using multiple full adders to add N-bit numbers. Each full adder inputs a Cin, which is the Cout of the previous adder. This kind of adder is called a <b>ripple-carry</b> adder, since each carry bit [...] "ripples" [...] to the next full adder. Note that the first (and only the first) full adder may {{be replaced by a}} half adder (under the assumption that Cin = 0).|$|E
50|$|If an adding circuit is {{to compute}} the sum of three or more numbers, it can be {{advantageous}} to not propagate the carry result. Instead, three-input adders are used, generating two results: a sum and a carry. The sum and the carry may be fed into two inputs of the subsequent 3-number adder without having to wait for propagation of a carry signal. After all stages of addition, however, a conventional adder (such as the <b>ripple-carry</b> or the lookahead) must be used to combine the final sum and carry results.|$|E
5000|$|A <b>ripple-carry</b> adder {{works in}} the same way as pencil-and-paper methods of addition. Starting at the {{rightmost}} (least significant) digit position, the two corresponding digits are added and a result obtained. It is also possible that there may be a carry out of this digit position (for example, in pencil-and-paper methods, [...] "9+5=4, carry 1"). Accordingly, all digit positions other than the rightmost need to take into account the possibility of having to add an extra 1, from a carry that has come in from the next position to the right.|$|E
5000|$|The runtime {{bottleneck}} of Shor's {{algorithm is}} quantum modular exponentiation, which {{is by far}} slower than the quantum Fourier transform and classical pre-/post-processing. There are several approaches to constructing and optimizing circuits for modular exponentiation. The simplest and (currently) most practical approach is to mimic conventional arithmetic circuits with reversible gates, starting with <b>ripple-carry</b> adders. Knowing the base and the modulus of exponentiation facilitates further optimizations. Reversible circuits typically use {{on the order of}} [...] gates for [...] qubits. Alternative techniques asymptotically improve gate counts by using quantum Fourier transforms, but are not competitive with less than 600 qubits due to high constants.|$|E
5000|$|This greatly {{reduces the}} latency of the adder through its {{critical}} path, since the carry bit for each block can now [...] "skip" [...] over blocks {{with a group}} propagate signal set to logic 1 (as opposed to a long <b>ripple-carry</b> chain, which would require the carry to ripple through each bit in the adder).The number of inputs of the AND-gate {{is equal to the}} width of the adder. For a large width, this becomes impractical and leads to additional delays, because the AND-gate has to be built as a tree. A good width is achieved, when the sum-logic has the same depth like the n-input AND-gate and the multiplexer.|$|E
5000|$|This {{means that}} no digit {{position}} {{can have an}} absolutely final value until it has been established {{whether or not a}} carry is coming in from the right. Moreover, if the sum without a carry is 9 (in pencil-and-paper methods) or 1 (in binary arithmetic), it is not even possible to tell whether or not a given digit position is going to pass on a carry to the position on its left. At worst, when a whole sequence of sums comes to ...99999999... (in decimal) or ...11111111... (in binary), nothing can be deduced at all until the value of the carry coming in from the right is known, and that carry is then propagated to the left, one step at a time, as each digit position evaluated [...] "9+1=0, carry 1" [...] or [...] "1+1=0, carry 1". It is the [...] "rippling" [...] of the carry from right to left that gives a <b>ripple-carry</b> adder its name, and its slowness. When adding 32-bit integers, for instance, allowance has to be made for the possibility that a carry could have to ripple through every one of the 32 one-bit adders.|$|E
40|$|Abstract—This paper {{proposes a}} {{mathematical}} model for proba-bilistic <b>ripple-carry</b> adders. The model gives explicit expressions for calculating error probabilities of sum and carry bits. The expressions show how errors propagate through the carry, which accumulate and eventually influence the correctness of a <b>ripple-carry</b> adder’s outputs. The proposed model is flexible since it only requires mild assumptions on the probability distribution of noise. Hence, in addition to Gaussian, it is applicable to a wide class of distributions. We validate the model through HSPICE simulation. The model is able to predict error-rates of a simulated probabilistic <b>ripple-carry</b> adder with reasonable accuracy. Keywords-Probabilistic computation; <b>ripple-carry</b> adder; error prop-agation; noise modeling. I...|$|E
40|$|We {{present the}} design of a quantum carry-lookahead adder using measurement-based quantum computation. QCLA {{utilizes}} MBQC`s ability to transfer quantum states in unit time to accelerate addition. The quantum carry-lookahead adder (QCLA) is faster than a quantum <b>ripple-carry</b> adder; QCLA has logarithmic depth while ripple adders have linear depth. QCLA is an order of magnitude faster than a <b>ripple-carry</b> adder when adding registers longer than 100 qubits but requires a cluster state that is an order of magnitude larger. Hand optimization results in a ≈ 26...|$|E
40|$|Abstract. In {{this work}} {{modelling}} {{of the power}} consumption for <b>ripple-carry</b> adders implemented in CMOS is considered. Based on the switching activity of each input bit, two switching models, one full and one simplified, are derived. These switching models {{can be used to}} derive the average energy consumed for one computation. This work extends previous results by introducing a data dependent power model, i. e., correlated input data is considered. Examples show that the switching model is accurate, while there are some differences in the power consumption. This {{is due to the fact}} that not all switching in the <b>ripple-carry</b> adder is rail-to-rail (full swing) in the actual implementation. ...|$|E
40|$|Abstract—Probabilistic CMOS is {{considered}} a promising technology for future generations of computing devices. By embracing possibly incorrect calculations, the technology {{makes it possible to}} trade correct-ness of circuit operations for potentially significant energy saving. For systematic design of probabilistic circuits, accurate mathematical models are indispensable. To this end, we propose a model of probabilistic <b>ripple-carry</b> adders. Compared to existing models, ours is applicable under a wide range of noise assumptions, including the popular additive-noise assumption. Our model provides recursive equations that can accurately capture propagation of carry errors. The proposed model is validated by HSPICE simulation, and we find that the model is able to predict multi-bit error-rates of a simulated probabilistic <b>ripple-carry</b> adder with reasonable accuracy. I...|$|E
40|$|Abstract—Efficient modulo 2 n + 1 adders are {{important}} for several applications including residue number system, digital signal processors and cryptography algorithms. In this paper we present a novel modulo 2 n + 1 addition algorithm for a recently represented number system. The proposed approach is introduced for {{the reduction of the}} power dissipated. In a conventional modulo 2 n + 1 adder, all operands have (n+ 1) -bit length. To avoid using (n+ 1) -bit circuits, the diminished- 1 and carry save diminished- 1 number systems can be effectively used in applications. In the paper, we also derive two new architectures for designing modulo 2 n + 1 adder, based on n-bit <b>ripple-carry</b> adder. The first architecture is a faster design whereas the second one uses less hardware. In the proposed method, the special treatment required for zero operands in Diminished- 1 number system is removed. In the fastest modulo 2 n + 1 adders in normal binary system, there are 3 -operand adders. This problem is also resolved in this paper. The proposed architectures are compared with some efficient adders based on <b>ripple-carry</b> adder and highspeed adder. It is shown that the hardware overhead and power consumption will be reduced. As well as power reduction, in some cases, power-delay product will be also reduced. n Keywords—Modulo 2 � 1 arithmetic, residue number system, low power, <b>ripple-carry</b> adders. I...|$|E
40|$|Abstract. We {{present the}} design of a quantum carry-lookahead adder using measurement-based quantum computation. The quantum carry-lookahead adder (QCLA) is faster than a quantum <b>ripple-carry</b> adder; QCLA has {{logarithmic}} depth while ripple adders have linear depth. Our design is evaluated in terms of number of time steps and the total number of qubits used...|$|E
40|$|In {{this work}} {{a model for}} {{estimation}} of the switching activity in <b>ripple-carry</b> adders is presented. The model is based on word-level statistics, such as mean, variance, and correlation, of the two input signals to be added. It is shown that the proposed model gives accurate results when the two’scomplement represented inputs are real world signals. 1...|$|E
40|$|We {{present the}} design and {{evaluation}} of a quantum carry-lookahead adder (QCLA) using measurement-based quantum computation (MBQC), called MBQCLA. QCLA was originally designed for an abstract, concurrent architecture supporting long-distance communication, but most realistic architectures heavily constrain communication distances. The quantum carry-lookahead adder is faster than a quantum <b>ripple-carry</b> adder; QCLA has logarithmic depth while ripple adders have linear depth. MBQCLA utilizes MBQC's ability to transfer quantum states in unit time to accelerate addition. MBQCLA breaks the latency limit of addition circuits in nearest neighbor-only architectures : compared to the Θ(n) limit on circuit depth for linear nearest-neighbor architectures, it can reach Θ(log n) depth. MBQCLA is {{an order of magnitude}} faster than a <b>ripple-carry</b> adder when adding registers longer than 100 qubits, but requires a cluster state that is an order of magnitude larger. The cluster state resources can be classified as computation and communication; for the unoptimized form, ≈ 88...|$|E
40|$|We {{present the}} design of a quantum carry-lookahead adder using measurement-based quantum computation. The quantum carry-lookahead adder (QCLA) is faster than a quantum <b>ripple-carry</b> adder; QCLA has {{logarithmic}} depth while ripple adders have linear depth. Our design is evaluated in terms of number of time steps and the total number of qubits used. Comment: 2 pages, 3 figures, Asian Conference on Quantum Information Science 2008, KIAS, South Kore...|$|E
40|$|Abstract. We {{present the}} design of a quantum carry-lookahead adder using measurement-based quantum computation. QCLA {{utilizes}} MBQC‘s ability to transfer quantum states in unit time to accelerate addition. The quantum carry-lookahead adder (QCLA) is faster than a quantum <b>ripple-carry</b> adder; QCLA has logarithmic depth while ripple adders have linear depth. QCLA is an order of magnitude faster than a <b>ripple-carry</b> adder when adding registers longer than 100 qubits but requires a cluster state that is an order of magnitude larger. Hand optimization results in a ≈ 26 % reduction in spatial resources for the circuit. Measurement-based quantum computation (MBQC) is a new paradigm for implementing quantum algorithms using a quantum cluster state [1]. All gates in the Clifford group, including CNOT, can be performed in one time step via a large number of concurrent measurements. Remarkably, because both wires and SWAP gates are in the Clifford group, MBQC supports long-distance gates in a single time step. The Toffoli Phase gate can be executed in two time steps, where the measurement basis for th...|$|E
40|$|<b>Ripple-carry</b> {{architectures}} are {{the norm}} in today’s reconfig-urable fabrics. They are simple, require minimal routing, and are easily formed across arbitrary cells in a fabric. How-ever, their computation delay grows linearly with operand width. Many different fabric carry-chains have been pre-sented in literature offering non-linear delays, but generally require a significant investment in routing and processing area. Carry-skip chains are well-known in arithmetic logic design, and although they too possess a linear delay, their performance is 2 x or more faster than simple <b>ripple-carry</b> schemes. They require an expanded carry chain and minimal extra logic, but offer impressive speed-ups for arithmetic. This paper presents a reconfigurable cell that supports carry-skip arithmetic using a multi-bit carry chain achieving 2 ·k ·b+ n b performance, where b is the block size and k is an architecture constant. The cell is specialized for arithmetic and Boolean operations with reduced configuration mem-ory. Additional resources are provided to reuse the multi-bit carry chain for 3 -source operand arithmetic to explore how multi-bit chains can be reused. 1...|$|E
40|$|Abstract — Binary {{addition}} is {{the most}} fundamental and frequently used operation. A well-designed adder should be fast and satisfy the application requirements. We propose an algorithmic approach to generate an irregular parallel-prefix adder, which has minimal delay for a given profile of input signals. It can cover different topologies such as <b>ripple-carry,</b> carry-skip and carry-select adders. Compared with Kogge-Stone and Brent-Kung adders, {{the results of the}} proposed approach have the smallest output delay. I...|$|E
40|$|This paper {{presents}} {{a novel approach}} for theoretical estimation of power consumption in digital binary adders. Closed-form expressions for power consumption of four different types of binary adders – the <b>ripple-carry</b> adder, the Manchester adder, a multiplexor-based carry-select adder and an efficient tree-based look-ahead adder – are derived in terms of word-length and pre-computed technologyspecific energy parameters. These expressions are verified to be accurate to within 1 - 5 % by simulation using the HEAT tool. 1...|$|E
40|$|Abstract—Given a 16 -bit or 32 -bit overclocked <b>ripple-carry</b> adder, we {{minimize}} error by allocating multiple supply voltages to the gates. We {{solve the}} error minimization {{problem for a}} fixed energy budget using a binned geometric program solution (BGPS). A solution found via BGPS outperforms the two best prior approaches, uniform voltage scaling and biased voltage scaling, reducing error {{by as much as}} a factor of 2. 58 X and by a median of 1. 58 X in 90 nm transistor technology...|$|E
40|$|Abstract — Full-custom {{design is}} {{considered}} superior to standard-cell design when a high-performance circuit is requested. The structured routing of critical wires {{is considered to}} be the most important contributor to this performance gap. However, this is only true for bitsliced designs, such as <b>ripple-carry</b> adders, but not for designs with inter-bitslice interconnections spanning several bitslices, such as tree adders and reduction-tree multipliers. It is found that standard-cell design techniques scale better with the data width than full-custom bitsliced layouts for designs dominated by inter-bitslice interconnections. I...|$|E
40|$|This paper {{presents}} {{a computer program}} for a fast adder's synthesis. From a given input operand size the program generates structural VHDL models of carry look ahead (CLA) or <b>ripple-carry</b> adders. In case of CLA adders the designer can select from several architectural variations of Brent-Kung adders. The synthesis target can be any standard cells library or a custom library with optimised "o" cells. The resulting VHDL code can be embedded in larger designs (e. g. signal processors) and used as input for logic synthesis tools...|$|E
40|$|WO 9321576; GR 920100163; EP 0591490 Method of {{self-checking}} arithmetic {{units and}} data paths using the double rail code for the arithmetic operators and a parity code {{for the other}} blocks. The method uses a single block for the generation of both codes, thus avoiding the need of code translators. The <b>ripple-carry</b> adders, ALU's, multiply and divide arrays are implemented with DCVS or static differential gates, to avoid overhead (Output Checking/Parity Generation Scheme). When the adders or ALU's are of a certain length, the schemes used are the Carry and Output Checking/Parity Generation and Carry Checking/Parity Prediction...|$|E
40|$|This paper {{presents}} a general method for designing delay insensitive datapath circuits. Its {{emphasis is on}} the formal derivation of a circuit from its specification. We discuss the properties required in a code that is used to transmit data asynchronously, and we introduce such a code. We introduce a general method (in the form of a theorem) for distributing the evaluation of a function over a number of concurrent cells. This method requires that the code be "distributive. " We apply the method to the familiar example of a <b>ripple-carry</b> adder, and we give a CMOS implementation of the adder...|$|E
40|$|In {{this paper}} design of fast {{arithmetic}} circuits using GaAs based Feed Through Logic (FTL) family [1] is presented. A {{modified version of}} FTL termed Differen-tial FTL (DFTL) is introduced and basic aspects of design methologies using FTL are discussed. A 4 -bit <b>ripple-carry</b> adder is designed and its performance is evaluated against other similar reported works in terms of, device count, chip area, delay, clock rate, and power consumption. It is shown how arithmetic circuits based on FTL outperform the eval-uated performance. A 4 -bit magnitude comparator is de-signed and performance evaluated against four cascaded 1 -bit comparators. 1...|$|E
40|$|Abstract. An {{evolutionary}} algorithm {{is used as}} an engine for discovering new designs of digital circuits, particularly arithmetic functions. These designs are often radically different from those produced by top-down, human, rule-based approaches. It is argued that by studying evolved designs of gradually increasing scale, one {{might be able to}} discern new, efficient, and generalizable principles of design. The <b>ripple-carry</b> adder principle is one such principle that can be inferred from evolved designs for one and two-bit adders. Novel evolved designs for three-bit binary multipliers are given that are 20 % more. efficient in terms of number of two-input gates used than the most efficient known conventional design...|$|E
40|$|International audienceInteger {{addition}} is {{a universal}} building block, and applications such as quad-precision floating-point or elliptic curve cryptography now demand precisions well beyond 64 bits. This study explores the trade-offs between size, latency and frequency for pipelined large-precision adders on FPGA. It compares three pipelined adder architectures: the classical pipelined <b>ripple-carry</b> adder, a variation that reduces register count, and an FPGA-specific implementation of the carry-select adder capable of providing lower latency additions at a comparable price. For each of these architectures, resource estimation models are defined, and used in an adder generator that selects the best architecture considering the target FPGA, the target operating frequency, and the addition bit width...|$|E
40|$|In {{this letter}} {{we present a}} timing and control {{strategy}} {{that can be used}} to realize synchronous systems with a level of performance that approaches that of asynchronous circuits or systems. This approach is based upon a single-phase synchronous circuit/system architecture with a variable period clock. The handshaking signals required for asynchronous self-timed circuits are not needed. Dynamic power supply current monitoring is used to generate the timing information, that is comparable to the completion signal found in self-timed circuits; this timing information is used to modi@ the circuit clock period. This letter is concluded with an example of the proposed approach applied to a static CMOS <b>ripple-carry</b> adder...|$|E
40|$|The CORDIC {{algorithms}} {{has proved}} to be a powerful and flexible generic architecture to implement many signal processing and image processing algorithms. In practice, however, it sometimes suffers from its comparatively excessive silicon area demands. We present hardware solutions with reduced chip area requirements and power dissipation for parallel array or pipeline implementations of the unified algorithm (providing all known CORDIC functions) as well as for specialised architectures, supporting a subset of CORDIC functions. The chip area savings lie between 20 % and 50 %, respectively. In addition, these architectures result in lower latencies, typically by 25 - 50 %, when compact non-redundant addition schemes like <b>ripple-carry</b> adders are employed...|$|E
40|$|We {{present an}} {{efficient}} addition circuit, borrowing techniques from the classical carry-lookahead arithmetic circuit. Our quantum carry-lookahead (QCLA) adder accepts two n-bit numbers and adds them in O(log n) depth using O(n) ancillary qubits. We present both in-place and out-of-place versions, {{as well as}} versions that add modulo 2 ^n and modulo 2 ^n - 1. Previously, the linear-depth <b>ripple-carry</b> addition circuit has been the method of choice. Our work reduces the cost of addition dramatically with only {{a slight increase in}} the number of required qubits. The QCLA adder can be used within current modular multiplication circuits to reduce substantially the run-time of Shor's algorithm. Comment: 21 pages, 4 color figure...|$|E
