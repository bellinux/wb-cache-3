7|23|Public
5000|$|... #Caption: A 24-byte {{keyboard}} circular buffer. When the {{write pointer}} {{is about to}} reach the <b>read</b> <b>pointer</b> - because the microprocessor is not responding, the buffer will stop recording keystrokes and - in some computers - a beep will be played.|$|E
50|$|Upon {{decoding}} D, L, c, again, D = LR. When {{the first}} LR characters are {{read to the}} output, this corresponds to a single run unit appended to the output buffer. At this point, the <b>read</b> <b>pointer</b> could {{be thought of as}} only needing to return int(L/LR) + (1 if L mod LR ≠ 0) times to the start of that single buffered run unit, read LR characters (or maybe fewer on the last return), and repeat until a total of L characters are read. But mirroring the encoding process, since the pattern is repetitive, the <b>read</b> <b>pointer</b> need only trail in sync with the write pointer by a fixed distance equal to the run length LR until L characters have been copied to output in total.|$|E
5000|$|... {{check for}} expired reads (look at head of FIFO ordered queue)check {{to see if}} cached <b>read</b> <b>pointer</b> valid (so even if not streaming, the cached pointer still takes {{precedence}} so the sorted queue is traversed tip to tail in a sweep)pick up the first read from the sorted queue (start at the tip again for another sweep)If there are expired reads, then {{the first one is}} pulled from the FIFO. Note that this expired read then is the new nexus for read sort ordering. The cached next pointer will be set to point to the next io from the sort queue after this expired one…. The thing to note is that the algorithm doesn’t just execute ALL expired io once they are past their expiration date. This allows some reasonable performance to be maintained by batching up ‘write_starved’ sorted reads together before checking the expired read queue again.|$|E
40|$|While {{traditional}} implementations {{of digital}} delay lines {{are based on}} a circular buffer accessed by two pointers, we propose an implementation where a single fractional pointer is used both for reading and writing operations. On modern general-purpose architectures, the proposed method is nearly as efficient as the popular interpolated circular buffer, but it offers better performance in terms of frequency-dependent attenuation and response to delay-length modulations. 1 Prior Art The classic implementation of the digital delay line uses a circular buffer, which is accessed by a writing pointer followed by a <b>reading</b> <b>pointer</b> [5]. When the delay length has to be made variable, the relative distance between the <b>reading</b> <b>pointer</b> and the writing pointer is varied sample by sample. In order to allow for fractional lengths and click-free length modulation, some form of interpolation has to be applied at the reading point [10, 3, 9]. The following properties should be ensured by the inter [...] ...|$|R
50|$|There are {{summaries}} of this research; see the links in this section. Many textbooks on <b>reading</b> include <b>pointers</b> to readability.|$|R
5000|$|Up to 64 words {{relative}} to the constant <b>pointer</b> (<b>read</b> only, word access only) ...|$|R
40|$|Clock {{compensation}} for Gigabit Ethernet is necessary because the clock {{recovered from the}} 1. 25 Gb/s serial data stream {{has the potential to}} be 200 ppm slower or faster than the system clock. The serial data is converted to 10 -bit parallel data at a 125 MHz rate on a clock recovered from the serial data stream. This recovered data needs to be processed by a system clock that is also running at a nominal rate of 125 MHz, but not synchronous to the recovered clock. To cross clock domains, an asynchronous FIFO (first-in-first-out) is used, with the write pointer (wprt) in the recovered clock domain and the <b>read</b> <b>pointer</b> (rptr) in the system clock domain. Because the clocks are generated from separate sources, there is potential for FIFO overflow or underflow. Clock compensation in Gigabit Ethernet is possible by taking advantage of the protocol data stream features. There are two distinct data streams that occur in Gigabit Ethernet where identical data is transmitted for a period of time. The first is configuration, which happens during auto-negotiation. The second is idle, which occurs at the end of auto-negotiation and between every packet. The identical data in the FIFO can be repeated by decrementing the <b>read</b> <b>pointer,</b> thus compensating for a FIFO that is draining too fast. The identical data in the FIFO can also be skipped by incrementing the <b>read</b> <b>pointer,</b> which compensates for a FIFO draining too slowly. The unique and novel features of this FIFO are that it works in both the idle stream and the configuration streams. The increment or decrement of the <b>read</b> <b>pointer</b> is different in the idle and compensation streams to preserve disparity. Another unique feature is that the <b>read</b> <b>pointer</b> to write pointer difference range changes between compensation and idle to minimize FIFO latency during packet transmission...|$|E
30|$|Firstly, {{for each}} window W_i in the partition, we {{initialize}} {{the parameters of}} W_i and place the <b>read</b> <b>pointer</b> {{at the start of}} the window (Line 3). Then determine whether the start position of the current window is equal to that of the previous one. If the condition is true, we can reuse the previous result and assign it to W_i.V (Line 5). Nextly, we place the <b>read</b> <b>pointer</b> at the end of the previous window and traverse all tuples from W_i- 1.t to W_i.t. If it is false, we just traverse all tuples from W_i.h to W_i.t. Finally, return the result and prepare for the next window.|$|E
40|$|Abstract- A novel VLSI {{implementation}} of the Viterbi algorithm based on a cascade architecture is pre-sented. Survivor sequence memory management is imple-mented using a new single <b>read</b> <b>pointer</b> traceback tech-nique. The overall design for a 16 -qtate, rate 1 / 2 decoder requires about 26000 transistors and a core area of 8. 5 mma in a 1. 2 pm two-level metal CMOS technology. ...|$|E
40|$|Recently {{proposed}} idea of "protective" {{measurement of}} a quantum state is critically examined, and generalized. Earlier {{criticisms of the}} idea are discussed and their relevance to the proposal assessed. Several constraints on measuring apparatus required by "protective" measurements are discussed, with emphasis on how they may restrict their experimental feasibility. Though "protective" measurements result in an unchanged system state and a shift of the pointer proportional to the expectation value of the measured observable in the system state, the actual <b>reading</b> of the <b>pointer</b> position gives rise to several subtleties. We propose several schemes for <b>reading</b> <b>pointer</b> position, both when the apparatus is treated as a classical system as well as when its quantum aspects are taken into account, that address these issues. The tiny entanglement which is always present due to deviation from extreme adiabaticity in realistic situations is argued to be the weakest aspect of the proposal. Because of this, one can never perform a protective measurement on a single quantum system with absolute certainty. This clearly precludes an ontological status for the wave function. Several other conceptual issues are also discussed. Comment: 14 pages RevTex, published version with change in titl...|$|R
40|$|Abstract —StarSync, a {{mesochronous}} synchronizer, enables {{low latency}} and full throughput crossing of clock domain boundaries having same frequency but different phases. Full back pressure is supported, where the receiver can {{start and stop}} accepting words without any data loss. Variable depth buffering is provided, supporting {{a wide range of}} short and long range communications and accommodating multi-cycle wire delays. Burst data can also be accommodated thanks to buffering. Dynamic phase shifting due to varying voltage and temperature are mitigated by increasing the separation between write and <b>read</b> <b>pointers.</b> The synchronizer is exposed to metastability risk only during reset. It is suitable for implementation using standard cell design and requires neither delay lines nor other full custom circuits. It is shown that a minimum of four buffer stages are required, to mitigate skew in reset synchronization, in contrast with previous proposals for three stages. Keywords—Synchronization, mesochronous, multi-synchronous, buffering, back-pressure 1...|$|R
40|$|A four-stage {{mesochronous}} synchronizer is described. It enables {{low latency}} and full throughput crossing of boundaries of same frequency, different phase clock domains. Full back pressure is supported, where the receiver can {{start and stop}} accepting words without any data loss. Variable depth buffering is provided, supporting {{a wide range of}} short and long range communications and accommodating multi-cycle wire delays. Burst data can also be accommodated thanks to buffering. Dynamic phase shifting due to varying voltage and temperature are mitigated by increasing the separation between write and <b>read</b> <b>pointers.</b> Unlike common synchronizers, this circuit is exposed to metastability risk only during reset. The synchronizer provides lower latency and higher reliability than typical two-clock FIFO and other asynchronous and mesochronous synchronizers. It is suitable for implementation using standard cell design and does not require any delay lines, tuning of clock trees and other full custom circuits. It is shown that a minimum of four buffer stages are required, in contrast with previous proposals for three stages. 1...|$|R
40|$|Abstract：A novel high {{throughput}} globally asynchronous locally synchronous wrapper {{is proposed}} to improve the network interface performance of network on chip. To prevent the occurrence of data sampling error, both the sender and receiver wrapper use the pausable clocking scheme to stop the clock when data come. The VC is based on Muller pipeline and chosen by the VC selector in the circuit. This wrapper can avoid the comparison between <b>read</b> <b>pointer</b> and write pointer in conventional design scheme and can increase the throughput. Simulations were based on SMIC 0. 18 um CMOS technology, and the sender wrapper and receiver wrapper have the throughput as high as 810 Mflit/s and 820 Mflit/s respectively...|$|E
40|$|The reader learns {{from this}} book’s {{introduction}} (written by Ali Farghaly) that {{the objective of}} the book is to “equip linguists embarking on NLP assignments. ” The introduction also explains why language engineers are needed and summarizes the contents of each chapter. “Domain Analysis and Representation ” by Farghaly and Bruce Hedin offers a good discussion of the importance of domain analysis in natural language processing (NLP). It provides a helpful background on the notion of sublanguages and correctly notes that distinctions between the different domains can be blurred, as domains often overlap. The chapter would have been more convincing if there were further examples of NLP applications that benefit from narrowing down the domain of their operation. The chapter also discusses the analysis of domain into topics. Section 2. 4. 4 covers statistical approaches to classification, but no references or further <b>reading</b> <b>pointers</b> are given. “The Language of the Internet ” by Naomi Baron gives an easy-to-read and useful chronological overview of the developments on the Internet. It provides informatio...|$|R
40|$|An {{interesting}} {{technique for}} doing FIFO design is to perform asynchronous {{comparisons between the}} FIFO write and <b>read</b> <b>pointers</b> that are generated in clock domains that are asynchronous to each other. The asynchronous FIFO pointer comparison technique uses fewer synchronization flip-flops to build the FIFO. The asynchronous FIFO comparison method requires additional techniques to correctly synthesize and analyze the design, which are detailed in this paper. To increase {{the speed of the}} FIFO, this design uses combined binary/Gray counters that take advantage of the built-in binary ripple carry logic. The fully coded, synthesized and analyzed RTL Verilog model (FIFO Style # 2) is included. This FIFO design paper builds on information already presented in another FIFO design paper where the FIFO pointers are synchronized into the opposite clock domain before running "FIFO full " or "FIFO empty " tests. The reader may benefit from first reviewing the FIFO Style # 1 method before proceeding to this FIFO Style # 2 method. Post-SNUG Editorial Comment (by Cliff Cummings) Although this paper was voted “Best Paper- 1 st Place ” by SNUG attendees, this paper builds off of a second FIF...|$|R
30|$|A {{hash table}} bucket usually holds a single entry or a {{reference}} to a collection of entries. If more than one entry is placed in a bucket, lookup might require multiple memory <b>reads</b> by following <b>pointers.</b> This leads to more sophisticated hash table constructions that try to limit the bucket load to one with high probability.|$|R
30|$|In {{the second}} scenario, we write an LLVM pass to {{automatically}} identify and instrument all function pointer accesses in Nginx. On serving each HTTP request, Nginx performs 104 function <b>pointer</b> <b>read</b> operations and 17 function pointer write operations on average. In the baseline, serving each request takes 31 microseconds on average. The throughput drops 1.1 to 2.7 % when a primitive’s latency varies from 12 to 36 cycles, and 7.9 % for emulated PTWRITE.|$|R
50|$|FIFOs are {{commonly}} used in electronic circuits for buffering and flow control between hardware and software. In its hardware form, a FIFO primarily consists {{of a set of}} <b>read</b> and write <b>pointers,</b> storage and control logic. Storage may be static random access memory (SRAM), flip-flops, latches or any other suitable form of storage. For FIFOs of non-trivial size, a dual-port SRAM is usually used, where one port is dedicated to writing and the other to reading.|$|R
50|$|Pointer was {{the last}} person in Colorado to be {{admitted}} to the bar under the practice of clerkship. Clerkship was a system in which, a person would read the law, rather than attended law school, in preparation for admittance to the bar. <b>Pointer</b> <b>read</b> the law for seven years and passed her examination in 1926, making her Colorado's first female water lawyer. Following her admitance to the bar, Pointer worked with her law partner Fred Sabin in Pueblo, Colorado till his death in 1931.|$|R
5000|$|The M1890M1 mortar {{was most}} often {{installed}} on an M1896 carriage (as shown {{here in the}} images at top left and right). The mortar and its carriage weighed a total of 78.5 tons. The carriage was geared to enable it to be turned (in azimuth) {{by means of a}} traversing crank with two handles, located {{on the right side of}} the piece. A ring marked in degrees of azimuth ran around the mortar, just outside the inner steel circle or [...] "racer" [...] that carried the carriage, and a soldier <b>read</b> a <b>pointer</b> on the racer to aim the mortar in direction. The tube was raised or lowered (in elevation) by twin geared wheels with long spokes (resembling ship's wheels) that were located on either side of the carriage. The breech could be rapidly depressed to an almost level position for loading and then be quickly elevated for firing. Other carriages included the M1891 and M1908.|$|R
50|$|A {{synchronous}} FIFO is a FIFO {{where the}} same clock {{is used for}} both reading and writing. An asynchronous FIFO uses different clocks for reading and writing. Asynchronous FIFOs introduce metastability issues.A common implementation of an asynchronous FIFO uses a Gray code (or any unit distance code) for the <b>read</b> and write <b>pointers</b> to ensure reliable flag generation. One further note concerning flag generation is that one must necessarily use pointer arithmetic to generate flags for asynchronous FIFO implementations. Conversely, one may use either a leaky bucket approach or pointer arithmetic to generate flags in synchronous FIFO implementations.|$|R
40|$|We {{propose a}} formal {{definition}} for (valid) speculative computa-tions, which {{is independent of}} any implementation technique. By speculative computations we mean optimization mechanisms that rely on relaxing the flow of execution in a given program, and on guessing the values <b>read</b> from <b>pointers</b> in the memory. Our frame-work for formalizing these computations is the standard operational one {{that is used to}} describe the semantics of programming lan-guages. In particular, we introduce speculation contexts, that gen-eralize classical evaluation contexts, and allow us to deal with out of order (or parallel) computations. We show that the standard DRF guarantee, asserting that data race free programs are correctly im-plemented in a relaxed semantics, fails with speculative computa-tions, but that a similar guarantee holds for programs that are free of data races in the speculative semantics. We then introduce a lan-guage featuring an explicit distinction between shared and private variables, and show that there is a translation, guided by a type and effect system, that transforms a program written in this language into speculatively data race free code, which is therefore robust against aggressive optimizations. 1...|$|R
40|$|Abstract: In {{the recent}} years the {{development}} in communication systems requires the data transmission to be performed faster and faster. To meet this demand the paper presents a high speed multi channel UART controller based on FIFO (First In First Out) technique. An Asynchronous FIFO is designed with dual port ram array and with <b>read</b> and right <b>pointers.</b> The structure of controller is designed with UART (Universal Asynchronous Receiver Transmitter) and FIFO circuit design, {{the structure of the}} controller is scalable and reconfigurable design. This controller reduces the synchronization error between the sub systems in a system with other sub systems. Mainly the controller is used to operate or implement the communication system when master equipment and slave equipment are set at different baud rate...|$|R
5000|$|Like buffer-overflow bugs, dangling/wild pointer bugs {{frequently}} become security holes. For example, if {{the pointer}} {{is used to}} make a virtual function call, a different address (possibly pointing at exploit code) may be called due to the vtable pointer being overwritten. Alternatively, if the pointer is used for writing to memory, some other data structure may be corrupted. Even if the memory is only <b>read</b> once the <b>pointer</b> becomes dangling, it can lead to information leaks (if interesting data is put in the next structure allocated there) or to privilege escalation (if the now-invalid memory is used in security checks). When a dangling pointer is used after it has been freed without allocating a new chunk of memory to it, this becomes known as a [...] "use after free" [...] vulnerability. For example, CVE-2014-1776 is a use-after-free vulnerability in Microsoft Internet Explorer 6 through 11 being used by zero-day attacks by an advanced persistent threat.|$|R
40|$|Memory bugs in C/C++ {{programs}} severely affect {{system availability}} and security. This paper presents First-Aid, a lightweight runtime system that survives software failures caused by common memory management bugs and prevents future failures {{by the same}} bugs during production runs. Upon a failure, First-Aid diagnoses the bug type and identifies the memory objects that trigger the bug. To do so, it rolls back the program to previous checkpoints and uses two types of environmental changes that can prevent or expose memory bug manifestation during re-execution. Based on the diagnosis, First-Aid generates and applies runtime patches to avoid the memory bug and prevent its reoccurrence. Furthermore, First-Aid validates the consistent effects of the runtime patches and generates on-site diagnostic reports to assist developers in fixing the bugs. We have implemented First-Aid on Linux and evaluated it with seven applications that contain various types of memory bugs, including buffer overflow, uninitialized <b>read,</b> dangling <b>pointer</b> read/write, and double free. The results show that First-Aid can quickly diagnose the tested bugs and recover applications from failures (in 0. 084 to 3. 978 seconds). The results also show that the runtime patches generated by First-Aid can prevent future failures caused by the diagnosed bugs. Additionally, First-Aid provides detailed diagnostic information on both the root cause and the manifestation of the bugs. Furthermore, First-Aid incurs low overhead (0. 4 - 11. 6 % {{with an average of}} 3. 7 %) during normal execution for the tested buggy applications, SPEC INT 2000, and four allocation intensive programs...|$|R
5000|$|A typical use of Gray code {{counters}} {{is building}} a FIFO (first-in, first-out) data buffer that has read and write ports that exist in different clock domains. The input and output counters inside such a dual-port FIFO are often stored using Gray code to prevent invalid transient states from being captured when the count crosses clock domains.The updated <b>read</b> and write <b>pointers</b> need to be passed between clock domains when they change, {{to be able to}} track FIFO empty and full status in each domain. Each bit of the pointers is sampled non-deterministically for this clock domain transfer. So for each bit, either the old value or the new value is propagated. Therefore, if more than one bit in the multi-bit pointer is changing at the sampling point, a [...] "wrong" [...] binary value (neither new nor old) can be propagated. By guaranteeing only one bit can be changing, Gray codes guarantee that the only possible sampled values are the new or old multi-bit value. Typically Gray codes of power-of-two length are used.|$|R
40|$|Today {{managing}} {{files in}} a server system {{has the same}} magnitude as managing the World Wide Web due to the dynamic nature of the file system. Even searching for files over the file system is time consuming because finding a file on hard disk is a long-running task. Every file on the disk has to be <b>read</b> with dangling <b>pointers</b> to files which no longer exist {{because they have been}} changed, moved or deleted. This makes the user frustrated. The Automatic file indexing framework facilitates users to resolve file names and locate documents stored in file repositories. The main design objective of the framework is to maintain sub-indexes at the folder level that have the full knowledge of the revisions that are made at the folder level automatically. This research proposes a framework that manages the creation and maintenance of the file index, with the use of Resources Description Framework (RDF) and retrieval using semantic query languages i. e. SPARQL. The sub-indexes are maintained hierarchically starting from the leaf node to the root node recursively. The proposed framework will monitor the file system continuously and update individual folder descriptors (sub-indexes) stored on each node as the file system changes making the cached indexes resilient to any file changes. The framework is resilient of file or folder name changes. Further, the study explores avenues to build an offline semantic index that can be used by the clients to perform distribute file search without performing the search on the server itself. This is viable since the framework uses semantic languages to describe and build file descriptors that can easily integrate semantic indexing and hence this makes the index readily available for the Web...|$|R
40|$|Abstract—Use of FIFOs {{in digital}} designs for {{buffering}} and flow control has been widespread since many years. As feature sizes continue their south-bound journey, {{more and more}} complex circuitry has found its way onto the chip. The emergence of system on chip (SOC) and networks on chip (NOC) for internal connections have made it imperative to ensure correct flow of data across the chip {{especially in light of}} the performance shortcomings of global interconnects. One of the design challenges that arises is to ensure safety and fidelity for this data transfer. FIFO cells are a good way to accomplish this task. The FIFOs now require to serve two masters (clocks) instead of one. Such FIFOs are called Asynchronous FIFOs. There are many clever architectures and implementations of FIFOs as enlisted in the references. These aim to maximize benefits in latency or throughput or both. This work aims at comparing two pointer synchronization techniques in FIFOs. to generate the FULL and EMPTY status flags. An EMPTY flag is generated by the comparison of the <b>read</b> and write <b>pointers</b> and results in the number of memory locations between them being zero. If the number of memory locations between them is the maximum FIFO depth, the FULL flag is asserted. It is clear that an EMPTY FIFO cannot be read from and a FULL FIFO cannot be written into. Efficient generation and comparison of these status flags depends on the correct design of the FIFO and is the topic of this study. Sections II and III provide information about the two synchronization and comparison techniques used in this project. Section IV details the implementation of the FIFOs. Section V reports a few results. Conclusion and future work is outlined in Section VI...|$|R

