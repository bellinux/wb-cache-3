781|1560|Public
25|$|A notable {{restriction}} of this let {{is that the}} name f is not defined in M, since M is {{outside the scope of}} the lambda-abstraction binding f; this means a <b>recursive</b> <b>function</b> definition cannot be used as the M with let. The more advanced letrec syntactic sugar construction that allows writing <b>recursive</b> <b>function</b> definitions in that naive style instead additionally employs fixed-point combinators.|$|E
25|$|Then {{because the}} {{construction}} of f was uniform, this is a <b>recursive</b> <b>function</b> of two variables.|$|E
25|$|The {{function}} that takes m to Ackermann(m,m) is a unary total <b>recursive</b> <b>function</b> {{that is not}} primitive recursive.|$|E
5000|$|... {{limiting}} <b>recursive</b> <b>functions</b> {{and limiting}} partial <b>recursive</b> <b>functions</b> (E.M. Gold) ...|$|R
50|$|The {{smallest}} {{class of}} functions including the initial functions and closed under composition and primitive recursion (i.e. without minimisation) is {{the class of}} primitive <b>recursive</b> <b>functions.</b> While all primitive <b>recursive</b> <b>functions</b> are total, {{this is not true}} of partial recursive functions; for example, the minimisation of the successor function is undefined. The primitive <b>recursive</b> <b>functions</b> are a subset of the total <b>recursive</b> <b>functions,</b> which are a subset of the partial <b>recursive</b> <b>functions.</b> For example, the Ackermann function can be proven to be total recursive, but not primitive.|$|R
50|$|Whereas {{elementary}} <b>recursive</b> <b>functions</b> have {{potentially more}} than exponential growth, the lower elementary <b>recursive</b> <b>functions</b> have polynomial growth.|$|R
25|$|His son, another Andrei Andreevich Markov (1903–1979), {{was also}} a notable mathematician, making {{contributions}} to constructive mathematics and <b>recursive</b> <b>function</b> theory.|$|E
25|$|In the {{equivalence}} {{of models}} of computability, a parallel is drawn between Turing machines {{that do not}} terminate for certain inputs and an undefined result for that input in the corresponding partial <b>recursive</b> <b>function.</b>|$|E
25|$|By using a Gödel {{numbering}} for sequences, {{for example}} Gödel's β function, any {{sequence of numbers}} can be encoded by a single number. Such a number can therefore represent the primitive <b>recursive</b> <b>function</b> until a given n.|$|E
2500|$|An {{important}} {{property of}} the primitive <b>recursive</b> <b>functions</b> {{is that they are}} a recursively enumerable subset of the set of all total <b>recursive</b> <b>functions</b> (which is not itself recursively enumerable). This means that there is a single computable function f(m,n) that enumerated the primitive <b>recursive</b> <b>functions,</b> namely: ...|$|R
40|$|AbstractThe paper {{presents}} a synthetic view of transformations that invert {{the order of}} evaluation of <b>recursive</b> <b>functions.</b> Techniques for linear <b>recursive</b> <b>functions</b> are presented. A consideration of stacks motivates {{the introduction of a}} general control structure for tabulation. Several transformations for tree-like <b>recursive</b> <b>functions</b> are given...|$|R
5000|$|An {{important}} {{property of}} the primitive <b>recursive</b> <b>functions</b> {{is that they are}} a recursively enumerable subset of the set of all total <b>recursive</b> <b>functions</b> (which is not itself recursively enumerable). This means that there is a single computable function f(m,n) that enumerated the primitive <b>recursive</b> <b>functions,</b> namely: ...|$|R
25|$|Green recursively {{constructs}} {{machines for}} any number of states and provides the <b>recursive</b> <b>function</b> that computes their score (computes σ), thus providing a lower bound for Σ. This function's growth is comparable to that of Ackermann's function.|$|E
25|$|Divide-and-conquer {{algorithms}} {{are naturally}} implemented as recursive procedures. In that case, the partial sub-problems {{leading to the}} one currently being solved are automatically stored in the procedure call stack. A <b>recursive</b> <b>function</b> is a function that calls itself within its definition.|$|E
25|$|A single-argument version f(n) = A(n, n) that {{increases}} both m and n {{at the same}} time dwarfs every primitive <b>recursive</b> <b>function,</b> including very fast-growing functions such as the exponential function, the factorial function, multi- and superfactorial functions, and even functions defined using Knuth's up-arrow notation (except when the indexed up-arrow is used). It can be seen that f(n) is roughly comparable to fω(n) in the fast-growing hierarchy. This extreme growth can be exploited to show that f, which is obviously computable on a machine with infinite memory such as a Turing machine and so is a computable function, grows faster than any primitive <b>recursive</b> <b>function</b> and is therefore not primitive recursive.|$|E
2500|$|... {{more natural}} for reading or writing. Course-of-values {{recursion}} defines primitive <b>recursive</b> <b>functions.</b> Some forms of mutual recursion also define primitive <b>recursive</b> <b>functions.</b>|$|R
50|$|In first-order arithmetic, {{the only}} {{primitive}} <b>recursive</b> <b>functions</b> {{that need to}} be explicitly axiomatized are addition and multiplication. All other primitive recursive predicates can be defined using these two primitive <b>recursive</b> <b>functions</b> and quantification over all natural numbers. Defining primitive <b>recursive</b> <b>functions</b> in this manner is not possible in PRA, because it lacks quantifiers.|$|R
40|$|Abstract. In this article, we {{will study}} certain {{reductions}} in the schemes that conform unary primitive <b>recursive</b> <b>functions</b> (i. e. primitive <b>recursive</b> <b>functions</b> of one argument) and we will extend some results previously researched by R. M. Robinson in [15]. Furthermore, we will introduce formal notation for unary primitive <b>recursive</b> <b>functions.</b> § 1. Introduction. The set of primitive <b>recursive</b> <b>functions</b> is the closure under composition and primitive recursion of zero, successor and projection functions. For a detailed definition, the reader is referred to any standard work, for instance chapter 1 of [8]. A suitable subset is the set of unary primitive <b>recursive</b> <b>functions</b> (we will denote it as F) {{that will be the}} object of our research...|$|R
25|$|The {{converse}} is not true, as {{not every}} provably total function is primitive recursive. Indeed, one can enumerate all the primitive recursive functions and define a function en such {{that for all}} n, m: en(n,m) = f'n(m), where f'n is the n-th primitive <b>recursive</b> <b>function</b> (for k-ary functions, this will be set to f'n(m,m...m)). Now, g(n) = en(n,n)+1 is provably total but not primitive recursive, by a diagonalization argument: had there been a j such that g = f'j, we would have got g(j) = en(j,j)+1 = f'j (j)+1= g(j)+1, a contradiction. (It {{should be noted that}} the Gödel numbers of all primitive recursive functions can be enumerated by a primitive <b>recursive</b> <b>function,</b> though the primitive recursive functions' values cannot).|$|E
25|$|Example. Suppose f(x) = P11(x) = x and g(x,y,z)= S(P23(x,y,z)) = S(y). Then h(0,x) = x and h(S(y),x) = g(y,h(y,x),x) = S(h(y,x)). Now h(0,1) = 1, h(1,1) = S(h(0,1)) = 2, h(2,1) = S(h(1,1)) = 3. This h is a 2-ary {{primitive}} <b>recursive</b> <b>function.</b> We {{can call}} it 'addition'.|$|E
25|$|Example. We take f(x) as the S(x) defined above. This f is a 1-ary {{primitive}} <b>recursive</b> <b>function.</b> And so is g(x) = S(x). So h(x) {{defined as}} f(g(x)) = S(S(x)) is a primitive recursive 1-ary function too. Informally speaking, h(x) is the function that turns x into x+2.|$|E
50|$|Simple {{inductive}} Turing {{machines are}} equivalent to other models of computation. More advanced inductive Turing machines {{are much more}} powerful. It is proved (Burgin, 2005) that limiting partial <b>recursive</b> <b>functions,</b> trial and error predicates, general Turing machines, and simple inductive Turing machines are equivalent models of computation. However, simple inductive Turing machines and general Turing machines give direct constructions of computing automata, which are thoroughly grounded in physical machines. In contrast, trial and error predicates, limiting <b>recursive</b> <b>functions</b> and limiting partial <b>recursive</b> <b>functions</b> present syntactic systems of symbols with formal rules for their manipulation. Simple inductive Turing machines and general Turing machines are related to limiting partial <b>recursive</b> <b>functions</b> and trial and error predicates as Turing machines are related to partial <b>recursive</b> <b>functions</b> and lambda-calculus.|$|R
5000|$|In mathematics, {{primitive}} <b>recursive</b> set <b>functions</b> or primitive <b>recursive</b> ordinal <b>functions</b> are analogs {{of primitive}} <b>recursive</b> <b>functions,</b> defined for sets or ordinals rather than natural numbers. They were introduced by [...]|$|R
5000|$|It {{can also}} be shown that all {{primitive}} <b>recursive</b> <b>functions</b> are in some level of the hierarchy (Rose 1984; Gakwaya 1997), thusand the sets [...] partition the set of primitive <b>recursive</b> <b>functions,</b> [...]|$|R
25|$|These {{examples}} reduce {{easily to}} a single <b>recursive</b> <b>function</b> by inlining the forest function in the tree function, which is commonly done in practice: directly recursive functions that operate on trees sequentially process {{the value of the}} node and recurse on the children within one function, rather than dividing these into two separate functions.|$|E
25|$|Most of the {{functions}} normally studied in number theory are primitive recursive. For example, addition and division, the factorial and exponential function, and the function which returns the nth prime are all primitive recursive. So are many approximations to real-valued functions. In fact, {{it is difficult to}} devise a total <b>recursive</b> <b>function</b> that is not primitive recursive, although some are known (see the section on Limitations below).|$|E
25|$|Given a lambda {{term with}} first {{argument}} representing recursive call (e.g. G here), the fixed-point combinator FIX will return a self-replicating lambda expression representing the <b>recursive</b> <b>function</b> (here, F). The function {{does not need}} to be explicitly passed to itself at any point, for the self-replication is arranged in advance, when it is created, to be done each time it is called. Thus the original lambda expression (FIX G) is re-created inside itself, at call-point, achieving self-reference.|$|E
50|$|Here A, B, and C are any terms ({{primitive}} <b>recursive</b> <b>functions</b> of zero or more variables). Finally, {{there are}} symbols for any primitive <b>recursive</b> <b>functions</b> with corresponding defining equations, as in Skolem's system above.|$|R
40|$|It {{is common}} {{practice}} {{to compare the}} computational power of different models of computation. For example, the <b>recursive</b> <b>functions</b> are strictly {{more powerful than the}} primitive <b>recursive</b> <b>functions,</b> because the latter are a proper subset of the former (which includes Ackermann's function). Side-by-side with this "containment" method of measuring power, it is standard to use an approach based on "simulation". For example, one says that the (untyped) lambda calculus is as powerful [...] computationally speaking [...] as the partial <b>recursive</b> <b>functions,</b> because the lambda calculus can simulate all partial <b>recursive</b> <b>functions</b> by encoding the natural numbers as Church numerals. The problem is that unbridled use of these two ways of comparing power allows one to show that some computational models are strictly stronger than themselves! We argue that a better definition is that model A is strictly stronger than B if A can simulate B via some encoding, whereas B cannot simulate A under any encoding. We then show that the <b>recursive</b> <b>functions</b> are strictly stronger in this sense than the primitive recursive. We also prove that the <b>recursive</b> <b>functions,</b> partial <b>recursive</b> <b>functions,</b> and Turing machines are "complete", in the sense that no injective encoding can make them equivalent to any "hypercomputational" model. Comment: To appear in Logic Journal of the IGPL in 200...|$|R
25|$|For {{the most}} part the papers contain {{mathematics}} beyond the undergraduate level—in particular the primitive <b>recursive</b> <b>functions</b> and mu <b>recursive</b> <b>functions</b> presented elegantly in Kleene (1952) and less in depth, but useful nonetheless, in Boolos-Burgess-Jeffrey (2002).|$|R
25|$|First, {{there are}} several cases where the NKS book {{introduces}} what was, during the book's composition, the simplest known system in some class that has a particular characteristic. Some examples include the first primitive <b>recursive</b> <b>function</b> that results in complexity, the smallest universal Turing Machine, and the shortest axiom for propositional calculus. In a similar vein, Wolfram also demonstrates many simple programs that exhibit phenomena like phase transitions, conserved quantities, continuum behavior, and thermodynamics that are familiar from traditional science. Simple computational models of natural systems like shell growth, fluid turbulence, and phyllotaxis are a final category of applications that fall in this theme.|$|E
25|$|The {{development}} and continual improvement of computers, at first mechanical analog machines and then digital electronic machines, allowed industry {{to deal with}} larger and larger amounts of data to facilitate mass production and distribution and communication, and new areas of mathematics were developed to deal with this: Alan Turing's computability theory; complexity theory; Derrick Henry Lehmer's use of ENIAC to further number theory and the Lucas-Lehmer test; Rózsa Péter's <b>recursive</b> <b>function</b> theory; Claude Shannon's information theory; signal processing; data analysis; optimization and other areas of operations research. In the preceding centuries much mathematical focus was on calculus and continuous functions, but the rise of computing and communication networks led to an increasing importance of discrete concepts {{and the expansion of}} combinatorics including graph theory. The speed and data processing abilities of computers also enabled the handling of mathematical problems that were too time-consuming to deal with by pencil and paper calculations, leading to areas such as numerical analysis and symbolic computation. Some of the most important methods and algorithms of the 20th century are: the simplex algorithm, the Fast Fourier Transform, error-correcting codes, the Kalman filter from control theory and the RSA algorithm of public-key cryptography.|$|E
2500|$|... (iii) In {{the context}} of the partial {{recursive}} functions: Suppose that the relation R holds if and only if a partial <b>recursive</b> <b>function</b> converges to zero. And suppose that that partial <b>recursive</b> <b>function</b> converges (to something, not necessarily zero) whenever [...] is defined and y is [...] or smaller. Then the function [...] is also a partial <b>recursive</b> <b>function.</b>|$|E
50|$|In {{the field}} of {{recursion}} theory, index sets describe classes of partial <b>recursive</b> <b>functions,</b> specifically they give all indices of functions in that class according to a fixed enumeration of partial <b>recursive</b> <b>functions</b> (a Gödel numbering).|$|R
50|$|In {{order to}} prove these results, Gödel {{introduced}} {{in this paper}} a method now known as Gödel numbering. In this method, each sentence and formal proof in first-order arithmetic is assigned a particular natural number. Gödel shows that many properties of these proofs can be defined within any theory of arithmetic that {{is strong enough to}} define the primitive <b>recursive</b> <b>functions.</b> (The contemporary terminology for <b>recursive</b> <b>functions</b> and primitive <b>recursive</b> <b>functions</b> had not yet been established when the paper was published; Gödel used the word rekursiv ("recursive") for what are now known as primitive <b>recursive</b> <b>functions.)</b> The method of Gödel numbering has since become common in mathematical logic.|$|R
40|$|AbstractRegarding {{effectivity}} {{of functions}} on the reals, {{there have been}} several proposed models of analog, continuous-time computation, as opposed to the digital, discrete nature of the type- 2 computability. We study one of them, Moore's real (primitive) <b>recursive</b> <b>functions,</b> whose definition mimics the classical characterization of <b>recursive</b> <b>functions</b> on N by the closure properties. We show that the class of type- 2 computable real functions falls between Moore's classes of primitive <b>recursive</b> and <b>recursive</b> <b>functions...</b>|$|R
