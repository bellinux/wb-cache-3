414|572|Public
25|$|The Soviet {{systems in}} general used a code to convert words and letters into numbers, to which {{additive}} keys (from one-time pads) were added, encrypting the content. When used correctly {{so that the}} plain text is of equal or lesser length to a <b>random</b> <b>key,</b> one-time pad encryption is unbreakable. However, cryptanalysis by American and British code-breakers revealed {{that some of the}} one-time pad material had incorrectly been reused by the Soviets (specifically, entire pages, although not complete books), which allowed decryption (sometimes only partial) of {{a small part of the}} traffic.|$|E
25|$|Quantum key {{distribution}} is only {{used to produce}} and distribute a key, not to transmit any message data. This key can then be used with any chosen encryption algorithm to encrypt (and decrypt) a message, which can then be transmitted over a standard communication channel. The algorithm most commonly associated with QKD is the one-time pad, as it is provably secure when used with a secret, <b>random</b> <b>key.</b> In real-world situations, it is often also used with encryption using symmetric key algorithms like the Advanced Encryption Standard algorithm.|$|E
25|$|This {{is one of}} {{the major}} {{concepts}} behind the Vanish computer project at the University of Washington, where a <b>random</b> <b>key</b> is used to encrypt data, and the key is distributed as a secret across several nodes in a P2P network. In order to decrypt the message, at least t nodes on the network must be accessible; the principle for this particular project being that the number of secret-sharing nodes on the network will decrease naturally over time, therefore causing the secret to eventually vanish. However, the network is vulnerable to a Sybil attack, thus making Vanish insecure.|$|E
30|$|Allkeys-random: evict <b>random</b> <b>keys</b> to make {{space for}} the new data added.|$|R
3000|$|On each {{simulation}} we perform ten trials, {{that is we}} instantiate the EHT {{and fill}} it with n <b>random</b> <b>keys</b> and values. No updates are performed but the EHT is queried for all n and additional 2 n <b>random</b> <b>keys</b> to verify that every key can be retrieved and to analyze the false-positive probability. As summary we use HC-CBF. The compression rate γ [...]...|$|R
30|$|To {{improve the}} {{resilience}} of the <b>random</b> <b>keys</b> scheme in against node capture attacks, <b>random</b> pairwise <b>keys</b> schemes have been proposed [3, 4], in which a key is shared by two sensors only. These schemes have good resilience against node capture attacks since the compromise of a sensor only affects the links incident to that sensor. The difference between [3] and [4] is that sensors in [3] are paired based on ids while in [4] are on virtual grid locations. Similar to the <b>random</b> <b>keys</b> schemes, <b>random</b> pairwise <b>keys</b> schemes do not scale well to large sensor networks. Neither do they have good key-sharing probability due to {{the conflict between the}} high keying storage redundancy requirement and the memory constraint.|$|R
2500|$|The joining node inserts the {{bootstrap}} node {{into one}} of its k-buckets. The joining node then does a FIND_NODE of its own ID against the bootstrap node (the only other node it knows). The [...] "self-lookup" [...] will populate other nodes' k-buckets with the new node ID, and will populate the joining node's k-buckets with the nodes in the path {{between it and the}} bootstrap node. After this, the joining node refreshes all k-buckets further away than the k-bucket the bootstrap node falls in. This refresh is just a lookup of a <b>random</b> <b>key</b> that is within that k-bucket range.|$|E
5000|$|... #Subtitle level 3: PRNG with {{periodically}} refreshed <b>random</b> <b>key</b> ...|$|E
5000|$|If {{the coin}} lands on heads, he chooses a <b>random</b> <b>key</b> K and defines the {{function}} f = EK.|$|E
30|$|Volatile-random: evict <b>random</b> <b>keys</b> to make {{space for}} the new data added, but only evict keys with an expired set.|$|R
30|$|Cryptographic security: low security, {{brute force}} attack is feasible. Indeed, trying 30 {{millions}} <b>random</b> <b>keys</b> will allow retrieving the secret encryption key.|$|R
40|$|When using {{genetic and}} {{evolutionary}} algorithms for network design, choosing a good representation scheme {{for the construction}} of the genotype is important for algorithm performance. One of the most common representation schemes for networks is the characteristic vector representation. However, with encoding trees, and using crossover and mutation, invalid individuals occur that are either under- or overspecified. When constructing the offspring or repairing the invalid individuals that do not represent a tree, it is impossible to distinguish between the importance of the links that should be used. These problems can be overcome by transferring the concept of <b>random</b> <b>keys</b> from scheduling and ordering problems to the encoding of trees. This paper investigates the performance of a simple genetic algorithm (SGA) using network <b>random</b> <b>keys</b> (NetKeys) for the one-max tree and a real-world problem. The comparison between the network <b>random</b> <b>keys</b> and the characteristic vector encoding shows that despite the effects of stealth mutation, which favors the characteristic vector representation, selectorecombinative SGAs with NetKeys have some advantages for small and easy optimization problems. With more complex problems, SGAs with network <b>random</b> <b>keys</b> significantly outperform SGAs using characteristic vectors...|$|R
5000|$|The {{original}} AONT, {{the package}} transform, {{was described by}} Ronald L. Rivest in All-Or-Nothing Encryption and The Package Transform. Simply put, Rivest proposed encrypting each plaintext block with a <b>random</b> <b>key</b> to form the pseudomessage, then hashing each block and XORing all the hashes together with the <b>random</b> <b>key</b> to generate the last block of the pseudomessage. The blocks are also XOR'd with an incrementing counter to prevent duplicate blocks encrypting identically. This results in a [...] "package" [...] that cannot be partially decoded.|$|E
50|$|Informally, a {{block cipher}} is {{secure in the}} {{standard}} model if an attacker cannot {{tell the difference between}} the block cipher (equipped with a <b>random</b> <b>key)</b> and a random permutation.|$|E
50|$|RC5 {{encryption}} and decryption both {{expand the}} <b>random</b> <b>key</b> into 2(r+1) words {{that will be}} used sequentially (and only once each) during the encryption and decryption processes. All of the below comes from Rivest's revised paper on RC5.|$|E
40|$|We {{investigate}} {{the construction of}} weakly-secure index codes for a sender to send messages to multiple receivers with side information {{in the presence of}} an eavesdropper. We derive a sufficient and necessary condition for the existence of index codes that are secure against an eavesdropper with access to any subset of messages of cardinality t, for any fixed t. In contrast to the benefits of using <b>random</b> <b>keys</b> in secure network coding, we prove that <b>random</b> <b>keys</b> do not promote security in three classes of index-coding instances...|$|R
40|$|In this paper, {{we discuss}} multivariately factorized {{probability}} distributions for permutation random variables and a greedy approach to estimating these probability distributions from data. We use the representation known as <b>random</b> <b>keys</b> for permutations. The major benefit of using <b>random</b> <b>keys</b> {{is that no}} infeasible solution can be generated if crossover is applied in an evolutionary algorithm (EA). The estimated multivariately factorized probability distribution {{can be used to}} construct a linkage friendly crossover operator with which new o#spring can be generated. We call the EA that uses this technique to construct a crossover operator, ICE...|$|R
50|$|The term PLOKTA (sometimes {{rendered}} in lowercase, plokta) /plokt*/ is {{an acronym for}} Press Lots Of Keys To Abort, and essentially means pressing <b>random</b> <b>keys</b> {{in an attempt to}} get some response from a (computer) system.|$|R
50|$|The {{simplest}} such pairwise independent {{hash function}} {{is defined by}} the <b>random</b> <b>key</b> key = (a,b), and the MAC tag for a message m is computed as tag = (am + b) mod p, where p is prime.|$|E
50|$|Many {{failures}} in cryptographic engineering are catastrophic. That is, success in breaking one message leads to reading all messages. Most cryptographic algorithms and protocols make certain assumptions (<b>random</b> <b>key</b> or nonce choices, for example), and when those assumptions are violated, all security is lost.|$|E
5000|$|GnuTLS {{consists}} of a library that allows client applications to start secure sessions using the available protocols.It also provides command-line tools, including an X.509 certificate manager, a test client and server, and <b>random</b> <b>key</b> and password generators. [...] administrators can configure Apache web server to use GnuTLS so as to support TLS 1.2.|$|E
40|$|Abstract—This paper studies secure unicast {{communication}} over {{a network}} with uniform wiretap sets and shows that, when network nodes can independently generate randomness, determining the secrecy capacity {{is at least}} as difficult as the k-unicast network coding problem. In particular, we show that a general k-unicast problem can be reduced to the problem of finding the secrecy capacity of a corresponding single unicast network with uniform link capacities and any one wiretap link. We propose a low-complexity linear optimization-based achievable strategy involving global <b>random</b> <b>keys</b> that can be generated anywhere in the network, and an efficient greedy algorithm that further improves achieveable rate by exploiting local <b>random</b> <b>keys.</b> I...|$|R
3000|$|Finally, {{the paper}} [...] "Distributed KDC-based <b>random</b> {{pairwise}} <b>key</b> establishment in wireless sensor networks" [...] proposes a <b>random</b> pair-wise <b>key</b> establishment scheme for WSNs that differentiates {{the roles of}} sensors as either auxiliary nodes or ordinary nodes prior to network deployment.|$|R
40|$|In {{this work}} we propose a multi-population genetic {{algorithm}} for tree-shaped network design problems using <b>random</b> <b>keys.</b> Recent literature on finding optimal spanning trees suggests {{the use of}} genetic algorithms. Furthermore, <b>random</b> <b>keys</b> encoding has been proved efficient at dealing with problems where the relative order of tasks is important. Here we propose to use <b>random</b> <b>keys</b> for encoding trees. The topology of these trees is restricted, since no path from the root vertex to any other vertex may {{have more than a}} pre-defined number of arcs. In addition, the problems under consideration also exhibit the characteristic of flows. Therefore, we want to find a minimum cost tree satisfying all demand vertices and the pre-defined number of arcs. The contributions of this paper are twofold: on one hand we address a new problem, which is an extension of the well known NP-hard hop-constrained MST problem since we also consider determining arc flows such that vertices requirements are met at minimum cost and the cost functions considered include a fixed cost component and a nonlinear flow routing component; on the other hand, we propose a new genetic algorithm to efficiently find solutions to this problem...|$|R
50|$|To {{create a}} PEX {{protocol}} providing a uniformly-distributed peer selection, one could form a small DHT local to a torrent. For each desired new peer one {{would look up}} a (uniformly) <b>random</b> <b>key,</b> and use the node responsible for the key as a new peer. This is conceptually simple but would require quite some overhead.|$|E
5000|$|Systems that {{implement}} greylisting work {{fine with}} VERP if the envelope sender follows the above mentioned format. However, some VERP implementations use message number or <b>random</b> <b>key</b> {{as part of}} VERP, which causes each post to the mailing list to be delayed unless the greylisting system treats [...] "similar" [...] sender addresses as being equivalent.|$|E
50|$|The major {{difference}} from RTSP is an initial asymmetric key verification made by iTunes to verify it is communicating with an AirPort Express or an Apple TV (as {{opposed to a}} simulation), and vice versa. The data channel is also encrypted by AES, with a <b>random</b> <b>key</b> protected by the asymmetric key mentioned above.|$|E
50|$|<b>Random</b> {{symmetric}} <b>key</b> K is generated.|$|R
5000|$|The {{most common}} types {{of this form}} of signal jamming are random noise, random pulse, stepped tones, warbler, <b>random</b> <b>keyed</b> {{modulated}} CW, tone, rotary, pulse, spark, recorded sounds, gulls, and sweep-through. These {{can be divided into}} two groups [...] - [...] obvious and subtle.|$|R
40|$|In this paper, {{we present}} a hybrid genetic {{algorithm}} for {{a version of the}} early/tardy scheduling problem in which no unforced idle time may be inserted in a sequence. The chromosome representation of the problem is based on <b>random</b> <b>keys.</b> The genetic algorithm is used to establish the order in which the jobs are initially scheduled, and a local search procedure is subsequently applied to detect possible improvements. The approach is tested on a set of randomly generated problems and compared with existing efficient heuristic procedures based on dispatch rules and local search. The computational results show that this new approach, although requiring slightly longer computational times, is better than the previous algorithms in terms of solution quality. Scheduling, early/tardy, heuristics, genetic algorithms, <b>random</b> <b>keys...</b>|$|R
50|$|For each message, the {{operator}} would choose a three-letter message key to encrypt {{the body of}} the message. The intention was for this key to be random, and using a <b>random</b> <b>key</b> for each message was a good security practice. The message key needed to be communicated to the recipient so the recipient could decrypt the message.|$|E
50|$|Keys may be {{generated}} randomly {{and then the}} nodes determine mutual connectivity. A structured approach based on matrices that establishes keys in a pair-wise fashion is due to Rolf Blom. Many variations to Blom's scheme exist. Thus the scheme of Du et al. combines Blom’s key pre-distribution scheme with the <b>random</b> <b>key</b> pre-distribution method with it, providing better resiliency.|$|E
50|$|HKDF {{extracts}} a pseudo <b>random</b> <b>key</b> (PRK) {{using an}} HMAC hash function (e.g. HMAC-SHA256) on an optional salt and any potentially weak input key material (IKM). It then generates similarly cryptographically strong output key material (OKM) of any desired length by repeatedly generating PRK-keyed hash-blocks and then appending {{them into the}} output key material, finally truncating to the desired length.|$|E
2500|$|Opera Mini encrypts the {{connection}} between the mobile device and the Opera proxy server for security. The encryption key is obtained on the first start by requesting <b>random</b> <b>keys</b> a certain number of times. Opera Mini supports most advanced version of Transport Layer Security (TLS) protocol ...|$|R
40|$|We {{address the}} issue of optimal {{resource}} allocation, and more specifically, the analysis of complementarity of resources (primary resource or P-resource and supportive resource or S-resource) to activities in a project. In this paper we present new computational results of a Genetic Algorithm, based in a <b>random</b> <b>keys</b> alphabet...|$|R
40|$|Two {{methods of}} {{creating}} schedules in a <b>Random</b> <b>Keys</b> Genetic Algorithm are investigated {{with regards to}} effectiveness. One uses job-to-machine assignments {{in the first stage}} as the chromosome, with a greedy heuristic to assign jobs to machines in later stages. The other method explicitly makes job-to-machine assignments in all stages...|$|R
