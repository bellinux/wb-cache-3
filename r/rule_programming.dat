7|1266|Public
40|$|Distributed systems {{development}} is complex; especially if system needs to specify dynamic behavior, increase scalability, maintenance, and debugging. A programming paradigm {{specifically designed for}} distributed systems could help reduce the implementation complexity of distributed systems applications. In this paper we present {{the implementation of a}} distributed system for flood alert using two programming paradigms: the event <b>rule</b> <b>programming</b> [Arroyo 02] and the object-oriented programming. 1...|$|E
40|$|Different rule {{execution}} semantics may {{be available}} in the same active database system. We perform several simulation experiments to evaluate the performance trade-offs yielded by different execution semantics in various operating conditions. In particular, we evaluate the eflect of executing transaction and rule statements that affect a varying number of data instances, and applications with different rule triggering breadth and depth. Since references to data changed by the database operation triggering the rules are commonly used in active <b>rule</b> <b>programming,</b> we also analyze the impact of its management on overall performance. 1...|$|E
40|$|An expert system, ETUDES - Expert Time {{integration}} control Using Deep and Surface Knowledge System, which {{addresses the}} determination of the timestep for time integration of linear structural dynamic equations is described. This timestep may also be applicable for a moderately nonlinear simulation of the same structure. The program also determines whether an explicit or implicit method is most efficient for the particular simulation. A production <b>rule</b> <b>programming</b> system written in OPS 5 is used for the implementation of this prototype expert system. Issues relating to the expert system architecture for this application, such as knowledge representation and structure, as well as domain knowledge are discussed. The prototype is evaluated by measuring its performance in various benchmark model problems...|$|E
40|$|Abstract—Rule-based {{programming}} {{has been}} gaining interest in the industry for several years, through the growing use of Business Rules Management Systems. A demand for verification of semantic properties on <b>rule</b> <b>programs</b> has thus emerged. In this paper we present an approach to <b>rule</b> <b>program</b> verification, using constraints to model program executions and verification properties, and a Constraint-Based Programming Solver (CP Solver) to compute the answers to verification questions. We also study the use of constraint-based <b>programming</b> in <b>rule</b> <b>program</b> verification, {{and the consequences of}} this usage on the CP Solver compared to combinatorial optimization problems. Keywords-rule-based programming; program analysis; pro-gram verification; constraint-based programming; constraint satisfiability. I...|$|R
40|$|The {{purpose of}} this study was to {{determine}} the outcomes and to offer improvement recommendations for the Rural-Urban Leadership <b>Program</b> (<b>RULE)</b> an agricultural-based leadership <b>program.</b> The <b>RULE</b> <b>program</b> is an agricultural-based leadership program that is administered by Penn State Extension under the College of Agricultural Sciences of Penn State University. Specifically, this study utilized the ten-point RULE curriculum plan and <b>RULE</b> <b>program</b> objectives to determine anticipated outcomes of RULE participants. Alumni were also asked to offer suggestions for <b>RULE</b> <b>program</b> improvement regarding curriculum and alumni engagement. This study identified the outcomes and recommendations for programmatic improvement of the <b>RULE</b> <b>program</b> through a mixed-methods approach involving ten semi-structured interviews and a Qualtrics survey instrument. The sample population for both the semi-structured interview and the Qualtrics survey consisted of alumni that participated in the program over the last 9 Study Institutes or 15 years. There was a total of 206 alumni that completed the program, and 196 were accessible through email. Of the 196 accessible alumni, a total of 74 completed the Qualtrics survey which is a survey response rate of 38...|$|R
40|$|Abstract Production {{systems are}} declarative, {{in that they}} do not ex-plicitly specify the control flow. Yet, the concept of a {{production}} system does not include the definition of a given control strategy. The control be-tween rules in a production <b>rule</b> <b>program</b> is, in practice, defined by each implementation of a production rule engine. Engines have traditionally been implemented using the Rete algorithm. Since the turn of the cen-tury, however, production systems have evolved into industrial products known as Business Rules Management Systems (BRMS). BRMS have in-troduced new compilation and execution schemes, which are often called sequential in contrast with the incremental behavior of Rete. This change in execution scheme came with a change in semantics for <b>rule</b> <b>programs.</b> In this paper, we propose a formal description of the execution of pro-duction <b>rule</b> <b>programs.</b> Existing descriptions either ignore the control strategy, or assume a Rete semantics. Ours isolates the handling of rule eligibility in the control strategy, which allows us to describe the sequen-tial execution semantics of <b>rule</b> <b>programs,</b> as well as the Rete semantics, and others. ...|$|R
40|$|This paper {{illustrates}} a prototype system, called GPRS, supporting the Generalized Production Rules (GPR) database language. The GPR language integrates, in a unified framework, active rules, which allow the specification of event driven computations on data, and deductive rules, {{which can be}} used to derive intensional relations in the style of logic programming. The prototype realizes the operational semantics of GPR using a unique ruleevaluation engine. The data model of reference is object based and the system is implemented on top of an object oriented DBMS. Hence, the GPRS prototype represents a concrete proposal of an advanced DBMS for complex objects that provides both active and deductive styles of <b>rule</b> <b>programming.</b> c fl 1997 John Wiley & Son...|$|E
40|$|Telecare and {{telehealth}} {{system services}} can be dynamically configured to collect, analyse, store, and adapt to multimodal data about {{people as they}} go about their activities of daily life. These services {{need to be able}} to personalise to subjects and adapt to changes in lifestyles, environments and technology. Such dynamic adaptability may be well supported by a low-level <b>rule</b> <b>programming</b> approach; however measures may need to be taken to limit the emergence of conflicts between the distributed rulesets owing to differing programmatic assumptions and unexpected changes. Here, we consider types of conflict that might arise when a variety of care devices are brought together and begin to rely on each others' services. This paper describes a distributed rule-based conflict detection approach for use with heterogeneous mobile and home care devices. We propose methods that make it possible to detect certain forms of rule conflict. To do so, we introduce Event Calculus based logic for writing device rules and an analytical framework for conflict detection...|$|E
40|$|Abstract—Telecare and {{telehealth}} {{system services}} can be dynamically configured to collect, analyse, store, and adapt to multimodal data about {{people as they}} go about their activities of daily life. These services {{need to be able}} to personalise to subjects and adapt to changes in lifestyles, environments and technology. Such dynamic adaptability may be well supported by a low-level <b>rule</b> <b>programming</b> approach; however measures may need to be taken to limit the emergence of conflicts between the distributed rulesets owing to differing programmatic assumptions and unexpected changes. Here, we consider types of conflict that might arise when a variety of care devices are brought together and begin to rely on each others ’ services. This paper describes a distributed rule-based conflict detection approach for use with heterogeneous mobile and home care devices. We propose methods that make it possible to detect certain forms of rule conflict. To do so, we introduce Event Calculus based logic for writing device rules and an analytical framework for conflict detection. Keywords-service conflict detection; rule-based sensor networks; ambulatory assessment I...|$|E
5000|$|The Avicenna Directory {{included}} contact details, admission <b>rules,</b> <b>program</b> descriptions, {{titles of}} degrees and diplomas awarded, and accreditation status of institutions.|$|R
40|$|National audienceThis paper {{introduces}} the UBIQUEST project that proposes {{a high level}} programming abstraction for rapid prototyping of networking applications in a dynamic environment perceived as a distributed database. Applications interact with this environment through declarative queries that include <b>rule</b> <b>programs</b> for network management (e. g. routing) and/or for specific data-oriented distributed algorithms (e. g. distributed join). The <b>rule</b> <b>programs</b> are specified using Datalog-based languages, while classical data oriented manipulations are specified using an SQL-Like language...|$|R
40|$|Rules {{represent}} a simplified means of programming, congruent with {{our understanding of}} human brain constructs. With the advent of business rules management systems, it has been possible to introduce rule-based programming to nonprogrammers, allowing them to map expert intent into code in applications such as fraud detection, financial transactions, healthcare, retail, and marketing. However, a remaining concern is the quality, safety, and reliability of the resulting programs.  This book is on business <b>rules</b> <b>programs,</b> that is, <b>rule</b> <b>programs</b> as handled in business rules management systems. It...|$|R
40|$|The {{purpose of}} this {{research}} is to analyze production rules with coupling modes in active databases and to exploit an assistant system for <b>rule</b> <b>programming.</b> Each production rule is a specification including an event, acondition, and an action. The action is automatically executed whenever the event occurs and the condition is satisfied. Coupling modes are useful to control execution order of transactions. For example, a transaction for consistency check should be executed after transactions for update. An active database, which is a database with production rules, can spontaneously update database states and check their consistency. Production rules provide a powerful mechanism for knowledge-bases. However it is very difficult in general to predict how a set of production rules will behave because of cascading rule triggers, concurrency, and so on. We are attempting to adopt a process algebra as a basic tool to analyze production rules. In order to describe and analyze concurrent and communicating systems, process algebras such as CCS, CSP, ACP, and π-calculus, are well known. However there are some difficulties to apply existing process algebras to analysis of production rules in growing process trees by process creation. In this paper we propose a process algebra named CCSPR (a Calculus of Communicating Systems with Production Rules), which is an extension of CCS. An advantage of CCSPR is to syntactically describe growing process trees. Therefore, production rules can be appropriately analyzed in CCSPR. After giving definitions and properties of CCSPR, we show an example of analysis of production rules in CCSPR. key words: active database, production rule, process algebra, process creation, process tree, multi-way communication. 1...|$|E
50|$|Location-based routing - <b>Rules</b> <b>programmed</b> in at {{particular}} {{points in a}} system to route the call on to different destinations depending on {{the location of the}} caller.|$|R
50|$|In the Schorre META X {{languages}} {{there is}} a driving <b>rule.</b> The <b>program</b> <b>rule</b> above {{is an example of}} a driving <b>rule.</b> The <b>program</b> <b>rule</b> is a test function that calls declaration, a test rule, that returns success or failure. The $ loop operator repeatedly calling declarations until failure is returned. The $ operator is always successful, even when zero declarations occur. Above program would always return success.|$|R
40|$|AbstractWe {{consider}} logic programs without function symbols, called Datalog programs, {{and study}} their parallel complexity. We survey the tools developed for proving {{that there is}} a PRAM algorithm which computes the minimum model of a Datalog program in polylogarithmic parallel time using a polynomial number of processors (that is, for proving membership in NC). We extend certain of these tools to be applied to a wider class of programs; as they were, they were applied to chain <b>rule</b> <b>programs</b> (i. e., the relations on the right-hand side of the rule are binary and form a chain). We examine the parallel complexity of weak-chain <b>rule</b> <b>programs</b> (i. e., the relations on the right-hand side of the rule form a weak chain), and prove certain subclasses to belong to NC. Finally we prove a wide class of programs to be log space complete for P, by giving sufficient conditions for a single <b>rule</b> <b>program</b> to be P-complet...|$|R
50|$|Time and Date-Based Routing - <b>Rules</b> <b>programmed</b> in at {{particular}} {{points in a}} system to route the call on to different destinations depending the time or date of the call.|$|R
40|$|Abstract In this paper, {{we focus}} on the impact of {{ontology}} changes on production rules, in the context of <b>rule</b> <b>programs</b> written over the entities of OWL ontologies. Then, ontology evolutions may make rules inconsistent with respect to the knowledge modeled by the ontology. To address this problem, we propose to combine two approaches: the syntactic approach of the Model-Detect-Repair (MDR) method, and a semantic approach based on a formal description of production <b>rules</b> and <b>rule</b> <b>program</b> inconsistencies. The present paper shows on simple use cases the expected benefits of such a combination, which relies on existing implementations...|$|R
40|$|The {{variable}} <b>rule</b> <b>program</b> {{is one of}} {{the predominant}} data analysis tools used in sociolinguistics, employed successfully for over three decades to quantitatively assess the influence of multiple factors on linguistic variables. However, its most popular current version, GoldVarb, lacks flexibility and also isolates its users from the wider community of quantitative linguists. A new version of the variable <b>rule</b> <b>program,</b> Rbrul, attempts to resolve these concerns, and with mixed-effects modelling also addresses a more serious problem whereby GoldVarb overestimates the significance of effects. Rbrul's superior performance is demonstrated on both simulated and real data sets...|$|R
40|$|Integrated {{rule and}} {{database}} systems are quickly {{moving from the}} research laboratory into commercial systems. However, {{the current generation of}} prototypes are designed to work with small rule sets involving limited inferencing. The problem of supporting large complex <b>rule</b> <b>programs</b> within database management systems still presents significant challenges. The basis for many of these challenges is providing support for rule activation. Rule activation is defined as the process of determining which rules are satisfied and what data satisfies them. In this paper we present performance results for the DATEX database rule system and its novel indexing technique for supporting rule activation. Our approach assumes that both the <b>rule</b> <b>program</b> and the database must be optimized syn-ergistically. However, as an experimental result we have deter-mined that DATEX requires very few changes to a standard DBMS environment, and we argue that these changes are reasonable for the problems being solved. Based on the performance of DATEX we believe we have demonstrated a satisfactory solution to the rule activation problem for complex <b>rule</b> <b>programs</b> operating within a database system. ...|$|R
50|$|The Lodi <b>Rules</b> <b>program</b> {{includes}} the Pesticide Environmental Assessment System (PEAS)., which measures {{the environmental impact}} of pesticides, organic or synthetic. The vineyard must not exceed a maximum number of pesticide impact points. Certification is assessed annually.|$|R
2500|$|Football Inquest, Melbourne-based Australian <b>rules</b> {{football}} <b>program</b> ...|$|R
5000|$|Requirements for {{a process}} system are derived at every {{hierarchical}} level. [...] Black-box requirements {{for a system}} come from its suprastructure. Customer requirements are black-box requirements near, if not at, {{the top of a}} process architecture's hierarchy. White-box requirements, such as engineering <b>rules,</b> <b>programming</b> syntax, etc., come from the process system's infrastructure.|$|R
5000|$|A few {{exceptions}} exist to this <b>rule</b> for <b>programming</b> and continuity: ...|$|R
2500|$|Requirements for {{a process}} system are derived at every {{hierarchical}} level. [...] Black-box requirements {{for a system}} come from its suprastructure. [...] Customer requirements are black-box requirements near, if not at, {{the top of a}} process architecture's hierarchy. [...] White-box requirements, such as engineering <b>rules,</b> <b>programming</b> syntax, etc., come from the process system's infrastructure.|$|R
5000|$|Tagliamonte was a Killam Research Fellow from 2013-2015 [...] and {{has been}} a Fellow of the Royal Society of Canada since 2013. She was a media expert for the Linguistic Society of America in 2013. She was an {{associate}} editor of Language from 2007-2010. She is a co-creator of a variable <b>rule</b> <b>program,</b> Goldvarb.|$|R
40|$|Expert Databases are {{environments that}} support the {{processing}} of <b>rule</b> <b>programs</b> against a disk resident database. They occupy a position intermediate between active and deductive databases, {{with respect to the}} level of abstraction of the underlying rule language. The operational semantics of the rule language influences the problem solving strategy, while the architecture of the processing environment determines efficiency and scalability. In this paper, we present elements of the PARADISER architecture and its kernel rule language, PARULEL. The PARADISER environment provides support for parallel and distributed evaluation of <b>rule</b> <b>programs,</b> as well as static and dynamic load balancing protocols that predictively balance a computation at runtime. This combination of features results in a scalable database rule and complex query processing architecture. We validate our claims by analyzing the performance of the system for two realistic test cases. In particular, we show how the performanc [...] ...|$|R
40|$|Projet RODINSeveral {{incremental}} algorithms {{have been}} proposed ro evaluate database production <b>rule</b> <b>programs.</b> They all derive from existing incremental algorithms, lke RETE and TREAT, developed for rule-based systems {{in the framework of}} artificial intelligence. In this paper, we address a specific but crucial problem that arises with these incremental algorithms : how much data should be profitably materialized and maintained in order to speed-up program evaluation ?. We show that the answer exposes to a well known space-time tradeoff. Our major contribution is to propose and adaptive algorithm that takes as input a <b>program</b> of <b>rules</b> and returns for each rule, the set of most profitable relational expressions that should be maintained in order to obtain a good space-time compromise. A notable feature of our algorithm is that it works for both set-oriented and instance-oriented rules. We compare our algorithms with existing incremental algorithms for database production <b>rule</b> <b>programs...</b>|$|R
40|$|We {{introduce}} the CHR machine, {{a model of}} computation based on the Constraint Handling <b>Rules</b> <b>programming</b> language. Its computational power and time complexity properties are {{compared with those of}} the Turing machine and Random Access Memory machine. Our major result is the proof that every algorithm can be implemented in CHR with the best known time and space complexity. status: publishe...|$|R
40|$|The {{dependability}} of {{a system}} can be enhanced by structuring it so as to limit the flow of errors, so that faults do not result in failures. This concept applies to both the mechanical and the human components of a computer-based system (see Chapter 1 of this volume). The present chapter looks at the impact of <b>rules</b> (<b>programs</b> and proce...|$|R
5000|$|Several {{countries}} {{now have}} youth Australian <b>rules</b> <b>programs</b> in place. These countries include Papua New Guinea, New Zealand, Samoa, Tonga, Nauru, Denmark, South Africa, England, Indonesia, the United States, and Canada. The {{number of participants}} is quite high in PNG, RSA and NZ generally dependent {{on the level of}} AFL funding but some [...] "private" [...] endeavours in Canada and the UK have produced significant results.|$|R
5000|$|Greenspun's tenth <b>rule</b> of <b>programming</b> is an aphorism in {{computer}} programming and especially programming language circles that states: ...|$|R
40|$|AdaControl [1] is a (free) tool {{whose purpose}} is to enforce coding {{standards}} and <b>programming</b> <b>rules</b> in Ada <b>programs.</b> As AdaControl {{is more and more}} widely used in the industry, we had to review many industrial coding standards, in order to write the corresponding AdaControl rules. This paper presents our experience with rules of various origins, analyzes the rules commonly encountered, and provides some lessons-learned about good and bad <b>programming</b> <b>rules...</b>|$|R
50|$|Every <b>rule</b> is <b>programmed</b> in the software, {{so there}} will be no errors during the {{execution}} or getting the results.|$|R
5000|$|Technology reference: {{specifies}} a technology-dependent {{interpretation of}} the technology-independent parts of the standard, typically via mapping <b>rules</b> or <b>program</b> code.|$|R
2500|$|The Philippines was {{included}} in the vast territory of the Kingdom of Spain, in the first constitution of Spain promulgated in Cadiz in 1812. It was never a colony as modern-day historical literature would say, but an overseas region in Asia {Spanish Constitution 1812}. The Spanish Constitution of 1870 provides for the first autonomous community for [...] "Archipelago Filipino" [...] where all provinces in the Philippine Islands will be given the semi-independent home <b>rule</b> <b>program.</b>|$|R
