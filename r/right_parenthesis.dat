20|12|Public
2500|$|In ordered lists, {{after the}} ordinal symbol (such as a letter or number), {{separating}} {{it from the}} text of the item; compare the colon, period, or <b>right</b> <b>parenthesis</b> in western text ...|$|E
5000|$|... add [...] {{at the end}} of the {{expression}} and before each <b>right</b> <b>parenthesis</b> in the original expression.|$|E
5000|$|If φ is {{a natural}} number, then the result of concatenating s, left parenthesis, φ, and <b>right</b> <b>parenthesis</b> (in that order, from left to right) denotes the {{successor}} of φ.|$|E
5000|$|It can {{be shown}} that any {{expression}} matched by the grammar has a balanced number of left and <b>right</b> <b>parentheses,</b> and any nonempty initial segment of a formula has more left than <b>right</b> <b>parentheses.</b> This fact {{can be used to}} give an algorithm for parsing formulas. For example, suppose that an expression x begins with [...] Starting after the second symbol, match the shortest subexpression y of x that has balanced parentheses. If x is a formula, there is exactly one symbol left after this expression, this symbol is a closing parenthesis, and y itself is a formula. This idea can be used to generate a recursive descent parser for formulas.|$|R
5000|$|Two symbols for left, [...] and <b>right,</b> [...] <b>parentheses</b> for {{establishing}} precedence of quantifiers.|$|R
5000|$|The {{inductive}} definition {{can also}} be rephrased {{in terms of a}} closure operation (Enderton 2002). Let V denote a set of propositional variables and let XV denote the set of all strings from an alphabet including symbols in V, left and <b>right</b> <b>parentheses,</b> and all the logical connectives under consideration. Each logical connective corresponds to a formula building operation, a function from XXV to XXV: ...|$|R
5000|$|In ordered lists, {{after the}} ordinal symbol (such as a letter or number), {{separating}} {{it from the}} text of the item; compare the colon, period, or <b>right</b> <b>parenthesis</b> in western text ...|$|E
50|$|Positive kerning is used {{mainly in}} {{conjunction}} with special characters and punctuation (for example, the lower case letter f followed by <b>right</b> <b>parenthesis</b> or quotation mark). Depending on the font, some small positive kerning may also be required for accented letters and for pairs like Bo, Dw, and TY.|$|E
50|$|The {{shunting}} yard algorithm {{can also be}} applied to produce prefix notation (also known as Polish notation). To do this one would simply start {{from the end of}} a string of tokens to be parsed and work backwards, reverse the output queue (therefore making the output queue an output stack), and flip the left and <b>right</b> <b>parenthesis</b> behavior (remembering that the now-left parenthesis behavior should pop until it finds a now-right parenthesis).|$|E
50|$|The {{proof that}} the {{language}} of balanced (i.e., properly nested) parentheses is not regular follows the same idea. Given p, there is a string of balanced parentheses that begins with more than p left parentheses, so that y will consist entirely of left parentheses. By repeating y, we can produce a string that does not contain {{the same number of}} left and <b>right</b> <b>parentheses,</b> and so they cannot be balanced.|$|R
40|$|We {{show that}} the set Bn of {{balanced}} parentheses strings with n left and n <b>right</b> <b>parentheses</b> can be generated by prefix shifts. If b 1, b 2, [...] ., b 2 n {{is a member of}} Bn, then the k-th prefix shift is the string b 1, bk, b 2, [...] ., bk− 1, bk+ 1, [...] .,b 2 n. Prefix shift algorithms are also known for combinations, and permutations of a multiset; the combination algorithm appears in fascicles of Knuth vol 4. We {{show that the}} algorithm is closely related to the combination algorithm, and like it, has a loopless implementation, and a ranking algorithm that uses O(n) arithmetic operations. Additionally, the algorithm can be directly translated to generate all binary trees by a loopless implementation that makes a constant number of pointer changes for each successively generated tree...|$|R
2500|$|... and so forth. The {{expressions}} on the <b>right</b> (with no <b>parentheses</b> whatsoever) {{are allowed}} to be written unambiguously because of the equalities on the left. Note that the associative property does not hold for expressions that include nonlinear operators, such as the antilinear time reversal operator in physics.|$|R
50|$|The quasi-quotation marks {{here are}} {{interpreted}} just the same. Where φ and ψ denote wffs of L, ⌜(φ v ψ)⌝ denotes {{the result of}} concatenating left parenthesis, the wff denoted by φ, space, v, space, the wff denoted by ψ, and <b>right</b> <b>parenthesis</b> (in that order, from left to right). Just as before, rule 2.5 (unlike rule 2.5) entails, e.g., that if p and q are wffs of L, then (p v q) is a wff of L.|$|E
50|$|With metric kerning, in a {{text that}} uses several fonts, the program must decide which kerning table to use when two {{consecutive}} characters belong to different fonts - the table from the font of the first character, or the second one - or to avoid kerning altogether. In this case, optical kerning is preferable. A common situation occurs when italic text ends with a roman symbol (<b>right</b> <b>parenthesis</b> or quotation mark, question mark, etc.) and the last letter's slant clashes with the symbol.|$|E
5000|$|In English-speaking countries, long {{division}} {{does not}} use the division slash [...] or obelus [...] signs but instead constructs a tableau. The divisor is separated from the dividend by a <b>right</b> <b>parenthesis</b> [...] or vertical bar the dividend is separated from the quotient by a vinculum (i.e., overbar). The combination of these two symbols is sometimes known as a long division symbol or division bracket. It developed in the 18th century from an earlier single-line notation separating the dividend from the quotient by a left parenthesis.|$|E
40|$|The call-by-value λµ-calculus (λµV, de Groote, 2008) is an {{extension}} of typed λ-calculus, adapted from the λµ-calculus of Parigot (1992). λµV differs from Parigot’s calculus in that: • The notion of a class of terms called values is introduced (see Definition 2). These terms are treated specially with respect to certain reduction rules. • A “symmetric ” reduction rule (µV) is added that is similar to rule R 4 of Parigot’s (2000) symmetric λµ-calculus. A reduction rule for µ-variables (Rename) is also added. • A new reset operator is introduced, with typing and reduction rules that govern its use. Like the λµ-calculus of Parigot (1992), λµV allows a term to be “named ” and used (via µ-application and µ-abstraction) so that its name is preserved under reduction. We mildly extend de Groote’s λµV by adding product for both terms and types. Definition 1 (Terms). Terms are generated from two disjoint sets of variables, λ-variables (represented by x) and µ-variables (represented by a), according to the following rules: M:: = c | x | λx M | (M M) | 〈M, M 〉 | µaM | (a M) | ⌈M⌋ where c is a constant. We adopt the convention that applications and pairings associate to the left and abstractions associate to the <b>right.</b> <b>Parentheses</b> are sometimes abbreviated using. in the usual way (e. g., λx µa. M). Definition 2 (Values). The set of values is the subset of the set M of terms defined as: where c, x, and M are as defined in Definition 1. V:: = x | λx M | (c V [...] . V) | 〈V, V 〉 Definition 3 (Typing). The set of types T is generated according to the following rules...|$|R
40|$|Fig. 1. Phylogenetic tree {{based on}} the Maximum-Likelihood {{reconstruction}} (calculated with PHYML v 3. 0; Guindon and Gascuel 2003) using 3254 bp of the mitochondrial DNA showing position of Vipera walser, and relationships with other Vipera species. Values of bootstrap supports are showed for neighbour joining (top left), maximum parsimony (top right), maximum-likelihood (bottom left) and Bayesian inferences (bottom right). Support values for the bPTP species delimitation model are shown in <b>parenthesis</b> <b>right</b> of the species epithet...|$|R
50|$|Given any {{expression}} involving complex numbers, bras, kets, inner products, outer products, and/or linear operators (but not addition), {{written in}} bra-ket notation, the parenthetical groupings do not matter (i.e., the associative property holds). For example:and so forth. The expressions on the <b>right</b> (with no <b>parentheses</b> whatsoever) {{are allowed to}} be written unambiguously because of the equalities on the left. Note that the associative property does not hold for expressions that include non-linear operators, such as the antilinear time reversal operator in physics.|$|R
5000|$|PM 's dots {{are used}} {{in a manner similar}} to parentheses. Each dot (or {{multiple}} dot) represents either a left or <b>right</b> <b>parenthesis</b> or the logical symbol ∧. More than one dot indicates the [...] "depth" [...] of the parentheses, for example, [...] ".", [...] ":" [...] or [...] ":.", [...] "::". However the position of the matching right or left parenthesis is not indicated explicitly in the notation but has to be deduced from some rules that are complicated, confusing and sometimes ambiguous. Moreover, when the dots stand for a logical symbol ∧ its left and right operands have to be deduced using similar rules. First one has to decide based on context whether the dots stand for a left or <b>right</b> <b>parenthesis</b> or a logical symbol. Then one has to decide how far the other corresponding parenthesis is: here one carries on until one meets either a larger number of dots, or the same number of dots next that have equal or greater [...] "force", or the end of the line. Dots next to the signs ⊃, ≡,∨, =Df have greater force than dots next to (x), (∃x) and so on, which have greater force than dots indicating a logical product ∧.|$|E
5000|$|The {{sequence}} of pushes and pops performed by Knuth's sorting algorithm as it sorts a stack-sortable permutation form a Dyck language: reinterpreting a push as a left parenthesis and a pop as a <b>right</b> <b>parenthesis</b> produces {{a string of}} balanced parentheses. Moreover, every Dyck string comes from a stack-sortable permutation in this way, and every two different stack-sortable permutations produce different Dyck strings. For this reason, the number of stack-sortable permutations of length n {{is the same as}} the number of Dyck strings of length 2n, the Catalan number ...|$|E
5000|$|The words [...] (colon), , [...] (tick) are {{examples}} of parsing words that take their arguments from the user input device instead of the data stack. Another example is the word [...] (paren) which reads and ignores the following words {{up to and including}} the next <b>right</b> <b>parenthesis</b> and is used to place comments in a colon definition. Similarly, the word [...] (backslash) is used for comments that continue {{to the end of the}} current line. To be parsed correctly, [...] (paren) and [...] (backslash) must be separated by whitespace from the following comment text.|$|E
5000|$|The first lines contain {{metainformation}} such as {{the name}} of the chant, the appropriate place in the liturgy of the mass or the Liturgy of the Hours, the original source or the copyright of the score. Sung text and notes are not, as in Lilypond syntax, separated, but the notes are written in <b>parentheses</b> <b>right</b> after the corresponding syllable. A short overview of the syntax is provided by a cheat sheet. If both the TeX and the gabc file are in the same directory, one has just to compile the tex-file with [...]|$|R
3000|$|We now {{present the}} feature {{matching}} results produced by our benchmark. These {{are presented in}} Fig.  7 using PR curves with the [...] F_ 1 scores shown in <b>parentheses</b> <b>right</b> next to the feature names. The points along the curves are sampled {{in such a way}} that there is an equal amount of data points between two samples. This reveals the additional property that most of the curves contain a majority of samples with a low precision. The scores are shown with three significant digits, since some results differ by very small amounts. This is reasonable, because the curves, and thereby the scores, are computed based on thousands of data points. The same holds for all the results presented in the rest of this paper.|$|R
40|$|Chierchia (2004) {{argues that}} scalar implicature {{computation}} {{is part of}} function compositional process of a sentence interpretation. In this talk I will discuss a set of data from Japanese which indirectly support this hypothesis. The data involve a numeral quantifier (NQ) and mo. An NQ {{is a combination of}} a numeral and a classifier, and mo is a presuppositional element similar to English even. The data show there to be strict correlations between syntactic structure and presuppositional meaning. I argue that these correlations can only be explained satisfactorily if presupposition is locally computed during semantic interpretation via function composition. The relevant set of data is shown in (1) -(3), where boldfacing shows focus stress and square brackets indicate syntactic constituents. In (1) NQ-mo is in an adverbial position modifying a VP. In (2) mo is attached to a nominal constituent of the form [NQ-no NP]. In (3) NQ-mo is embedded in a DP as [[NQ-mo]-no NP]DP. The different interpretations corresponding to the different syntactic structures in positive and negative contexts are indicated on the <b>right</b> in <b>parentheses.</b> (1) NQ-mo a. gakusei-ga [20 -nin-mo shiken-ni gookaku shita]. student-NOM 20 -CL-MO exam-in pass did ‘As many as 20 students passed the exam. (high) b. gakusei-ga [20 -nin-mo shiken-ni gookaku shinakatta]. student-NOM 20 -CL-MO exam-in pass didn’t ‘As many as 20 students didn’t pass the exam. ...|$|R
5000|$|A {{preprocessor}} procedure is a subroutine {{executed by the}} preprocessor. The procedure is delimited by [...] and [...] statements and can contain only preprocessor statements, without the leading [...] It is invoked as a function reference from open code, outside of any {{preprocessor procedure}}, or from another preprocessor procedure, and returns a [...] or [...] value. When the procedure is invoked from open code the arguments are passed by name, that is they are interpreted as character strings delimited by commas or a <b>right</b> <b>parenthesis,</b> all leading, trailing, or embedded blanks are significant and {{considered part of the}} argument.|$|E
5000|$|Most APL {{implementations}} {{support a}} number of system variables and functions, usually preceded by the ⎕ (quad) and or [...] ")" [...] (hook=close parenthesis) character. Particularly important and widely implemented is the ⎕IO (Index Origin) variable, since while the original IBM APL based its arrays on 1 some newer variants base them on zero:There are also system functions available to users for saving the current workspace e.g. [...] )SAVE and terminating the APL environment, e.g. [...] )OFF - sometimes called hook commands or functions due {{to the use of}} a leading <b>right</b> <b>parenthesis</b> or hook. [...] There is some standardization of these quad and hook functions.|$|E
5000|$|A smiley (sometimes simply {{called a}} happy face or smiling face) is a stylized {{representation}} of a smiling humanoid face that {{is a part of}} popular culture worldwide. The classic form designed by Harry Ball in 1963 comprises a yellow circle with two black dots representing eyes and a black arc representing the mouth (''''''). On the Internet and in other plain text communication channels, the emoticon form (sometimes also called the smiley-face emoticon) has traditionally been most popular, typically employing a colon and a <b>right</b> <b>parenthesis</b> to form sequences like '''''', '''''', or '''''' that resemble a smiling face when viewed after rotation through 90 degrees. [...] "Smiley" [...] is also sometimes used as a generic term for any emoticon. The smiley has been referenced in nearly all areas of Western culture including music, movies, and art. The smiley has also been associated with late 1980s and early 1990s rave culture.|$|E
5000|$|The 1403 chain or train {{contained}} 240 characters, however numerous duplications {{allowed a}} line to be printed in less than the 0.4 s required for one full rotation. The original standard [...] "A" [...] chain contained 48 different characters, repeated five times each. A [...] "preferred character set" [...] variant used in later models printed the same 48 characters, but varied the number of appearances: 10 digits appeared eight times each, 26 upper-case letters appeared four times each, and 12 special characters [...] appeared eight (first four), four (middle four) or two (last four characters) times each.Special chains or trains could be ordered for other character sets. Scientific users, for example, would use a chain that had the left parenthesis, the <b>right</b> <b>parenthesis,</b> and the plus sign {{in place of the}} per cent sign (%), the lozenge (⌑), and the ampersand (&). The numerics chain had 15 copies each of only 16 characters. The [...] "T" [...] chain for general text had two copies of 120 characters, including upper-and lower-case letters and numerous special symbols.|$|E
5000|$|This is also present, {{but less}} precisely, in the {{organization}} of digits and symbols in columns 2 (010) and 3 (011) - this discrepancy is the source of bit-paired layouts. Ideally the characters would have been ordered so that unshifted and shifted values of a typewriter key were in adjacent columns, allowing shifting to be implemented by toggling the 5th bit (1st high bit). Due to other concerns, this correspondence is inexact: for example, SP (Space) and 0 (zero) both have low bits 00000 (to ease collation for space and conversion to/from binary coded decimal for 0), preventing 0 from lining up with [...] ) (<b>right</b> <b>parenthesis),</b> its conventional value, and thus instead (...) corresponded to 89, instead of 90 as on typewriters. Further, while digits were placed in column 3, the characters ,-./ (conventionally unshifted) were placed in column 2, to ease collation, due to being used as separators, and the characters: (conventionally paired) were both placed in column 3. Other symbols also did not line up with their conventional digit pair, as detailed below.|$|E
40|$|Let T(n) be {{the set of}} all well-formed {{parentheses}} {{strings of}} length 2 n. We show that the elements of T(n) can be listed so that successive strings differ by the transposition of a left and a <b>right</b> <b>parenthesis.</b> Furthermore, between the two parentheses that are transposed, only left parentheses occur. Our listing is a modification of the well-known Eades-McKay [4] algorithm for generating combinations. Like that algorithm, ours generates strings from the lexicographically greatest string to the lexicographically least and can be implemented so that each string is generated in constant time, in an amortized sense. 1 Introduction Among the classes of strings studied by mathematicians and computer scientists, perhaps none has been examined so intensely as the class of well-formed parentheses strings. There is a natural correspondence, right parentheses to internal nodes and left parentheses to leaves, between these strings and extended binary trees. As a consequence, one representation is [...] ...|$|E
40|$|Abstract: The far-infrared {{spectrum}} of gaseous fluoromethyl methyl ether, FCH 2 OCH 3, {{along with three}} of the deuterium isotopes, has been recorded at a resolution of 0. 10 cm- 1 in the 350 to 50 cm- 1 region. The fundamental asymmetric torsional and methyl torsional modes are extensively mixed and have been observed at 182 and 132 cm- 1, respectively, for the stable gauche conformer with the lower frequency band having several excited states falling to lower frequency. An estimate is given for the potential function governing the asymmetric rotation. On {{the basis of a}} one-dimensional model the barrier to internal rotation of the methyl moiety is determined to be 527 +/- 9 cm- 1 (1. 51 +/- 0. 03 kcal/mol). A complete assignment of the vibrational fundamentals for all four isotopic species observed from the infrared (3500 to 50 cm- 1) spectra of the gas and solid and from the Raman (3200 to 10 cm- 1) spectra of the gas, liquid, and solid is proposed. No evidence could be found in any of the spectra for the high-energy trans conformer. All of these data are compared to the corresponding quantities obtained from ab initio Hartree-Fock gradient calculations employing the 3 - 21 G and 6 - 31 G* basis sets along with the 6 - 31 G* basis set with electron correlation at the MP 2 level. Additionally, complete r 0 geometries have been determined from the previously reported microwave data and carbon-hydrogen distances determined from infrared studies. The heavy-atom structural parameters (distances in angstrom, angles in degrees) are r(C 1 -F) = 1. 395 +/- 0. 005; r(C 1 - 0) = 1. 368 +/- 0. 007; r(C 2 -O) = 1. 426 +/- 0. 003; less than with <b>right</b> <b>parenthesis</b> through FC 1 O = 11 1. 33 = 0. 25; less than with <b>right</b> <b>parenthesis</b> through C 1 OC 2 = 113. 50 +/- 0. 18 and dih FC 1 OC 2 = 69. 12 +/- 0. 26. All of these results are discussed and compared with the corresponding quantities obtained for some similar molecules...|$|E
30|$|Srndic and Laskov [7] {{introduced}} PJScan, 20 {{a static}} analysis and anomaly detection {{tool for the}} detection of malicious JavaScript code inside a PDF file. After the JavaScript code has been found and extracted, a lexical analysis is applied using a JavaScript interpreter. Lexical analysis represents the JavaScript code as a sequence of tokens. For example, left parenthesis, plus, <b>right</b> <b>parenthesis,</b> etc. By using these tokens PJScan tries to induce learning detection models that differentiate between benign and malicious PDF files. Liu et al. [14] combined both static and dynamic analysis to detect potential infection attempts in the context of JavaScript execution. First, they extract a set of static features, and then they insert context monitoring code into a PDF document, a code that later cooperates with the runtime monitor used for the detection task. Additional work done by Corona et al. [15] in which they presented the Luxor system which applied this combination of static and dynamic analysis as well. Their idea involved translating the JavaScript code into an API reference pattern, and accumulating the times of presences for every API reference. By doing this they tried to find a discriminative set of references that characterizes malware code in order to automatically differentiate this code from benign code within PDF files.|$|E

