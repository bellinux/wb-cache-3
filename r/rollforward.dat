8|0|Public
50|$|SFAS No. 157, {{paragraph}} 32 requires {{two main}} types of disclosures - a Fair Value Balance Sheet and a Level 3 <b>Rollforward.</b>|$|E
50|$|The Level 3 <b>Rollforward</b> reconciles the Level 3 {{balances}} for {{assets and}} liabilities from the prior reporting period to the current reporting period. This reconciliation must include the total gains and losses (realized and unrealized) for the period, the purchase, sales, issuances, and settlements (net), the transfers in and/or out of Level 3. These components should reconcile the prior period’s balance to the current period’s balance.|$|E
50|$|Wang dialects of COBOL-74 and COBOL-85 have {{important}} {{places in the}} evolution of COBOL. Wang was among the first, if not the first, to integrate COBOL into environments built from the ground up to be interactive as well as batch. Wang also had a principal role in the COBOL standards bodies until the early 1990s. Wang extensions to COBOL involving record locking scope, rollback and <b>rollforward</b> recovery implemented at the file system level allowing transaction processing, and full interactive workstation screen I/O have often made it difficult to port Wang COBOL applications to other systems.|$|E
50|$|It is also {{possible}} to keep a separate journal of all modifications to a database management system. (sometimes called after images). This is not required for rollback of failed transactions but it is useful for updating the database management system {{in the event of}} a database failure, so some transaction-processing systems provide it. If the database management system fails entirely, it must be restored from the most recent back-up. The back-up will not reflect transactions committed since the back-up was made. However, once the database management system is restored, the journal of after images can be applied to the database (<b>rollforward)</b> to bring the database management system up to date. Any transactions in progress at the time of the failure can then be rolled back. The result is a database in a consistent, known state that includes the results of all transactions committed up to the moment of failure.|$|E
40|$|This paper {{presents}} {{a technique to}} solve the mutual exclusion problem for uniprocessors purely in software. The idea is to execute atomic sequences without any hardware protection and, in the rare case that the atomic sequence is interrupted, to <b>rollforward</b> {{to the end of}} the sequence. The main contribution of this paper is to discuss the OS-related issues of this technique and to demonstrate its practicality, both in terms of flexibility and performance. It proposes a purely software-based technique that achieves mutual exclusion without any memory-accesses. Experiments show that this technique has the potential to outperform equivalent hardware mechanisms...|$|E
40|$|Roll-forward {{checkpointing}} schemes [8][10] {{are developed}} {{in order to}} avoid rollback in the presence of independent faults and to increase the possibility that a task completes within a tight deadline. However, despite of the adoption of roll-forward recovery, these schemes are not necessarily appropriate for time-critical applications because interactions with the external environment and communications between processes must be deferred during checkpoint validation steps (typically, two checkpoint intervals) until the fault-free processors are identified. The deadlines on providing services may thus be violated. In this paper we present and discuss two alternative <b>rollforward</b> recovery schemes, especially for time-critical and interaction-intensive applications, that deliver correct, timely results even when checkpoint validation is required. Key Words [...] - Checkpoint validation, dynamic redundancy, fault tolerance, forward error recovery, real-time multiprocessor and distributed syste [...] ...|$|E
40|$|This paper {{presents}} {{a technique to}} solve the mutual exclusion problem for uniprocessors purely in software. The idea is to execute atomic sequences without any hardware protection and, in the rare case that the atomic sequence is interrupted, to <b>rollforward</b> {{to the end of}} the sequence. The main contribution of this paper is to discuss the OS-related issues of this technique and to demonstrate its practicality, both in terms of flexibility and performance. It proposes a purely software-based technique that achieves mutual exclusion without any memory-accesses. Experiments show that this technique has the potential to outperform equivalent hardware mechanisms. June 24, 1994 Department of Computer Science The University of Arizona Tucson, AZ 85721 1 This work supported in part by ARPA Contract DABT 63 - 91 -C- 0030, by Digital Equipment Corporation, and Hewlett-Packard. 1 Introduction Atomic sequences [...] -a sequence of instructions that needs to execute without interference [...] -are fundamental [...] ...|$|E
40|$|Technology scaling {{accompanied}} {{with higher}} operating frequencies {{and the ability}} to integrate more functionality in the same chip has been the driving force behind delivering higher performance computing systems at lower costs. Embedded computing systems, which have been riding the same wave of success, have evolved into complex architectures encompassing a high number of cores interconnected by an on-chip network (usually identified as Multiprocessor System-on-Chip). However these trends are hindered by issues that arise as technology scaling continues towards deep submicron scales. Firstly, growing complexity of these systems and the variability introduced by process technologies make it ever harder to perform a thorough optimization of the system at design time. Secondly, designers are faced with a reliability wall that emerges as age-related degradation reduces the lifetime of transistors, and as the probability of defects escaping post-manufacturing testing is increased. In this thesis, we take on these challenges within the context of streaming applications running in network-on-chip based parallel (not necessarily homogeneous) systems-on-chip that adopt the no-remote memory access model. In particular, this thesis tackles two main problems: (1) fault-aware online task remapping, (2) application-level self-adaptation for quality management. For the former, by viewing fault tolerance as a self-adaptation aspect, we adopt a cross-layer approach that aims at graceful performance degradation by addressing permanent faults in processing elements mostly at system-level, in particular by exploiting redundancy available in multi-core platforms. We propose an optimal solution based on an integer linear programming formulation (suitable for design time adoption) as well as heuristic-based solutions to be used at run-time. We assess the impact of our approach on the lifetime reliability. We propose two recovery schemes based on a checkpoint-and-rollback and a <b>rollforward</b> technique. For the latter, we propose two variants of a monitor-controller- adapter loop that adapts application-level parameters to meet performance goals. We demonstrate not only that fault tolerance and self-adaptivity can be achieved in embedded platforms, but also that it can be done without incurring large overheads. In addressing these problems, we present techniques which have been realized (depending on their characteristics) {{in the form of a}} design tool, a run-time library or a hardware core to be added to the basic architecture...|$|E

