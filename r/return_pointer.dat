9|91|Public
2500|$|The [...] "jump to register" [...] {{technique}} {{allows for}} reliable exploitation of stack buffer overflows {{without the need}} for extra room for a NOP-sled and without having to guess stack offsets. The strategy is to overwrite the <b>return</b> <b>pointer</b> with something that will cause the program to jump to a known pointer stored within a register which points to the controlled buffer and thus the shellcode. For example, if register A contains a pointer to the start of a buffer then any jump or call taking that register as an operand can be used to gain control of the flow of execution.|$|E
5000|$|Within {{the topic}} of stack buffer overflows, an often {{discussed}} but rarely seen architecture {{is one in which}} the stack grows in the opposite direction. This change in architecture is frequently suggested as a solution to the stack buffer overflow problem because any overflow of a stack buffer that occurs within the same stack frame can not overwrite the <b>return</b> <b>pointer.</b> Further investigation of this claimed protection finds it to be a naive solution at best. Any overflow that occurs in a buffer from a previous stack frame will still overwrite a <b>return</b> <b>pointer</b> and allow for malicious exploitation of the bug. For instance, in the example above, the <b>return</b> <b>pointer</b> for [...] will not be overwritten because the overflow actually occurs within the stack frame for [...] However, because the buffer that overflows during the call to [...] resides in a previous stack frame, the <b>return</b> <b>pointer</b> for [...] will have a numerically higher memory address than the buffer. This means that instead of the <b>return</b> <b>pointer</b> for [...] being overwritten, the <b>return</b> <b>pointer</b> for [...] will be overwritten. At most this means that growing the stack in the opposite direction will change some details of how stack buffer overflows are exploitable, but it will not reduce significantly the number of exploitable bugs.|$|E
50|$|Stack canaries, {{named for}} their analogy to a canary in a coal mine, {{are used to}} detect a stack buffer {{overflow}} before execution of malicious code can occur. This method works by placing a small integer, the value of which is randomly chosen at program start, in memory just before the stack <b>return</b> <b>pointer.</b> Most buffer overflows overwrite memory from lower to higher memory addresses, {{so in order to}} overwrite the <b>return</b> <b>pointer</b> (and thus take control of the process) the canary value must also be overwritten. This value is checked to make sure it has not changed before a routine uses the <b>return</b> <b>pointer</b> on the stack. This technique can greatly increase the difficulty of exploiting a stack buffer overflow because it forces the attacker to gain control of the instruction pointer by some non-traditional means such as corrupting other important variables on the stack.|$|E
5000|$|The new {{operator}} <b>returns</b> a <b>pointer</b> of {{type based}} on operand, whereas malloc <b>returns</b> a void <b>pointer.</b>|$|R
5000|$|If no [...] is installed, [...] instead throws an {{exception}} of type [...] Thus, the program {{does not need}} to check the value of the <b>returned</b> <b>pointer,</b> as is the habit in C; if no exception was thrown, the allocation succeeded.|$|R
5000|$|... func2 takes a pointer to a {{constant}} character array {{as well as}} an integer and <b>returns</b> a <b>pointer</b> to a character, and is assigned to a C string handling function which <b>returns</b> a <b>pointer</b> to the first occurrence of a given character in a character array.|$|R
50|$|In {{languages}} with pointers or references, {{one solution}} is to return a pointer to a value, rather than the value itself. This <b>return</b> <b>pointer</b> can then be set to null to indicate an error. This approach may cause some overhead, and it is typically suited to functions that return a pointer anyway.|$|E
50|$|The {{randomization}} of {{the stack}} base {{has an effect on}} payload delivery during shellcode and return-to-libc attacks. Shellcode attacks modify the <b>return</b> <b>pointer</b> field to the address of the payload; while return-to-libc attacks modify the stack frame pointer. In either case, the probability of success is diminished significantly; the position {{of the stack}} is unpredictable, and missing the payload likely causes the program to crash.|$|E
5000|$|In {{computer}} security, {{a register}} spring {{is a sort}} of trampoline. It is a bogus <b>return</b> <b>pointer</b> or Structured Exception Handling (SEH) pointer which an exploit places on the call stack, directing control flow to existing code (within a dynamic-link library (DLL) or the static program binary). This target code in turn consists of a call or jump such as [...] "CALL EBX" [...] or [...] "JMP ESP", where the appropriate processor register was previously prepared by the exploit to point to where the payload code begins.|$|E
5000|$|... char cff 55; /* {{array of}} arrays of chars */char *cfp 5; /* array of {{pointers}} to chars */char **cpp; /* pointer to pointer to char ("double pointer") */char (*cpf) 5; /* pointer to array(s) of chars */char *cpF (...) /* function which <b>returns</b> a <b>pointer</b> to char(s) */char (*CFp) (...) /* pointer to a function which returns a char */char (*cfpF (...) [...] )5; /* function which <b>returns</b> <b>pointer</b> to {{an array of}} chars */char (*cpFf5) (...) /* an array of pointers to functions which return a char */The (...) and [...] have a higher priority than *.|$|R
5000|$|Because of this problem, the POSIX {{documentation}} on [...] for the outdated issue 6 {{stated that}} [...] "a future version may either {{add a new}} function to <b>return</b> function <b>pointers,</b> or the current interface may be deprecated in favor of two new functions: one that <b>returns</b> data <b>pointers</b> and the other that returns function pointers".|$|R
5000|$|Checks if the <b>returned</b> object <b>pointer</b> {{is valid}} before {{performing}} any initialization.|$|R
50|$|It is {{possible}} to leak information about memory layout using format string vulnerabilities. Format string functions such as printf use a variable argument list to do their job; format specifiers describe what the argument list looks like. Because of the way arguments are typically passed, each format specifier moves closer {{to the top of}} the stack frame. Eventually, the <b>return</b> <b>pointer</b> and stack frame pointer can be extracted, revealing the address of a vulnerable library and the address of a known stack frame; this can completely eliminate library and stack randomization as an obstacle to an attacker.|$|E
5000|$|The [...] "jump to register" [...] {{technique}} {{allows for}} reliable exploitation of stack buffer overflows {{without the need}} for extra room for a NOP-sled and without having to guess stack offsets. The strategy is to overwrite the <b>return</b> <b>pointer</b> with something that will cause the program to jump to a known pointer stored within a register which points to the controlled buffer and thus the shellcode. For example, if register A contains a pointer to the start of a buffer then any jump or call taking that register as an operand can be used to gain control of the flow of execution.|$|E
40|$|Conventional {{security}} exploits {{have relied}} on overwriting the saved <b>return</b> <b>pointer</b> on the stack to hijack the path of execution. Under Sun Microsystem 's Sparc processor architecture, {{we were able to}} implement a kernel modification to transparently and automatically guard applications' return pointers. Our implementation called StackGhost under OpenBSD 2. 8 acts as a ghost in the machine. StackGhost advances exploit prevention in that it protects every application run on the system without their knowledge nor does it require their source or binary modification. We will document several of the methods devised to preserve the sanctity of the system and will explore the performance ramifications of StackGhost. ...|$|E
5000|$|As an example, {{consider}} a type that defines a pointer to a function that accepts pointers to struct types and <b>returns</b> a <b>pointer</b> to struct: ...|$|R
5000|$|Notice {{that the}} object pointed by an [...] is {{destroyed}} using this means that you should only use [...] for pointers obtained with [...] This excludes <b>pointers</b> <b>returned</b> by , and <b>pointers</b> to arrays (because arrays are allocated by [...] and must be deallocated by [...] ).|$|R
5000|$|The example C code below {{illustrates}} how structure objects are dynamically allocated and referenced. The standard C library provides the function [...] for allocating memory {{blocks from the}} heap. It takes {{the size of an}} object to allocate as a parameter and <b>returns</b> a <b>pointer</b> to a newly allocated block of memory suitable for storing the object, or it <b>returns</b> a null <b>pointer</b> if the allocation failed.|$|R
50|$|Note {{that each}} of a_stringn would have a 'char' data type while a_string itself would <b>return</b> a <b>pointer</b> to the first element in the a_string {{character}} array.|$|R
5000|$|A value (the error number) {{is stored}} in [...] by certain library {{functions}} when they detect errors. At program startup, the value stored is zero. Library functions store only values greater than zero. Any library function can alter the value stored before return, {{whether or not they}} detect errors. Most functions indicate that they detected an error by returning a special value, typically NULL for functions that <b>return</b> <b>pointers,</b> and &minus;1 for functions that return integers. A few functions require the caller to preset [...] to zero and test it afterwards to see if an error was detected.|$|R
50|$|Invented by Mike Frantzen, StackGhost is {{a simple}} tweak to the {{register}} window spill/fill routines which makes buffer overflows {{much more difficult to}} exploit. It uses a unique hardware feature of the Sun Microsystems SPARC architecture (that being: deferred on-stack in-frame register window spill/fill) to detect modifications of <b>return</b> <b>pointers</b> (a common way for an exploit to hijack execution paths) transparently, automatically protecting all applications without requiring binary or source modifications. The performance impact is negligible, less than one percent. The resulting gdb issues were resolved by Mark Kettenis two years later, allowing enabling of the feature. Following this event, the StackGhost code was integrated (and optimized) into OpenBSD/SPARC.|$|R
5000|$|... <b>returns</b> a void <b>pointer</b> (...) , which {{indicates}} {{that it is a}} pointer to a region of unknown data type. The use of casting is required in C++ due to the strong type system, whereas {{this is not the case}} in C. The lack of a specific <b>pointer</b> type <b>returned</b> from [...] is type-unsafe behaviour according to some programmers: [...] allocates based on byte count but not on type. This is different from the C++ new operator that <b>returns</b> a <b>pointer</b> whose type relies on the operand. (See C Type Safety.) ...|$|R
5000|$|A {{null pointer}} value {{explicitly}} points to no valid location. Dereferencing a null pointer value is undefined, often {{resulting in a}} segmentation fault. Null pointer values are useful for indicating special cases such as no [...] "next" [...] pointer in the final node of a linked list, or as an error indication from functions <b>returning</b> <b>pointers.</b> In appropriate contexts in source code, such as for assigning to a pointer variable, a null pointer constant can be written as , with or without explicit casting to a pointer type, or as the [...] macro defined by several standard headers. In conditional contexts, null pointer values evaluate to false, while all other pointer values evaluate to true.|$|R
50|$|In this example, malloc allocates {{memory and}} <b>returns</b> a <b>pointer</b> {{to the memory}} block. The size of the block {{allocated}} {{is equal to the}} number of bytes for a single object of type int multiplied by 10, providing space for ten integers.|$|R
5000|$|... fopen uses string flags such as , , [...] and [...] and <b>returns</b> a file <b>pointer</b> {{used with}} fgets, fputs and fclose.|$|R
2500|$|As LMDB is memory-mapped, it can <b>return</b> direct <b>pointers</b> {{to memory}} {{addresses}} of keys and values through its API, thereby avoiding unnecessary and expensive copying of memory. [...] This results in greatly-increased performance (especially when the values stored are extremely large), and expands the potential use cases for LMDB.|$|R
5000|$|The [...] and [...] {{functions}} {{are used to}} resolve host names and addresses in the domain name system or the local host's other resolver mechanisms (e.g., /etc/hosts lookup). They <b>return</b> a <b>pointer</b> to an object of type , which describes an Internet Protocol host. The functions take the following arguments: ...|$|R
50|$|The Binn {{format is}} {{designed}} to be compact and fast on readings. The elements are stored with their sizes to increase the read performance. The strings are null terminated so when read the library <b>returns</b> a <b>pointer</b> to them inside the buffer, avoiding memory allocation and data copying, an operation known as zero-copy.|$|R
5000|$|If a {{subroutine}} allocates {{an object}} and <b>returns</b> a <b>pointer</b> to it, the object {{can be accessed}} from undetermined places in the program [...] - [...] the pointer has [...] "escaped". Pointers can also escape if they are stored in global variables or other data structures that, in turn, escape the current procedure.|$|R
5000|$|When a {{function}} <b>returns</b> {{a function}} <b>pointer,</b> {{it can be}} even more confusing without typedef. The following is the function prototype of signal(3) from FreeBSD: ...|$|R
5000|$|In 1986, Anita <b>Pointer</b> <b>returned</b> to {{the country}} charts, scoring a number 2 C&W hit with Earl Thomas Conley on the duet, [...] "Too Many Times".|$|R
5000|$|... program ObjectPascalExample;type THelloWorld = class {{procedure}} Put; end;procedure THelloWorld.Put;begin Writeln('Hello, World!');end;var HelloWorld: THelloWorld; { this is {{an implicit}} pointer }begin HelloWorld := THelloWorld.Create; { constructor <b>returns</b> a <b>pointer</b> to an object of type THelloWorld } HelloWorld.Put; HelloWorld.Free; { this line deallocates the THelloWorld object pointed to by HelloWorld }end.Note that the object construct is still available in Delphi and Free Pascal.|$|R
50|$|<b>Return</b> {{instruction}} <b>pointers</b> {{are usually}} protected by stack canaries. A stack canary causes {{the program to}} crash if its value is modified by a buffer overrun. In the BROP model of attack, the buffer overrun is carried byte by byte. Each try at the overrun results either in program crash or continued execution. A program crash implies that the stack value was incorrectly guessed, therefore in 256 tries (average case is 128 tries) the stack value can be probably estimated. On 64 bit machines, 4 such stack reads {{would be required to}} leak the canary. Once the canary is leaked, the <b>return</b> instruction <b>pointer</b> can be perturbed in the same way. It may however be noted that though the estimation of the stack canary is exact, the same cannot be said about the return instruction address. The attacker would be satisfied to be able to leak any address within the text segment of the address space.|$|R
5000|$|The [...] method {{does not}} ensure zero-ing of the buffer, but does <b>return</b> the limit <b>pointer</b> {{to the upper}} {{boundary}} of the underlying array, and the position pointer to zero.|$|R
50|$|This insulates client code from object {{creation}} by having clients ask a factory object {{to create an}} object of the desired abstract type and to <b>return</b> an abstract <b>pointer</b> to the object.|$|R
5000|$|... /* Using the struct point type {{from before}} *//* Define a {{function}} that <b>returns</b> a <b>pointer</b> {{to the biggest}} point, using a function to do the comparison. */struct point *biggest_point (size_t size, struct point *points, struct point *(*point_compare) (struct point *a, struct point *b)){ int i; struct point *biggest = NULL; for (i=0; i < size; i++) { biggest = point_compare(biggest, points + i); } return biggest;} ...|$|R
