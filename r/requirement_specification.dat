626|3737|Public
25|$|The Royal Navy <b>requirement</b> (<b>Specification</b> HR.146) {{was for a}} Leonides Major-powered {{aircraft}} for a shipborne helicopter for anti-submarine, {{rescue and}} transport duties, Specification HR.149 was for a similar aircraft for the Royal Canadian Navy. The Royal Air Force issued specification H.150 for a general-purpose transport helicopter {{with the ability to}} lift bulky external loads. Bristol produced three designs, the Type 191 to meet the Royal Navy requirement, Type 192 for the Royal Air Force and the Type 193 to be built in Canada for the Royal Canadian Navy. In April 1956 orders were placed for 94 helicopters of all three types, prototypes with Leonides Major engines and production aircraft to use Napier Gazelle turboshafts.|$|E
2500|$|The Type 322 was {{designed}} by Supermarine to meet a 1937 <b>requirement</b> (<b>Specification</b> S.24/37) for a replacement for the British Royal Navy's Fairey Albacore biplane (even though the Albacore was yet to fly, with orders placed both with Supermarine, and with Fairey Aviation for what became the Barracuda. Supermarine's design was a high-wing monoplane, originally intended to be powered by the Rolls-Royce Exe engine. [...] Unusually it featured a variable-incidence wing, first demonstrated on the French Paul Scmitt biplane at the Paris Airshow in 1913.|$|E
2500|$|The second aircraft, the Bristol Type 75 was {{powered by}} the {{preferred}} Jupiter engine, which was mounted behind a fireproof bulkhead, with the entire engine installation (or [...] "power-egg") capable of being swung open like a gate to allow {{easy access to the}} rear of the engine. The Type 75 was designed to accommodate eight passengers and two crew. This aircraft, registered G-EBEV, first flew in July 1922. A third aircraft, the Bristol Type 79 was ordered by the Air Council to meet a <b>requirement</b> (<b>Specification</b> 32/22) for a single-engined ambulance landplane for the Royal Air Force. It was fitted with wings of greater chord, and had accommodation for three stretchers and an attendant or two stretchers and four sitting patients.|$|E
5000|$|EIRENE Functional <b>Requirements</b> <b>Specification</b> EIRENE System <b>Requirements</b> <b>Specification</b> ...|$|R
40|$|Abstract. Assuring {{the quality}} of {{software}} <b>requirement</b> <b>specifications</b> is critical. Poor <b>requirement</b> <b>specifications</b> may make costly errors during the development process. Therefore methods and techniques for verification and validation of software <b>requirement</b> <b>specifications</b> are fundamentally important. This survey presents taxonomy of verification and validation of <b>requirements</b> and <b>specifications</b> that represents the “flow ” from <b>requirements</b> to <b>specifications...</b>|$|R
50|$|<b>Requirements</b> <b>specification</b> - <b>Requirements</b> are {{documented}} {{in a formal}} artifact called <b>Requirements</b> <b>Specification</b> (RS). Nevertheless, it will become official only after validation. A RS can contain both written and graphical (models) information if necessary. Example: Software <b>requirements</b> <b>specification</b> (SRS).|$|R
5000|$|Functional <b>Requirement</b> <b>Specification</b> (FRS): the {{definition}} of higher lever functional requirements ...|$|E
5000|$|System <b>Requirement</b> <b>Specification</b> (SRS): the {{definition}} of the technical solutions supporting the functional requirements ...|$|E
50|$|A {{functional}} specification {{is closely related}} to the <b>requirement</b> <b>specification</b> and may show functional block diagrams.|$|E
40|$|It {{is shown}} how <b>specification</b> of {{behavioural}} <b>requirements</b> from informal to formal {{can be integrated}} within knowledge engineering. The integration of <b>requirements</b> <b>specification</b> has addressed, in particular: the integration of <b>requirements</b> acquisition and <b>specification</b> with ontology acquisition and specification, the relations between <b>requirements</b> <b>specifications</b> and specifications of task models and problem solving methods, and the relation of <b>requirements</b> <b>specification</b> to verification...|$|R
40|$|Requirements {{engineering}} {{in the new}} millennium is facing an increasing diversity of computerised devices comprising an increasing diversity of interaction styles for an increasing diversity of user groups. Thus the incorporation of user interface requirements into software <b>requirements</b> <b>specifications</b> becomes more and more mandatory. Validating these <b>requirements</b> <b>specifications</b> with hand-made, throw-away prototypes is not only expensive, but also bears the danger that validation results are not accurately fed back into the <b>requirements</b> <b>specification.</b> In this paper, we propose an enhancement of the <b>requirements</b> <b>specification</b> method SCORES for an explicit capturing of user interface requirements. The advantages of the approach are threefold. First, the user interface <b>requirements</b> <b>specification</b> is UML-compliant and integrated into the functional <b>requirements</b> <b>specification.</b> Second, prototypes for validation purposes can semi-automatically be generated. Third, the model-based generation of prototypes allows for ‘round-trip prototyping’ such that manual changes of the prototype during the validation process are automatically fed back into the <b>requirements</b> <b>specification.</b> ...|$|R
30|$|A way to {{validate}} a <b>requirements</b> <b>specification</b> should be shaped {{so that the}} users can validate the <b>requirements</b> <b>specification</b> sufficiently and intuitively because the users are not experts of a software development generally. User interface prototyping {{is one of the}} effective methods for validating the <b>requirements</b> <b>specification</b> by the users sufficiently.|$|R
50|$|A <b>requirement</b> <b>specification</b> {{is a set}} of {{documented}} {{requirements to}} be satisfied by a material, design, product, or service.|$|E
50|$|A {{task force}} of the Open Smart Grid Users Group {{published}} a systems <b>requirement</b> <b>specification</b> in 2008, which was revised in August 2010.|$|E
5000|$|... "Verification. The {{evaluation}} {{of whether or}} not a product, service, or system complies with a regulation, <b>requirement,</b> <b>specification,</b> or imposed condition. It is often an internal process. Contrast with validation." ...|$|E
40|$|In {{this paper}} it is shown how <b>specification</b> of {{behavioural}} <b>requirements</b> from informal to formal {{can be integrated}} within knowledge engineering. The integration of <b>requirements</b> <b>specification</b> has addressed, in particular: the integration of <b>requirements</b> acquisition and <b>specification</b> with ontology acquisition and specification, the relations between <b>requirements</b> <b>specifications</b> and specifications of task models and problem solving methods, and the relation of <b>requirements</b> <b>specification</b> to verification. © 2005 Elsevier B. V. All rights reserved...|$|R
40|$|The {{quality of}} a <b>requirements</b> <b>specification</b> has {{a great impact on}} the quality of the {{software}} developed. Because of this, a <b>requirements</b> <b>specification</b> should be complete, correct, consistent, and unambiguous. Otherwise, defects may remain undetected, resulting in the delivery of a faulty software product to the users. Motivated by this, Basili et al. have developed the perspective-based reading (PBR) technique to help identify defects in <b>requirements</b> <b>specifications.</b> In this paper we propose a problem-driven approach for supporting the PBR technique. We also discuss the experience of applying our proposal to a real-life <b>requirements</b> <b>specification.</b> published_or_final_versio...|$|R
50|$|A System <b>Requirements</b> <b>Specification</b> (abbreviated SyRS when {{need to be}} {{distinct}} from a Software <b>Requirements</b> <b>Specification</b> SRS) is a structured collection of information that embodies the requirements of a system.|$|R
5000|$|A (complete) {{specification}} freeze, {{in which}} the parties involved decide not to add any new <b>requirement,</b> <b>specification,</b> or feature to the feature list of a software project, so as to begin coding work.|$|E
50|$|A Software <b>Requirement</b> <b>Specification</b> {{document}} (SRS) {{might be}} created using a software tool as general as {{a word processor}} or a electronic spreadsheet; but, there are several specialized tools {{to carry out this}} activity.|$|E
50|$|Specification {{languages}} {{are generally not}} directly executed. They are meant to describe the what, not the how. Indeed, it is considered as an error if a <b>requirement</b> <b>specification</b> is cluttered with unnecessary implementation detail.|$|E
40|$|This paper {{argues that}} a user's manual makes an excellent, if not the best, {{software}} <b>requirements</b> <b>specification.</b> It discusses several lessons learned from experiences writing user's manuals as <b>requirements</b> <b>specifications.</b> Keywords: ambiguity, <b>requirements</b> analysis, requirements elicitation, requirements validation, <b>requirements,</b> scenarios, <b>specification,</b> test cases; use cases, user's manual...|$|R
40|$|In this paper, {{we report}} on the {{integration}} of informal, semiformal and formal <b>requirements</b> <b>specification</b> techniques. We present a framework for <b>requirements</b> <b>specification</b> called TRADE, within which several well-known semiformal specification techniques are placed. TRADE is based on an analysis of structured and object-oriented <b>requirements</b> <b>specification</b> methods. In this paper, we combine TRADE with the logicbased specification language Albert II and show that this leads to a coherent formal and semiformal <b>requirements</b> <b>specification.</b> We illustrate our approach with examples taken from a large distributed telecommunication application case study performed {{in the context of the}} Esprit project 2 RARE...|$|R
40|$|The {{result from}} Requirements Engineering is a <b>Requirements</b> <b>Specification.</b> Characteristics {{of a good}} <b>Requirements</b> <b>Specification</b> are unambiguity, completeness, verifiability, consistency, modifiability, traceability, {{correctness}} and ranked for importance and/or stability. This work defines these quality attributes and answers the questions how to reach these attributes and the diffuculties which exist in this area. This work should be read to get an overwiew of the area Requirements Engineering and <b>Requirements</b> <b>Specification...</b>|$|R
50|$|Gray-box {{testing is}} based on {{requirement}} test case generation because it presents all the conditions before the program is tested by using the assertion method. A <b>requirement</b> <b>specification</b> language is used {{to make it easy}} to understand the requirements and verify its correctness.|$|E
50|$|Because ETCS is in {{many parts}} {{implemented}} in software, some wording from software technology is occupied. Versions are called System <b>Requirement</b> <b>Specification</b> (SRS). This is a bundle of documents, which may have different versioning for each document. A main version is called Baseline (BL).|$|E
50|$|System {{testing is}} {{performed}} on the entire system {{in the context of}} a Functional Requirement Specification(s) (FRS) and/or a System <b>Requirement</b> <b>Specification</b> (SRS). System testing tests not only the design, but also the behaviour and even the believed expectations of the customer. It is also intended to test up to and beyond the bounds defined in the software/hardware requirements specification(s).|$|E
40|$|The new {{millennium}} opens with an increasing diversity of computerized devices comprising an increasing diversity of interaction styles used by an increasing diversity of user groups. Thus {{the incorporation of}} user interface requirements into software <b>requirements</b> <b>specifications</b> {{becomes more and more}} mandatory. Validating these <b>requirements</b> <b>specifications</b> with hand made, throw away prototypes is not only expensive, but also bears the danger that validation results are not sufficiently taken into account in the updated <b>requirements</b> <b>specification.</b> In this paper we propose an enhancement of a UMLbased <b>requirements</b> <b>specification</b> for an explicit capturing of user interface requirements. The advantages of the approach are twofold. First, presentation prototypes for validation purposes can semi-automatically be generated. Second, the model based construction of presentation prototypes allows for "round-trip prototyping" such that manual changes of the prototype during the validation process are automatically fed back into the <b>requirements</b> <b>specification...</b>|$|R
40|$|<b>Requirement</b> <b>Specifications</b> {{are very}} {{difficult}} to define. Due to lack of information and differences in interpretation, software engineers are faced with the necessity to redesign and iterate. This imperfection in software <b>requirement</b> <b>specifications</b> is commonly addressed by incremental design. In this paper, we advocate an approach where the imperfect <b>requirements</b> in <b>requirement</b> <b>specifications</b> are modeled by fuzzy sets. By supporting this approach with a requirement tracing and an optimization approach, the necessity for design iteration can be reduced...|$|R
40|$|In the (mechanical) design process, the <b>requirements</b> <b>specification</b> is {{a formal}} {{registration}} {{of the conditions}} that are imposed on a new or altered product design, both preceding as well as during the corresponding product development cycle. For a long time, the use of technical specifications has prevailed {{in the establishment of}} such <b>requirements</b> <b>specifications.</b> However, gradually, there is an appreciation for the fact that sheer technical specifications may inadvertently fix constraints and possibilities too early in the process. Moreover, it is recognized that technical specifications are unsuitable to adequately address the role of unquantifiable aspects that play important roles in the development cycle. Using functional specifications and scenarios respectively may aid in addressing these problems. Considering the importance of having an effective <b>requirements</b> <b>specification,</b> the coherence, synergy and specifics of technical specifications, functional specifications and scenarios as part of the <b>requirements</b> <b>specification</b> are addressed. This publication focuses on the different roles, limitations and added values of the constituents of the <b>requirements</b> <b>specification...</b>|$|R
50|$|Below is {{a sample}} use case written with a slightly-modified {{version of the}} Cockburn-style template. Note {{that there are no}} buttons, controls, forms, or any other UI {{elements}} and operations in the basic use case description, where only user goals, subgoals or intentions are expressed in every step of the basic flow or extensions. This practice makes the <b>requirement</b> <b>specification</b> clearer, and maximizes the flexibility of the design and implementations.|$|E
50|$|A {{product design}} {{specification}} (PDS) {{is a statement}} of how a design is made (specify the design), what {{it is intended to}} do, and how far it complies with the requirements. Requirements may be gathered in the Product <b>Requirement</b> <b>Specification</b> (PRS). Its aim is to ensure that the subsequent design and development of a product meets the needs (or requirements) of the user. Product design specification is one of the elements of product lifecycle management.|$|E
50|$|All teams {{must have}} one faculty member and can have student members from juniors and seniors. The first phase {{consists}} {{of developing a}} quality Software <b>Requirement</b> <b>Specification</b> document. In part the other considerations include technology, use of xml, quality code and design tools are given scores based upon the usage. The second phase considers the support of regional languages and portability issues of the software developed in part with functionality, User Interface and output.|$|E
50|$|A {{functional}} specification (also, functional spec, specs, {{functional specification}}s document (FSD), functional <b>requirements</b> <b>specification)</b> in systems engineering and software {{development is a}} document that specifies the functions that a system or component must perform (often part of a <b>requirements</b> <b>specification)</b> (ISO/IEC/IEEE 24765-2010).|$|R
40|$|Abstract. <b>Requirement</b> <b>Specifications</b> {{are very}} {{difficult}} to define concisely and unambiguously. Due to lack of information and differences in interpretation, software engineers are frequently faced with the necessity to redesign and iterate. The imperfection in software <b>requirement</b> <b>specifications</b> that causes these problems has lead to for example iterative approaches and incremental design. In this paper, we advocate an approach where the imperfect <b>requirements</b> in <b>requirement</b> <b>specifications</b> are modeled by fuzzy sets. By supporting this approach with a requirement tracing and optimization approach, the necessit...|$|R
40|$|Abstract. Developing new {{software}} based on <b>requirements</b> <b>specifications</b> created by business analysts {{often leads to}} misunderstanding and lack of comprehension, because of the different background of the involved persons. If the <b>requirements</b> <b>specifications</b> instead have a clearly defined structure and comprehensive semantics, this obstacle can be resolved. Therefore, we propose to structure the <b>requirements</b> <b>specifications</b> using existing linguistic modeling methods and annotate the used terms with ontologies {{in order to enhance}} the understanding and reuse of these documents during the whole software engineering process. 1...|$|R
