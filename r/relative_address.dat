21|180|Public
2500|$|Flow of control: JMP (jump), JSR (jump to subroutine), BSR (<b>relative</b> <b>address</b> jump to subroutine), RTS (return from subroutine), RTE (return from exception, i.e. an interrupt), TRAP (trigger a {{software}} exception similar to software interrupt), CHK (a conditional software exception) ...|$|E
5000|$|Starting sector = <b>relative</b> <b>address</b> of next EBR within {{extended}} partition ...|$|E
50|$|Unlike the 8080, the Z80 {{can jump}} to a <b>relative</b> <b>address</b> using a signed 8-bit displacement. Only the Zero and Carry flags {{can be tested}} for these new two-byte JR instructions.|$|E
40|$|The {{suitability}} of using <b>relative</b> <b>addressing</b> {{to help support}} the deployment of customized protocols or reduce the communication and processing overhead of signaling packets is explored. The basic approach consists of breaking the signaling used for routing into an addressing component and a routing component, and establishing virtual networks that use <b>relative</b> <b>addressing</b> and customized protocols within such networks. Specific examples of how routing update mechanisms can be expedited with <b>relative</b> <b>addressing</b> are presented. A specific approach to make AODV support address mappings for "virtual networks " is described. The performance of an ad hoc network running IPv 4 and an example customized protocol (called TIP) is discussed. Simulation results in GloMoSim illustrate that significant savings can be attained using <b>relative</b> <b>addressing</b> in scenarios with low bandwidth and traffic mostly composed of small packets, {{both of which are}} expected in ad hoc networks of sensors...|$|R
5000|$|Direct {{register}} and stack <b>relative</b> <b>addressing</b> provides capability for reentrant, recursive and re-locatable programming.|$|R
50|$|The key {{moment in}} the play occurs when a young <b>relative</b> <b>addresses</b> Rosita as Doña Rosita. This form of address signals her change of status.|$|R
5000|$|Flow of control: JMP (jump), JSR (jump to subroutine), BSR (<b>relative</b> <b>address</b> jump to subroutine), RTS (return from subroutine), RTE (return from exception, i.e. an interrupt), TRAP (trigger a {{software}} exception similar to software interrupt), CHK (a conditional software exception) ...|$|E
50|$|In simple layouts, {{programs}} {{begin their}} execution at the beginning, which {{is common in}} scripting languages, simple binary executable formats, and boot loaders. In other cases, the entry point is at some other fixed point, which is some memory address than can be an absolute address or <b>relative</b> <b>address</b> (offset).|$|E
5000|$|A {{computer}} program can access an address given explicitly - in low-level programming {{this is usually}} called an , or sometimes a specific address, and is known as pointer data type in higher-level languages. But a program can also use <b>relative</b> <b>address</b> which specifies a location in relation to somewhere else (the base address). There are many more [...] addressing modes.|$|E
50|$|Instruction <b>relative</b> <b>addressing</b> in 64-bit code (RIP + displacement, where RIP is the {{instruction}} pointer register) simplifies {{the implementation of}} position-independent code (as used in shared libraries in some operating systems).|$|R
50|$|Under the <b>relative</b> <b>addressing</b> scheme, {{to obtain}} an {{absolute}} address, the relevant base address is taken and offset (aka displacement) is added to it. Under this type of scheme, the base address is the lowest numbered address within a prescribed range, to facilitate adding related positive-valued offsets.|$|R
5000|$|Modified READ (MR) (<b>Relative</b> Element <b>Address</b> Designate), {{optional}} ...|$|R
50|$|In {{computer}} engineering and low-level programming (such as assembly language), an offset usually denotes {{the number of}} address locations added to a base address {{in order to get}} to a specific absolute address. In this (original) meaning of offset, only the basic address unit, usually the 8-bit byte, is used to specify the offset's size. In this context an offset is sometimes called a <b>relative</b> <b>address.</b>|$|E
50|$|This {{of course}} is not {{possible}} for distributed systems since an (absolute) address - in the caller's address space - is normally meaningless to the remote program (however, a <b>relative</b> <b>address</b> might in fact be usable if the receiver had an exact copy of, at least some of, the sender's memory in advance). Web browsers and web servers are examples of processes that communicate by message passing. A URL {{is an example of}} a way of referencing resources that does not depend on exposing the internals of a process.|$|E
5000|$|In IBM System/360 through {{present day}} z/Architecture, an address {{constant}} or [...] "adcon" [...] is an assembly language data type which contains {{the address of}} a location in computer memory. An address constant can be one, two, three or four bytes long, although an adcon of less than four bytes is conventionally used to hold expression for a small integer such as a length, a <b>relative</b> <b>address,</b> or an index value, and does not represent an address at all. Address constants are defined using an assembler language [...] "DC" [...] statement.|$|E
5000|$|<b>Relative</b> <b>addresses</b> are a form {{of manual}} memory segmentation, and share many of its {{advantages}} and disadvantages. A two-byte offset, containing a 16-bit, unsigned integer, {{can be used to}} provide <b>relative</b> <b>addressing</b> for up to 64 kilobytes of a data structure. This can easily be extended to 128K, 256K or 512K if the address pointed to is forced to be aligned on a half-word, word or double-word boundary (but, requiring an additional [...] "shift left" [...] bitwise operation—by 1, 2 or 3 bits—in order to adjust the offset by a factor of 2, 4 or 8, before its addition to the base address). Generally, though, such schemes are a lot of trouble, and for convenience to the programmer absolute addresses (and underlying that, a flat address space) is preferred.|$|R
50|$|Most operands {{can apply}} any of eight {{addressing}} modes to eight registers. The addressing modes provide register, immediate, absolute, relative, deferred (indirect), and indexed addressing, and can specify autoincrementation and autodecrementation of a register by one (byte instructions) or two (word instructions). Use of <b>relative</b> <b>addressing</b> lets a machine-language program be position-independent.|$|R
5000|$|An Entry Sequenced Data Set (ESDS) {{is a type}} of {{data set}} used by the VSAM {{computer}} data storage system. Records are accessed based on their sequential order, that is, the order in which they were written to the file; which means that accessing a particular record involves searching all the records sequentially until it is located, or by using a <b>relative</b> physical <b>address</b> (<b>Relative</b> byte <b>address,</b> RBA), i.e. the number of bytes {{from the beginning of the}} file to start reading.|$|R
5000|$|The ISA manual {{recommends}} that software be optimized to avoid branch stalls {{by using the}} default branch predictions. This reuses the most significant bit of the signed <b>relative</b> <b>address</b> as a [...] "hint bit" [...] to tell whether the conditional branch will be taken or not. So, no other hint bits are needed in the operation codes of RISC-V branches. This makes more bits available in the branch operation codes. Simple, inexpensive CPUs can merely follow the default predictions and still perform well with optimizing compilers. Compilers can still perform statistical path optimization, if desired.|$|E
5000|$|RISC-V's {{subroutine}} call [...] (jump and link) places its return address in a register. This is faster in many computer designs, because it saves a memory access compared to systems that push a return address directly on a stack in memory. [...] has a 20-bit signed (2's complement) offset. The offset is multiplied by 2, then {{added to the}} PC to generate a <b>relative</b> <b>address</b> to a 32-bit instruction. If the result is not at a 32-bit address (i.e. evenly divisible by 4), the CPU may force an exception.|$|E
50|$|When Unix was ported {{to one of}} {{the first}} DEC PDP-11/20s it did not have memory {{protection}} and, therefore, early versions of Unix used the relocatable memory reference model. Pre-Sixth Edition Unix versions read an executable file into memory and jumped to the first low memory address of the program, <b>relative</b> <b>address</b> zero. With the development of paged versions of Unix, a header was created to describe the executable image components. Also, a branch instruction was inserted as the first word of the header to skip the header and start the program. In this way a program could be run in the older relocatable memory reference (regular) mode or in paged mode. As more executable formats were developed, new constants were added by incrementing the branch offset.|$|E
50|$|It was {{probably}} the first minicomputer to feature floating-point equipment as standard, and had an unusually rich complement of registers for its time. It also featured <b>relative</b> <b>addressing,</b> and a fully automatic context switched interrupt system. It {{was also the first}} minicomputer to offer virtual memory, offered as an option by 1969. It was succeeded by the Nord-10.|$|R
5000|$|In addition, ZPAQ {{will use}} an E8E9 {{transform}} {{to improve the}} compression of x86 code typically found in [...]exe and [...]dll files. An E8E9 transform scans for CALL and JMP instructions (opcodes E8 and E9 hex) and replaces their <b>relative</b> <b>addresses</b> with absolute addresses. Then it inserts code into the PCOMP section to perform the inverse transform.|$|R
50|$|Virtual memory makes {{application}} programming {{easier by}} hiding fragmentation of physical memory; by delegating to the kernel {{the burden of}} managing the memory hierarchy (eliminating {{the need for the}} program to handle overlays explicitly); and, when each process is run in its own dedicated address space, by obviating the need to relocate program code or to access memory with <b>relative</b> <b>addressing.</b>|$|R
50|$|User {{programs}} {{are restricted to}} use only a contiguous area of main memory. The portion of memory to which an executing program has access {{is controlled by the}} RA (<b>Relative</b> <b>Address)</b> and FL (Field Length) registers which are not accessible to the user program. When a user program tries to read or write a word in central memory at address a, the processor will first verify that a is between 0 and FL-1. If it is, the processor accesses the word in central memory at address RA+a. This process is known as base-bound relocation; each user program sees core memory as a contiguous block words with length FL, starting with address 0; in fact the program may be anywhere in the physical memory. Using this technique, each user program can be moved ("relocated") in main memory by the operating system, as long as the RA register reflects its position in memory. A user program which attempts to access memory outside the allowed range (that is, with an address which is not less than FL) will trigger an interrupt, and will be terminated by the operating system. When this happens, the operating system may create a core dump which records the contents of the program's memory and registers in a file, allowing the developer of the program a means to know what happened. Note the distinction with virtual memory systems; in this case, the entirety of a process's addressable space must be in core memory, must be contiguous, and its size cannot be larger than the real memory capacity.|$|E
40|$|We {{introduce}} local {{environments for}} mobile processes, expressed in π-calculus. Each local name {{is equipped with}} its <b>relative</b> <b>address,</b> i. e., with the information needed to point back to the process that generated it. Relative addresses are built upon the labels of the proved transition system of π-calculus. A router is specified that guarantees sound exportation of names...|$|E
40|$|Abstract: This paper {{outlines}} {{a framework}} for connectionist representation based on the composition of connectionist states under vector space operators. The framework is used to specify a level of connectionist structure {{defined in terms of}} addressable superposition space hierarchies. Direct and <b>relative</b> <b>address</b> systems (:an be defined for such structures which use the functional components of linguistic structures as labels. Unbounded dependency phenomena are shown {{to be related to the}} different properties of these labelling structures...|$|E
50|$|The 8061 had a 240-byte {{internal}} register file, from address 0010H to 00FFH.I/O addresses {{were from}} 0002H to 000FH. Throughout the 8061 family, address 0000H {{was reserved for}} a constant ZERO register. This permitted use of <b>relative</b> <b>addressing</b> to access absolute addresses. The stack pointer was at 00010H.8061 could address 64K of memory.Reset was to 2000H.Interrupt vectors were at 2010H.|$|R
40|$|The {{concept for}} the {{generation}} of arbitrary permutations of d-dimensional data cubes in a multistage manner is presented. In particular, d-dimensional switching cubes are proposed, and the geometry of the ports of the switches and their locations within the switching cubes (d= 3, 4) are discussed. A new addressing scheme for the ports of these switches is presented, which is called the horizontal coding of addresses because the ports of the switches are distributed to the subsequently arranged arrays of the cube(s) in a horizontal manner. This addressing scheme permits any desired organization of the switches and the ports by reordering the absolute d-tuple addresses. This reordering is described by permutation matrices and explained by means of several examples. Within this <b>addressing</b> scheme <b>relative</b> <b>addresses</b> of the ports of the switches (which are {{a subset of the}} common absolute <b>addresses)</b> are introduced. <b>Relative</b> <b>addresses</b> offer an additional saving of hardware if applied within the concept of rearrangeability...|$|R
50|$|<b>Relative</b> track <b>addresses</b> {{are three}} byte {{fields in the}} form TTR. All subfields are binary numbers.|$|R
40|$|SHared MEMory library (SPMD model) � Library of {{functions}} similar to MPI (e. g. shmem_get()) Available for C / Fortran Used for programs that � perform computations in separate address spaces and � explicitly pass data {{to and from}} different processes in the program. The processes participating in shared memory applications {{are referred to as}} processing elements (PEs). Shmem routines supply remote data transfer, work-shared broadcast and reduction, barrier synchronization, and atomic memory operations. � Symmetric Variables � Arrays or variables that exist with the same size, type, and <b>relative</b> <b>address</b> on all PEs. � Data allocated and managed by shmem...|$|E
40|$|In {{order to}} {{recognize}} characters on the neat oracle bone rubbings, a new mesh point feature extraction algorithm was put forward {{in this paper}} by researching and improving of the existing coarse mesh feature extraction algorithm and the point feature extraction algorithm. Some improvements of this algorithm were as followings: point feature was introduced into the coarse mesh feature, the absolute address was converted to <b>relative</b> <b>address,</b> and point features have been changed grid and position relationship integrating into the feature vector. The recognition effect has been improved greatly using this algorithm to recognize oracle characters on the neat bone rubbings. At the same time, it could supply some help to recognize words of the neat handwriting instruments.  </p...|$|E
40|$|Existing {{techniques}} for injecting probes into running code are limited: they either fail to support probing arbitrary locations, or to support scalable, rapid toggling of probes. We {{introduce a new}} technique on x 86 - 64, called instruction punning, which allows scalable probes at any instruction. The key idea {{is that when we}} inject a jump instruction, the <b>relative</b> <b>address</b> of the jump serves simultaneously as data and as an instruction sequence. We show that this approach achieves probe invocation overheads of only a few dozen cycles, as well as low probe activation/deactivation costs, even when all threads in the system are both invoking probes and toggling them. Unlike competing systems, the latent overhead when probes are deactivated is exactly zero...|$|E
40|$|An assembly-language {{debug program}} {{written for the}} Honeywell HDC- 601 and DDP- 516 / 316 {{computers}} is described. Names and <b>relative</b> <b>addressing</b> to improve operator-machine interaction are used. Features include versatile display, on-line assembly, and improved program execution and analysis. The program is discussed from both a programmer's and an operator's standpoint. Functional diagrams are included to describe the program, and each command is illustrated...|$|R
50|$|BDAM accepts disk {{addresses}} {{as either}} actual device <b>addresses,</b> as <b>relative</b> track <b>addresses,</b> or as <b>relative</b> block numbers.|$|R
40|$|We {{present the}} design of a typed {{assembly}} language called TALT that supports heterogeneous tuples, disjoint sums, and a general account of addressing modes. TALT also implements the von Neumann model in which programs are stored in memory, and supports <b>relative</b> <b>addressing.</b> Type safety for execution and for garbage collection are shown by machine-checkable proofs. TALT is the first formalized typed assembly language to provide any of these features...|$|R
