1439|7931|Public
5|$|In May 2008, it was {{revealed}} that a Debian developer discovered that the OpenSSL package distributed with Debian and derivatives such as Ubuntu, made a variety of security keys vulnerable to a <b>random</b> <b>number</b> <b>generator</b> attack, since only 32,767 different keys were generated. The security weakness was caused by changes made in 2006 by another Debian developer in response to memory debugger warnings. The complete resolution procedure was cumbersome because patching the security hole was not enough; it involved regenerating all affected keys and certificates.|$|E
25|$|Proposed new {{random number}} {{generators}} are often {{compared to the}} RC4 <b>random</b> <b>number</b> <b>generator.</b>|$|E
25|$|The {{random number}} {{generators}} used by Alice and Bob must be trusted and truly random (for example a Quantum <b>random</b> <b>number</b> <b>generator).</b>|$|E
40|$|We {{present a}} {{computational}} scheme, GRIP (geometric random inner products), for testing {{the quality of}} <b>random</b> <b>number</b> <b>generators.</b> The GRIP formalism utilizes geometric probability techniques to calculate the average scalar products of random vectors distributed in geometric objects, such as circles and spheres. We show that these average scalar products define a family of geometric constants {{which can be used}} to evaluate the quality of <b>random</b> <b>number</b> <b>generators.</b> We explicitly apply the GRIP tests to several <b>random</b> <b>number</b> <b>generators</b> frequently used in Monte Carlo simulations, and demonstrate a statistical property for good <b>random</b> <b>number</b> <b>generators...</b>|$|R
5000|$|Most uniform <b>random</b> <b>number</b> <b>generators</b> {{are based}} on integer <b>random</b> <b>number</b> <b>generators</b> which return an integer in the range 232. A table of 2−32xi lets you use such numbers {{directly}} for U0.|$|R
40|$|We {{present a}} new {{computational}} scheme, GRIP (Geometric Random Inner Products), for testing {{the quality of}} <b>random</b> <b>number</b> <b>generators.</b> The GRIP formalism utilizes geometric probability techniques to calculate the average scalar products of random vectors generated in geometric objects, such as circles and spheres. We show that these average scalar products define a family of geometric constants {{which can be used}} to evaluate the quality of <b>random</b> <b>number</b> <b>generators.</b> We explicitly apply the GRIP tests to several <b>random</b> <b>number</b> <b>generators</b> frequently used in Monte Carlo simulations, and demonstrate a new statistical property for good <b>random</b> <b>number</b> <b>generators...</b>|$|R
25|$|It is also {{recently}} demonstrated that a degenerate OPO {{can be used}} as an all-optical quantum <b>random</b> <b>number</b> <b>generator</b> that does not require post processing.|$|E
25|$|A player starts by {{clearing}} the memory on their calculator. The player will {{then use the}} <b>random</b> <b>number</b> <b>generator</b> on their calculator to bring up a number between 0 and 1. The number of runs scored is the first digit after the decimal point (for example, if the <b>random</b> <b>number</b> <b>generator</b> provides 0.521, 5 runs are scored). Scoring is kept by using the memory addition function on the calculator, or by pen and paper. Scoring a 0 is considered out. The player who has the highest score wins.|$|E
25|$|Eddie Tipton, {{the former}} {{security}} {{director of the}} US Multi-State Lottery Association, installed software code to the Hot Lotto <b>random</b> <b>number</b> <b>generator</b> {{that allowed him to}} predict winning numbers on specific days of the year.|$|E
5000|$|John von Neumann was {{a pioneer}} in {{computer-based}} <b>random</b> <b>number</b> <b>generators.</b> In 1949, Derrick Henry Lehmer invented the linear congruential generator, which {{was for a long}} time used in most pseudorandom <b>number</b> <b>generators.</b> Today, most generators in use are based on linear recurrence (for instance, the Xorshift family). With the spread of the use of computers, algorithmic pseudorandom <b>number</b> <b>generators</b> replaced <b>random</b> <b>number</b> tables, and [...] "true" [...] <b>random</b> <b>number</b> <b>generators</b> (hardware <b>random</b> <b>number</b> <b>generators)</b> are used in only a few cases.|$|R
5000|$|The entropy pool can be {{improved}} by programs like , , [...] etc. With , hardware <b>random</b> <b>number</b> <b>generators</b> like Entropy Key, etc. can write to [...] The programs , [...] and [...] can test these <b>random</b> <b>number</b> <b>generators.</b>|$|R
5000|$|Computational and {{hardware}} <b>random</b> <b>number</b> <b>generators</b> are sometimes combined {{to reflect the}} benefits of both kinds. Computational <b>random</b> <b>number</b> <b>generators</b> can typically generate pseudo-random numbers much faster than physical generators, while physical generators can generate [...] "true randomness." ...|$|R
25|$|This section {{refers to}} 'traditional' draw style lotteries offered by Australian lottery organisations. In {{this type of}} game, a set number of tickets – {{typically}} in the low six figures – are offered for sale in each draw. A set of numbers are then drawn (these days by a <b>random</b> <b>number</b> <b>generator)</b> and are awarded prizes, with many consolation prizes often offered.|$|E
25|$|This {{is useful}} in {{computer}} science since most data structures have members with 2X possible values. For example, a byte has 256 (28) possible values (0–255). Therefore, to fill a byte or bytes with random values a <b>random</b> <b>number</b> <b>generator</b> which produces values 1–256 can be used, the byte taking the output value −nbsp&1. Very large Fermat primes are of particular interest in data encryption for this reason. This method produces only pseudorandom values as, after Pnbsp&−nbsp&1 repetitions, the sequence repeats. A poorly chosen multiplier can result in the sequence repeating sooner than Pnbsp&−nbsp&1.|$|E
25|$|The C++ {{standard}} {{consists of}} two parts: the core language and the standard library. C++ programmers expect the latter on every major implementation of C++; it includes vectors, lists, maps, algorithms (find, for_each, binary_search, random_shuffle, etc.), sets, queues, stacks, arrays, tuples, input/output facilities (iostream, for reading from and writing to the console and files), smart pointers for automatic memory management, regular expression support, multi-threading library, atomics support (allowing a variable to be read or written to by at most one thread at a time without any external synchronisation), time utilities (measurement, getting current time, etc.), a system for converting error reporting that doesn't use C++ exceptions into C++ exceptions, a <b>random</b> <b>number</b> <b>generator</b> and a slightly {{modified version of the}} C standard library (to make it comply with the C++ type system).|$|E
40|$|Project Specification This project {{concerns}} {{the field of}} vectorization for Computing in High Energy Physics at CERN,Geneva. This paper summarises the results and progress of vectorizing two newly proposed counter based <b>random</b> <b>number</b> <b>generators</b> on Intel’s Haswell Architecture. Abstract This project studies SIMD optimizing two different newly proposed <b>random</b> <b>number</b> <b>generators</b> on Intel’s Haswell architecture with AVX 2 instruction sets. AVX 2 instruction set is necessary since many <b>random</b> <b>number</b> <b>generators</b> rely on 64 -bit integer multiplication. In first phase, mathematical algorithms behind the <b>random</b> <b>number</b> <b>generators</b> are studied and the places {{where they can be}} vectorized are identified. Then all internal data structures of <b>random</b> <b>number</b> <b>generators</b> are transformed from Array of Struct to Struct of Array for better auto-vectorization. To achieve better results intrinsics are used via a high-level C++ wrapping library. In second phase we performed benchmarks and studied the speed up obtained up to 1. 57 times for Threefry CBRNG due to vectorization on Haswell...|$|R
40|$|Although the <b>random</b> <b>number</b> {{generation}} in a cryptographic {{system is a}} key element of the security chain, bibliography dealing with attacks on this part is not really wide. However, among the large number of attacks targeting cyphers, the ones exploiting electromagnetic side channel (in near field) could be very effective against <b>random</b> <b>number</b> <b>generators.</b> This presentation gives an insight on the first results of electromagnetic analysis performed on <b>random</b> <b>number</b> <b>generators.</b> The main idea is to evaluate if the tools elaborated to perform electromagnetic analysis on cyphers could be used on <b>random</b> <b>number</b> <b>generators,</b> too...|$|R
5000|$|Annex C: Approved <b>Random</b> <b>Number</b> <b>Generators</b> (Draft 01-04-2016) ...|$|R
25|$|Hacking attacks target {{vulnerabilities}} in {{the operation}} of a QKD protocol or deficiencies in the components of the physical devices used in construction of the QKD system. If the equipment used in quantum key distribution can be tampered with, it could be made to generate keys that were not secure using a <b>random</b> <b>number</b> <b>generator</b> attack. Another common class of attacks is the Trojan horse attack which does not require physical access to the endpoints: rather than attempt to read Alice and Bob's single photons, Eve sends a large pulse of light back to Alice in between transmitted photons. Alice's equipment reflects some of Eve's light, revealing the state of Alice's basis (e.g., a polarizer). This attack can be detected, e.g. by using a classical detector to check the non-legitimate signals (i.e. light from Eve) entering Alice's system. It is also conjectured that most hacking attacks can similarly be defeated by modifying the implementation, though there is no formal proof.|$|E
500|$|This {{probability}} {{can be used}} {{in conjunction}} with a <b>random</b> <b>number</b> <b>generator</b> to approximate [...] using a Monte Carlo approach.|$|E
500|$|On May 27, 2014, Perl 5.20 was released. Notable new {{features}} include subroutine signatures, hash slices/new slice syntax, postfix dereferencing (experimental), Unicode 6.3, rand (...) using consistent <b>random</b> <b>number</b> <b>generator.</b>|$|E
5000|$|<b>Random</b> <b>Number</b> <b>Generators</b> in both single- and {{double-precision}} ...|$|R
40|$|Several {{widely used}} uniform <b>random</b> <b>number</b> <b>generators</b> have been {{extensively}} subjected to three commonly used statistical tests of uniformity and randomness. The object was i) {{to examine the}} power of these statistical tests to discriminate between "good" and "bad" <b>random</b> <b>number</b> <b>generators,</b> ii) to correlate these results with recently proposed mathematical characterizations of <b>random</b> <b>number</b> <b>generators</b> which might also be useful in such a discrimination, and iii) to {{examine the effect of}} shuffling on the <b>random</b> <b>number</b> <b>generators.</b> Briefly the results show that the commonly used runs test has virtually no power to discriminate between "good" and "bad" generators, while serial tests perform better. Also shuffling does help, although much {{more needs to be done}} in this area. And finally, there is some utility to the mathematical characterizations, but many unanswered questions. [URL]...|$|R
40|$|<b>Random</b> <b>numbers</b> {{are needed}} {{in a variety of}} applications, yet finding good <b>random</b> <b>number</b> <b>generators</b> is a {{difficult}} task. In the last decade cellular automata (CA) have been used to generate <b>random</b> <b>numbers.</b> In this paper non-uniform CAs are studied, where each cell may contain a different rule, in contrast to the original, uniform model. We present the cellular programming algorithm for co-evolving non-uniform CAs to perform computations, and apply it to the evolution of <b>random</b> <b>number</b> <b>generators.</b> Our results suggest that good generators can be evolved; these exhibit behavior at least as good as that of previously described CAs, with notable advantages arising from the existence of a "tunable" algorithm for obtaining <b>random</b> <b>number</b> <b>generators.</b> Keywords: non-uniform cellular automata, <b>random</b> <b>number</b> <b>generators,</b> cellular programming, evolution, co-evolution, parallel computation, artificial life, complex systems. 1 Introduction <b>Random</b> <b>numbers</b> {{are needed in}} a variety of scientific, mathemat [...] ...|$|R
2500|$|Quantum <b>random</b> <b>number</b> <b>generator</b> {{with single}} photons as {{interactive}} experiment.|$|E
2500|$|Each player starts {{each round}} with several Dice {{of various sizes}} (maximum values), each {{represented}} {{by one or more}} physical “dice” (any <b>random</b> <b>number</b> <b>generator</b> with a uniform distribution from one to a given value), as specified by the numbers and letters on his fighter’s button.|$|E
2500|$|In {{computer}} simulations, {{especially in}} {{applications of the}} Monte-Carlo method, it is often desirable to generate values that are normally distributed. The algorithms listed below all generate the standard normal deviates, since a [...] can be generated as , where Z is standard normal. All these algorithms rely {{on the availability of}} a <b>random</b> <b>number</b> <b>generator</b> U capable of producing uniform random variates.|$|E
40|$|In this document, {{we define}} an {{object-oriented}} class structure for generating and testing <b>random</b> <b>number</b> <b>generators.</b> The structure {{is intended to}} provide a uniform, {{easy to use and}} easy to extend system for investigating <b>random</b> <b>number</b> <b>generators.</b> Implementations including a variety of generators and tests is available on the net...|$|R
40|$|An {{implementation}} of 32 and 64 bit parallel <b>random</b> <b>number</b> <b>generators</b> is presented. In the near future, 64 bit processors will be commonplace and parallel architectures will dominate the computing scene. These developments {{will lead to}} an increase in computing power, which will enable simulations of larger proportions, in particular those using <b>random</b> <b>number</b> <b>generators.</b> Longer periods, better randomness properties, and portability to different machines and architectures are needed for these generators to keep up with simulation demands. The combination of two linear congruential <b>random</b> <b>number</b> <b>generators,</b> used as a single generator, efficiently implemented in a language such as High Performance Fortran, is expected to meet these requirements. 1 Introduction Many computer simulations, for example, Monte Carlo simulations, use <b>random</b> <b>number</b> <b>generators.</b> However, according to Donald Knuth [1], "Random <b>number</b> <b>generators</b> should not be chosen at random", since there are not many high quality g [...] ...|$|R
40|$|<b>Random</b> <b>number</b> <b>generators</b> {{are used}} in many applications, from slot {{machines}} to simulations of nuclear reactors. For many computational science applications, such as Monte Carlo simulation, {{it is crucial that}} the generators have good randomness properties. This is particularly true for large-scale simulations done on high-performance parallel computers. Good <b>random</b> <b>number</b> <b>generators</b> are hard to find, and many widely-used techniques {{have been shown to be}} inadequate. Finding high-quality, efficient algorithms for <b>random</b> <b>number</b> generation on parallel computers is even more difficult. Here we present a review of the most commonly-used <b>random</b> <b>number</b> <b>generators</b> for parallel computers, and evaluate each generator based on theoretical knowledge and empirical tests. In conclusion, we provide recommendations for using <b>random</b> <b>number</b> <b>generators</b> on parallel computers. Outline This review is organized as follows: A brief summary of the findings of this review is first presented, giving an overview of th...|$|R
2500|$|If the {{probability}} density {{function of a}} random variable X is given as fX(x), it is possible (but often not necessary; see below) to calculate {{the probability}} density function of some variable [...] This is also called a “change of variable” and is in practice used to generate a random variable of arbitrary shape [...] using a known (for instance uniform) <b>random</b> <b>number</b> <b>generator.</b>|$|E
2500|$|Several {{operating}} systems include arc4random, an API originating in OpenBSD {{providing access to}} a <b>random</b> <b>number</b> <b>generator</b> originally based on RC4. In OpenBSD 5.5, released in May 2014, arc4random was modified to use ChaCha20. The implementations of arc4random in NetBSD and Linux's libbsd also use ChaCha20. In the 2017 release of its desktop and mobile {{operating systems}}, Apple replaced RC4 with AES in its implementation of arc4random. Man pages for the new arc4random include the backronym [...] "A Replacement Call for Random" [...] for ARC4 as a mnemonic, as it provides better random data than rand (...) does.|$|E
50|$|The <b>random</b> <b>number</b> <b>generator</b> is {{compliant}} with security and cryptographic standards such as NIST SP 800-90A, FIPS 140-2, and ANSI X9.82. Intel also requested Cryptography Research Inc. {{to review the}} <b>random</b> <b>number</b> <b>generator</b> in 1999 and 2012, which resulted in two published papers: The Intel <b>Random</b> <b>Number</b> <b>Generator</b> in 1999, and Analysis of Intel's Ivy Bridge Digital <b>Random</b> <b>Number</b> <b>Generator</b> in 2012.|$|E
40|$|We {{introduce}} {{the concept of}} canary numbers, {{to be used in}} health tests for true <b>random</b> <b>number</b> <b>generators.</b> Health tests are essential components of true <b>random</b> <b>number</b> <b>generators</b> because they are used to detect defects and failures of the entropy source. These tests need to be lightweight, low-latency and highly reliable. The proposed solution uses canary numbers which are an extra output of the entropy source of lower quality. This enables an early-warning attack detection before the output of the generator is compromised. We illustrate the idea with 2 case studies of true <b>random</b> <b>number</b> <b>generators</b> implemented on aXilinx Spartan- 6 FPGA...|$|R
40|$|Lasers are {{recently}} {{being used}} {{more frequently in}} <b>random</b> <b>number</b> <b>generators.</b> The world record in <b>random</b> <b>number</b> generation was broken by the help of lasers. The world's fastest quantum <b>random</b> <b>number</b> <b>generators</b> utilize lasers {{to tap into the}} random fluctuations in order to extract true random bit sequences. We investigate a system based on a Nd:YAG laser that potentially generates true random bits at Gbit/s rates. As photonic on chip technologies progress we foresee laser based high speed <b>random</b> <b>number</b> <b>generators</b> integrated on chips. Such a photonic chip will create a revolution in the technology of security devices that employ quantum cryptography techniques for secure communication...|$|R
50|$|Jitter of ring {{oscillators}} {{is commonly used}} in hardware <b>random</b> <b>number</b> <b>generators.</b>|$|R
