90|293|Public
25|$|When {{an outline}} font is used, a <b>rasterizing</b> routine (in the {{application}} software, operating system or printer) renders the character outlines, interpreting the vector instructions {{to decide which}} pixels should be black and which ones white. Rasterization is straightforward at high resolutions such as those used by laser printers and in high-end publishing systems. For computer screens, where each individual pixel {{can mean the difference}} between legible and illegible characters, some digital fonts use hinting algorithms to make readable bitmaps at small sizes.|$|E
25|$|New Media as Digital Data Controlled by Software The {{language}} of New Media {{is based on}} the assumption that, in fact, all cultural objects that rely on digital representation and computer-based delivery do share a number of common qualities. New media is reduced to digital data that can be manipulated by software as any other data. Now media operations can create several versions of the same object. An example is an image stored as matrix data which can be manipulated and altered according to the additional algorithms implemented, such as color inversion, gray-scaling, sharpening, <b>rasterizing,</b> etc.|$|E
25|$|The {{simplest}} {{method for}} scan converting (<b>rasterizing)</b> a Bézier curve is to evaluate it at many closely spaced points and scan convert the approximating sequence of line segments. However, {{this does not}} guarantee that the rasterized output looks sufficiently smooth, because the points may be spaced too far apart. Conversely it may generate too many points {{in areas where the}} curve is close to linear. A common adaptive method is recursive subdivision, in which a curve's control points are checked to see if the curve approximates a straight line to within a small tolerance. If not, the curve is subdivided parametrically into two segments, 0 ≤ t ≤ 0.5 and 0.5 ≤ t ≤ 1, and the same procedure is applied recursively to each half. There are also forward differencing methods, but great care must be taken to analyse error propagation.|$|E
5000|$|FreeType has {{replaced}} the code that scales and <b>rasterizes</b> fonts.|$|R
5000|$|The {{code that}} scales and <b>rasterizes</b> fonts uses open source FreeType ...|$|R
5000|$|Maya Hardware - {{a legacy}} GPU <b>rasterize</b> {{renderer}} in Maya 2017 or earlier.|$|R
2500|$|Metafont, not {{strictly}} part of TeX, is a font description system {{which allows the}} designer to describe characters algorithmically. It uses Bézier curves in a fairly standard way to generate the actual characters to be displayed, but Knuth devotes substantial attention to the <b>rasterizing</b> problem on bitmapped displays. Another thesis, by John Hobby, further explores this problem of digitizing [...] "brush trajectories". This term derives {{from the fact that}} Metafont describes characters as having been drawn by abstract brushes (and erasers). It is commonly believed that TeX is based on bitmap fonts but, in fact, these programs [...] "know" [...] nothing about the fonts that they are using other than their dimensions. It {{is the responsibility of the}} device driver to appropriately handle fonts of other types, including PostScript Type 1 and TrueType. Computer Modern (commonly known as [...] "the TeX font") is freely available in Type 1 format, as are the AMS math fonts. Users of TeX systems that output directly to PDF, such as pdfTeX, XeTeX, or LuaTeX, generally never use Metafont output at all.|$|E
50|$|Defining {{standardized}} events, and 2D <b>rasterizing</b> functions.|$|E
5000|$|... #Subtitle level 3: Calculation of bitmap fonts (<b>rasterizing</b> 1975) ...|$|E
40|$|Ray-tracing {{achieves}} impressive effects such as realistic {{reflections on}} complex surfaces {{but is also}} more computationally expensive than classic rasterization. <b>Rasterized</b> ray-tracing methods can accelerate ray-tracing {{by taking advantage of}} the massive parallelization available in the rasterization pipeline on the GPU. In this paper, we propose a selective <b>rasterized</b> raytracing method that optimizes the <b>rasterized</b> ray-tracing by selectively allocating computational resources to reflective regions in the image. Our experiments suggest that the method can speed-up the computation by up to 4 times and also reduce the memory footprint by almost 66 % without affecting the image quality. We demonstrate the effectiveness of our method using complex scenes and animations...|$|R
5000|$|Triangulated {{irregular}} network, a vector {{source for}} topography data, often <b>rasterized</b> as a (raster) digital elevation model.|$|R
50|$|Multiple signals {{processed}} {{in this way}} are lined up together and interpolated and <b>rasterized</b> into a readable image.|$|R
50|$|Depending on the {{hardware}} and software components and configurations, RIPs can experience problems <b>rasterizing</b> the image data contained in PostScript or PDF files. If there is a failure in <b>rasterizing</b> the image, it can be costly, as output systems (printers, plate-setters, etc.) consume expensive supplies, can require extensive amounts of time to process complex image data, and require skilled labor to operate.|$|E
5000|$|Digital {{differential}} analyzer (graphics algorithm), {{a simple and}} general method for <b>rasterizing</b> lines and triangles ...|$|E
50|$|Solid layers are {{generated}} by following a <b>rasterizing</b> motion where {{the roads are}} deposited side by side within an enveloping domain boundary.|$|E
30|$|The {{study area}} was <b>rasterized</b> into the {{smallest}} raster cells to be considered. A square covering Georgia was <b>rasterized</b> into 4096 x 4096 raster cells. The {{number of cells}} must be a power of two for the quadtree algorithm to work. Population data was then disaggregated to this raster. Population and employment were allocated proportionally to each cell based on the area percentage of the various intersecting zones.|$|R
40|$|An {{automated}} {{system has been}} developed to generate grid DTM data from a <b>rasterized</b> topographic map. Conventional methods used are based on either "raster-vector conversion " or "line following " and {{require a lot of}} manual input and computing time. The system developed here is based on automated recognition of color contour lines from a <b>rasterized</b> topographic map and automated tracing of the sectional heights of the recognized lines...|$|R
50|$|It is also {{possible}} {{to use the same}} concept to <b>rasterize</b> a parabola, ellipse, or any other two-dimensional curve.|$|R
50|$|Another Bitstream {{product is}} Font Fusion, a font <b>rasterizing</b> engine {{developed}} jointly with Type Solutions, Inc., which was later owned entirely by Bitstream.|$|E
50|$|The Bresenham {{algorithm}} can {{be interpreted}} as slightly modified digital differential analyzer (using 0.5 as error threshold instead of 0, which is required for non-overlapping polygon <b>rasterizing).</b>|$|E
50|$|Windows Presentation Foundation (formerly codenamed Avalon) in Windows Vista {{supports}} <b>rasterizing</b> OpenType CFF/Type 2 fonts, whereas Type 1 fonts {{will still}} be supported in GDI, but not in GDI+.|$|E
5000|$|The {{front cover}} {{image is a}} monochrome, heavily <b>rasterized</b> excerpt of the cover image on In Gorbachev We Trust.|$|R
50|$|In another variant, an ID buffer is <b>rasterized</b> in an {{intermediate}} step, allowing deferred shading {{of the resulting}} visible pixels.|$|R
5000|$|FurryBall - Advanced {{real-time}} GPU {{production quality}} final frame renderer using raytrace {{as well as}} <b>rasterize</b> - based on Nvidia OptiX ...|$|R
50|$|In {{computer}} graphics, {{the midpoint}} circle algorithm is an algorithm {{used to determine}} the points needed for <b>rasterizing</b> a circle. Bresenham's circle algorithm is derived from the midpoint circle algorithm. The algorithm can be generalized to conic sections.|$|E
50|$|Some {{software}} rasterizers use 'span buffering' (or 'coverage buffering'), {{in which}} a list of sorted, clipped spans are stored in scanline buckets. Primitives would be successively added to this datastructure, before <b>rasterizing</b> only the visible pixels in a final stage.|$|E
50|$|With {{this method}} it is, theoretically, {{possible}} {{to build an}} entire 3D engine (applying software <b>rasterizing)</b> using only one native function {{in the form of}} DrawPoint, with other functions being implemented as and when time permits. In practise this would be hopelessly slow, but it does demonstrate the possibilities for double-chance functions.|$|E
5000|$|Bitmap (<b>rasterized)</b> overlay {{graphics}} and text {{may be present}} in unused high bits of the pixel data or in a separate attribute (deprecated) ...|$|R
5000|$|... 1843: fax machine: a scanning, <b>rasterized,</b> digital {{replacement}} for the vectorized, analog telautograph."The Secret Life of the Fax Machine" [...] by Tim Hunkin ...|$|R
50|$|The Nintendo DS is {{the latest}} {{hardware}} to render 3D scenes in this manner, with the option of caching the <b>rasterized</b> images into VRAM.|$|R
50|$|XPS {{supports}} HD Photo images natively for raster images. The XPS format used in {{the spool}} file represents advanced graphics effects such as 3D images, glow effects, and gradients as Windows Presentation Foundation primitives, which printer drivers could offload their rasterization to the printer {{in order to reduce}} computational load if the printer is capable of <b>rasterizing</b> those primitives.|$|E
50|$|A similar {{principle}} is employed in tiled rendering (most famously the PowerVR 3D chip); that is, primitives {{are sorted into}} screen space, then rendered in fast on-chip memory, one tile at a time. The Dreamcast provided a mode for <b>rasterizing</b> one row of tiles at a time for direct raster scanout, saving {{the need for a}} complete framebuffer, somewhat in the spirit of hardware scanline rendering.|$|E
50|$|This article {{refers to}} doing the rendering-computation fast enough, {{so that the}} series of {{rendered}} images induce the illusion of movement in the human brain of the user. This illusion allows for the interaction with the software doing the calculations taking into account user input. The unit used for measuring the frame rate {{in a series of}} images is frames per second (fps). Different techniques for rendering exist, e.g. ray-tracing and <b>rasterizing.</b>|$|E
5000|$|Image file formats are {{standardized}} {{means of}} organizing and storing digital images. Image files {{are composed of}} digital data {{in one of these}} formats that can be <b>rasterized</b> for use on a computer display or printer. An image file format may store data in uncompressed, compressed, or vector formats. Once <b>rasterized,</b> an image becomes a grid of pixels, each of which has a number of bits to designate its color equal to the color depth of the device displaying it.|$|R
40|$|Misalignment {{between the}} color planes used to print color images creates {{undesirable}} artifacts in printed images. Color trapping {{is a technique}} used to diminish these artifacts. It consists of creating small overlaps between the color planes, either at the page description language level or the <b>rasterized</b> image level. Existing color trapping algorithms for <b>rasterized</b> images trap pixels independently. Once a pixel is trapped, the next pixel is processed without making use of the information already acquired. We propose a more efficient strategy which makes use of this information. Our strategy {{is based on the}} observation of some important properties of color edges. Combined with any existing algorithm for trapping <b>rasterized</b> images, this strategy significantly reduces its complexity. We implement this strategy in combination with a previously proposed color trapping algorithm (WBTA 08). Our numerical tests indicate an average reduction of close to 38...|$|R
40|$|Abstract. Localization is {{the process}} of {{determining}} the robot’s location within its environment. More precisely, it is a procedure which takes as input a geometric map, a current estimate of the robot’s pose, and sensor readings, and produces as output an improved estimate of the robot’s current pose (position and orientation). We describe a combinatorially precise algorithm which performs mobile robot localization using a geometric model of the world and a point-and-shoot ranging device. We also describe a <b>rasterized</b> version of this algorithm which we have implemented on a real mobile robot equipped with a laser rangefinder we designed. Both versions of the algorithm allow for uncertainty in the data returned by the range sensor. We also present experimental results for the <b>rasterized</b> algorithm, obtained using our mobile robots at Cornell. Key Words. Navigation, Mobile robots, <b>Rasterized</b> algorithms, Localization. 1. Introduction. Localizatio...|$|R
