62|224|Public
50|$|This {{similarity}} in form between Shannon's capacity and Hartley's law {{should not be}} interpreted to mean that M pulse levels can be literally sent without any confusion; more levels are needed, to allow for <b>redundant</b> <b>coding</b> and error correction, but the net data rate that can be approached with coding is equivalent to using that M in Hartley's law.|$|E
3000|$|... {{to denote}} {{the two new}} modes, respectively, with r {{standing}} for <b>redundant</b> <b>coding,</b> u representing the candidate QP value in the intra <b>redundant</b> <b>coding</b> and v representing the candidate QP value in the inter <b>redundant</b> <b>coding.</b> Therefore, for the HRMIR approach, the set of encoding options become [...]...|$|E
30|$|<b>Redundant</b> <b>coding</b> {{is another}} {{effective}} tool for robust video communication over lossy network. In [8], an optimal algorithm {{is presented to}} determined whether one picture needs redundant version. In [9], redundant slice is optimally allocated based on the slice position in the GOP, and the primary and redundant slices are then interleaved to generate two equal importance descriptions using the MDC [10] diagram. Whereas in [11], the two descriptions are generated by splitting the video pictures into two threads, and then redundant pictures are periodically inserted into the two threads. In both [8] and [11], <b>redundant</b> <b>coding</b> are optimized in frame level, namely all the macroblocks in one frame is encoded with the same <b>redundant</b> <b>coding</b> parameters, whereas for [9], redundant information is allocated in slice level. In [12], <b>redundant</b> <b>coding</b> is optimized in macroblock level. However, in order to optimally tune the redundancy, this approach needs all the motion vector information in one GOP, {{which leads to a}} delay of one GOP; consequently, this work cannot be applied in real-time applications, such as video conference.|$|E
50|$|The {{dead code}} {{elimination}} technique {{is in the}} same class of optimizations as unreachable <b>code</b> elimination and <b>redundant</b> <b>code</b> elimination.|$|R
5000|$|In {{computer}} programming, <b>redundant</b> <b>code</b> is {{source code}} or compiled code {{in a computer}} program that is unnecessary, such as: ...|$|R
40|$|In greedy parsing {{dictionary}} coders with deferred innovation ([2], certain phrases in {{the dictionary}} that are impossible to be matched during {{the next stage of}} parsing can be eliminated. We call this process as phrase elimination, and it is used with less <b>redundant</b> <b>codes</b> ([9] to achieve compression ratio improvement in this work. We provide theoretical estimate of the expected dictionary size after phrase elimination over a certain type of source. Experimental results suggest that 3 % improvement can be expected over LZW coders using less <b>redundant</b> <b>codes...</b>|$|R
3000|$|..., {{the total}} bit rate RMB(o) is {{calculated}} by summing up the bit rate used for both primary and <b>redundant</b> <b>coding.</b>|$|E
3000|$|... {{to denote}} the primary QP value of intra and inter coding, respectively. In the <b>redundant</b> <b>coding,</b> {{candidate}} QP value is u ∈ {u|QP [...]...|$|E
3000|$|... [...]. In the <b>{{redundant}}</b> <b>coding,</b> the redundant QP {{value is}} v, pixel i is predicted from pixel i + mv(v) {{in the previous}} frame, the prediction residual [...]...|$|E
50|$|The second iX*2 {{expression}} is <b>redundant</b> <b>code</b> {{and can be}} replaced by a reference to the variable iY. Alternatively, the definition int iY = iX*2 can instead be removed.|$|R
40|$|Partial {{redundancy}} elimination (PRE) subsumes {{the classical}} optimizations of loop invariant movement and common subexpression elimination. The original formulation of PRE involved complex bi-directional data flows {{and had two}} major deficiencies—missed optimization opportunities and <b>redundant</b> <b>code</b> movement. To eliminate <b>redundant</b> <b>code</b> movement, most current PRE approaches use a hoisting-followed-by-sinking approach. Unfortunately, this approach has a high conceptual complexity and requires complicated correctness proofs. We show that optimization by partial redundancy elimination is simpler {{than it has been}} made out to be. Its essence is the concept of eliminatability of an expression. We show that E-path PRE, a formulation of PRE based on the concept of eliminatability paths (E-paths), is easy to understand and simple to prove correct. It uses only well-known data flow concepts of available expressions and anticipatable (i. e. very-busy) expressions to directly identify code insertion points which avoid <b>redundant</b> <b>code</b> movement. These features reduce the conceptual complexity of PRE considerably. Interestingly, performance studies show that E-path PRE is also less expensive to perform than the closest equivalent approach to PRE. This is a sheer bonus...|$|R
50|$|Programming Languages {{and their}} Compilers by John Cocke and Jacob T. Schwartz, {{published}} early in 1970, devoted more than 200 pages to optimization algorithms. It included {{many of the}} now familiar techniques such as <b>redundant</b> <b>code</b> elimination and strength reduction.|$|R
30|$|In application, {{our results}} {{indicate}} that redundant visual signals {{are likely to be}} as effective at aiding visual detection under multi-task conditions as under single-task conditions. This means both that <b>redundant</b> <b>coding</b> will be useful within multi-task workspaces, and that the results of single-task pilot testing can be used to predict the magnitude of RT gain that redundant signals will purchase in a multi-task environment. Thus, design guidelines for complex visual workspaces, such as pilot cockpits or vehicle dashboards, should encourage the use of <b>redundant</b> <b>coding</b> of visual alerts for enhancing detection.|$|E
40|$|Abstract—The {{present study}} {{examined}} the efficacy of using audio cues for <b>redundant</b> <b>coding</b> of tactile key clicks simulated with a piezoelectric actuator. The tactile stimuli consisted of six raised cosine pulses at two levels of frequency and three levels of amplitude. An absolute identification experiment was conducted to measure the information transfers associated with the tactile-audio signal set. Results from Condition 1 (C 1) provided a baseline measure by employing only the tactile signals. In Conditions 2 - 4 (C 2 -C 4), supplemental audio signals were used to encode amplitude cues only, frequency cues only, and both amplitude and frequency cues, respectively. The results showed that partial <b>redundant</b> <b>coding</b> of tactile cues with audio signals could increase information transfer, when the cue (amplitude) was not perfectly identifiable with tactile signals alone (C 2). When the cue (frequency) was well perceived through tactile signals alone, audio supplemental cues did not improve performance (C 3). With <b>redundant</b> <b>coding</b> of both amplitude and frequency cues (C 4), audio signals dominated tactile signals. It was also found that increased information transfer was achieved {{at the cost of}} increased response time (C 2), suggesting increased mental load associated with the processing of multisensory information. Our findings have implications for the design of simulated key-click signals for mobile devices, and the use of multimodal signals for <b>redundant</b> <b>coding</b> of information in general. ...|$|E
40|$|Abstract-We {{consider}} asynchronous multiple accessing without feedback {{over the}} collision channel. <b>Redundant</b> <b>coding</b> {{is used to}} overcome user scribes the channel model and derives the capacity region. Section III analyzes the performance of block codes. Secinterference which causes erasures for collided packets. The channel has a sum capacity of e-I and a sum cutoff rate of 0. 295. The best codes areoses a convolutional coding and terleavg long constraint length rate 1 / 3 convolutional encoders which achieve a sum scheme, and computes the sum cutoff rate of the channel. throughput up to the sum cutoff rate using an easy-to-implement forward Section V generalizes Sections II and IV to the case when search decoding algorithm. In the presence of additive Gaussian noise, the the channel is corrupted by additive Gaussian noise; it same <b>redundant</b> <b>coding</b> can save, at hardly any extra cost, about 6 dB of shows that substantial power saving is gained, at hardly signal-to-noise ratio. any extra cost, by the <b>redundant</b> <b>coding</b> that was originally intended to correct erasures due to packet collisions. I...|$|E
5000|$|The above example {{contains}} some <b>redundant</b> <b>code</b> {{to do with}} the four attributes , , , and [...] It is possible to eliminate some of this redundancy using a metaclass. In Python, a metaclass is most easily defined as a subclass of [...]|$|R
40|$|Conventional {{collection}} libraries do {{not perform}} automatic collection-specific optimizations. Instead, performance-critical code using collections must be hand-optimized, leading to non-modular, brittle, and <b>redundant</b> <b>code.</b> We propose SQUOPT, the Scala Query Optimizer, a deep embedding of the Scala collection library performing collection-specific optimizations automatically without external tools or compiler extensions...|$|R
5000|$|A NOP {{instruction}} {{might be}} considered to be <b>redundant</b> <b>code</b> that has been explicitly inserted to pad out the instruction stream or introduce a time delay, for example to create a timing loop by [...] "wasting time". Identifiers that are declared, but never referenced, are termed redundant declarations.|$|R
30|$|In this paper, a novel Hybrid Redundant Macroblock and Intra {{macroblock}} Refreshment {{approach has}} been proposed to combat packet loss. In the proposed approach, <b>redundant</b> <b>coding</b> and/or intra coding are optimally allocated in macroblock level. Whether to use <b>redundant</b> <b>coding</b> and/or intra coding and the quantization parameter of the <b>redundant</b> <b>coding</b> is all determined in the end-to-end rate-distortion optimization procedure. It is worth mentioning that, in the proposed approach, only information from the previously encoded frames {{is used to calculate}} the end-to-end distortion in the RDO process; therefore, no additional delay is caused, making the proposed approach suitable for real-time applications such as video conference. Extensive experimental results show that the proposed method provides better performance than other error-resilient source coding approaches. The performance gap between the proposed approach and the Optimal Intra Refreshment is huge, and in some simulation environments, the proposed approach can provide 4 dB higher PSNR than the conventional Optimal Intra Refreshment with the same bitrate. Our future work is to calculate the end-to-end distortion in sub-pixel accuracy; therefore, more accurate end-to-end distortion would be available, which would eventually lead to better resource allocation.|$|E
40|$|A main {{obstacle}} for {{the experimental}} realization of a quantum computer is the unavoidable coupling of the qubits to external degrees of freedom and the decoherence caused in that way. A possible solution of this problem are error correcting codes. These, however, require <b>redundant</b> <b>coding</b> and, thus, a considerably higher algorithmic effort...|$|E
40|$|The {{possibility}} of finding redundancy gains with overlearned tasks was examined using a paradigm varying {{familiarity with the}} stimulus set. <b>Redundant</b> <b>coding</b> in a multidimensional stimulus was demonstrated to result in increased identification accuracy and decreased latency of identification when compared to stimuli varying on only one dimension. The advantages attributable to <b>redundant</b> <b>coding</b> {{are referred to as}} redundancy gain and were found for a variety of stimulus dimension combinations, including the use of hue or color as one of the dimensions. Factors that have affected redundancy gain include the discriminability of the levels of one stimulus dimension and the level of stimulus-to-response association. The results demonstrated that response time is in part a function of familiarity, but no effect of redundant color coding was demonstrated. Implications of research on coding in identification tasks for display design are discussed...|$|E
40|$|Long-term {{maintenance}} of code will {{often lead to}} the introduction of duplicated or 'cloned' code. Legacy systems riddled with these clones have large amounts of <b>redundant</b> <b>code</b> and are more difficult to understand and maintain. One option available to improve maintainability and to increase software reuse, is to re-engineer code clones into reusable components. However, before this can be achieved detection and removal of this <b>redundant</b> <b>code</b> is necessary. There are several established clone detection tools for software maintenance and this thesis aims to investigate the similarities between their output. It also looks at how maintainers may best use them {{to reduce the amount of}} <b>redundant</b> <b>code</b> in a software system. This will be achieved by running clone detection tools on several different case studies. Included in these case studies will be a novel tool called Covet inspired by research of Mayrand [May 96 b] which attempted to identify cloned routines through a comparison of software metrics generated from each routine. It was found that none of the clone detection tools achieved either 100 % precision or 100 % recall. Each tool identified very different sets of clones. Overall MOSS achieved the greatest precision and CCFinder the greatest recall. Also observed was that the use of automatically generated code increased the proportion of clones found in a software system...|$|R
40|$|We {{present some}} {{modifications}} to Morel and Renvoise's algorithm for global optimization by suppression of partial redundancies. The modifications {{are motivated by}} the desire to (1) eliminate <b>redundant</b> <b>code</b> motion, and (2) extend the scope of optimization to the movement of assignments. The complexity of the modified algorithm is compared with that of the original algorithm...|$|R
50|$|In 2009 Motorola {{created an}} updated version of EMML in order to {{co-ordinate}} it with other Internet standards, most notably CSS. There was a clear focus on simplifying the standard and reducing the amount of <b>redundant</b> <b>code.</b> In doing so, the number of bytes required to be downloaded was reduced and the readability of the language was vastly improved.|$|R
40|$|This {{proposal}} {{presents a}} new error robust strategy for encoding redundant pictures for the H. 264 /AVC standard. The method {{is based on}} providing motion vectors as redundant data, i. e. providing extra protection to the motion information of the encoded stream. The proposed system is implemented based on the existing <b>redundant</b> <b>coding</b> algorithm of the scalable extension of H. 264 /AVC. The performance of the algorithm is evaluated using various objective quality measurements under both error free and error prone Internet Protocol (IP) packet network environments. The proposed algorithm increases the bandwidth utilization with slight degradation in the primary picture quality for error free conditions, compared to the existing <b>redundant</b> <b>coding</b> method of JSVM (Joint Scalable Video Model). Furthermore, the simulation results under packet loss environments show that the proposed algorithm outperforms the existing redundant picture coding of JSVM. Index Terms — Redundant picture coding, Erro...|$|E
3000|$|In the HRMIR {{rate-distortion}} optimization procedure, {{in order}} to find the optimal QP value for <b>redundant</b> <b>coding,</b> we need to calculate the rate-distortion cost for all possible redundant QP value; therefore, the computation complexity is tremendous. For example, let us assume the primary QP value is 22, in the RDO procedure described in Section III-A, the encoding options are [...]...|$|E
40|$|Abstract — The motion {{information}} of an encoded video data stream plays {{a vital role}} in frame reconstruction, compared to its residual information. Hence, it is sensible to provide extra protection for the motion information. The proposed system is implemented based on the existing <b>redundant</b> <b>coding</b> algorithm of H. 264 /AVC and it provides extra protection only for the motion information. The paper analyzes the effect of proposed error resilience technique on enhancement layer picture quality. The performance of the algorithm is evaluated under both error free and error prone Internet Protocol(IP) packet network environments. The proposed algorithm increases the bandwidth utilization with slight degradation in the primary picture quality at error free conditions, compared to the existing <b>redundant</b> <b>coding</b> method of H. 264 /AVC standard. Furthermore, the simulation results show that the proposed algorithm outperforms the existing redundant picture coding technique of scalable extension of H. 264 /AVC standard, under packet loss environments. Keywords-component; H. 264; scalable video coding; error resilience; motion vectors I...|$|E
40|$|Many web {{applications}} use {{a mixture}} of HTML and scripting language code as the front-end to business services. Analogously to traditional applications, <b>redundant</b> <b>code</b> is introduced by copy-and-paste practices. Code duplication is a pathological form of software reuse because of its effects on the maintenance of large software systems. This paper describes how a simple semi-automated approach {{can be used to}} identity cloned functions within scripting code of web applications. The results obtained from applying our approach to three web applications show that the approach is useful for a fast selection of script function clones, and can be applied to prevent clone spreading or to remove <b>redundant</b> scripting <b>code.</b> 1...|$|R
40|$|Abstract—This paper {{proposes a}} novel error-correcting scheme for {{noncoherent}} chaos communications. By using the chaotic dynamics {{which is one}} of characteristics of chaos our pro-posed scheme is possible to operate the error-correcting without the physical <b>redundant</b> <b>code.</b> As results of computer simulations, we confirm about 1 – 2 dB gain in BER performance as compared with the conventional noncoherent chaos communications. I...|$|R
40|$|Abstract. Generics (templates) {{attempt to}} unify similar program {{structures}} to avoid explosion of <b>redundant</b> <b>code.</b> How well do generics serve this purpose in practice? We {{try to answer}} this question through empirical analysis from two case studies. First, we analyzed the Java Buffer library in which 68 % of the <b>code</b> was <b>redundant</b> due to cloning. We were able to remove only 40 % of the <b>redundant</b> <b>code</b> using the proposed Java generics. Unification failed because the variations between cloned classes were either non-type parametric or nonparametric. To analyze whether this problem is specific to Java generics, we investigated the C++ Standard Template Library (STL), an exemplary application of C++ templates, as our second case study. Even though C++ templates are more powerful, we still found substantial cloning. We believe that we are dealing with a fundamental phenomenon that will cause many other class libraries and application programs to suffer from the code redundancy problem. ...|$|R
40|$|Describes the {{interrelations between}} {{information}} theory and semiconductor {{technology in the}} different phases of their development with a special emphasis on their applications in telecommunication technology. The elements of information theory are outlined {{as well as its}} special subjects, i. e. source coding (data reduction) and channel coding (<b>redundant</b> <b>coding</b> for the error correction). The development of semiconductor technology is surveyed with particular emphasis on the LSI- and VLSI-technology...|$|E
40|$|H. 264 video coding {{standard}} introduces motion estimation with multiple block sizes {{to achieve a}} considerably higher coding efficiency than other video coding algorithms. However, this comes at the greatly increased computing complexity at the encoder. In this paper, a method is proposed to eliminate some <b>redundant</b> <b>coding</b> modes that contribute very little coding gain. The simulation {{results show that the}} algorithm can remarkably decrease the complexity at the encoder while keeping satisfying coding efficiency...|$|E
40|$|In {{a visual}} search task, {{subjects}} detected {{the presence of}} a target (long vertical line) among distractors that differed in length, orientation, or both. Distractors were designed to model the random variability found in naturalistic data by having them vary normally around the mean distractor. As predicted, adding variability to distractors eliminated popout by increasing reaction times and search function slopes, but <b>redundant</b> <b>coding</b> on two dimensions reduced search times and restored the popout effect...|$|E
40|$|Partial Redundancy Elimination (PRE) is {{a general}} scheme for suppressing partial {{redundancies}} which encompasses traditional optimizations like loop invariant <b>code</b> motion and <b>redundant</b> <b>code</b> elimination. In this paper we {{address the problem of}} performing this optimization interprocedurally. We use interprocedural partial redundancy elimination for placement of communication and communication preprocessing statements while compiling for distributed memory parallel machines. (Also cross-referenced as UMIACS-TR- 95 - 42...|$|R
5000|$|The {{sequence}} POP regs {{followed by}} PUSH {{for the same}} registers is generally redundant. In cases where it is redundant, a peephole optimization would remove these instructions. In the example, this would cause another redundant POP/PUSH pair {{to appear in the}} peephole, and these would be removed in turn. Removing all of the <b>redundant</b> <b>code</b> in the example above would eventually leave the following code: ...|$|R
40|$|<b>Redundant</b> source <b>code</b> hinders {{software}} maintenance, since updates have to {{be performed}} in multiple places. This holds independent of whether redundancy was created by copy&paste or by independent development of behav-iorally similar code. Existing clone detection tools success-fully discover syntactically similar <b>redundant</b> <b>code.</b> They thus work well for redundancy that has been created by copy&paste. But: how syntactically similar is behaviorally similar code of independent origin? This paper presents the results of a controlled experiment that demonstrates that be-haviorally similar code of independent origin is highly un-likely to be syntactically similar. In fact, it is so syntactically different, that existing clone detection approaches cannot identify more than 1 % of such redundancy. This is unfor...|$|R
