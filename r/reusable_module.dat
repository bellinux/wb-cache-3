11|222|Public
40|$|Reusability is an {{only one}} best {{direction}} to increase developing productivity and maintainability of application. One must first search for good tested software component and reusable. Developed Application software by one programmer {{can be shown}} useful for others also component. This is proving that code specifics to application requirements can be also reused in develop projects related with same requirements. The main aim of this paper proposed a way for <b>reusable</b> <b>module.</b> An process that takes source code as a input that will helped to take the decision approximately which particular software, reusable artefacts should be reused or not...|$|E
40|$|In this paper, {{we propose}} a {{programming}} language called NextEJ. NextEJ is a smooth combination of a role-based language EpsilonJ and context activation mechanisms provided by COP languages. It supports all {{the features of the}} Epsilon model such as dynamic object-role binding and unbinding, and encapsulation of collaboration of roles as a context that can be defined as a <b>reusable</b> <b>module.</b> Furthermore, NextEJ tackles typing problem of the Epsilon model by introducing the context activation scope inspired by COP languages. The key ideas described in this paper are formalized as a small core language FEJ that is built on top of FJ. FEJ’s type system is proven to be sound...|$|E
40|$|Reusability is one best {{direction}} to increase developing productivity and maintainability of application. We have to first search and focus upon the good tested software component and reusable. Application {{is being developed}} by one programmer can be reuse by other programmer. The data, design for the application and code of one project or application can be reused with the projects/applications having the same requirement. The objective of this paper proposed a way for <b>reusable</b> <b>module.</b> An process that takes source code as a input and helped us to take decision whether the particular code of one project can be reuse or not or how much part of the code we can reuse...|$|E
5000|$|The Hybrid-Driven Testing {{pattern is}} made up of a number of <b>reusable</b> <b>modules</b> / {{function}} libraries that are developed with the following characteristics in mind: ...|$|R
50|$|Buck is a build system {{developed}} {{and used by}} Facebook. It encourages the creation of small, <b>reusable</b> <b>modules</b> consisting of code and resources, and supports a variety of languages on many platforms.|$|R
40|$|International audienceOne of {{the design}} {{problems}} of B 2 C products results from their increasingly short lifespan. The technological changes, associated with the evolutions of use, lead the companies indeed to renew their ranges more and more early. This tendency generates waste more and more, while some components are thrown quickly they {{could be used in}} new generations of products; the remanufacturing appears of this fact as a promising solution. However, the remanufacturing can be economically and environmentally beneficial only if the product and its life cycle are designed by taking account of the value, the nature and lifespan of the modules to be re-used, and the lifespan of the product. This article proposes an approach of green design of <b>reusable</b> <b>modules</b> with environmental and economic evaluations covering Multiples Life Cycles (MLC). We introduce into this article the parameters of number of cycle, duration of cycle and the number of <b>reusable</b> <b>modules.</b> This approach was tested within the framework of a comparison of 3 espresso machines. This test made it possible to show that the product decomposition in module with MLC for <b>reusable</b> <b>modules</b> have a better environmental and economic performance...|$|R
40|$|The {{first step}} in a {{software}} reuse reengineering process is to analyze the structural characteristics of the existing software so as to produce software component sets, each of which is a candidate for clustering and reengineering into a <b>reusable</b> <b>module.</b> This step is founded on one or more candidature criteria and the cost of the following steps depends on their quality. The notions of completeness and adequacy as applied to candidature criteria are introduced, the need for an adequacy validation process before they are applied on a software system is outlined. An adequate validation process founded on the assignment of a concept to the candidate modules is proposed, and the results of an application of this process are described and discusse...|$|E
40|$|Pronominalization {{has been}} related {{to the idea of}} a local focus - a set of {{discourse}} entities in the speakcr's centre of attention, for example in Gundel et al. (1993) 's givenness hierarchy or in centering theory. Both accounts say that the determination of the tbcus depends on syntactic as well as pragmatic factors, but have not been able to pin those factors down. In this paper, we uncover the major factors which determine the focus set in descriptive texts. This new ibcus definition has been ewduated with re- spect to two corpora: lnUSeUlll exhibit labels, and newsimper articles. It provides an operationalizable basis for pronorm production, and has been implemented as the <b>reusable</b> <b>module</b> gnome-np. The algorithm behind gnome-np is compared with the most recent pronoun gener- ation algorithm of McCoy and Strube (1999) ...|$|E
40|$|A mixin is a <b>reusable</b> <b>module</b> that {{provides}} uniform extensions and modifications to classes. It is an abstract subclass that is composable {{with a variety}} of superclasses. In mixinbased composition, however, the problem of accidental overriding arises. A method declared in a mixin may accidentally overrides its superclasses ’ method. To tackle this problem, we propose a new approach of method lookup that allows selective method combination; that is, when we have multiple methods with the same name and the same formal parameter types in a composition, we can select which method to execute, and which method is called when there exists a method call to super. This proposal is an extension of hygienic mixins with stronger expressive power. This proposal is implemented in McJava, an extension of Java with mixintypes. Its compilation is achieved by source code translation to Java thus making it runnable on a standard Java virtual machine...|$|E
5000|$|<b>Reusable</b> Orbital <b>Module,</b> Booster, and Utility Shuttle (ROMBUS) ...|$|R
40|$|Complex {{security}} {{policies are}} difficult to specify, understand, and update. The {{same is true for}} complex software in general, but while many software-engineering tools exist for decomposing complex general software into simpler <b>reusable</b> <b>modules</b> (packages, classes, functions, aspects, etc.), few policyengineering tools exist for decomposing complex security policies into simpler <b>reusable</b> <b>modules.</b> The tools that do exist for modularizing policies either encapsulate entire policies as atomic, indecomposable modules or allow fine-grained modularization but are complicated and lack policy-visualization capabilities. This paper presents PoliSeer, the first tool we are aware of that allows policy engineers to specify, visualize, modify, and enforce complex policies as compositions of simpler policy modules. We describe the design and implementation of PoliSeer, as well as a case study in which we have bootstrapped PoliSeer by using it to specify and enforce a policy on itself. ...|$|R
40|$|The article {{describes}} the results of experimental researches of machining accuracy of shafts. The new construction of <b>reusable</b> base <b>module</b> is offered. The investigation was conducted on vertical- and horizontal milling machine tools. The level of accuracy of proposed <b>reusable</b> base <b>module</b> was determined. When you are citing the document, use the following link [URL]...|$|R
40|$|The {{development}} of a model for sub-system reuse and the evaluation of currently available rapid prototyping platforms has prompted the {{development of}} a GEneric <b>Reusable</b> <b>Module</b> (GERM). The GERM is a low-cost, stand-alone, reprogrammable development tool designed for prototyping reusable subsystems. The GERM, and associated templates, aid the designer in rapidly prototyping and reusing subsystem designs. The GERM addresses also the introduction of students to FPGA technology in an environment which they can continue to use for more complex designs. Extensions of the GERM include combining multiple GERMs together to prototype larger subsystems and systems. The reuse of subsystems has proven to be an effective method of rapidly prototyping systems in an academic environment. 1 Introduction Decomposition of a system into functional blocks, or subsystems, {{is one of the more}} common approaches used in managing designs of complex systems. By dividing a system into small functional blocks, mu [...] ...|$|E
40|$|A mixin is a <b>reusable</b> <b>module</b> that {{provides}} uniform extensions and modifications to classes. It is an abstract subclass that is composable {{with a variety}} of superclasses. In mixin-based composition, however, the problem of accidental overriding arises. A method declared in a mixin may accidentally override its superclass’s method. To tackle this problem, we propose a selective method combination that selects where the method invocation starts, and where method body execution jumps in the case of super invocation, by using the static type information of the receiver. We use the flexible mixin-based subtyping rules that allow subtype relations to be not restricted to the immediate inheritance relations; therefore, flexible control of method combination is achieved. To describe precisely how selective method combination works, we formalize this mechanism over McJava, an extension of Java with mixin-types. We also implement this mechanism by source code translation to Java thus making it runnable on a standard Java virtual machine. ...|$|E
40|$|Quality {{management}} in medical care cannot be just outcome-oriented, be-cause outcomes {{are not always}} measurable or reversible. An overall quality management system is required by companies and organisations offering med-ical care services. These overall quality management systems {{to improve the quality}} of medical care are supported by the establishment of monitoring and control systems using information technology. The objective of this work was the development of a <b>reusable</b> <b>module</b> for dynamically modifiable analyses of clinical patient data which facilitates han-dling analyses on a higher level of abstraction as plain SQL. Results of analyses should be visualised as customizable charts and tables. Java technology was used to develop the data analysis module. The module generates SQL statements out of an XML document representing the anal-ysis. The analysis result are visualised as charts using the charting library JFreeChart. The developed data analysis module named PatAn allows handling analyses on a higher level of abstraction as with plain SQL. Recurring analysis patterns were identified and integrated in the analysis structure to achieve modularity, reusability and faster development...|$|E
40|$|We are {{developing}} an astrophysical rotating plasma simulator, {{which consists of}} <b>reusable</b> <b>modules</b> plugged-in to a platform of a 3 -dimensional magnetohydrodynamical code. Modules incorporating magnetic di#usion, thermal conduction, radiative cooling, self-gravity, and so on, have been designed. We are also developing modules to visualize the numerical results. The code is parallelized and optimized for vector-parallel computers...|$|R
50|$|A test {{automation}} {{framework is}} an integrated system {{that sets the}} rules of automation of a specific product. This system integrates the function libraries, test data sources, object details and various <b>reusable</b> <b>modules.</b> These components act as small building blocks which need to be assembled to represent a business process. The framework provides the basis of test automation and simplifies the automation effort.|$|R
5000|$|Paul DiLascia died {{suddenly}} {{on the evening}} of September 3, 2008. He was only 49 years old at the time. Many present day C++ and MFC programmers still use his <b>reusable</b> <b>modules</b> and pieces of code containing his famous article/code comment: [...] "If this code works, it was written by Paul DiLascia. If not, I don't know who wrote it".|$|R
40|$|Design {{pattern is}} a <b>reusable</b> <b>module</b> {{to improve the}} problem and defines {{solution}} among all those methods techniques & algorithms to choose the best one then applies for our requirement. When designing a system or end product usually need to control how an object is used and prevent users from making copies of it or creating new instances. Design pattern are used in object oriented programming language, Dot Net, Java. Design pattern is simple research but it is innovative, to achieve our analysis for particular query in search engine, we are using design pattern to identify the solution in development. In this paper define a problem & solution using of design pattern our aim is to detect unwanted information in particular analysis and provide the relevant information, to retrieve the information from databases our solution may use the mining algorithm and design pattern {{in the development of}} our end product “Novel Design Pattern Mining”. This work improves the mining process and reduces the time and effort for developers...|$|E
40|$|This thesis {{presents}} an architecture for task independent autonomous flying vehicles. We review the conventional architectures {{such as the}} model-and-planner, behavior-based, and the subsumption architectures. We focus on their mechanism, their basic assumptions and their weaknesses. Based on the review, we propose the Strategic Architecture, an adaptive composition {{of a set of}} strategic multi-agents, which over-comes limitations of the existing architectures. In the Strategic Architecture, each strategy is designated to deal with a particular task and the composition of strategies tackles more complex tasks. The proposed Strategic Architecture maintains a uniform design for its low level control, high level planning, and multi-robot cooperative system thus facilitating the strategies' composition. This highly modular organization reduces the dependency between strategies and, hence, increases the reusability of strategies. Based on the Strategic Architecture, we have designed an autonomous system for model helicopter that takes the advantages of this new architecture. The design consists of well-organized layers of strategies tackling different subtasks using different algorithms, such as the two-dimensional land covering algorithm. The design, on the other hand, serves as an example that substantiates the concepts in the Strategic Architecture. This thesis has four components: the Strategic Architecture, an autonomous helicopter design, a 2 -dimensional land covering algorithm and the simulation. The Strategic Architecture is proposed to overcome the limitations and encompass the strengths of the existing architectures for autonomous system. The autonomous helicopter design shows how different strategies using different algorithms fit into the homogenous Strategic Architecture. Using the two-dimensional land covering task as an example, the autonomous model helicopter system is demonstrated to be applicable in the simulation. The simulation system examines the autonomous system before the autonomous system is built on the actual hardware. The contributions of this thesis are, first, a new Strategic Architecture with strengths in adaptive composition, hardware independence and with a highly <b>reusable</b> <b>module</b> design of strategies and, second, simulation that adequately substantiates these benefits. This research provides strong support for further exploration about automating real helicopters...|$|E
40|$|Abstract: Membrane {{computing}} is {{a formal}} framework of distributed parallel com-puting. In this paper we implement {{the work with}} the prefix tree by P systems with strings and active membranes. We present the algorithms of searching in a dictionary and updating it implemented as membrane systems. The systems are constructed as <b>reusable</b> <b>modules,</b> so they are suitable for using as sub-algorithms for solving more complicated problems...|$|R
50|$|In the 1960s, programmers built {{scientific}} subroutine libraries {{that were}} reusable {{in a broad}} array of engineering and scientific applications. Though these subroutine libraries reused well-defined algorithms in an effective manner, they had a limited domain of application. Commercial sites routinely created application programs from <b>reusable</b> <b>modules</b> written in assembly language, COBOL, PL/1 and other second- and third-generation languages using both system and user application libraries.|$|R
40|$|This paper {{describes}} a recovery technique called progressive retry for bypassing software faults in message-passing applications. The technique is implemented as <b>reusable</b> <b>modules</b> to provide application-level software fault tolerance. The paper describes {{the implementation of}} the technique and presents results from the application of progressive retry to two telecommunications systems. the results presented show that the technique is helpful in reducing the total recovery time for message-passing applications...|$|R
40|$|A major {{reengineering}} goal is software reuse. Effective reuse of knowledge, {{processes and}} products from previous software developments can reduce costs and increase both productivity and quality in software projects. This thesis extensively tests five projects {{produced by the}} graduate software engineering class at Ball State University. Each project has {{the same set of}} requirements. Each project is also analyzed based on subjective criteria, for example documentation, use of mnemonics for variable names and ease of understanding. Based on the outcome of testing and subjective analysis, reusable parts are identified. Metrics are collected on all of these projects. This thesis compares the metrics collected on the modules identified for reuse, and the same metrics collected on the non-reusable modules, to determine if there is a statistically significant difference in those metrics between the two groups. Metrics which are good predictors of <b>reusable</b> <b>modules</b> are identified. Metrics which are found to be good predictors of <b>reusable</b> <b>modules</b> include: number of in-parameters, number of data structure manipulations and central calls. Department of Computer ScienceThesis (M. S. ...|$|R
40|$|This paper {{describes}} {{work performed}} for the IDENT project which {{is concerned with}} the identification and encapsulation of <b>reusable</b> <b>modules.</b> The aim of the project {{is to look at the}} integration of two methods for supporting maintenance; RE 2 and RECAST. In this paper we describe a case study where we try to extract <b>reusable</b> <b>modules</b> from a 21, 000 line COBOL program. We approach this through the use of some of the basic methods addressed by the RE 2 reuse reengineering paradigm and some of the stages of the reverse engineering RECAST method. We have found that the identification of modules is very difficult because of high connectivity between data items. In order to deal with this problem we identify a number of strategies for removing particular data items using some of the RECAST stages and steps. These include the logical data model and system processing steps. However, in most cases we have found that such approaches were insufficient and that expert domain knowledge is also required [...] ...|$|R
40|$|We {{present the}} design and its' {{implementation}} for a flexible and robust parallel modular finite element (FEM) framework, called ModFem. The design is based on <b>reusable</b> <b>modules</b> which use narrow and well-defined interfaces to cooperate. At {{the top of the}} architecture there are problem dependent modules. Problem dependent modules can be additionally grouped together by "super-modules". This structure allows for applying the sequential codes to parallel environments and also support solving multi-physics and multi-scale problems...|$|R
40|$|This paper {{presents}} GePaRD, a novel {{approach to}} High-Level Synthesis of self-adaptive systems based on Partially Reconfigurable (PR) FPGAs. GePaRD combines Temporal Modularization and Temporal Placement {{in order to reduce}} the reconfiguration overhead at runtime by extracting Temporal <b>Reusable</b> <b>Modules.</b> We introduce the basics of High-Level PR design as well as the GePaRD design steps (transformations) and GePaRD descriptions (models). Moreover, we describe our approach to Temporal Modularization using Greedy Clique Partitioning and Temporal Placement using Simulated Annealing...|$|R
40|$|Software {{re-engineering}} and reusability are {{two areas}} of {{growing interest in}} the last years. However, while many researchers have focused their interest in the classification of <b>reusable</b> <b>modules</b> proposing meaningful examples of reusable components repositories and software packages libraries, the problem of potential reusable chunks searching and extracting is still opened. In this paper, after a brief discussion of the re-engineering issues, we examine the problems related {{to the difficulty of}} identifying various subfunctionality in a module and isolating them...|$|R
40|$|Abstract—Ensuring the {{correctness}} {{of high-level}} security prop-erties including access control policies in mission-critical ap-plications is indispensable. Recent literature has shown how immaturity of such properties has caused serious security vulnerabilities, which {{are likely to}} be exploited by malicious parties for compromising a given application. This situation gets aggravated by the fact that modern applications are mostly built on previously developed <b>reusable</b> software <b>modules</b> and any failures in security properties in these <b>reusable</b> <b>modules</b> may lead to vulnerabilities across associated applications. In this paper, we propose a framework to address this issue by adopting Design by Contract (DBC) features. Our framework accommodates security properties in each application focusing on access control requirements. We demonstrate how access control requirements based on ANSI RBAC standard model can be specified and verified at the source code level. Index Terms—security, access control, formal verification I...|$|R
500|$|Perl 5 added {{features}} that support complex data structures, first-class functions (that is, closures as values), and an object-oriented programming model. These include references, packages, class-based method dispatch, and lexically scoped variables, along with compiler directives (for example, the strict pragma). A major additional feature introduced with Perl 5 was {{the ability to}} package code as <b>reusable</b> <b>modules.</b> Wall later stated that [...] "The whole intent of Perl 5's module system was to encourage the growth of Perl culture rather than the Perl core." ...|$|R
40|$|Dynamically {{evolving}} {{a widely}} distributed service or application is a challenging systems design task. In this paper, we describe a plausible, high-level {{design for a}} common software framework that supports such extensible distributed services. Our design requires that the distributed service be implemented in an interpreted language, but our framework allows transparent and on-demand procedure instantiation at agents of the distributed service. In addition, this framework enables distributed services to be composed from <b>reusable</b> <b>modules,</b> and service sessions to be initiated from a single site...|$|R
50|$|LabRAD {{provides}} a platform to efficiently separate code into <b>reusable</b> <b>modules.</b> The modules {{communicate with each}} other over the network making the system inherently distributed. This strong separation allows each module to be independently maintained by a different developer. A well-specified interface allows other developers to easily use the available modules in their projects. The interface was designed to enable the addition of features to individual modules while maintaining backward compatibility. Developers can update modules to fit new functional requirements without compromising existing projects.|$|R
5000|$|Perl 5 added {{features}} that support complex data structures, first-class functions (that is, closures as values), and an object-oriented programming model. These include references, packages, class-based method dispatch, and lexically scoped variables, along with compiler directives (for example, the [...] pragma). A major additional feature introduced with Perl 5 was {{the ability to}} package code as <b>reusable</b> <b>modules.</b> Wall later stated that [...] "The whole intent of Perl 5's module system was to encourage the growth of Perl culture rather than the Perl core." ...|$|R
40|$|An {{attribute}} grammar is a declarative specification of dependence among computations {{carried out at}} the nodes of a tree. Attribute grammars have proven remarkably difficult to decompose into logical fragments. As a result, {{they have not yet}} been accepted as a viable specification technique. By combining the ideas of remote attribute access and inheritance, {{we have been able to}} define "attribution modules" that can be reused in a variety of applications. As an example, we show how to define <b>reusable</b> <b>modules</b> for name analysis that embody different scope rules...|$|R
40|$|AbstractDIEGO module systems offer {{means for}} Distributed {{programming}} with Encapsulated Graph Objects. Their operational semantics definition follows {{the lines of}} distributed graph transformation, thereby permitting the specification of distributed systems with concurrently interacting objects. Adapting previously made proposals for a graph grammar module concept and for graph models with information hiding to this setting, the new approach supports structuring of large specifications into small <b>reusable</b> <b>modules</b> with well-defined interfaces between them. Use relations between export interfaces and import interfaces are our means to construct system architectures and to allow reuse of modules in different environments...|$|R
40|$|Core based {{design has}} become the de-facto design style for many VLSI design houses, as it {{facilitates}} design reuse, import of specialized expertise from external vendors and leads to a more streamlined design flow. Pre-designed cores and <b>reusable</b> <b>modules</b> are popularly used {{in the design of}} large and complex Systems-on-a-Chip (SOC). Embedded cores such as processors, custom application-specific integrated circuits (ASIC), and memories are being used to provide SOC solutions to complex integrated circuit design problems. Traditional approaches for testing core-based SOCs completely rely on additional test structures such as boundary sca...|$|R
