954|2820|Public
25|$|Despite their simplicity, binary {{relations}} {{are at the}} core of an abstract computation model known as an abstract <b>rewriting</b> <b>system.</b>|$|E
25|$|A term <b>rewriting</b> <b>system</b> {{is said to}} be {{orthogonal}} if it is left-linear and is non-ambiguous. Orthogonal term rewriting {{systems are}} confluent.|$|E
2500|$|An L-system or Lindenmayer {{system is}} a {{parallel}} <b>rewriting</b> <b>system</b> and a type of formal grammar. An L-system consists of an alphabet of symbols {{that can be used}} to make strings, a collection of production rules that expand each symbol into some larger string of symbols, an initial [...] "axiom" [...] string from which to begin construction, and a mechanism for translating the generated strings into geometric structures. L-systems were introduced and developed in 1968 by Aristid Lindenmayer, a Hungarian theoretical biologist and botanist at the University of Utrecht. Lindenmayer used L-systems to describe the behaviour of plant cells and to model the growth processes of plant development. L-systems have also been used to model the morphology of a variety of organisms and can be used to generate self-similar fractals such as iterated function systems.|$|E
40|$|AbstractWe {{introduce}} {{the notion of}} the generalized semi-monadic <b>rewrite</b> <b>system,</b> which is a generalization of well-known rewrite systems: the ground <b>rewrite</b> <b>system,</b> the monadic <b>rewrite</b> <b>system,</b> and the semi-monadic <b>rewrite</b> <b>system.</b> We show that linear generalized semi-monadic <b>rewrite</b> <b>systems</b> effectively preserve recognizability. We show that a tree language L is recognizable if and only if there exists a <b>rewrite</b> <b>system</b> R such that R∪R− 1 is a linear generalized semi-monadic <b>rewrite</b> <b>system</b> and that L is the union of finitely many ↔R★-classes. We show several decidability and undecidability results on <b>rewrite</b> <b>systems</b> effectively preserving recognizability and on generalized semi-monadic <b>rewrite</b> <b>systems.</b> For example, we show that for a <b>rewrite</b> <b>system</b> R effectively preserving recognizability, it is decidable if R is locally confluent. Moreover, we show that preserving recognizability and effectively preserving recognizability are modular properties of linear collapse-free <b>rewrite</b> <b>systems.</b> Finally, as a consequence of our results on trees we get that restricted right-left overlapping string <b>rewrite</b> <b>systems</b> effectively preserve recognizability...|$|R
40|$|International audienceWe define {{different}} types of bottom-up tree pushdown automata and study their connections with <b>rewrite</b> <b>systems.</b> Along this line of research we complete and generalize the results of Gallier, Book and Salomaa. We define {{the notion of a}} tail-reduction-free (trf) <b>rewrite</b> <b>system.</b> Using the decidability of ground reducibility, we prove the decidability of the trf property. Monadic <b>rewrite</b> <b>systems</b> of Book, Gallier and Salomaa become a natural particular case of trf <b>rewrite</b> <b>systems.</b> We associate a deterministic bottom-up tree pushdown automaton with any left-linear trf <b>rewrite</b> <b>system.</b> Finally, we generalize monadic <b>rewrite</b> <b>systems</b> by introducing the notion of a semi-monadic <b>rewrite</b> <b>system</b> and show that, like a monadic <b>rewrite</b> <b>system,</b> it preserves recognizability...|$|R
40|$|International audienceStudying {{connections}} between term <b>rewrite</b> <b>systems</b> and bottom-up tree pushdown automata (tpda), we complete and generalize results of Gallier, Book and K. Salomaa. We define {{the notion of}} tail reduction free <b>rewrite</b> <b>systems</b> (trf <b>rewrite</b> <b>systems).</b> Using the decidability of inductive reducibility (Plaisted), we prove the decidability of the trf property. Monadic <b>rewrite</b> <b>systems</b> of Book, Gallier and K. Salomaa become an obvious particular case of trf <b>rewrite</b> <b>systems.</b> We define also semi-monadic <b>rewrite</b> <b>systems</b> which generalize monadic systems but keep their fair properties. We discuss different notions of bottom-up tree pushdown automata, {{that can be seen}} as the algorithmic aspect of classes of problems specified by trf <b>rewrite</b> <b>systems.</b> Especially, we associate a deterministic tpda with any left-linear trf <b>rewrite</b> <b>system...</b>|$|R
50|$|The {{critical}} pair lemma {{states that}} a term <b>rewriting</b> <b>system</b> is locally confluent (or weakly confluent) if {{and only if}} all its critical pairs are convergent. Furthermore, we have Newman's lemma which states that if an (abstract) <b>rewriting</b> <b>system</b> is strongly normalizing and weakly confluent, then the <b>rewriting</b> <b>system</b> is confluent. So, if we can add rules to the term <b>rewriting</b> <b>system</b> in order to force all critical pairs to be convergent while maintaining the strong normalizing property, then this will force the resultant <b>rewriting</b> <b>system</b> to be confluent.|$|E
50|$|If {{the term}} <b>rewriting</b> <b>system</b> is not confluent, the {{critical}} pair may not converge, so critical pairs are potential sources where confluence will fail. In fact, the critical pair lemma states that a term <b>rewriting</b> <b>system</b> is weakly (a.k.a. locally) confluent if all critical pairs are convergent. Thus, {{to find out}} if a term <b>rewriting</b> <b>system</b> is weakly confluent, it suffices to test all critical pairs and see if they are convergent. This makes it possible to find out algorithmically if a term <b>rewriting</b> <b>system</b> is weakly confluent or not, given that one can algorithmically check if two terms converge.|$|E
50|$|ARM {{implements}} {{general term}} rewriting, in that every single-sorted unconditional left-linear term <b>rewriting</b> <b>system</b> {{can be transformed}} (compiled) into a minimal term <b>rewriting</b> <b>system</b> that {{gives rise to the}} same normal form relation.|$|E
40|$|Abstract. Kamperman and Walters {{proposed}} {{the notion of}} a simulation of one <b>rewrite</b> <b>system</b> by another one, whereby each term of the simulating <b>rewrite</b> <b>system</b> is related to a term in the original <b>rewrite</b> <b>system.</b> In this paper it is shown that if such a simulation is sound and complete and preserves termination, then the transformation of the original into the simulating <b>rewrite</b> <b>system</b> constitutes a correct step in the compilation of the original <b>rewrite</b> <b>system.</b> That is, the normal forms of a term in the original <b>rewrite</b> <b>system</b> can then be obtained by computing the normal forms of a related term in the simulating <b>rewrite</b> <b>system.</b> ...|$|R
40|$|In this paper, we {{extend the}} notions of first-order {{conditional}} <b>rewrite</b> <b>systems</b> and higher-order <b>rewrite</b> <b>systems</b> to obtain higher-order conditional <b>rewriting.</b> Such <b>rewrite</b> <b>systems</b> {{can be used to}} directly express many operations in theorem proving and functional programming. We then illustrate that these <b>rewrite</b> <b>systems</b> can be naturally specified and implemented in a higher-order logic programming language. This paper was presented at the Third International Workshop on Extensions of Logic Programming, February 1992. 1 Introduction Higher-order <b>rewrite</b> <b>systems</b> extend first-order <b>rewrite</b> <b>systems</b> and provide a mechanism for reasoning about equality in languages that include notions of bound variables [1, 9, 12, 5]. First-order conditional <b>rewrite</b> <b>systems</b> extend firstorder <b>rewrite</b> <b>systems,</b> providing more expressive power by allowing conditions to be placed on rewrite rules [2, 8]. Such conditions must be satisfied before a particular rewrite can be applied. In this paper, we extend these [...] ...|$|R
40|$|AbstractA {{property}} of term <b>rewriting</b> <b>systems</b> is called modular {{if it is}} preserved under disjoint union. For unconditional term <b>rewriting</b> <b>systems</b> several modularity results are known. The aim {{of this paper is}} to analyze and extend these results to conditional term <b>rewriting</b> <b>systems.</b> It turns out that conditional term rewriting is much more complicated than unconditional rewriting from a modularity point of view. For instance, we show that the modularity of weak normalization for unconditional term <b>rewriting</b> <b>systems</b> does not extend to conditional term <b>rewriting</b> <b>systems.</b> On the positive side, we mention the extension of Toyama′s confluence result for disjoint unions of term <b>rewriting</b> <b>systems</b> to conditional term rewriting...|$|R
5000|$|A term <b>rewriting</b> <b>system</b> (TRS) is a <b>rewriting</b> <b>system</b> {{where the}} objects are terms, or {{expressions}} with nested sub-expressions. For example, the system shown under Logic above {{is a term}} <b>rewriting</b> <b>system.</b> The terms in this system are composed of binary operators [...] and [...] and the unary operator [...] Also present in the rules are variables,these each represent any possible term (though a single variable always represents the same term throughout a single rule).|$|E
5000|$|From the {{presentation}} of the monoid it is possible to define a <b>rewriting</b> <b>system</b> given by the relations R. If A x B is in R then either A < B in which case B → A is a rule in the <b>rewriting</b> <b>system,</b> otherwise A > B and A → B. Since < is a reduction order a given word W can be reduced W > W_1 > ... > W_n where W_n is irreducible under the <b>rewriting</b> <b>system.</b> However, depending on the rules that are applied at each Wi → Wi+1 it is possible to end up with two different irreducible reductions Wn ≠ W'm of W. However, if the <b>rewriting</b> <b>system</b> given by the relations is converted to a confluent <b>rewriting</b> <b>system</b> via the Knuth-Bendix algorithm, then all reductions are guaranteed to produce the same irreducible word, namely the normal form for that word.|$|E
50|$|As a {{mathematical}} object, an unlabeled transition system is identical with an (unindexed) abstract <b>rewriting</b> <b>system.</b> If {{we consider the}} rewriting relation as an indexed set of relations, as some authors do, then a labeled transition system is equivalent to an abstract <b>rewriting</b> <b>system</b> with the indices being the labels. The focus {{of the study and}} the terminology are different however. In a transition system one is interested in interpreting the labels as actions, whereas in an abstract <b>rewriting</b> <b>system</b> the focus is on how objects may be transformed (rewritten) into others.|$|E
40|$|Length-two string <b>rewriting</b> <b>systems</b> are length {{preserving}} string <b>rewriting</b> <b>systems</b> that {{consist of}} length-two rules. This paper shows that confluence, termination, left-most termination and right-most termination are undecidable properties for length-two string <b>rewriting</b> <b>systems.</b> This results mean that these properties are undecidable {{for the class}} of linear term <b>rewriting</b> <b>systems</b> in which depth-two variables are allowed in both-hand sides of rules. ...|$|R
40|$|Kamperman and Walters {{proposed}} {{the notion of}} a simulation of one <b>rewrite</b> <b>system</b> by another one, whereby each term of the simulating <b>rewrite</b> <b>system</b> is related to a term in the original <b>rewrite</b> <b>system.</b> In this paper it is shown that if such a simulation is sound and complete and preserves termination, then the transformation of the original into the simulating <b>rewrite</b> <b>system</b> constitutes a correct step in the compilation of the original <b>rewrite</b> <b>system.</b> That is, the normal forms of a term in the original <b>rewrite</b> <b>system</b> can then be obtained by computing the normal forms of a related term in the simulating <b>rewrite</b> <b>system.</b> 1 Introduction Questions on the correctness of compilation of programming languages date back to McCarthy [12]. In this paper we present a technique to deduce the correctness of compilation steps for functional programming languages which stay inside the domain of <b>rewrite</b> <b>systems.</b> Quite a number of papers deal with particular examples of transformations of rewrite syst [...] ...|$|R
40|$|Métivier (1983) {{proved that}} every {{confluent}} and terminating <b>rewrite</b> <b>system</b> {{can be transformed}} into an equivalent canonical <b>rewrite</b> <b>system.</b> He also proved that equivalent canonical <b>rewrite</b> <b>systems</b> which are compatible with the same reduction order are unique up to variable renaming. In this note we present simple and formalized proofs of these results. The latter result is generalized to the uniqueness of normalization equivalent reduced <b>rewrite</b> <b>systems.</b> ...|$|R
50|$|A <b>rewriting</b> <b>system</b> may be locally {{confluent}} {{without being}} (globally) confluent. Examples {{are shown in}} picture 3 and 4. However, Newman's lemma states that if a locally confluent <b>rewriting</b> <b>system</b> has no infinite reduction sequences (in which case {{it is said to}} be terminating or strongly normalizing), then it is globally confluent.|$|E
5000|$|... #Subtitle level 2: Classes of graph {{grammar and}} graph <b>rewriting</b> <b>system</b> ...|$|E
5000|$|As another example, {{consider}} the term <b>rewriting</b> <b>system</b> {{with the single}} rule ...|$|E
40|$|Commutativity is {{very useful}} in showing the Church-Rosser {{property}} {{for the union}} of term <b>rewriting</b> <b>systems.</b> This paper studies the critical pair technique for proving commutativity of term <b>rewriting</b> <b>systems.</b> Extending the concept of critical pairs between two term <b>rewriting</b> <b>systems,</b> a sufficient condition for commutativity is proposed. Using this condition, a new sufficient condition is offered for the Church-Rosser property of left-linear term <b>rewriting</b> <b>systems.</b> ...|$|R
40|$|AbstractIn {{the absence}} of termination, {{confluence}} of <b>rewriting</b> <b>systems</b> is often hard to establish. The class of orthogonal <b>rewriting</b> <b>systems</b> is the main class of not-necessarily-terminating, but confluent <b>rewriting</b> <b>systems.</b> The reason why confluence holds in orthogonal <b>rewriting</b> <b>systems</b> is {{the absence of}} the so-called critical pairs, making that rewrite steps never interfere (in a destructive way) with one another. We discuss some ways to adapt the confluence by orthogonality proof method to <b>rewriting</b> <b>systems</b> having ‘innocent’ critical pairs. Confluence results are obtained for lambda calculus with beta, eta and omega rules, lambda calculi with restricted expansion rules and for (first- and higher-order) term <b>rewriting</b> <b>systems</b> for which all critical pairs are development closed...|$|R
40|$|In {{this paper}} {{we present a}} new path order for <b>rewrite</b> <b>systems,</b> the {{exponential}} path order EPO*. Suppose a term <b>rewrite</b> <b>system</b> is compatible with EPO*, then the runtime complexity of this <b>rewrite</b> <b>system</b> is bounded from above by an exponential function. Furthermore, the class of function computed by a <b>rewrite</b> <b>system</b> compatible with EPO* equals the class of functions computable in exponential time on a Turing machine...|$|R
5000|$|A string <b>rewriting</b> <b>system</b> or semi-Thue {{system is}} a tuple [...] where ...|$|E
5000|$|For example, {{consider}} the term <b>rewriting</b> <b>system</b> {{defined by the}} reduction rules ...|$|E
5000|$|In an {{abstract}} <b>rewriting</b> <b>system</b> a normal form is an irreducible object.|$|E
40|$|This paper {{describes}} {{an extension of}} head-needed rewriting on term <b>rewriting</b> <b>systems</b> to higher-order <b>rewrite</b> <b>systems.</b> The main difficulty of this extension {{is caused by the}} fi-reductions induced from the higher-order reductions. In order to overcome this difficulty, we define a new descendant of higher-order <b>rewrite</b> <b>systems.</b> This paper shows the new definition of descendant, its properties and head normalization of head-needed rewriting on orthogonal higher-order <b>rewrite</b> <b>systems...</b>|$|R
40|$|The paper {{presents}} a new schematization of infinite families of terms called the primal grammars, {{based on the}} notion of primitive recursive <b>rewrite</b> <b>systems.</b> This schematization is presented by a generating term and a canonical <b>rewrite</b> <b>system.</b> It is proved that the class of primal grammars covers completely the class of crossed <b>rewrite</b> <b>systems.</b> This proof contains a construction of a primal grammar from a crossed <b>rewrite</b> <b>system...</b>|$|R
40|$|AbstractThe aim of {{this paper}} is to propose an {{algorithm}} to decide the confluence of finite ground term <b>rewrite</b> <b>systems.</b> Actually a more general class of possibly infinite ground term <b>rewrite</b> <b>systems</b> is studied. It is well known that the confluence is not decidable for general term <b>rewrite</b> <b>systems,</b> but this paper proves it is for ground term <b>rewrite</b> <b>systems</b> following a conjecture made by Huet and Oppen in their survey. The result is also applied to the confluence of left-linear and right-ground term <b>rewrite</b> <b>systems.</b> We also sketch an algorithm for checking this property. This algorithm is based on tree automata and tree transducers. Here, we regard them as <b>rewrite</b> <b>systems</b> and specialists in automata theory would translate that easily in their language...|$|R
5000|$|Conversely, {{for every}} {{terminating}} term <b>rewriting</b> <b>system,</b> the transitive closure of (::=) is a reduction ordering, which needn't be extendable to a ground-total one, however. For example, the ground term <b>rewriting</b> <b>system</b> { f(a)::=f(b), g(b)::=g(a) } is terminating, {{but can be}} shown so using a reduction ordering only if the constants a and b are incomparable.|$|E
5000|$|EMorF a graph <b>rewriting</b> <b>system</b> {{based on}} EMF, {{supporting}} in-place and model-to-model transformation ...|$|E
5000|$|Critical pair (term rewriting), terms {{resulting}} from two overlapping rules in a term <b>rewriting</b> <b>system</b> ...|$|E
5000|$|Minimal term <b>rewriting</b> <b>systems</b> are left-linear term <b>rewriting</b> <b>systems</b> {{in which}} each rule takes on one of six forms: ...|$|R
40|$|AbstractWe study {{rewriting}} {{of ground}} terms. For an arbitrary term <b>rewrite</b> <b>system</b> R over a ranked alphabet Σ, we restrict the rewriting relation →R to ground terms. We introduce the relation →R,g=→R∩(TΣ×TΣ). We show that ↔R,g∗=↔R∗∩(TΣ×TΣ). We show {{that for a}} given term <b>rewrite</b> <b>system</b> R and a given ground term <b>rewrite</b> <b>system</b> S over a ranked alphabet Σ it is decidable if ↔R,g∗⊆↔S∗. We show that for a given left-linear right-ground term <b>rewrite</b> <b>system</b> R over a ranked alphabet Σ it is decidable {{if there is a}} ground term <b>rewrite</b> <b>system</b> S over Σ such that →R,g∗=→S∗...|$|R
40|$|In this paper, we {{extend the}} notions of rst-order {{conditional}} <b>rewrite</b> <b>systems</b> and higher-order <b>rewrite</b> <b>systems</b> to obtain higher-order conditional <b>rewriting.</b> Such <b>rewrite</b> <b>systems</b> {{can be used to}} directly express many operations in theo-rem proving and functional programming. We then illustrate that these <b>rewrite</b> <b>systems</b> can be naturally specied and implemented in a higher-order logic pro-gramming language. This paper was presented at the Third International Work-shop on Extensions of Logic Programming, February 1992. ...|$|R
