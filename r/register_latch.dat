2|25|Public
40|$|Error {{correcting}} coding is {{the dominant}} technique to achieve acceptable soft-error rates in memory arrays. In many modern circuits, the number of memory elements in the random logic is {{in the order of}} the number of SRAM cells on chips only a few years ago. Often latches are clock gated and have to retain their states during longer periods. Moreover, miniaturization has led to elevated susceptibility of the memory elements and further increases the need for protection. This paper presents a fault-tolerant <b>register</b> <b>latch</b> organization that is able to detect single-bit errors while it is clock gated. With active clock, single and multiple errors are detected. The registers can be efficiently integrated similar to the scan design flow, and error detecting or locating information can be collected at module level. The resulting structure can be efficiently reused for offline and general online testing...|$|E
40|$|Abstract—In {{many modern}} circuits, {{the number of}} memory {{elements}} in the random logic is {{in the order of}} the number of SRAM cells on chips only a few years ago. In arrays, error cor-recting coding is the dominant technique to achieve acceptable soft-error rates. For low power applications, often latches are clock gated and have to retain their states during longer peri-ods while miniaturization has led to elevated susceptibility and further increases the need for protection. This paper presents a fault-tolerant <b>register</b> <b>latch</b> organiza-tion that is able to detect single-bit errors while it is clock gated. With small addition, single and multiple errors are detected in the clocked mode, too. The registers can be efficiently integrated similar to the scan design flow, and error detecting or locat-ing information can be collected at module level. The resulting structure can be efficiently reused for offline and general online testing. I...|$|E
50|$|There is one 16-bit {{accumulator}} register, and single-bit <b>registers</b> (<b>latches)</b> for addition {{carry and}} system halt.|$|R
50|$|Even in {{very simple}} systems, {{at various times}} the data bus {{is driven by the}} program memory, by RAM, and by I/O devices.To prevent bus {{contention}} on the data bus, at any one instant only one device drives the data bus.In very simple systems, only the data bus is required to be a bidirectional bus.In very simple systems, the memory address register always drives the address bus, the control unit always drives the control bus,and an address decoder selects which particular device is allowed to drive the data bus during this bus cycle.In very simple systems, every instruction cycle starts with a READ memory cycle where program memory drives the instruction onto the data bus while the instruction <b>register</b> <b>latches</b> that instruction from the data bus.Some instructions continue with a WRITE memory cycle where the memory data register drives data onto the data bus into the chosen RAM or I/O device.Other instructions continue with another READ memory cycle where the chosen RAM, program memory, or I/O device drives data onto the data bus while the memory data <b>register</b> <b>latches</b> that data from the data bus.|$|R
40|$|International audienceMicrocircuits {{dedicated}} to security in smartcards are targeted by {{more and more}} sophisticated attacks like fault attacks that combine physical disturbance and cryptanalysis. The use of simulation for circuit validation considering these attacks {{is limited by the}} time needed to compute the result of the chosen fault injections. Usually, this choice is made by the user according to his knowledge of the circuit functionality. The aim {{of this paper is to}} propose a generic and semi-automatic method to reduce the number of fault injections using types of data stored in <b>registers</b> (<b>latch</b> by latch...|$|R
50|$|The {{technique}} uses a {{directed graph}} where the vertices represent asynchronous combinational blocks and the directed edges represent {{a series of}} <b>registers</b> or <b>latches</b> (the number of <b>registers</b> or <b>latches</b> can be zero). Each vertex has a value corresponding to the delay through the combinational circuit it represents. After doing this, one can attempt to optimize the circuit by pushing registers from output to input and vice versa - much like bubble pushing. Two operations can be used - deleting a register from each input of a vertex while adding a register to all outputs, and conversely adding a register to each input of vertex and deleting a register from all outputs. In all cases, if the rules are followed, the circuit {{will have the same}} functional behavior as it did before retiming.|$|R
40|$|The main aim is {{to reduce}} area and power by {{replacing}} pulsed latches with dual edge latch. The average power, static power and dynamic power are reduced by dual edge latch. Dual edge latch is combined with inverter coupling circuit. It has MN 1 and MN 2 as 2 NMOS transistor for dual edge latch. The circuit having input as D, Db and output as Q, Qb. When clock is “set” MN 1, MN 2 both turns “ON”, If clock is “RESET ” MN 1, MN 2 turns “OFF”. This dual edge latch consumes less static current and power delay product than shift <b>register</b> with pulsed <b>latches.</b> It {{can be used to}} design Successive Approximation Ratio (SAR) and Comparator. Power also reduced and also it uses less amount of transistor than shift <b>register</b> with pulsed <b>latches.</b> It consumes 67 % power and 46 % area when compared to shift <b>register</b> with pulsed <b>latches...</b>|$|R
40|$|Syntax Intermediate Flow-graph SAFL Specification Register Placement Data Validity High level program {{transformation}} Translate Lex/Parse Translate Analysis Analysis Transformation Hierarchical RTL Verilog Figure 1 : Structure of the FLaSH Compiler {{which is}} that we must synthesise a <b>register</b> to <b>latch</b> the value of f(4) before it is corrupted. We call these <b>latches</b> permanising <b>registers</b> since they make the result of computing an expression permanent, decoupling the caller from the callee...|$|R
40|$|In {{this paper}} we present our {{experience}} on model checking of an Asynchronous Transfer Mode (ATM) switch using the Verification Interacting with Synthesis (VIS) tool. The switch we considered is in use for real {{applications in the}} Cambridge Fairisle network. It is composed of four input/output port controllers and a switch fabric, and contains around 1 MB memory, 2 KB FIFO buffer and 800 <b>registers</b> (<b>latches).</b> To overcome state space explosion, we adopted several abstractions and reductions, and applied compositional reasoning combined with two novel property division approaches. For the verification in VIS, we produced Verilog descriptions of the switch {{at different levels of}} design hierarchy and defined a number of relevant properties in CTL. Using the above techniques, we succeeded in verifying the switch at different hierarchy levels within reasonable CPU time, and thus illustrated the applicability of model checking to large designs containing a considerable number of state-holding elements. In addition, we succeeded in discovering several injected design errors in both the fabric and the port controllers...|$|R
40|$|Modern TTL Circuits Manual {{provides}} {{an introduction to}} the basic principles of Transistor-Transistor Logic (TTL). This book outlines the major features of the 74 series of integrated circuits (ICs) and introduces the various sub-groups of the TTL family. Organized into seven chapters, this book begins with an overview of the basics of digital ICs. This text then examines the symbology and mathematics of digital logic. Other chapters consider a variety of topics, including waveform generator circuitry, clocked flip-flop and counter circuits, special counter/dividers, <b>registers,</b> data <b>latches,</b> co...|$|R
40|$|Abstract-This paper {{presents}} an ultra low power (ULP) solution to hold time closure for subthreshold circuits across PVT variation and mismatch using a two-phase, latch based timing method. We show that compared to conventional hold buffering, our solution saves up to 37 % (at 6 σ yield) in energy per operation {{and allows for}} post tapeout hold time correction. Replacing <b>registers</b> with <b>latches</b> also permits time borrowing, which we show can save up to 47 % (6 σ yield) when used for setup time closure. I...|$|R
40|$|This thesis {{addresses}} {{the problem of}} tolerating soft errors in brake-by-wire systems. Soft errors are caused by ionizing particles and manifest themselves as bit-flips in memory <b>registers,</b> <b>latches,</b> and flip-flops. As transistors are shrunk to sustain Moore's law, the frequency of such radiation-induced faults increases. The overall goal of the thesis is to design and evaluate cost-efficient techniques to tolerate soft errors in control systems. To emulate the effects of soft errors, we inject single bit-flips into the registers and the main memory of a microcontroller running a prototype brake controller. We first evaluate {{a version of the}} brake controller in which hardware exceptions are the only means for detecting errors. These experiments show that although many of the injected errors are masked by the brake controller program, a non-negligible proportion of the errors caused the controller to produce erroneous outputs to the brake actuator. We designed two software implemented mechanisms for detecting and recovering soft errors in the brake controller. These mechanisms protect the stack pointer and the brake controller's integrator state. Using a second error injection campaign, we evaluate the effectiveness of these mechanisms. Results from this campaign show that the software mechanisms reduced the proportion of errors causing critical controller significantly...|$|R
40|$|This report {{describes}} the scheduling algorithm in RTL design methodology. The proposed scheduling algorithm {{is based on}} resource constrained list scheduling, which considers the number of function units, storage units, busses and ports of storage units in each control step, and supports the pipelined/multicycle operations and storage units, such as pipelined <b>register</b> files and <b>latched</b> memory. ...|$|R
40|$|Abstract-This paper {{presents}} an ultra-low power (ULP) finite-impulse response (FIR) filter using {{a method that}} approximates filter coefficients on-chip without reliance on dedicated memory such as SRAM. In a system-on-chip (SoC) context, this method allows for full power gating of the coefficient unit without coefficient state loss, and runtime modifications of filtering specifications, such as filter order and cutoff frequency. Using trigonometric approximation methods for the sinc and resource sharing of computational units, a single coefficient is generated in five clock cycles. The approximation unit is compared against standard-cell-based memories, such as <b>register</b> and <b>latch</b> files, for energy and area, and the design is synthesized in 130 nm CMOS consumin...|$|R
40|$|In this report, we {{describe}} the novel RTL design methodology based on Accellera RTL semantics. We also propose the scheduling algorithm targeting bus-based architecture for the RTL design methodology. The proposed scheduling algorithm is based on resource constrained list scheduling, which considers the number of function units, storage units, buses and ports of storage units in each control step. It supports the pipelined/multicycle operations and storage units, such as pipelined <b>register</b> files and <b>latched</b> memory. 2 Content...|$|R
40|$|A {{protective}} cover assembly {{for an end}} of a cable connector having a cable housing that encloses a plurality of connective pins or sockets and that satisfies all requirements for space applications. A connector body flange is formed at the extremity of a cable and is positioned so that it may register with a corresponding connector body flange {{on the end of}} a companion cable to which a connection is to be made, one cable end having cable lead pins and the companion cable end having lead sockets with which the pins <b>register.</b> A <b>latch</b> mechanism having a latch housing is received in the connector body flange and a crank connected to a manually rotatable cap actuates a spring-loaded latch element that is engageable with a connector body flange to secure or to release the cover assembly with the simple twisting motion of the cap, thereby simplifying the task of effecting coupling and decoupling of the cable ends...|$|R
5000|$|The {{most common}} method for {{delivering}} test data from chip inputs to internal circuits under test (CUTs, for short), and observing their outputs, is called scan-design. In scan-design, <b>registers</b> (flip-flops or <b>latches)</b> {{in the design}} are connected {{in one or more}} scan chains, which are used to gain access to internal nodes of the chip. Test patterns are shifted in via the scan chain(s), functional clock signals are pulsed to test the circuit during the [...] "capture cycle(s)", and the results are then shifted out to chip output pins and compared against the expected [...] "good machine" [...] results.|$|R
40|$|The CAT 4103 is a 3 −channel, linear based constant−current LED driver {{designed}} for RGB LED control, requiring no inductor {{and provides a}} low noise operation. LED channel currents up to 175 mA are programmed independently via separate external resistors. Low output voltage operation of 0. 4 V at 175 mA allows for more power efficient designs across wider supply voltage range. The three LED pins are compatible with high voltage up to 25 V supporting applications with long strings of LEDs. A high−speed 4 −wire 25 MHz serial interface controls each individual channel using a shift <b>register</b> and <b>latch</b> configuration. Output data pins allow multiple devices to be cascaded and programmed via one serial interface with no need for external drivers or timing considerations. The device also includes a blanking control pin (BIN) {{that can be used}} to disable all channels independently of the interface. Thermal shutdown protection is incorporated in the device to disable the LED outputs whenever the die temperature exceeds 150 °C. The device is available in a 16 −lead SOIC package. Feature...|$|R
40|$|Product SpecificationLogiCORE IP Image Noise Reduction v 1. 0 The noise_reg 02 _filt_strength {{register}} is double buffered in {{hardware to}} ensure no image tearing {{happens if the}} filter strength value is modified in the active area of a frame. This double buffering provides system control that is more flexible {{and easier to use}} by decoupling the register updates from the blanking period, allowing software a much larger window with which to update the parameter values. The updated value for the filter strength <b>register</b> is <b>latched</b> into the shadow register immediately after writing, while the actual filter strength used is stored in the working register. Any reads of registers during operation return the values stored in the shadow registers. The rising edge of vblank_in triggers the values from the shadow registers to be copied to the working registers when bit 1 of noise_reg 00 _control is set to 1. This semaphore bit helps to prevent changing the filter strength mid-frame. Figure 6 shows a software flow diagram for updating registers during the operation of the core...|$|R
5000|$|Edge-triggered {{interrupts}} do {{not suffer}} {{the problems that}} level-triggered interrupts have with sharing. Service of a low-priority device can be postponed arbitrarily, and interrupts {{will continue to be}} received from the high-priority devices that are being serviced. If there is a device that the CPU does not know how to service, it may cause a spurious interrupt, or even periodic spurious interrupts, but it does not interfere with the interrupt signalling of the other devices. However, it is fairly easy for an edge triggered interrupt to be missed - for example if interrupts have to be masked for a period - and unless there is some type of hardware latch that records the event it is impossible to recover. Such problems caused many [...] "lockups" [...] in early computer hardware because the processor did not know it was expected to do something. More modern hardware often has one or more interrupt status <b>registers</b> that <b>latch</b> the interrupt requests; well written edge-driven interrupt software often checks such registers to ensure events are not missed.|$|R
40|$|A laser {{velocimeter}} {{signal processor}} {{for measuring the}} signal frequency within a signal burst was invented. The input signal is converted to digital by an {{analog to digital converter}} and then shifted into shift registers. An automatic gain circuit controls the gain of the input signal. A signal integration circuit determines when a signal burst has been captured by the shift registers and then transfers the contents of the <b>registers</b> to data <b>latches.</b> The data in the data latches is processed by digital bandpass filters, square law detectors, burst counters and a signal processor to determine the frequency of the signal within the captured signal burst...|$|R
40|$|Abstract—Exponential {{increase}} in leakage power {{has emerged as}} a major barrier to technology scaling. Existing circuit techniques for leakage reduction either suffer from reduced effectiveness at nanometer technologies or affect performance and gate-oxide reliability. In this paper, we propose application of a specific carbon nanotube (CNT) -based nano-electromechanical switch as a leakage-control structure in logic and memory circuits. In case of memory circuits, we demonstrate that the proposed hybridization can be employed to reduce both cell leakage and bitline leakage, thereby improving the read noise margin as well. Due to the unique electromechanical properties of CNTs, these switches have high current-carrying capacity, extremely low leakage current, and low operating voltages. Moreover, they can act as nonvolatile memory elements, which can be exploited for data retention of important <b>registers</b> and <b>latches</b> during power down. Simulation results for a set of benchmark circuits show that we can obtain sev-eral orders of magnitude improvement in leakage saving in logic circuits at iso-performance compared to existing multi-threshold CMOS technique. In memory circuits, simulations show 19 reduction in standby leakage and 55 reduction in bitline leakage compared with the best existing techniques. Index Terms—Bitline leakage, CMOS logic circuits, CMOS memory circuits, nano-electromechanical switch (NEMS), leakage reduction. I...|$|R
40|$|Abstract—This paper {{proposes a}} design {{approach}} targeting circuits operating at extremely low supply voltages, {{with the goal}} of reducing the voltage at which energy is minimized, thereby improving the achievable energy efficiency of the circuit. The proposed methods accomplish this by minimizing the cir-cuit’s ratio of leakage to active current. The first method, super pipelining, increases the number of pipeline stages compared to conventional ultra low voltage (ULV) pipelining strategies, reducing the leakage/dynamic energy ratio and simultaneously improving performance and energy efficiency. Measurements of super-pipelined multipliers demonstrate 30 % energy savings and 1. 6 performance improvement. Since super pipelining reduces the logic depth between <b>registers,</b> two-phase <b>latch</b> based design is employed to compensate for reduced averaging effects and pro-vide better variation tolerance. The second technique introduces a parallel-pipelined architecture that suppresses leakage energy by ensuring full utilization of functional units and reduces memory size. We apply these techniques to a 16 -b 1024 -pt complex-valued Fast Fourier Transform (FFT) core along with low-power first-in first-out (FIFO) design and robust clock distribution network. The FFT core is fabricated in 65 nm CMOS and consumes 15. 8 nJ/FFT with a clock frequency of 30 MHz and throughput of 240 Msamples/s at, providing 2. 4 better energy efficiency than current state-of-art and higher throughput than typical ULV designs. Measurements of 60 dies show modest frequency (energy) spreads of 7 % (2 %). Index Terms—Fast Fourier Transform (FFT), subthreshold CMOS circuits, super-pipelining, ultra low voltage (ULV) design. I...|$|R
40|$|Single slope ADC is {{a common}} {{building}} block in many ASCI or FPGA based front-end systems due to its simplicity, small silicon footprint, low noise interference and low power consumption. In single slope ADC, using a Gray code counter is a popular scheme for time digitization, in which the comparator output drives the clock (CK) port of a <b>register</b> to <b>latch</b> the bits from the Gray code counter. Unfortunately, feeding the comparator output into the CK-port causes unnecessary complexities and artificial challenges. In this case, the propagation delays of all bits from the counter to the register inputs must be matched and the counter must be a Gray code one. A simple improvement on the circuit topology, i. e., feeding the comparator output into the D-port of a register, will avoid these unnecessary challenges, eliminating the requirement of the propagation delay match of the counter bits and allowing the use of regular binary counters. This scheme not only simplifies current designs for low speeds and resolutions, but also opens possibilities for applications requiring higher speeds and resolutions. A multi-channel single slope ADC based on a low-cost FPGA device has been implemented and tested. The timing measurement bin width in this work is 60 ps, which would need a 16. 7 GHz counter clock had it implemented with the conventional Gray code counter scheme. A 12 -bit performance is achieved using a fully differential circuit making comparison between the input and the ramping reference, both in differential format...|$|R
40|$|ABSTRACT- The {{necessity}} for precise time synchronisation of measurement data from multiple sensors is widely {{recognised in the}} field of GPS/INS integration. Having precise time synchronisation is critical for achieving high data fusion performance. The limitations and advantages of various time synchronisation scenarios and existing solutions are investigated in this paper. A criterion for evaluating synchronisation accuracy requirements is derived based on the comparison of the Kalman filter innovation series and the platform dynamics. An innovative time synchronisation solution using a counter and two <b>latching</b> <b>registers</b> is proposed. The proposed solution has been implemented with off-the-shelf components and tested. The resolution and accuracy analysis shows that the proposed solution has the capability to reach a time synchronisation accuracy at 0. 1 ms level if INS could provide hard-wired timing signal. A synchronisation accuracy of 2 ms has been achieved when the test system was used to synchronise a low-grade MEMS IMU which has only an RS- 232 data output interface. Keywords- GPS, INS, time synchronisation, multi-sensor integratio...|$|R
40|$|Now days {{a number}} of {{processors}} are available with a lot kind of feature from different industries. A processor with similar kind of architecture of the current processors only missing the memory stuffs like the RAM and ROM has been designed here {{with the help of}} Verilog style of coding. This processor contains architecturally the program counter, instruction <b>register,</b> ALU, ALU <b>latch,</b> General Purpose <b>Registers,</b> control state module, flag registers and the core module containing all the modules. And a test module is designed for testing the processor. After the design of the processor with successful functionality, the processor is synthesized with 180 nm technology. The synthesis is performed with the data path optimization like the selection of proper adders and multipliers for timing optimization in the data path while the ALU operations are performed. During synthesis {{how to take care of}} the worst negative slack (WNS), how to include the clock gating cells, how to define the cost and path groups etc. have been covered. After the proper synthesis we get the proper net list and the synthesized constraint file for carrying out the physical design. In physical design the steps like floor-planning, partitioning, placement, legalization of the placement, clock tree synthesis, and routing etc. have been performed. At all the stages the static timing analysis is performed for the timing meet of the design for better performance in terms of timing or frequency. Each steps of physical design are discussed with special effort towards the concepts behind the step. Out of all the steps of physical design the clock tree synthesis is performed with some improvement in the performance of the clock tree by creating a symmetrical clock tree and maintaining more common clock paths. A special algorithm has been framed for creating a symmetrical clock tree and thereby making the power consumption of the clock tree low...|$|R
40|$|System-on-Chip (SoC) faced lots of {{challenges}} {{over the past}} decade. With nowadays applications centered around Internet-of-Everything (IoE), these challenges {{are expected to be}} more critical. Among these challenges are the reduction of power consumption for better energy efficiency, the overcoming of different sources of variations to ensure reliable operation and the reduction of design area to reduce the cost and increase the integration. As a result, chip designers find themselves facing lots of problems, trying to build reliable systems that integrate complex level of functionality, on a minimum die size and with a limited power budgets. Among different circuit components in every chip, memory components are of great concern. They consume the majority of the chip area and power, in addition to affecting the entire chip performance and reliability. These include large memory arrays, caches, register files and different sequential elements in the logic paths. Sequential elements play an important and critical role in modern synchronous CMOS circuits. Indeed, they can represent up to 50 % of the standard cells used in a chip. In addition, the power consumption of the clock tree, including these elements can be {{more than half of the}} total chip power. In addition, they come in the second place after memory to be affected by different sources of variation. Hence, efficient implementation of these elements is of great importance for the design of energy efficient and reliable integrated circuits. Pulsed latches have been proposed as efficient replacement of flip-flops in the implementation of sequential elements. They can achieve higher performance when compared to traditional flip-flops, and can be designed to be smaller in area and more power efficient. However, the operation of pulsed latch is more sensitive to process, voltage and temperature (PVT) variations. In this thesis, we are proposing a methodology to study the reliability of pulsed latches and we have used it to evaluate the effect of PVT variations on their behavior. In addition, novel approaches to enhance the reliability of pulsed latches without significant degradation in performance, area or power are presented. Also, since sequential elements can be used to build small size <b>register</b> files, pulsed <b>latch</b> implementation of <b>register</b> files are discussed and compared to other traditional implementations, including SRAM and flip-flops. In addition, since multiport register files are very beneficial for quite few applications, novel implementations of multiport register files are also presented. The proposed implementation is proved to highly reduce the significant overhead in area, power and latency associated with the traditional way of designing multiport register files...|$|R

