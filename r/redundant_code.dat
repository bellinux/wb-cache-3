89|195|Public
50|$|The {{dead code}} {{elimination}} technique {{is in the}} same class of optimizations as unreachable code elimination and <b>redundant</b> <b>code</b> elimination.|$|E
5000|$|In {{computer}} programming, <b>redundant</b> <b>code</b> is {{source code}} or compiled code {{in a computer}} program that is unnecessary, such as: ...|$|E
50|$|The second iX*2 {{expression}} is <b>redundant</b> <b>code</b> {{and can be}} replaced by a reference to the variable iY. Alternatively, the definition int iY = iX*2 can instead be removed.|$|E
3000|$|... {{to denote}} {{the two new}} modes, respectively, with r {{standing}} for <b>redundant</b> <b>coding,</b> u representing the candidate QP value in the intra <b>redundant</b> <b>coding</b> and v representing the candidate QP value in the inter <b>redundant</b> <b>coding.</b> Therefore, for the HRMIR approach, the set of encoding options become [...]...|$|R
30|$|<b>Redundant</b> <b>coding</b> {{is another}} {{effective}} tool for robust video communication over lossy network. In [8], an optimal algorithm {{is presented to}} determined whether one picture needs redundant version. In [9], redundant slice is optimally allocated based on the slice position in the GOP, and the primary and redundant slices are then interleaved to generate two equal importance descriptions using the MDC [10] diagram. Whereas in [11], the two descriptions are generated by splitting the video pictures into two threads, and then redundant pictures are periodically inserted into the two threads. In both [8] and [11], <b>redundant</b> <b>coding</b> are optimized in frame level, namely all the macroblocks in one frame is encoded with the same <b>redundant</b> <b>coding</b> parameters, whereas for [9], redundant information is allocated in slice level. In [12], <b>redundant</b> <b>coding</b> is optimized in macroblock level. However, in order to optimally tune the redundancy, this approach needs all the motion vector information in one GOP, {{which leads to a}} delay of one GOP; consequently, this work cannot be applied in real-time applications, such as video conference.|$|R
3000|$|..., {{the total}} bit rate RMB(o) is {{calculated}} by summing up the bit rate used for both primary and <b>redundant</b> <b>coding.</b>|$|R
50|$|Programming Languages {{and their}} Compilers by John Cocke and Jacob T. Schwartz, {{published}} early in 1970, devoted more than 200 pages to optimization algorithms. It included {{many of the}} now familiar techniques such as <b>redundant</b> <b>code</b> elimination and strength reduction.|$|E
5000|$|The above example {{contains}} some <b>redundant</b> <b>code</b> {{to do with}} the four attributes , , , and [...] It is possible to eliminate some of this redundancy using a metaclass. In Python, a metaclass is most easily defined as a subclass of [...]|$|E
5000|$|A NOP {{instruction}} {{might be}} considered to be <b>redundant</b> <b>code</b> that has been explicitly inserted to pad out the instruction stream or introduce a time delay, for example to create a timing loop by [...] "wasting time". Identifiers that are declared, but never referenced, are termed redundant declarations.|$|E
3000|$|... {{to denote}} the primary QP value of intra and inter coding, respectively. In the <b>redundant</b> <b>coding,</b> {{candidate}} QP value is u ∈ {u|QP [...]...|$|R
40|$|This {{proposal}} {{presents a}} new error robust strategy for encoding redundant pictures for the H. 264 /AVC standard. The method {{is based on}} providing motion vectors as redundant data, i. e. providing extra protection to the motion information of the encoded stream. The proposed system is implemented based on the existing <b>redundant</b> <b>coding</b> algorithm of the scalable extension of H. 264 /AVC. The performance of the algorithm is evaluated using various objective quality measurements under both error free and error prone Internet Protocol (IP) packet network environments. The proposed algorithm increases the bandwidth utilization with slight degradation in the primary picture quality for error free conditions, compared to the existing <b>redundant</b> <b>coding</b> method of JSVM (Joint Scalable Video Model). Furthermore, the simulation results under packet loss environments show that the proposed algorithm outperforms the existing <b>redundant</b> picture <b>coding</b> of JSVM. Index Terms — <b>Redundant</b> picture <b>coding,</b> Erro...|$|R
3000|$|... [...]. In the <b>redundant</b> <b>coding,</b> the <b>redundant</b> QP {{value is}} v, pixel i is {{predicted}} from pixel i + mv(v) {{in the previous}} frame, the prediction residual [...]...|$|R
50|$|In 2009 Motorola {{created an}} updated version of EMML in order to {{co-ordinate}} it with other Internet standards, most notably CSS. There was a clear focus on simplifying the standard and reducing the amount of <b>redundant</b> <b>code.</b> In doing so, the number of bytes required to be downloaded was reduced and the readability of the language was vastly improved.|$|E
5000|$|The {{sequence}} POP regs {{followed by}} PUSH {{for the same}} registers is generally redundant. In cases where it is redundant, a peephole optimization would remove these instructions. In the example, this would cause another redundant POP/PUSH pair {{to appear in the}} peephole, and these would be removed in turn. Removing all of the <b>redundant</b> <b>code</b> in the example above would eventually leave the following code: ...|$|E
50|$|NOP is {{sometimes}} {{used as a}} description for the action performed by a function or a sequence of programming language statements if the function or code has no effect (it might also be called <b>redundant</b> <b>code).</b> A common compiler optimization is the detection and removal {{of this kind of}} code. Such code may be required by the grammar of the programming language, which does not allow a blank.|$|E
30|$|In application, {{our results}} {{indicate}} that redundant visual signals {{are likely to be}} as effective at aiding visual detection under multi-task conditions as under single-task conditions. This means both that <b>redundant</b> <b>coding</b> will be useful within multi-task workspaces, and that the results of single-task pilot testing can be used to predict the magnitude of RT gain that redundant signals will purchase in a multi-task environment. Thus, design guidelines for complex visual workspaces, such as pilot cockpits or vehicle dashboards, should encourage the use of <b>redundant</b> <b>coding</b> of visual alerts for enhancing detection.|$|R
40|$|In greedy parsing {{dictionary}} coders with deferred innovation ([2], certain phrases in {{the dictionary}} that are impossible to be matched during {{the next stage of}} parsing can be eliminated. We call this process as phrase elimination, and it is used with less <b>redundant</b> <b>codes</b> ([9] to achieve compression ratio improvement in this work. We provide theoretical estimate of the expected dictionary size after phrase elimination over a certain type of source. Experimental results suggest that 3 % improvement can be expected over LZW coders using less <b>redundant</b> <b>codes...</b>|$|R
40|$|Abstract—The {{present study}} {{examined}} the efficacy of using audio cues for <b>redundant</b> <b>coding</b> of tactile key clicks simulated with a piezoelectric actuator. The tactile stimuli consisted of six raised cosine pulses at two levels of frequency and three levels of amplitude. An absolute identification experiment was conducted to measure the information transfers associated with the tactile-audio signal set. Results from Condition 1 (C 1) provided a baseline measure by employing only the tactile signals. In Conditions 2 - 4 (C 2 -C 4), supplemental audio signals were used to encode amplitude cues only, frequency cues only, and both amplitude and frequency cues, respectively. The results showed that partial <b>redundant</b> <b>coding</b> of tactile cues with audio signals could increase information transfer, when the cue (amplitude) was not perfectly identifiable with tactile signals alone (C 2). When the cue (frequency) was well perceived through tactile signals alone, audio supplemental cues did not improve performance (C 3). With <b>redundant</b> <b>coding</b> of both amplitude and frequency cues (C 4), audio signals dominated tactile signals. It was also found that increased information transfer was achieved {{at the cost of}} increased response time (C 2), suggesting increased mental load associated with the processing of multisensory information. Our findings have implications for the design of simulated key-click signals for mobile devices, and the use of multimodal signals for <b>redundant</b> <b>coding</b> of information in general. ...|$|R
50|$|The SofCheck Inspector is {{a static}} {{analysis}} tool for Java and Ada. It statically determines and documents the pre- and postconditions of Java methods or Ada subprograms, and uses {{that information to}} identify logic flaws, race conditions, and <b>redundant</b> <b>code</b> in an individual Java class or Ada package, a subsystem, or a complete program. The SofCheck Inspector is produced by SofCheck, Inc., a software product company in Burlington, Massachusetts.|$|E
5000|$|Curried and higher-order {{functions}} {{can be used}} {{to eliminate}} <b>redundant</b> <b>code.</b> For example, a library may require functions of type , but it is more convenient to write functions of type [...] where there is a fixed relationship between the objects of type [...] and [...] A higher order function of type (a * c -> b) -> (a -> b) can factor out this commonality. This {{is an example of the}} adapter pattern.|$|E
50|$|Global value {{numbering}} (GVN) is a compiler optimization {{based on}} the static single assignment form (SSA) intermediate representation. It sometimes helps eliminate <b>redundant</b> <b>code</b> that common subexpression elimination (CSE) does not. At the same time, however, CSE may eliminate code that GVN does not, so both are often found in modern compilers. Global value numbering is distinct from local value numbering in that the value-number mappings hold across basic block boundaries as well, and different algorithms are used to compute the mappings.|$|E
40|$|Abstract-We {{consider}} asynchronous multiple accessing without feedback {{over the}} collision channel. <b>Redundant</b> <b>coding</b> {{is used to}} overcome user scribes the channel model and derives the capacity region. Section III analyzes the performance of block codes. Secinterference which causes erasures for collided packets. The channel has a sum capacity of e-I and a sum cutoff rate of 0. 295. The best codes areoses a convolutional coding and terleavg long constraint length rate 1 / 3 convolutional encoders which achieve a sum scheme, and computes the sum cutoff rate of the channel. throughput up to the sum cutoff rate using an easy-to-implement forward Section V generalizes Sections II and IV to the case when search decoding algorithm. In the presence of additive Gaussian noise, the the channel is corrupted by additive Gaussian noise; it same <b>redundant</b> <b>coding</b> can save, at hardly any extra cost, about 6 dB of shows that substantial power saving is gained, at hardly signal-to-noise ratio. any extra cost, by the <b>redundant</b> <b>coding</b> that was originally intended to correct erasures due to packet collisions. I...|$|R
40|$|The {{possibility}} of finding redundancy gains with overlearned tasks was examined using a paradigm varying {{familiarity with the}} stimulus set. <b>Redundant</b> <b>coding</b> in a multidimensional stimulus was demonstrated to result in increased identification accuracy and decreased latency of identification when compared to stimuli varying on only one dimension. The advantages attributable to <b>redundant</b> <b>coding</b> {{are referred to as}} redundancy gain and were found for a variety of stimulus dimension combinations, including the use of hue or color as one of the dimensions. Factors that have affected redundancy gain include the discriminability of the levels of one stimulus dimension and the level of stimulus-to-response association. The results demonstrated that response time is in part a function of familiarity, but no effect of <b>redundant</b> color <b>coding</b> was demonstrated. Implications of research on coding in identification tasks for display design are discussed...|$|R
30|$|In this paper, a novel Hybrid Redundant Macroblock and Intra {{macroblock}} Refreshment {{approach has}} been proposed to combat packet loss. In the proposed approach, <b>redundant</b> <b>coding</b> and/or intra coding are optimally allocated in macroblock level. Whether to use <b>redundant</b> <b>coding</b> and/or intra coding and the quantization parameter of the <b>redundant</b> <b>coding</b> is all determined in the end-to-end rate-distortion optimization procedure. It is worth mentioning that, in the proposed approach, only information from the previously encoded frames {{is used to calculate}} the end-to-end distortion in the RDO process; therefore, no additional delay is caused, making the proposed approach suitable for real-time applications such as video conference. Extensive experimental results show that the proposed method provides better performance than other error-resilient source coding approaches. The performance gap between the proposed approach and the Optimal Intra Refreshment is huge, and in some simulation environments, the proposed approach can provide 4 dB higher PSNR than the conventional Optimal Intra Refreshment with the same bitrate. Our future work is to calculate the end-to-end distortion in sub-pixel accuracy; therefore, more accurate end-to-end distortion would be available, which would eventually lead to better resource allocation.|$|R
5000|$|HyperTalk tried {{its best}} to {{determine}} additional context and allow the programmer to [...] "leave out" [...] <b>redundant</b> <b>code.</b> In the case of text fields, for instance, [...] "the value", the text typed into the field, {{was assumed to be}} the main property and was assumed to be the target if not otherwise specified. Likewise, [...] "card fields" [...] were assumed to be the target of commands, as opposed to [...] "background field", so it could be left off as well. Even container types had short forms to save typing. The code above is equivalent to the short form [...]|$|E
5000|$|Lack of Cohesion with Functionality: Though {{experiments}} [...] {{have repeatedly}} confirmed that while effort is {{highly correlated with}} LOC, functionality is less well correlated with LOC. That is, skilled developers {{may be able to}} develop the same functionality with far less code, so one program with less LOC may exhibit more functionality than another similar program. In particular, LOC is a poor productivity measure of individuals, because a developer who develops only a few lines may still be more productive than a developer creating more lines of code - even more: some good refactoring like [...] "extract method" [...] to get rid of <b>redundant</b> <b>code</b> and keep it clean will mostly reduce the lines of code.|$|E
5000|$|PLASMA's use of lexical scope {{was similar}} to the lambda calculus. Sussman and Steele decided to try to model Actors in the lambda calculus. They called their {{modeling}} system Schemer, eventually changing it to Scheme to fit the six-character limit on the ITS file system on their DEC PDP-10. They soon concluded Actors were essentially closures that never return but instead invoke a continuation, and thus they decided that the closure and the Actor were, for the purposes of their investigation, essentially identical concepts. They eliminated what they regarded as <b>redundant</b> <b>code</b> and, at that point, discovered that they had written a very small and capable dialect of Lisp. Hewitt remained critical of the [...] "hairy control structure" [...] in Scheme and considered primitives (e.g., , [...] and [...] ) used in the Scheme implementation to be a backward step.|$|E
40|$|Abstract — The motion {{information}} of an encoded video data stream plays {{a vital role}} in frame reconstruction, compared to its residual information. Hence, it is sensible to provide extra protection for the motion information. The proposed system is implemented based on the existing <b>redundant</b> <b>coding</b> algorithm of H. 264 /AVC and it provides extra protection only for the motion information. The paper analyzes the effect of proposed error resilience technique on enhancement layer picture quality. The performance of the algorithm is evaluated under both error free and error prone Internet Protocol(IP) packet network environments. The proposed algorithm increases the bandwidth utilization with slight degradation in the primary picture quality at error free conditions, compared to the existing <b>redundant</b> <b>coding</b> method of H. 264 /AVC standard. Furthermore, the simulation results show that the proposed algorithm outperforms the existing <b>redundant</b> picture <b>coding</b> technique of scalable extension of H. 264 /AVC standard, under packet loss environments. Keywords-component; H. 264; scalable video coding; error resilience; motion vectors I...|$|R
40|$|The {{proposed}} error resilience algorithm incorporates motion {{information of}} predictive based video coding {{to improve the}} robustness of the transmitted data. The motion information of the video data plays {{a vital role in}} frame reconstruction. Therefore, the technique proposed in this research highlights the effect of providing extra protection for the motion information. The proposed system is implemented based on the existing <b>redundant</b> <b>coding</b> algorithm of the scalable extension of H. 264 /AVC and it encodes redundant data only for the motion information. The paper analyzes the effect of proposed error resilience technique, <b>redundant</b> motion information <b>coding,</b> on both base layer and enhancement layer picture quality. The performance of the algorithm is evaluated in both error free and error prone Internet Protocol(IP) packet network environments. The proposed algorithm increases the bandwidth utilization with slight degradation in the primary picture quality for error free conditions, compared to the existing <b>redundant</b> <b>coding</b> method of H. 264 /AVC standard. Furthermore, the simulation results under packet loss environments show that the proposed algorithm outperforms the existing <b>redundant</b> picture <b>coding</b> technique of H. 264 /AVC standard. Key words: H. 264; scalable video coding; error resilience; motion vector...|$|R
40|$|Orthogonal {{frequency}} division multiplexing (OFDM) provides a viable solution to communicate over frequency selective fading channels by converting {{them to an}} equivalent collection of flat fading channels. In doing so, OFDM systems fail {{to reap the benefits}} of diversity available in multipath fading channels. To ameliorate this shortcoming of OFDM, explicit diversity in the form of <b>redundant</b> or non-redundant <b>coding</b> is needed. Our main goal in this paper is to explore different options for low complexity encoder design and compare their performance and complexity. Specifically, in the class of non-redundant codes we discuss the use of signal space diversity codes in OFDM systems. For <b>redundant</b> <b>codes,</b> we introduce a novel low complexity postcoded-OFDM system where coding is employed after performing the IFFT (inverse fast Fourier transform) in the transmitter to reduce system complexity. Simulation results show that postcoded-OFDM with <b>redundant</b> <b>coding</b> outperforms other choices of encoder design considered in this paper. 1...|$|R
50|$|In May 2008, {{security}} researcher Luciano Bello {{revealed his}} discovery that changes made in 2006 to the {{random number generator}} in the version of the OpenSSL package distributed with Debian GNU/Linux and other Debian-based distributions, such as Ubuntu, dramatically reduced the entropy of generated values and made a variety of security keys vulnerable to attack. The security weakness was caused by changes made to the openssl code by a Debian developer in response to compiler warnings of apparently <b>redundant</b> <b>code.</b> This caused a massive worldwide regeneration of keys, and despite all attention the issue got, it could be assumed many of these old keys are still in use. Key types affected include SSH keys, OpenVPN keys, DNSSEC keys, key material for use in X.509 certificates and session keys used in SSL/TLS connections. Keys generated with GnuPG or GNUTLS are not affected as these programs used different methods to generate random numbers. Keys generated by non-Debian-based Linux distributions are also unaffected. The weak-key-generation vulnerability was promptly patched after it was reported, but any services still using keys that were generated by the old code remain vulnerable. A number of software packages now contain checks against a weak key blacklist to attempt to prevent use {{of any of these}} remaining weak keys, but researchers continue to find weak key implementations.|$|E
40|$|Partial {{redundancy}} elimination (PRE) subsumes {{the classical}} optimizations of loop invariant movement and common subexpression elimination. The original formulation of PRE involved complex bi-directional data flows {{and had two}} major deficiencies—missed optimization opportunities and <b>redundant</b> <b>code</b> movement. To eliminate <b>redundant</b> <b>code</b> movement, most current PRE approaches use a hoisting-followed-by-sinking approach. Unfortunately, this approach has a high conceptual complexity and requires complicated correctness proofs. We show that optimization by partial redundancy elimination is simpler {{than it has been}} made out to be. Its essence is the concept of eliminatability of an expression. We show that E-path PRE, a formulation of PRE based on the concept of eliminatability paths (E-paths), is easy to understand and simple to prove correct. It uses only well-known data flow concepts of available expressions and anticipatable (i. e. very-busy) expressions to directly identify code insertion points which avoid <b>redundant</b> <b>code</b> movement. These features reduce the conceptual complexity of PRE considerably. Interestingly, performance studies show that E-path PRE is also less expensive to perform than the closest equivalent approach to PRE. This is a sheer bonus...|$|E
40|$|Conventional {{collection}} libraries do {{not perform}} automatic collection-specific optimizations. Instead, performance-critical code using collections must be hand-optimized, leading to non-modular, brittle, and <b>redundant</b> <b>code.</b> We propose SQUOPT, the Scala Query Optimizer, a deep embedding of the Scala collection library performing collection-specific optimizations automatically without external tools or compiler extensions...|$|E
40|$|A main {{obstacle}} for {{the experimental}} realization of a quantum computer is the unavoidable coupling of the qubits to external degrees of freedom and the decoherence caused in that way. A possible solution of this problem are error correcting codes. These, however, require <b>redundant</b> <b>coding</b> and, thus, a considerably higher algorithmic effort...|$|R
50|$|This {{similarity}} in form between Shannon's capacity and Hartley's law {{should not be}} interpreted to mean that M pulse levels can be literally sent without any confusion; more levels are needed, to allow for <b>redundant</b> <b>coding</b> and error correction, but the net data rate that can be approached with coding is equivalent to using that M in Hartley's law.|$|R
3000|$|In the HRMIR {{rate-distortion}} optimization procedure, {{in order}} to find the optimal QP value for <b>redundant</b> <b>coding,</b> we need to calculate the rate-distortion cost for all possible redundant QP value; therefore, the computation complexity is tremendous. For example, let us assume the primary QP value is 22, in the RDO procedure described in Section III-A, the encoding options are [...]...|$|R
