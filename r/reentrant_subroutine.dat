1|3|Public
50|$|This {{definition}} of reentrancy {{differs from that}} of thread-safety in multi-threaded environments. A <b>reentrant</b> <b>subroutine</b> can achieve thread-safety, but being reentrant alone might not be sufficient to be thread-safe in all situations. Conversely, thread-safe code does not necessarily have to be reentrant (see below for examples).|$|E
5000|$|The {{ability for}} {{multiple}} users to quickly load {{and use a}} collection of common <b>reentrant</b> <b>subroutines,</b> which are available in shared virtual memory.|$|R
5000|$|There was {{a single}} {{interrupt}} line on the PDP-8 I/O bus. The processor handled any interrupt by disabling further interrupts and executing a [...] to location 0000. As {{it was difficult to}} write <b>reentrant</b> <b>subroutines,</b> it was difficult to nest interrupts and this was usually not done; each interrupt ran to completion and re-enabled interrupts just before executing the [...] instruction that returned from the interrupt.|$|R
50|$|This {{definition}} originates from single-threaded programming environments {{where the}} flow of control could be interrupted by an interrupt and transferred to an interrupt service routine (ISR). Any subroutine used by the ISR that could potentially have been executing when the interrupt was triggered should be <b>reentrant.</b> Often, <b>subroutines</b> accessible via the operating system kernel are not reentrant. Hence, interrupt service routines are limited in the actions they can perform; for instance, they are usually restricted from accessing the file system and sometimes even from allocating memory.|$|R

