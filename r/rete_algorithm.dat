96|31|Public
50|$|ReteOO is an {{improved}} {{version of the}} <b>Rete</b> <b>algorithm.</b>|$|E
5000|$|Business {{rules engine}} (BRE). This is a <b>Rete</b> <b>algorithm</b> rule engine.|$|E
5000|$|The Jess {{rules engine}} {{utilizes}} the <b>Rete</b> <b>algorithm,</b> {{and can be}} utilized to create: ...|$|E
50|$|Dr Forgy {{retained}} the {{intellectual property rights}} to Rete 2 and his personal company, Production Systems Technology, still sells OPSJ and other systems that incorporate the <b>Rete</b> 2 <b>algorithm.</b> KnowledgeBased Systems Corporation, an independent consulting company in Texas, maintains an extensive set of benchmarks for most BRMS and rulebased systems that demonstrate {{the effectiveness of the}} Rete and <b>Rete</b> 2 <b>algorithms.</b> Dr Forgy has often described PST as a research-oriented company rather than a vendor of BRMS tools, but he does sell various rulebased tools via PST.|$|R
40|$|Abstract- Given that {{companies}} operate {{in an environment}} of continuous evolution it requires information systems to have greater adaptation, flexibility, scalability and reliability of incorporation of these changes. Cloud Computing can be regarded as a paradigm and key element of recent computing in business management solutions. A business solution arises in the cloud; this solution includes both the environmental dynamics and the changes needed in the business logic assuring speed of response, efficiency in the solution and maintenance of the application. This article shows a design model of Saas applications based on a platform (PaaS) which has the business logic as central element and is subdivided in "Business Objects", "Business Processes " and "Business Rules. " According to the business rules, and in order to resolve the problem based on facts and inferences from the knowledge as {{an essential part of the}} construction of the system, expert systems are applied through the use of the <b>RETE</b> <b>algorithms</b> (Forward Chaining) ...|$|R
40|$|The present C-Language Integrated Production System (CLIPS) {{architecture}} has {{not been}} optimized {{to deal with the}} constraints of real-time production systems. Matching in CLIPS is based on the <b>Rete</b> Net <b>algorithm,</b> whose assumption of working memory stability might fail to be satisfied in a system subject to real-time dataflow. Further, the CLIPS forward-chaining control mechanism with a predefined conflict resultion strategy may not effectively focus the system's attention on situation-dependent current priorties, or appropriately address different kinds of knowledge which might appear in a given application. Portable Inference Engine (PIE) is a production system architecture based on CLIPS which attempts to create a more general tool while addressing the problems of real-time expert systems. Features of the PIE design include a modular knowledge base, a modified <b>Rete</b> Net <b>algorithm,</b> a bi-directional control strategy, and multiple user-defined conflict resolution strategies. Problems associated with real-time applications are analyzed and an explanation is given for how the PIE architecture addresses these problems...|$|R
5000|$|In 2010, Forgy {{developed}} {{a new generation of}} the <b>Rete</b> <b>algorithm.</b> In an InfoWorld benchmark, the algorithm was deemed 500 times faster than the original <b>Rete</b> <b>algorithm</b> and 10 times faster than its predecessor, Rete II. [...] This algorithm is now licensed to Sparkling Logic, the company that Charles joined as investor and strategic advisor, as the inference engine of the SMARTS product.|$|E
5000|$|Business Rules Engine - Drools Expert {{using the}} <b>Rete</b> <b>algorithm</b> and the Drools Rule Language (DRL) ...|$|E
5000|$|... #Caption: Diagram of {{the results}} of using a <b>Rete</b> <b>algorithm</b> {{compared}} to Corticon’s Design-Time-Inferencing™ (DeTI) algorithm.|$|E
50|$|In {{the early}} 2000s, the Rete III engine was {{developed}} by Charles Forgy in cooperation with FICO engineers. The <b>Rete</b> III <b>algorithm,</b> which is not Rete-NT, is the FICO trademark for Rete II and is implemented {{as part of the}} FICO Advisor engine. It is basically the Rete II engine with an API that allows access to the Advisor engine because the Advisor engine can access other FICO products.|$|R
40|$|TREAT: A New and Efficient Match Algorithm for AI Production Systems {{describes}} the architecture and software systems embodying the DADO machine, a parallel tree-structured computer {{designed to provide}} significant performance improvements over serial computers of comparable hardware complexity in the execution of large expert systems implemented in production system form. This book focuses on TREAT as a match algorithm for executing production systems that is presented and comparatively analyzed with the <b>RETE</b> match <b>algorithm.</b> TREAT, originally designed specifically for the DADO machine architec...|$|R
40|$|DADO is {{a highly}} parallel, VLSI-based, tree {{structured}} computer, intended (or the rapid execution of production system programs. In this paper we describe a new match algorithm for executing production systems on DADO {{that is capable of}} handling both temporally redundant and nontemporally redundant production systems. We argue that the new algorithm is faster than the original DADO algorithm intended for nontemporally redundant systems. We also show that the new algorithm executed on parallel hardware is faster and more space efficient than parallel implementations of the <b>RETE</b> match <b>algorithm,</b> which is appropriate for temporally redundant systems...|$|R
50|$|ECA rules {{can also}} be used in rule engines that use {{variants}} of the <b>Rete</b> <b>algorithm</b> for rule processing.|$|E
5000|$|Drools, a forward-chaining inference-based {{rules engine}} which uses an {{enhanced}} {{implementation of the}} <b>Rete</b> <b>algorithm.</b> (Drools, Apache license 2.0) ...|$|E
50|$|As {{a student}} of Allen Newell, he {{received}} his Ph.D. in 1979 based on the <b>Rete</b> <b>algorithm.</b> Even though Forgy did not work directly on the DEC XCON AI problem of configuring computers for DEC in the late 70's and early 80's, the <b>Rete</b> <b>algorithm</b> was later incorporated into the system for more speed. The XCON used the early versions of OPS (Official Production System) that migrated to OPS2 and later OPS5.|$|E
40|$|Abstract: 2 ̆ 2 The {{combinatorial}} {{match in}} production systems (rule- based systems) is problematical {{in several areas}} of production system application: real-time performance, learning new productions for performance improvement, modeling human cognition, and parallelization. The unique-attribute representation is a promising approach to eliminate match combinatorics. Earlier investigations {{have focused on the}} ability of unique-attributes to alleviate the problems caused by combinatorial match [Tambe, Newell and Rosenbloom 90]. This paper reports on an additional benefit of unique-attributes: a specialized match algorithm called Uni-Rete. Uni-Rete is a specialization of the widely used <b>Rete</b> match <b>algorithm</b> for unique-attributes, and it has shown over 10 -fold speedup over Rete in performing match. 2 ̆...|$|R
40|$|This paper {{presents}} KRON, {{a representation}} schema to create models for discrete event systems. It {{is based in}} the integration of high level Petri nets with a frame based representation and an object oriented methodology. The main objectives considered in its definition are to obtain a comprehensive and powerful representation model for data and control, and to incorporate a powerful modelling methodology. KRON provides an e#cient execution mechanism to make evolve the models. It is an adaptation of the <b>RETE</b> matching <b>algorithm</b> {{to deal with the}} features provided by high level Petri nets. Moreover, KRON allows the representation of decision points in the execution of non-deterministic models. ...|$|R
40|$|The {{combinatorial}} {{match in}} production systems (rule-based systems) is problematical {{in several areas}} of production system application: real-time performance, learning new productions for performance improvement, modeling human cognition, and parallelization. The unique-attribute representation is a promising approach to eliminate match combinatorics. Earlier investigations {{have focused on the}} ability of unique-attributes to alleviate the problems caused by combinatorial match [Tambe, Newell and Rosenbloom 90]. This paper reports on an additional benefit of unique-attributes: a specialized match algorithm called Uni-Rete. Uni-Rete is a specialization of the widely used <b>Rete</b> match <b>algorithm</b> for unique-attributes, and it has shown over 10 -fold speedup over Rete in performing match...|$|R
50|$|The <b>Rete</b> <b>algorithm</b> is {{designed}} to sacrifice memory for increased speed. In most cases, the speed increase over naïve implementations is several orders of magnitude (because Rete performance is theoretically independent {{of the number of}} rules in the system). In very large expert systems, however, the original <b>Rete</b> <b>algorithm</b> tends to run into memory consumption problems. Other algorithms, both novel and Rete-based, have since been designed which require less memory (e.g. Rete* or Collection-Oriented Match).|$|E
5000|$|The <b>Rete</b> <b>algorithm</b> {{provides}} a generalized logical description of an implementation of functionality responsible for matching data tuples ("facts") against productions ("rules") in a pattern-matching production system (a category of rule engine). A production consists {{of one or}} more conditions and a set of actions which may be undertaken for each complete set of facts that match the conditions. Conditions test fact attributes, including fact type specifiers/identifiers. The <b>Rete</b> <b>algorithm</b> exhibits the following major characteristics: ...|$|E
50|$|The <b>Rete</b> <b>algorithm</b> {{is widely}} used to {{implement}} matching functionality within pattern-matching engines that exploit a match-resolve-act cycle to support forward chaining and inferencing.|$|E
40|$|The production-system {{language}} OPS 5 {{implemented in}} LISP with the MEA strategy and the <b>RETE</b> match <b>algorithm</b> {{is used for}} developing the Expert System (ES) IONIA. This is an ES for the prediction of thermal degradation processes, temperature of thermal degradation and degradation products of condensation polymers. The prediction {{is based on the}} structure of the polymers. The prototype for polyurethanes and polyureas is outlined {{as an example of how}} the system is functioning. The knowledge base used, both the chemical rules and the meta-rules, are discussed. The system makes an enhancement and change of the knowledge base possible. The advantages of IONIA in practical applications are presented. © 1991...|$|R
40|$|In {{this brief}} paper we report a simple scheme to extract {{implicit}} parallelism in the low-level match {{phase of the}} parallel execution of production system programs. The essence of the approach is to replicate rules while introducing new constraints within each copy to restrict each individual rule to match a potentially smaller set of data elements. Speed up is achieved by matching each copy of a rule in parallel. Variations of this approach may be applicable to logic-based programming systems, such as PROLOG, executed in a parallel environment. Indeed, sequential implementations of OPS-style production systems based on the <b>Rete</b> match <b>algorithm</b> may enjoy performance advantages as well. This scheme may be implemented by a simple preprocessing stage which requires no modification to the underlying match algorithms...|$|R
40|$|Rising {{interest}} in production systems {{has led to}} a number of research efforts aimed at increasing their execution speed. The bottleneck in current implementations is the matching required during each production cycle. CUPID is a multiprocessor architecture designed to execute OPS 5 matching using DRete, a distributed version of the <b>Rete</b> matching <b>algorithm.</b> This paper describes CUPID and the DRete algorithm with emphasis on correctness and effectiveness in exploiting parallelism in the match operation. The Monkey and Bananas program was executed on a CUPID simulator running the DRete algorithm. The results show that on a technology-independent comparison basis, and in measured execution speed, that the CUPID/DRete combination is several times faster than a commercial uniprocessor, a VAX 11 / 785, running compiled OPS 83. 1...|$|R
50|$|Conflict {{resolution}} is not defined {{as part of}} the <b>Rete</b> <b>algorithm,</b> but is used alongside the algorithm. Some specialised production systems do not perform conflict resolution.|$|E
50|$|The <b>Rete</b> <b>algorithm</b> {{does not}} define any {{approach}} to justification. Justification refers to mechanisms commonly required in expert and decision systems in which, at its simplest, the system reports {{each of the}} inner decisions used to reach some final conclusion. For example, an expert system might justify a conclusion that an animal is an elephant by reporting that it is large, grey, has big ears, a trunk and tusks. Some engines provide built-in justification systems in conjunction with their implementation of the <b>Rete</b> <b>algorithm.</b>|$|E
50|$|At {{its core}} is a {{reasoning}} engine {{based on an}} object-oriented implementation of the <b>Rete</b> <b>algorithm,</b> a very efficient mechanism for solving the difficult many-to-many matching problem.|$|E
40|$|CUCS- 174 - 85 In this brier {{paper we}} report a. simple scheme to extract {{implicit}} parallelism in the low-level match {{phase of the}} para. lle 1 execution of production system programs. The essence of the approach is to replicate rules while introducing new constraints within each copy to restrict each individual rule to match a potentially smaller set of data elements. Speed up is achieved by matching each copy of a rule in parallel. Variations of this approach may be applicable to logic-based programming systems, such as PROLOG, executed in a parallel environment. Indeed, sequential implementations of OPS-style production systems based on the <b>Rete</b> match <b>algorithm</b> may enjoy performance advantages as well. This scheme may be implemented by a simple preprocessing stage which requires no modification to the underlying match algorithms. ...|$|R
40|$|Abstract: This paper {{reports on}} the {{development}} of a new hybrid architecture that integrates Learning Classifier Systems (LCS) with Rete-based production systems inference engine to improve the performance of the process of compacting LCS generated rules. While LCS is responsible for generating a complete ruleset from a given breast cancer pathological data-set, an adapted Rete-based inference engine has been integrated for the efficient extraction of a minimal and representative ruleset from the original generated ruleset. This has resulted in an architecture that is hybrid, efficient, component-based, elegant, and extensible. Also, this has demonstrated significant savings in computing the match phase when building on the two main features of the <b>Rete</b> match <b>algorithm,</b> namely structural similarity and temporal redundancy. Finally, this architecture may be considered as a new platform for research on compaction of LCS rules using Rete-based inference engines...|$|R
40|$|Abstract: 2 ̆ 2 Conjunctive {{match is}} often used in Artificial Intelligence as the kernel of a pattern-directed {{inference}} [37] engine. Conjunctive match entails generating and testing all possible combinations of objects against a pattern of constraints. While simple to program, it is an expensive, exponential cost computation. To reduce this average match cost in production system engines, the <b>RETE</b> match <b>algorithm</b> [8] was devised. RETE compiles each rule 2 ̆ 7 s pattern of constraints into a network, and then incrementally updates partial matches as objects are inserted and deleted. RETE, however, has its own cost: conceptual and implementational complexity. Call-graph caching (CGC) [20] is a mechanism for transforming recursive specifications into highly optimized networks. In this paper, we describe CGC, {{and use it to}} transform a family of recursive conjunctive match formulations into their corresponding RETE networks. Our approach illustrates the ideas behind RETE, and shows their application to other algorithms. 2 ̆...|$|R
50|$|For a more {{detailed}} and complete description of the <b>Rete</b> <b>algorithm,</b> see chapter 2 of Production Matching for Large Learning Systems by Robert Doorenbos (see link below).|$|E
50|$|Dr Charles L. Forgy (born December 12, 1949 in Texas) is a {{computer}} scientist, known for developing the <b>Rete</b> <b>algorithm</b> used in his OPS5 and other production system languages used to build expert systems.|$|E
50|$|Drools is a {{business}} rule management system (BRMS) with a forward and backward chaining inference based rules engine, more correctly known as a production rule system, using an enhanced implementation of the <b>Rete</b> <b>algorithm.</b>|$|E
40|$|In {{rule-based}} AI planning, expert, {{and learning}} systems, {{it is often}} the case that the left-hand-sides of the rules must be repeatedly compared to the contents of some 'working memory'. The traditional approach to solve such a 'match phase problem' for production systems is to use the <b>Rete</b> Match <b>Algorithm.</b> Here, a new technique using a multilayer perceptron, a particular artificial neural network model, is presented to solve the match phase problem for rule-based AI systems. A syntax for premise formulas (i. e., the left-hand-sides of the rules) is defined, and working memory is specified. From this, it is shown how to construct a multilayer perceptron that finds all of the rules which can be executed for the current situation in working memory. The complexity of the constructed multilayer perceptron is derived in terms of the maximum number of nodes and the required number of layers. A method for reducing the number of layers to at most three is also presented...|$|R
40|$|In systems which learn a {{large number}} of rules (productions), it is {{important}} to match the rules efficiently, {{in order to avoid the}} machine learning utility problem [...] - if the learned rules slow down the matcher, the "learning" can slow the whole system down to a crawl. So we need match algorithms that scale well with the number of productions in the system. (Doorenbos, 1993) introduced right unlinking as a way to improve the scalability of the <b>Rete</b> match <b>algorithm.</b> In this paper we build on this idea, introducing a symmetric optimization, left unlinking, and demonstrating that it makes Rete scale well on an even larger class of systems. Unfortunately, when left and right unlinking are combined in the same system, they can interfere with each other. We give a particular way to combine them which we prove minimizes this interference, and analyze the worst-case remaining interference. Finally, we present empirical results showing that the interference is very small in practice, and that [...] ...|$|R
40|$|There are {{computer}} programs {{that use the}} same flow of control when run on different inputs. This redundancy in their program execution traces can be exploited by preserving suitably abstracted call-graphs for subsequent reuse. We introduce a new programming transformation Call-Graph Caching (CGC) which partially evaluates the control flow of sets of such programs into a network formed from their call-graphs. CGC can automatically generate efficient state-saving structure-sharing incremental algorithms from simple program specifications. As an example, we show how a straightforward, inefficient LISP program for conjunctive match is automatically transformed into the <b>RETE</b> network <b>algorithm.</b> Simple and understandable changes to elegant functional (and other) programs are automatically translated by CGC into new efficient incremental network algorithms; this abstraction mechanism is shown for a class of conjunctive matching algorithms. We establish criteria for the appropriate application of CGC to other AI methods, such as planning, chart parsing, consistency maintenance, and analogical reasoning...|$|R
