6|537|Public
50|$|The DoD Secure Kiosk (DSK) {{is a thin}} client-derived, custom-built, {{browsing}} appliance using a <b>run-time</b> <b>environment</b> (<b>RTE)</b> {{instead of}} an operating system to execute only the code it boots from read-only memory. It was designed by the Air Force Research Laboratory (AFRL) to be exceptionally secure, low-cost to purchase, and need no maintenance/updating.|$|E
40|$|We {{present the}} design and {{prototype}} implementation of a <b>run-time</b> <b>environment</b> (<b>RTE)</b> for the implicitly parallel execution of high-level languages. In our design a micro-kernel provides basic infrastructure, such as garbage collection, but all complex RTE operations, including the handling of parallelism, are implemented on a separate system level. By choosing a high-level language, (Concurrent) Haskell, as system-level language, we obtain a prototype {{in the form of}} an executable specification that is easier to maintain and more flexible than conventional RTEs. In particular, components can be easily replaced. We demonstrate the flexibility of this approach by presenting different variants of the scheduling component in our RTE. ...|$|E
40|$|Abstract. We {{present the}} design and {{prototype}} implementation of the scheduling component in ArTCoP (architecture transparent control of parallelism), a novel <b>run-time</b> <b>environment</b> (<b>RTE)</b> for parallel execution of high-level languages. A key feature of ArTCoP is its support for deep process and memory hierarchies, shown in the scheduler by supporting light-weight threads. To realise a system with easily exchangeable components, the system defines a micro-kernel, providing basic infrastructure, such as garbage collection. All complex RTE operations, including the handling of parallelism, are implemented at a separate system level. By choosing Concurrent Haskell as high-level system language, we obtain a prototype {{in the form of}} an executable specification that is easier to maintain and more flexible than conventional RTEs. We demonstrate the flexibility of this approach by presenting implementations of a scheduler for light-weight threads in ArTCoP, based on GHC Version 6. 6...|$|E
30|$|An {{alternative}} approach of WSN protocol and application development using the general purpose processor {{is to use}} virtual <b>run-time</b> <b>environment</b> instead of event-based OS such as TinyOS. The virtual <b>run-time</b> <b>environment</b> facilitates application development in higher level programming languages such as Java and C# as in IBM’s Moterunner[4]. Though virtual <b>run-time</b> <b>environment</b> offers rapid application development, it is slower and requires more hardware resources than the operating system based solutions such as TinyOS to accomplish {{the same amount of}} tasks.|$|R
5000|$|SAFIRE Integrated Development & <b>Run-Time</b> <b>Environment</b> (COMMERCIAL) ...|$|R
5000|$|... #Subtitle level 2: Janus Platform: a SARL <b>Run-time</b> <b>Environment</b> ...|$|R
40|$|Abstract—As current studies show, in {{the last}} couple of years {{software}} functionality of modern cars has increased dramatically. This growth will gradually increase the system complexity, because the new functionality is more and more interconnected. To cope with this process, it is necessary to change the current electrics and electronics (E/E) architecture. An adequate <b>run-time</b> <b>environment</b> (<b>RTE)</b> is the heart of such a new E/E architecture and orchestrates the interaction and communication between the components in such systems. Due to high safety requirements of modern driver assistance, the RTE must also provide built-in safety features. This paper analyses these requirements and derives a set of software modules of an RTE that enforce the safety critical behavior of the entire system. The suggested software architecture can act as a blueprint for other run-time environments that deal with similar requirements. The proposed concept has been integrated in the RTE, that is developed in the RACE project 1. Keywords-embedded systems, automotive systems, safety-critical systems, middleware, components and reusability, safety, fault tolerance I...|$|E
40|$|Standardization {{efforts in}} {{e-learning}} {{are aimed at}} achieving interoperability among Learning Management Systems (LMSs) and Learning Object (LO) authoring tools. Some of the specifications produced have reached quite a good maturity level and have been adopted in software systems. Some others, such as SCORM <b>Run-Time</b> <b>Environment</b> (<b>RTE),</b> have not reached the same success, probably due to their intrinsic difficulty in being understood adequately and implemented properly. The SCORM RTE defines a set of functionalities which allow LOs to be launched in the LMS and to exchange data with it. Its adoption is crucial in the achievement of full interoperability among LMSs and LO authoring tools. In order to boost the adoption of SCORM RTE in LMSs, we propose a Service Oriented Architecture (SOA) -based reference model for offering the SCORM RTE functionalities as a service, external to the LMS. By externalizing functionalities from LMSs, our model encourages the independent development of e-learning system components, allowing e-learning software producers to gain several benefits, such as better software re-use and easier integration and complexity management, with a consequent cost reduction. The proposed model is validated through a prototype system, in which a popular LMS, developed with PHP language, is enhanced {{with the support of}} SCORM RTE functionalities, provided by an external Web service based on Java technology...|$|E
40|$|Abstract—The {{high-performance}} computing (HPC) commu-nity {{continues to increase}} the size and complexity of hardware platforms that support advanced scientific workloads. The <b>run-time</b> <b>environment</b> (<b>RTE)</b> is a crucial layer in the software stack for these large-scale systems. The RTE manages the interface between the operating system and the application running in parallel on the machine. The deployment of applications and tools on large-scale HPC computing systems requires the RTE to manage process creation in a scalable manner, support sparse connectivity, and provide fault tolerance. We have developed a new RTE that provides a basis for building distributed execution environments and developing tools for HPC to aid research in system software and resilience. This paper describes the software architecture of the Scalable runTime Component Infrastructure (STCI), which is intended to provide a complete infrastructure for scalable start-up and management of many processes in large-scale HPC systems. We highlight features of the current implementation, which is provided as a system library that allows developers to easily use and integrate STCI in their tools and/or applications. The motivation for this work has been to support ongoing research activities in fault-tolerance for large-scale systems. We discuss {{the advantages of the}} modular framework employed and describe two use cases that demonstrate its capabilities: (i) an alternate runtime for a Message Passing Interface (MPI) stack, and (ii) a distributed control and communication substrate for a fault-injection tool. I...|$|E
5000|$|<b>Run-time</b> <b>environment</b> (including {{parameter}} passing, symbol {{tables and}} register allocation) ...|$|R
50|$|Cygwin {{provides}} a largely POSIX-compliant development and <b>run-time</b> <b>environment</b> for Microsoft Windows.|$|R
5000|$|Supports both XML-based {{and native}} PHP-coded {{configuration}} of application and <b>run-time</b> <b>environments</b> ...|$|R
2500|$|Run-time environment: JavaScript {{typically}} {{relies on}} a <b>run-time</b> <b>environment</b> (e.g., a Web browser) to provide objects and methods by which scripts can interact with the environment (e.g., a webpage DOM). It also relies on the <b>run-time</b> <b>environment</b> to provide the ability to include/import scripts (e.g., HTML [...] elements). This is not a language feature per se, but it is common in most JavaScript implementations.|$|R
50|$|OpenLaszlo Server is a Java servlet that compiles LZX {{applications}} into executable binaries for targeted <b>run-time</b> <b>environments.</b>|$|R
40|$|Portability of {{programs}} between <b>run-time</b> <b>environments</b> {{is regarded as}} a desirable feature by programmers and users. In a modern virtual machine like the JVM, portability is supported by large standard libraries. A program that uses an interface from a standard library should be portable to any <b>run-time</b> <b>environment</b> that provides an implementation of the interface. Because different implementations of an interface have different names, a programmer who desires portability must write code to select an implementation. This introduces software engineering costs and type-safety concerns. We believe that dynamic linking is well-suited to providing portability automatically. Link-ing traditionally requires that types from the compile-time environment are present in the <b>run-time</b> <b>environment.</b> We suggest “flexible ” dynamic linking that relaxes a program’s depen-dencies on compile-time types in a type-safe and language-independent way, thus providing portability to different <b>run-time</b> <b>environments.</b> Bytecode is annotated with type variables rather than type names, and a non-deterministic model substitutes type variables with type names during linking. We interleave linking with execution, as in the JVM, and examin...|$|R
5000|$|The <b>run-time</b> <b>environment</b> can {{run your}} {{application}} as an applet, in a JUnit environment or in a command-line window ...|$|R
5000|$|<b>Run-Time</b> <b>Environment</b> - {{describes}} runtime API {{and data}} model used for communication between content objects and learning management systems ...|$|R
2500|$|There is no {{built-in}} I/O functionality in JavaScript; the <b>run-time</b> <b>environment</b> provides that. The ECMAScript specification in edition 5.1 mentions: ...|$|R
50|$|XULJet is an {{open-source}} JavaScript {{framework for}} the Mozilla XULRunner <b>run-time</b> <b>environment.</b> It is intended for writing desktop applications in pure JavaScript.|$|R
40|$|We {{describe}} two things. First, {{we present}} a uniform framework for object oriented specification and verification of hardware. For this purpose the object oriented language `e' is introduced along with a powerful <b>run-time</b> <b>environment</b> that enables the designer to perform the verification task. Second, {{we present a}}n object oriented synthesis that enhances `e' and its dedicated <b>run-time</b> <b>environment</b> into a framework for specification, verification, and synthesis. The usability of our approach is demonstrated by realworld examples...|$|R
30|$|The {{proposed}} SAViNE framework {{has been}} {{integrated with the}} OpenLab experimental facilities, providing a <b>run-time</b> <b>environment</b> for CDN deployment, operation, and performance evaluation.|$|R
40|$|Current {{e-learning}} standardization {{initiatives have}} put much effort into easing interoperabil-ity between {{systems and the}} reusability of contents. For this to be possible, {{one of the most}} relevant areas is the definition of a <b>run-time</b> <b>environment</b> which allows Learning Manage-ment Systems to launch, track and communicate with learning objects. However, when dealing with intelligent content, these environments show important restrictions. In this paper, we study these restrictions, comparing several standardized <b>run-time</b> <b>environments</b> with non-standardized solutions that aim to overcome these constraints...|$|R
50|$|The SARL agent-oriented {{programming}} {{language is a}} language with native support for the concept of holon. The associated <b>run-time</b> <b>environment</b> Janus enables running the implemented holons.|$|R
40|$|Abstract [...] Software {{components}} are specially built software units {{that can be}} reused most efficiently and independently from their development environments. Although specifications are mandatory, user of components cannot depend on how the {{components are}} developed because they cannot be tested or debugged like {{they are supposed to}} be in development environment. Improving development processes and software engineering are crutial but there are big gaps between development <b>environment</b> and <b>run-time</b> <b>environments.</b> This paper studies the inter-component interfaces and the capabilities of assembling components into component software on-the-fly at run-time. First, programmer will have to shift his attentions to <b>run-time</b> <b>environments</b> in order to minimize risks of application failures and to maximize programming efficiency. The Application Run-time Life Cycle Model captures and provides application contexts, which are combinations of component contexts. The model also has the ability of adapting to different <b>run-time</b> <b>environments</b> by packing necessary information into a Component Run-time Integration Box. The benefits are that, component reuse and the efficiency of component software are emphasized...|$|R
50|$|API {{documentation}} can be enriched with metadata information like Java annotations. This metadata {{can be used}} by the compiler, tools, and by the <b>run-time</b> <b>environment</b> {{to implement}} custom behaviors or custom handling.|$|R
40|$|Withtheshifttomany-corechipmultiprocessors(CMPs),acritical {{issue is}} how to {{effectively}} coordinate and manage the execution of applications and hardware resources to overcome performance, power consumption, and reliability challenges stemming from hardwareandapplicationvariationsinherentinthisnewcomputing environment. Effective resource and application management on CMPsrequiresconsideration ofuser/application/hardware-specific requirements and dynamic adaption of management decisions based on the actual <b>run-time</b> <b>environment.</b> However, designing an algorithm to manage resources and applications that can dynamically adapt based on the <b>run-time</b> <b>environment</b> is difficult because most resource and application management and monitoring facilities are only available at the operating system level. This paper presents REEact, an infrastructure that provides the capability t...|$|R
40|$|Abstract. This paper {{describes}} an implemented {{system that is}} designed to sup-port the deployment of applications offering distributed services, comprising a number of distributed components. This is achieved by creating high level placement and topology descriptions that drive tools to deploy applications consisting of components running on multiple hosts. The system addresses is-sues of heterogeneity by providing abstractions over host-specific attributes yielding a homogeneous <b>run-time</b> <b>environment</b> into which components may be deployed. The <b>run-time</b> <b>environments</b> provide secure binding mechanisms that permit deployed components to bind to stored data and services on the hosts on which they are running. ...|$|R
50|$|The WebSocket {{protocol}} {{is implemented}} in different web browsers, web servers, and <b>run-time</b> <b>environments</b> and libraries acting as clients or servers. The {{following is a}} table of different features of notable WebSocket implementations.|$|R
50|$|The netBook {{runs the}} EPOC ER5 {{operating}} system (the predecessor of SymbianOS). Unlike the Psion Series 7, the netBook operating system runs from RAM. A Java <b>run-time</b> <b>environment,</b> conforming to Java version 1.1.8, is available.|$|R
40|$|This paper {{describes}} an implemented system {{which is designed}} to support the deployment of applications offering distributed services, comprising a number of distributed components. This is achieved by creating high level placement and topology descriptions which drive tools that deploy applications consisting of components running on multiple hosts. The system addresses issues of heterogeneity by providing abstractions over host-specific attributes yielding a homogeneous <b>run-time</b> <b>environment</b> into which components may be deployed. The <b>run-time</b> <b>environments</b> provide secure binding mechanisms that permit deployed components to bind to stored data and services on the hosts on which they are running. Comment: 2 nd International Working Conference on Component Deployment (CD 2004), Edinburgh, Scotlan...|$|R
5000|$|Run-time {{autonomy}} {{refers to}} the extent of the control that a service has over the way its solution logic is processed by the <b>run-time</b> <b>environment.</b> The more control a service has over its <b>run-time</b> <b>environment,</b> the more predictable is its behavior. Run-time autonomy is achieved by providing dedicated processing resources to the service. For example, if the service logic performs memory intensive tasks then the service could be deployed to a server with reserved or conserved resources. Similarly, by providing locally cached copies of data, where applicable, the service’s dependency on a remote shared database can be reduced. As a result, the overall autonomy of the service is increased...|$|R
40|$|Abstract. High {{performance}} computing platforms are becoming larger, leading to scalability and fault-tolerance issues for both applications and runtime <b>environments</b> (<b>RTE)</b> dedicated {{to run on}} such machines. After being deployed, usually following a spanning tree, a RTE needs to build its own communication infrastructur...|$|R
30|$|Language support. The use of {{language}} based techniques for protecting information has as its most prominent example the security mechanism implemented by the Java <b>run-time</b> <b>environment,</b> which defines a set of security policies for applets [30, 54].|$|R
50|$|A few {{commercial}} game engines target Flash Player (Stage3D) as <b>run-time</b> <b>environment,</b> such as Unity 3D and Unreal Engine 3. Before {{the introduction}} of Stage3D, a number of older 2D engines or isometric engines like Flixel saw their heyday.|$|R
40|$|Research Interests Areas of {{research}} interest span data mining and machine learning algorithms, high-performance data-intensive computing, parallel and distributed systems for Cloud and Grid computing. More specifically, developing high-performance data mining algorithms and researching efficient <b>run-time</b> <b>environments</b> in Cloud and Grid systems...|$|R
5000|$|Most dynamic {{languages}} are also dynamically typed, {{but not all}} are. Dynamic {{languages are}} frequently (but not always) referred to as [...] "scripting languages", although the term [...] "scripting language" [...] in its narrowest sense refers to languages specific to a given <b>run-time</b> <b>environment.</b>|$|R
