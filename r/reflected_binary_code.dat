9|5274|Public
50|$|The <b>reflected</b> <b>binary</b> <b>code</b> (RBC), {{also known}} as Gray code after Frank Gray, is a binary numeral system where two {{successive}} values differ in only one bit (binary digit).The <b>reflected</b> <b>binary</b> <b>code</b> was originally designed to prevent spurious output from electromechanical switches. Today, Gray codes are widely used to facilitate error correction in digital communications such as digital terrestrial television and some cable TV systems.|$|E
5000|$|... #Caption: Part of {{front page}} of Gray's patent, showing PCM tube (10) with <b>reflected</b> <b>binary</b> <b>code</b> in plate (15) ...|$|E
5000|$|The <b>reflected</b> <b>binary</b> <b>code</b> solves {{this problem}} by {{changing}} only one switch at a time, so there is never any ambiguity of position, ...|$|E
5000|$|<b>Reflected</b> <b>binary</b> <b>codes</b> {{were applied}} to {{mathematical}} puzzles before they became known to engineers. Martin Gardner wrote a popular account of the Gray code in his August 1972 Mathematical Games column in Scientific American. The French engineer Émile Baudot used Gray codes in telegraphy in 1878. [...] He received the French Legion of Honor medal for his work. The Gray code is sometimes attributed, incorrectly, to Elisha Gray.|$|R
40|$|On <b>binary</b> <b>reflected</b> Gray <b>codes</b> and {{functions}} The <b>Binary</b> <b>Reflected</b> Gray <b>Code</b> function b {{is defined as}} follows: If m is a nonnegative integer, then b(m) is the integer obtained when initial zeros are omitted from the <b>binary</b> <b>reflected</b> Gray <b>code</b> of length m. This paper examines this Gray code function and its inverse and gives simple algorithms to generate both. It also simplifies Conder’s result that the jth letter of the kth word of the <b>binary</b> <b>reflected</b> Gray <b>code</b> of length n, is (2 n − 2 n−j − 1 [2 n − 2 n−j− 1 − k/ 2]) mod 2, by replacing the binomial coefficient by [(k- 1) /(2 n-j+ 1) + 1 / 2]...|$|R
40|$|AbstractThe <b>binary</b> <b>reflected</b> Gray <b>code</b> {{function}} b {{is defined}} as follows: If m is a nonnegative integer, then b(m) is the integer obtained when initial zeros are omitted from the <b>binary</b> <b>reflected</b> Gray <b>code</b> of m. This paper examines this Gray code function and its inverse and gives simple algorithms to generate both. It also simplifies Conder's result that the jth letter of the kth word of the <b>binary</b> <b>reflected</b> Gray <b>code</b> of length n is 2 n- 2 n-j- 1 ⌊ 2 n- 2 n-j- 1 -k/ 2 ⌋mod 2 by replacing the binomial coefficient by k- 12 n-j+ 1 + 12...|$|R
50|$|The Gray code, or <b>reflected</b> <b>binary</b> <b>code,</b> {{appearing}} in Gray's 1953 patent, is a binary numeral system {{often used in}} electronics, but with many applications in mathematics.|$|E
5000|$|Frank Gray, {{who became}} famous for inventing the {{signaling}} method {{that came to}} be used for compatible color television, invented a method to convert analog signals to <b>reflected</b> <b>binary</b> <b>code</b> groups using vacuum tube-based apparatus. The method and apparatus were patented in 1953 and the name of Gray stuck to the codes. The [...] "PCM tube" [...] apparatus that Gray patented was made by Raymond W. Sears of Bell Labs, working with Gray and William M. Goodall, who credited Gray for the idea of the <b>reflected</b> <b>binary</b> <b>code.</b>|$|E
50|$|The <b>reflected</b> <b>binary</b> <b>code,</b> {{also known}} as the Gray code, is closely related to binary numbers, but some bits are inverted, {{depending}} on the parity of the higher order bits.|$|E
40|$|The <b>Binary</b> <b>Reflected</b> Gray <b>Code</b> {{function}} b {{is defined}} as follows: If m is a nonnegative integer, then b(m) is the integer obtained when initial zeros are omitted from the <b>binary</b> <b>reflected</b> Gray <b>code</b> of length m. This paper examines this Gray code function and its inverse and gives simple algorithms to generate both. It also simplifies Conder’s result that the jth letter of the kth word of the <b>binary</b> <b>reflected</b> Gray <b>code</b> of length n, is (2 n − 2 n−j − 1 [2 n − 2 n−j− 1 − k/ 2]) mod 2, by replacing the binomial coefficient by [(k- 1) /(2 n-j+ 1) + 1 / 2]...|$|R
40|$|Abstract. The {{problem of}} {{constructing}} quasi equidistant and <b>reflected</b> <b>binary</b> Gray <b>code</b> sequences and code in a mixed factorial, Fibonacci and binomial numeration systems is {{considered in the}} article. Some combinatorial constructions and machine algorithms synthesis sequences, based on the method of directed enumeration are offered. For selected parameters of sequences all quasi equidistant (for individual cases- reflected) codes with Hamming distance equal to 1 are found...|$|R
40|$|AbstractIt {{is shown}} that for 1 ⩽ j ⩽ n and 1 ⩽ k ⩽ 2 ″, the jth {{letter of the}} kth word of the <b>binary</b> <b>reflected</b> Gray <b>code</b> of length n {{is equal to the}} parity of the {{binomial}} coefficient 2 n− 2 n−j− 1 C[2 n− 2 n−j− 1 −k/ 2] modulo 2. Also it is shown how this observation and the usual iterative definition of the <b>binary</b> <b>reflected</b> Gray <b>codes</b> are revealed in a modified version of Sierpinski's gasket (Pascal's triangle modulo 2) ...|$|R
5000|$|Bits D2 (msbit) through B4 (lsbit) encode the {{pressure}} altitude in 500 ft increments (above a base altitude of −1000±250 ft) {{in a standard}} 8-bit <b>reflected</b> <b>binary</b> <b>code</b> (Gray code). [...] The specification stops at code 1000000 (126500±250 ft), above which D1 would be needed as a most significant bit.|$|E
5000|$|Bell Labs {{researcher}} Frank Gray {{introduced the}} term <b>reflected</b> <b>binary</b> <b>code</b> in his 1947 patent application, remarking that the code had [...] "as yet no recognized name". [...] He derived the {{name from the}} fact that it [...] "may be built up from the conventional binary code by a sort of reflection process".|$|E
50|$|In Gray code, {{also known}} as <b>reflected</b> <b>binary</b> <b>code,</b> state are {{assigned}} such that consecutive state codes differ by only one bit. In this encoding also the relationship between number of bits {{and the number of}} states is defined by b = log2(n)Number of flips-flops used and the complexity of the decoding logic is same as Binary encoding. But the hamming distance in Gray code is always 1.|$|E
40|$|It {{is shown}} that for 1 # j # n and 1 # k # 2 n; the jth {{letter of the}} kth word of the <b>binary</b> <b>reflected</b> Gray <b>code</b> of length n {{is equal to the}} parity of the {{binomial}} coefficient 2 n # 2 n#j # 1 C # 2 n # 2 n#j# 1 #k= 2 # modulo 2. Also it is shown how this observation and the usual iterative definition of the <b>binary</b> <b>reflected</b> Gray <b>codes</b> are revealed in a modified version of Sierpinski's gasket (Pascal's triangle modulo 2) ...|$|R
5000|$|... /* * This {{function}} converts an unsigned binary * {{number to}} <b>reflected</b> <b>binary</b> Gray <b>code.</b> * * The operator >> is shift right. The operator ^ is exclusive or. */unsigned int binaryToGray(unsigned int num){ return num ^ (num >> 1);}/* * This function converts a <b>reflected</b> <b>binary</b> * Gray <b>code</b> number to a binary number. * Each Gray code bit is exclusive-ored with all * more significant bits. */unsigned int grayToBinary(unsigned int num){ unsigned int mask; for (mask = num >> 1; mask != 0; mask = mask >> 1) { num = num ^ mask; } return num;}/* * A more efficient version, for Gray codes of 32 or fewer bits. */unsigned int grayToBinary32(unsigned int num){ num = num ^ (num >> 16); num = num ^ (num >> 8); num = num ^ (num >> 4); num = num ^ (num >> 2); num = num ^ (num >> 1); return num;} ...|$|R
40|$|It {{is shown}} that for 1 j n and 1 k 2 n; the jth {{letter of the}} kth word of the <b>binary</b> <b>reflected</b> Gray <b>code</b> of length n {{is equal to the}} parity of the {{binomial}} coefficient 2 n Γ 2 nΓ 1 C [2 n Γ 2 nΓ 1 = 2] modulo 2. Also it is shown how this observation and the usual iterative definition of the <b>binary</b> <b>reflected</b> Gray <b>codes</b> are revealed in a modified version of Sierpinski's gasket (Pascal's triangle modulo 2). 1 Introduction A Gray code of length n is a sequence of n-bit strings (which we shall call words) of letters from some alphabet, with the property that each word differs from the next in just one position. The most celebrated of these <b>codes</b> are the <b>binary</b> <b>reflected</b> Gray <b>codes</b> G n, which may be defined inductively as follows: G 1 consists of the words 0 and 1 (in that order), and G n+ 1 is obtainable by first listing G n with each word prefixed by 0 and then listing G n in reverse order with each word prefixed by 1. For example, G 2 = [...] ...|$|R
40|$|This paper investigates optimal {{constellation}} labeling in {{the context}} of the edge profile. A constellation's edge profile lists the minimum-distance edge for each binary symbol error. The paper introduces the symmetric-ultracomposite (SU) labeling structure and shows that this structure provides undominated edge profiles for -point square QAM. The SU structure is a generalization of the commonly used <b>reflected</b> <b>binary</b> Gray <b>code.</b> With the proper choice of basis vectors, SU labeling can support either set-partition or Gray-code labeling of -point square QAM. Notably, there are Gray-code and set-partition labelings that do not have the SU structure. These labelings yield inferior edge profiles...|$|R
40|$|The {{problem of}} calculating the average bit-error {{probability}} (BER) of coherent M-ary {{phase shift keying}} (PSK) over a Gaussian channel has been studied previously in the literature. A {{solution to the problem}} for systems using a <b>binary</b> <b>reflected</b> Gray <b>code</b> (BRGC) to map bits to symbols was first presented by Lee in [1]...|$|R
40|$|Abstract- Parallel {{algorithms}} of the hypercube allo-cation {{strategies are}} considered in this paper. Although the sequential algorithms of various hypercube alloca-tion strategies {{are easier to}} implement, their worst case time complexities exponentially increase as the dimension of the hypercube increases. We show that the free processors can be utilized t o perform the allo-cation jobs in parallel to improve the. eficiency of the hypercube allocation algorithms. A modified parallel algorithm for the single GC strategy is proposed and is shown {{to be able to}} recognize more subcubes than the single GC strategy by using the <b>binary</b> <b>reflected</b> Gray <b>code</b> and inverse <b>binary</b> <b>reflected</b> Gray <b>code,</b> without increasing the execution time. Two algorithms for a complete subcube recognition system are also presented and shown t o be more efficient and attractive than the sequential one currently used in the hypercube multi-processor. ...|$|R
40|$|Three {{equivalent}} methods of generating the paperfolding sequence are pre-sented {{as well as}} a categorisation of runs of identical terms. We find all repeated subsequences, the largest repeated subsequences and the spacing of singles, doubles and triples throughout the sequence. The paperfolding sequence is shown to have links to the <b>Binary</b> <b>Reflected</b> Gray <b>Code</b> and the Stern-Brocot tree. 1...|$|R
40|$|We {{show that}} the {{ordering}} used in the sorting stage of the Burrows-Wheeler transform, an aspect hitherto ignored, can {{have a significant impact}} on the size of the compressed data. We present experimental results showing smaller compressed output achieved with two modifications to the sorting: using a better alphabet ordering and reflecting the sorted strings as in <b>binary</b> <b>reflected</b> Gray <b>coding...</b>|$|R
40|$|In {{this paper}} we {{introduce}} a natural mathematical structure derived from Samuel Beckett's play "Quad". We call this structure a <b>binary</b> Beckett-Gray <b>code.</b> We enumerate all codes for n ≤ 6 and give examples for n= 7, 8. Beckett-Gray codes {{can be realized}} as successive states of a queue data structure. We show that the <b>binary</b> <b>reflected</b> Gray <b>code</b> can be realized as successive states of two stack data structures. Comment: 6 pages, 3 tables. Revisions requested from Journal of Combinatorial Mathematics and Combinatorial Computin...|$|R
40|$|A <b>binary</b> <b>reflected</b> Gray <b>code</b> (Gray {{code for}} short) is a {{one-to-one}} function G(i) of the integers 0 • i • 2 n – 1 (for some pre-selected value of n) to binary numbers {{such that the}} binary number for G(i) and G(i+ 1) differ in exactly one bit. For example, with N = 3, the Gray <b>codes</b> (written in <b>binary)</b> are 000, 001...|$|R
40|$|Abstract. The {{permutation}} {{associated with}} the decimal expression of the <b>binary</b> <b>reflected</b> Gray <b>code</b> with N bits is considered. Its cycle structure is studied. Considered {{as a set of}} points, its self-similarity is pointed out. As a fractal, it is shown to be the attractor of a IFS. For large values of N the set is examined {{from the point of view}} of time series analysis...|$|R
5000|$|Although the <b>binary</b> <b>reflected</b> Gray <b>code</b> {{is useful}} in many scenarios, it is not optimal in certain cases {{because of a lack}} of [...] "uniformity". In {{balanced}} Gray codes, the number of changes in different coordinate positions are as close as possible. To make this more precise, let G be an R-ary complete Gray cycle having transition sequence the transition counts (spectrum) of G are the collection of integers defined by ...|$|R
40|$|The optimal bit-wise {{demodulator}} for M-ary {{pulse amplitude}} modulation (PAM) over the additive white Gaussian noise channel is analyzed in terms of uncoded bit-error rate (BER). New closed-form BER expressions for 4 -PAM with any labeling are developed. Moreover, closed-form BER expressions for 11 out of 23 possible bit patterns for 8 -PAM are presented, which enable us to obtain the BER for 8 -PAM {{with some of the}} most popular labelings, including the <b>binary</b> <b>reflected</b> Gray <b>code</b> and the natural <b>binary</b> <b>code.</b> Numerical results show that, regardless of the labeling, there is no difference between the optimal demodulator and the symbol-wise demodulator for any BER of practical interest (below 0. 1) ...|$|R
40|$|The {{generalized}} {{mutual information}} (GMI) is an achievable rate for bit-interleaved coded modulation (BICM) and is {{highly dependent on}} the binary labeling of the constellation. The BICM-GMI, sometimes called the BICM capacity, can be evaluated numerically. This approach, however, becomes impractical {{when the number of}} constellation points and/or the constellation dimensionality grows, or when many different labelings are considered. A simple approximation for the BICM-GMI based on the area theorem of the demapper's extrinsic information transfer (EXIT) function is proposed. Numerical results show the proposed approximation gives good estimates of the BICM-GMI for labelings with close to linear EXIT functions, which includes labelings of common interest, such as the natural <b>binary</b> <b>code,</b> <b>binary</b> <b>reflected</b> Gray <b>code,</b> etc. This approximation is used to optimize the binary labeling of the 32 -APSK constellation defined in the DVB-S 2 standard. Gains of approximately 0. 15 dB are obtained...|$|R
40|$|A Gray code is a Hamilton path H on the n-cube, Qn. By {{labeling}} each edge of Qn {{with the}} dimension that changes between its incident vertices, a Gray code {{can be thought}} of as a sequence H = t 1; t 2; : : :; t N- 1 (with N = 2 n and each t i satisfying 1 t i n). The sequence H defines an (undirected) graph of transitions, GH, whose vertices are f 1; 2; : : :; ng and with edge set E(GH) = f[t i; t i+ 1] j 1 i N - 1 g. A G-code is a Hamilton path H whose graph of transitions is a subgraph of G; if H is a Hamilton cycle then it is a cyclic G-code. The classic <b>binary</b> <b>reflected</b> Gray <b>code</b> is a cyclic K 1;n -code. We prove that every tree T of diameter 4 has a T-code, and that no tree T of diameter 3 has a T-code. 1 Introduction The utility of the ubiquitous <b>binary</b> <b>reflected</b> Gray <b>code</b> is undisputed. See, for example, the books of Nijenhuis and Wilf [5], Reingold, Nievergelt, and Deo [6], and Wilf [8]. For certain applications, however, other Gray codes are desired. Many other [...] ...|$|R
40|$|This paper investigates optimal {{constellation}} labeling in {{the context}} of the edge profile. A constellation’s edge profile lists the minimum-distance edge for each binary symbol error. The paper introduces the symmetric-ultracomposite (SU) labeling structure and shows that this structure provides undominated edge profiles for 2 -PSK, 2 -PAM, and 22 -point square QAM. The SU structure is a generalization of the commonly used <b>reflected</b> <b>binary</b> Gray <b>code.</b> With the proper choice of basis vectors, SU labeling can support either set-partition or Gray-code labeling of 2 -PSK, 2 -PAM, and 22 -point square QAM. Notably, there are Gray-code and set-partition labelings that do not have the SU structure. These labelings yield inferior edge profiles. The SU structure does not apply to cross constellations. However, for any standard cross constellation with 32 or more points, a quasi-SU labeling structure can approximate the SU structure. With the correct choice of basis, quasi-SU labelings produce quasi-Gray labelings. However, the quasi-SU structure cannot support set-partition labeling. In fact, the quasi-SU structure provides a better edge profile than standard set-partition labeling. Thus, for cross constellations there is a choice between edge profile optimality and the group structure provided by set-partitioning. Here, the correct choice depends on whether the encoder trellis has parallel branches...|$|R
40|$|Choosing a good {{representation}} {{is a vital}} component of solving any search problem. However, choosing a good representation for a problem is as difficult as choosing a good search algorithm for a problem. Wolpert and Macready's No Free Lunch theorem proves that no search algorithm is {{better than any other}} over all possible discrete functions. We elaborate on the No Free Lunch theorem by proving that there tend to be a small set of points that occur as local optima under almost all representations. Along with the analytical results, we provide some empirical evaluation of two representations commonly used in genetic algorithms: <b>Binary</b> <b>Reflected</b> Gray <b>coding</b> and standard <b>Binary</b> encoding...|$|R
40|$|International audienceIn {{this paper}} we study {{the problem of}} the whole mirror duplication-random loss model in terms of pattern {{avoiding}} permutations. We prove that the class of permutations obtained with this model after a given number p of duplications of the identity is the class of permutations avoiding the alternating permutations of length p 2 + 1. We also compute the number of duplications necessary and sufficient to obtain any permutation of length n. We provide two efficient algorithms to reconstitute a possible scenario of whole mirror duplications from identity to any permutation of length n. One of them uses the well-known <b>binary</b> <b>reflected</b> Gray <b>code</b> (Gray, 1953). Other relative models are also considered...|$|R
40|$|In {{this paper}} we {{formally}} analyze the interleaver and code design for QAM-based BICM transmissions using the <b>binary</b> <b>reflected</b> Gray <b>code.</b> We develop analytical bounds on the {{bit error rate}} and we use them to predict the performance of BICM when unequal error protection (UEP) is introduced by the constellation labeling. Based on these bounds the optimum design of interleaver and code is found, and numerical results for representative configurations are presented. When the new design is used, the improvements may reach 2 dB, and they are obtained without any increase on the transceiver's complexity. We also introduce the concept of generalized optimum distance spectrum convolutional codes, which are the optimum codes for QAM-based BICM transmissions...|$|R
40|$|The {{problem of}} calculating the average bit-error {{probability}} (BEP) of coherent M-ary phase-shift keying (PSK) over a Gaussian channel {{has been studied}} previously in the literature. A {{solution to the problem}} for systems using a <b>binary</b> <b>reflected</b> Gray <b>code</b> (BRGC) to map bits to symbols was first presented by Lee. In this letter, we show that the results obtained by Lee are incorrect for M {{greater than or equal to}} 16. We show that the reason for this is an invalid assumption that the bit-error rate (BER) is independent of the transmitted symbols, an assumption which has also propagated to textbooks. We give a new expression for the BER of M-PSK systems using the BRGC and compare this with Lee's results...|$|R
40|$|The {{purpose of}} this paper is to present a new and faster {{algorithmic}} procedure for generating the n bi Gray codes. Thereby, through this paper we have presented the derivation, design and implementation of a newly developed algorithm for the generation of an n-bit <b>binary</b> <b>reflected</b> Gray <b>code</b> sequences. The developed algorithm is stemmed from the fact of generating and properly placing the min-terms from the universal set of all the possible min-terms [m 0 m 1 m 2 …. mN] of Boolean function of n variables, where, 0 < N <  2 n- 1. The resulting algorithm is in concise form and trivial to implement. Furthermore, the developed algorithm is equipped with added attributes of optimizing of time and space while executed...|$|R
