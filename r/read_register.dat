3|175|Public
5000|$|The branch {{resolution}} recurrence {{goes through}} {{quite a bit}} of circuitry: the instruction cache <b>read,</b> <b>register</b> file read, branch condition compute (which involves a 32-bit compare on the MIPS CPUs), and the next instruction address multiplexer.|$|E
40|$|The PCA 9655 E {{provides}} 16 bits of General Purpose parallel Input / Output (GPIO) expansion {{through the}} I 2 C−bus / SMBus. The PCA 9655 E {{consists of two}} 8 −bit Configuration (Input or Output selection); Input, Output and Polarity Inversion (active−HIGH or active−LOW operation) registers. At power on, all I/Os default to inputs. Each I/O may be configured as either input or output by writing to its corresponding I/O configuration bit. The data for each Input or Output is kept in its corresponding Input or Output register. The Polarity Inversion register {{may be used to}} invert the polarity of the <b>read</b> <b>register.</b> All registers can be read by the system master. The PCA 9655 E provides an open−drain interrupt output which is activated when any input state differs from its corresponding input port register state. The interrupt output is used to indicate to the system master that an input state has changed. The power−on reset sets the registers to their default values and initializes the device state machine. Three hardware pins (AD 0, AD 1, AD 2) are used to configure the I 2 C−bus slave address of the device. Up to 64 devices are allowed to share the same I 2 C−bus / SMBus...|$|E
40|$|I 2 C−bus / SMBus. The PCA 9535 E and PCA 9535 EC {{consist of}} two 8 −bit Configuration (Input or Output selection); Input, Output and Polarity Inversion (active−HIGH or active−LOW operation) registers. At power on, all I/Os default to inputs. Each I/O may be {{configured}} as either input or output by writing to its corresponding I/O configuration bit. The data for each Input or Output {{is kept in}} its corresponding Input or Output register. The Polarity Inversion register {{may be used to}} invert the polarity if the <b>read</b> <b>register.</b> All registers can be read by the system master. The PCA 9535 E, identical to the PCA 9655 E but with the internal I/O pull−up resistors removed, has greatly reduced power consumption when the I/Os are held LOW. The PCA 9535 EC is identical to the PCA 9535 E but with high−impedance open−drain outputs at all the I/O pins. The PCA 9535 E and PCA 9535 EC provide an open−drain interrupt output which is activated when any input state differs from its corresponding input port register state. The interrupt output is used to indicate to the system master that an input state has changed. The power−on reset sets the registers to their default values and initializes the device state machine. Three hardware pins (AD 0, AD 1, AD 2) are used to configure the I 2 C−bus slave address of the device. The I 2 C−bus slave addresses of the PCA 9535 E and PCA 9535 EC are the same as the PCA 9655 E. This allows up to 64 of these devices in any combination to share the same I 2 C−bus/SMBus...|$|E
30|$|Time: {{obtained}} in seconds {{based on the}} Unix <b>reading</b> <b>registered</b> by the device 1 January 1970 LLC, Books (2010). The calculation was made by subtracting the accumulated figure from that established in the first <b>reading</b> <b>registered</b> by the device.|$|R
5000|$|... #Subtitle level 3: Function code 4 (<b>read</b> input <b>registers)</b> and {{function}} code 3 (<b>read</b> holding <b>registers)</b> ...|$|R
5000|$|Because of {{the very}} limited {{register}} space (5 bits), 4 rarely <b>read</b> <b>registers</b> were not assigned addresses, but written by special instructions ( [...] and [...] ).|$|R
50|$|Operating System Shadow {{registers}} {{also exist}} for some <b>Read</b> <b>registers</b> where <b>reading</b> the value directly from hardware at an unknown {{stage in the}} display cycle may return inconsistent results.|$|R
50|$|Reading values {{directly}} from hardware at an unknown {{stage in the}} display cycle may return inconsistent results (an example: reading potentiometers). Operating System Shadow <b>registers</b> for <b>Read</b> <b>registers</b> would usually be the preferred source of information.|$|R
50|$|This error {{occurs because}} Instruction 2 <b>reads</b> <b>Register</b> 1 before Instruction 1 has committed/stored {{the result of}} its write {{operation}} to Register 1. So when Instruction 2 is reading the contents of Register 1, register 1 still contains 6, not 3.|$|R
5000|$|Write Result: In {{this stage}} {{the result is}} about to be written to its {{destination}} register. However, this operation is delayed until earlier instructions - which intend to <b>read</b> <b>registers</b> this instruction wants to write to - have completed their read operands stage. This way, so called data dependencies (WAR - Write after Read) can be addressed.|$|R
50|$|When the <b>read</b> address <b>register</b> {{equals the}} write address register, the FIFO is empty.|$|R
50|$|FIFO Empty: When the <b>read</b> address <b>register</b> {{reaches the}} write address register, the FIFO {{triggers}} the Empty signal.|$|R
50|$|FIFO FULL: When the write address <b>register</b> {{reaches the}} <b>read</b> address <b>register,</b> the FIFO {{triggers}} the FULL signal.|$|R
5000|$|Sometimes FPGA {{developers}} {{also use}} JTAG to develop debugging tools. [...] The same JTAG techniques used to debug software running inside a CPU can help debug other digital design blocks inside an FPGA. For example, custom JTAG instructions {{can be provided}} to allow <b>reading</b> <b>registers</b> built from arbitrary sets of signals inside the FPGA, providing visibility for behaviors which are invisible to boundary scan operations. Similarly, writing such registers could provide controllability which is not otherwise available.|$|R
5000|$|Reading {{from the}} {{registers}} will always return {{the time of}} day. In order to avoid a carry error while fetching the time, <b>reading</b> the hours <b>register</b> will immediately halt register updating, with no effect on internal timekeeping accuracy. Once the tenths <b>register</b> has been <b>read,</b> updating will resume. It is possible to <b>read</b> any <b>register</b> other than the hours register [...] "on the fly," [...] making {{the use of a}} running TOD clock as a timer a practical application. If the hours <b>register</b> is <b>read,</b> however, it is essential to subsequently <b>read</b> the tenths <b>register.</b> Otherwise, all TOD registers will remain [...] "frozen." ...|$|R
50|$|The Operating System's Non-Maskable Interrupt {{dispatch}} routine <b>reads</b> this <b>register</b> {{to determine}} {{the reason for the}} interrupt and so which service routine to execute.|$|R
5000|$|This {{problem is}} solved for some {{registers}} by Operating System [...] "Shadow" [...] registers implemented in regular RAM that mirror {{the values of}} hardware registers. During the Vertical Blank the Operating System copies the Shadow registers in RAM for Write registers to the corresponding hardware register, and updates Shadow values for <b>Read</b> <b>registers</b> from the hardware accordingly. Therefore, writes to hardware registers which have corresponding shadow registers will be overwritten by {{the value of the}} Shadow registers during the next vertical blank.|$|R
5000|$|Eliminate {{register}} writes {{and minimize}} <b>register</b> <b>reads</b> for normal data transfers ...|$|R
30|$|The use of Xen hypercalls is {{different}} between PVM and HVM, and different between user-level applications and kernel. PVM read hypercall page through interrupt 0 x 82 while HVM access hypercall page by <b>reading</b> <b>registers</b> using CPUID instructions. Guest user-level application cannot access hypercall page directly. Instead, they use ioctl to manipulate a special file named privcmd under /proc/xen directory, {{so as to}} indirectly access the hypercall page. No matter how the user-level application and the kernel use hypercalls, they would finally come to call their entries at hypercall page. So {{in order to keep}} generality, we directly monitor the execution or hypercall pages, instead of user-level hypercall interfaces.|$|R
50|$|The HPA {{is useful}} only if other {{software}} or firmware (e.g. BIOS) {{is able to}} use it. Software and firmware {{that are able to}} use the HPA are referred to as 'HPA aware'. The ATA command that these entities use is called READ NATIVE MAX ADDRESS. This command accesses a register that contains the true size of the hard drive. To use the area, the controlling HPA-aware program changes the value of the <b>register</b> <b>read</b> by IDENTIFY DEVICE to that found in the <b>register</b> <b>read</b> by READ NATIVE MAX ADDRESS. When its operations are complete, the <b>register</b> <b>read</b> by IDENTIFY DEVICE is returned to its original fake value.|$|R
50|$|There are ten 60-bit <b>read</b> <b>{{register}}s</b> and ten 60-bit write registers, {{each with}} an address register. Moving {{an address to}} an address register starts a small core memory read or write. Arithmetic and logic instructions have these registers as sources and destinations. The programmer or compiler tries to fetch data in time to be used and store data before more data needs the same register, {{but if it is}} not ready the processor goes into a wait state until it is. It also waits if one of the four floating-point arithmetic units is not ready when requested, but due to pipelining, this does not usually happen.|$|R
5000|$|Operation: Decode the {{instruction}} and access the <b>register</b> file to <b>read</b> the <b>registers.</b> This unit gets instruction from IF, and extracts opcode and operand from that instruction. It also retrieves register values if {{requested by the}} operation.|$|R
5000|$|Up to 12 words {{relative}} to any general purpose <b>register</b> (<b>read</b> and write, word access only) ...|$|R
50|$|Decode stage logic {{compares the}} {{registers}} written by instructions in the execute and access {{stages of the}} pipeline to the <b>registers</b> <b>read</b> by the instruction in the decode stage, and cause the multiplexers to select the most recent data. These bypass multiplexers {{make it possible for}} the pipeline to execute simple instructions with just the latency of the ALU, the multiplexer, and a flip-flop. Without the multiplexers, the latency of writing and then <b>reading</b> the <b>register</b> file would have {{to be included in the}} latency of these instructions.|$|R
25|$|As {{commercial}} use of electric energy {{spread in the}} 1880s, it became increasingly important that an electric energy meter, similar to the then existing gas meters, was required to properly bill customers {{for the cost of}} energy, instead of billing for a fixed number of lamps per month. Many experimental types of meter were developed. Edison at first worked on a direct current (DC) electromechanical meter with a direct <b>reading</b> <b>register,</b> but instead developed an electrochemical metering system, which used an electrolytic cell to totalise current consumption. At periodic intervals the plates were removed and weighed, and the customer billed. The electrochemical meter was labor-intensive to read and not well received by customers.|$|R
50|$|A {{good deal}} {{has been written}} about the highly {{integrated}} symbolic structure of this story, whose perfectly competent surface narration deals with a Hard-SF solution to the problem of an alien labyrinth, discovered on the Moon, which kills anyone who tries to pass through it. At one level, the novel's description of attempts to thread the labyrinth from Earth via Matter Transmission makes for excellent traditional sf; at another, it is a sustained rite de passage, a doppelgänger conundrum about the mind-body split, a death-paean. There is no doubt that AB Budrys intends that both levels of <b>reading</b> <b>register,</b> however any interepretation might run; in this novel the two levels interact fruitfully.|$|R
40|$|PC {{instruction}} memory, {{fetch instruction}} Register numbers <b>register</b> file, <b>read</b> <b>registers</b> Depending on instruction class Use ALU to calculate Arithmetic result Memory address for load/store Branch target address Access data memory for load/store PC target address or PC + 4 3 Abstract / Simplified View Two types of functional units: elements that operate on data values (combinational) elements that contain state (sequential) 4 PC address instruction instruction memory data memory address data registers data register # register # register # ALU Abstract / Simplified View Cannot just join wires together Use multiplexers 5 PC address instruction instruction memory data memory address data registers data register # register # register # ALU Recall...|$|R
5000|$|In 1974, Thomas Hall {{was added}} to the National Register of Historic Places, with the <b>register</b> <b>reading</b> ...|$|R
50|$|CTIA/GTIA {{provides}} 54 Read/Write registers controlling Player/Missile graphics, Playfield colors, joystick triggers, and console keys. Many CTIA/GTIA register addresses have dual purposes performing different {{functions as}} a Read vs a Write register. Therefore, no code should <b>read</b> Hardware <b>registers</b> expecting to retrieve the previously written value.|$|R
50|$|POKEY {{provides}} 29 Read/Write registers controlling Sound, Paddle input, keyboard input, serial input/output, and interrupts. Many POKEY register addresses have dual purposes performing different {{functions as}} a Read vs a Write register. Therefore, no code should <b>read</b> Hardware <b>registers</b> expecting to retrieve the previously written value.|$|R
5000|$|Mode <b>register</b> <b>read</b> {{and some}} {{multi-purpose}} commands {{must also be}} followed by a CAS-2 command, however all the column bits must be zero (low).|$|R
30|$|Configuration and control, {{enabling}} {{the configuration of}} the transceiver and the management of data transmission and reception.Typically, modulation and coding schemes are configurable and need to be controlled by the entity in charge of operating the baseband transceiver. For an RTL model for example, this corresponds to writing (and possibly <b>reading)</b> configuration <b>registers.</b>|$|R
50|$|This {{translates}} into addresses between 0 and 9,998 in data frames.For example, {{in order to}} <b>read</b> holding <b>registers</b> starting at number 40001, corresponding address in the data frame will be 0 with a function code of 3 (as seen above). For holding registers starting at number 40100, address will be 99. Etc.|$|R
30|$|Software: The Java {{software}} application SmartGridFetch collects data over Modbus TCP/IP from the energy analyzers. For each device, the application starts a thread which requests 18 measurements {{at the same}} time every second. For each measurement, we request 2 registers with 2 bytes over the <b>Read</b> Holding <b>Register</b> function and so each measurement has a size of 4 bytes.|$|R
5000|$|IEEE 802.3 Part [...] use {{different}} opcodes and start sequences. Opcodes 00(set address) and 11(read)/01(write)/10(read increment) {{are used as}} two serial transactions to <b>read</b> and write <b>registers.</b>|$|R
6000|$|In this July came to {{the hotel}} one whose card that she sent to the clerk for her name to be <b>registered</b> <b>read</b> [...] "Mme. Héloise D'Arcy Beaumont." ...|$|R
