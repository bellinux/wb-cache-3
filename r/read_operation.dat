379|1087|Public
500|$|Memory cells (blue squares in the illustration) {{are further}} {{organized}} into matrices and addressed through rows and columns. [...] A memory address {{applied to a}} matrix is broken into the row address and column address, which are processed by the row and column address decoders (in the illustration, vertical and horizontal green rectangles, respectively). [...] After a row address selects the row for a <b>read</b> <b>operation</b> (the selection {{is also known as}} row activation), bits from all cells in the row are transferred into the sense amplifiers that form the row buffer (red squares in the illustration), from which the exact bit is selected using the column address. [...] Consequently, read operations are of a destructive nature because the design of DRAM requires memory cells to be rewritten after their values have been read by transferring the cell charges into the row buffer. [...] Write operations decode the addresses in a similar way, but {{as a result of the}} design entire rows must be rewritten for the value of a single bit to be changed.|$|E
2500|$|Similar {{procedures}} are provided for input. R5RS Scheme provides the predicates input-port? and output-port?. [...] For character input and output, write-char, read-char, peek-char and char-ready? are provided. [...] For writing and reading Scheme expressions, Scheme provides read and write. [...] On a <b>read</b> <b>operation,</b> the result returned is the end-of-file object if the input port {{has reached the}} end of the file, and this can be tested using the predicate eof-object?.|$|E
2500|$|The {{prefetch}} architecture {{takes advantage}} of the specific characteristics of memory accesses to DRAM. Typical DRAM memory operations involve three phases: bitline precharge, row access, column access. Row access is the heart of a <b>read</b> <b>operation,</b> as it involves the careful sensing of the tiny signals in DRAM memory cells; it is the slowest phase of memory operation. However, once a row is read, subsequent column accesses to that same row can be very quick, as the sense amplifiers also act as latches. For reference, a row of a 1 Gbit DDR3 device is 2,048 bits wide, so internally 2,048 bits are read into 2,048 separate sense amplifiers during the row access phase. [...] Row accesses might take 50 ns, depending on the speed of the DRAM, whereas column accesses off an open row are less than 10 ns.|$|E
3000|$|... verification: it is {{required}} either by a top-down <b>reading</b> <b>operation,</b> i.e., when message passing is executed from below in the hierarchy; or by a <b>reading</b> <b>operation</b> {{performed by a}} sceptic agent; [...]...|$|R
30|$|As summarized, {{prototype}} SCOPE takes 322 s for write operations, 1089 s for {{write with}} replication operations, and 501 s for <b>read</b> <b>operations</b> compared to prototype SCOPE-MR, which takes 314, 1051, 435 s for write, write with replication, and <b>read</b> <b>operations</b> respectively. The average relative performance overhead introduced by prototype SCOPE is 3 % for write operations and 4 % for write with replication, whereas the monitoring overhead increases to 15 % when the <b>read</b> <b>operations</b> are performed.|$|R
40|$|Distributed {{file system}} (DFS) {{is the main}} storage {{component}} of a distributed system (DS). DFS provides scalable storage to the DS {{and it is also}} the main component of any cloud storage system. Improving the performance of <b>read</b> <b>operations</b> in a DFS is very important as many web-based applications deployed in the cloud perform <b>read</b> <b>operations</b> quite frequently. Many pre fetching and caching techniques are used to improve the performance of the <b>read</b> <b>operations</b> in a DFS. Speculation-based techniques have also been proposed in the literature for reducing the read access time. In this paper, we propose a novel anticipation-based parallel processing technique by considering global caching technique for a DFS. The results of performance analysis through mathematical and simula-tion modeling indicate that the proposed technique improves the performance of <b>read</b> <b>operations</b> better than the speculation-based algorithm proposed in the literature...|$|R
2500|$|SLDRAM used an 11-bit command bus (10 command bits CA9:0 {{plus one}} start-of-command FLAG line) to {{transmit}} 40-bit command packets on 4 consecutive edges of a differential command clock (CCLK/CCLK#). [...] Unlike SDRAM, {{there were no}} per-chip select signals; each chip was assigned an ID when reset, and the command contained the ID of the chip that should process it. [...] Data was transferred in 4- or 8-word bursts across an 18-bit (per chip) data bus, using one of two differential data clocks (DCLK0/DCLK0# and DCLK1/DCLK1#). [...] Unlike standard SDRAM, the clock was generated by the data source (the SLDRAM chip {{in the case of}} a <b>read</b> <b>operation)</b> and transmitted in the same direction as the data, greatly reducing data skew. [...] To avoid the need for a pause when the source of the DCLK changes, each command specified which DCLK pair it would use.|$|E
50|$|An HWB device shall {{return the}} data {{requested}} by a <b>read</b> <b>operation.</b>|$|E
5000|$|Read {{operations}} from [...] {{return as}} many null characters (0x00) as requested in the <b>read</b> <b>operation.</b>|$|E
30|$|In {{order to}} {{accommodate}} byzantine clients in our failure model, we must reconsider our consistency criterion since {{with the current}} definition, {{it would be easy}} for a byzantine client to generate histories that are not serializable. One simple attack is a byzantine client who issues <b>read</b> <b>operations</b> that return bogus information. Another attack is a byzantine client who executes <b>read</b> <b>operations</b> (e.g., against a byzantine server) and does not include them in the transaction’s readset. As a consequence, honest servers would certify the transaction using a subset of the transaction’s <b>read</b> <b>operations,</b> which could violate serializability.|$|R
5000|$|No {{disk access}} for <b>read</b> <b>{{operations}}</b> and limited disk access for write operations ...|$|R
5000|$|This {{interface}} {{must provide}} sufficiently fast <b>read</b> <b>operations</b> with a random access pattern, ...|$|R
5000|$|<b>Read</b> <b>operation</b> (...) : the <b>read</b> <b>operation</b> {{algorithm}} {{is a basic}} version of the join operation.The only {{difference between these two}} algorithms is the broadcast mechanism used by the read operation.A client (cw)will broadcast a message to the system and once a server receives the inquiry,it will send a reply message to the client.Once the client receives enough replies (n-f-j) it will stop sending an inquiry.|$|E
50|$|When Read and Write happen concurrently, {{the value}} {{returned}} by Read {{may not be}} uniquely determined. Lamport defined three types of registers: safe registers, regular registers and atomic registers. A <b>Read</b> <b>operation</b> of a safe register can return any value if it is concurrent with a Write operation, and returns the value written by the most recent Write operation if the <b>Read</b> <b>operation</b> does not overlap with any Write. A regular register differs from a safe register in that the <b>read</b> <b>operation</b> can return the value written by either the most recent completed Write operation or a Write operation it overlaps with. An atomic register satisfies the stronger condition of being linearizable.|$|E
50|$|Read repair: The {{correction}} is {{done when}} a read finds an inconsistency. This slows down the <b>read</b> <b>operation.</b>|$|E
30|$|Subsequently, the {{optimization}} of <b>reading</b> <b>operation</b> is also investigated. The <b>reading</b> <b>operation</b> strongly {{relies on}} the BTBT between the P+ source and channel. During the reading “ 1 ”, Gate 1 mainly promotes the BTBT at the source side, whereas Gate 2 with the high voltage lowers the energy barrier which resists the flowing of electrons from the channel to drain. But during the reading “ 0 ”, {{it is necessary that}} Gate 2 with the small voltage be able to prevent electrons flowing from the channel to drain. Therefore, the optimization of both the Gate 1 and Gate 2 voltages is very important for the <b>reading</b> <b>operation.</b>|$|R
30|$|The {{operating}} {{principle of the}} DG-TFET DRAM cell {{is different from that}} of the traditional DRAM. Both the writing and <b>reading</b> <b>operations</b> are based on the BTBT, but each of them has the different function. The BTBT during the writing “ 1 ” leads the holes to be stored in the potential well under Gate 2, which can elevate the reading “ 1 ” current. During the <b>reading</b> <b>operation,</b> the drain current mainly depends on the BTBT near the source side. Furthermore, the two gates also act as the different roles: Gate 1 and Gate 2 mainly determine the <b>reading</b> <b>operation</b> and writing operation, respectively.|$|R
5000|$|Reducing {{total costs}} of meter’s <b>reading,</b> <b>operation</b> and maintenance, and customer’s {{disconnection}} and reconnection ...|$|R
5000|$|A <b>read</b> <b>operation</b> not {{concurrent}} {{with any}} write operation returns the value {{written by the}} latest write operation.|$|E
5000|$|MDIO data: bidirectional, the PHY drives it {{to provide}} {{register}} data {{at the end}} of a <b>read</b> <b>operation.</b>|$|E
5000|$|A <b>read</b> <b>operation</b> that is {{concurrent}} with a {{write operation}} may return any value within the register's allowed {{range of values}} (for example, 0,1,2,...).|$|E
40|$|SRAM cell {{stability}} {{analysis is}} typically based on Static Noise Margin (SNM) investigation when in hold mode, although many memory errors may occur during <b>read</b> <b>operations.</b> Given that SNM varies with each cell operation, a thorough analysis of SNM in read mode is required. In this paper we investigate the SRAM cell SNM during <b>read</b> <b>operations</b> analyzing various alternatives to improve cell stability in this mode. The techniques studied {{are based on}} transistor width, and word- and bit-line voltage modulations. We show {{that it is possible}} to improve cell stability during <b>read</b> <b>operations</b> while reducing current leakage, as opposed to current methods that improve cell read stability at the cost of leakage increase. 1...|$|R
5000|$|Read Your Writes : {{this means}} that {{preceding}} write operations are indicated and reflected by the following <b>read</b> <b>operations.</b>|$|R
3000|$|... is {{the number}} of <b>read</b> <b>operations</b> on a single tag between two updates of the database. A suited size for [...]...|$|R
50|$|To write {{a bit of}} core memory, the {{circuitry}} assumes {{there has}} been a <b>read</b> <b>operation</b> and the bit is in the 0 state.|$|E
5000|$|... 2) Each <b>read</b> <b>{{operation}}</b> {{returns the}} value {{written by the}} last write operation before the read, in the sequence where all operations are ordered by their τ values.|$|E
50|$|A value {{written by}} a process on a data item X will be always {{available}} to a successive <b>read</b> <b>operation</b> performed by the same process on data item X.|$|E
5000|$|Monotonic Reads: {{this implies}} that an {{up-to-date}} increasing set of write operations is guaranteed to be indicated by later <b>read</b> <b>operations.</b>|$|R
5000|$|... 'command' is a {{file that}} {{connects to the}} command line, {{so that it can}} be read using normal file <b>read</b> <b>operations.</b>|$|R
40|$|Data {{recovery}} for malicious committed transactions af-ter attacks increasingly becomes an important issue. Dam-age assessment for data recovery requires a transaction log which record data items read or written by all mali-cious and benign transactions. Unfortunately, conventional undo/redo log could not record <b>read</b> <b>operations</b> for trans-actions; and existing auditing mechanisms in DBMS could not capture operations for data items. In this paper, we introduce {{a concept of}} “Extended <b>Read</b> <b>Operations</b> ” and illustrate how the Extended <b>Read</b> <b>Operations</b> would cause the damage spreading, and then a Fine Grained Transac-tion Log (FGTL) is proposed. The log records all the data items of the read only and update-involved <b>operations</b> (<b>read</b> and write) for the committed transactions, and even extracts data items read by the subqueries in the SQL statements. A prototype system denoted FGTL Generator is developed to generate the FGTL. Experiments based on TPC-W Bench-mark show the availability for FGTL Generator...|$|R
5000|$|Safe {{semantics}} {{are defined}} for a variable {{with a single}} writer but multiple readers (SWMR). A SWMR register is safe if each <b>read</b> <b>operation</b> satisfies the two following properties: ...|$|E
5000|$|... #Caption: Diagram of the {{hysteresis}} curve for {{a magnetic}} memory core during a <b>read</b> <b>operation.</b> Sense line current pulse is high ("1") or low ("0") depending on original magnetization {{state of the}} core.|$|E
5000|$|Slow write, fast read storage : Read/write storage {{which allows}} {{information}} to be overwritten multiple times, but with the write operation being much slower than the <b>read</b> <b>operation.</b> Examples include CD-RW and swayne memory ...|$|E
30|$|Blind transactions, a {{powerful}} mechanism to boost byzantine client attacks, benefit from two properties: (a) they never abort and (b) they execute {{more quickly than}} honest transactions, which contain <b>read</b> <b>operations.</b> From property (a), every transaction created by a byzantine client may cause honest transactions to abort. Property (b) {{stems from the fact}} that without reads, byzantine transactions are executed in a single step. As a consequence, more transactions can be generated by byzantine clients in an execution. We have assessed that property (b) can created more damage to honest transactions than property (a). In our assessment, we configured byzantine transactions to issue <b>read</b> <b>operations</b> that no transaction updates. Thus, such transactions never abort, although they issue <b>read</b> <b>operations.</b> It turned out that in this case, byzantine transactions were much less harmful than blind transactions.|$|R
50|$|During {{the times}} of combo (CD-RW/DVD-ROM) drives, an {{additional}} speed rating (e.g. the 16× in 52×/32×/52×/16×) is designated for DVD-ROM media <b>reading</b> <b>operations.</b>|$|R
5000|$|In Writes-follow-reads consistency, updates are {{propagated}} after {{performing the}} previous <b>read</b> <b>operations.</b> Tanenbaum et al., 2007 defines the following condition for Writes-follow-reads consistency: ...|$|R
