87|188|Public
50|$|The {{software}} operating platform implements {{the software}} model, supporting the features {{defined in the}} entity model and the collaboration model. For example, researchers have proposed connectors that enable communications between heterogeneous protocols, and <b>runtime</b> <b>software</b> architecture to govern on-demand collaboration.|$|E
50|$|The <b>runtime</b> <b>software</b> ran on a DSI card; a 32 bit co-processor {{that was}} {{inserted}} into an available ISA {{slot in the}} PC. This was due to insufficient processing power available in the 286 and 386 PCs available at the time.|$|E
50|$|GetDataBack is a data {{recovery}} software developed by <b>Runtime</b> <b>Software.</b> It {{can be used}} to recover data from external and internal hard disks, in the FAT and the NTFS file systems, although different variants of the program are needed for each file system. Registration of the software is required in order to recover data with the software.|$|E
30|$|The model {{proposed}} hereby {{allows for}} composing, at <b>runtime,</b> a <b>software</b> architecture which is optimal {{with respect to}} all the other design alternatives satisfying the same requirements.|$|R
40|$|<b>Software</b> <b>runtime</b> {{monitoring}} {{has been}} used to increase the dependability of software. This paper focuses on <b>software</b> <b>runtime</b> monitoring techniques and tools. A generic <b>software</b> <b>runtime</b> monitoring model is presented, which consists of five basic elements, i. e., Monitored Object Features, Monitoring Access Methods, Execution Relationships, Runtime Monitor and Platform Dependencies. This model is an innovation in software monitoring fields. This paper gives some features of each element. Based on these features, researchers can use the model to comprehend and analyze runtime monitoring techniques and tools. The objective {{of this paper is to}} help researchers and users to identify the difference and the basic principles of <b>software</b> <b>runtime</b> monitoring techniques and tools. This paper also shows a result of relationship between techniques and features, through the result, we can understand the development trends of the techniques and tools, such as, what features are concerned more, and what features are concerned less. </span...|$|R
30|$|It is {{necessary}} to explain that the results (<b>software</b> <b>runtime)</b> are the average of results after 10 times of service restoration implementation.|$|R
50|$|The first Windows {{versions}} of Microsoft Word and Microsoft Excel ran on Windows 2.0. Third-party developer support for Windows increased substantially with this version (some shipped the Windows <b>Runtime</b> <b>software</b> with their applications, for customers {{who had not}} purchased the full version of Windows). However, most developers still maintained DOS {{versions of}} their applications, as Windows users were still a distinct minority of their market. Windows 2.0 was still very dependent on the DOS system and it still hadn't passed the 1 megabyte mark in terms of memory.|$|E
5000|$|Nenad Medvidović is a Professor of Computer Science and Informatics at the University of Southern California, Los Angeles. He is {{a fellow}} of the IEEE and an ACM Distinguished Scientist. He is chair of ACM SIGSOFT and {{co-author}} of Software Architecture: Foundations, Theory, and Practice (2009). In 2008, he received the Most Influential Paper Award for a paper titled [...] "Architecture-Based <b>Runtime</b> <b>Software</b> Evolution" [...] published in the ACM/IEEE International Conference on Software Engineering 1998. [...] In 2017, he received an IEEE International Conference on Software Architecture Best Paper Award for his paper titled [...] "Continuous Analysis of Collaborative Design".|$|E
40|$|We {{summarize}} {{and relate}} current {{work in the}} area of dynamic software architecture. Based on this and our experience to date in constructing systems based on dynamic software architectures, we present a set of open research issues that need further investigation. Keywords Dynamic software architectures, <b>runtime</b> <b>software</b> evolution, <b>runtime</b> <b>software</b> reconfiguration, software consistency, software integrity. ...|$|E
5000|$|The {{first public}} release of Integra Live {{was made on}} July 30, 2010 when the {{software}} entered its open beta development phase. The version 1.0.x series of releases was for Mac OS X only, (version 10.4 upwards) and required users to manually install the Adobe AIR <b>runtime.</b> The <b>software</b> was released as a ZIP archive containing the software [...] ".app" [...] bundle and a PDF [...] "Quick Start Guide".|$|R
40|$|Abstract—In {{addition}} to studying {{the construction and}} evolution of software services, the software engineering discipline needs to address the operation of continuously running software services. A requirement for its robust operation are means for effective monitoring of <b>software</b> <b>runtime</b> behavior. In contrast to profiling for construc-tion activities, monitoring of operational services should only impose a small performance overhead. Furthermore, instrumentation should be non-intrusive to the business logic, as far as possible. We present the Kieker framework for monitoring <b>software</b> <b>runtime</b> behavior, e. g., internal performance or (distributed) trace data. The flexible architecture allows to replace or add framework components, including monitor-ing probes, analysis components, and monitoring recor...|$|R
50|$|Additionally to storing data in {{non-standard}} formats, {{some games}} also utilize <b>runtime</b> protection through <b>software</b> protectors. The key target {{is to keep}} attackers from directly inspecting or modifying compiled software. Protectors utilize either of three methods to protect software.|$|R
40|$|To {{ensure the}} {{reliability}} of complex software systems, <b>runtime</b> <b>software</b> monitoring is widely accepted to monitor and check system execution against formal properties specification at runtime. <b>Runtime</b> <b>software</b> monitoring can detect property violations, however it can not explain why a violation has occurred. Diagnosing runtime property violations is still a challenge issue. In this paper, a novel diagnosis method based on dependency rules is constructed to diagnose runtime property violations in complex software systems. A set of rules is formally defined to isolate software fault from hardware fault, then software faults is localized by combining trace slicing and dicing. The method is implemented in the <b>runtime</b> <b>software</b> monitoring system SRMS, and experimental results demonstrate that the method can effectively isolate and locate the related faults with property violations. © 2011 IEEE...|$|E
40|$|This {{paper is}} a {{preliminary}} report of our work currently in progress. Our goal {{is to develop a}} mechanism that allows computer programs, which are running, to evolve and change their behavior without stopping their execution. Our approach is to extend dynamic linking libraries (DLLs) to support <b>runtime</b> <b>software</b> evolution. More precisely, we have included a runtime version management mechanism into DLLs to support <b>runtime</b> <b>software</b> evolution. In this paper, I will first show the outline of our runtime version management mechanism of DLLs. And then I will show our ways of implementing the runtime version management mechanism of DLLs. I will also briefly summarize {{the advantages and disadvantages of}} our approaches...|$|E
40|$|The {{increasingly}} complex {{environments in which}} software systems are running today have made <b>runtime</b> <b>software</b> quality unstable and hardly in an optimal state, especially for those systems in open and dynamic environments, e. g. Internetware. In this paper, we explore the effectiveness of software cybernetics and feedback control theory in <b>runtime</b> <b>software</b> quality optimization. We propose a method of runtime quality optimization by using feedback control theory. Specially, we consider the problem of runtime optimization for a specific quality attribute, namely throughput, for Web-based systems. We design a double-layer feedback control model for the problem and implement the runtime optimization control method. In the method, runtime feedbacks are collected and used by the control model to adjust related control parameters. The experimental study has demonstrated the effectiveness of software cybernetics and feedback control theory in runtime quality optimization...|$|E
40|$|Low-level systems software— such as {{operating}} systems, virtual machines, language <b>runtimes,</b> embedded <b>software,</b> and performance-critical applications—is commonly {{written in}} unsafe languages, notably CandC++. Theselow-levellanguagesremain prevalent {{because they provide}} high performance, {{direct access to the}} underlying hardware, and explicit control over memory management. Moreover, because such systems often consist of millions of lines of code, transitioning the computing ecosystem away from C and its variants is not feasible any time soon. Unfortunately, C and its variants do no...|$|R
40|$|Conventional {{approaches}} to self-adaptive software architectures require human experts to specify models, policies and {{processes by which}} software can adapt to its environment. We present REX, a complete platform and online learning approach for <b>runtime</b> emergent <b>software</b> systems, in which all decisions about the assembly and adaptation of software are machine-derived. REX is built with three major, integrated layers: (i) a novel component-based programming language called Dana, enabling discovered assembly of systems and very low cost adaptation of those systems for dynamic re-assembly; (ii) a perception, assembly and learning framework (PAL) built on Dana, which abstracts emergent software into configurations and perception streams; and (iii) an online learning implementation based on a linear bandit model, which helps solve the search space explosion problem inherent in <b>runtime</b> emergent <b>software.</b> Using an emergent web server as a case study, we show how software can be autonomously self-assembled from discovered parts, and continually optimized over time (by using alternative parts) as it is subjected to different deployment conditions. Our system begins with no knowledge that it is specifically assembling a web server, nor {{with knowledge of the}} deployment conditions that may occur at runtime...|$|R
5000|$|RDS {{is based}} on CCR (Concurrency and Coordination Runtime): a [...]NET-based {{concurrent}} library implementation for managing asynchronous parallel tasks. This technique involves using message-passing and a lightweight services-oriented <b>runtime,</b> DSS (Decentralized <b>Software</b> Services), which allows the orchestration of multiple services to achieve complex behaviors.|$|R
40|$|Abstract. This paper {{introduces}} JNET, a novel constraint {{representation and}} reasoning framework that supports procedural constraints and constraint attachments, providing a flexible way of integrating the constraint reasoner with a <b>runtime</b> <b>software</b> environment. Attachments in JNET are constraints over arbitrary Java objects, which are defined using Java code, at runtime, with no {{changes to the}} JNET source code. ...|$|E
40|$|Many {{long-lived}} {{and distributed}} systems must remain available yet evolve over time, due to, e. g., bugfixes, feature extensions, or changing user requirements. To facilitate such changes, formal methods {{can help in}} modeling and analyzing <b>runtime</b> <b>software</b> evolution. This paper presents an executable object-oriented modeling language which supports <b>runtime</b> <b>software</b> evolution. The language, based on Creol, targets distributed systems by active objects, asynchronous method calls, and futures. A dynamic class construct is proposed in this setting, providing an asynchronous and modular upgrade mechanism. At runtime, class redefinitions gradually upgrade existing {{instances of a class}} and of its subclasses. An upgrade may depend on previous upgrades of other classes. For asynchronous runtime upgrades, the static picture may differ from the actual runtime system. An operational semantics and a type and effect system are given for the language. The type analysis of an upgrade infers and collects dependencies on previous upgrades. These dependencies are exploited as runtime constraints to ensure type safety...|$|E
30|$|When {{running the}} <b>Runtime</b> <b>software</b> as a TCP server, its meters and {{actuators}} are visible from MATLAB, which enables direct {{control of the}} RTDS simulation through MATLAB [19]. However, the acquisition of data is more complicated as MATLAB must encode the Runtime meter data to a specific syntax, and afterwards decode the value to enable processing. Therefore, an alternative way of data acquisition from RTDS to MATLAB is considered.|$|E
40|$|As {{part of the}} National Nuclear Security Administration’s (NNSA) Advanced Simulation and Computing program, Sandia National Laboratories is {{addressing}} a critical need for experimental architecture test beds to support path-finding explorations of alternative programming models, architecture-aware algorithms, low-energy <b>runtimes</b> and system <b>software,</b> and advanced memory subsystem development...|$|R
50|$|Without a coprocessor, the 386 {{normally}} performs floating-point arithmetic through (slow) software routines, implemented at <b>runtime</b> {{through a}} <b>software</b> exception-handler. When a math coprocessor is paired with the 386, the coprocessor performs the {{floating point arithmetic}} in hardware, returning results much faster than an (emulating) software library call.|$|R
40|$|To {{improve the}} {{programmability}} of multicores, several task-based programming models {{have recently been}} proposed. Inter-task dependencies have to be resolved by either the programmer or a <b>software</b> <b>runtime</b> system, increasing the respectively. In this paper we therefore propose the Nexus hardware task management support system. Based on the inputs and outputs of tasks, it dynamically detects dependencies between tasks and schedules ready tasks for execution. In addition, it provides fast and scalable synchronization. Experiments show that compared to a <b>software</b> <b>runtime</b> system, Nexus improves the task {{by a factor of}} 54 times. As a consequence much finer-grained tasks and/or many more cores can be efficiently employed. example, for H. 264 decoding, which has an average task size 8. 1 us, Nexus scales up to more than 12 cores, while when using the software approach, the scalability saturates at below three cores...|$|R
40|$|Society’s {{increasing}} {{dependence on}} software-intensive systems {{is driving the}} need for dependable, robust, continuously available systems. Runtime system reconfiguration is one aspect of achieving continuous availability. We present an architecture-based approach to <b>runtime</b> <b>software</b> reconfiguration, highlighting the beneficial role of architectural styles and software connectors in facilitating runtime change. We conclude by describing the implementation of our tool suite, called ArchStudio, that supports runtime reconfiguration using our architecture-based approach. 1...|$|E
40|$|Continuous {{availability}} is {{a critical}} requirement for an important class of software systems. For these systems, runtime system evolution can mitigate the costs and risks associated with shutting down and restarting the system for an update. We present an architecture-based approach to <b>runtime</b> <b>software</b> evolution and highlight the role of software connectors in supporting runtime change. An initial implementation of a tool suite for supporting the runtime modification of software architectures, called ArchStudio, is presented. ...|$|E
40|$|Motion_Reward_ 96 _XP. vi, is the {{graphical}} {{source code}} file for the software {{described in the}} article "An automated motion detection and reward system for animal training" by Brad Miller, Audrey N. Lim, Arnold F. Heidbreder, and Kevin J. Black (doi: 10. 7759 /cureus. 397). Monkey Motion is © 2006 -, Arnold F. Heidbreder. The software was designed on the LabVIEW programming system, and running the program requires the appropriate LabVIEW <b>runtime</b> <b>software</b> from National Instruments Corporation ([URL]...|$|E
40|$|Abstract — The {{focus of}} this paper is an {{experimentation}} plat-form known as Iris that has a <b>runtime</b> reconfigurable <b>software</b> radio at its core. We have employed this platform to enable a wide variety of tests and experimentation in the fields of dynamic spectrum access and cognitive radio. The paper charts the progress of the Iris system since its inception as well as details of some of the experiments and trials conducted using this platform. We also discuss the challenges involved in the development and deployment of a software radio platform that supports runtime reconfigurability and provide recommendations for future improvements. I...|$|R
50|$|Knowledge {{management}} {{plays an}} important part in Quality Engineering. The quality engineering knowledge base comprises manifold structured and unstructured data, ranging from code repositories via requirements specifications, standards, test reports, enterprise architecture models to system configurations and <b>runtime</b> logs. <b>Software</b> and system models {{play an important role in}} mapping this knowledge. The data of the quality engineering knowledge base are generated, processed and made available both manually as well as tool-based in a geographically, organisationally and technically distributed context. Of prime importance is the focus on quality assurance tasks, early recognition of risks, and appropriate support for the collaboration of actors.|$|R
40|$|Software Engineering TrackInternational audienceReal-time {{features}} and <b>software</b> <b>runtime</b> adaptation are two requirements of modern software. On the one hand, {{the most important}} characteristics in real-time applications are their predictable behavior and deterministic execution time. On the other hand, <b>runtime</b> adaptive <b>software</b> are capable of being updated and reconfigured at execution time, making them more flexible and available. The OSGi Service Platform has become the de facto platform for developing flexible and modular software, due to its simple service-oriented component model. Many Java applications are being migrated to and developed for the OSGi Platform's component model. However, due to the popularization of real-time solutions such as the Real-Time Specification for Java, some of these applications may have timing constraints which cannot be respected because of the platform's dynamic behavior {{and the fact that}} service-oriented component-based application architectures may change at execution time. This paper proposes to delay reconfigurations for after critical processing, according to Service Level Agreements established between service providers and consumers. Our approach has been implemented as an extension to the iPOJO component model which freezes application's architecture and avoids introducing unpredictability caused by runtime adaptation during real-time applications' execution...|$|R
40|$|Abstract. In this paper, we {{introduce}} JNET, a novel constraint {{representation and}} reasoning framework that supports procedural constraints and constraint attachments, providing a flexible way of integrating the constraint {{system with a}} <b>runtime</b> <b>software</b> environment and improving its applicability. We describe how JNET is applied to a real-world problem – NASA’s Earth-science data processing domain, and demonstrate how JNET can be extended, without any knowledge of how it is implemented, to meet the growing demands of real-world applications. ...|$|E
40|$|The Human Machine Interface (HMI) {{is where}} {{interaction}} {{between humans and}} machines occurs. It is widely used in industry such as automatic control field. Controls such as button, text box and so on are fundamental and commonly used in the HMI. Controls typically contain the User Interface (UI) rendering and the business logic. The UI is the graphic display for users, and business logic is logic unit used to handle events of controls in UI. A typical HMI platform usually provides standard controls for users, but users {{may also want to}} use. NET custom controls such as self-defined controls and third-party controls. The feature of supporting. NET custom controls is what the thesis is concern on. Siemens is developing a new HMI platform in which the HMI <b>runtime</b> <b>software</b> has no prior knowledge of a. NET custom control until it is loaded during runtime. However, the business logic of the. NET custom controls will ideally reside in the HMI <b>runtime</b> <b>software,</b> where the full runtime functionalities are available. The key of this concept is to separate the UI rendering of a control and the business logic of a control. Hostin...|$|E
40|$|We present Protagoras, a new plug-in {{architecture}} for the GNU compiler {{collection that}} {{allows one to}} modify GCC’s internal representation of the program under compilation. We illustrate the utility of Protagoras by presenting plug-ins for both compile-time and <b>runtime</b> <b>software</b> verification and monitoring. In the compiletime case, we have developed plug-ins that interpret the GIMPLE intermediate representation to verify properties statically. In the runtime case, we have developed plug-ins for GCC to perform memory leak detection, array bounds checking, and reference-count access monitoring. ...|$|E
50|$|Software {{transactional}} memory provides transactional memory semantics in a <b>software</b> <b>runtime</b> {{library or}} the programming language, and requires minimal hardware support (typically an atomic compare and swap operation, or equivalent). As the downside, software implementations usually {{come with a}} performance penalty, when compared to hardware solutions. Hardware acceleration can reduce some of the overheads associated with software transactional memory.|$|R
40|$|The DART (Distributed Adaptive RunTime) {{project is}} {{developing}} a <b>software</b> <b>runtime</b> that will allow application authors to quickly develop distributed software, such as network or web software, without {{having to deal with}} the details of the distribution technology. A key feature of the runtime is its ability to reconfigure, or adapt itself, to the application requirements and to the system and networking environment using a reflective architecture...|$|R
40|$|We {{propose a}} meta-framework called 'Plastik' which i) {{supports}} the specification {{and creation of}} <b>runtime</b> component-framework-based <b>software</b> systems and ii) facilitates and manages the runtime reconfiguration of such systems while ensuring integrity across changes. The meta-framework is fundamentally an integration of an architecture description language (an extension of ACME/Armani) and a reflective component runtime (OpenCOM). Plastik-generated component frameworks can be dynamically reconfigured either through programmed changes (which are foreseen at design time and specified at the ADL level); or through ad-hoc changes (which are unforeseen at design time but which are nevertheless constrained by invariants specified at the ADL level). We provide in the paper a case study that illustrates the operation and benefits of Plastik...|$|R
