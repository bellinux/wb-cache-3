4|83|Public
40|$|This paper {{examines}} correctness {{issues that}} arise in distributed database design. A distributed relational database design is traditionally considered to be valid if every global relation can be reconstructed from its fragments by join operations. In this paper, three successively less restrictive definitions of validity are presented, each providing progressively improved handling of incomplete information. Examining these forms, a hybrid reconstruction approach involving inner- and outer-joins is proposed and we briefly describe its application to query formulation. We also propose replacing the notion of global reconstructability with the less restrictive, yet intuitively natural notion of object reconstructability. Universal relations need not be constructed. The need for maintenance of constraints across sites of a distributed system is discussed, {{and the notion of}} a distributed <b>referential</b> <b>constraint</b> is proposed which fulfills this need...|$|E
40|$|We {{address the}} problem of minimal-change {{integrity}} maintenance in the context of integrity constraints in relational databases. Using the framework proposed by Arenas, Bertossi, and Chomicki [4], we focus on two basic computational issues: repair checking (is a database instance a repair of a given database?) and consistent query answers (is a tuple an answer to a given query in every repair of a given database?). We study the computational complexity of both problems, delineating the boundary between the tractable and the intractable. We review relevant semantical issues and survey different computational mechanisms proposed in this context. Our analysis sheds light on the computational feasibility of minimal-change integrity maintenance. The tractable cases should lead to practical implementations. The intractability results highlight the inherent limitations of any integrity enforcement mechanism, e. g., triggers or <b>referential</b> <b>constraint</b> actions, as a way of performing minimal-change integrity maintenance...|$|E
40|$|AbstractWe {{address the}} problem of minimal-change {{integrity}} maintenance in the context of integrity constraints in relational databases. We assume that integrity-restoration actions are limited to tuple deletions. We focus on two basic computational issues: repair checking (is a database instance a repair of a given database?) and consistent query answers [in: ACM Symposium on Principles of Database Systems (PODS), 1999, 68] (is a tuple an answer to a given query in every repair of a given database?). We study the computational complexity of both problems, delineating the boundary between the tractable and the intractable cases. We consider denial constraints, general functional and inclusion dependencies, as well as key and foreign key constraints. Our results shed light on the computational feasibility of minimal-change integrity maintenance. The tractable cases should lead to practical implementations. The intractability results highlight the inherent limitations of any integrity enforcement mechanism, e. g., triggers or <b>referential</b> <b>constraint</b> actions, as a way of performing minimal-change integrity maintenance...|$|E
40|$|We {{investigate}} the transformation and {{the preservation of}} XML <b>referential</b> <b>constraints</b> in XML data transformation for integration purposes in this paper. In the transformation and the preser-vation, we consider XML inclusion dependencies and XML foreign keys. We show how XML <b>referential</b> <b>constraints</b> should be transformed and preserved using important transformation op-erators with sufficient conditions. 1...|$|R
40|$|Data is {{business}} asset {{that should be}} safeguarded and maintained. Business data is recorded in a table/relation. Because inconeet relation structure could produce any modification anomaly, this relation should be normalized. Data modification in normalized relation will face <b>referential</b> integrity <b>constraint</b> problem. This problem could make inconsistent data and wrong information. <b>Referential</b> integrity <b>constraint</b> depends on minimum relationship cardinality. The trial and implementation of <b>referential</b> integrity <b>constraint</b> is taken on Microsoft Access. Abstract in Bahasa Indonesia : Data adalah asset perusahaan yang harus dijaga dan dipelihara. Data perusahaan dicatat pada tabel/relation. Struktur relation yang kurang baik dapat mengakibatkan modification anomaly, sehingga relation tersebut harus di-normalisasi. Modifikasi data pada relation yang sudah di-normalisasi akan menghadapi masalah <b>referential</b> integrity <b>constraint.</b> Masalah tersebut menyebabkan data tidak konsisten dan menghasilkan informasi yang salah. <b>Referential</b> integrity <b>constraint</b> tergantung pada minimum relationship cardinality. Penulis mengimplementasikan dan menguji coba <b>referential</b> integrity <b>constraint</b> pada Microsoft Access. Kata kunci: modification anomaly, normalization, <b>referential</b> integrity <b>constraint,</b> relationship cardinality constraint...|$|R
40|$|In this paper, {{we address}} the issue of {{reasoning}} with two classes of commonly used semantic integrity constraints in database and knowledge [...] base systems: implication <b>constraints</b> and <b>referential</b> <b>constraints.</b> We first consider a central problem in this respect, the IRC [...] refuting problem, which is to decide whether a conjunctive query always produces an empty relation on (finite) database instances satisfying a given set of implication and <b>referential</b> <b>constraints.</b> Since the general problem is undecidable, we only consider acyclic <b>referential</b> <b>constraints.</b> Under this assumption, we prove that the IRC [...] refuting problem is decidable, and give a novel necessary and sufficient condition for it. Under the same assumption, we also study several other problems encountered in semantic query optimization, such as the semantics [...] based query containment problem, redundant join problem, and redundant selection [...] condition problem, and show that they are polynomially equivalent or reducible to the IRC [...] ...|$|R
40|$|The {{processes}} of personal {{relationships in the}} field of families are also very complex varied. The national situation allows us to note {{that there are a number}} of situations in which the "legality described in a standard" escape areas of execution practiced in society. The real time context of the national family is diverse and it can be seen situations where family violence levels reach extreme situations, the level reaching cases of “feminicidio”. This has been the factor that has allowed us to initially analyze the {{processes of}} family violence in which we developed in our work as the Public Prosecutor's Office (Ministerio Público). Given the need to intervene under the regulatory framework of our legislation we have observed that the very "law" has been decontextualized from reality, especially when cases of multiculturalism are discussed as well as matters outside parties themselves such as economic factors motivated interests. For our role as public prosecutors then we have seen a major in constant evolution, but also constantly parking situation. However contradictory positions can be represented under the following justification: The Supreme Court of the Republic and the Constitutional Court have generated binding case law on the protection of victims in cases of family violence, particularly where it develops a situation of psychological effects. Particularly the development of what is known as "Parental Alienation Syndrome" and "obstruction relationships" as complementary elements of the same process of violence are those who have motivated us to analyze this issue as theses, mainly because we have observed in personal experience and professional situations in which the complainants, defense attorneys or staff of the Judiciary and Public Prosecution have exposed foundations or level of applicability of the jurisprudence of the highest judicial offices in our country. In essence then, we note that although there is a binding case law on our subject, we could apply theoretically and procedurally such scope in our litigation practice as public prosecutors mainly because in between has not been a factor for institutional collaboration with the judiciary and the pair our forensic experts team has no clinical studies on the subject, based on their recent treatment. As you can see this picture is the one that allows us to execute the proposed research, the same as to have the conceptual and <b>referential</b> <b>constraint</b> on the bibliography does not allow us to extend our study, but that also allows us to argue that there is a need for both academic and professional to develop a study of the condition of a Thesis for the Degree of Master of our University, because we believe it could provide greater scope for reference on the subject to local and national academic community. Also notes that the cases evaluated in our institutional office, limited to general cases not being able to link a case with the binding law of the Judiciary and the Constitutional Court, but the extent of this social phenomenon of family violence go developing, the procedural mechanisms to limit its harmful effects on the local and national community will be found. Tesis presentada para optar por el Grado Académico de Maestro en Derecho con mención en Derecho Civil y Comercia...|$|E
50|$|SQL Server 2000 also {{introduced}} many T-SQL language enhancements, such as table variables, user-defined functions, indexed views, INSTEAD OF triggers, cascading <b>referential</b> <b>constraints</b> and some basic XML support.|$|R
5000|$|<b>Referential</b> <b>constraints</b> {{known as}} Foreign keys ensure that these {{attributes}} can only hold {{values that are}} {{also found in the}} corresponding attributes in the Supplier and Parts relations.|$|R
5000|$|Temporal <b>referential</b> {{integrity}} <b>constraints</b> for {{application time}} tables ...|$|R
5000|$|Because the {{database}} management system enforces <b>referential</b> <b>constraints,</b> it must ensure data integrity if rows in a referenced table are to be deleted (or updated). If dependent rows in referencing tables still exist, those references have to be considered. SQL:2003 specifies 5 different referential actions that shall take place in such occurrences: ...|$|R
5000|$|<b>Referential</b> {{integrity}} <b>constraints</b> including {{foreign key}} constraints, column constraints, and row checks ...|$|R
5000|$|The default storage {{engine is}} InnoDB, which {{supports}} transactions and <b>referential</b> integrity <b>constraints.</b>|$|R
5000|$|Does not {{natively}} enforce <b>referential</b> integrity <b>constraints,</b> i.e. parent-child relations must {{be maintained}} by application code.|$|R
50|$|Versions of MySQL 5.5 {{and greater}} have {{switched}} to the InnoDB engine to ensure <b>referential</b> integrity <b>constraints,</b> and higher concurrency.|$|R
40|$|International {{audience}} Open-world query answering is {{the problem}} of deciding, given a set of facts, conjunction of constraints, and query, whether the facts and constraints imply the query. This amounts to reasoning over all instances that include the facts and satisfy the constraints. We study finite open-world query answering (FQA), which assumes that the underlying world is finite and thus only considers the finite completions of the instance. The major known decidable cases of FQA derive from the following: the guarded fragment of first-order logic, which can express <b>referential</b> <b>constraints</b> (data in one place points to data in another) but cannot express number restrictions such as functional dependencies, and the guarded fragment with number restrictions but on a signature of arity only two. In this paper, we give the first decidability results for FQA that combine both <b>referential</b> <b>constraints</b> and number restrictions for arbitrary signatures: we show that, for unary inclusion dependencies and functional dependencies, the finiteness assumption of FQA can be lifted up to taking the finite implication closure of the dependencies[5]. Our result relies on new techniques to construct finite universal models of such constraints, for any bound on the maximal query size. </p...|$|R
40|$|We {{present a}} novel {{framework}} for mapping between {{any combination of}} XML and relational schemas, in which a high-level, userspecified mapping is translated into semantically meaningful queries that transform source data into the target representation. Our approach works in two phases. In the first phase, the high-level mapping, expressed {{as a set of}} inter-schema correspondences, is converted into a set of mappings that capture the design choices made in the source and target schemas (including their hierarchical organization as well as their nested <b>referential</b> <b>constraints)</b> ...|$|R
40|$|Prior {{studies of}} {{ambiguity}} resolution {{in young children}} have found that children rely heavily on lexical information but persistently fail to use <b>referential</b> <b>constraints</b> in online parsing (Trueswell, Sekerina, Hill & Logrip, 1999; Snedeker & Trueswell, 2004). This pattern is consistent with either a modular parsing system driven by stored lexical information or an interactive system which has yet to acquire low-validity <b>referential</b> <b>constraints.</b> In two experiments we explored whether children could use a third constraint—prosody—to resolve globally ambiguous prepositional-phrase attachments (“You can feel the frog with the feather”). Four to six years olds and adults were tested using the visual world paradigm. In both groups the fixation patterns were influenced by lexical cues by around 200 ms after {{the onset of the}} critical PP-object noun (“feather”). In adults the prosody manipulation had an effect in this early time window. In children the effect of prosody was delayed by approximately 500 ms. The effects of lexical and prosodic cues were roughly additive: prosody influenced the interpretation of utterances with strong lexical cues and lexical information had an effect on utterances with strong prosodic cues. We conclude that young children, like adults, can rapidly use both of these information sources to resolve structural ambiguities...|$|R
40|$|Open-world query {{answering}} is {{the problem}} of deciding, given a set of facts, conjunction of constraints, and query, whether the facts and constraints imply the query. This amounts to reasoning over all instances that include the facts and satisfy the constraints. We study finite open-world query answering (FQA), which assumes that the underlying world is finite and thus only considers the finite completions of the instance. The major known decidable cases of FQA derive from the following: the guarded fragment of first-order logic, which can express <b>referential</b> <b>constraints</b> (data in one place points to data in another) but cannot express number restrictions such as functional dependencies; and the guarded fragment with number restrictions but on a signature of arity only two. In this paper, we give the first decidability results for FQA that combine both <b>referential</b> <b>constraints</b> and number restrictions for arbitrary signatures: we show that, for unary inclusion dependencies and functional dependencies, the finiteness assumption of FQA can be lifted up to taking the finite implication closure of the dependencies. Our result relies on new techniques to construct finite universal models of such constraints, for any bound on the maximal query size. Comment: 59 pages. To appear in LICS 2015. Extended version including proof...|$|R
40|$|Referential {{integrity}} {{underlies the}} relational representation of objeceoriented structures. The concept of referential integrity in relational databases is hindered by the confusion surrounding both the concept {{itself and its}} implementation by relational database management systems (RDBMS). Most of this confusion {{is caused by the}} diversity of relational representations for object-oriented structures. We examine the relationship between these representations and the structure of <b>referential</b> integrity <b>constraints,</b> and show that the controversial structures either do not occur or can be avoided in the relational representations of object-oriented structures. Referential integrity is not supported uniformly by RDBMS products. Thus, <b>referential</b> integrity <b>constraints</b> can be specified in some RDBMSs nonprocedurally (declaratively), while in other RDBMSs they must be specified procedurally. Moreover, some RDBMSs do not allow the specification of certain <b>referential</b> integrity <b>constraints.</b> We discuss the referential integrity capabilities provided by three representative RDBMSs, DB 2, SYBASE, and INGRES. I...|$|R
40|$|AbstractCoupled {{transformation}} {{occurs when}} multiple software artifacts must be transformed {{in such a}} way that they remain consistent with each other. For instance, when a database schema is adapted in the context of system maintenance, the persistent data residing in the system's database needs to be migrated to conform to the adapted schema. Also, queries embedded in the application code and any declared <b>referential</b> <b>constraints</b> must be adapted to take the schema changes into account. As another example, in XML-to-relational data mapping, a hierarchical XML Schema is mapped to a relational SQL schema with appropriate <b>referential</b> <b>constraints,</b> and the XML documents and queries are converted into relational data and relational queries. The 2 LT project is aimed at providing a formal basis for coupled transformation. This formal basis is found in data refinement theory, point-free program calculation, and strategic term rewriting. We formalize the coupled transformation of a data type by an algebra of information-preserving data refinement steps, each witnessed by appropriate data conversion functions. Refinement steps are modeled by so-called two-level rewrite rules on type expressions that synthesize conversion functions between redex and reduct while rewriting. Strategy combinators are used to composed two-level rewrite rules into complete rewrite systems. Point-free program calculation is applied to optimized synthesize conversion function, to migrate queries, and to normalize data type constraints. In this paper, we provide an overview of the challenges met by the 2 LT project and we give a sketch of the solutions offered...|$|R
40|$|This paper {{considers}} {{the problem of}} containment of conjunctive queries (CQ) with disjunctive integrity constraints. Query containment problem {{in the presence of}} integrity constraints has been studied broadly, especially with functional and inclusion dependencies. However, to handle incomplete information in the database, disjunctions are needed to be expressed as integrity constraints. In this paper we introduce disjunctive <b>referential</b> integrity <b>constraints</b> and give a sound and complete algorithm for checking the containment of conjunctive queries under disjunctive <b>referential</b> and implication <b>constraints.</b> ...|$|R
40|$|Abstract: This paper {{describes}} {{a technique that}} can be used to bridge the gap between HTML, the standard markup language of the Web, and SQL, the standard query language used to access relational DBMS. It proposes a flexible general approach to the generation and validation of HTML forms based on Meta information (Metadata) held in catalog tables in typical relational database systems. In principle integrity <b>constraints</b> and <b>referential</b> <b>constraints,</b> can be used to restrict the data values accepted into our relational database tables. Java is used and particularly Java Database Connectivity (JDBC), which provides a very general method for addressing databases and also includes Metadata features...|$|R
5000|$|Functional {{dependencies}} however {{should not}} be confused with inclusion dependencies, which are the formalism for foreign keys; even though they are used for normalization, functional dependencies express constraints over one relation (schema), whereas inclusion dependencies express constraints between relation schemas in a database schema. Furthermore, the two notions do not even intersect in the classification of dependencies: functional dependencies are equality-generating dependencies whereas inclusion dependencies are tuple-generating dependencies. Enforcing <b>referential</b> <b>constraints</b> after relation schema decomposition (normalization) requires a new formalism, i.e. inclusion dependencies. In the decomposition resulting from Heath's theorem, there's nothing preventing the insertion of tuples in [...] having some value of X not found in [...]|$|R
50|$|If a <b>referential</b> {{integrity}} <b>constraint</b> {{is defined}} {{to the effect}} that {Shop Type, Nearest Shop} from the first table must refer to a {Shop Type, Shop} from the second table, then the data anomalies described previously are prevented.|$|R
40|$|Abstract. The inverse <b>referential</b> {{integrity}} <b>constraints</b> (IRICs) are specialization of non-key-based inclusion dependencies (INDs). Key-based INDs (<b>referential</b> integrity <b>constraints)</b> may {{be fully}} enforced by most current relational database management systems (RDBMSs). On the contrary, non-key-based INDs are completely disregarded by actual RDBMSs, obliging the users to manage them via custom procedures and/or triggers. In this paper we present {{an approach to}} the automated implementation of IRICs integrated in the SQL Generator tool that we developed {{as a part of}} the IIS*Studio development environment. In the paper the algorithms for insertion, modification and deletion control are presented, alongside with parameterized patterns for their implementation for DBMSs MS SQL Server 2008 and Oracle 10 g. It is also given an example of generated procedures/triggers...|$|R
50|$|Certain code-development {{frameworks}} can leverage {{certain forms}} of logic that are represented in the database's schema (such as <b>referential</b> integrity <b>constraints),</b> so that such issues are handled in a generic and standard fashion through library routines rather than ad hoc code written on a case-by-case basis.|$|R
40|$|A wide {{number of}} {{practical}} applications {{would benefit from}} automatically generated graphical representations of database schemas, in which tables are represented by boxes, and table attributes correspond to distinct stripes inside each table. Links, connecting attributes of two different tables, represent <b>referential</b> <b>constraints</b> or join relationships, and may attach arbitrarily to the left- or to the right hand side of the stripes representing the attributes. To our knowledge no drawing technique is available to automatically produce diagrams in such a strongly constrained drawing convention. In this paper we provide a polynomial time algorithm for solving this problem, and test its efficiency and effectiveness against a large test suite. Also, we describe an implementation {{of a system that}} uses such an algorithm and we study the main methodological problems we faced in developing such a technology...|$|R
40|$|Abstract. A {{two-level}} {{data transformation}} {{consists of a}} type-level transformation of a data format coupled with value-level transformations of data instances corresponding to that format. We have implemented a system for performing two-level transformations on XML schemas and their corresponding documents, and on SQL schemas and the databases that they describe. The core of the system consists of a combinator library for composing type-changing rewrite rules that preserve structural information and <b>referential</b> <b>constraints.</b> We discuss {{the implementation of the}} system’s core library, and of its SQL and XML front-ends in the functional language Haskell. We show how the system can be used to tackle various two-level transformation scenarios, such as XML schema evolution coupled with document migration, and hierarchical-relational data mappings that convert between XML documents and SQL databases. Key words: Haskell, Transformation, SQL, XML...|$|R
40|$|A data {{warehouse}} {{is a large}} data repository {{for the purpose of}} analysis and decision making in organizations. To improve the query performance and to get fast access to the data, data is stored as materialized views (MV) in the {{data warehouse}}. When data at source gets updated, the materialized views also need to be updated. In this paper, we focus on the problem of maintenance of these materialized views and address the issue of finding such auxiliary views (AV) that together with the materialized views make the data self-maintainable and take minimal space. We propose an algorithm that uses key and <b>referential</b> <b>constraints</b> which reduces the total number of tuples in auxiliary views and uses idea of information sharing between these auxiliary views to further reduce number of auxiliary views. Comment: Journal based on thesi...|$|R
40|$|A {{two-level}} {{data transformation}} {{consists of a}} type-level transformation of a data format coupled with value-level transformations of data instances corresponding to that format. We have implemented a system for performing two-level transformations on XML schemas and their corresponding documents, and on SQL schemas and the databases that they describe. The core of the system consists of a combinator library for composing type-changing rewrite rules that preserve structural information and <b>referential</b> <b>constraints.</b> We discuss {{the implementation of the}} system’s core library, and of its SQL and XML front-ends in the functional language Haskell. We show how the system can be used to tackle various two-level transformation scenarios, such as XML schema evolution coupled with document migration, and hierarchical-relational data mappings that convert between XML documents and SQL databases. Fundação para a Ciência e a Tecnologia (FCT) - POSI/ICHS/ 44304 / 2002...|$|R
5000|$|Element declarations, which define {{properties}} of elements. These include the element name and target namespace. An important property {{is the type}} of the element, which constrains what attributes and children the element can have. In XSD 1.1, the type of the element may be conditional on the values of its attributes. An element may belong to a substitution group; if element E is in the substitution group of element H, then wherever the schema permits H to appear, E may appear in its place. Elements may have integrity constraints: uniqueness constraints determining that particular values must be unique within the subtree rooted at an element, and <b>referential</b> <b>constraints</b> determining that values must match the identifier of some other element. Element declarations may be global or local, allowing the same name to be used for unrelated elements in different parts of an instance document.|$|R
5000|$|Virtuoso ORDBMS {{database}} supports entity {{integrity and}} referential integrity. Virtuoso ensures that relationships between records in related tables are valid by enforcing <b>referential</b> integrity. Integrity <b>constraints</b> include: ...|$|R
40|$|Studies {{with adult}} listene rs have {{demonstrated}} that prosody, lexical information and referential evidence all have rapid effect s on the interpretation of syntactically ambiguous sentences, lending support to highly interactive models of online interpretation. But young children in parallel studies often fail to use referential information and instead rely heavily on lexical constraints (Trueswell, Sekerina, Hill & Logr ip, 1999; Snedeker & Trueswell, 2004). This pattern is consistent with either a modular parsin g system driven by stored lexical information or an interactive system which has yet to acquire low-validity <b>referential</b> <b>constraints.</b> In two experiments, we used a spoken language eye-gaze pa radigm to demonstrate that four to six-year old children, and adults, rapidly use prosody to interpret prepositional-phrase attachment ambiguities. When both lexical and prosodic cu es are manipulated, they have independent (additive) effects on online inte rpretation. We conclude that young children, like adults, rapidly use multiple sources of information to resolve structural ambiguities...|$|R
40|$|We {{present a}} novel {{framework}} for mapping between {{any combination of}} XML and relational schemas, in which a high-level, userspecified mapping is translated into semantically meaningful queries that transform source data into the target representation. Our approach works in two phases. In the first phase, the high-level mapping, expressed {{as a set of}} inter-schema correspondences, is converted into a set of mappings that capture the design choices made in the source and target schemas (including their hierarchical organization as well as their nested <b>referential</b> <b>constraints).</b> The second phase translates these mappings into queries over the source schemas that produce data satisfying the constraints and structure of the target schema, and preserving the semantic relationships of the source. Nonnull target values may need to be invented in this process. The mapping algorithm is complete in that it produces all mappings that are consistent with the schema constraints. We have implemented the translation algorithm in Clio, a schema mapping tool, and present our experience using Clio on several real schemas. ...|$|R
40|$|This paper {{describes}} a technique for importing automatically an external relational schema into Pegasus, a heterogeneous, multidatabase system. The Pegasus data {{model is a}} functional object model which supports specialization, object-identity, and nested aggregation. The import algorithm generates {{the definition of a}} Pegasus schema which captures the semantics of a relational schema containing information about primary keys and <b>referential</b> integrity <b>constraints.</b> The algorithm described can be adapted easily for other semantic and objectoriented data models...|$|R
