147|377|Public
5000|$|... {{extending}} the <b>relational</b> <b>language</b> with hierarchy manipulations, {{such as in}} the nested relational algebra.|$|E
5000|$|The {{system is}} {{described}} as a behavioral modeling system based on [...] "fuzzy logic" [...] and a complex <b>relational</b> <b>language.</b>|$|E
50|$|It was {{designed}} at Imperial College, London by Steve Gregory and Keith L. Clark, as {{a descendant of}} IC Prolog and <b>Relational</b> <b>Language.</b>|$|E
40|$|In this work, a novel {{approach}} to the integration of <b>relational</b> and functional <b>languages</b> {{on the basis of}} abstract machines (in the context of the RELFUN language and implementation) is described. This integration is carried out for several reasons: to combine two declarative paradigms into a more expressive one, to allow existing software libraries in relational and functional (here LL, a COMMON LISP derivative) languages to be used together without the need of re-implementation, to speed up relational programs by transforming deterministic relations into functions, and to enhance the expressiveness of <b>relational</b> <b>languages</b> by new extra-logicals with the help of functions. The integration is performed on two levels: 1. on the abstract machine level (the WAM, the abstract machine behind most implementations of <b>relational</b> <b>languages,</b> and the LLAMA, an abstract machine especially designed for the efficient execution of LL, are coupled), and 2. on the source language level (LL functions are [...] ...|$|R
40|$|We {{study the}} problem of {{maintaining}} recursively defined views, such as the transitive closure of a relation, in traditional <b>relational</b> <b>languages</b> {{that do not have}} recursion mechanisms. The main results of this paper are negative ones: we show that a certain property of query languages implies impossibility of such incremental maintenance. 2003 Elsevier Science (USA). All rights reserved...|$|R
5000|$|Andl is an <b>relational</b> {{programming}} <b>language</b> with Sqlite or Postgres backend and Thrift interfaces.|$|R
5000|$|... {{extending}} the <b>relational</b> <b>language</b> with transitive closure, such as SQL's CONNECT statement; this allows a parent-child relation to be used, but execution remains expensive; ...|$|E
50|$|If a {{relational}} {{system has}} a low-level (single-record-at-a-time) language, that low level {{cannot be used}} to subvert or bypass the integrity rules and constraints expressed in the higher level <b>relational</b> <b>language</b> (multiple-records-at-a-time).|$|E
50|$|Some of the {{features}} included, and continue to include, a programming-free application development wizard, automatic multi-user capabilities, a full-featured 4GL programming language, form, report and label designers, and a fully ANSI SQL compliant <b>relational</b> <b>language</b> capability.|$|E
40|$|OQL is a query {{language}} {{proposed in the}} standard ODMG- 93 {{as a tool for}} declarative access to object bases. We argue that bindings of OQL to universal programming languages (C++, Smalltalk, Java) must inevitably lead to the infamous impedance mismatch {{that was one of the}} major points of criticism of <b>relational</b> <b>languages</b> by the object-oriented school. This criticism to a big extent is not relevant now, as many relational and extended <b>relational</b> <b>languages</b> avoid the impedance mismatch by integrating programming constructs, for example the SQL 3 standard, Oracle PL/SQL, or visual programming interfaces such as IBM VisualAge. As a remedy of this situation in the paper we discuss the integration of OQL with imperative programming constructs and abstractions in the spirit of the stack-based approach to object-oriented integrated query/programming languages. 1 Introduction The object database standard ODMG- 93 [9] is an important milestone in the development of object bases [3]. Perhaps the mos [...] ...|$|R
40|$|Graduation date: 2008 Building {{intelligent}} computer assistants {{has been}} a long-cherished goal of AI. Many intelligent assistant systems were built and fine-tuned to specific application domains. In this work, we develop a general model of assistance that combines three powerful ideas: decision theory, hierarchical task models and probabilistic <b>relational</b> <b>languages.</b> We use the principles of decision theory to model the general problem of intelligent assistance. We {{use a combination of}} hierarchical task models and probabilistic <b>relational</b> <b>languages</b> to specify prior knowledge of the computer assistant. The assistant exploits its prior knowledge to infer the user's goals and takes actions to assist the user. We evaluate the decision theoretic assistance model in three different domains including a real-world domain to demonstrate its generality. We show through experiments that both the hierarchical structure of the goals and the parameter sharing facilitated by relational models significantly improve the learning speed of the agent. Finally, we present the results of deploying our relational hierarchical model in a real-world activity recognition task...|$|R
40|$|In {{this paper}} we propose an extensible, flexible, multi-argument {{indexing}} technique for <b>relational</b> <b>languages.</b> We present a compiler producing indexing header code for a PROLOG emulator based on the Warren Abstract Machine. We will show that our technique combines positive aspects of relational database methods and other existing WAM-based indexing schemes. All the indexing concepts introduced are implemented in LISP for the relational-functional programming language RELFUN...|$|R
50|$|The {{data base}} {{description}} is represented at the logical {{level in the}} same way as ordinary data, so that authorized users can apply the same <b>relational</b> <b>language</b> to its interrogation as they apply to the regular data.|$|E
5000|$|The first {{concurrent}} {{logic programming}} language was the <b>Relational</b> <b>Language</b> of Clark and Gregory, {{which was an}} offshoot of IC-Prolog. Later versions of concurrent logic programming include Shapiro's Concurrent Prolog and Ueda's Guarded Horn Clause language [...]|$|E
5000|$|Let L be {{a finite}} <b>relational</b> <b>language.</b> Fix C {{a class of}} finite L-structures which are closed under isomorphisms andsubstructures. We want to {{strengthen}} the notion of substructure; let be a relation on pairs from C satisfying: ...|$|E
5000|$|SQL - a <b>relational</b> query <b>language</b> {{developed}} for IBM's System R; now the standard RDBMS query language ...|$|R
40|$|In FLIP, a novel {{approach}} to the integration of <b>relational</b> and functional <b>languages</b> {{on the basis of}} abstract machines (in the context of the RELFUN language and implementation) is described. This integration is carried out for several reasons: to combine two declarative paradigms into a more expressive one, to allow existing software libraries in relational and functional (here LL, a COMMON LISP derivative) languages to be used together without the need of re-implementation, to speed up relational programs by transforming deterministic relations into functions, and to enhance the expressiveness of <b>relational</b> <b>languages</b> by new extra-logicals with the help of functions. The integration is performed on two levels: 1. on the abstract machine level (the WAM, the abstract machine behind most implementations of <b>relational</b> <b>languages,</b> and the LLAMA, an abstract machine especially designed for the efficient execution of LL, are coupled), and 2. on the source language level (LL functions are accessible from relations and vice versa). One of the major points of this work is the detection and transformation of deterministic relations (into LL functions), resulting in a speed-up factor of 2 - 4. For this, a theoretical foundation for deterministic relations and several intermediate representation languages for the transformation process are developed...|$|R
5000|$|Zhang, N. 2008. Gapless {{relative}} clauses as clausal licensers of <b>relational</b> nouns, <b>Language</b> and Linguistics 9 (4): 1005-1028.|$|R
5000|$|K. L. Clark, S. Gregory, A <b>relational</b> <b>language</b> for {{parallel}} programming, Proc. ACM Conference on Functional Languages and Computer Architecture, ACM, New York, 171-178 pp, 1981. (Also in Concurrent Prolog, (ed. E Shapiro), MIT Press, 9-26 pp, 1987.) ...|$|E
50|$|Clark's key {{contributions}} {{have been}} in the field of logic programming. His 1978 paper on negation as failure was arguably the first formalisation of a non-monotonic logic. His 1981 paper on a <b>relational</b> <b>language</b> for parallel programming introduced concurrent logic programming.|$|E
5000|$|Let [...] be a {{countable}} admissible set. Let [...] be an -finite <b>relational</b> <b>language.</b> Suppose [...] {{is a set}} of -sentences, where [...] is a [...] {{set with}} parameters from , and every -finite subset of [...] is satisfiable. Then [...] is satisfiable.|$|E
40|$|We {{present a}} very simple but {{flexible}} declarative debugging scheme. A declarative debugger can be defined in Prolog with a single clause, and relies on the definition of just two additional predicates. With suitable definitions of these predicates, the debugger can diagnose several classes of bugs in many languages. We give examples of diagnoses of wrong answers in functional, <b>relational,</b> and object-oriented <b>languages</b> as well as missing answers in <b>relational</b> <b>languages</b> and calls that are not well defined in functional languages. By using declarative semantics of programs, the debugger is able to hide complex execution mechanisms such as unification, backtracking, coroutining, parallelism, higher-order functions, lazy evaluation, message passing, and inheritance...|$|R
50|$|A {{probabilistic}} <b>relational</b> programming <b>language</b> (PRPL) is a PPL {{specially designed}} {{to describe and}} infer with probabilistic relational models (PRMs).|$|R
40|$|Non-deterministic {{operators}} {{are needed in}} First-Order <b>relational</b> <b>languages</b> and Datalog to extend the expressive power of such languages and support efficient formulations of low complexity problems. In this paper, we study the operators proposed in the literature, including witness, lazy choice and dynamic choice, and compare their power of expressing deterministic and non-deterministic queries. We obtain a simple hierarchy that relates these operators {{with each other and}} with other constructs, such as negation and fixpoint...|$|R
50|$|The future and/or promise {{constructs}} {{were first}} implemented in programming languages such as MultiLisp and Act 1. The use of logic variables for communication in concurrent logic programming languages was {{quite similar to}} futures. These began in Prolog with Freeze and IC Prolog, and became a true concurrency primitive with <b>Relational</b> <b>Language,</b> Concurrent Prolog, guarded Horn clauses (GHC), Parlog, Strand, Vulcan, Janus, Oz-Mozart, Flow Java, and Alice ML. The single-assignment I-var from dataflow programming languages, originating in Id and included in Reppy's Concurrent ML, is much like the concurrent logic variable.|$|E
50|$|Sound {{structure}} (phonological and phonetic) {{studies of}} focus {{are not as}} numerous, as <b>relational</b> <b>language</b> phenomena tend to be of greater interest to syntacticians and semanticists. But this may be changing: a {{recent study found that}} not only do focused words and phrases have a higher range of pitch compared to words in the same sentence but that words following the focus in both American English and Mandarin Chinese were lower than normal in pitch and words before a focus are unaffected. The precise usages of focus in natural language are still uncertain. A continuum of possibilities could possibly be defined between precisely enunciated and staccato styles of speech based on variations in pragmatics or timing.|$|E
40|$|We study free {{amalgamation}} classes over {{a finite}} <b>relational</b> <b>language</b> and their applications {{to the model}} companions of ∀ 1 classes over a finite <b>relational</b> <b>language.</b> If an ∀ 1 class K is a free amalgamation class over a finite <b>relational</b> <b>language</b> with edges, the model companion is nqfa(1) : non-finitely axiomatizable even modul...|$|E
40|$|We {{study the}} problem of {{maintaining}} recursively-dened views, such as the transitive closure of a relation, in traditional <b>relational</b> <b>languages</b> {{that do not have}} recursion mechanisms. The main results of this paper are negative ones: we show that a certain property of query languages implies impossibility of such incremental maintenance. The property we use is locality of queries, which is known to hold for relational calculus and various extensions, including those with grouping and aggregate constructs (essentially, plain SQL). ...|$|R
40|$|OBJECTIVE/DESCRIPTION: To {{provide an}} {{introduction}} to data models, database systems, the structure and use of relational database systems and <b>relational</b> <b>languages,</b> indexing and storage management, query processing in relational databases, and the theory of relational database design. The course concentrates on the relational model, with a brief introduction to entity-relationship, hierarchical and network data models as well. Assignment work will include the design and implementation of a database using the Microsoft SQL Server relational database management system. TOPICS: An introduction to Database Systems...|$|R
40|$|AbstractWe {{study the}} problem of {{maintaining}} recursively defined views, such as the transitive closure of a relation, in traditional <b>relational</b> <b>languages</b> {{that do not have}} recursion mechanisms. The main results of this paper are negative ones: we show that a certain property of query languages implies impossibility of such incremental maintenance. The property we use is locality of queries, which is known to hold for relational calculus and various extensions, including those with grouping and aggregate constructs (essentially, plain SQL) ...|$|R
40|$|This paper {{explores the}} role of <b>relational</b> <b>language</b> in the {{development}} of children’s analogical reasoning ability. In two experiments, children were asked to make a relational mapping between two pictures while ignoring a competing object match. Three-and-a-half-year-olds, 5 -year-olds, and 7 -year-olds were all more successful at this task when they heard <b>relational</b> <b>language.</b> Experiment 2 further demonstrated that children were as good at finding the relational match with an object match present if they heard <b>relational</b> <b>language</b> as they were when there was no compelling object match present at all. These results suggest that <b>relational</b> <b>language</b> may be important in instilling the ability to reason analogically...|$|E
40|$|Young children‟s {{performance}} on certain mapping tasks {{can be improved}} by introducing <b>relational</b> <b>language</b> (Gentner, 1998). We show that children‟s {{performance on}} a spatial mapping task can be modeled using the Structure-Mapping Engine (SME) to simulate the comparisons involved. To model the effects of <b>relational</b> <b>language</b> in our simulations, we vary the quantity {{and nature of the}} spa-tial relations and object descriptions represented. The results reproduce the trends observed in the developmental studies of Loewens-tein & Gentner (1998; in preparation). The results of these simulations are consistent with the claim that gains in relational represen-tation are a major contributor to the development of spatial mapping ability. We further suggest that <b>relational</b> <b>language</b> can promote relational representation...|$|E
40|$|We {{investigated}} {{the claim that}} <b>relational</b> <b>language</b> promotes the development of relational reasoning (Gentner, 2003). Prior research has shown the benefit of spatial <b>relational</b> <b>language</b> (e. g. top, middle, bottom) in preschoolers’ performance in spatial mapping (Loewenstein and Gentner, 2005), suggesting that spatial <b>relational</b> <b>language</b> invites a delineated relational representation. We generalized this conclusion by testing the benefit of using nonspatial <b>relational</b> <b>language</b> in a spatial analogical task. Preschool children were presented with two identical three-tiered boxes, in which they watched an item being hidden in one box and {{were then asked to}} search for a similar item in the corresponding location at the second box. Half of the children heard a set of systematic terms conveying monotonic structure (1 2 3), whereas {{the other half of the}} children heard non-systematic terms consisting of names of familiar animals. Both sets of terms are familiar to preschoolers and neither directly denotes spatial locations. We found that preschool children who heard the 123 labels performed better than those who heard animal names. The results are evidence of young children’s sensitivity to the relational structure conveyed by language, and to their ability to apply this structure into a different domain...|$|E
5000|$|Jones, S., Mason, P. & Stamper, R.K. (1979). [...] "LEGOL 2.0: A <b>relational</b> {{specification}} <b>language</b> {{for complex}} rules." [...] Information Systems 4(4) 1979, pp 293-305.|$|R
40|$|In {{this work}} we survey the {{connections}} between modal logic and relation algebra. We compare various modal and <b>relational</b> <b>languages</b> for the specification of reactive systems by giving new translation algorithms between these languages. We then characterize the expressiveness of the languages algebraically with p-morphisms (or bisimulations). Furthermore, we show how completeness and incompleteness proofs of modal logic can be transferred to relation algebra, and give a relation algebraic treatment of modal correspondence theory. We show how our methods {{can be applied to}} stronger languages like those containing derivation rules or fixpoint operators. ...|$|R
40|$|We generalize {{the stable}} graph {{regularity}} lemma of Malliaris and Shelah {{to the case}} of finite structures in finite <b>relational</b> <b>languages,</b> e. g., finite hypergraphs. We show that under the model-theoretic assumption of stability, such a structure has an equitable regularity partition of size polynomial in the reciprocal of the desired accuracy, and such that for each $k$-ary relation and $k$-tuple of parts of the partition, the density is close to either 0 or 1. In addition, we provide regularity results for finite and Borel structures that satisfy a weaker notion that we call almost stability. Comment: 37 pages. Minor improvement...|$|R
