1|9|Public
5000|$|The {{permanently}} <b>resident</b> <b>kernel</b> of {{this powerful}} multiprocessor mainframe computing utility, much derided in its day {{as being too}} large and complex, was only 135 KiB of code. In comparison, a Linux system in 2007 might have occupied 18 MiB. [...] The first MIT GE-645 had 512 kilowords of memory (2 MiB), a truly enormous amount at the time, and the kernel used only a moderate portion of Multics main memory.|$|E
40|$|This paper {{describes}} in high-level terms {{the implementation of}} the <b>resident</b> UNIX+ <b>kernel.</b> This discussion is broken into three parts. The first part describes how the UNIX system views processes, users, and programs. The second part describes the I/O system. The last part describes the UNIX file system...|$|R
50|$|Forth {{became very}} popular in the 1980s because it was well suited to the small {{microcomputers}} of that time, being compact and portable. At least one home computer, the British Jupiter ACE, had Forth in its ROM-resident operating system. The Canon Cat also used Forth for its system programming, and Rockwell produced single-chip microcomputers with <b>resident</b> Forth <b>kernels,</b> the R65F11 and R65F12. A complete family tree is at TU-Wien.Insoft GraFORTH was a version of Forth with graphics expansions for the Apple II. ASYST was a Forth expansion for measuring and controlling on PCs.|$|R
40|$|The paper {{deals with}} the problem of fuzzy system design. Many {{producers}} offer software tools supporting design and tuning of fuzzy system. Once the fuzzy sytem/controller is designed, it can be implemented in a fuzzy hardware or as a software program. For industrial application, a relatively cheep microcontroller with limited resources is often selected. The implementation of the target code must respect the limited on board memory space and limited operational speed. We present an educational fuzzy development environment FREG/M especially oriented to design and debugging a fuzzy system/controller for the platform of Motorola microcontrollers 68 HC 11. The concept of the design system utilizes the <b>resident</b> RunTime <b>Kernel</b> which works under the knowledge base. The FREG/M system enables the semiautomated composing of the total target code for the developed fuzzy application. In the paper there is also the problem of computational speed and the system monitoring disscused. 1 Introduction [...] ...|$|R
40|$|This paper {{describes}} in high-level terms {{the implementation of}} the <b>resident</b> UNIX+ <b>kernel.</b> This discussion is broken into three parts. The first part describes how the UNIX system views processes, users, and programs. The second part describes the I/O system. The last part describes the UNIX file system. 1. INTRODUCTION The UNIX kernel consists of about 10, 000 lines of C code and about 1, 000 lines of assembly code. The assembly code can be further broken down into 200 lines included for the sake of efficiency (they could have been written in C) and 800 lines to perform hardware functions not possible in C. This code represents 5 to 10 percent of what has been lumped into the broad expression "the UNIX operating system. " The kernel is the only UNIX code that cannot be substituted by a user to his own liking. For this reason, the kernel should make as few real decisions as possible. This does not mean to allow the user a million options to do the same thing. Rather, it means to allow o [...] ...|$|R
40|$|In field plot experiments, an atoxigenic {{strain of}} Aspergillus flavus {{interfered}} with preharvest aflatoxin contamination of corn when applied either simultaneously with or one day {{prior to a}} toxigenic strain. The atoxigenic strain reduced preharvest aflatoxin contamination 80 to 95 %. The atoxigenic strain was also effective in reducing postharvest aflatoxin contamination caused by both an introduckd toxigenic strain and by strains <b>resident</b> on the <b>kernels.</b> The results suggest that atoxigenic strains of A. flavus may have potential use as biological control agents directed at reducing both preharvest and postharvest aflatoxin contamination of corn. Aflatoxins, toxic metabolites of the fungi Aspergillus jlavus Link: Fr. and A. parasiticus Speare, are potent carcinogens which pose serious health hazards to human...|$|R
40|$|The aim of {{the study}} was to analyze the {{differences}} between the home range landscape structure of resident and translocated brown hares during the non- hunting period (January-June). The trial was carried out in the typical hilly landscape of central Italy (Florence province, X = 1667003 Y = 4844543, ref. Rome, 1940). During the capture operations for the translocation, 20 hares were captured and equipped with a necklace radio tag (Biotrak, TW 3) : 6 hares (4 males and 2 females) were immediately released in the same non-hunting area where they had been captured and 14 hares (7 males and 7 females) were translocated in a neighbouring Hunting Territory. The tagged hares were localized, and/or sighted individually, 2 - 3 times a week, from mid January to mid June, 2007. UTM coordinates were determinated for each localization using a portable GPS than transferred on Arc View software. Animal movement extension was used to calculate Max, min and average daily movements. Kernel method was used to calculate each home range. Home range sizes also were calculated using the MCP method. Maximum distance from the releasing sites and maximum distance from centroid were also calculated for translocated hares and resident hares, respectively. Aerial photographs (scale 1 : 10000) geo-referenced and digitalized were used. 14 different land use categories were selected and digitalized in a vector format. These land use were composed by natural uses (woods, shrubs-area, river and ponds), agricultural uses (crops for game, orchards and gardens, grasses and pastures, uncultivated fields, winter and spring cereals, vineyards, tree orchards and poplars, olive orchards) and anthropomorphized uses (extractive and construction sites, road and urban areas). Landscape metrics for home range (patch density, edge density, fractal dimension, contagion) were calculated using FRAGSTATS software after rasterization process. Results showed that the Max distance from the releasing sites in the translocated hares was significantly greater than the maximum distance from centroid in the resident hares (simple = radius, or doubled = diameter), (1. 281 vs. 368 or 736 m, p < 0. 05). Home range sizes also differed in relationship to translocated and <b>resident’s</b> (<b>Kernel</b> 173 vs. 23 ha and MCP 63 vs. 9 ha p < 0. 05). Considering landscape structure indices, the translocated hares preferred landscape characterized by a lower density of patches and edges than the resident’s (70 vs. 152 n/ 100 ha and 258 vs. 448 m/ha, p< 0. 01). Moreover translocated hares preferred areas characterized by greater aggregation and a lower path shape complexity than resident’s (contagion index: 61 vs. 54 %; fractal dimension index: 1. 11 vs 1. 12, p< 0. 01). Either the home range sizes or the maximum distance from the releasing sites suggest that the translocated hares must be however released in suited habitats or the animal will move from their releasing point searching better habitats. The increased travels, increase the risk to be killed by the predators or by the vehicles in the crossing roads...|$|R
40|$|We {{suggest to}} model {{software}} package flaws (bugs) by assuming eventual Byzantine {{behavior of the}} package. In particular, the package has been tested by the manufacturer for limited length scenarios when started in a predefined initial state; the behavior beyond the tested scenario may be Byzantine. Restarts (reboots) are useful for recovering such systems. We suggest a general yet practical framework and paradigm, based on a theoretical foundation, for the monitoring and restarting of systems. An autonomic recoverer that monitors and restarts the system is proposed, where: The autonomic recoverer is designed to handle different tasks given specific task requirements {{in the form of}} predicates and actions. DAG subsystem hierarchy structure is used by a consistency monitoring procedure in order to achieve gracious recovery. The existence and correct functionality of the autonomic recovery is guaranteed by the use of a <b>kernel</b> <b>resident</b> (anchor) process, and the design of the process to be self-stabilizing. The autonomic recoverer uses the new scheme for liveness assurance via on-line monitoring that complements known schemes for on-line ensuring safety...|$|R
40|$|File System {{development}} is a diÆcult and time consuming task, the results of which are rarely portable across operating systems. Several proposals to improve the vnode interface to allow for more exible le system design and implementation {{have been made in}} recent years, but none is used in practice because they require costly fundamental changes to kernel interfaces, only operating systems vendors can make those changes, are still non-portable, tend to degrade performance, and do not appear to provide immediate return on such an investment. This proposal advocates a language for describing le systems, called FiST. The associated translator can generate portable C code | <b>kernel</b> <b>resident</b> or not | that implements the described le system. No kernel source code is needed and no existing vnode interface must change. The performance of the le systems automatically generated by FiST can be within a few percent of comparable hand-written le systems. The main benets to automation are that development and maintenance costs are greatly reduced, and that it becomes practical to prototype, implement, test, debug, and compose a vastly larger set of such le systems with dierent properties. The proposed thesis will describe the language and its translator, use it to implement a few le systems on more than one platform, and evaluate the performance of the automatically generate...|$|R
40|$|Data {{encryption}} {{has become}} an increasingly important factor in everyday work. Users seek a method of securing their data with maximum comfort and minimum additional requirements on their part; they want a security system that protects any files used by any of their applications, without resorting to application-specific encryption methods. Performance {{is an important factor}} to users since encryption can be time consuming. Operating system vendors want to provide this functionality but without incurring the large costs of developing a new file system. This paper describes the design and implementation of Cryptfs — a file system that was designed as a stackable Vnode layer loadable kernel module[5, 15, 19]. Cryptfs operates by “encapsulating ” a client file system with a layer of encryption transparent to the user. Being <b>kernel</b> <b>resident,</b> Cryptfs performs better than user-level or NFS based file servers such as CFS[2] and TCFS[3]. It is 2 to 37 times faster on micro-benchmarks such as read and write; this translates to 12 - 52 % application speedup, as exemplified by a large build. Cryptfs offers stronger security by basing its keys on process session IDs as well as user IDs, and by the fact that kernel memory is harder to access. Working at and above the vnode level, Cryptfs is more portable than a file system which works directly with native media such as disks and networks. Cryptfs can operate on top of any other native file system such as UFS/FFS[8] and NFS[11, 16]. Finally, Cryptfs requires no changes to client file systems or remote servers. ...|$|R

