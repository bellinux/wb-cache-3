122|16|Public
25|$|The Direct3D 10 API {{introduces}} unified vertex shader and pixel shader. In addition, it {{also supports}} geometry shaders, which operate on entire geometric primitives (points, lines, and triangles), and can allow calculations based on adjacent primitives as well. The {{output of the}} geometry shader can be passed directly onwards to the <b>rasterizer</b> for interpolation and pixel shading, or written to a vertex buffer (known as 'stream out') to be fed back into {{the beginning of the}} pipeline.|$|E
25|$|During {{his time}} at Microsoft and Definition Six, Hecker wrote an {{influential}} programming column for Game Developer Magazine. Two series of articles from this column still serve today as standard references on their respective subjects. The first series was the first complete synthesis of perspectively-correct texture mapping and formed the mathematical basis for many important game rasterizers, including Michael Abrash's <b>rasterizer</b> for the 3D title Quake. The second was a series on rigid body dynamics simulation for games, complete with an extensive bibliography of rigid body dynamics resources. The articles {{were part of a}} general push by Hecker to incorporate more interactive physics into games, which at the time in 1996 rarely featured any physical simulation. In the summer of 1997, Hecker stepped down as author of the regular column to focus on game development full-time.|$|E
2500|$|<b>Rasterizer</b> – creates {{fragments}} and interpolates per-vertex constants such as texture coordinates and color ...|$|E
5000|$|Mazatech AmanithVG GLE - commercial. Built {{on top of}} OpenGL 1.1+ and OpenGL ES 1.x. Claim “achieving better {{performance}} than software <b>rasterizers</b> in terms of high resolution animations and complex special effects (transparencies, fading, realtime rotoscaling and many others).” ...|$|R
50|$|Some {{software}} <b>rasterizers</b> use 'span buffering' (or 'coverage buffering'), {{in which}} a list of sorted, clipped spans are stored in scanline buckets. Primitives would be successively added to this datastructure, before rasterizing only the visible pixels in a final stage.|$|R
50|$|The {{most basic}} {{rasterization}} algorithm takes a 3D scene, described as polygons, and renders {{it onto a}} 2D surface, usually a computer monitor. Polygons are themselves represented as collections of triangles. Triangles are represented by 3 vertices in 3D-space. At a very basic level, <b>rasterizers</b> simply take a stream of vertices, transform them into corresponding 2-dimensional points on the viewer’s monitor and fill in the transformed 2-dimensional triangles as appropriate.|$|R
50|$|Once {{all of the}} {{necessary}} steps are completed from the two previous stages, all the elements, including the lines that have been drawn and the models that have been transformed, are ready to enter the <b>rasterizer</b> stages. <b>Rasterizer</b> stage means turning all of those elements into pixels, or picture elements, and adding color onto them.|$|E
5000|$|<b>Rasterizer</b> - creates {{fragments}} and interpolates per-vertex constants such as texture coordinates and color ...|$|E
5000|$|The {{anti-aliasing}} graphics <b>rasterizer</b> code {{uses the}} open source Pisces renderer {{used in the}} phoneME project.|$|E
5000|$|GCN 2nd {{generation}} {{introduced an}} entity called [...] "Shader Engine" [...] (SE). A Shader Engine comprises one geometry processor, up to 11 CUs (Hawaii chip), <b>rasterizers,</b> ROPs, and L1 cache. Not {{part of a}} Shader Engine is the Graphics Command Processor, the 8 ACEs, the L2 cache and memory controllers {{as well as the}} audio and video accelerators, the display controllers, the 2 DMA controllers and the PCIe interface.|$|R
50|$|D-Type Font Engine is an independent, {{proprietary}} {{and portable}} font rasterization library. It provides anti-aliasing, subpixel precision, automatic hinting, bitmap filtering and other techniques that {{can improve the}} appearance and legibility of text on screen. According to the authors, the display quality of D-Type Font Engine can be configured to match or exceed the quality of Windows and Mac OS X font <b>rasterizers</b> while using only non-hinted TrueType, OpenType or Type 1 fonts.|$|R
25|$|Digital fonts {{may also}} contain data {{representing}} the metrics used for composition, including kerning pairs, component creation data for accented characters, glyph substitution rules for Arabic typography and for connecting script faces, and for simple everyday ligatures like ﬂ. Common font formats include TrueType, OpenType and PostScript Type 1, while Metafont is still used by TeX and its variants. Applications using these font formats, including the <b>rasterizers,</b> appear in Microsoft and Apple Computer operating systems, Adobe Systems products {{and those of}} several other companies. Digital fonts are created with font editors such as FontForge, RoboFont, Glyphs, Fontlab's TypeTool, FontLab Studio, Fontographer, or AsiaFont Studio.|$|R
5000|$|Image space photon mapping {{achieves}} real-time {{performance by}} computing {{the first and}} last scattering using a GPU <b>rasterizer.</b>|$|E
5000|$|PDF <b>Rasterizer</b> SDK: Convert vector-based PDF {{files to}} raster images (JPEG, TIF, PDF, PNG etc.) for viewing and printing.|$|E
50|$|Java: In 2007, Sun Microsystems {{switched}} from using a proprietary font <b>rasterizer</b> to using FreeType in the OpenJDK Java development kit.|$|E
50|$|Irrlicht {{supports}} 3D rendering via OpenGL, DirectX 8, 9, and 11 (with DirectX 11 extension), {{and internal}} software <b>rasterizers.</b> DirectX 8 {{will not be}} supported after 1.8.1, effectively ending support for Xbox. External renderers and windowing systems plug in through simple interfaces, giving rise to a community-made Simple DirectMedia Layer (SDL) video driver and support for iPhone and Symbian devices.The engine comes with a library of standard material renderers, allowing fallback materials where user hardware is unable to handle advanced methods. New materials {{can be added to}} the engine at run-time, allowing users to write their own as needed. In addition to legacy fixed-function pipeline materials, programmable Pixel and Vertex Shaders (1.1 to 3.0 and 4.0 using GLSL), ARB Fragment and Vertex Programs, HLSL, Cg and GLSL materials are supported.|$|R
50|$|There are {{a number}} of shading {{algorithms}} for <b>rasterizers.</b> All shading algorithms need to account for distance from light and the normal vector of the shaded object with respect to the incident direction of light. The fastest algorithms simply shade all pixels on any given triangle with a single lighting value, also known as flat shading. There is no way to create the illusion of smooth surfaces this way, except by subdividing into many small triangles. Algorithms can also separately shade vertices, and interpolate the lighting value of the vertices when drawing pixels. This is known as Gouraud shading. The slowest and most realistic approach is to calculate lighting separately for each pixel, also known as Phong shading. This performs bilinear interpolation of the normal vectors and uses the result to do local lighting calculation.|$|R
5000|$|Mac OS X's Quartz is {{distinguished}} {{by the use}} of floating-point positioning it does not force glyphs into exact pixel locations, instead using various antialiasing techniques, including subpixel rendering, to position characters and lines to appear closer to the type designer's intent. The result is that the on-screen display looks extremely similar to printed output, but can occasionally be difficult to read at smaller point sizes. Contrary to other <b>rasterizers,</b> Quartz ignores any Postscript or TrueType hints in the font and solely relies on its own algorithm. A simpler type of font antialiasing was introduced in Mac OS 8.5, in 1998. Apple's technique can be seen on Windows in older versions of Safari for Windows. In more recent versions, however, Apple has switched to using system settings by default.|$|R
50|$|In Windows 10, WARP {{has been}} updated to support Direct3D 12 at feature level 12_1; under Direct3D 12, WARP also replaces the Reference <b>rasterizer.</b>|$|E
5000|$|Windows Advanced Rasterization Platform (WARP), a {{software}} <b>rasterizer</b> component for DirectX that provides {{all of the}} capabilities of Direct3D 10.0 and 10.1 in software.|$|E
5000|$|The open-sourced Pisces {{renderer}} {{used in the}} phoneME {{project has}} replaced the anti-aliasing graphics <b>rasterizer</b> code. This code is fully functional, but still needs some performance enhancements, ...|$|E
40|$|Tiling architectures, being {{capable of}} saving memory {{bandwidth}} on frame buffer accesses {{as well as}} requiring modest storage for full-scene antialiasing, are the most suitable candidates for graphics hardware implementations in embedded systems. The main difficulty with the existing primitive traversal algorithms when adapted to the tilebased paradigm {{is to find a}} first rasterization tile position inside the to be rasterized primitive. Previous investigations indicate that when the classical traversal algorithm is utilized in conjunction with tile based rasterization the overhead associated with the finding of the first rasterization point can be between 40 %- 300 % of the primitive rasterization time. In this report we attempt to alleviate this problem by proposing heuristic hardware algorithms to accelerate primitive traversal in 3 D graphics tile-based <b>rasterizers.</b> To reduce the overhead we propose several hardware algorithms (that can b...|$|R
40|$|Traditionally, {{hardware}} <b>rasterizers</b> only {{support the}} Phong lighting model {{in combination with}} Gouraud shading using point light sources. However, the Phong lighting model is strictly empirical and physically implausible. Gouraud shading also tends to undersample the highlight unless a highly tesselated surface is used. Hence, higher-quality hardware accelerated lighting and shading has gained much interest in the recent five years. The research on hardware lighting and shading is two-fold. On the one hand, better lighting models for local il-lumination (assuming point light sources but evaluated per pixel) were demonstrated to be amenable to hardware implementation. On the other hand, recent {{research has demonstrated that}} even area lights, represented as envi-ronment maps, can be combined with complex lighting models. In both areas, many articles have been published, making it hard to decide, which algorithm is well-suited for which application. This state-of-the-art report will review all relevent articles in both areas, and list advantages and disadvantages of each algorithm...|$|R
50|$|Over time, Microsoft {{began to}} work more closely with {{hardware}} developers, and started to target the releases of DirectX to coincide {{with those of the}} supporting graphics hardware. Direct3D 5.0 was the first version of the burgeoning API to gain widespread adoption in the gaming market, and it competed directly with many more-hardware-specific, often proprietary graphics libraries, while OpenGL maintained a strong following. Direct3D 7.0 introduced support for hardware-accelerated transform and lighting (T&L) for Direct3D, while OpenGL had this capability already exposed from its inception. 3D accelerator cards moved beyond being just simple <b>rasterizers</b> to add another significant hardware stage to the 3D rendering pipeline. The Nvidia GeForce 256 (also known as NV10) was the first consumer-level card released on the market with hardware-accelerated T&L, while professional 3D cards already had this capability. Hardware transform and lighting, both already existing features of OpenGL, came to consumer-level hardware in the '90s and set the precedent for later pixel shader and vertex shader units which were far more flexible and programmable.|$|R
50|$|New Version is 17.1.0 in 10. May 2017 {{with some}} {{interesting}} improvements. OpenGL 4.2+ for Intel Ivy Bridge and OpenGL 3.3+ for Intel Open SWR <b>Rasterizer</b> are 2 of some more Highlights.|$|E
5000|$|Rasterizer: Converts {{primitives}} into pixels, feeding these pixels {{into the}} pixel shader. The <b>Rasterizer</b> may also perform other {{tasks such as}} clipping what is not visible, or interpolating vertex data into per-pixel data.|$|E
50|$|Windows Advanced Rasterization Platform (WARP) is a {{software}} <b>rasterizer</b> and {{a component of}} DirectX graphics runtime in Windows 7 and later. It is available for Windows Vista and Windows Server 2008 through platform update for Windows Vista.|$|E
40|$|Pixel art is {{a popular}} style of digital art often found in video games. It is {{typically}} characterized by its low resolution and use of limited colour palettes. Pixel art is created manually with little automation because it requires attention to pixel-level details. Working with individual pixels is a challenging and abstract task, whereas manipulating higher-level objects in vector graphics is much more intuitive. However, {{it is difficult to}} bridge this gap because although many rasterization algorithms exist, they are not well-suited for the particular needs of pixel artists, particularly at low resolutions. In this thesis, we introduce a class of rasterization algorithms called pixelation that is tailored to pixel art needs. We describe how our algorithm suppresses artifacts when pixelating vector paths and preserves shape-level features when pixelating geometric primitives. We also developed methods inspired by pixel art for drawing lines and angles more effectively at low resolutions. We compared our results to rasterization algorithms, <b>rasterizers</b> used in commercial software, and human subjects [...] -both amateurs and pixel artists. Through formal analyses of our user study studies and a close collaboration with professional pixel artists, we showed that, in general, our pixelation algorithms produce more visually appealing results than naïve rasterization algorithms do...|$|R
40|$|Search-based texture {{synthesis}} algorithms {{are sensitive}} to the order in which texture samples are generated; different synthesis orders yield different textures. Unfortunately, most polygon <b>rasterizers</b> and ray tracers do not guarantee the order with which surfaces are sampled. To circumvent this problem, textures are synthesized beforehand at some maximum resolution and rendered using texture mapping. We describe a search-based texture synthesis algorithm in which samples can be generated in arbitrary order, yet the resulting texture remains identical. The key to our algorithm is a pyramidal representation in which each texture sample depends only on a fixed number of neighboring samples at each level of the pyramid. The bottom (coarsest) level of the pyramid consists of a noise image, which is small and predetermined. When a sample is requested by the renderer, all samples on which it depends are generated at once. Using this approach, samples can be generated in any order. To make the algorithm efficient, we propose storing texture samples and their dependents in a pyramidal cache. Although the first few samples are expensive to generate, there is substantial reuse, so subsequent samples cost less. Fortunately, most rendering algorithms exhibit good coherence, so cache reuse is high. Comment: This is a combination of Stanford Computer Science Department Technical Report 2002 - 01 and a subsequent submission to SIGGRAPH 200...|$|R
40|$|The {{decomposition}} of the graphics pipeline {{into a coherent}} set of programmable functions provides greater flexibility and valuable new tools to the graphics programmer. Furthermore, this enhanced flexibility can be implemented efficiently to yield systems that maintain interactive frame rates. It has been recognized that given the wealth of shading possibilities, no single parameter-based shading model could ever be sufficient [Hanrahan 90]. In response to this, procedural shading and shading languages have arisen to give the graphics programmer full access to the range of shading algorithms. However, {{the existence of this}} kind of flexibility at other points in the graphics pipeline is in its infancy. I intend to show that it is worthwhile to allow programmability throughout the graphics process. I will show this by first implementing programmable hooks for the PixelFlow graphics library [Molnar 92], and then finding one or two people to use the added capabilities or solving a couple of suitable problems proposed by the committee. Contributions • A new {{decomposition of}} the rendering process into a framework and a logical and orthogonal set of functions. • The idea that such a system can and should be designed for use by the graphics programmer/user. • The idea that such a system can be implemented efficiently enough to be interactive on near-term graphics hardware. • The design and demonstration of such a system. • Separation into <b>rasterizers</b> and interpolators to decouple scan conversion from the interpolation of shading parameters. • Data structure for efficient caching of composited linear transformations while still allowing general programmable transformations...|$|R
5000|$|Sub-pixel ClearType text {{rendering}} with bi-directional antialiasing {{which can}} interoperate with GDI/GDI+, Direct2D/Direct3D and any application-specific technology. When using with Direct2D, text rendering can be hardware-accelerated or can use WARP software <b>rasterizer</b> when hardware acceleration is not available.|$|E
5000|$|WARP, {{provided}} since Windows Vista by Microsoft, {{which works}} at the system level to provide fast D3D 9.1 and above emulation. This is {{in addition to the}} extremely slow software-based reference <b>rasterizer</b> Microsoft has always provided to developers.|$|E
50|$|The {{architecture}} of the real-time rendering pipeline {{can be divided into}} three conceptual stages as shown as in the figure below. These stages include application, geometry, and <b>rasterizer.</b> This structure is the core which is used in real-time computer graphics applications.|$|E
5000|$|It is {{designed}} to allow the FreeType <b>rasterizer</b> {{to be used with}} the X Rendering Extension; it is generally employed to use FreeType's anti-aliased fonts with the X Window System. Xft also depends on fontconfig for access to the system fonts.|$|E
5000|$|... macOS {{includes}} a software <b>rasterizer</b> that supports PostScript. Thus {{eliminating the need}} for the Adobe Type Manager Light program. The built-in text editing supports advanced typesetting features such as adjustable kerning and baseline, as well as a few OpenType features.|$|E
50|$|The {{beginning}} of the program is mainly focused on the Unix development environment with the C-language. These software developments are planned through 40 projects such as the implementation of a basic First-person shooter engine, an engine for an online game and a 3D rendering engine (<b>rasterizer)</b> by ray tracing.|$|E
