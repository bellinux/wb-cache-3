27|174|Public
25|$|Among the {{significant}} enhancements {{introduced in the}} 6809 were the use of two 8-bit accumulators (A and B, which could be combined into a single 16-bit register, D), two 16-bit index registers (X, Y) and two 16-bit stack pointers. The index and stack registers allowed advanced addressing modes. Program counter <b>relative</b> <b>addressing</b> allowed for the easy creation of position-independent code, while a user stack pointer (U) facilitated the creation of reentrant code.|$|E
5000|$|Direct {{register}} and stack <b>relative</b> <b>addressing</b> provides capability for reentrant, recursive and re-locatable programming.|$|E
50|$|Instruction <b>relative</b> <b>addressing</b> in 64-bit code (RIP + displacement, where RIP is the {{instruction}} pointer register) simplifies {{the implementation of}} position-independent code (as used in shared libraries in some operating systems).|$|E
5000|$|Starting sector = <b>relative</b> <b>address</b> of next EBR within {{extended}} partition ...|$|R
40|$|We {{introduce}} local {{environments for}} mobile processes, expressed in π-calculus. Each local name {{is equipped with}} its <b>relative</b> <b>address,</b> i. e., with the information needed to point back to the process that generated it. <b>Relative</b> <b>addresses</b> are built upon the labels of the proved transition system of π-calculus. A router is specified that guarantees sound exportation of names...|$|R
50|$|The key {{moment in}} the play occurs when a young <b>relative</b> <b>addresses</b> Rosita as Doña Rosita. This form of address signals her change of status.|$|R
50|$|Under the <b>relative</b> <b>addressing</b> scheme, {{to obtain}} an {{absolute}} address, the relevant base address is taken and offset (aka displacement) is added to it. Under this type of scheme, the base address is the lowest numbered address within a prescribed range, to facilitate adding related positive-valued offsets.|$|E
50|$|Most operands {{can apply}} any of eight {{addressing}} modes to eight registers. The addressing modes provide register, immediate, absolute, relative, deferred (indirect), and indexed addressing, and can specify autoincrementation and autodecrementation of a register by one (byte instructions) or two (word instructions). Use of <b>relative</b> <b>addressing</b> lets a machine-language program be position-independent.|$|E
50|$|It was {{probably}} the first minicomputer to feature floating-point equipment as standard, and had an unusually rich complement of registers for its time. It also featured <b>relative</b> <b>addressing,</b> and a fully automatic context switched interrupt system. It {{was also the first}} minicomputer to offer virtual memory, offered as an option by 1969. It was succeeded by the Nord-10.|$|E
50|$|Unlike the 8080, the Z80 {{can jump}} to a <b>relative</b> <b>address</b> using a signed 8-bit displacement. Only the Zero and Carry flags {{can be tested}} for these new two-byte JR instructions.|$|R
2500|$|Flow of control: JMP (jump), JSR (jump to subroutine), BSR (<b>relative</b> <b>address</b> jump to subroutine), RTS (return from subroutine), RTE (return from exception, i.e. an interrupt), TRAP (trigger a {{software}} exception similar to software interrupt), CHK (a conditional software exception) ...|$|R
5000|$|Modified READ (MR) (<b>Relative</b> Element <b>Address</b> Designate), {{optional}} ...|$|R
50|$|Virtual memory makes {{application}} programming {{easier by}} hiding fragmentation of physical memory; by delegating to the kernel {{the burden of}} managing the memory hierarchy (eliminating {{the need for the}} program to handle overlays explicitly); and, when each process is run in its own dedicated address space, by obviating the need to relocate program code or to access memory with <b>relative</b> <b>addressing.</b>|$|E
50|$|The 8061 had a 240-byte {{internal}} register file, from address 0010H to 00FFH.I/O addresses {{were from}} 0002H to 000FH. Throughout the 8061 family, address 0000H {{was reserved for}} a constant ZERO register. This permitted use of <b>relative</b> <b>addressing</b> to access absolute addresses. The stack pointer was at 00010H.8061 could address 64K of memory.Reset was to 2000H.Interrupt vectors were at 2010H.|$|E
50|$|Among the {{significant}} enhancements {{introduced in the}} 6809 were the use of two 8-bit accumulators (A and B, which could be combined into a single 16-bit register, D), two 16-bit index registers (X, Y) and two 16-bit stack pointers. The index and stack registers allowed advanced addressing modes. Program counter <b>relative</b> <b>addressing</b> allowed for the easy creation of position-independent code, while a user stack pointer (U) facilitated the creation of reentrant code.|$|E
50|$|In simple layouts, {{programs}} {{begin their}} execution at the beginning, which {{is common in}} scripting languages, simple binary executable formats, and boot loaders. In other cases, the entry point is at some other fixed point, which is some memory address than can be an absolute <b>address</b> or <b>relative</b> <b>address</b> (offset).|$|R
5000|$|An Entry Sequenced Data Set (ESDS) {{is a type}} of {{data set}} used by the VSAM {{computer}} data storage system. Records are accessed based on their sequential order, that is, the order in which they were written to the file; which means that accessing a particular record involves searching all the records sequentially until it is located, or by using a <b>relative</b> physical <b>address</b> (<b>Relative</b> byte <b>address,</b> RBA), i.e. the number of bytes {{from the beginning of the}} file to start reading.|$|R
5000|$|In addition, ZPAQ {{will use}} an E8E9 {{transform}} {{to improve the}} compression of x86 code typically found in [...]exe and [...]dll files. An E8E9 transform scans for CALL and JMP instructions (opcodes E8 and E9 hex) and replaces their <b>relative</b> <b>addresses</b> with absolute addresses. Then it inserts code into the PCOMP section to perform the inverse transform.|$|R
50|$|The B5000, B5500 and B5700 in Word Mode has two {{different}} addressing modes, {{depending on whether}} it is executing a main program (SALF off) or a subroutine (SALF on). For a main program, the T field of an Operand Call or Descriptor Call syllable is relative to the Program Reference Table (PRT). For subroutines, the type of addressing {{is dependent on the}} high three bits of T and on the Mark Stack FlipFlop (MSFF), as shown in B5x00 <b>Relative</b> <b>Addressing.</b>|$|E
50|$|In {{contrast}} to the von Neumann network there are no limitations for topology of neurons for semantic networks. It leads to the impossibility of <b>relative</b> <b>addressing</b> of neurons as it was done by von Neumann. In this case an absolute readdressing should be used. Every neuron should have a unique identifier that would provide a direct access to another neuron. Of course, neurons interacting by axons-dendrites should have each other's identifiers. An absolute readdressing can be modulated by using neuron specificity as it was realized for biological neural networks.|$|E
5000|$|In 1996, Forbes went to {{work for}} Microsoft, and Microsoft's cabinet archiver was {{enhanced}} to include the LZX compression method. Improvements included a variable search window size; Amiga LZX was fixed to 64kB, Microsoft LZX could range on powers of two between 32 and 2048 kilobytes. A special preprocessor was added to detect Intel 80x86 [...] "CALL" [...] instructions, converting their operands from <b>relative</b> <b>addressing</b> to absolute addressing, thus calls to the same location resulted in repeated strings that the compressor could match, improving compression of 80x86 binary code.|$|E
5000|$|A {{computer}} program can access an address given explicitly - in low-level programming {{this is usually}} called an , or sometimes a specific address, and is known as pointer data type in higher-level languages. But a program can also use <b>relative</b> <b>address</b> which specifies a location in relation to somewhere else (the base address). There are many more [...] addressing modes.|$|R
40|$|Abstract. We {{introduce}} local {{environments for}} mobile processes, expressed in ß-calculus. Each local name {{is equipped with}} its <b>relative</b> <b>address,</b> i. e., with the information needed to point back to the process that generated it. <b>Relative</b> <b>addresses</b> are built upon the labels of the proved transition system of ß-calculus. A router is specified that guarantees sound exportation of names. 1 Introduction The specification of systems of mobile processes is receiving more and more attention [9, 1, 12, 14, 10]. Efficiency considerations suggest implementations that provide each process composing the system with its own local environment. In the ß-calculus [9] view, this amounts to saying that each process has its own space of private names. Possibly, some of these names are communicated to another process and so they become shared by different local environments. Here, we give a new structural operational semantics to ß-calculus that considers names localized to their owners. In other words, each [...] ...|$|R
40|$|The {{concept for}} the {{generation}} of arbitrary permutations of d-dimensional data cubes in a multistage manner is presented. In particular, d-dimensional switching cubes are proposed, and the geometry of the ports of the switches and their locations within the switching cubes (d= 3, 4) are discussed. A new addressing scheme for the ports of these switches is presented, which is called the horizontal coding of addresses because the ports of the switches are distributed to the subsequently arranged arrays of the cube(s) in a horizontal manner. This addressing scheme permits any desired organization of the switches and the ports by reordering the absolute d-tuple addresses. This reordering is described by permutation matrices and explained by means of several examples. Within this <b>addressing</b> scheme <b>relative</b> <b>addresses</b> of the ports of the switches (which are {{a subset of the}} common absolute <b>addresses)</b> are introduced. <b>Relative</b> <b>addresses</b> offer an additional saving of hardware if applied within the concept of rearrangeability...|$|R
5000|$|The PicoBlaze {{is poorly}} suited to {{programming}} in compiled languages such as C. [...] In {{addition to the}} lack of support for function pointers, there are no instructions or addressing modes to expedite a stack-based calling convention. For PicoBlaze it takes two instructions to implement PUSH or POP and two instructions to implement <b>relative</b> <b>addressing</b> off a software-designated stack pointer. The PicoBlaze is better suited to a hand-optimized register-based calling convention. This does not preclude the use of a Forth-like data stack, and in fact the PicoBlaze is well suited to this approach, if the 64-byte scratchpad memory offers sufficient space.|$|E
50|$|Position-independent code can be {{executed}} at any memory address without modification. This differs from relocatable code, {{in which a}} linker or program loader modifies a program before execution {{so it can be}} run only from a particular memory location. Generating position-independent code is often the default behavior for compilers, but they may place restrictions on the use of some language features, such as disallowing use of absolute addresses (position-independent code has to use <b>relative</b> <b>addressing).</b> Instructions that refer directly to specific memory addresses sometimes execute faster, and replacing them with equivalent relative-addressing instructions may result in slightly slower execution, although modern processors make the difference practically negligible.|$|E
50|$|The window {{addressable}} area {{should always}} be within the Safe-Title area, so that all addressable locations are within the display window if the monitor overscans the image onto a non-rectangular screen. If the video stream has a 16:9 aspect ratio the addresses {{should be in the}} range 0..74 for the vertical addresses, and 0..209 for the horizontal addresses. If the video stream has a 4:3 aspect ratio the addresses should be in the range 0..74 for the vertical addresses, and 0..159 for the horizontal addresses. For other aspect ratios <b>relative</b> <b>addressing</b> should be used and both vertical and horizontal addresses should be in the range 0..99%.|$|E
50|$|<b>Relative</b> track <b>addresses</b> {{are three}} byte {{fields in the}} form TTR. All subfields are binary numbers.|$|R
50|$|In {{computer}} engineering and low-level programming (such as assembly language), an offset usually denotes {{the number of}} address locations added to a base address {{in order to get}} to a specific absolute address. In this (original) meaning of offset, only the basic address unit, usually the 8-bit byte, is used to specify the offset's size. In this context an offset is sometimes called a <b>relative</b> <b>address.</b>|$|R
50|$|BDAM accepts disk {{addresses}} {{as either}} actual device <b>addresses,</b> as <b>relative</b> track <b>addresses,</b> or as <b>relative</b> block numbers.|$|R
50|$|Circular memory: The {{memory is}} {{addressed}} in units of one instruction. The memory space (or core) is of finite size, but only <b>relative</b> <b>addressing</b> is used, that is, address 0 always {{refers to the}} currently executing instruction, address 1 to the instruction after it, and so on. The maximum address value is set to equal one less {{than the number of}} memory locations, and will wrap around if necessary. As a result, there is a one-to-one correspondence between addresses and memory locations, but it is impossible for a Redcode program to determine any absolute address. A process that encounters no invalid or jump instructions will continue executing successive instructions endlessly, eventually returning to the instruction where it started.|$|E
5000|$|Relative {{addresses}} are a form {{of manual}} memory segmentation, and share many of its advantages and disadvantages. A two-byte offset, containing a 16-bit, unsigned integer, {{can be used to}} provide <b>relative</b> <b>addressing</b> for up to 64 kilobytes of a data structure. This can easily be extended to 128K, 256K or 512K if the address pointed to is forced to be aligned on a half-word, word or double-word boundary (but, requiring an additional [...] "shift left" [...] bitwise operation—by 1, 2 or 3 bits—in order to adjust the offset by a factor of 2, 4 or 8, before its addition to the base address). Generally, though, such schemes are a lot of trouble, and for convenience to the programmer absolute addresses (and underlying that, a flat address space) is preferred.|$|E
5000|$|Its {{extensive}} integrated feature set and glueless architecture facilitate rapid hardware design, and its C-friendly {{instruction set}} permits efficient development of complex applications for embedded systems. The instruction set {{is based on}} the original Z80 microprocessor, but with some additions of new instructions as well as deletions of some instructions. Particularly useful for C is the stack pointer <b>relative</b> <b>addressing</b> available in some of the new instructions. Among the Z80 instructions missing in the Rabbit, cpir is particularly notable, since it allows for much more efficient implementations of some often-used standard C functions such as strlen (...) , strnlen (...) and memchr (...) [...] According to the Rabbit documentation, it executes its instructions 5 times faster than the original Z80 microprocessor, that is, similarly to the Zilog eZ80.The Rabbit 3000 is a variant of the Rabbit 2000 with the same core, but more powerful integrated peripherals. The Rabbit 3000A variant adds a small number of additional instructions for I/O and large integer arithmetic. The Rabbit 4000 again adds more integrated peripherals. The further derivatives, starting with the Rabbit 5000 have a substantially different architecture.|$|E
50|$|<b>Relative</b> virtual <b>addresses</b> (RVAs) {{are not to}} be {{confused}} with standard virtual <b>addresses.</b> A <b>relative</b> virtual <b>address</b> is the virtual address of an object from the file once it is loaded into memory, minus the base address of the file image. If the file were to be mapped literally from disk to memory, the RVA would be the same as that of the offset into the file, but this is actually quite unusual.|$|R
40|$|Abstract: This paper {{outlines}} {{a framework}} for connectionist representation based on the composition of connectionist states under vector space operators. The framework is used to specify a level of connectionist structure {{defined in terms of}} addressable superposition space hierarchies. Direct and <b>relative</b> <b>address</b> systems (:an be defined for such structures which use the functional components of linguistic structures as labels. Unbounded dependency phenomena are shown {{to be related to the}} different properties of these labelling structures...|$|R
50|$|This {{of course}} is not {{possible}} for distributed systems since an (absolute) address - in the caller's address space - is normally meaningless to the remote program (however, a <b>relative</b> <b>address</b> might in fact be usable if the receiver had an exact copy of, at least some of, the sender's memory in advance). Web browsers and web servers are examples of processes that communicate by message passing. A URL {{is an example of}} a way of referencing resources that does not depend on exposing the internals of a process.|$|R
