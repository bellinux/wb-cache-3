20|240|Public
40|$|This study {{presents}} a performance analysis {{of two different}} multipliers for unsigned data, one uses a carry-look-ahead adder and the second one uses a <b>ripple</b> <b>adder.</b> The study's main {{focus is on the}} speed of the multiplication operation on these 32 -bit multipliers which are modeled using VHDL, A hardware description language. The multiplier with a carry-look-ahead adder has shown a better performance over the multiplier with a <b>ripple</b> <b>adder</b> in terms of gate delays. Under the worst case, the multiplier with the fast adder shows approximately twice the speed of the multiplier with the <b>ripple</b> <b>adder.</b> The multiplier with a <b>ripple</b> <b>adder</b> uses time = 979. 056 ns, while the multiplier with the carry-look-ahead adder uses time = 659. 292 ns...|$|E
40|$|Most bit serial {{computation}} is done {{least significant bit}} first (LSB) {{because it}} is a natural implementation of the carry chain. However, number comparisons need to start at the most significant bit (MSB) making MSB-first logic very important for executing programs with a lot of comparisons. This paper presents the design of an asynchronous bit serial MSB-first adder that uses a conventional two's complement binary encoding. The adder can process varying unmatched input bit lengths at run time and produce the minimal bit length addition result. However, since it has a data-dependent output latency, it is only suitable only for an asynchronous implementation. We compare this adder to an asynchronous bitserial LSB-first adder and a bit-parallel carry <b>ripple</b> <b>adder</b> in HSPICE using a 90 nm process. The results will show that this MSB-first adder uses 3. 15 times the energy as the analogous LSB-first adder. It also produces the most significant bit 1. 10 times faster than the LSB-first adder and carry <b>ripple</b> <b>adder.</b> Optimizations made to a constant-response time counter used in the design are also described. 2021 - 02 - 0...|$|E
40|$|A new dynamic {{differential}} logic family, Short-Circuit Current Logic (SC 2 L), {{is proposed}} for low-power high-performance applications. It achieves low-power consumption {{by using an}} aggressively reduced logic swing without requiring restoration circuitry. Using a 0. 35 µm CMOS technology and a nominal supply voltage of 3. 3 V, a SC 2 L full-adder 8 carry <b>ripple</b> <b>adder</b> (CRA) is implemented. It offers {{an order of magnitude}} less power-delay product than several other logic families...|$|E
40|$|Reduction in leakage {{power has}} become an {{important}} concern in low-voltage, low-power, and high-performance applications. In this paper, the dual-threshold technique is used to reduce leakage power in a 32 -bit <b>ripple</b> carry <b>adder</b> by assigning high-threshold voltage to some transistors in noncritical paths, and using low-threshold transistors in critical path. The circuit was implemented using Cadence Virtuoso tools in 90 -nm technology. The optimized layout of the <b>ripple</b> carry <b>adder</b> is designed using Cadence Virtuoso Layout Suite. Performance parameters such as total power, delay, static power and power delay product (PDP), were calculated and compared with the existing design topologies of full adder. The simulation results of the 32 -bit <b>ripple</b> carry <b>adder</b> using the dual threshold voltage technique are compared with the conventional 32 -bit <b>ripple</b> carry <b>adder</b> with different threshold values. Results show that the dual-threshold technique is good for leakage power reduction during runtime mode. General Terms CMOS, full <b>adder,</b> <b>ripple</b> carry <b>adder,</b> critical-path, delay, high performance, low-power design, low voltage, power estimation, layout...|$|R
40|$|Abstract. We {{present the}} design of a quantum carry-lookahead adder using measurement-based quantum computation. The quantum carry-lookahead adder (QCLA) is faster than a quantum {{ripple-carry}} adder; QCLA has logarithmic depth while <b>ripple</b> <b>adders</b> have linear depth. Our design is evaluated in terms of number of time steps and the total number of qubits used...|$|R
5000|$|... #Caption: Decimal 4-digit <b>ripple</b> carry <b>adder.</b> FA = full adder, HA = half adder.|$|R
40|$|While {{the use of}} RNS has {{provided}} groundbreaking theory and progress in this field, the applications still lack viable testing platforms to test and verify the theory. This Thesis outlines the processing of developing an instruction set architecture (ISA) and an instruction execution unit (IEU) {{to help make the}} first residue based general processor a viable testing platform to address the mentioned problems. Consider a 32 -bit <b>ripple</b> <b>adder.</b> The delay on this device will be 32 N where N is the delay for each adder to complete its operation. The delay of this process is due to the need to propagate each carry signal generated by each adder to the next one. This was solved by the creation of the Carry Look Ahead (CLA), which could drastically reduce the delay by 2 / 3. However, like the <b>ripple</b> <b>adder,</b> the CLA is still encumbered by propagation delay. A residue processor in the same situation would have a delay of 1 N regardless of bit size since carry propagation is no longer a concern. The Thesis discusses how prior challenges using residue number systems in computers has been overcome by Digital System Research (DSR) ...|$|E
40|$|Abstract-Multipliers are {{inevitable}} components in digital system design and embedded applications. The performance parameters of multipliers {{play a vital}} role in maximizing the efficiency of these applications. Different algorithms have been proposed for improving the performance parameters of multipliers. This paper formulates a comparative study of some of the well known existing multipliers and thereafter proposes a robust design. The multiplier with a carry-look-ahead adder has shown a better performance over the multiplier with a <b>ripple</b> <b>adder</b> in terms of gate delays...|$|E
40|$|Power Dissipation of Digital {{circuits}} can {{be reduced}} by 15 %- 25 % by using appropriate logic restructuring and also it {{can be reduced}} by 40 %- 60 % by lowering switching activity. Here, Gate Diffusion Input Technique {{which is based on}} a Shannon expansion is analyzed for minimizing the power consumption and delay of static digital circuits. This technique as compare to other currently used logic design style, allows less power consumption and reduced propagation delay for low-power design of combinatorial digital circuits with minimum number of transistors. In this paper, basic building blocks of digital system and few combinational circuits are analyzed using GDI and other CMOS techniques. All circuits are designed at 180 nm technology in CADENCE and simulate using VIRTUOSO SPECTRE simulator at 100 MHz frequency. Comparative analysis has been done among GDI and other parallel design styles for designing <b>ripple</b> <b>adder,</b> CLA adder and bit magnitude comparator. Simulation result shows GDI technique saves 53. 3 %, 55. 6 % and 75. 6 % power in <b>ripple</b> <b>adder,</b> CLA adder and bit magnitude comparator respectively as compare to CMOS. Also delay is reduced with 25. 2 %, 3. 4 % and 6. 9 % as compare to CMOS. Analysis conclude that GDI is revolutionary high speed and low power consumption technique...|$|E
5000|$|Using a <b>ripple</b> carry <b>adder</b> to add {{these two}} {{together}} and produce the resulting n + 1-bit value.|$|R
40|$|We {{present the}} design of a quantum carry-lookahead adder using measurement-based quantum computation. The quantum carry-lookahead adder (QCLA) is faster than a quantum {{ripple-carry}} adder; QCLA has logarithmic depth while <b>ripple</b> <b>adders</b> have linear depth. Our design is evaluated in terms of number of time steps and the total number of qubits used. Comment: 2 pages, 3 figures, Asian Conference on Quantum Information Science 2008, KIAS, South Kore...|$|R
50|$|Above is {{the basic}} {{building}} block of a carry-select adder, where the block size is 4. Two 4-bit <b>ripple</b> carry <b>adders</b> are multiplexed together, where the resulting carry and sum bits are selected by the carry-in. Since one <b>ripple</b> carry <b>adder</b> assumes a carry-in of 0, and the other assumes a carry-in of 1, selecting which adder had the correct assumption via the actual carry-in yields the desired result.|$|R
40|$|International audienceThis paper {{presents}} {{the design and}} implementation of a time driven adder generator architecture. There exists a large variety of adders designed to satisfy different computation requirements, in particular we list the Carry Look Ahead (CLA) adder, the skip adder, the <b>ripple</b> <b>adder,</b> the carry select adder (CSA), etc. These different architectures will offer different delays and {{it is up to}} the user to chose among them. The design we present here allows the parametrization of the architecture to fit ones design constraints. From the word length and the wanted delay the generator outputs a suitable architecture...|$|E
40|$|In {{this paper}} we discuss Hybrid Ripple Carry Lookahead Adder (HRCLA), which is a hybrid between Carry Lookahead Adder (CLA) and <b>ripple</b> <b>adder</b> (RA). In HRCLA time is traded off for area and power. HRCLA has been {{designed}} by rippling the last carry bit of a 4 -bit CLA. HRCLA extracts the traits of Carry Lookahead Adders (CLA) speed and ripple adders (RA), area. A four bit proposed HRCLA has been implemented in Cadence using 45 nm technology; the implementation results showed 12. 2 %Area, 4. 6 % power improvement and 14. 01 % critical path delay overhead over CLA...|$|E
40|$|The authors first {{address the}} {{following}} issues: why a voltage transition causes power dissipation, what causes a transition, what are useful and redundant transitions, how information redundancy {{may reduce the}} number of transitions, how to make information redundant by adding dependant bits, how to statistically measure the average number of transitions (or activity) and reduce it through redundancy. Then they concentrate on addition and answer the following questions: how to compute the average activity using statistics, how to model activity in the simplest adder: the carry <b>ripple</b> <b>adder,</b> how to extend the model to carry select adder, to carry lookahead adder and finally how to make adders redundant...|$|E
5000|$|The maximum time is 8 gate delays (for [...] ).A {{standard}} 16-bit <b>ripple</b> carry <b>adder</b> {{would take}} 16*3-1=47 gate delays.|$|R
5000|$|A <b>ripple</b> carry <b>adder</b> is {{a simple}} adder circuit, but slow because the carry signal has to {{propagate}} through each stage of the adder: ...|$|R
50|$|The carry-select adder {{generally}} {{consists of}} two <b>ripple</b> carry <b>adders</b> and a multiplexer. Adding two n-bit numbers with a carry-select adder is done with two <b>adders</b> (therefore two <b>ripple</b> carry <b>adders).</b> In order to perform the calculation twice, one time with the assumption of the carry-in being zero and the other assuming it will be one. After the two results are calculated, the correct sum, {{as well as the}} correct carry-out, is then selected with the multiplexer once the correct carry-in is known.|$|R
40|$|New ternary adders, {{which are}} {{fundamental}} components of ternary addition, {{are presented in}} this paper. They are {{on the basis of}} a logic style which mostly generates binary signals. Therefore, static power dissipation reaches its minimum extent. Extensive different analyses are carried out to examine how efficient the new designs are. For instance, the ternary <b>ripple</b> <b>adder</b> constructed by the proposed ternary half and full adders consumes 2. 33 [*]μW less power than the one implemented by the previous adder cells. It is almost twice faster as well. Due to their unique superior characteristics for ternary circuitry, carbon nanotube field-effect transistors are used to form the novel circuits, which are entirely suitable for practical applications...|$|E
40|$|In {{this paper}} a new {{self-checking}} fast <b>ripple</b> <b>adder</b> is presented. The adder implements the sum {{as well as}} the inverted sum and is totally self-checking with respect to all single stuck-at faults. The inverted sum is implemented by adding three gates per adder cell only. Total hardware overhead of the proposed adder is less than the hardware overhead in case of the completely duplication of the adder and comparable with hardware overhead of the parity checked adder. We also show in this paper how the hardware overhead of the self-checking carry select adder with duplicated sum-bits can be reduced by use of the proposed adder. This work was firstly introduced in [1]...|$|E
40|$|This chapter {{will first}} address the {{following}} issues: why a voltage transition causes power dissipation, what causes a transition, what are useful and redundant transitions, how information redundancy {{may reduce the}} number of transitions, how to make information redundant by adding dependant bits, how to statistically measure the average number of transitions (or activity) and reduce it through redundancy. Then this chapter will concentrate on addition and answer the following questions: how to compute the average activity using statistics, how to model activity in the simplest adder: the carry <b>ripple</b> <b>adder,</b> how to extend the model to carry select adder, to carry lookahead adder and finally how to make adders redundant. 1. REDUCING POWER Designing low-power high-speed circuits requires a combination of techniques at four levels: technology, circuitry, architectures and algorithms [BCS 92]. This work concentrates on the architecture level and considers a CMOS static technology. Let u [...] ...|$|E
40|$|We {{present the}} design of a quantum carry-lookahead adder using measurement-based quantum computation. QCLA {{utilizes}} MBQC`s ability to transfer quantum states in unit time to accelerate addition. The quantum carry-lookahead adder (QCLA) is faster than a quantum ripple-carry adder; QCLA has logarithmic depth while <b>ripple</b> <b>adders</b> have linear depth. QCLA is an order of magnitude faster than a ripple-carry adder when adding registers longer than 100 qubits but requires a cluster state that is an order of magnitude larger. Hand optimization results in a ≈ 26...|$|R
40|$|This paper {{considers}} {{two types}} of n-bit <b>adders,</b> <b>ripple</b> carry <b>adders</b> and cascaded carry look-ahead adders, with minimum tests for stuck-at fault models. In the first part, we present {{two types of}} full adders consisting of five gates, and show their minimality. We also prove {{that one of the}} full adders can be tested by only three test patterns for single stuck-at faults. We also present two types of 4 -bit carry look-ahead adders and their minimum tests. In the second part, we consider the tests for the cascaded <b>adders,</b> an n-bit <b>ripple</b> carry <b>adder</b> and a 4 m-bit cascaded carry look-ahead adders. These tests are considerably smaller than previously published ones. In this paper, we consider two types of n-bit adders with minimum tests for stuck-at fault models: <b>Ripple</b> carry <b>adders</b> and cascaded carry look-ahead adders. First, we show the minimality of full adders shown in Fig. 1. They contain the minimum number of gates among adders consisting of only 2 -input gates. We also show that the sizes of the minimum tests for single stuck-at faults in the full adders of Fig. 1 A and 1 B are five and three, respectively. To our knowledge, the ful...|$|R
50|$|On average, an n-bit {{asynchronous}} <b>ripple</b> carry <b>adder</b> {{will finish}} in O(log n) time. By extending {{this approach to}} carry look-ahead adders, {{it is possible to}} add in O(log log n) time.|$|R
40|$|Relational {{languages}} such as Ruby {{are used}} to derive hardware circuits from abstract specifications of their behaviour. Much reasoning is done informally in Ruby using pictorial representations of relational terms. We formalise this use of pictures in circuit design. We show that pictures naturally form a unitary pretabular allegory. Homomorphisms of pictures correspond to adding new wires or circuit components. Two pictures are mutually homomorphic {{if and only if}} they represent equal allegorical terms. We prove soundness and completeness results which guarantee that deriving circuits using pictures does not lead to errors. We illustrate the use of pictures by deriving the <b>ripple</b> <b>adder</b> implementation from a high level, behavioural specification. 1 : Introduction Hardware circuit design involves translating abstract specifications of programs into efficient circuits which compute those programs. Pictures are widely used as an informal means of translating a specification into an imple [...] ...|$|E
40|$|A robust {{numerical}} {{solution of the}} input voltage equations (IVEs) for the independent-double-gate metal-oxide-semiconductor field-effect transistor requires root bracketing methods (RBMs) instead of the commonly used Newton-Raphson (NR) technique due {{to the presence of}} nonremovable discontinuity and singularity. In this brief, we do an exhaustive study of the different RBMs available in the literature and propose a single derivative-free RBM that could be applied to both trigonometric and hyperbolic IVEs and offers faster convergence than the earlier proposed hybrid NR-Ridders algorithm. We also propose some adjustments to the solution space for the trigonometric IVE that leads to a further reduction of the computation time. The improvement of computational efficiency is demonstrated to be about 60 % for trigonometric IVE and about 15 % for hyperbolic IVE, by implementing the proposed algorithm in a commercial circuit simulator through the Verilog-A interface and simulating a variety of circuit blocks such as ring oscillator, <b>ripple</b> <b>adder,</b> and twisted ring counter...|$|E
40|$|This paper {{presents}} {{the design and}} implementation of a time driven adder generator architecture. There exists a large variety of adders designed to satisfy different computation requirements, in particular we list the Carry Look Ahead (CLA) adder, the skip adder, the <b>ripple</b> <b>adder,</b> the carry select adder (CSA), etc. These different architectures will offer different delays and {{it is up to}} the user to chose among them. The design we present here allows the parametrization of the architecture to fit ones design constraints. From the word length and the wanted delay the generator outputs a suitable architecture. Keywords Addition VLSI architectures, generators, macroblocks, 4 - 1928 architecture. INTRODUCTION The exists a so large set of different adders generators (Sklansky, 1990), (Bedrij, 1962), (Brent, 1982), (Cavanagh, 1984),(Hwang, 91 - 1 (Muller, 1989), each one implementing a particular architecture, that the choice of an adder may be tough. We present here an alternative which will r [...] ...|$|E
40|$|Abstract: In {{this paper}} the first code-disjoint totally {{self-checking}} carry-select adder is proposed. The adder blocks are fast <b>ripple</b> <b>adders</b> {{with a single}} NAND-gate delay for carry-propagation per cell. In every adder block both the sum-bits and the corre-sponding inverted sum-bits are simultaneously implemented. The parity of the input operands is checked against the XOR-sum of the propagate signals. For 64 bits area and maximal delay {{are determined by the}} SYNOPSYS CAD tool of the EUROCHIP project. Compared to a 64 bit carry-select adder without error detection the delay of the most significant sum-bit does not increase. Compared to a completely duplicated code-disjoint carry-select adder we save 240 XOR-gates. ...|$|R
50|$|Often {{algorithms}} {{for those}} problems {{had to be}} separately invented {{and could not be}} naïvely adapted from well-known algorithms - Gaussian elimination and Euclidean algorithm rely on operations performed in sequence. One might contrast <b>ripple</b> carry <b>adder</b> with a carry-lookahead adder.|$|R
50|$|This diagram shows a 5-bit <b>ripple</b> carry <b>adder</b> in action. There is a five-stage long carry path, {{so every}} time two numbers are added with this adder, {{it needs to}} wait for the carry to {{propagate}} through all five stages.|$|R
40|$|We {{describe}} {{in this paper}} a novel approach to identify repeating circuit structures referred to as templates. The approach {{is based on a}} clan-based decomposition algorithm that has been successfully used in other domains [6, 5]. The algorithm discovers clans, a grouping of nodes in the circuit graph that have a natural affinity towards each other, and it hierarchically builds a parse tree of all clans. A non-leaf node in the parse tree corresponds to a clan. Each clan is classified as either linear, independent, or pseudo-linear to reflect the relationships among the node's immediate children, which are either clans or leaf nodes. Identical clans in the parse tree are then identified to be appropriate templates with which the circuit can be covered. We describe the results of applying this algorithm to a <b>ripple</b> <b>adder,</b> an ALU, and 4 Θ 4 multiplier. 1 Introduction With the increasing gap in design productivity, innovative methods are needed to minimize design and verification effo [...] ...|$|E
40|$|This paper {{presents}} a delay comparison {{of two different}} multipliers for unsigned data, one uses a ripple carry and the second one uses a carry-lookahead adder. The 4 × 4 Vedic multiplier module using Urdhva Tiryakbhyam Sutra uses four 2 × 2 Vedic multiplier modules. Urdhva tiryakbhyam Sutra is most powerful Sutra, giving minimum delay for multiplication {{of all types of}} numbers, either small or large. Urdhva Triyagbhyam – Vedic method for multiplication which strikes a difference in the real process of multiplication itself. It causes parallel generation of intermediate products,removes unwanted multiplication steps with zeros and scaled to higher bit levels. The paper’s main focus is on the speed/delay of the multiplication operation on 4 -bit multipliers which are modeled using VHDL, A hardware description language. The 4 × 4 Vedic multiplier is coded in VHDL, synthesized and simulated using Xilinx ISE 9. 1 software. This multiplier is implemented on Spartan 3 FPGA device XC 3 S 50 - 5 pq 208. The performance evaluation results in terms of speed and device utilization. The multiplier with a carry-look-ahead adder has shown a less delay over the multiplier with a ripple carry adder. The multiplier with a <b>ripple</b> <b>adder</b> uses time = 17. 796 ns, while the multiplier with the carry-look-ahead adder uses time = 17. 560 ns...|$|E
40|$|Carry Select Adder {{is one of}} {{the fastest}} adders used in many data-processing {{processors}} to perform fast arithmetic functions. Carry select adder(CSLA) is used to increase the speed of a parallel adder that expands area in favour of speed. CSLA is used in many computational systems to alleviate the problem of carry propagation delay by independently generating multiple carriers and then select a carry to generate the sum. The problem raised in CSLA is not area efficient because it uses multiple pairs of Ripple carry adders (RCA) to generate the partial sum and carry which are selected by the multiplexer. Square Root CSLA is constructed by equalising the delay through two carry chains and the block multiplexer signal from previous stage. This is an extension of linear CSLA which improves the delay time greatly. By using SQRT CSLA, the time can be improved, as the time waiting for carry bit is used to calculate an extra input bit in each stage. The main disadvantage in the SQRT CSLA is duplication of adders is done. By this duplication the size of the adder is bigger and takes more space than standard <b>ripple</b> <b>adder.</b> This disadvantage is overcome by using Binary to Excess- 1 convertor for RCA with cin= 1 to optimise the area and delay. This modified design will reduce area and power as compared with regular SQRT CSLA with only a slight increase in delay. Based on this modification 8, 16, 32, 64, 128 -b SQRT CSLA architecture and simulation will be developed and compare with regular SQRT CSL...|$|E
40|$|In this paper, {{we present}} {{and compare the}} design and the {{performances}} of ten different implementations for a 16 -bit adder in a 180 nm CMOS standard-cell technology. <b>Ripple</b> carry <b>adder,</b> increment adder, triangle adder, uniform and progressive carry select adder, uniform and progressive carry bypass <b>adder,</b> conditional <b>adder,</b> <b>ripple</b> carry look ahead adder and hierarchical carry look ahead adder are taken into account. Every architecture is explained, highlighting the pros and cons. Finally, the results of area complexity, worst path timing and average power consumption for each implementation are shown...|$|R
40|$|Abstract — The energy {{efficient}} <b>ripple</b> carry <b>adder</b> based turbo decoder {{is required in}} CDMA 2000, WCDMA (UMTS) and HSDPA receivers to decode the data packets between the mobile station and network provided by 4 G standard. The high throughput cellular standards 3 GPP/ 4 G require an {{energy efficient}} decoder architecture. An efficient VLSI architecture for turbo decoder by utilizing state metric calculator is presented here. In decoding, the state metric calculator is inserted to perform state metric calculations. This energy efficient turbo decoder comprises level limiter, error generator, SOVA decoder, state metric calculator, interleaver and corresponding deinterleaver. The <b>ripple</b> carry <b>adder</b> based turbo decoder achieved a low energy consumption o...|$|R
40|$|In {{this paper}} the first code-disjoint totally selfchecking carry-select adder is proposed. The adder blocks are fast <b>ripple</b> <b>adders</b> {{with a single}} NAND-gate delay for carry-propagation per cell. In every adder block both the sum-bits and the {{corresponding}} inverted sum-bits are simultaneously implemented. The parity of the input operands is checked against the XOR-sum of the propagate signals. For 64 bits area and maximal delay {{are determined by the}} SYNOPSYS CAD tool of the EUROCHIP project. Compared to a 64 bit carry-select adder without error detection the delay of the most significant sum-bit does not increase. The area is 170 % of a 64 bit carry-select adder (without error detection and not code-disjoint). 1...|$|R
