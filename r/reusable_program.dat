31|143|Public
40|$|Most of CERN’s {{industrial}} installations rely on PLC-based (Programmable Logic Controller) {{control systems}} developed using the UNICOS framework. This framework contains common, <b>reusable</b> <b>program</b> modules and their correctness {{is a high}} priority. Testing is already applied to find errors, but this method has limitations. In this work an approach is proposed to transform automatically PLC programs into formal models, {{with the goal of}} applying formal verification to ensure their correctness. We target model checking which is a precise, mathematical-based method to check formalized requirements automatically against the system...|$|E
40|$|Abstract: This paper {{presents}} {{an overview of}} the Redwood programming environment and details one of its key features, snippets. Through snippets, developers can both make use of a variety of predefined programming constructs and build their own <b>reusable</b> <b>program</b> components. Language-independent, snippets are descriptions of program parts that {{can be as simple as}} an assignment statement or as complex as a sophisticated optimization algorithm. In Redwood, snippets also provide support for a distinguishing facility of visual environments: direct manipulation via drag-and-drop. An example of working with snippets, including snippet definition, visualization, customization, and mapping to code is also presented in the paper...|$|E
40|$|We {{present a}} {{specification}} composition technique, {{for improving the}} reliability of message passing applications composed by the Ensemble methodology. In Ensemble, applications are built by composing reusable executable program components designed with scalable communication interfaces. The composition is controlled by scripts. We define reusable specification components associated to program components, {{as well as their}} composition directed by the same Ensemble scripts, thus obtaining specifications of applications. We propose an extension of coloured Petri nets, which is used to define specification components. Composed specifications and applications may be validated or verified by available tools. Keywords: Message Passing Composition, Specification Composition, <b>Reusable</b> <b>Program</b> Component, Reusable Specification Component, Software Reliability, Coloured Petri Net. ...|$|E
5000|$|Koza, J.R. (1994). Genetic Programming II: Automatic Discovery of <b>Reusable</b> <b>Programs,</b> MIT Press.|$|R
40|$|Abstract: A {{model of}} a multiprocessing, {{multiprogramming}} computer system with serially <b>reusable</b> <b>programs</b> was developed to study the effect of serial programs on system performance. Two strategies for implementing serially <b>reusable</b> <b>programs</b> were investigated, a wait strategy in which the processor waits until the serial program is available, and a switch strategy, in which the processor is freed to do other work. Relative performances and asymptotic conditions as functions {{of the number of}} processors, processes, serially reus-able programs, and the fraction of time each process executes serially <b>reusable</b> <b>programs</b> were obtained. Quantitative results are pre-sented showing that the switch strategy is superior. The wait strategy causes quick saturation when the number of processes is increased...|$|R
5000|$|... {{upgraded}} {{structure in}} the landing legs, also to support the <b>reusable</b> development <b>program</b> and objectives ...|$|R
40|$|Genetic {{programming}} is a domain-independent method that genetically breeds population of computer programs to solve problems. Genetic {{programming is}} considered to be a machine learning technique used to optimize a population of computer programs according to a fitness landscape determined by a program's ability to perform a given computational task. There are a number of representation methods to illustrate these programs, such as LISP expressions and integer lists. This study investigated the effectiveness of genetic programming in solving the symbolic regression problem where, the population programs are expressed as integer sequences rather than lisp expressions. This study also introduced the concept of <b>reusable</b> <b>program</b> to genetic algorithm for developing software...|$|E
40|$|Enabling the reuse of {{available}} techniques and tools for software maintenance {{is a major}} topic. However, research focuses mostly on two topics: parsing and tool interoperability. In the future, more sophisticated approaches to maintenance will be needed and dataflow analysis has to be used. As building dataflow analyzers for real languages is expensive, we must start to provide reusable dataflow analysis infrastructures for software maintenance. This paper first reports on our experience in building program analysis based maintenance tools. From that perspective, we formulate specific requirements for <b>reusable</b> <b>program</b> analysis infrastructures and then {{take a look at}} some program analysis infrastructures from compiler optimization research to evaluate if they are (re) usable for software maintenance tools...|$|E
40|$|In a pre- and post-conditions style specification, it is {{difficult}} to specify allowed sequences of method calls, often called protocols. However, the protocols are essential properties of reusable object-oriented classes and application frameworks, and the approaches based on the pre- and post-conditions, such as design by contracts (DBC) and formal behavioral interface specification languages (BISL), are being accepted as a practical and effective way of describing precise interfaces of (<b>reusable)</b> <b>program</b> modules. We propose a simple extension to JML, a BISL for Java, to specify protocol properties in an intuitive and concise manner. We also define a formal semantics of our extension and provide runtime checks. We believe that our approach can be easily adopted for other BISLs...|$|E
40|$|We {{present a}} {{formalism}} for reasoning about declarative object-oriented programs. Classes are represented as first-order theories that contain logic programs as methods. Inheritance, genericity and related concepts {{are represented by}} operations on such theories which preserve the consistency of these theories {{as well as the}} correctness of the programs specified by their axioms. Our approach provides a logical basis for the construction of correct and <b>reusable</b> <b>programming</b> systems...|$|R
40|$|High-level {{programming}} languages offer significant expressivity but provide {{little or}} no guarantees about resource use. Resourcebounded languages [...] - such as hardware-description languages [...] - provide strong guarantees about the runtime behavior of computations but often lack mechanisms that allow programmers to write more structured, modular, and <b>reusable</b> <b>programs.</b> To overcome this basic tension in language design, recent work advocated the use of Resource-aware Programming (RAP) languages, which {{take into account the}} natural distinction between the development platform and the deployment platform for resource-constrained software...|$|R
5000|$|In 2017, Bulk Barn {{partnered with}} zero waste enthusiast, Béa Johnson, and {{launched}} a <b>Reusable</b> Container <b>Program</b> that allows customers to shop waste free should they choose.|$|R
40|$|SUMMARY This is {{commonly}} thought that CASE tools reduce programming efforts and increase development productivity. However, no paper has provide quantitative data supporting the matter. This paper discusses productivity improvement {{through the use}} of an integrated CASE tool system named EAGLE (Effective Approach to Achieving High Level Software Productivity), as shown by various data collected in Hitachi from the 1980 s to the 2000 s. We have evaluated productivity by using three metrics, l) program generation rate using <b>reusable</b> <b>program</b> skeletons and components, 2) fault density at two test phase, and 3) learning curve for the education of inexperienced programmers. We will show that productivity has been improved by the various facilities of EAGLE. key words: CASE, productivity, quality, reuse 1...|$|E
40|$|Object-oriented {{programming}} languages, such as Smalltalk, {{help one}} to build <b>reusable</b> <b>program</b> modules. The reuse of program modules requires adequate documentation [...] - formal or informal. Larch/Smalltalk is a formal specification language for specifying such reusable Smalltalk modules. Larch/Smalltalk firmly separates specification from implementation. In Larch/Smalltalk {{the unit of}} specification is an abstract data type, which is an abstraction of the behavior produced {{by one or more}} Smalltalk classes. A type can be a subtype of other types, which allows types to be organized based on specified behavior, and also allows for inheritance of their specifications. Larch/Smalltalk specifications are developed using specification tools integrated in the Smalltalk programming environment. 1 Introduction Object-oriented techniques encourage code reuse and modular design. In Smalltalk [GR 83], code reuse is achieved by defining one class to be a subclass of another class, called its superclass [...] ...|$|E
40|$|In a pre- and post-conditions {{style of}} specification, it is {{complicated}} to specify required sequences {{of the method}} calls. These sequences, that are called protocols, are important properties of reusable object-oriented classes and application frameworks. The approaches based on the pre- and post-conditions, such as design by contracts and formal behavioral interface specification languages (BISL), are an effective way of depicting precise interfaces of (<b>reusable)</b> <b>program</b> modules. ^ I developed an approach to specify the protocol properties in a compact and direct way by extending the Java Modeling Language, a behavioral interface specification language for Java. In this thesis, I will describe our approach by describing the syntax of the call sequence specification clause (ordering of allowed method calls), its formal semantics, and implementation. I believe that our approach can be easily adapted to other BISLs. ...|$|E
40|$|We {{present a}} {{specification}} composition technique which supports the message passing composition of applications by the Ensemble methodology. In Ensemble applications are built by composing <b>reusable</b> executable <b>program</b> components designed with scalable communication interfaces. We define <b>reusable</b> specifications of <b>program</b> components, using coloured Petri nets, {{which are then}} composed to obtain the specification of the application. The composition {{is controlled by the}} same script that is used to compose the application. ...|$|R
40|$|Abstract. This paper {{examines}} {{the question of}} whether increased software reuse can improve software reliability. One conclusion is that the assumed positive relationship between them depends on three different hypotheses, which this paper clarifies and makes testable. The intuitive concept of reusable and equivalent one-use components is clarified through the identification of attributes for comparing them, and showing how these attributes affect reliability. By applying measurement theory and using simple programs, the paper shows how various reliability models can be applied to collect data for one-use and <b>reusable</b> <b>programs...</b>|$|R
5000|$|<b>Reusable</b> Vehicle Testing <b>program</b> of the Japanese Space Agency JAXA ...|$|R
40|$|There are {{significant}} programming and methodological problems when developing PVM programs, the process communication structure of {{which does not}} form trees but arbitrary graphs. We present a design methodology, called Ensemble, and the appropriate PVM techniques and tools for the efficient composition of arbitrarily structured PVM programs. In Ensemble PVM programs are described by annotated Process Communication Graphs (PCGs) and the sequential program components are designed with open communication interfaces. The annotated PCGs are interpreted by a universal PVM program Loader which spawns processes and sets values to their communication interfaces, thus establishing the program communication structure. The program components are reusable without any modification in other PVM programs. Annotated PCGs are produced from PVM program scripts. The methodology may be applied to any message passing environment by developing specific annotations of the PCG, <b>reusable</b> <b>program</b> components and [...] ...|$|E
40|$|The {{object-oriented}} {{paradigm in}} software engineering provides {{support for the}} construction of modular and <b>reusable</b> <b>program</b> components, and is attractive for the design of large and complex distributed systems. Reachability analysis is an important and well-known tool for static analysis of critical properties in concurrent programs, such as deadlock freedom. It involves the systematic enumeration of all possible global states of program execution and provides the same level of assurance as formal veri cation, for properties of the synchronization structure in concurrent programs. However, direct application of traditional reachability analysis to concurrent object-oriented programs has many problems, such as incomplete analysis for reusable classes (not safe) and increased computational complexity (not ecient). We have proposed a novel technique called apportioning, for safe and ecient reachability analysis of concurrent object-oriented programs, that is based upon a simple [...] ...|$|E
40|$|High {{assurance}} in {{embedded system}} software {{is difficult to}} attain. Verification relies on testing. The unreliable and costly testing process is made much worse because the software base constantly changes: Adding a feature is by changing the code of other features, and the programs of the features entangle in the same <b>reusable</b> <b>program</b> unit of the programming language. For a large class of applications, including those requiring exception handling, this entanglement problem cannot be solved using existing general purpose programming languages. The Feature Language Extensions (FLX) {{is a set of}} language constructs designed to enable the programmer to solve the entanglement problem. It provides language support for assertion based verification. The satisfiability of first order assertions composed of variables defined by FLX can be determined without iterations of trials and errors. An executable FLX program is compiled into a finite state machine even if the state variables are unbounded...|$|E
40|$|This {{position}} paper presents a concept for aspect-oriented design and a seamless integration of AO design and implementation. We suggest a design notation based on standard UML which separates clearly the <b>reusable</b> <b>programming</b> language independent design of aspect code and base (business logic) code from the language dependant cross-cutting parts. Thus fostering reuse of aspect code and simplifying {{the replacement of}} the aspect-oriented implementation language. Additionally we ease the transition from design to implementation by defining the mapping from design model to implementation language and support automatic generation of aspect-oriented code skeletons from the design model...|$|R
40|$|The {{provision}} of embedding neural networks into software applications can enable variety of Artificial Intelligence systems for individual users {{as well as}} organizations. Previously, software implementation of neural networks remained limited to only simulations or application specific solutions. Tightly coupled solutions end up in monolithic systems and non <b>reusable</b> <b>programming</b> efforts. We adapt component based software engineering approach to effortlessly integrate neural network models into AI systems in an application independent way. As proof of concept, this paper presents componentization of three famous neural network models i) Multi Layer Perceptron ii) Learning Vector Quantization and iii) Adaptive Resonance Theory family of networks...|$|R
50|$|The Air Force <b>Reusable</b> Booster System <b>program</b> may renew {{interest}} in further development.|$|R
40|$|In the {{development}} of integrated software systems for assisting engineers {{in the design of}} structure particular program are often observed to be similar to a large extent. To reduce development costs these program modules should be designed for reusability. The design of such program modules is supported by so-called design patterns. They provide instructions and guidelines for supported by so-called design patterns. They provide instructions and guidelines for conceiving <b>reusable</b> <b>program</b> modules and for allowing programmers to utilize the experience of design experts. This thesis presents two interdependent desing patterns for the design of integrated software systems which especially emphasize reusability of program modules. The application of the developed design patterns is then shown in the field of structural analysis by the implementation of a reusable structural analysis module. Examples are provided to demonstrate the feasability of the implemented system. (orig.) Available from TIB Hannover: RA 3043 (96 - 1) / FIZ - Fachinformationszzentrum Karlsruhe / TIB - Technische InformationsbibliothekSIGLEDEGerman...|$|E
40|$|Abstract. One of {{the most}} {{difficult}} tasks in software development is that features are implemented by changing the code of other features. This problem cannot be solved with existing general purpose programming languages if the features interact and are executed in the same process [1]. A solution to the problem must include a method that can automatically identify where to make the changes, or in the context of interacting features, automatically detect their interaction conditions. The Feature Language Extensions (FLX) is a set of language constructs that enable the programmer to develop interacting features as separate and <b>reusable</b> <b>program</b> modules. This paper overviews the feature interaction detection method of FLX. It includes an algorithm that determines the satisfiability of quantifier free first order predicate formulas containing variables that are used in the actual software and, therefore, may have complex data structures and predicate methods. FLX provides language constructs for the programmer to specify reusable predicate combination functions so that the algorithm does not require iterations of trials and errors...|$|E
40|$|Abstract. With {{existing}} {{general purpose}} programming languages, interacting features executed {{in the same}} process must be implemented by changing the code of one another [1]. The Feature Language Extensions (FLX) {{is a set of}} programming language constructs that enables the programmer to develop interacting features as separate and <b>reusable</b> <b>program</b> modules. Features are integrated and have their interactions resolved in feature packages. FLX provides the precedence list facilities for the programmer to specify the execution order of the features in a feature package. While not applicable in all situations, precedence lists can be used to resolve many interaction conditions in a single statement. This paper describes the two types of precedence lists supported by FLX and their usage. We give the contradiction conditions that may occur when multiple precedence lists are used in a feature package and show how to resolve them. Finally, we show that the two types of FLX precedence lists are primitive: they can be used to implement arbitrary precedence relations among features that do not exhibit contradictions...|$|E
40|$|The {{development}} of flexible and <b>reusable</b> <b>programming</b> abstractions {{has suffered from}} the inherent problem that reusability and extensibility are limited due to position-dependent parameters. To tackle this problem, {{we have been working}} on the definition of a general-purpose composition language based on a variant of the _-calculus as formal semantics, in which agents communicate by passing immutable extensible records, called forms, rather than tuples. Using this approach, we are able to define compositional abstractions in a more natural and robust way. In this position paper, we will extend the notion of forms and illustrate that forms may serve as a unifying concept for component-based software development...|$|R
2500|$|The [...] VTHL <b>Reusable</b> Booster System <b>program</b> was {{initiated}} by the USAF in 2010.|$|R
50|$|Joined NASA in 1998 {{to work on}} the <b>reusable</b> {{launch vehicle}} <b>program</b> (space shuttle).|$|R
40|$|The paper {{describes}} a knowledge-based {{framework for the}} development of program reverse and forward engineering. The substrate for this framework is an object-oriented environment for knowledge-based applications (XRL) written in Common Lisp. The approach starts from the idea that forward and reverse engineering are evolutive, knowledge intensive activities. Regarding the development of knowledge-based systems, knowledge acquisition is considered as a modelling activity that implies not only the evolution of the knowledge base of the system but also the evolution of the mental model that the human experts actually use. Therefore, an integrated collection of tools and techniques that support the construction, evolution, and usage of knowledge-based models of programming concepts and constructs are provided. An evolutive taxonomy of <b>reusable</b> <b>program</b> components related to programming concepts is also considered essential for the approach. One of the main applications written in the knowledge-based framework is the development of an intelligent reverse engineering system of FORTRAN programs. After obtaining a high level description of an analyzed program, this description may be refined to C or pseudocode. 2 1...|$|E
40|$|A {{quantitative}} study {{has shown that}} frame technology [1] supported by Fusion toolset can lead to reduction in time-to-market (70 %) and project costs (84 %). Frame technology has been developed to handle large COBOL-based business software product families. We wished to investigate how the principle of frame approach {{can be applied to}} support product families in other application domains, in particular to build distributed component-based systems written in Object-Oriented languages. As Fusion is tightly coupled with COBOL, we implemented our own tools based on frame concepts using the XML technology. In our solution, a generic architecture for a product family is a hierarchy of XML documents. Each such document contains a <b>reusable</b> <b>program</b> fragment instrumented for change with XML tags. We use a tool built on top of XML parsing framework JAXP to process documents in order to produce a custom member of a product family. Our solution is cost-effective and extensible. In the paper, we describe our solution, illustrating its use with examples. We intend to make our solution available to public in order to encourage investigation of frame concepts in other application domains, implementation languages and platforms...|$|E
40|$|Software Design for Reliability and Reuse (SDRR) is {{a program}} {{generation}} technology based on a core of <b>reusable</b> <b>program</b> transformation tools. This report outlines the top-level design of the tools constructed in the proof-of-concept demonstration project. The SDRR system was designed with goals of simplicity, redundant functionality, incremental development, interoperability, and structure preservation. To meet the requirements specification and accomplish these goals, a suite of tools was developed and integrated into a linear pipeline of program transformations forming a software component generator. We describe the design goals, {{the structure of the}} pipeline, and design issues raised in the development process. Contents 1 Introduction 2 2 Design Goals 3 2. 1 Keep it simple : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 3 2. 2 Minimize number of intermediate representations : : : : : : : : : : : : : : : : : : : : : : 3 2. 3 Redundant functionality : [...] ...|$|E
5000|$|External Requirements Assessment Team for NASA 2nd Generation <b>Reusable</b> Launch Vehicle <b>Program</b> (2000- [...] ) ...|$|R
5000|$|The [...] VTHL <b>Reusable</b> Booster System <b>program</b> was {{initiated}} by the USAF in 2010.|$|R
25|$|SpaceX's <b>reusable</b> {{launcher}} <b>program</b> was publicly {{announced in}} 2011 {{and the design}} phase was completed in February 2012. The system returns {{the first stage of}} a Falcon 9 rocket to its launchpad using only its own propulsion systems.|$|R
