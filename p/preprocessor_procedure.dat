6|4|Public
5000|$|... terminates a {{preprocessor}} -group, -group, or <b>preprocessor</b> <b>procedure.</b>|$|E
5000|$|A <b>preprocessor</b> <b>procedure</b> is a {{subroutine}} {{executed by}} the preprocessor. The procedure is delimited by [...] and [...] statements and can contain only preprocessor statements, without the leading [...] It is invoked as a function reference from open code, outside of any <b>preprocessor</b> <b>procedure,</b> or from another <b>preprocessor</b> <b>procedure,</b> and returns a [...] or [...] value. When the procedure is invoked from open code the arguments are passed by name, that is they are interpreted as character strings delimited by commas or a right parenthesis, all leading, trailing, or embedded blanks are significant and {{considered part of the}} argument.|$|E
5000|$|... [...] returns [...] if the {{argument}} [...] {{was set in}} the current call to this <b>preprocessor</b> <b>procedure,</b> otherwise [...]|$|E
5000|$|In 1965 {{an update}} to IBM's PL/I Language {{specification}} defined an even less ambitious preprocessor language. All mention of <b>preprocessor</b> <b>procedures</b> was omitted. The following compile-time statements were specified: ...|$|R
5000|$|This {{language}} specification {{was again}} never implemented, however a 1966 revision of this manual restored <b>preprocessor</b> <b>procedures</b> with the now-current [...] syntax {{and brought the}} specification close to what was actually included in PL/I(F). Fixed-length character variables were gone. New statements added were: ...|$|R
5000|$|The {{preprocessor}} {{language has}} a PL/I-like syntax with preprocessor statements and <b>preprocessor</b> <b>procedures</b> prefixed with a percent symbol (...) [...] Listing-control statements, which supply formatting commands for the compiler listing, are usually considered preprocessor statements and also begin with [...] Preprocessor statements are imbedded in and operate on input text. The input text is normally a PL/I program, but is agnostic to the grammar of PL/I, so the preprocessor {{can also be}} used independently to process other kinds of text files.|$|R
5000|$|... heads a <b>{{preprocessor}}</b> <b>procedure,</b> {{a set of}} preprocessor {{statements that}} functions as a macro returning a value when its name is encountered in the input text.|$|E
5000|$|The {{following}} {{example for}} IBM PL/I for OS/2 illustrates {{the use of}} a <b>preprocessor</b> <b>procedure</b> to implement a C-like write statement for PL/I. [...] The procedure would be called by coding the statement [...] Byte_count is optional and defaults to the length of varying_string if omitted.|$|E
50|$|The {{preprocessor}} operates by {{scanning the}} input text and recognizing declared preprocessor names, also called preprocessor identifiers. The text is copied to the preprocessor output with the preprocessor names replaced with their current values. The name {{may represent a}} call to a <b>preprocessor</b> <b>procedure</b> (macro). Replacement text may be rescanned by the preprocessor for possible additional replacement.|$|E
5000|$|Preprocessor {{data may}} be {{declared}} to be , a character string with no maximum length, or [...] an integer number {{of up to}} five decimal digits. A preprocessor builtin is a predefined <b>procedure</b> operating on <b>preprocessor</b> data. A preprocessor expression is an expression consisting only of preprocessor names, references to <b>preprocessor</b> <b>procedures</b> or builtins, and decimal or character constants. There are no [...] variables, but a [...] result may be obtained by comparison. The expression in [...] evaluates to [...] All PL/I operators are allowed except exponentiation.|$|R

