394|244|Public
25|$|Dijkstra, Edsger W. (1968). A Constructive Approach to the Problem of <b>Program</b> <b>Correctness.</b> BIT Numerical Mathematics 8(1968): pp.174–186.|$|E
2500|$|Proof of <b>program</b> <b>correctness</b> {{by use of}} {{mathematical}} induction: Knuth demonstrates the application {{of mathematical}} induction to an [...] "extended" [...] version of Euclid's algorithm, and he proposes [...] "a general method applicable to proving the validity of any algorithm". Tausworthe proposes that {{a measure of the}} complexity of a program be the length of its correctness proof.|$|E
2500|$|Type safety {{contributes}} to <b>program</b> <b>correctness,</b> but can only guarantee correctness {{at the cost}} of making the type checking itself an undecidable problem. [...] In a type system with automated type checking a program may prove to run incorrectly yet be safely typed, and produce no compiler errors. Division by zero is an unsafe and incorrect operation, but a type checker running at compile time only doesn't scan for division by zero in most languages, and then it is left as a runtime error. To prove the absence of these more-general-than-types defects, other kinds of formal methods, collectively known as program analyses, are in common use. Alternatively, a sufficiently expressive type system, such as in dependently typed languages, can prevent these kinds of errors (for example, expressing the type of non-zero numbers). [...] In addition software testing is an empirical method for finding errors that the type checker cannot detect.|$|E
40|$|International audienceThe present paper {{introduces}} Scala-of-Coq, a new compiler {{that allows}} a Coq-based synthesis of Scala programs which are "correct-by-construction". A typical workflow features a user implementing a Coq functional program, proving this <b>program's</b> <b>correctness</b> with regards to its specification and making use of Scala-of-Coq to synthesize a Scala program that can seamlessly be integrated into an existing industrial Scala or Java application...|$|R
40|$|All {{software}} verification techniques, from theorem proving to testing, share the common goal {{of establishing a}} <b>program’s</b> <b>correctness</b> with both (1) {{a high degree of}} confidence and (2) a low cost to the user, two criteria in tension with one another. Theorem proving offers the benefit of high confidence, but requires significant expertise and effort from the user. Testing, on the other hand, can be performed for little cost, but low-cost testing does not yield high confidence in a <b>program’s</b> <b>correctness.</b> Although many static analyses can quickly and with high confidence check a program’s conformance to a specification, they achieve these goals by sacrificing the expressiveness of the specification. To date, static analyses have been largely limited to the detection of shallow properties that apply to a very large class of programs, such as absence of array-bound errors and conformance to API usage conventions. Few static analyses are capable of checking strong specifications, specifications whose satisfaction relies upon the program’s precise behavior...|$|R
50|$|Many {{programming}} paradigms are as {{well known}} for what methods they forbid as for what they enable. For instance, pure functional programming forbids using side-effects; structured programming forbids using goto statements. Partly for this reason, new paradigms are often regarded as doctrinaire or overly rigid by those accustomed to earlier styles. Avoiding certain methods can {{make it easier to}} prove theorems about a <b>program's</b> <b>correctness,</b> or simply to understand its behavior.|$|R
2500|$|Programmers in the Scheme dialect often express loops using tail recursion. Scheme's {{commonality}} {{in academic}} computer science {{has led some}} students to believe that tail recursion is the only, or the most common, way to write iterations in Lisp, but this is incorrect. All oft-seen Lisp dialects have imperative-style iteration constructs, from Scheme's [...] loop to Common Lisp's complex [...] expressions. Moreover, the key issue that makes this an objective rather than subjective matter is that Scheme makes specific requirements for the handling of tail calls, and thus {{the reason that the}} use of tail recursion is generally encouraged for Scheme is that the practice is expressly supported by the language definition. By contrast, ANSI Common Lisp does not require the optimization commonly termed a tail call elimination. Thus, the fact that tail recursive style as a casual replacement for the use of more traditional iteration constructs (such as , [...] or [...] ) is discouraged in Common Lisp {{is not just a matter}} of stylistic preference, but potentially one of efficiency (since an apparent tail call in Common Lisp may not compile as a simple jump) and <b>program</b> <b>correctness</b> (since tail recursion may increase stack use in Common Lisp, risking stack overflow).|$|E
50|$|An {{important}} use of specification languages is {{enabling the}} creation of proofs of <b>program</b> <b>correctness</b> (see theorem prover).|$|E
5000|$|Dijkstra, Edsger W. (1968). A Constructive Approach to the Problem of <b>Program</b> <b>Correctness.</b> BIT Numerical Mathematics 8(1968): pp. 174-186.|$|E
40|$|A {{tendency}} is becoming evident in programming, namely {{the attempt to}} use programming constructs that {{are more and more}} declarative in flavour. Here we present some observations on (and contributions to) this trend. We analyze declarative programming constructs taking into account the two following points of view: programming methodology (and its impact on <b>programming</b> <b>correctness)</b> and efficiency (and how it can be improved by means of program transformations). Then we present some examples of declarative programming...|$|R
40|$|To show {{various forms}} of {{equivalence}} between <b>programs</b> <b>Correctness</b> of optimization � p opt ∼ p unopt: τ Secrecy as non-interference � p v ∼ p w: τ for v ≠ w Correspondence between CPS and direct style � p CPS ∼ p DS: τ This Talk Logical relations for wider range of programming constructs Perfect encryption [Sumii-Pierce 01] Cf. Type abstraction [Reynolds 83] Higher-order references [ongoing work] First-class channels [ongoing work] Everything is syntactic and operationa...|$|R
40|$|The present paper {{introduces}} Scala-of-Coq, a new compiler {{that allows}} a Coq-based synthesis of Scala programs which are "correct-by-construction". A typical workflow features a user implementing a Coq functional program, proving this <b>program's</b> <b>correctness</b> with regards to its specification and making use of Scala-of-Coq to synthesize a Scala program that can seamlessly be integrated into an existing industrial Scala or Java application. Comment: 2 pages, accepted version of the paper as submitted to FTfJP 2017 (Formal Techniques for Java-like Programs), June 18 - 23, 2017, Barcelona, Spai...|$|R
50|$|Using RAII greatly {{simplifies}} resource management, reduces overall code {{size and}} helps ensure <b>program</b> <b>correctness.</b> RAII is therefore highly recommended in C++, {{and most of}} the C++ standard library follows the idiom.|$|E
50|$|Invariants are {{especially}} useful when reasoning {{about whether a}} computer program is correct. The theory of optimizing compilers, the methodology of design by contract, and formal methods for determining <b>program</b> <b>correctness,</b> all rely heavily on invariants.|$|E
50|$|Until {{the end of}} his life, Dijkstra {{maintained}} that the central challenges of computing hadn’t been met to his satisfaction, due to an insufficient emphasis on <b>program</b> <b>correctness</b> (though not obviating other requirements, such as maintainability and efficiency).|$|E
40|$|In {{this paper}} we {{describe}} the design of an extensible kernel, called Paramecium. This kernel uses an object-based software architecture which together with instance naming, late binding and explicit overrides enables easy reconfiguration. Determining which components reside in the kernel protection domain {{is up to the}} user. An certification authority or one of its delegates certifies which components are trustworthy and therefore permitted to run in the kernel protection domain. These delegates may include validation <b>programs,</b> <b>correctness</b> provers, and system administrators. The main advantage of certifications is that it can handle trust and sharing in a non-cooperative environment. 1...|$|R
40|$|We {{present a}} Coq library about Kleene algebra with tests, {{including}} a proof of their completeness over the appropriate notion of languages, a decision procedure for their equational theory, and tools for exploiting hypotheses {{of a particular}} shape in such a theory. Kleene algebra with tests {{make it possible to}} represent if-then-else statements and while loops in most imperative programming languages. They were actually introduced by Kozen as an alternative to propositional Hoare logic. We show how to exploit the corresponding Coq tools in the context of program verification by proving equivalences of while <b>programs,</b> <b>correctness</b> of some standard compiler optimisations, Hoare rules for partial correctness, and a particularly challenging equivalence of flowchart schemes. Comment: 16 + 3 page...|$|R
40|$|The {{order of}} method {{calls in a}} program can present subtle {{problems}} in ensuring the <b>program’s</b> <b>correctness.</b> Some of the problems have been known under different names in the open literature. These include protocols, synchronisation, re-entrance, mandatory calls, and the indirect invariant effect. However, all these problems relate to the temporal ordering of method calls. In essence, the orderings constrain invocations of methods that share program state or otherwise need to cooperate. This paper proposes a taxonomy of call ordering problems and their proposed solutions. The taxonomy classifies the problems by showing their common root and a few distinguishing properties. The paper also sketches the key features of a practical unifying solution to these call ordering problems. 1...|$|R
50|$|In the execute stage, the {{instruction}} operations are carried out. Instructions are delayed in this step {{until all of}} their operands are available, eliminating RAW hazards. <b>Program</b> <b>correctness</b> is maintained through effective address calculation to prevent hazards through memory.|$|E
50|$|In {{the context}} of <b>program</b> <b>correctness,</b> static {{analysis}} can discover vulnerabilities during the development phase of the program. These vulnerabilities are easier to correct than the ones found during the testing phase since static analysis leads {{to the root of}} the vulnerability.|$|E
50|$|If {{the above}} {{ordinary}} while rule {{is replaced by}} the following one, the Hoare calculus {{can also be used}} to prove total correctness, i.e. termination as well as partial correctness. Commonly, square brackets are used here instead of curly braces to indicate the different notion of <b>program</b> <b>correctness.</b>|$|E
40|$|We {{present a}} method for the {{synthesis}} of polynomial lasso programs. These programs consist of a program stem, a set of transitions, and an exit condition, all {{in the form of}} algebraic assertions (conjunctions of polynomial equalities). Central to this approach is the discovery of non-linear (algebraic) loop invariants. We extend Sankaranarayanan, Sipma, and Manna's template-based approach and prove a completeness criterion. We perform program synthesis by generating a constraint whose solution is a synthesized program together with a loop invariant that proves the <b>program's</b> <b>correctness.</b> This constraint is non-linear and is passed to an SMT solver. Moreover, we can enforce the termination of the synthesized program with the support of test cases. Comment: Paper at VMCAI' 14, including appendi...|$|R
40|$|Although testing {{starts with}} {{individual}} programs, programs are rarely self-contained in real software environments. They depend on external subsystems like language run time and operating system libraries for various functionalities. These subsystems are developed externally to any given program, {{with their own}} test processes. Of course, an uncoordinated change {{in one of the}} external subsystems may affect the <b>program’s</b> <b>correctness.</b> Test teams therefore add an integration testing step to their process to ensure that programs will continue to operate with different versions of the external subsystems. As full testing may take days or weeks to run, it is useful to understand how to prioritize these tests. We present an integration testing system to understand and quantify the impact of a change, so test teams can focus thei...|$|R
40|$|The {{development}} of parallel applications usually is composed by three tasks: <b>programming,</b> <b>correctness</b> debugging and performance debugging. The last {{of these three}} tasks is specially important in parallel applications to obtain high performance. There {{are a number of}} tools that try to turn the performance debugging more convenient to the programmer. However, most of them are ad-hoc implementations. A more proeminent tool that is trying to became a standard is MPE- Multiprocessing Environment, which is distributed with MPICH implementation. The drawback of this tool {{is that it does not}} have support to all MPI operations and has a limited number of functions that can be used by the programmer. This paper describes MPI-Rastro library, which tries to solve the main problems of MPE implementatio...|$|R
5000|$|Programmers can use assertions to help specify {{programs}} and to reason about <b>program</b> <b>correctness.</b> For example, a precondition—an assertion {{placed at the}} beginning of a section of code—determines the set of states under which the programmer expects the code to execute. A postcondition—placed at the end—describes the expected state at the end of execution. For example: ...|$|E
5000|$|Proof of <b>program</b> <b>correctness</b> {{by use of}} {{mathematical}} induction: Knuth demonstrates the application {{of mathematical}} induction to an [...] "extended" [...] version of Euclid's algorithm, and he proposes [...] "a general method applicable to proving the validity of any algorithm". Tausworthe proposes that {{a measure of the}} complexity of a program be the length of its correctness proof.|$|E
50|$|The design goal {{behind the}} Eiffel language, libraries, and {{programming}} methods is to enable programmers to create reliable, reusable software modules. Eiffel supports multiple inheritance, genericity, polymorphism, encapsulation, type-safe conversions, and parameter covariance. Eiffel's most {{important contribution to}} software engineering is design by contract (DbC), in which assertions, preconditions, postconditions, and class invariants are employed to help ensure <b>program</b> <b>correctness</b> without sacrificing efficiency.|$|E
50|$|To derive {{a program}} means {{to write a}} formal specification, which is usually non-{{executable}}, and then apply mathematically correct rules {{in order to obtain}} an executable program satisfying that specification. The program thus obtained is then correct by construction. <b>Program</b> and <b>correctness</b> proof are constructed together.|$|R
40|$|There {{are many}} {{applications}} where precise mode analysis is required. However, {{within the framework}} of abstract interpretation, the precision of an analyser depends, in part, on the expressiveness of the abstract domain and its associated abstraction function. This paper considers abstract domains for polymorphically typed logic programs where each nonvariable symbol is explicitly typed. We show how to construct precise domains and their abstraction functions that reflect the declared structure of terms. This domain construction is modular in that an abstract domain for a type does not depend on modules that import this type. A program is abstracted by replacing the unification operations with abstract unification operations. The precision of the domains is demonstrated for several examples using Godel <b>programs.</b> <b>Correctness</b> of the method is proven. The domain construction has been implemented in Gödel...|$|R
50|$|Liskov's {{notion of}} a {{behavioral}} subtype defines a notion of substitutability for objects; that is, if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that <b>program</b> (e.g. <b>correctness).</b>|$|R
50|$|The main {{applications}} of program analysis are program optimization (running time, space requirements, power consumption etc.) and <b>program</b> <b>correctness</b> (bugs, security vulnerabilities etc.). Program analysis {{can be applied}} to compilation (static analysis), run-time (dynamic analysis), or both. In language-based security, program analysis can provide several useful features, such as: type checking (static and dynamic), monitoring, taint checking and control-flow analysis.|$|E
50|$|In {{computer}} science, program {{analysis is}} the process of automatically analyzing the behavior of computer programs regarding a property such as correctness, robustness, safety and liveness. Program analysis focuses on two major areas: program optimization and <b>program</b> <b>correctness.</b> The first focuses on improving the program’s performance while reducing the resource usage while the latter focuses on ensuring that the program does what it is supposed to do.|$|E
50|$|The {{last and}} maybe most {{important}} point to note about descriptors {{is how they}} affect the complementary notions of system security and <b>program</b> <b>correctness.</b> One of the best tools a hacker has to compromise operating systems of today is the buffer overflow. C, in particular, uses the most primitive and error-prone way to {{mark the end of}} strings, using a null byte as an end-of-string sentinel in the data stream itself.|$|E
40|$|We try {{to assess}} {{to what extent}} {{declarative}} programming can be realized in Prolog and which aspects of <b>correctness</b> of Prolog <b>programs</b> {{can be dealt with}} by means of declarative interpretation. More speci cally, we shall discuss termination of Prolog <b>programs,</b> partial <b>correctness,</b> absence of errors and the safe use of negation...|$|R
40|$|A {{relation}} � v ∼ w: τ between values v and w in a typed λ-calculus, defined {{according to}} their type τ E. g., � i ∼ j: int ⇔ i = j � f ∼ g: σ → τ ⇔ � eval(f v) ∼ eval(g w) : τ for any � v ∼ w: σ � (v 1, v 2) ∼ (w 1, w 2) : τ 1 × τ 2 ⇔ � v 1 ∼ w 1 : τ 1 and � v 2 ∼ w 2 : τ 2 What is it Useful for? To show various forms of equivalence between <b>programs</b> <b>Correctness</b> of optimization � p opt ∼ p unopt: τ Secrecy as non-interference � p v ∼ p w: τ for v ≠ w Correspondence between CPS and direct style etc. � p CPS ∼ p DS:...|$|R
40|$|Cooperative {{applications}} {{are expected to}} become commonplace in the future. We are concerned here with a special case of cooperation called indirect cooperation. The idea of the paper is that a Concurrency Control approach better fits to indirect cooperation than a Concurrent Programming one. In other words, it does exist syntactic correctness criteria which defines a large sphere of security in which application programmers are released from the burden of interaction explicit programming. This paper arguments {{this point of view}} and describes such a criterion: the COO-Serializability. It applies for a class of applications which cooperate indirectly. Keywords: Cooperation, Concurrency control, Concurrent <b>Programming,</b> <b>Correctness</b> Criterion, Cooperative <b>Programming,</b> Cooperative Execution 1 Introduction Cooperative {{applications are}} expected to become commonplace in the future. We are concerned here with a special case of cooperation that we called indirect cooperation. The idea of the pa [...] ...|$|R
