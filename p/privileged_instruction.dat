27|74|Public
25|$|The CPU recognizes seven {{interrupt}} levels. Levels 1 through 5 {{are strictly}} prioritized. That is, a higher-numbered interrupt can always interrupt a lower-numbered interrupt. In the status register, a <b>privileged</b> <b>instruction</b> {{allows one to}} set the current minimum interrupt level, blocking lower or equal priority interrupts. For example, if the interrupt level in the status register is set to 3, higher levels from 4 to 7 can cause an exception. Level 7 is a level triggered Non-maskable interrupt (NMI). Level 1 can be interrupted by any higher level. Level 0 means no interrupt. The level is stored in the status register, and is visible to user-level programs.|$|E
5000|$|RISC-V's ISA {{includes}} a separate <b>privileged</b> <b>instruction</b> set specification.|$|E
50|$|The <b>privileged</b> <b>instruction</b> set {{specification}} of RISC-V is currently (July 2017) preliminary.|$|E
5000|$|... {{privilege}} violation (attempts {{to execute}} <b>privileged</b> <b>instructions)</b> ...|$|R
5000|$|... <b>privileged</b> <b>instructions</b> ALLCLEAN, OTHERW, NORMALW, and INVALW ...|$|R
50|$|There {{was both}} a user mode and a {{supervisor}} mode, selected by bit 14 in the flag register. In supervisor mode, the stack registers point to the system stack and all <b>privileged</b> <b>instructions</b> are available. In user mode, the stack registers point to the normal stack and all <b>privileged</b> <b>instructions</b> will generate a fault.|$|R
5000|$|The SIGILL {{signal is}} sent to a process when it {{attempts}} to execute an illegal, malformed, unknown, or <b>privileged</b> <b>instruction.</b>|$|E
50|$|The RISC-V website has a {{specification}} for user-mode instructions, and {{a preliminary}} specification for a general-purpose <b>privileged</b> <b>instruction</b> set, to support operating systems.|$|E
5000|$|A privileged {{operation}} exceptionPoOps is recognized when a program attempts {{to execute a}} <b>privileged</b> <b>instruction</b> when the problem state bit in the PSW is 1.|$|E
5000|$|Kernel mode allows {{unrestricted}} {{access to}} hardware including execution of <b>privileged</b> <b>instructions.</b>|$|R
5000|$|... {{attempting}} to execute <b>privileged</b> <b>instructions</b> {{when the current}} privilege level (CPL) is not zero ...|$|R
30|$|Nested {{virtualization}} of CPU is firstly {{implemented by}} binary translation of <b>privileged</b> <b>instructions.</b> With {{the support of}} new CPU feature, including Intel VMX and AMD SVM, nested virtualization of CPU becomes easier and more efficient. Binary translation can reduce the time cost {{when there is a}} TLB miss, but hardware assisted virtualization can more efficiently support <b>privileged</b> <b>instructions.</b> So, hardware assisted virtualization is better in CPU intense workload while binary translation is better in memory intensive workload. As the hypercalls are more concerned with executing <b>privileged</b> CPU <b>instructions,</b> we choose hardware assisted virtualization as our solution.|$|R
50|$|When a set {{amount of}} gates {{in a network}} became infected, they would begin {{communicating}} {{with each other and}} create <b>privileged</b> <b>instruction</b> channels which could be used by shadowy controllers with the correct authentication keys to control them remotely. They could defend themselves against attack, build and direct weapons to selected targets, and netlink to any number of T-gates.|$|E
50|$|When {{a program}} was running in 'problem state', using a <b>privileged</b> <b>instruction</b> or an invalid memory address {{would cause the}} {{hardware}} to raise an exception condition. By trapping these conditions, CP could simulate the appropriate behavior, e.g. performing I/O or paging operations. A guest operating system, which would run in 'supervisor state' on a bare machine, was run in 'problem state' under CP.|$|E
5000|$|The TR {{register}} is a 16-bit register {{which holds}} a segment selector for the TSS. It may be loaded through the LTR instruction. LTR is a <b>privileged</b> <b>instruction</b> and acts {{in a manner}} similar to other segment register loads. The task register has two parts: a portion visible and accessible by the programmer and an invisible one that is automatically loaded from the TSS descriptor ...|$|E
5000|$|Address space layout {{randomization}} (to make {{it harder}} for buffer overruns to execute <b>privileged</b> <b>instructions</b> at known addresses in memory) ...|$|R
50|$|The dom0 domain is {{typically}} {{a version of}} Linux or BSD. User domains may either be traditional operating systems, such as Microsoft Windows under which <b>privileged</b> <b>instructions</b> are provided by hardware virtualization instructions (if the host processor supports x86 virtualization, e.g., Intel VT-x and AMD-V), or para-virtualized operating systems whereby the operating system is aware that it is running inside a virtual machine, and so makes hypercalls directly, rather than issuing <b>privileged</b> <b>instructions.</b>|$|R
5000|$|... The Model 67 {{includes}} some instructions to handle 32-bit addresses and [...] "dynamic address translation" [...] with additional <b>privileged</b> <b>instructions</b> to provide virtual memory.|$|R
50|$|However, RISC-V also {{supports}} the designers' academic uses. The {{simplicity of the}} integer subset permits basic student exercises. The integer subset is a simple ISA enabling software to control research machines. The variable-length ISA enables extensions for both student exercises and research. The separated <b>privileged</b> <b>instruction</b> set permits research in operating system support, without redesigning compilers. RISC-V's open intellectual property allows its designs to be published, reused, and modified.|$|E
50|$|In {{computer}} programming, exceptions {{related to}} <b>privileged</b> <b>instruction</b> violations {{may be caused}} when an array has been accessed out of bounds or an invalid pointer has been dereferenced when the invalid memory location referenced is a privileged location, such as one controlling device input/output. This is particularly {{more likely to occur}} in programming languages such as C which use pointer arithmetic or do not check array bounds automatically.|$|E
5000|$|An {{instruction}} {{set for the}} smallest [...] "embedded" [...] CPUs (set [...] "E") is reduced in other ways: Only 16 of the 32-bit integer registers are supported. Floating-point instructions should not be supported (the specification forbids it as uneconomical), so a floating-point software library must be used. The compressed set [...] "C" [...] is recommended. The <b>privileged</b> <b>instruction</b> set supports only machine mode, user mode and memory schemes that use base-and-bound address relocation.|$|E
5000|$|A {{mainstream}} operating system. IBM's mainstream {{operating systems}} (i.e. the MVS or DOS/VSE families) can be loaded and run without modification. The VM hypervisor treats guest operating systems as application programs with exceptional privileges - it {{prevents them from}} using <b>privileged</b> <b>instructions</b> (those which would let applications take over the whole system or significant parts of it), but simulates <b>privileged</b> <b>instructions</b> on their behalf. Most mainframe operating systems terminate a normal application which tries to usurp the operating system's privileges.|$|R
5000|$|<b>Privileged</b> <b>instructions</b> : Those that trap if the {{processor}} is in user mode {{and do not}} trap {{if it is in}} system mode (supervisor mode).|$|R
50|$|This made it {{difficult}} to implement a virtual machine monitor for this type of processor. Specific limitations included the inability to trap on some <b>privileged</b> <b>instructions.</b>|$|R
50|$|An escape {{mechanism}} {{was provided}} to allow the instruction set to be expanded beyond the 256 entries selected by any one opcode. A further mechanism existed to switch between several sets of dispatch tables, allowing the machine to support multiple instruction sets concurrently. Using this mechanism a different instruction set could be selected each time a context switch occurred. This mechanism was also used to implement <b>privileged</b> <b>instruction,</b> dynamic profiling (for performance monitoring) and multiple CPU modes (e. g. User and Kernel).|$|E
5000|$|EXCPVR may be viewed, historically, as a V=R (i.e., Virtual=Real) {{version of}} EXCP. However, EXCPVR is not {{restricted}} to V=R applications. Indeed, EXCPVR may refer to non-V=R data areas provided such data areas are [...] "fixed" [...] and the channel command words which reference such data areas have been translated from virtual to real addresses by the programmer using the LRA Load Real Address [...] <b>privileged</b> <b>instruction,</b> as the data channels deal only with real addresses,not virtual addresses. EXCPVR was first introduced in SVS and was continued in MVS/370.|$|E
5000|$|Load Program Status Word (LPSW) is a <b>privileged</b> <b>instruction</b> that loads the Program Status Word (PSW), {{including}} the program mode, protection key, and {{the address of}} the next instruction to be executed. LPSW is most often used to [...] "return" [...] from an interruption by loading the [...] "old" [...] PSW which is associated with the interruption class. Other privileged instructions (e.g., SSM, STNSM, STOSM, SPKA, etcetera) are available for manipulating subsets of the PSW without causing an interruption or loading a PSW; and one non-privileged instruction (SPM) is available for manipulating the program mask.|$|E
50|$|Although certain fields {{within the}} PSW may be tested or set by using non-privileged instructions, testing or setting the {{remaining}} fields {{may only be}} accomplished by using <b>privileged</b> <b>instructions.</b>|$|R
50|$|Theorem 1. For any {{conventional}} third-generation computer, {{an effective}} VMM may be constructed if {{the set of}} sensitive instructions for that computer is {{a subset of the}} set of <b>privileged</b> <b>instructions.</b>|$|R
50|$|CLI and STI are <b>privileged</b> <b>instructions,</b> which {{trigger a}} general {{protection}} fault if an unprivileged application attempts to execute it, while POPF will simply not modify the IF flag if the application is unprivileged.|$|R
5000|$|As {{mentioned}} above, the VM {{control program}} includes a hypervisor-call handler that intercepts DIAG ("Diagnose") instructions used within a virtual machine. This provides fast-path non-virtualized execution of file-system access and other operations (DIAG is a model-dependent <b>privileged</b> <b>instruction,</b> {{not used in}} normal programming, and thus is not virtualized. It is therefore available {{for use as a}} signal to the [...] "host" [...] operating system). When first implemented in CP/CMS release 3.1, this use of DIAG provided an operating system interface that was analogous to the System/360 Supervisor Call instruction (SVC), but that did not require altering or extending the system's virtualization of SVC.|$|E
5000|$|The <b>privileged</b> <b>instruction</b> set {{specification}} explicitly defines [...] "hardware threads," [...] or [...] "harts." [...] Multiple hardware threads are {{a common}} practice in larger, more powerful computers. When one thread is stalled, waiting for memory, others can often proceed. Hardware threads can help make better use of {{the large number of}} registers and execution units in large CPUs. Finally, hardware threads can be a simple, powerful way to handle interrupts: No saving or restoring of registers is required, simply executing a different hardware thread. The only hardware thread required in a RISC-V computer is thread zero.|$|E
50|$|The CPU recognizes seven {{interrupt}} levels. Levels 1 through 5 {{are strictly}} prioritized. That is, a higher-numbered interrupt can always interrupt a lower-numbered interrupt. In the status register, a <b>privileged</b> <b>instruction</b> {{allows one to}} set the current minimum interrupt level, blocking lower or equal priority interrupts. For example, if the interrupt level in the status register is set to 3, higher levels from 4 to 7 can cause an exception. Level 7 is a level triggered Non-maskable interrupt (NMI). Level 1 can be interrupted by any higher level. Level 0 means no interrupt. The level is stored in the status register, and is visible to user-level programs.|$|E
50|$|The 940 adds {{modes of}} {{operation}} to support multiple users. The operating mode of previous models is renamed normal mode. A new monitor mode limits access to input/output and certain <b>privileged</b> <b>instructions.</b> A user mode is used to run users' application programs.|$|R
50|$|Instead, in MINIX 3, each {{device driver}} is a {{separate}} user-mode process. Drivers cannot execute <b>privileged</b> <b>instructions,</b> change the page tables, perform arbitrary input/output (I/O), or write to absolute memory. They must make kernel calls for these services and the kernel checks each call for authority.|$|R
2500|$|Supervisor mode is [...] "an {{execution}} mode on some processors {{which enables}} execution of all <b>instructions,</b> including <b>privileged</b> <b>instructions.</b> It may also give {{access to a}} different address space, to memory management hardware and to other peripherals. This is the mode in which the operating system usually runs." ...|$|R
