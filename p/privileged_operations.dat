37|14|Public
25|$|To {{reduce the}} risk of a {{vulnerability}} or misconfiguration allowing privilege escalation, many programs have been written or adapted to make use of privilege separation, privilege revocation and chrooting. Privilege separation is a technique, pioneered on OpenBSD and inspired by the principle of least privilege, where a program is split into two or more parts, one of which performs <b>privileged</b> <b>operations</b> and the other—almost always the bulk of the code—runs without privilege. Privilege revocation is similar and involves a program performing any necessary operations with the privileges it starts with then dropping them. Chrooting involves restricting an application to one section of the file system, prohibiting it from accessing areas that contain private or system files. Developers have applied these features to OpenBSD versions of many common applications, such as tcpdump, file, tmux, smtpd, and syslogd.|$|E
50|$|A common {{method to}} {{implement}} privilege separation {{is to have}} a computer program fork into two processes. The main program drops privileges, and the smaller program keeps privileges in order to perform a certain task. The two halves then communicate via a socket pair. Thus, any successful attack against the larger program will gain minimal access, even though the pair of programs will be capable of performing <b>privileged</b> <b>operations.</b>|$|E
50|$|Primary token: Primary tokens {{can only}} be {{associated}} to processes, and they represent a process's security subject. The creation of primary tokens and their association to processes are both <b>privileged</b> <b>operations,</b> requiring two different privileges {{in the name of}} privilege separation - the typical scenario sees the authentication service creating the token, and a logon service associating it to the user's operating system shell. Processes initially inherit a copy of the parent process's primary token.|$|E
5000|$|A <b>privileged</b> <b>operation</b> exceptionPoOps is {{recognized}} when a program attempts {{to execute a}} privileged instruction when the problem state bit in the PSW is 1.|$|R
40|$|Abstract—Network {{has been}} widely applied {{in all aspects of}} life with time. Spread of {{malicious}} programs and harm thereof are also gradually increased with network. Sandbox provides high isolation environment for operation of suspicious program, thereby detecting malicious code effectively. However, there are some problems and disadvantages in sandboxes which are popular at present. Therefore, we establish a sandbox on user-level virtualization platform, which is called Dune[1]. The so-called user-level virtualization refers to a virtualization platform capable for providing direct and safe <b>privileged</b> <b>operation</b> for application programs. It is called Dune[1]. Compared with VMM [2] which provides support for operation system, Dune is more compact and lightweight. Meanwhile, sandbox, as an application program, is operated under dune, which can be operated under privileged mode by the aid of VT-x[3]. <b>Privileged</b> <b>operation</b> can be provided directly and safely, mode switch can be reduced compared with sandbox in the application layer in the aspect of intercepting API calls[4]. Experimental results showed that dune-based sandbox can guarantee higher performance on the basis of smaller scale. Keywords—sandbox, dune, hardware support, API interception, information security I...|$|R
5000|$|Many {{network service}} daemons {{have to do}} a {{specific}} <b>privileged</b> <b>operation</b> such as open a raw socket or an Internet socket in the well known ports range. Administrative utilities can require particular privileges at run-time as well. Such software tends to separate privileges by revoking them completely after the critical section is done, and change the user it runs under to some unprivileged account after so doing. This action is known as dropping root under Unix-like operating systems. The unprivileged part is usually run under the [...] "nobody" [...] user or an equivalent separate user account.|$|R
5000|$|There are no {{controls}} in AppArmor for categorically bounding POSIX capabilities. Since the current implementation of capabilities contains no {{notion of a}} subject for the operation (only the actor and the operation itself) {{it is usually the}} job of the MAC layer to prevent <b>privileged</b> <b>operations</b> on files outside the actor's enforced realm of control (i.e. [...] "Sandbox"). AppArmor can prevent its own policy from being altered, and prevent filesystems from being mounted/unmounted, but does nothing to prevent users from stepping outside their approved realms of control.|$|E
50|$|A {{process is}} the {{scheduled}} entity in VOS and each process has a set of attributes that govern how it is manipulated by the system. For example, processes have a user name and process name. The former is used by VOS to determine the process's access rights to external devices and items with the file system. Of fundamental significance is a process's privileged flag, which is a binary attribute. Privileged processes may perform <b>privileged</b> <b>operations.</b> This mechanism is used to restrict certain potentially powerful operations that can have system wide consequences (e.g. shutting down the system, dismounting a hard disk etc.).|$|E
5000|$|LPC {{implementations}} {{generally have}} a [...] "master object", {{which is a}} specific LPC object that is loaded first by the LPC driver and which essentially controls what will happen past that point. The master object will typically tell the driver where the simul_efun object is, preload any objects which need to be present at startup, define what functions will be called when an object is loaded, and otherwise configure the driver's operation. The driver will refer back to the master object when it needs to interact with a central point of reference for the running environment, such as for accepting network connections, handling errors, and validating attempts to perform <b>privileged</b> <b>operations.</b>|$|E
50|$|In {{addition}} to files and catalogues, there are 3 types of symbolic links. References (REF) {{can be created}} to point to another file or catalogue which creator of the REF can see through an initial context pointer, in either the same filesystem or another filesystem. Off Disk Pointers (ODP) are similar to references but can be created to point to a file or catalogue which cannot be seen through any initial context pointers, and creating an ODP is a <b>privileged</b> <b>operation</b> only available to the system manager. Support for Unix style symlinks (arbitrary text stored in a catalogue) was added in Rel 6.5 to better support the OS4000 NFS server, but symlinks can only be created and are only visible from NFS clients.|$|R
5000|$|Logical Domains {{exploits}} {{the chip}} multithreading (CMT) {{nature of the}} [...] "CoolThreads" [...] processors. A single chip contains up to 32 CPU cores, and each core has either four hardware threads (for the UltraSPARC T1) or eight hardware threads (for the UltraSPARC T2/T2+, and SPARC T3/T4 and later) that act as virtual CPUs. All CPU cores execute instructions concurrently, and each core switches between threads—typically when a thread stalls on a cache miss or goes idle—within a single clock cycle. This lets the processor gain throughput that is lost during cache misses in conventional CPU designs. Each domain is assigned its own CPU threads and executes CPU instructions at native speed, avoiding the virtualization overhead for <b>privileged</b> <b>operation</b> trap-and-emulate or binary rewrite typical of most VM designs.|$|R
40|$|Private name spaces {{were first}} {{introduced}} into LINUX during the 2. 5 kernel series. Their use {{has been limited}} due to name space manipulation being considered a <b>privileged</b> <b>operation.</b> Giving users and applications {{the ability to create}} private name spaces as well as the ability to mount and bind resources is the key to unlocking the full potential of this technology. There are serious performance, security and stability issues involved with user-controlled dynamic private name spaces in LINUX. This paper proposes mechanisms and policies for maintaining system integrity while unlocking the power of dynamic name spaces for normal users. It discusses relevant potential applications of this technology including its use with FILESYSTEM IN USERSPACE[24], V 9 FS[8] (the LINUX port of the PLAN 9 resource sharing protocol) and PLAN 9 FROM USER SPACE[4] (the PLAN 9 application suite including user space synthetic file servers ported to UNIX variants) ...|$|R
50|$|SAP IQ {{provides}} several features, both {{included in}} the base product and licensable separately, to help protect {{the security of the}} user’s data. A new feature introduced in IQ 16 is the Role Based Access Control (RBAC) which enables for a separation of duties and upholds the principle of least privilege, by allowing the breakdown of <b>privileged</b> <b>operations</b> into fine-grained sets that can be individually granted to users. Included as part of the base product are: users, groups and permissions, database administration authorities, user login policies, database encryption, transport-layer security, IPV6, role-based access control, and database auditing. Additional features are part of a licensable option called the advanced security option: FIPS encryption, Kerberos authentication, LDAP authentication, and Database column encryption.|$|E
50|$|The {{heart of}} the VM {{architecture}} is a control program or hypervisor called VM-CP (usually: CP; sometimes, ambiguously: VM). It runs on the physical hardware, and creates the virtual machine environment. VM-CP provides full virtualization of the physical machine - including all I/O and other <b>privileged</b> <b>operations.</b> It performs the system's resource-sharing, including device management, dispatching, virtual storage management, and other traditional operating system tasks. Each VM user is provided with a separate virtual machine having its own address space, virtual devices, etc., and which is capable of running any software that could be run on a stand-alone machine. A given VM mainframe typically runs {{hundreds or thousands of}} virtual machine instances. VM-CP began life as CP-370, a reimplementation of CP-67, itself a reimplementation of CP-40.|$|E
5000|$|A key {{challenge}} for full virtualization is the interception and simulation of <b>privileged</b> <b>operations,</b> such as I/O instructions. The effects of every operation performed {{within a given}} virtual machine must be kept within that virtual machine [...] - [...] virtual operations cannot be allowed to alter the state of any other virtual machine, the control program, or the hardware. Some machine instructions can be executed directly by the hardware, since their effects are entirely contained within the elements managed by the control program, such as memory locations and arithmetic registers. But other instructions that would [...] "pierce the virtual machine" [...] cannot be allowed to execute directly; they must instead be trapped and simulated. Such instructions either access or affect state information that is outside the virtual machine.|$|E
50|$|Packet {{injection}} is a <b>privileged</b> <b>operation</b> {{that may}} introduce a security threat, {{something that the}} introduction of TAP device solved only partially. Slirp-derived NAT implementation brought {{a solution to this}} long-standing problem. It was discovered that Slirp has the full NAPT implementation as a stand-alone user-space code, whereas other NAT engines are usually embedded into a network protocol stack and/or do not cooperate with the host OS when doing PAT (use their own port ranges and require packet injection). QEMU project have adopted the appropriate code portions of the Slirp package and got the permission from its original authors to re-license it under 3-clause BSD license.Such license change allowed many other FOSS projects to adopt the QEMU-provided Slirp portions, which was (and still is) not possible with the original Slirp codebase because of the license compatibility problems. Some of the notable adopters are VDE and Libvirt projects. Even though the Slirp-derived code was heavily criticized, to the date there is no competing implementation available.|$|R
5000|$|The [...] "render nodes" [...] concept try {{to solve}} these {{scenarios}} by splitting the DRM user space API in two interfaces, one privileged and another non-privileged, and using separated device files (or [...] "nodes") for each one. For every GPU found, its corresponding DRM driver [...] - if it supports the render nodes feature - [...] creates a device file , called the render node, {{in addition to the}} primary node [...] Clients that use a direct rendering model and applications that {{want to take advantage of}} the computing facilities of a GPU, can do it without requiring additional privileges by simply opening any existing render node and dispatching GPU operations using the limited subset of the DRM API supported by those nodes [...] - provided they have file system permissions to open the device file. Display servers, compositors and any other program that requires the modeset API or any other <b>privileged</b> <b>operation</b> must open the standard primary node that grants access to the full DRM API and use it as usual. Render nodes restricted API explicitly disallow the GEM flink operation to prevent buffer sharing using insecure GEM global names; only PRIME (DMA-BUF) file descriptors can be used to share buffers with another client, including the graphics server.|$|R
40|$|Double-fetch bugs are {{a special}} type of race condition, where an unprivileged {{execution}} thread {{is able to}} change a memory location between the time-of-check and time-of-use of a privileged execution thread. If an unprivileged attacker changes the value at the right time, the <b>privileged</b> <b>operation</b> becomes inconsistent, leading {{to a change in}} control flow, and thus an escalation of privileges for the attacker. More severely, such double-fetch bugs can be introduced by the compiler, entirely invisible on the source-code level. We propose novel techniques to efficiently detect, exploit, and eliminate double-fetch bugs. We demonstrate the first combination of state-of-the-art cache attacks with kernel-fuzzing techniques to allow fully automated identification of double fetches. We demonstrate the first fully automated reliable detection and exploitation of double-fetch bugs, making manual analysis as in previous work superfluous. We show that cache-based triggers outperform state-of-the-art exploitation techniques significantly, leading to an exploitation success rate of up to 97 %. Our modified fuzzer automatically detects double fetches and automatically narrows down this candidate set for double-fetch bugs to the exploitable ones. We present the first generic technique based on hardware transactional memory, to eliminate double-fetch bugs in a fully automated and transparent manner. We extend defensive programming techniques by retrofitting arbitrary code with automated double-fetch prevention, both in trusted execution environments as well as in syscalls, with a performance overhead below 1 %...|$|R
50|$|To {{reduce the}} risk of a {{vulnerability}} or misconfiguration allowing privilege escalation, many programs have been written or adapted to make use of privilege separation, privilege revocation and chrooting. Privilege separation is a technique, pioneered on OpenBSD and inspired by the principle of least privilege, where a program is split into two or more parts, one of which performs <b>privileged</b> <b>operations</b> and the other—almost always the bulk of the code—runs without privilege. Privilege revocation is similar and involves a program performing any necessary operations with the privileges it starts with then dropping them. Chrooting involves restricting an application to one section of the file system, prohibiting it from accessing areas that contain private or system files. Developers have applied these features to OpenBSD versions of many common applications, such as tcpdump, file, tmux, smtpd, and syslogd.|$|E
5000|$|In the {{original}} DRM API, the DRM device [...] {{is used for}} both privileged (modesetting, other display control) and non-privileged (rendering, GPGPU compute) operations. For security reasons, opening the associated DRM device file requires special privileges [...] "equivalent to root-privileges". This leads to an architecture where only some reliable user space programs (the X server, a graphical compositor, ...) have full access to the DRM API, including the privileged parts like the modeset API. The remainder user space applications that want to render or make GPGPU computations should be granted by {{the owner of the}} DRM device ("DRM Master") {{through the use of a}} special authentication interface. Then the authenticated applications can render or make computations using a restricted version of the DRM API without <b>privileged</b> <b>operations.</b> This design imposes a severe constraint: there must always be a running graphics server (the X Server, a Wayland compositor, ...) acting as DRM-Master of a DRM device so that other user space programs can be granted to use the device, even in cases not involving any graphics display like GPGPU computations.|$|E
50|$|Reports {{surfaced}} in early 2007 that Windows Speech Recognition may {{be vulnerable to}} an attack that could allow attackers {{to take advantage of}} its capabilities to perform undesired operations on a targeted computer by playing audio through the targeted computer's speakers; it was the first vulnerability discovered after the operating system's general retail availability. While Microsoft stated that such an attack is theoretically possible, it would have to meet a number of prerequisites in order to be successful: the targeted system would be required to have the speech recognition feature previously activated and configured, speakers and microphone(s) connected to the targeted system would need to be turned on, and the exploit would require the software to interpret commands without a user noticing—an unlikely scenario as the affected system would perform user interface operations and produce audible feedback (as speakers would need to be active). Moreover, mitigating factors would include dictation clarity, and microphone feedback and placement. An exploit of this nature would also not be able to perform <b>privileged</b> <b>operations</b> for users or protected administrators without explicit user consent because of User Account Control.|$|E
50|$|A virtual private {{database}} or VPD masks data in {{a larger}} database so that only {{a subset of the}} data appear to exist, without actually segregating data into different tables, schemas, databases. A typical application is constraining sites, departments, individuals, etc. to operate only on their own records {{and at the same time}} allowing more <b>privileged</b> users and <b>operations</b> (e.g. reports, data warehousing, etc.) to access on the whole table.|$|R
40|$|Many {{software}} security solutions—including malware analyzers, information flow tracking systems, auditing utilities, and host-based intrusion detectors—rely on knowledge of standard system call interfaces to reason about process execution behavior. In this work, we first obfuscate the Windows and Linux system call interfaces to degrade {{the effectiveness of}} these tools. Our attack, called Illusion, invokes <b>privileged</b> kernel <b>operations</b> in the kernel at the request of user-level processes without requiring those processes to call the actual system calls corresponding to the operations. The Illusion interface hides system operations from user-, kernel-, and hypervisor-level monitors mediating the conventional system-call interface. Illusion alters neither static kernel code nor read-only dispatch tables, remaining elusive from tools protecting kernel memory. We then consider the problem of Illusion attacks and augment system call data with kernel-level execution information to expose the hidden kernel operations. We present a Xen-based monitoring system, Sherlock, that adds kernel execution watchpoints to the stream of system call events. Sherlock automatically adapts its sensitivity based on security requirements to remain performant on desktop systems. ...|$|R
40|$|An {{approach}} for a preprocessing system for telemetry data processing was developed. The {{philosophy of the}} approach {{is the development of}} a preprocessing system to interface with the main processor and relieve it of the burden of stripping information from a telemetry data stream. To accomplish this task, a telemetry preprocessing language was developed. Also, a hardware device for implementing the operation of this language was designed using a cellular logic module concept. In the development of the hardware device and the cellular logic module, a distributed form of control was implemented. This is accomplished by a technique of one-to-one intermodule communications and a set of <b>privileged</b> communication <b>operations.</b> By transferring this control state from module to module, the control function is dispersed through the system. A compiler for translating the preprocessing language statements into an operations table for the hardware device was also developed. Finally, to complete the system design and verify it, a simulator for the collular logic module was written using the APL/ 360 system...|$|R
5000|$|Impersonation token: Impersonation is a {{security}} concept implemented in Windows NT {{that allows a}} server application to temporarily [...] "be" [...] the client in terms of access to secure objects. Impersonation has four possible levels: anonymous, giving the server the access of an anonymous/unidentified user, identification, letting the server inspect the client's identity but not use that identity to access objects, impersonation, letting the server act {{on behalf of the}} client, and delegation, same as impersonation but extended to remote systems to which the server connects (through the preservation of credentials). The client can choose the maximum impersonation level (if any) available to the server as a connection parameter. Delegation and impersonation are <b>privileged</b> <b>operations</b> (impersonation initially was not, but historical carelessness in the implementation of client APIs failing to restrict the default level to [...] "identification", letting an unprivileged server impersonate an unwilling privileged client, called for it). Impersonation tokens can only be associated to threads, and they represent a client process's security subject. Impersonation tokens are usually created and associated to the current thread implicitly, by IPC mechanisms such as DCE RPC, DDE and named pipes.|$|E
50|$|Working of {{hardware-based}} security: A {{hardware device}} allows a user to log in, log out and set different privilege levels by doing manual actions. The device uses biometric technology to prevent malicious users from logging in, logging out, and changing privilege levels. The {{current state of}} a user of the device is read by controllers in peripheral devices such as hard disks. Illegal access by a malicious user or a malicious program is interrupted based on {{the current state of}} a user by hard disk and DVD controllers making illegal access to data impossible. Hardware-based access control is more secure than protection provided by the operating systems as operating systems are vulnerable to malicious attacks by viruses and hackers. The data on hard disks can be corrupted after a malicious access is obtained. With hardware-based protection, software cannot manipulate the user privilege levels. It is impossible for a hacker or a malicious program to gain access to secure data protected by hardware or perform unauthorized <b>privileged</b> <b>operations.</b> This assumption is broken only if the hardware itself is malicious or contains a backdoor. The hardware protects the operating system image and file system privileges from being tampered. Therefore, a completely secure system can be created using a combination of hardware-based security and secure system administration policies.|$|E
40|$|Virtualised {{systems have}} {{experienced}} a resurgence in popularity in recent years, particularly in supporting {{a large number of}} independent services on a single host. This paper describes our work designing and implementing Proper, a service running on the PlanetLab system, that allows other services to perform <b>privileged</b> <b>operations</b> in a safe, controlled manner. We describe how implementing such a system in a traditional UNIX environment is non-trivial, and discuss the practical use of Proper. ...|$|E
40|$|Abstract — Future many-core {{platforms}} present scalability {{challenges to}} VMMs, including {{the need to}} efficiently utilize their processor and cache resources. Focusing on platform virtualization, we address these challenges by devising new virtualization methods that not only work with, but actually exploit the many-core nature of future processors. Specifically, we utilize the fact that cores will differ {{with respect to their}} current internal processor and memory states. The hypervisor, or VMM, then leverages these differences to substantially improve VMM performance and better utilize these cores. The key idea underlying this work is simple: to carry out some <b>privileged</b> VMM <b>operation,</b> rather than forcing a core to undergo an expensive internal state change via traps, such as VMexit in Intel’s VT architecture, why not have the operation carried out by a remote core that is already in the appropriate state? Termed the sidecore approach to running VMM-level functionality, {{it can be used to}} run VMM services more efficiently on remote cores that are already in VMM state. This paper demonstrates the viability and utility of the sidecore approach for two VMM-level classes of functionality: (1) efficient VM-VMM communication in VT-enabled processors and (2) interrupt virtualization for selfvirtualized devices...|$|R
40|$|Abstract. Many {{software}} security solutions—including malware analyzers, information flow tracking systems, auditing utilities, and hostbased intrusion detectors—rely on knowledge of standard system call interfaces to reason about process execution behavior. In this work, we show how a rootkit can obfuscate a commodity kernel’s system call interfaces to degrade {{the effectiveness of}} these tools. Our attack, called Illusion, allows user-level malware to invoke <b>privileged</b> kernel <b>operations</b> without requiring the malware to call the actual system calls corresponding to the operations. The Illusion interface hides system operations from user-, kernel-, and hypervisor-level monitors mediating the conventional system-call interface. Illusion alters neither static kernel code nor readonly dispatch tables, remaining elusive from tools protecting kernel memory. We then consider the problem of Illusion attacks and augment system call data with kernel-level execution information to expose the hidden kernel operations. We present a Xen-based monitoring system, Sherlock, that adds kernel execution watchpoints to the stream of system calls. Sherlock automatically adapts its sensitivity based on security requirements to remain performant on desktop systems: in normal execution, it adds 1 % to 10 % overhead to a variety of workloads. ...|$|R
30|$|Nevertheless, each cloud {{security}} technique {{represents an}} integral building {{block in the}} multilayered defense of the cloud. Malware detection and prevention systems are the initial line of defense in preventing an attacker from gaining a foothold on a cloud. The secure hypervisors present a hardened code base that restricts access to hardware to all, but the most <b>privileged</b> <b>operations.</b> Lastly, cloud resilient solutions are present {{to protect against the}} unknown exploits, which may allow an attacker to operate on a cloud indefinitely.|$|E
40|$|Modern {{enterprise}} {{systems support}} Role-Based Access Con-trol (RBAC). Although RBAC allows restricting access to <b>privileged</b> <b>operations,</b> a deployer may actually intend to re-strict access to privileged data. This paper presents a theo-retical foundation for correlating an operation-based RBAC policy with a data-based RBAC policy. Relying on a location-consistency property, this paper shows how to infer whether an operation-based RBAC policy {{is equivalent to}} any data-based RBAC policy. We have built a static analysis tool for Java Platform, Enterprise Edition (Java EE) called Stati...|$|E
40|$|We present Vsys, a {{mechanism}} for restricting access to <b>privileged</b> <b>operations,</b> much like the popular sudo tool on UNIX. Unlike sudo, Vsys allows privileges to be constrained using general-purpose programming languages and facilitates composing multiple system services into powerful abstractions for isolation. In use for over three years on PlanetLab, Vsys has enabled over 100 researchers to create private overlay networks, userlevel file systems, virtual switches, and TCP-variants that function safely and without interference. Vsys has also been used by applications such as whole-system monitoring in a VM. We describe the design of Vsys and discuss our experiences and lessons learned. ...|$|E
40|$|SSU†, ‘‘Secure su,’ ’ is a {{mechanism}} that uses SSH [Ylonen] {{to provide the}} security for distributing access to <b>privileged</b> <b>operations.</b> Its features include both shell or per-command access, a password for each user that is distinct from the login password and easily changed, and high portability. By installing SSU, administrators build a solid infrastructure for using SSH for improving security in other areas, such as file distribution and revision control. Introduction and Site Information The EECS research computing environment at Harvard University is comprised of approximately two hundred workstations running eight variations of Unix. Users are primarily faculty, graduate student...|$|E
3000|$|... wu-ftpd. The FTP server wu-ftpd is {{vulnerable}} to CVE- 2000 - 0573 (CVE 2000) which escalates the privilege of a wu-ftpd server daemon running in non-root into root user. The CVE introduces a format string error which empowers a remote attacker to corrupt arbitrary memory data in the address space. As Listing 3 indicates, the wu-ftpd process saves the current non-root user uid in a record named pw →pw_uid. Then it acquires an escalated privilege which is required by setsockopt. Normally, when it completes the <b>privileged</b> <b>operations,</b> the process will drop the privilege as indicated in Line 15, which restores the uid saved in pw →pw_uid.|$|E
30|$|Table 4 are {{the results}} of Unixbench, which show a huge {{difference}} between the time to accomplish the task. Dhyrstone and Whetstone are {{used to test the}} integer and floating point operations, which are close to the clean state. However, the performance of I/O intensive operations including File Copying and Pipe Throughput, and <b>privileged</b> <b>operations</b> including Execl, Process Creation, Shell Scripts and System Call all degrades sharply compared with the clean state. The overall scores of unixbench declines sharply, which indicates a real-time monitoring might slow down the legal program running on VMs. Although we might cheat the VM by modifying the showing time, users’ experience will uncover the existence of monitoring. This is indeed a limitation as a tradeoff between the usability and security, but we will improve it with new hardware support such as #VE and VMFUNC, which will be discussed in further works.|$|E
40|$|Abstract. We {{claim that}} attacks can evade the {{comprehension}} of security tools {{that rely on}} knowledge of standard system call interfaces to reason about process execution behavior. Our attack, called Illusion, will invoke <b>privileged</b> <b>operations</b> in a Windows or Linux kernel {{at the request of}} user-level processes without requiring those processes to call the actual system calls corresponding to the operations. The Illusion interface will hide system operations from user-, kernel-, and hypervisor-level monitors mediating the conventional system-call interface. Illusion will alter neither static kernel code nor read-only dispatch tables, remaining elusive from tools protecting kernel memory. 1 Illusion Attack Honeypots and other utilities designed to audit, understand, classify, and detect malware and software attacks often monitor process ’ behavior at the system call interface as part of their approach. Past research has developed a widespread collection of system-call based systems operating at user or kernel level [1, 5, 2, 4...|$|E
