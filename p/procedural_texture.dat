57|147|Public
50|$|Besides these {{specialized}} programs, many others, such as Blender, contain <b>procedural</b> <b>texture</b> subsystems and so {{can also}} be used to generate these textures.|$|E
5000|$|A [...] is {{an image}} applied (mapped) {{to the surface of}} a shape or polygon. This may be a bitmap image or a <b>procedural</b> <b>texture.</b> They may be stored in common image file formats, {{referenced}} by 3d model formats or material definitions, and assembled into resource bundles.|$|E
5000|$|In {{computer}} graphics, a <b>procedural</b> <b>texture</b> is a texture created using {{a mathematical}} description (i.e. an algorithm) rather than directly stored data. The {{advantage of this}} approach is low storage cost, unlimited texture resolution and easy Texture mapping. [...] These kind of textures are often used to model surface or volumetric representations of natural elements such as wood, marble, granite, metal, stone, and others.|$|E
40|$|Image textures {{can easily}} be created using texture {{synthesis}} by example. However, creating <b>procedural</b> <b>textures</b> is much more difficult. This is unfortunate, since <b>procedural</b> <b>textures</b> have significant advantages over image textures. In this paper we {{address the problem of}} texture synthesis by example for <b>procedural</b> <b>textures.</b> We introduce a method for procedural multiresolution noise by example. Our method computes the weights of a procedural multiresolution noise, a simple but common class of <b>procedural</b> <b>textures,</b> from an example. We illustrate this method by using it as a key component in a method for texture synthesis by example for isotropic stochastic <b>procedural</b> <b>textures.</b> Our method significantly facilitates the creation of these <b>procedural</b> <b>textures.</b> status: publishe...|$|R
40|$|<b>Procedural</b> <b>textures</b> can be {{effectively}} {{used to enhance}} the visual realism of computer rendered images. <b>Procedural</b> <b>textures</b> can provide higher realism for 3 -D objects than traditional hardware texture mapping methods which use memory to store 2 -D texture images. This paper proposes a new method of hardware texture mapping in which texture images are synthesized using FPGAs. This method is very efficient for <b>texture</b> mapping <b>procedural</b> <b>textures</b> {{of more than two}} input variables. By synthesizing these textures on the fly, the large amount of memory required to store their multidimensional texture images is eliminated, making texture mapping of 3 -D textures and parameterized textures feasible in hardware. This paper shows that using FPGAs, <b>procedural</b> <b>textures</b> can be synthesized at high speed, with a small hardware cost. Data on the performance and the hardware cost of synthesizing <b>procedural</b> <b>textures</b> in FPGAs are presented. This paper also presents, the FPGA implementations of two Perlin noise based 3 -D <b>procedural</b> <b>textures.</b> ...|$|R
40|$|Gradient noise {{can be used}} {{to create}} {{non-regular}} patterns for <b>procedural</b> <b>textures</b> but, because it is derived from uniform-random distributed sources, trial and error is needed to achieve an acceptable appearance. We extract patterns from existing objects as non-uniform hierarchical noise functions, which we can then apply to synthesize new <b>procedural</b> <b>textures,</b> with similar characteristics. Users can control the randomness at specified frequencies by varying the parameters of the noise function, while preserving the features of the pattern. The extracted noise function {{can be used to}} generate a number of <b>procedural</b> <b>textures</b> sharing the similar non-regular patterns with the original object...|$|R
50|$|Value {{noise is}} a type of noise {{commonly}} used as a <b>procedural</b> <b>texture</b> primitive in computer graphics. It is conceptually different from, and often confused with gradient noise, examples of which are Perlin noise and Simplex noise. This method consists of the creation of a lattice of points which are assigned random values. The noise function then returns the interpolated number based on the values of the surrounding lattice points.|$|E
50|$|Gradient {{noise is}} a type of noise {{commonly}} used as a <b>procedural</b> <b>texture</b> primitive in computer graphics. It is conceptually different, and often confused with value noise. This method consists of a creation of a lattice of random (or typically pseudorandom) gradients, dot products of which are then interpolated to obtain values in between the lattices. An artifact of some implementations of this noise is that the returned value at the lattice points is 0. Unlike the value noise, gradient noise has more energy in the high frequencies.|$|E
50|$|Cellular {{texturing}} {{differs from}} the majority of other <b>procedural</b> <b>texture</b> generating techniques as it {{does not depend on}} noise functions as its basis, although it is often used to complement the technique. Cellular textures are based on feature points which are scattered over a three-dimensional space. These points are then used to split up the space into small, randomly tiled regions called cells. These cells often look like “lizard scales,” “pebbles,” or “flagstones”. Even though these regions are discrete, the cellular basis function itself is continuous and can be evaluated anywhere in space.|$|E
5000|$|... #Subtitle level 2: Some {{programs}} for creating <b>textures</b> using <b>procedural</b> <b>texturing</b> ...|$|R
5000|$|... surface {{patterns}} such as wrinkles, bumps, and ripples, {{for use in}} <b>procedural</b> <b>textures</b> and {{bump mapping}} ...|$|R
40|$|Genetic {{programming}} {{is used to}} automatically synthesize <b>procedural</b> <b>textures</b> for 3 D surfaces. The GP system evolves textures with similar colour and surface characteristics as training textures sampled on 3 D models. The texture language includes mathematical operators, colour and noise functions, as well as surface information for the point being rendered, such as coordinates, normal, and gradient. Experiments successfully generated <b>procedural</b> <b>textures</b> that displayed visual characteristics similar to target textures...|$|R
50|$|Perlin {{noise is}} a <b>procedural</b> <b>texture</b> primitive, {{a type of}} {{gradient}} noise used by visual effects artists to increase the appearance of realism in computer graphics. The function has a pseudo-random appearance, yet all of its visual details are the same size. This property allows it to be readily controllable; multiple scaled copies of Perlin noise can be inserted into mathematical expressions to create {{a great variety of}} procedural textures. Synthetic textures using Perlin noise are often used in CGI to make computer-generated visual elements - such as object surfaces, fire, smoke, or clouds - appear more natural, by imitating the controlled random appearance of textures in nature.|$|E
40|$|In this thesis, {{we present}} an {{approach}} to finding a procedural representation of a texture to replicate a given texture image which we call image-based <b>procedural</b> <b>texture</b> matching. Procedural representations are frequently used for many aspects of computer generated imagery, however, {{the ability to use}} procedural textures is limited by the difficulty inherent in finding a suitable procedural representation to match a desired texture. More importantly, the process of determining an appropriate set of parameters necessary to approximate the sample texture is a difficult task for a graphic artist. The textural characteristics of many real world objects change over time, so we are therefore interested in how textured objects in a graphical animation could also be made to change automatically. We would like this automatic texture transformation to be based on different texture samples in a time-dependant manner. This notion, which is a natural extension of <b>procedural</b> <b>texture</b> matching, involves the creation of a smoothly varying sequence of texture images, while allowing the graphic artist to control various characteristics of the texture sequence. Given a library of procedural textures, our approach uses a perceptually motivated texture similarity measure to identify which procedural textures in the library may produce a suitable match. Our work assumes that at least one <b>procedural</b> <b>texture</b> in the library is capable of approximating the desired texture. Because exhaustive search of all of the parameter combinations for each <b>procedural</b> <b>texture</b> is not computationally feasible, we perform a two-stage search on the candidate procedural textures. First, a global search is performed over pre-computed samples from the given <b>procedural</b> <b>texture</b> to locate promising parameter settings. Secondly, these parameter settings are optimised using a local search method to refine the match to the desired texture. The characteristics of a <b>procedural</b> <b>texture</b> generally do not vary uniformly for uniform parameter changes. That is, in some areas of the parameter domain of a <b>procedural</b> <b>texture</b> (the set of all valid parameter settings for the given <b>procedural</b> <b>texture)</b> small changes may produce large variations in the resulting texture, while in other areas the same changes may produce no variation at all. In this thesis, we present an adaptive random sampling algorithm which captures the texture range (the set of all images a <b>procedural</b> <b>texture</b> can produce) of a <b>procedural</b> <b>texture</b> by maintaining a sampling density which is consistent with the amount of change occurring in that region of the parameter domain. Texture transformations may not always be contained to a single <b>procedural</b> <b>texture,</b> and we therefore describe {{an approach to}} finding transitional points from one <b>procedural</b> <b>texture</b> to another. We present an algorithm for finding a path through the texture space formed from combining the texture range of the relevant procedural textures and their transitional points. Several examples of image-based texture matching, and texture transformations are shown. Finally, potential limitations of this work as well as future directions are discussed...|$|E
40|$|This work {{deals with}} <b>procedural</b> <b>texture</b> {{generation}} using programmable graphics pipeline in OpenGL. It describes basics of OpenGL operation and programmable shading. The main contribution is {{the analysis of}} methods used for generating procedural textures using various algorithms and noise functions, with focus on Perlin noise. The examples of <b>procedural</b> <b>texture</b> shaders are demonstrated by a C++ application, displaying 3 D model of Božetěchova building...|$|E
5000|$|Extensions API {{that allow}} third party {{developers}} {{to develop their own}} procedural geometries, geometry modifiers, <b>procedural</b> <b>textures,</b> camera lens, etc.|$|R
40|$|With {{the advent}} of image based {{modeling}} techniques, it becomes easier to apply textures extracted from reality onto virtual worlds. Many repetitive patterns (structural textures) in human constructions can be parametrized with <b>procedural</b> <b>textures.</b> These textures offer a powerful alternative to traditional color textures, but they require the artist to program the desired effects. We present a system to automatically extract from photographs values for parameters of structural textures, giving the user the possibility to guide the algorithms. Two common classes of <b>procedural</b> <b>textures</b> are studied : rectangular tilings and wood. The results demonstrate that synthesizing textures similar to their real counterpart can be very interesting for computer-augmented reality applications...|$|R
40|$|We {{describe}} a software {{system on the}} Pixel-Planes 5 graphics engine that displays user-defined antialiased <b>procedural</b> <b>textures</b> at rates of about 30 frames per second for use in realtime graphics applications. Our system allows a user to create textures that can modulate both diffuse and specular color, the sharpness of specular highlights, the amount of transparency and the surface normals of an object. We {{describe a}} texture editor that allows a user to interactively create and edit <b>procedural</b> <b>textures.</b> Antialiasing is essential for real-time textures, and {{in this paper we}} present some techniques for antialiasing <b>procedural</b> <b>textures.</b> Another direction we are exploring is the use of dynamic textures, which are functions of time or orientation. Examples of textures we have generated include a translucent fire texture that waves and flickers and an animated water texture that shows the use of both environment mapping and normal perturbation (bump mapping) ...|$|R
40|$|Figure 1 : Left: Two textures {{produced}} by a same <b>procedural</b> <b>texture</b> with sliders controlling their appearances. Middle: Sixteen random thumbnails cropped in the <b>procedural</b> <b>texture.</b> Right: Our <b>procedural</b> <b>texture</b> preview summarizes in a single image the possible appearances. A 5122, 2562 and 1282 previews are shown. Procedural textures usually require spending time testing parameters to realize the diversity of appearances. This paper introduces {{the idea of a}} <b>procedural</b> <b>texture</b> preview: A single static image summarizing in a limited pixel space the appearances {{produced by}} a given procedure. Unlike grids of thumbnails our previews present a continuous image of appearances, analog to a map. The main challenge is to ensure that most appearances are visible, are allocated a similar pixel area, and are ordered in a smooth manner throughout the preview. To reach this goal, we introduce a new layout algorithm accounting simultaneously for these criteria. After computing a layout of appearances, we rely on by–example texture synthesis to produce the final preview. We demonstrate our approach on a database of production–level procedural textures...|$|E
40|$|The e#ects of {{the texture}} {{coordinate}} precision {{to the image}} for <b>procedural</b> <b>texture</b> mapping is presented. In our project, {{we are trying to}} implement procedural solid texture mapping by hardware. By reducing the number of parameters for our texture mapping model and precision of texture coordinate, we can implement <b>procedural</b> <b>texture</b> mapping with small number of gates. We checked that how many bits were required to produce the image without degrading original by simulation and confirmed that we could have good textured image even with small number of bit width...|$|E
40|$|In {{this paper}} we {{describe}} {{an approach to}} the automated specification of procedural textures {{to be used in}} rendering, based on representative samples. Procedural textures exhibit many advantages over traditional surface texturing techniques, but unfortunately finding the correct <b>procedural</b> <b>texture</b> and appropriate parameters to create the desired texture can be a daunting task for even the most experienced computer graphics artists. The method we propose here, which we refer to as image-based procedural texturing, allows the specification of the desired texture {{in the form of a}} digital input image. From this sample texture, a corresponding <b>procedural</b> <b>texture</b> is found which produces a texture which is perceptually similar to the input sample...|$|E
40|$|This work {{deals with}} Perlin noise {{function}} in {{theoretical and practical}} way. <b>Procedural</b> <b>textures</b> can be generated by Perlin noise function. Perlin´s algorithm has many advantages, for example natural appearance, smaller demands on memory capacity and possibility of simple application on cubic objects. It is for these reasons that this technique is widely used nowadays in many varieties and improvements. We can meet these kind of textures mainly in computer games or animated movies. It is possible to create <b>procedural</b> <b>textures</b> by Perlin noise function so that they look like marble, wood or grass. Examples of these textures are generated by a program {{which is in the}} practical part of this work. The program was designed for simple presentation of <b>procedural</b> <b>textures</b> made by Perlin noise. Program can be operated via user interface, where the user can change some parameters which affect the look of the texture. The program can be used for presentation of Perlin noise to students...|$|R
40|$|This report {{discusses}} {{the application of}} <b>procedural</b> modeling and <b>texturing</b> techniques for creating animations of plant growth. In particular, we examine how tDOL-Systems {{can be used to}} simulate changes in plant geometry and topology over time. <b>Procedural</b> <b>textures</b> are used to enhance the appearance and believability of plants and are based o...|$|R
50|$|<b>Procedural</b> <b>textures</b> are {{a related}} {{technique}} which may synthesise textures from scratch with no source material. By contrast, texture synthesis refers to techniques where some source image is being matched or extended.|$|R
40|$|Procedural {{textures and}} image textures are commonplace in {{graphics}} today, finding uses {{in such places}} as animated movies and video games. Unlike image texture maps, procedural textures typically suffer from minification aliasing. I present a method that, given a <b>procedural</b> <b>texture</b> on a surface, automatically creates an anti-aliased version of the <b>procedural</b> <b>texture.</b> The new <b>procedural</b> <b>texture</b> maintains the original textures details, but reduces minification aliasing artifacts. This new algorithm creates an image pyramid similar to MIP-Maps to represent the texture. Whereas a MIP-Map stores per-texel color, however, my texture hierarchy stores weighted sums of reflectance functions, allowing a wider-range of effects to be anti-aliased. The stored reflectance functions are automatically selected based on {{an analysis of the}} different functions found over the surface. When the texture is viewed at close range, the original texture is used, but as the texture footprint grows, the algorithm gradually replaces the textures result with an anti-aliased one. This results in faster development time for writing procedural textures as well as higher visual fidelity and faster rendering. With the optional addition of authoring guidelines, the analysis phase can be sped up by as much as two orders of magnitude. Furthermore, I developed a method for handling pre-filtered integration of reflectance functions to anti-alias specular highlights. The normal-centric BRDF (NBRDF) allows for fast evaluation over a range of normals appearing on the surface of an object. The NBRDF is easy to implement on the GPU for real-time results and can be combined with procedural reduction maps for real-time <b>procedural</b> <b>texture</b> minification anti-aliasing. Ph. D. Committee Chair: Greg Turk; Committee Member: Blair MacIntyre; Committee Member: Irfan Essa; Committee Member: Jarek Rossigna...|$|E
40|$|Two {{deficiencies}} in the original Noise algorithm are corrected: second order interpolation discontinuity and unoptimal gradient computation. With these defects corrected, Noise both looks better and runs faster. The latter change also {{makes it easier to}} define a uniform mathematical reference standard. Keywords <b>procedural</b> <b>texture...</b>|$|E
40|$|This bachelor's thesis {{describes}} {{issues of}} making graphics intro with limited size below 64 kB. It contains short introduction to OpenGL, analyses techniques and procedures to reach required small sized application, from compiler settings, <b>procedural</b> <b>texture</b> and model generation to final compression by exe packer application...|$|E
50|$|This {{algorithm}} {{can be used}} {{to generate}} realistic-looking landscapes, and different implementations are used in computer graphics software such as Terragen. It is also applicable as a common component in <b>procedural</b> <b>textures.</b>|$|R
50|$|In 1997, he won an Academy Award for Technical Achievement {{from the}} Academy of Motion Picture Arts and Sciences for his noise and {{turbulence}} <b>procedural</b> <b>texturing</b> techniques, which {{are widely used}} in feature films and television.|$|R
40|$|This thesis {{explores the}} {{possibility}} of exchanging regular <b>textures</b> with <b>procedural</b> <b>textures.</b> It focuses on classic <b>procedural</b> <b>textures</b> like different types of rock and sand. Most time is spent on implicit textures generation on a GPU, this means a limit to the types of algorithms that can be used. As such, {{much of the work}} focuses on noise implementations. The goal is to lower texture memory usage by changing regular sampled <b>textures</b> with <b>procedural</b> ones. In the end a few ways of creating textures with a satisfactory level of detail is suggested using a blend of regular <b>textures</b> and <b>procedural</b> ones. Validerat; 20101217 (root...|$|R
40|$|Ministry of Education of PR China; Hong Kong University of Science and Technology; University of Electronic Science and Technology of China; City University of Hong Kong; IEEEFPGA {{technology}} {{provides a}} fast prototyping way to implement various algorithms on its reconfigurable hardware platform. It can flexibly handle with different applications. In this paper, <b>procedural</b> <b>texture</b> mapping based on Perlin noise function is imple...|$|E
40|$|Procedural {{cellular}} textures {{have been}} widely used in movie production to reproduce various natural and organic looks. The advantage of <b>procedural</b> <b>texture</b> is to trade memory for computer power and obtain potentially unlimited resolution. In this paper, we propose to compute non-uniform density cellular noise by using a procedural quad-tree. We will explain how to efficiently traverse the tree recursively (CPU) and iteratively (CPU and GPU) ...|$|E
40|$|We {{present a}} {{technique}} for creating procedurally {{the texture of}} the twists of thread. The procedure is designed to support variations in appearance due to tightness of twist, thickness of the bundles twisted together and the roughness of the bers. The <b>procedural</b> <b>texture</b> of the twist is further shaded to give it the appearance of a typical facet of thread that is visible on woven clothes. We demonstrate the utility of the texture by applying it to synthesize texture of woven textiles. ...|$|E
40|$|Many {{computer}} graphics applications have used procedural noise since the 1980 s, {{but there are}} still very few tools which allow non programming-oriented users to make <b>procedural</b> <b>textures.</b> This paper attempts to provide a framework for building and creating <b>procedural</b> noise based <b>textures,</b> in a way that can be easily abstracted and understood by those users. A careful study is conducted of Perlin Noise, and similar interfaces and tools are examined {{in order to create a}} framework centered around composable parts and semantic abstractions. The framework is then used to build a proof-of-concept interface which exemplifies some of the conclusions drawn from the study. The proof-of-concept interface successfully creates an environment which can be used to create <b>procedural</b> <b>textures,</b> and serves as a guide for future interfaces in the field...|$|R
50|$|Mapping Maestro - {{rendering}} algorithms for embedded graphics systems {{based on}} the texture mapping (specifically bump mapping, cube mapping, multitexturing etc.) and <b>procedural</b> <b>texturing</b> reduce contents size and memory bandwidth requirements an by that improves overall application performance.|$|R
50|$|A notable {{example of}} {{third-party}} node development is Denis Pontonnier's Additional Nodes. These free nodes enable modifying images, renders, <b>procedural</b> <b>textures,</b> Hypervoxels, object motions, animation channels, and volumetric lights. Also they enable particles and other meshes to drive node parameters.|$|R
