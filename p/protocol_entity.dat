22|137|Public
40|$|This thesis {{summarizes}} {{the work of}} the author as a master/doctor student of Osaka University on the implementation of service specifications on distributed computing systems. In a distributed computing system, multiple computers, called protocol entities, communicate with each other, exchanging messages for synchronization and data transfer. On the implementation phase of such a distributed system, the behavior of all the protocol entities must be specified. The specification of each <b>protocol</b> <b>entity</b> is called a <b>protocol</b> <b>entity</b> specification and the set of all the <b>protocol</b> <b>entity</b> specifications is called a protocol specification. In general, the control flow of each <b>protocol</b> <b>entity</b> specification may become complicated, since it contains communications among other protocol entities for cooperative computing. Therefore, it is hard for designers to describe a protocol specification directly without mistake. In the recent years, for designing reliable distributed computing systems, many approaches [...] ...|$|E
40|$|In general, the {{services}} of a distributed system are provided by some cooperative protocol entities. The protocol entities must exchange some data values and synchronization messages in order to ensure the temporal ordering of the events which are described in a service specification of the distributed system. It is desirable that a correct <b>protocol</b> <b>entity</b> specification for each node can be derived automatically from a given service specification. In this paper, we propose an algorithm which synthesizes a correct <b>protocol</b> <b>entity</b> specification automatically from a service specification in a Petri Net model with Registers called PNR model. In our model, parallel events and selective operations can be described naturally. The control flow of a service specification must be described as a free-choice net in order to simplify the derivation algorithm, however, many practical systems can be described in this class. In our approach, since each <b>protocol</b> <b>entity</b> specification is also described i [...] ...|$|E
30|$|Upon {{reception}} {{from the}} upper layer, a <b>protocol</b> <b>entity</b> adds its signaling information {{in front of the}} first byte of the received SDU, increases the pduBytes member by an amount equal {{to the size of the}} added signaling header, and transfers it to the lower layer. Upon reception from the lower layer, a <b>protocol</b> <b>entity</b> reads the header inserted by its homologous entity on the source, decreases the pduBytes member by an amount equal to the size of this signaling header, and transfers it to the upper layer. In this scheme, there is no longer one specific class derived of cMessage for each protocol layer, but only one generic BytesMsg class. The information usually contained in the data members of the classes derived from cMessage is contained in the properly encoded protocol headers.|$|E
50|$|Simple Gateway Monitoring Protocol (SGMP) {{defined in}} RFC 1028, allows {{commands}} {{to be issued}} to application <b>protocol</b> <b>entities</b> to set or retrieve values (integer or octet string types) for use in monitoring the gateways on which the application <b>protocol</b> <b>entities</b> reside. Messages are exchanged using UDP and utilize unreliable transport methods. Authentication takes place on UDP port 153. Some examples of {{things that can be}} monitored are listed below.|$|R
40|$|Typically {{a real-life}} {{protocol}} specification {{is composed of}} two or more <b>protocol</b> <b>entities</b> communicating with each other by exchanging messages through service access points (SAPs). These <b>protocol</b> <b>entities</b> can be created and released dynamically, and their connections can change over time. These dynamic behaviours {{have been one of the}} serious problems for protocol designers to model and analyze. Petri nets and high-level Petri nets have been used commonly and widely in protocol specification and verification. Traditionally protocol designers use a place in Petri nets to represent a state of a protocol. By following this tradition, it is impossible to model the dynamic configuration of communication protocols. To overcome this problem, tokens in Numerical Petri Nets (NPNs) are used to model states and also to model <b>protocol</b> <b>entities</b> and their connections. A sliding-window protocol is used to illustrate this approach...|$|R
3000|$|... local components, {{which are}} the <b>protocol</b> <b>entities</b> within the network node. Each such node may be a base station, a mobile station, or even a data server.|$|R
40|$|Syntax Notation 1 (ASN. 1) modules which specify syntax of {{management}} information. 2. 2 Existing Conformance Test Method for <b>Protocol</b> <b>Entity</b> The existing conformance test method for <b>protocol</b> <b>entity</b> [5] examines {{whether or not}} an implementation by vendors, so called an Implementation Under Test (IUT), conforms to the relevant protocol specification. To conduct the conformance test, a test system and an IUT are connected locally or remotely. A set of test items is developed from the protocol specification and the Protocol Implementation Conformance Statement (PICS) which gives information about implemented capabilities of the IUT. The test items are classified into three; basic interconnection tests, capability tests and behaviour tests, with the different test objective. Basic interconnection tests verify the basic capability of interconnection. Capability tests and behaviour tests verify the static and the dynamic conformance respectively. There {{are two kinds of}} test components: the Lo [...] ...|$|E
40|$|The Damocles {{project at}} the University of Twente is {{developing}} a prototyping vehicle for new SNMP versions. The motivation for such a vehicle {{stems from the fact}} that the IETF will develop new versions of SNMP in response to evolving user needs (version 2 is currently underway). Whereas the transition to newer versions is attractive from a functional and/or performance point of view, the effort and cost involved in such a transition should not be underestimated. The Damocles project investigates how modular design and implementation, and the application of object oriented techniques, facilitate modification and reduce the effort and cost of version transition. In this paper, we discuss a part of the Damocles prototyping vehicle: an SNMP agent <b>protocol</b> <b>entity</b> written in object oriented Perl. We discuss the design and implementation of the <b>protocol</b> <b>entity,</b> and how this development effort contributes to the objectives of the Damocles project. Keywords: SNMP, SNMPv 2, agent technology, prot [...] ...|$|E
40|$|In general, the {{services}} of a distributed system are provided by some cooperative protocol entities. The protocol entities must exchange some data values and synchronization messages in order to ensure the temporal ordering of the events which are described in a service specification of the distributed system. It is desirable that a correct <b>protocol</b> <b>entity</b> specification for each node can be derived automatically from a given service specification. In this pape...|$|E
40|$|REX is a {{protocol}} supporting a client/server style {{of interaction between}} a number of entities in a distributed system. Within this interaction paradigm, client entities may request services supplied by server entities, by interacting with intermediate <b>protocol</b> <b>entities.</b> This paper presents a Z specification of part of the REX protocol...|$|R
40|$|Previous papers {{describe}} an algorithm for deriving a specification of <b>protocol</b> <b>entities</b> from a given service specification. A service specification defines a particular ordering for {{the execution of}} service primitives at the different service access points using operators for sequential, parallel and alternative executions. The derived <b>protocol</b> <b>entities</b> ensure the correct ordering by exchanging appropriate synchronization messages, between one another through the underlying communication medium. This paper presents several new results which represent important improvements to the above protocol derivation approach. First the language restriction to finite behaviors is removed by allowing for the definition of procedures which can be called recursively. Secondly, a new derivation algorithm has been developed which is much simpler than the previous one. Third, the resulting protocol specifications are much more optimized than those obtained previously. * Christian Kant is with the UniversitC de Moncton, 1...|$|R
40|$|The {{complexity}} and efficiency {{aspects of a}} distributed application protocol (e. g., replicated data access, decentralized commit) are often intertwined with the application-specific communication requirements between <b>protocol</b> <b>entities</b> and the underlying support for communication. For example, the choice between recovery by application from a mis-ordered message delivery versus providing message ordering property in the communication layer (CL) is based on tradeoffs between protocol {{complexity and}} efficiency. The paper systematically analyzes these tradeoffs in a quantitative manner. The analysis is based on message ordering and atomicity, which refer to consistent event ordering at <b>protocol</b> <b>entities.</b> Enforcing these properties in the CL leads to uniform communication structure of applications. However, the CL incurs message and execution time overhead due {{to the need to}} maintain extensive communication state (e. g., message sequencing). When these properties are not supported by CL but a [...] ...|$|R
3000|$|From {{application}} to physical layer, each <b>protocol</b> <b>entity</b> receives data messages from its upper interface and forwards them to its lower interface. In a way {{similar to what}} {{is done in the}} Mobility Framework [3] a software API (Application Programming Interface) has been defined to send and receive information on the data path: sendDown (...) and sendUp (...) are used to send data to the lower and upper layers, and handleLowerMsg (...) and handleUpperMsg (...) are used to receive data from the lower and upper layers.|$|E
40|$|Abstract – A {{methodology}} for {{the synthesis of}} communication protocols based on evolutionary techniques is presented. It enables to automatically generate finite-state models that synthesize protocol specifications from partial input/output sequences. These partial sequences, directly derived from service specifications {{and a set of}} associated protocol data units (PDUs), are the training sequences that drive the evolution of finite-state machines (FSMs), each describing one <b>protocol</b> <b>entity</b> specification. The proposed approach has the advantage of reducing (or even eliminating) computation applicable to finite-state automata (FSA) in existing protocol synthesis methods, abstracting the protocol designer from such tasks. 1...|$|E
40|$|Model-based {{techniques}} for verification and validation require {{a model of}} the systemunder test (SUT). However, most communication systems lack a complete, correctmodel. One approach for generating a model of a system is to infer the model byobserving its external behavior. This approach is useful when the source code of thesystem is not available, e. g., third party components. Regular inference techniques areable to infer a finite state machine model of a system by observing its externalbehavior. In this master thesis we consider the models inferred by regular inferencetechniques of a certain kind of systems: communication protocol entities. Suchentities interact by sending and receiving messages consisting of a message type and anumber of parameters, each of which potentially can take on a large number of values. This may cause a model of a communication <b>protocol</b> <b>entity</b> inferred by regularinference, to be very large. Since regular inference creates a model from the observedbehavior of a communication <b>protocol</b> <b>entity,</b> the model may be very different from adesigner's model of the system's source code. This master thesis presents a novel approach to transform the inferred model ofcommunication protocols to a new formalism in a sense that it is more compact andit has a similar partitioning of an entity's behavior into control states as in a designer'smodel of the protocol. We have applied our approach to an executable specificationof the Mobile Arts Advanced Mobile Location Center (A-MLC) protocol andevaluated the results...|$|E
40|$|Manually synthesizing {{specifications}} for concurrent and distributed communication <b>protocol</b> <b>entities</b> from a service specification, which is modeled in the UML state machine with composite {{states is a}} time consuming and labor-intensive task. To save a time and generate error free {{specifications for}} distributed <b>protocol</b> <b>entities</b> modeled in UML state machines, we introduce a tool, called the UML protocol specification synthesizer (UPSS). The tool automates an existing synthesis method that derives a protocol specification from a service specification, where both specifications are modeled in the UML state machine. The tool, which is developed in Java, extends a well known tool, Eclipse. Using the tool, designers draw the UML state machine of the service specification. The tool stores the drawn diagram in XML format, parses the XML files, applies the synthesis rules to derive the corresponding protocol specification, stores the protocol specification in XML format, and allows for displaying and manipulating the protocol specification using the Eclipse diagram editor...|$|R
40|$|Abstract. An {{evolutionary}} {{approach to}} design communication protocols from scenario-based specifications is presented. It enables to automatically generate finite-state models of <b>protocol</b> <b>entities</b> from Message Sequence Charts. By converting the Message Sequence Charts into input/output sequences, the problem reduces to evolving finite-state machines with the specified input/output behaviors. The proposed approach does not overgeneralize the entity behavior producing, by construction, minimal, deterministic and completely specified finite-state machines. ...|$|R
40|$|ABSTRACT. Communications {{protocols}} re-synthesis {{involves the}} augmentation of existing synthesized <b>protocol</b> <b>entities</b> given a modified formal service definition. This process {{would reduce the}} time required for deploying enhanced and frequently modified services. In this paper, we introduce a re-synthesis technique based on a service-oriented protocol synthesis method introduced earlier [1]. Re-synthesis can be applied in various distributed systems application areas, such as discrete event distributed controllers, communications protocol converters, and distributed software agents...|$|R
40|$|COMSCRIPT {{is a new}} {{programming}} language based on POSTSCRIPT, designed {{for the implementation of}} protocol stacks. COMSCRIPT is a concurrent language providing synchronousand asynchronousinter-process communications based on a hierarchical model. The language allows the implementation of both low level and high level protocol entities. COMSCRIPT also allows a process to configure dynamically its communication needs. Thus COMSCRIPT is a configuration language. This paper describes the first implementation of a COMSCRIPT interpreter with its interfaces provoding access to raw Ethernet, IP datagrams, TCP/IP sockets and ordinary files. Finally we report on the coding of a low level <b>protocol</b> <b>entity</b> (ARP) and an application level FTP-server with COMSCRIPT...|$|E
40|$|There {{have been}} many {{developments}} {{in the field of}} facilitated model based verification and validation techniques. Most of them have been based upon observing the external behaviour of the system. Our approach follows the same and is valid with the source code of the system under observance is not available Inference mechanism allow us to infer such machine models by observing. We present a framework which adopts to generate component with infinite/finite states and adapt to formal verifications. The models used are communication protocol inferred by regular inference observed through the behaviour of communication <b>protocol</b> <b>entity.</b> Also, an approach is presented such that the observed behaviour of the protocol validates to the designed model of the protocol...|$|E
40|$|An {{important}} element estimating a good seamless handover scheme {{is that how}} rapidly and accurately can anticipate the imminent Layer 3 handover. The FMIPv 6 {{may be the best}} scheme for it because the anticipation is made by collaboration with Layer 2. However, the FMIPv 6 has a few issues which should be tackled: various Layer 2 implementations, various moving speeds of nodes and supporting the QoS-related protocols on the Internet. Especially, it seems that it could not always ensure the QoS on the Internet for the highly moving users. In this paper, we propose a pseudo fast handover mode for the QoS-related protocols when nodes are moving fast. For the proposed pseudo fast handover mode, we have modified the fast binding-update and defined a new <b>protocol</b> <b>entity</b> called edge cell...|$|E
40|$|The use of {{the formal}} design method FOCUS is {{illustrated}} by an example development of the so-called Stenning-protocol. The development process starts from global, non-constructive service specifications and ends in executable programs of the <b>protocol</b> <b>entities.</b> The four abstraction levels of FOCUS [...] trace specification, functional specification, abstract program, and concrete program [...] are covered. Special emphasis is put on the design steps within and between the first two abstraction levels, which are also proven correct...|$|R
40|$|We use an {{event-driven}} {{process model}} to specify {{a version of}} the High-Level Data Link Control (HDLC) protocol between two communicating <b>protocol</b> <b>entities.</b> The <b>protocol</b> is verified using the method of projections. The verification serves as a rigorous exercise to demonstrate the applicability of this method to the analysis of real-life communication protocols. The HDLC protocol has two characteristics found in most real-life communication protocols. First, the HDLC protocol operates under real-time constraints that are important not only for its performance but also for its correct logical behavior. We specify this real-time behavior using time variables and time events. Second, the HDLC protocol has three distinguishable functions: connection management, and one-way data transfers between the <b>protocol</b> <b>entities.</b> For each of these functions, we construct an image protocol using the method of projections. With each image protocol we obtain inductively complete invariant assertions that state various desirable logical safety properties. From the properties of image protocols it follows that these safety properties as proved for the image protocols are also satisfied by the HDLC protocol presented herein. We also suggest a minor modification to HDLC that will make it well-structured...|$|R
5000|$|... #Subtitle level 3: MME (Mobility Management <b>Entity)</b> <b>protocols</b> ...|$|R
40|$|Maximum 200 words) 14. SUBJECT TERMS 17. SECURITY CLASSIFICATION OF REPORT 18. SECURITY CLASSIFICATION OF THIS PAGE 19. SECURITY CLASSIFICATION OF ABSTRACT 15. NUMBER OF PAGES 16. PRICE CODE 20. LIMITATION OF ABSTRACT 5. FUNDING NUMBERS i Canterbury, Michael September 1995 Master's Thesis Unclassified Unclassified UL Unclassified An Automated Approach to Distributed Interactive Simulation (DIS) <b>Protocol</b> <b>Entity</b> Development(U) Naval Postgraduate School Monterey, CA 93943 - 5000 The views {{expressed}} in this thesis {{are those of the}} author and do not reflect the official policy or position of the Department of Defense or the United States Government. Approved for public release; distribution is unlimited. One problem associated with the Distributed Interactive Simulation (DIS) architecture is its limited ability to support real-time, simulated engagements of more than 1000 entities. To solve this problem, it is necessary to refine the existing DIS protocol and optimiz [...] ...|$|E
40|$|The {{decomposition}} of networking functions into smaller subsets simplifies implementation {{and leads to}} open standards. Nonetheless, in applications such as mobile Wireless ATM, where resources are scarce, protocol stacks must not compromise on performance. The layers of a protocol stack progressively enhance and add reliability to the supported services. Along with additional new functions, the higher layers frequently implement error control algorithms to overcome residual errors that escape the lower layers. If relatively large numbers of residual errors escape, as is likely in the mobile Wireless ATM environment, then frequent retransmissions or reinitialization of the higher layer <b>protocol</b> <b>entity</b> could result in drastic loss of throughput. In this paper we examine the consequences of errors spanning two layers of a protocol stack using an explicit model {{to account for the}} interaction between two layers. I. INTRODUCTION The advantages that accrue from the use of a layered protocol [...] ...|$|E
40|$|A {{complete}} {{communication system}} is {{broken down into}} a number of protocol layers each of which provides services to the layer above it and uses services provided by its underlying layer. A service specification defines a particular ordering of the operations that a given layer provides to the layer above it. The active elements in each layer are called entities and they use a protocol in order to implement their service definition. On the basis of this relation between the service and protocol concepts we have developed algorithms for deriving <b>protocol</b> <b>entity</b> specifications from a formal service specification. The derived protocol entities ensure the correct ordering of the service primitives by exchanging synchronization messages through an underlying communication medium. This paper presents a new version of our derivation algorithms; it is an extension of the method to a more comprehensive specification language. This version of the algorithm can handle now all operators and unrestricted process invocation and recursion as defined by basic LOTOS. The correctness of the derivation algorithm is formally proved. 1...|$|E
30|$|Nowadays, network simulators, like NS- 2 [7], have sped up the {{analysis}} of various network scenarios, under several settings. These tools enable a pretty precise understanding of protocol mechanisms but, under certain circumstances, provide arguable results on performances: the reason lies in the resources available to precisely implement <b>protocol</b> <b>entities</b> and in the simplistic descriptions of physical and channel phenomena. As a result, simulations could lead to purely conceptual and qualitative description of the physical events, especially in urban scenarios where interactions between nodes and surrounding environment become fundamental and, nevertheless, neglected.|$|R
40|$|We dene a notication {{hierarchy}} {{including a}} set of unied link-layer triggers {{to be used for}} cross-layer optimization in heterogeneous wireless networks. Unlike previous sugges-tions, our approach is not specic to IEEE 802 -technologies, and can be used by applications as well as network and transport <b>protocol</b> <b>entities.</b> We also present full testbed im-plementation of our system together with the correspond-ing software architecture focussing on IEEE 802. 11 WLAN networks. As a test case, we illustrate the benets of our approach with a video streaming application using the re-transmission ratio as a link quality indicator...|$|R
40|$|This paper {{presents}} ProtoTalk, {{a framework}} for developing telecommunication and network protocols. ProtoTalk is a generative domain specific framework on top of Smalltalk programming language. It provides facilities for specification of layer stacks and <b>protocol</b> <b>entities</b> in telecommunication software systems. State machine description and packet type encoding can also be done easier in ProtoTalk than general purpose programming languages. ProtoTalk {{is designed to be}} a concurrent system by introducing active objects to Smalltalk. The research behind this paper includes detail analysis of the protocol’s domain, survey of several related works done in the past...|$|R
40|$|This chapter {{discusses}} {{aspects of}} the OSI-RM related to the development and definition of application protocols. The OSI-RM has been adopted by ISO and ITU-TSS as the major framework for coordinating protocol standardization efforts. In addition, the wide acceptance of the terminology defined in the OSI-RM {{has contributed to the}} establishment of a ‘common language ’ for discussing protocol engineering concepts across different protocol architecture communities. The OSI-RM comprises both a (loosely defined) design model and a reference architecture for protocol design. The design model defines such general concepts as service, service primitive, service data unit, service access point, protocol, <b>protocol</b> <b>entity,</b> and protocol data unit. It also defines the basic structuring technique for OSI: layering. Extensions to this design model were later defined by the OSI Application Layer Structure (OSI-ALS). The OSI-ALS is mainly concerned with additional structuring techniques that must enable a greater flexibility in combining Application Layer standards. The reference architecture defines a layered subdivision of the overall protocol functionality. This results in a global characterization of four lower protocol layers and thre...|$|E
40|$|A way {{to create}} well-functioning {{computer}} systems is to automate error detection in the systems. Automated techniques for finding errors, such as testing and formal verification, requires {{a model of the}} system. The technique for constructing deterministic finite automata (DFA) models, without access to the source code, is called regular inference. The technique provides sequences of input, so called membership queries, to a system, observes the responses, and infers a model from the input and responses. This thesis presents work to adapt regular inference to a certain kind of systems: communication protocol entities. Such entities interact by sending and receiving messages consisting of a message type and a number of parameters, each of which potentially can take on a large number of values. This may cause a model of a communication <b>protocol</b> <b>entity</b> inferred by regular inference, to be very large and {{take a long time to}} infer. Since regular inference creates a model from the observed behavior of a communication <b>protocol</b> <b>entity,</b> the model may be very different from a designer's model of the system's source code. This thesis presents adaptations of regular inference to infer more compact models and use less membership queries. The first contribution is a survey over three algorithms for regular inference. We present their similarities and their differences in terms of the required number of membership queries. The second contribution is an investigation on how many membership queries a common regular inference algorithm, the L* algorithm by Angluin, requires for randomly generated DFAs and randomly generated DFAs with a structure common for communication protocol entities. In comparison, the DFAs with a structure common for communication protocol entities require more membership queries. The third contribution is an adaptation of regular inference to communication protocol entities which behavior foremost are affected by the message types. The adapted algorithm avoids asking membership queries containing messages with parameter values that results in already observed responses. The fourth contribution is an approach for regular inference of communication protocol entities which communicate with messages containing parameter values from very large ranges. The approach infers compact models, and uses parameter values taken from a small portion of their ranges in membership queries. The fifth contribution is an approach to infer compact models of communication protocol entities which have a similar partitioning of an entity's behavior into control states as in a designer's model of the protocol...|$|E
40|$|A NEW PROTOCOL FOR THE SUPPORT OF MULTIMEDIA COMMUNICATION AT THE APPLICATION LAYER OF THE OSI REFERENCE MODEL IS PROPOSED AND PRESENTED. THE NEW PROTOCOL RESIDES WITHIN THE FRAMEWORK OF A NEW COMMUNICATION ARCHITECTURAL MODEL. THE MAIN MOTIVATION FOR THE DESIGN AND DEVELOPMENT OF THE PROTOCOL WAS THE ADAPTATION OF THE CONVENTIONAL OSIRM TO THE NEW REQUIREMENTS AND ESPECIALLY IN CONJUCTION WITH THE SPECIFICATIONS OF THE EMERGING B-ISDN. PRECISELY, THE NEW PROTOCOL PROVIDES GENERIC SERVICES FOR THE ESTABLISHMENT AND MANAGEMENT OF MULTIMEDIA ASSOCIATIONS AT THE OSI APPLICATION LAYER. IT IS ENTITLED (AND AS A CONSEQUENCE THE NEW OSI SERVICE THAT PROVIDES) MULTIPLE ASSOCIATION CONTROL OF MULTIMEDIA ASSOCIATIONS AMONG MULTIPLE SPATIALLY DISPERSED USERS. MACSE DEFINESA NEW OSI SERVICE SO THAT TO SHIFT THE BURDEN OF SETTING-UP A COMPLEX MULTIMEDIA CALL TO A <b>PROTOCOL</b> <b>ENTITY</b> INSTEAD OF THE APPLICATION PROCESS. THE MACSE PROTOCOL ENHANCES THE FUNCTIONALITY OF THE ORIRM BY INTRODUCING CAREFUL APPLICATION SERVICE DEFINITION, SERVICE PRIMITIVES AND THE RELEVANT PARAMETERS, ASWELL AS A NON-MONOLITHIC PROTOCOL SPECIFICATION. THE PROTOCOL DEFINES PROCEDURES FOR THE NEGOTIATION AND CONFIRMATION OF QUALITY OF SERVICE (QOS) PER ASSOCIATION WHILE IT FORMS THE CORE OF THE PROPOSED ARCHITECTURAL MODEL WHICH PROVIDES A COHERENT TREATMENT OF QOS ACROSS ALL LAYERS OF THE OSIRM AND REDUES THE COMPLEXITY OF IT. (ABSTRACT TRUNCATED) ...|$|E
40|$|Abstract—MBMS is a {{unidirectional}} point-to-multipoint {{bearer service}} in which data are transmitted {{from a single}} source entity to multiple recipients. For a mobile to support the MBMS, MBMS client functions as well as MBMS radio protocols should be designed and implemented. In this paper, we analyze the MBMS client functions and describe the implementation of them in our mobile test-bed. User operations and signaling flows between <b>protocol</b> <b>entities</b> to control the MBMS functions are designed in detail. Service announcement utilizing the file download MBMS service and four MBMS user services are demonstrated in the test-bed to verify the MBMS client functions...|$|R
40|$|Multimedia {{multi-user}} {{applications are}} becoming more and more important. Intensive research is underway on the design of <b>protocols</b> and <b>protocol</b> <b>entities</b> for future communication systems supporting multimedia multi-user applications. The development of a service description ensures that protocol designs actually produce the required functional behavior. The authors explain the approach to the description of a multimedia multi-user service. An example illustrates the use of the service description in the design of communication systems. Next, they present the basic requirements of multimedia and multi-user communications. A call model underlies and structures the service description. Finally, the authors describe the service in terms of service element...|$|R
40|$|Abstract The {{computational}} proof {{model of}} Bellare and Rogaway for cryptographic protocol analysis is complemented {{by providing a}} formal specification {{of the actions of}} the adversary and the <b>protocol</b> <b>entities.</b> This allows a matching model to be used in both a machine-generated analysis and a human-generated computational proof. Using a protocol of Jakobsson and Pointcheval as a case study, it is demonstrated that flaws in the protocol could have been found with this approach, providing evidence that the combination of human and computer analysis can be more effective than either alone. As well as finding the known flaw, previously unknown flaws in the protocol are discovered by the automatic analysis. 1...|$|R
