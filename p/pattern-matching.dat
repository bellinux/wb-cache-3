906|46|Public
25|$|Perl's regular {{expression}} and string-processing support {{has always been}} one of its defining features. Since Perl's <b>pattern-matching</b> constructs have exceeded the capabilities of regular language expressions for some time, Perl 6 documentation will exclusively refer to them as regexen, distancing the term from the formal definition.|$|E
25|$|The {{human genome}} {{consists}} of three billion base pairs, which code for approximately 20,000–25,000 genes. However the genome alone is of little use, unless the locations and relationships of individual genes can be identified. One option is manual annotation, whereby {{a team of scientists}} tries to locate genes using experimental data from scientific journals and public databases. However this is a slow, painstaking task. The alternative, known as automated annotation, is to use the power of computers to do the complex <b>pattern-matching</b> of protein to DNA.|$|E
500|$|Statistical <b>pattern-matching</b> {{has been}} {{implemented}} using both the expectation-maximization algorithm and the Gibbs sampler. One {{of the most}} common motif-finding tools, known as MEME, uses expectation maximization and hidden Markov methods to generate motifs that are then used as search tools by its companion MAST in the combined suite [...]|$|E
40|$|A Haskell {{program may}} fail at runtime with a <b>pattern-match</b> error {{if the program}} has any {{incomplete}} (non-exhaustive) patterns in definitions or case alternatives. This paper describes a static checker that allows non-exhaustive patterns to exist, yet ensures that a <b>pattern-match</b> error does not occur. It describes a constraint language {{that can be used}} to reason about pattern matches, along with mechanisms to propagate these constraints between program components. ...|$|R
40|$|Left-nested list concatenations, left-nested binds on {{the free}} monad, and left-nested choices in many non-determinism monads have an algorithmically bad performance. Can we solve this problem without losing the ability to <b>pattern-match</b> on the computation? Surprisingly, there is a deceptively simple solution: use a smart view to <b>pattern-match</b> on the datatype. We {{introduce}} the notion of smart view and show how it solves the problem of slow left-nested operations. In particular, we use the technique to obtain fast and simple implementations of lists, of free monads, and of two non-determinism monads...|$|R
40|$|Abstract: A Haskell {{program may}} fail at runtime with a <b>pattern-match</b> error {{if the program}} has any {{incomplete}} (non-exhaustive) patterns in definitions or case alternatives. This paper describes a static checker that allows non-exhaustive patterns to exist, yet ensures that a <b>pattern-match</b> error does not occur. It describes a constraint language {{that can be used}} to reason about pattern matches, along with mechanisms to propagate these constraints between program components. Often it is useful to define pattern matches which are incomplete, for example head fails on the empty list. Unfortunately programs with incomplete pattern matches may fail at runtime...|$|R
2500|$|Baer is also {{credited}} with co-developing three popular electronic games. Baer, along with Howard J. Morrison, developed Simon (1978) and its sequel Super Simon (1979) for Milton Bradley, electronic <b>pattern-matching</b> games that were immensely popular {{through the late}} 1990s. The US patent for Simon, Pat No. 4,207,087 was obtained in 1980 by patent counsel for Marvin Glass and Associates, Robert J. Schneider, a managing partner with the firm of Mason, Kolehmainen, Rathburn and Wyss. Schneider is currently Co-Chair of the Intellectual Property Department of Taft, Stettinius & Hollister LLP. Baer also developed a similar <b>pattern-matching</b> game [...] "Maniac" [...] for the Ideal Toy Company (1979) on his own, though the game was not as popular as Simon; Baer considered that Maniac was [...] "really hard to play" [...] and thus not as popular as his earlier game.|$|E
2500|$|Via C++'s influence, {{catch is}} the keyword {{reserved}} for declaring a <b>pattern-matching</b> exception handler in other languages popular today, like Java or C#. Some other languages like Ada use the keyword exception to introduce an exception handler and then may even employ a different keyword (when in Ada) for the pattern matching. A few languages like AppleScript incorporate placeholders in the exception handler syntax to automatically extract several {{pieces of information}} when the exception occurs. This approach is exemplified below by the on error construct from AppleScript: ...|$|E
2500|$|Tens of {{thousands}} of letters from Masqueraders have convinced me that the human mind has an equal capacity for <b>pattern-matching</b> and self-deception. While some addicts were busy cooking the riddle, others were more single-mindedly continuing their own pursuit of the hare quite regardless of the news {{that it had been}} found. Their own theories had come to seem so convincing that no exterior evidence could refute them. These most determined of Masqueraders may grudgingly have accepted that a hare of some sort was dug up at Ampthill, but they believed there would be another hare, or a better solution, awaiting them at their favourite spot. [...] Kit would expect them to continue undismayed by the much publicised diversion at Ampthill and would be looking forward to the day when he would greet them as the real discoverers of the real puzzle of Masquerade. Optimistic expeditions were still setting out, with shovels and maps, throughout the summer of 1982.|$|E
5000|$|Generalized {{algebraic}} data types. Each constructor of a polymorphic datatype can encode {{information into}} the resulting type. A function which <b>pattern-matches</b> on this type {{can use the}} per-constructor type information to perform more specific operations on data.|$|R
40|$|Pattern {{matching}} mechanisms {{based on}} regular expressions feature {{in a number}} of recent languages for processing XML. The flexibility of these mechanisms demands novel approaches to the familiar problems of <b>pattern-match</b> compilation [...] -how to minimize the number of tests performed during pattern matching while keeping the size of the output code small...|$|R
50|$|Literal {{movement}} grammars (LMGs) are a grammar formalism {{introduced by}} Groenink in 1995 intended to characterize certain extraposition phenomena of natural language such as topicalization and cross-serial dependencies. LMGs extend {{the class of}} CFGs by adding introducing <b>pattern-matched</b> function-like rewrite semantics, {{as well as the}} operations of variable binding and slash deletion.|$|R
5000|$|... #Caption: Baer is {{credited}} with developing the <b>pattern-matching</b> game Simon.|$|E
5000|$|Whereas in CoffeeScript {{one can use}} [...] and <b>pattern-matching</b> instead: ...|$|E
5000|$|A <b>pattern-matching</b> {{facility}} {{based on}} Perl-style regular expressions (in package [...] ) ...|$|E
5000|$|The usual {{context of}} {{wildcard}} characters is in globbing similar names in {{a list of}} files, whereas regexes are usually employed in applications that <b>pattern-match</b> text strings in general. For example, the regex [...] matches excess whitespace at the beginning or end of a line. An advanced regex used to match any numeral is [...] See the Examples section for more examples.|$|R
5000|$|To do {{something}} with a value of this Tree algebraic data type, it is deconstructed using a process termed pattern matching. It involves matching the data {{with a series of}} patterns. The example function [...] "depth" [...] above <b>pattern-matches</b> its argument with three patterns. When the function is called, it finds the first pattern that matches its argument, performs any variable bindings that are found in the pattern, and evaluates the expression corresponding to the pattern.|$|R
50|$|OMeta uses pattern {{matching}} {{in order to}} accomplish all of the steps of traditional compiling by itself. It first finds patterns in characters to create tokens, then it matches those tokens to its grammar to make syntax trees. Typecheckers then match patterns on the syntax trees to make annotated trees, and visitors do the same to produce other trees. A code generator then <b>pattern-matches</b> the trees to produce the code. In OMeta, it is easy to “traverse through the parse tree since such functionality is natively supported”.|$|R
5000|$|Tom : a {{language}} based on rewriting calculus, with <b>pattern-matching</b> and strategies ...|$|E
50|$|Another {{variation}} {{replaces the}} parse table by <b>pattern-matching</b> rules in non-procedural languages such as Prolog.|$|E
5000|$|... "Conversational Language Comprehension Using Integrated <b>Pattern-Matching</b> and Parsing." [...] Artif. Intell. 9(2) (1977), pp. 111-134 ...|$|E
40|$|We {{describe}} a transformation which takes a higher-order program, and produces an equivalent first-order program. Unlike Reynoldsstyle defunctionalisation, {{it does not}} introduce any new data types, {{and the results are}} more amenable to subsequent analysis operations. We can use our method to improve the results of existing analysis operations, including strictness analysis, <b>pattern-match</b> safety and termination checking. Our transformation is implemented, and works on a Core language to which Haskell programs can be reduced. Our method cannot always succeed in removing all functional values, but in practice is remarkably successful. D. 3 [Software]: Program...|$|R
40|$|Even well-typed {{programs}} {{can go wrong}} in modern functional languages, by encountering a <b>pattern-match</b> failure, or simply returning the wrong answer. An increasingly-popular response is to allow programmers to write contracts that express semantic properties, such as crash-freedom or some useful post-condition. We study the static verification of such contracts. Our main contribution is a novel translation to first-order logic of both Haskell programs, and contracts written in Haskell, all justified by denotational semantics. This translation enables us to prove that functions satisfy their contracts using an off-the-shelf first-order logic theorem prover...|$|R
40|$|Abstract. Aiming at {{the problem}} of {{artificial}} preservation in seafood transportation, this article has designed an intelligent preservation system during seafood transportation based on Proportion Integration Differentiation(PID) and Evolvable Hardware（EHW）. This system can collect real-time humidity and temperature information by the sensor-module, and upload the data through GPRS network. We can analyze and process the data received in the remote control office, <b>pattern-match</b> it in the control-module libraries, and then take effective measures to preserve corresponding live seafood. The system is highly real-time and reliability and can solve the preservation problem in seafood transportation scientifically and effectively...|$|R
5000|$|... kill, which sends signals {{processes}} by process ID instead of by <b>pattern-matching</b> against the name.|$|E
50|$|In formal {{language}} theory, alternation is commutative and associative. This {{is not in}} general true in <b>pattern-matching</b> languages.|$|E
50|$|CSCM has lambda, {{just like}} scheme. It also, however, has lambda-match {{to account for}} Erlang's <b>pattern-matching</b> {{capabilities}} in anonymous function calls.|$|E
40|$|We {{describe}} an automated analysis of Haskell 98 programs to check statically that, despite the possible use of partial (or nonexhaustive) pattern matching, no <b>pattern-match</b> failure can occur. Our method is an iterative backward analysis using a novel form of pattern-constraint to represent {{sets of data}} values. The analysis is defined for a core first-order language to which Haskell 98 programs are reduced. Our analysis tool has been successfully applied {{to a range of}} programs, and our techniques seem to scale well. Throughout the paper, methods are represented much as we have implemented them in practice, again in Haskell...|$|R
40|$|Some type class {{instances}} can be automatically {{derived from}} the structure of types. As a result, the Haskell language includes the “deriving ” mechanism to automatic generates such instances for {{a small number of}} built-in type classes. In this paper, we present RepLib, a GHC library that enables a similar mechanism for arbitrary type classes. Users of RepLib can define the relationship between the structure of a datatype and the associated instance declaration by a normal Haskell functions that <b>pattern-matches</b> a representation type. Furthermore, operations defined in this manner are extensible—instances for specific types not defined by type structure may also be incorporated. Finally, this library also supports the definition of operations defined by parameterized types...|$|R
40|$|Information {{extraction}} {{is a form}} of shallow {{text processing}} that locates a specified set of relevant items in a natural-language document. Systems for this task require signicant domain-specific knowledge and are time-consuming and difficult to build by hand, making them a good application for machine learning. We present a system, Rapier, that uses pairs of sample documents and filled templates to induce <b>pattern-match</b> rules that directly extract llers for the slots in the template. Rapier employs a bottom-up learning algorithm which incorporates techniques from several inductive logic programming systems and ac-quires unbounded patterns that include constraints on the words, part-of-speech tags, and semantic classes present in the ller and the surrounding text. We present encouraging experimental results on two domains...|$|R
5000|$|The term [...] "glob" [...] is {{also used}} to refer more {{generally}} to limited <b>pattern-matching</b> facilities of this kind, in other contexts: ...|$|E
50|$|The Rete {{algorithm}} {{is widely used}} to implement matching functionality within <b>pattern-matching</b> engines that exploit a match-resolve-act cycle to support forward chaining and inferencing.|$|E
50|$|The {{assembler}} {{was very}} advanced, with a Lisp-like <b>pattern-matching</b> macro facility unmatched by {{almost any other}} assembler before or since. There was an always-resident debugger.|$|E
40|$|Information {{extraction}} {{is a form}} of shallow {{text processing}} that locates a specified set of relevant items in a natural-language document. Systems for this task require significant domain-specific knowledge and are time-consuming and difficult to build by hand, making them a good application for machine learning. We present an algorithm, RAPIER, that uses pairs of sample documents and filled templates to induce <b>pattern-match</b> rules that directly extract fillers for the slots in the template. RAPIER is a bottom-up learning algorithm that incorporates techniques from several inductive logic programming systems. We have implemented the algorithm in a system that allows patterns to have constraints on the words, part-of-speech tags, and semantic classes present in the filler and the surrounding text. We present encouraging experimental results on two domains...|$|R
40|$|OPTIMIX is a {{tool for}} {{generating}} optimization algorithms which construct and transform directed relational graphs. OPTIMIX's specification language allows graph queries which localize information that is distributed and hidden in the intermediate representation, as well as graph rewrite systems which describe transformations. Hence OPTIMIX {{can be applied to}} three major problem classes of optimization: graph reachability problems, context-sensitive <b>pattern-match</b> problems, and mark/transform problems. OPTIMIX's specification language is based on edge addition rewrite systems (EARS), exhaustive graph rewrite systems (XGRS), and Datalog. The generator type-checks the rewrite systems against the specified data model and tests whether they fulfil a termination criterion. While previous papers have clearified the technology in terms of graph rewriting, this paper concentrates on the specification language, on examples from the application domains, and on practical experiences with the to [...] ...|$|R
40|$|Information {{extraction}} {{is a form}} of shallow {{text processing}} which locates a specified set of relevant items in natural language documents. Such systems can be useful, but require domain-specific knowledge and rules, and are time-consuming and difficult to build by hand, making infomation extraction a good testbed for the application of machine learning techniques to natural language processing. This paper presents a system, Rapier, that takes pairs of documents and filled templates and induces <b>pattern-match</b> rules that directly extract fillers for the slots in the template. The learning algorithm incorporates techniques from several inductive logic programming systems and learns unbounded patterns that include constraints on the words and part-of-speech tags surrounding the filler. Encouraging results are presented on learning to extract information from computer job postings from the newsgroup misc. jobs. offered. Introduction Text understanding is a difficult and kno [...] ...|$|R
