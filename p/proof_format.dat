35|38|Public
50|$|Equational logic was {{developed}} over the years (beginning in the early 1980s) by researchers in the formal development of programs, who felt a need for an effective style of manipulation, of calculation. Involved were people like Roland Carl Backhouse, Edsger W. Dijkstra, Wim H.J. Feijen, David Gries, Carel S. Scholten, and Netty van Gasteren. Wim Feijen is responsible for important details of the <b>proof</b> <b>format.</b>|$|E
50|$|SD is {{a further}} {{development}} of the calculational <b>proof</b> <b>format</b> introduced by Edsger W. Dijkstra {{and others in the}} early 1990s. In essence, three main extensions have been made. First, a mechanism for decomposing proofs through the use of subderivations has been added. The calculational approach is limited to writing proof fragments, and longer derivations are commonly decomposed into several separate subproofs. Using SD with subderivations, on the other hand, the presentation of a complete proof or solution is kept together, as subproofs can be presented exactly where they are needed. In addition, SD makes it possible to handle assumptions and observations in proofs. As such, the format can be seen as combining the benefits of the calculational style with the decomposition facilities of natural deduction.|$|E
50|$|In their monograph, Dijkstra and Scholten use {{the three}} {{inference}} rules Leibniz, Substitution, and Transitivity. However, Dijkstra/Scholten {{system is not}} a logic, as logicians use the word. Some of their manipulations {{are based on the}} meanings of the terms involved, and not on clearly presented syntactical rules of manipulation. The first attempt at making a real logic out of it appeared in A Logical Approach to Discrete Math. However, inference rule Equanimity is missing there, and the definition of theorem is contorted to account for it. The introduction of Equanimity and its use in the <b>proof</b> <b>format</b> is due to Gries and Schneider. It is used, for example, in the proofs of soundness and completeness, and it will appear in the second edition of A Logical Approach to Discrete Math.|$|E
40|$|The quantifier-free {{logic of}} Equality with Uninterpreted Function symbols (EUF) {{is at the}} core of Satisfiability Modulo Theory (SMT) solvers. There exist several {{competing}} <b>proof</b> <b>formats</b> for EUF <b>proofs.</b> We propose original <b>proof</b> <b>formats</b> obtained from <b>proof</b> forests that are the artifacts proposed by Nieuwenhuis and Oliveras to extract efficiently EUF unsatisfiable cores. Our <b>proof</b> <b>formats</b> can be generated by SMT solvers for almost free. Moreover, our preliminary experiments show that our novel verifiers outperform other existing EUF verifiers and that our <b>proof</b> <b>formats</b> appear to be more concise than existing EUF proofs. ...|$|R
40|$|Automatic provers {{that can}} produce proof {{certificates}} {{do not need to}} be trusted. The certificate can be checked by an independent tool, for example an LCF-style proof assistant such as Isabelle/ HOL or HOL 4. Currently, the design of <b>proof</b> <b>formats</b> is mostly dictated by internal constraints of automatic provers and less guided by applications such as checking of certificates. In the worst case, checking can be as involved as the actual proof search simply because important information is missing in the proof certificate. To address this and other issues, we describe design choices for <b>proof</b> <b>formats</b> that we consider both feasible for implementors of automatic provers as well as effective to simplify checking of certificates. ...|$|R
40|$|AbstractThe {{structural}} elements in steel and composite bridges {{are sensitive to}} stability problems due to their large dimensions. Mainly, resulting elements are thin plates falling under the design requirements provided by EN 1993 - 1 - 5. Due {{to the results of}} recent scientific papers regarding the unstiffened plates under biaxial stress, the review of the buckling <b>proof</b> <b>formats</b> for stiffened plates under biaxial loading was needed. The article gives an overview of buckling <b>proof</b> <b>formats</b> according to EN 1993 - 1 - 5 for steel and composite bridge and it is limited to the usual method of reduced stresses in Germany. For a given example, this paper discusses whether the proposed approach in the literature is also appropriate for the case of stiffened panels. One method for the buckling verification according to the effective width method of plates under biaxial compression and shear will be proposed...|$|R
40|$|Introducing {{techniques}} {{deriving from}} dynamic proofs in proofs for propositional classical logic {{is shown to}} lead to a <b>proof</b> <b>format</b> that enables one to push search paths into the proofs themselves. The resulting goal directed <b>proof</b> <b>format</b> is shown to provide a decision method for A 1,... An B and a positive test for # A...|$|E
40|$|The {{standard}} input format for Satisfiability Modulo Theories (SMT) solvers has now reached its second version and integrates {{many of the}} features useful for users to interact with their favourite SMT solver. However, although many SMT solvers do output proofs, no standardised <b>proof</b> <b>format</b> exists. We, here, propose for discussion at the PxTP Workshop a generic <b>proof</b> <b>format</b> in the SMT-LIB philosophy that is flexible enough to be easily recast for any SMT solver. The format is configurable so that {{the proof can be}} provided by the solver at the desired level of detail. ...|$|E
40|$|This paper {{spells out}} a dynamic <b>proof</b> <b>format</b> for the pure logic of {{relevant}} implication. (A proof is dynamic if a formula derived at some stage {{need not be}} derived at a later stage). The papers illustrates three interesting points. (i) A set of properties that characterizes an inference relation on the (very natural) dynamic proof interpretation, need not characterize the same inference relation (or even any inference relation) on the usual set-theoretical interpretation. (ii) A <b>proof</b> <b>format</b> may display an internal dynamics (defeasible conclusions) {{in the absence of}} an external dynamics (non-monotonicity). (iii) A monotonic logic may have a non-monotonic characterization...|$|E
40|$|In this {{contribution}} I advocate an {{open system}} for formalised mathematical reasoning that {{is able to}} capture different mathematical formalisms {{as well as a}} wide variety of <b>proof</b> <b>formats.</b> This is assumed to be much more adequate since it more closely reflects the situation in mathematics as a whole. In particular I try to classify different dimension according to which proofs can be classified...|$|R
40|$|We {{propose a}} <b>proof</b> {{representation}} <b>format</b> for human-oriented <b>proofs</b> at the assertion level with underspecification. This work aims at providing a possible solution to challenging phenomena {{worked out in}} empirical studies in the DIALOG project at Saarland University. A particular challenge in this project is {{to bridge the gap}} between the human-oriented <b>proof</b> representation <b>format</b> with under-specification used in the proof manager of the tutorial dialogue system and the calculus- and machine-oriented representation format of the domain reasoner...|$|R
40|$|International audienceThe TPTP {{library is}} one of the leading problem {{libraries}} in the automated theorem proving community. Over time, support was added for problems beyond those in first-order clausal form. TPTP has also been augmented with support for various <b>proof</b> <b>formats</b> output by theorem provers. Such proofs can also be maintained in the TSTP proof library. In this paper we propose an extension of this framework to support the semantic specification of the inference rules used in proofs...|$|R
40|$|The Edinburgh Logical Framework (LF) {{extended}} to support side condition code (LFSC) is advocated {{as a foundation}} for a <b>proof</b> <b>format</b> for SMT. The flexibility of the framework is demonstrated by example encoded inference rules, notably propositional resolution. Preliminary empirical results obtained with a SAT solver producing proofs in LFSC format are presented. ...|$|E
40|$|This {{document}} describes SCAPA, {{a system}} for presenting and developing World Wide Web based animations of non formal proofs for computer science education. With SCAPA one can systematically produce proof animations in a fashion {{that is similar to}} generating algorithm animations with the help of script based algorithm animation systems. The proofs are written with L A T E X in the structured calculational <b>proof</b> <b>format</b> and converted into browsable HTML. The structuring information contained in the special <b>proof</b> <b>format</b> is used for synthesizing a partial algorithm that serves as a basis for generating the animation. SCAPA can be used with every Java based algorithm animation system. Our examples have been produced with Lambada, a fully Java based algorithm animation system that is compatible to Samba. The animations can be used to help undergraduate students of computer science to overcome their problems in reading and understanding non formal proofs in the domain of theoretical computer [...] ...|$|E
40|$|Dijkstra {{argues that}} calculational proofs are {{preferable}} to traditional pictorial and/or verbal proofs. First, {{due to the}} calculational <b>proof</b> <b>format,</b> incorrect proofs are less likely. Second, syntactic considerations (letting the "symbols do the work") have led to {{an impressive array of}} techniques for elegant proof construction. However, calculational proofs are not formal and are not awless. Why not make them formal and check them mechanically...|$|E
40|$|I {{would like}} to express my sincere {{appreciation}} to Chief Justice Gerald W. VandeWalle and State Court Administrator Sally Holewa for their support in allowing me {{to participate in the}} Court Executive Development Program. Thanks to Dr. Geoff Gallas, my advisor on this project, for his editing abilities, excellent feedback, and guidance during this project. Thanks to my dear friend, Kim Reinke, for the many hours she spent <b>proofing,</b> <b>formatting</b> and typing this report. To my fellow CEDP colleagues in the class of 2007, for their friendship, sense of humor and support throughout the program. And lastly, to my husband Tim, for his patience and support throughout th...|$|R
40|$|Most {{automated}} theorem provers suffer on {{the problem}} that the proofs they produce are difficult to understand even for experienced users. Therefore, many efforts {{have been made to}} transform, abstract and restructure machine-found proofs to produce <b>proof</b> <b>formats</b> better understandable for humans. One of the most prefered target formats is the natural deduction proof. Current approaches suffer mainly on two problems. First, the state-ofthe -art transformation procedures generate very often natural deduction proofs with many indirect parts since they translate at the literal level steps from the machine-found proofs into the natural deduction proofs. Secondly, the natural deduction calculus itself is not eligible for presenting mathematical proofs. The problem is that inferences in the natural deduction calculus are still on the level of syntactical manipulations of logical connectives and quantifiers. They are not on the level of theorem or definition applications as we have in mathematic [...] ...|$|R
40|$|Abstract A common {{exchange}} {{format for}} logic {{problems to be}} used by members of the DFG-SchwerpunktprogrammDeduktion is introduced. It is thought to be a format that can easily be parsed such that it forms a compromise between the needs of the different groups. The language is partly more general than other popular exchangeformats such as Otter or TPTP in allowing non-clausal and sorted formulae, several <b>proof</b> <b>formats</b> as well as user-defined operators. The latter feature makes it also useful for non-classical logics. 1 Introduction The language proposed in the following is intended to be a common exchange format for logic problem settings. It is thought to be a format that can easily be parsed such that it forms a compromise between the needs of the different groups. Therefore, it is kept as simple as possible, in particular, the grammar of the language can beeasily processed by some automatic parser-generator...|$|R
40|$|This paper {{discusses}} {{advantages and}} disadvantages of some possible alternatives for inference rules that handle quantifiers in the <b>proof</b> <b>format</b> of the SMT-solver veriT. The quantifier-handling modules in veriT being fairly standard, we hope this will motivate the discussion among the PxTP audience around proof production for quantifier handling. This could generate ideas to help us im-prove our proof production module, and also benefit the SMT community. ...|$|E
40|$|The author {{considers}} the model-theoretic character of proofs and disproofs {{by means of}} attempted counterexample constructions, distinguishes this <b>proof</b> <b>format</b> from formal derivations, then contrasts two approaches to semantic tableaux proposed by Beth and Lambert-van Fraassen. It is noted that Beth's original approach has not as yet been provided with a precisely formulated rule of closure for detecting tableau sequences terminating in contradiction. To remedy this deficiency, a technique is proposed to clarify tableau operations...|$|E
40|$|Abstract. We {{consider}} {{an extension of}} OMDoc proofs with alternative sub-proofs and proofs at different level of detail, and an affine nondeterministic fragment of the *u~u-calculus seen as a <b>proof</b> <b>format.</b> We provide explanations in pseudo-natural language of proofs in both formats, and a formal correspondence between the two by means of two mutually inverse encodings of one format in the other one. 1 Introduction Proofs {{play a major role}} in mathematics and their representation is a key issue inmathematical knowledge management. Proofs of all kinds need to be stored an...|$|E
40|$|Binary Decision Diagrams (BDDs) {{are usually}} {{thought of as}} devices {{engineered}} specially for classical propositional logic. We show that we can build {{on one of their}} variants, Minato's zero-suppressed BDDs, to build compact data structures that encode whole tableaux. We call these structures tableaux decision diagrams (TDDs), and show how tableaux proof search is implemented in this framework. For this to be efficient, we have to restrict to canonical <b>proof</b> <b>formats</b> (in the sense of Galmiche et al.) {{to be able to take}} advantage of sharing in TDDs. Sharing is fundamental, not because it reduces memory consumption, but because it allows us to expand or close many tableaux paths in parallel, with corresponding gains in efficiency. We provide some empirical evidence that this is indeed efficient, by illustrating the method on a well-chosen system for propositional intuitionistic logic. 1 Introduction Binary Decision Diagrams, or BDDs, are simple data structures that represent both the sets o [...] ...|$|R
40|$|In this {{contribution}} I advocate an {{open system}} for formalised mathematical reasoning that {{is able to}} capture different mathematical formalisms {{as well as a}} wide variety of <b>proof</b> <b>formats.</b> This is assumed to be much more adequate since it more closely reflects the situation in mathematics as a whole. In particular I try to classify different dimension according to which proofs can be classified. 1 Introduction One of the ultimate goals of the mechanisation of proofs is to achieve an increased rigour in proof. Mathematics generally enjoys the prestige of being the correct scientific discipline par excellence. This reputation stems from the requirement that every claim must be justified by a rigorous proof. The ultimate goal of many mechanised reasoning systems is to support mathematicians in the task of constructing such a proof. This is not trivial, since in traditional mathematical practice, proofs are not given in terms of single calculus rules but at a level of abstraction that conv [...] ...|$|R
40|$|Learning-assisted {{automated}} reasoning {{has recently}} gained popularity among the users of Isabelle/HOL, HOL Light, and Mizar. In this paper, we present an add-on to the HOL 4 proof assistant and {{an adaptation of}} the HOL(y) Hammer system that provides machine learning-based premise selection and automated reasoning also for HOL 4. We efficiently record the HOL 4 dependencies and extract features from the the-orem statements, which form a basis for premise selection. HOL(y) Hammer transforms the HOL 4 statements in the var-ious TPTP-ATP <b>proof</b> <b>formats,</b> which are then processed by the ATPs. We discuss the different evaluation settings: ATPs, acces-sible lemmas, and premise numbers. We measure the perfor-mance of HOL(y) Hammer on the HOL 4 standard library. The results are combined accordingly and compared with the HOL Light experiments, showing a comparably high qual-ity of predictions. The system directly benefits HOL 4 users by automatically finding proofs dependencies that can be reconstructed by Metis...|$|R
40|$|A common <b>proof</b> <b>format</b> for solvers for Satisfiability Modulo Theories (SMT) is proposed, {{based on}} the Edinburgh Logical Framework (LF). Two {{problems}} arise: checking very large proofs, and keeping proofs compact {{in the presence of}} complex side conditions on rules. Incremental checking combines parsing and proof checking in a single step, to avoid building in-memory representations of proof subterms. LF with Side Conditions (LFSC) extends LF to allow side conditions to be expressed using a simple first-order functional programming language. Experimental data with an implementation show very good proof checking times and memory usage on benchmarks including the important example of resolution inferences...|$|E
40|$|Abstract. The ¯ λµ˜µ-calculus, {{introduced}} by Curien and Herbelin, is a calculus isomorphic to (a variant of) the classical sequent calculus LK of Gentzen. As a <b>proof</b> <b>format</b> it has very remarkable properties that {{we plan to}} study in future works. In this paper we embed it with a rendering semantics that provides explanations in pseudo-natural language of its proof terms, {{in the spirit of}} the work of Yann Coscoy [3] for the λ-calculus. The rendering semantics unveils the richness of the calculus that allows to preserve several proof structures that are identified when encoded in the λ-calculus. ...|$|E
40|$|The quantifier-free {{logic of}} {{equality}} with uninterpreted function symbols (EUF) {{is at the}} core of SMT solvers. However, there exist several competing proof formats to validate EUF proofs. As EUF proof, we advocate for the proof forest that is the artifact proposed by Nieuwenhuis and Oliveras to extract efficiently EUF unsatisfiable cores. An advantage of this <b>proof</b> <b>format</b> is that it can be generated by the SMT solver for almost free. Our preliminary experiments show that our proof forest verifier outperforms other EUF verifiers and that proof forests appear to be more concise than existing EUF proofs. ...|$|E
50|$|Printers: In {{addition}} to computers and displays, digital darkrooms may include printing equipment, ranging from smaller size printers for <b>proofing</b> to large <b>format</b> productions printers. Scanner and studio photographic equipment {{may also be}} included.|$|R
40|$|This paper {{describes}} the implementation, {{as well as}} the features, of the graphical user interface, more specifically defined as a proof viewer, for the General Architecture for Proof Theory (GAPT) framework. It contains methods to render classical and schematic sequent calculus proofs as well as resolution proofs and other tree-like structures in a flexible way. Additional emphasis is put on the schematic <b>proof</b> input <b>format</b> which should be as user-friendly as possible for the end-user. ...|$|R
40|$|The package lplfitch {{provides}} macros for typesetting {{natural deduction}} proofs in “Fitch ” style, with subproofs indented and offset by scope lines. It produces <b>proofs</b> in the <b>format</b> {{used in the}} textbook Language, Proof, and Logic by Dave Barker-Plummer, Jon Barwise, and John Etchemendy. The package was originall...|$|R
40|$|Abstract. An {{effective}} SAT preprocessing {{technique is}} using symmetry-breaking predicates, i. e., auxiliary clauses that guide a solver away from needless exploration of isomorphic sub-problems. Although symmetry-breaking predicates {{have been in}} use for over a decade, it was not known how to express them in proofs of unsatisfiability. Consequently, results obtained by symmetry breaking cannot be validated by existing proof checkers. We present a method to express symmetry-breaking predicates in DRAT, a <b>proof</b> <b>format</b> that {{is supported by the}} top-tier solvers. We applied this method to generate proofs of problems that have not been solved without symmetry-breaking predicates. We validated these proofs with both an ACL 2 -based, mechanically-verified checker and the proof-checking tool of SAT Competition 2014. ...|$|E
40|$|Isabelle/HOL is {{a popular}} {{interactive}} theorem prover based on higherorder logic. It owes its success to its ease of use and powerful automation. Much of the automation is performed by external tools: The metaprover Sledgehammer relies on resolution provers and SMT solvers for its proof search, the counterexample generator Quickcheck uses the ML compiler as a fast evaluator for ground formulas, and its rival Nitpick {{is based on the}} model finder Kodkod, which performs a reduction to SAT. Together with the Isar structured <b>proof</b> <b>format</b> and a new asynchronous user interface, these tools have radically transformed the Isabelle user experience. This paper provides an overview of the main automatic proof and disproof tools...|$|E
40|$|Abstract. Compared to SAT, {{there is}} no simple concept of what a {{solution}} to a QBF problem is. Furthermore, as the series of QBF evaluations shows, the QBF solvers that are available often disagree. Thus, proof generation for QBF seems {{to be even more}} important than for SAT. In this paper we propose a new uniform <b>proof</b> <b>format,</b> which captures refutations and witnesses for a variety of QBF solvers, and is based on a novel extended resolution rule for QBF. Our experiments show the flexibility of this new format. We also identify shortcomings of our format and conjecture that a purely resolution based proof calculus is not powerful enough to trace the most efficient solvers. ...|$|E
40|$|Abstract. In {{this paper}} we {{describe}} some initial {{investigations into the}} use XML to {{support the use of}} VDM. This presents a snapshot of ongoing work-in-progress, and thoughts to the future development of such work, including transformation into different <b>formats,</b> <b>proof</b> obligation generation, and integration with other formal and semi-formal methods. ...|$|R
40|$|We {{present a}} novel propositional <b>proof</b> tracing <b>format</b> that {{eliminates}} complex processing, thus enabling efficient (formal) proof checking. The {{benefits of this}} format are demonstrated by implementing a proof checker in C, which outperforms a state-of-the-art checker by two orders of magnitude. We then formalize the theory underlying propositional proof checking in Coq, and extract a correct-by-construction proof checker for our format from the formalization. An empirical evaluation using 280 unsatisfiable instances from the 2015 and 2016 SAT competitions shows that this certified checker usually performs comparably to a state-of-the-art non-certified proof checker. Using this format, we formally verify the recent 200 TB proof of the Boolean Pythagorean Triples conjecture...|$|R
5000|$|Phonovision is a <b>proof</b> of concept <b>format</b> and {{experiment}} for recording a mechanical television signal on gramophone records. The format {{was developed in}} the late 1920s in London by Scottish television pioneer John Logie Baird. The objective was not simply to record video, but to record it synchronously, as Baird intended playback from an inexpensive playback device, which he called a [...] "Phonovisor".|$|R
