0|24|Public
50|$|GPUTILS (frequently written gputils) is a GPL-licensed set {{of tools}} for the PIC microcontroller, {{comprising}} an <b>assembler,</b> <b>disassembler,</b> linker, and object file viewer. It is available for various flavors of Unix, Mac OS X, and Microsoft Windows.|$|R
50|$|Lilac, an <b>assembler</b> and <b>disassembler</b> for the Java virtual machine.|$|R
40|$|This paper {{describes}} a methodology for developing processor specific {{tools such as}} <b>assemblers,</b> <b>disassemblers,</b> processor simulators, compilers etc., using processor models in a generic way. The processor models are written in a language called Sim-nML [1] which is powerful enough to capture the instruction set architecture of a processor. We describe a few tools in this paper which can be retargeted to any processor using the high level Sim-nML model of the processor. 1...|$|R
5000|$|... '''''' is {{a command}} in DOS, OS/2 and Microsoft Windows (only in 32bit) {{which runs the}} program debug.exe (or DEBUG.COM in older {{versions}} of DOS). Debug can act as an <b>assembler,</b> <b>disassembler,</b> or hex dump program allowing users to interactively examine memory contents (in assembly language, hexadecimal or ASCII), make changes, and selectively execute COM, EXE and other file types. It also has several subcommands which are used to access specific disk sectors, I/O ports and memory addresses.|$|R
40|$|Project Lissom is {{developing}} environment for design application specific processors or SoC (System on Chip). Project developes tools like <b>assembler,</b> <b>disassembler,</b> simulator, C compiler etc. Environment testing is required and It's {{main reason for}} this work. The work is about software testing, types of testing and about existing testing systems. The inspiration from existing systems is used for design and implementation Lissom testing system. System is comparing tools outputs with reference files. The system needs Bugzilla client end e-mail sender for complete functionality. These tools were also created...|$|R
40|$|In {{embedded}} systems design, strong need exists for generic processor models using which {{a set of}} system specific tool e. g. functional simulator, compiler, <b>assembler,</b> <b>disassembler,</b> code instrumentor can be generated from the processor specification. Sim-nML is one such specification language for describing generic processor models. Design of Sim-nML is aimed at providing more exibility {{and ease of use}} in writing machine descriptions along with the intent to design automatic tool generators for tools like functional simulator, assembler etc. So the way instruction semantics are described in Sim-nML makes it difficult to generate compiler back-end directly from the Sim-nML specification. In thi...|$|R
50|$|The Netwide Assembler (NASM) is an <b>assembler</b> and <b>disassembler</b> for the Intel x86 architecture. It {{can be used}} {{to write}} 16-bit, 32-bit (IA-32) and 64-bit (x86-64) programs. NASM is {{considered}} {{to be one of the}} most popular assemblers for Linux.|$|R
5000|$|Rockwell advertised the $375 AIM-65, with 1K RAM, as an [...] "easy, {{inexpensive}} computer ... for learning, designing, work or just fun". Standard software {{included the}} system console monitor software in ROM, called Advanced Interactive Monitor. It featured an <b>assembler,</b> <b>disassembler,</b> setting and viewing memory and registers, starting execution of other programs and more. Single stepping {{was made possible}} using non-maskable interrupt (NMI). The command prompt was the less-than sign [...] "<", and on receiving a single character command, it added this input character and the greater-than sign [...] ">". If the thermal printer was turned on, this would be output on a single line. The monitor included a number of service routines that could be accessed and used by a user's program to control I/O and code execution, and was fully documented, including source code.|$|R
50|$|A {{disassembler}} is {{a computer}} program that translates machine language into assembly language—the inverse operation to that of an <b>assembler.</b> A <b>disassembler</b> differs from a decompiler, which targets a high-level language rather than an assembly language. Disassembly, the output of a disassembler, is often formatted for human-readability rather than suitability for input to an assembler, making it principally a reverse-engineering tool.|$|R
50|$|OSI/CPM had an assembler, FORTRAN and COBOL compiler, {{but to make}} {{a copy of the}} CP/M, one had to boot in OS-65D to {{copy the}} disk.OS-65D had a Basic Interpreter, <b>Assembler,</b> Editor, <b>Disassembler,</b> and Disk Copy Utility.OS-65U had a Basic Interpreter, and had some simple {{networking}} capability, but assembly programs had to be done in OS-65D and then ported over.|$|R
40|$|Microprocessor support hardware, software, {{and cross}} {{assemblers}} {{relating to the}} Motorola 6800 and 6809 process systems were developed. Pinter controller and intelligent CRT development are discussed. The user's manual, design specifications for the MC 6809 version of the intelligent printer controller card, and a 132 -character by 64 -line intelligent CRT display system using a Motorola 6809 MPU, and a one-line <b>assembler</b> and <b>disassembler</b> are provided...|$|R
50|$|The {{magazine}} published {{two versions}} of the BASIC interpreter: an adapted version of Micro-80 BASIC and a version specially developed for Radio-86RK featuring enhanced editing capabilities, new functions, and other improvements. Other software published in the magazine included <b>assembler,</b> debugger, <b>disassembler,</b> text editor, voice recorder, music editing system. Also, a lot of BASIC programs were published, including calculations for electronic circuits design and games.|$|R
50|$|Without a TANEX board, {{and due to}} {{deliberately}} ambiguous address decoding, {{the address}} $F7F7 would appear to the 6502 {{to have the same}} data as $FFF7. In TANBUG, this is a jump to an internal monitor routine. With TANEX installed, $F7F7 is decoded properly, and that address is an entry point into XBUG. XBUG provided features such as cassette tape loading and saving, a simple <b>assembler</b> / <b>disassembler,</b> hex calculator.|$|R
5000|$|In computing, Yasm is an <b>assembler</b> and <b>disassembler</b> for the Intel x86 architecture. It {{can be used}} {{to write}} 16-bit, 32-bit (IA-32) and 64-bit (x86-64) programs. Yasm is a full rewrite of Netwide Assembler (NASM). Yasm can {{generally}} be used interchangeably with NASM and supports the x86 and x86-64 architectures. It is licensed under a revision of the BSD licenses. [...] it was developed by Peter Johnson and Michael Urman.|$|R
40|$|This {{document}} {{presents the}} design and {{development of a new}} terminal node controller (TNC) and GPS/telemetry beacon for space and ground applications. The techniques developed are unique and innovative in the field of space communication. It outlines the objectives; the system requirements; the system layout; the theory of operation; software; communication protocols, including equipment specifications and other major aspects of the system. An important feature of this system is the extensive use of commercial off the shelf (COTS) components, which has lowered cost and shortened development time. Key words: terminal node controller, TNC, GPS, telemetry, beacon, space communications, satellite, nanosatellite, transmitter, receiver, transceiver, PCM page, APRS, tracking device, spacecraft, <b>packet</b> <b>assembler,</b> protocol decoder, PIC, amateur radio, Ham radio, microcontroller, digipeater, AX. 25, NMEA, Engineering...|$|R
40|$|An {{experimental}} set {{of tools}} that generate instruction set simula-tors, <b>assemblers,</b> and <b>disassemblers</b> from a single description was developed to test if retargetable development tools would work for commercial DSP processors and microprocessors. The processor instruction set was described using a language called nML. The TMS 320 C 50 DSP processor and the ARM 7 microprocessor were modeled in nML. The resulting instruction set models execute about 25, 000 instructions per second, and compiled instruction set simulation models execute about 150, 000 instructions per second. The viability of this approach and the deficiencies of nML are dis-cussed. 1...|$|R
40|$|We {{present in}} this report the formal {{specification}} and verification results of the Memory Manager block of a System-on-a-Chip (SoC) platform Protocol Converter using the model checking tool FormalCheck. The Memory Manager represents the main block of the protocol converter system and is made of five modules, namely, a Memory Manager Controller, an Address Counter Register, a Data Counter Register, a Packet Counter Register and a <b>Packet</b> <b>Assembler.</b> First, we extracted some constraints to define the environment for the Memory Manager. Then we specified a number of relevant liveness and safety properties expressible in FormalCheck and accomplished their verification under the defined set of constraints. Through extensive verification, {{we have been able}} to find a number of bugs in the design that were omitted by simulation. This experience demonstrates the usefulness of formal verification techniques to complement traditional verification by simulation. ...|$|R
40|$|A Digital Signal Processing (DSP) {{application}} can {{be implemented}} {{in a variety of}} ways. The objective of this project is to design an Embedded DSP Processor. The desired processor is run by an instruction set. Such a processor is called an Application Specific Instruction Set Processor (ASIP). ASIP is becoming essential to convergent System on Chip (SoC) Design. Usually there are two approaches to design an ASIP. One of them is at Register Transfer Level (RTL) and another is at just higher level than RTL and is known as Electronic System Level (ESL). Application Description Languages (ADLs) are becoming popular recently because of its quick and optimal design convergence achievement capability during the design of ASIPs. In this project we first concentrate on the implementation and optimization of an ASIP using an ADL known as Language for Instruction Set Architecture (LISA) and CoWare Processor Designer environment. We have written a LISA 2. 0 description of the processor. Given a LISA code, the CoWare Processor Designer (PD) then generates Software Development tools like <b>assembler,</b> <b>disassembler,</b> linker and compiler. A particular application in assembly language to find out the convolution using FIR filter is then run on the processor. Provided that the functionality of the processor is correct, synthesizable RTL for the processor can be generated using Coware Processor Generator. Using the RTL generated, we implemented our processor in the following IC Design technologies: •	Semi-Custom IC Design Technology Here, the RTL is synthesized using Magma Blast Create Tool and the final Layout is drawn using Magma Blast Fusion Tool •	Programmable Logic Device IC Design Technology Here, the processor is dumped to a Field Programmable Gate Array (FPGA). The FPGA used for this purpose is Xilinx Virtex II Pro. ...|$|R
50|$|In 2005, Apple Inc. hired Lattner {{to begin}} work {{bringing}} LLVM to production quality for use in Apple products. Over time, Lattner built out the technology, personally implementing many major new features in LLVM, formed and built a team of LLVM developers at Apple, started the Clang project, took responsibility for evolving Objective-C (contributing to the blocks language feature, and driving the ARC and Objective-C literals features), and nurtured the open source community (leading it through many open source releases). Apple first shipped LLVM-based technology in the 10.5 (and 10.4.8) OpenGL stack as a just-in-time (JIT) compiler, shipped the llvm-gcc compiler in the integrated development environment (IDE) Xcode 3.1, Clang 1.0 in Xcode 3.2, Clang 2.0 (with C++ support) in Xcode 4.0, and LLDB, libc++, <b>assemblers,</b> and <b>disassembler</b> technology in later releases.|$|R
40|$|Dynamic time {{division}} multiplexing (DTDM) is a flexible network transport technique calmhie of handling both continuous and bursty traffic effectively. By employing three different multiplexing ar- chitectures in the network, DTDM permits graceful evolution of the existing circuit switching network into a flexible broadband packet communication network supporting integrated voice, data, and video traffic. The first multiplexing stage uses a <b>packet</b> <b>assembler</b> to multiplex different broadband services into a common DTDM-format serial bit stream. The second multiplexing stage uses a statistical packet mul- tiplexer to concentrate network traffic for more efficient use of trans- mission facilities. A novel architecture for a multiple-input multiple- output statistical packet multiplexer was designed so that the total traffic load of the multiplexer ran be evenly distributed among the output lines and the service priority of each input line can be rearranged dynamically. The third multiplexing stage uSes a synchronous {{time division}} multiplexer for high-speed point-to-point transparent transmission. The multiplexer uses a simple tributary synchronization scheme based on positive and negative block justification, which combines the concept of controlled-slip and bit-stuffing techniques while maintaining information integrity. A generic CMOS LSI chip has been designed {{for use in the}} above three-stage multiplexing system...|$|R
5000|$|There {{are today}} {{throughout}} the world a handful of artists working in a way, which is truly unique in art history. Theirs is an art which separates the makers from the unmakers, the <b>assemblers</b> from the <b>disassemblers,</b> the constructors from the destructors. These artists are destroyers, materialists, and sensualists dealing with process directly. These artists are destructivists and do not pretend to play at God’s happy game of creation; on the contrary, theirs {{is a response to}} the pervading will to kill. It is not the trauma of birth which concerns the destructivist. He understands that {{there is no need for}} magic in living. It is one’s sense of death which needs the life-giving nourishment of transcendental ritual.6 ...|$|R
40|$|A {{simulator}} is {{a powerful}} tool for hardware as well as software development. However, implementing an efficient simulator by hand is a very labour intensive and error-prone task. This paper describes a tool for automatic generation of efficient instruction set architecture (ISA) simulators. A specification file describing the ISA is used as input to the tool. Besides a simulator, the tool also generates an <b>assembler</b> and a <b>disassembler</b> for the architecture. We present a method where statistics is used to identify frequently used instructions. Special versions of these instructions are then created by the tool in order to speed up the simulator. With this technique we have generated a SPARC V 8 simulator which is more efficient than our hand-coded and hand-optimized one. ...|$|R
40|$|In {{this paper}} we {{describe}} the UPFAST system that automatically generates a cycle level simulator, an <b>assembler</b> and a <b>disassembler</b> from a microarchitec-ture specication written in a domain specic language called the Architecture Description Language (ADL). Using the UPFAST system {{it is easy to}} retarget a sim-ulator for an existing architecture to a modied archi-tecture since one has to simply modify the input spec-i cation and the new simulator is generated automat-ically. UPFAST also allows porting of simulators to dierent platforms with minimal eort. We have been able to develop three simulators ranging from simple pipelined processors to complicated out-of-order issue processors over a short period of three months. While the specications of the architectures varied from 5000 to 6000 lines of ADL code, the sizes of automatically generated software varied from 20, 000 to 30, 000 lines of C++ code. The automatically generated simulators are less than 2 times slower than hand coded simula-tors for similar architectures. ...|$|R
40|$|Contemporary SoC design {{involves}} the proper selection of cores from a reference platform. Such selection implies the design exploration of alternative CPUs, which requires {{the generation of}} binary code for each possible target. However, the embedded computing market shows {{a broad spectrum of}} instruction-set architectures, ranging from micro-controllers to RISCs and ASIPs. As a consequence, binary utilities cannot always rely on pre-existent tools within standard packages. Besides, the task of manually retargeting every binary utility is not acceptable under time-to-market pressure. This paper describes a technique model of the target CPU, which can be synthesized from an arbitrary ADL. The technique is based upon two key mechanisms: model provision for tool generation (at the front-end) and automatic library modification (at the backend). To illustrate the technique’s automation effectiveness, we describe the generation of <b>assemblers,</b> linkers and <b>disassemblers.</b> We have successfully compared the files produced by the generated tools to those produced by conventional tools. Moreover, to give proper evidence of retargetability, we present results for MIPS, SPARC, PowerPC and i 8051. ...|$|R

