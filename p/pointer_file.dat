3|62|Public
5000|$|Google Video Player {{was another}} way to view Google videos; it ran on Windows and Mac OS X. The Google Video Player plays back files in Google's own Google Video File (.gvi) media format and {{supported}} playlists in [...] "Google Video Pointer" [...] (.gvp) format. When users downloaded to their computers, the resulting file {{used to be a}} small [...]gvp (<b>pointer)</b> <b>file</b> rather than a [...]gvi file. When run, the [...]gvp file would download a [...]gvi (movie) file to the user's default directory.|$|E
40|$|This {{report is}} a {{technical}} and user manual {{for a computer}} program generating automated form documents. This automated form document generation provides the reader with a technical description of the programs, files, and procedures required to design and process form documents, such as found in the legal profession. Each section details the structure {{of one of the}} four programs that make up the total system. The system consists of four major programs, Text Program, Text Parameter Program, Special Format Program, and Execution Program, and seven files, Text Reference Point File, Text File, Text Parameter File, Special Format <b>Pointer</b> <b>File,</b> Special Format Parameter File, Error File, and Input File. A user???s manual that describes the features {{and the use of the}} program is contained in the appendix...|$|E
40|$|In this work, {{we present}} a {{hardware}} implementation of the encryption algorithm YAEA. The basic notion behind this encryption technique is a sequential search in a random binary file for an octet that represents the ASCII number of the plain-text character. Recording the location of this octet, one is able to assemble a file of near or far pointers to the locations of various octets. Rather inaccurately, we call this file the ciphered text. However, this file contains only pointers to {{the locations of the}} searched octets. Since there is negligible correlation between the <b>pointer</b> <b>file</b> and the plain-text characters, the method, we believe, is robust against any type of cipher attacks. The hardware implementation utilizes Field Programmable Gate Array Technology (FPGA) and the hardware description language VHDL to conclude the realization. The basic micro-architecture of the encryption processor consists of a random binary number generator, an encryption-processing unit and a specially designed sequential memory unit. Furthermore, we demonstrate the results of various performance tests that we have carried out on the architecture. These tests were performed taking into considerations certain real-time applications. KEYWORDS...|$|E
5000|$|In July 2014 <b>Pointer</b> <b>filed</b> {{for divorce}} from Bowen, citing [...] "irreconcilable differences." ...|$|R
50|$|Workflow (or {{concrete}} workflow) containing information both on {{the graph}} structure and on the configuration parameters (input <b>files</b> <b>pointers,</b> output <b>files</b> <b>pointers,</b> executable code and target DCI of workflow nodes).|$|R
40|$|While the I/O {{functions}} {{described in}} the MPI standard included shared <b>file</b> <b>pointer</b> support from the beginning, the performance and portability of these functions have been subpar at best. ROMIO [1], which provides the MPI-IO functionality for most MPI libraries, to this day uses a separate file to manage the shared <b>file</b> <b>pointer.</b> This <b>file</b> provides the shared location that holds the cur-rent value of the shared <b>file</b> <b>pointer.</b> Unfortunately, each access to the shared <b>file</b> <b>pointer</b> involves <b>file</b> lock management and updates to the file contents. Further-more, support for shared <b>file</b> <b>pointers</b> is not universally available because few file systems support native shared <b>file</b> <b>pointers</b> [5] and a few file systems do not support file locks [3]. Application developers rarely use shared <b>file</b> <b>pointers,</b> even though many ap-plications can benefit from this file I/O capability. These applications are typi-cally loosely coupled and rarely exhibit application-wide synchronization. Exam-ples include application tracing toolkits [8, 4] and many-task computing applica...|$|R
40|$|One {{feature that}} the MPI-IO {{interface}} provides is shared <b>file</b> <b>pointers.</b> Ashared <b>file</b> <b>pointer</b> is an offset that is updated by any process accessing the file in this mode. This feature organizes accesses to a file {{on behalf of}} the applicationin such a way that subsequent accesses do not overwrite previous ones. This is particularly useful for logging purposes: it eliminates the need for the applicationto coordinate access to a log file...|$|R
5000|$|The [...] class {{supports}} {{random access}} {{reading and writing}} of files. The class uses a <b>file</b> <b>pointer</b> that represents a byte-offset within the file for the next read or write operation. The <b>file</b> <b>pointer</b> is moved implicitly by reading or writing and explicitly by calling the [...] or [...] methods. The current position of the <b>file</b> <b>pointer</b> is returned by the [...] method.|$|R
50|$|Files are {{composed}} of a file header block, which contains information about the file (size, last access time, data block pointers, etc.), and the data blocks, which contain the actual data. The file header block contains up to BSIZE/4-56 data block pointers (which amounts to 72 entries with the usual 512 byte blocks). If a file is larger than that, file extension blocks will be allocated to hold the data block <b>pointers.</b> <b>File</b> extension blocks are organised in a linked list, which starts in the file header block ('extension' field).|$|R
40|$|AbstractIn {{this paper}} we {{demonstrate}} how {{to prove the}} correctness of systems implemented using low-level imperative features like <b>pointers,</b> <b>files,</b> and socket I/O with respect to high level I/O protocol descriptions by using the Coq proof assistant. We present a web-based course gradebook application developed with Ynot, a Coq library for verified imperative programming. We add a dialog-based I/O system to Ynot, and we extend Ynot’s underlying Hoare logic with event traces to reason about I/O and protocol behavior. Expressive abstractions allow the modular verification of both high level specifications like privacy guarantees and low level properties like data structure pointer invariants...|$|R
40|$|Abstract. In {{this paper}} we {{demonstrate}} {{that it is}} possible to implement certified web systems in a way not much different from writing Standard ML or Haskell code, including use of imperative features like <b>pointers,</b> <b>files,</b> and socket I/O. We present a web-based course gradebook application developed with Ynot, a Coq library for certified imperative programming. We add a dialog-based I/O system to Ynot, and we extend Ynot’s underlying Hoare logic with event traces to reason about I/O behavior. Expressive abstractions allow the modular certification of both high level specifications like privacy guarantees and low level properties like memory safety and correct parsing. ...|$|R
40|$|In {{this paper}} we {{demonstrate}} how {{to prove the}} correctness of systems implemented using lowlevel imperative features like <b>pointers,</b> <b>files,</b> and socket I/O with respect to high level I/O protocol descriptions by using the Coq proof assistant. We present a web-based course gradebook application developed with Ynot, a Coq library for verified imperative programming. We add a dialog-based I/O system to Ynot, and we extend Ynot’s underlying Hoare logic with event traces to reason about I/O and protocol behavior. Expressive abstractions allow the modular verification of both high level specifications like privacy guarantees and low level properties like data structure pointer invariants...|$|R
40|$|Increasingly, file {{systems for}} multiprocessors are {{designed}} with parallel access to multiple disks, to keep I/O from becoming a serious bottleneck for parallel applications. Although file system software can transparently provide high-performance access to parallel disks, a new file system interface is needed to facilitate parallel access to a file from a parallel application. We describe the difficulties faced when using the conventional (Unix-like) interface in parallel applications, and then outline ways to extend the conventional interface to provide convenient access to the file for parallel programs, while retaining the traditional interface for programs that have no need for explicitly parallel file access. Our interface includes a single naming scheme, a multiopen operation, local and global <b>file</b> <b>pointers,</b> mapped <b>file</b> <b>pointers,</b> logical records, multifiles, and logical coercion for backward compatibility. 1 Introduction Multiprocessors have increased in computational power to [...] ...|$|R
50|$|At File system level, ISO 9660 or Universal Disk Format (UDF), no <b>file</b> <b>pointers</b> to {{the label}} area are present.|$|R
5000|$|... fopen uses string flags such as , , [...] and [...] {{and returns}} a <b>file</b> <b>pointer</b> used with fgets, fputs and fclose.|$|R
50|$|SETLL {{causes the}} index <b>pointer</b> for the <b>file</b> named in Factor 2 to be {{positioned}} at the location specified by the value in Factor 1.|$|R
5000|$|The middle tier of the gUSE {{architecture}} {{contains the}} high-level gUSE services. The Workﬂow Storage stores {{every piece of}} information {{that is needed to}} define a workflow (graph structure description, input <b>files</b> <b>pointers,</b> output <b>files</b> <b>pointers,</b> executable code, and target DCI of workflow nodes) except the input files of the workflow. The local input files and the local output files created during workflow execution are stored in the File Storage. The Workﬂow Interpreter is responsible for the execution of workflows, which are stored in the Workﬂow Sto-rage. the Information System holds information for users about workflows running and job status. Users of WS-PGRADE gateways work in isolated workspace, i.e., they see only their own workflows. In order to enable collaboration among the isolated users, the Application Repository stores the WS-PGRADE workflows in one of their five possible stages. (Physically all the five categories are stored as zip files.) The five categories of stored workflows are as follows, and the collaboration among the gateway users is possible via all these categories: ...|$|R
50|$|Images {{stored on}} the server are being encrypted, {{and it is}} not {{possible}} to mass-decrypt images by an administrator. Unless presented with URL, that contains <b>file</b> <b>pointer</b> and decryption key, the file itself cannot be decrypted.|$|R
40|$|The ROMIO {{implementation}} of the MPI-IO standard provides a portable infrastructure for use {{on top of a}} variety of underlying storage targets. These targets vary widely in their capabilities, and in some cases additional effort is needed within ROMIO to support all MPI-IO semantics. Two aspects of the interface that can be problematic to implement are MPI-IO atomic mode and the shared <b>file</b> <b>pointer</b> access routines. Atomic mode requires enforcing strict consistency semantics, and shared <b>file</b> <b>pointer</b> routines require communication and coordination in order to atomically update a shared resource. For some file systems, native locks may be used to implement these features, but not all file systems have lock support. In this work, we describe algorithms for implementing efficient mutex lock...|$|R
40|$|Abstract: The {{fundamental}} idea behind this encryption technique is {{the exploitation of}} DNA cryptographic strength, such as its storing capabilities and parallelism in order to enforce other conventional cryptographic algorithms. In this study, a binary form of data, such as plaintext messages, and images are transformed into sequences of DNA nucleotides. Subsequently, efficient searching algorithms are used to locate the multiple positions of a sequence of four DNA nucleotides. These four DNA nucleotides represent the binary octet of a single plaintext character or the single pixel of an image within, say, a Canis Familiaris genomic chromosome. The process of recording the locations of a sequence of four DNA nucleotides representing a single plain-text character, then returning a single randomly chosen position, {{will enable us to}} assemble a <b>file</b> of random <b>pointers</b> of the locations of the four DNA nucleotides in the searched Canis Families genome. We call the file containing the randomly selected position in the searchable DNA strand for each plain text character, the ciphered text. Since there is negligible correlation between the <b>pointers</b> <b>file</b> obtained from the selected genome, with its inherently massive storing capabilities, and the plain-text characters, the method, we believe, is robust against any type of cipher attacks...|$|R
50|$|In the C {{programming}} language, {{the standard}} input, output, and error streams {{are attached to}} the existing Unix file descriptors 0, 1 and 2 respectively. In a POSIX environment the <unistd.h> definitions STDIN_FILENO, STDOUT_FILENO or STDERR_FILENO should be used instead rather than magic numbers. <b>File</b> <b>pointers</b> stdin, stdout, and stderr are also provided.|$|R
25|$|The {{derivation}} of Exif {{from the}} TIFF file structure using offset <b>pointers</b> in the <b>files</b> means that {{data can be}} spread anywhere within a file, which means that software is likely to corrupt any pointers or corresponding data that it doesn't decode/encode. For this reason most image editors damage or remove the Exif metadata to some extent upon saving.|$|R
40|$|The {{increasing}} {{frequency with which}} serious security flaws are discovered and the increasing rapidity {{with which they are}} exploited have made it necessary for programs to be updated far more frequently than in the past. While binary updates are generally far more convenient than source code updates, the distribution of <b>pointers</b> throughout executable <b>files</b> makes it much harder to produce compact patches. In contrast t...|$|R
40|$|Implementation {{defects in}} file systems {{can lead to}} {{disastrous}} data-loss. This situation has drawn the attention of researchers for a long time, yet file system bugs are still very common [4, 6, 8]. Even well established file systems like Ext 2 and Ext 3, which have not been extended with new features for years, occasionally get patched to fix implementation flaws[3]. Previous work on file system verification was mostly based on model checking[4, 6, 8] which aims at preventing certain classes of bugs such as buffer overflows or NULL <b>pointer</b> dereferences. <b>File</b> systems are central part of operating systems, expectations from such critical components go beyond the mere absence of generic programming errors. The usual approach to obtain functional correctness guarantees is to prove the implementation correct using an interactiv...|$|R
50|$|Another notable feature was the {{combined}} use {{of both a}} command-line interface and graphical user interface. AmigaDOS was the disk operating system and command line portion of the OS and Workbench the native graphical windowing, icons, menu and <b>pointer</b> environment for <b>file</b> management and launching applications. Notably, AmigaDOS allowed long filenames (up to 107 characters) with whitespace and did not require filename extensions. The windowing system and user interface engine which handles all input events is called Intuition.|$|R
50|$|The same file may {{be opened}} {{simultaneously}} by several processes, and {{even by the}} same process (resulting in several file descriptors for the same file) depending on the file organization and filesystem. Operations on the descriptors such as moving the <b>file</b> <b>pointer</b> or closing it are independent (they do not affect other descriptors for the same file). Operations on the file (like a write) {{can be seen by}} operations on the other descriptors (a posterior read can read the written data).|$|R
50|$|On the server, eyeOS uses XML {{files to}} store information. This makes it simple for a user {{to set up}} on the server, as it {{requires}} zero configuration other than the account information for the first user, making it simple to deploy. To avoid bottlenecks that flat files present, each user's information and settings are stored in different files, preventing resource starvation from occurring; Though this in turn may create issues in high volume user environments due to host operating system open <b>file</b> <b>pointer</b> limits.|$|R
40|$|This {{appendix}} {{provides a}} complete set of the PDS catalog objects. Each section includes a description of the object, lists of keywords and sub-objects, guidelines to follow in assigning values, and a specific example of the object. The catalog objects provide high-level information suitable for loading a database to facilitate searches across data sets, collections and volumes. The catalog objects included on a PDS volume also provide local, high-level documentation. The full set of catalog objects is required in the CATALOG directory of every PDS archive volume. See the File Specification and Naming chapter of this document for <b>pointer</b> and <b>file</b> names used with catalog objects. Not every object described in this section is required in all cases. A PDS Central Node Data Engineer will supply a set of blank catalog object templates to be completed for any specific delivery, and can also supply additional examples if desired...|$|R
40|$|Thanks to MPI [9], writing {{portable}} {{message passing}} parallel programs {{is almost a}} reality. One of the remaining problems is file I/ 0. Although parallel file systems support similar interfaces, {{the lack of a}} standard makes developing a truly portable program impossible. Further, {{the closest thing to a}} standard, the UNIX file interface, is ill-suited to parallel computing. Working together, IBM Research and NASA Ames have drafted MPI-I 0, a proposal to address the portable parallel I/ 0 problem. In a nutshell, this proposal is based on the idea that I/ 0 can be modeled as message passing: writing to a file is like sending a message, and reading from a file is like receiving a message. MPI-IO intends to leverage the relatively wide acceptance of the MPI interface in order to create a similar I/ 0 interface. The above approach can be materialized in different ways. The current proposal represents the result of extensive discussions (and arguments), but is by no means finished. Many changes can be expected as additional participants join the effort to define an interface for portable I/ 0. This document is organized as follows. The remainder of this section includes a discussion of some issues that have shaped the style of the interface. Section 2 presents an overview of MPI-IO as it is currently defined. It specifies what the interface currently supports and states what would need to be added to the current proposal to make the interface more complete and robust. The next seven sections contain the interface definition itself. Section 3 presents definitions and conventions. Section 4 contains functions for file control, most notably open. Section 5 includes functions for independent I/O, both blocking and nonblocking. Section 6 includes functions for collective I/O, both blocking and nonblocking. Section 7 presents functions to support system-maintained <b>file</b> <b>pointers,</b> and shared <b>file</b> <b>pointers.</b> Section 8 presents constructors that can be used to define useful filetypes (the role of filetypes is explained in Section 2 below). Section 9 presents how the error handling mechanism of MPI is supported by the MPI-IO interface. All this is followed by a set of appendices, which contain information about issues that have not been totally resolved yet, and about design considerations. The reader can find there the motivation behind some of our design choices. More information on this would definitely be welcome and will be included in a further release of this document. The first appendix contains a description of MPI-I 0 's 'hints' structure which is used when opening a file. Appendix B is a discussion of various issues in the support for <b>file</b> <b>pointers.</b> Appendix C explains what we mean in talking about atomic access. Appendix D provides detailed examples of filetype constructors, and Appendix E contains a collection of arguments for and against various design decisions...|$|R
25|$|Because of the {{particular}} characteristics of flash memory, it is best used with either a controller to perform wear leveling and error correction or specifically designed flash file systems, which spread writes over the media {{and deal with the}} long erase times of NORflash blocks. The basic concept behind flash file systems is the following: when the flash store is to be updated, the file system will write a new copy of the changed data to a fresh block, remap the <b>file</b> <b>pointers,</b> then erase the old block later when it has time.|$|R
40|$|Learn {{the basics}} of {{programming}} with C with this fun and friendly guide! C offers a reliable, strong foundation for programming {{and serves as a}} stepping stone upon which to expand your knowledge and learn additional programming languages. Written by veteran For Dummies author Dan Gookin, this straightforward-but-fun beginner's guide covers the fundamentals of using C and gradually walks you through more advanced topics including <b>pointers,</b> linked lists, <b>file</b> I/O, and debugging. With a special focus on the subject of an Integrated Development Environment, it gives you a solid understanding o...|$|R
5000|$|As {{mentioned}} in Section 3.2 above, a directory entry contains only {{a name for}} the associated <b>file</b> and a <b>pointer</b> to the <b>file</b> itself. This <b>pointer</b> is an integer called the i-number (for index number) of the file. When the file is accessed, its i-number is used as an index into a system table (the i-list) stored in a known part of the device on which the directory resides. The entry found thereby (the file's i-node) contains the description of the file:... The UNIX Time-Sharing System, The Bell System Technical Journal, 1978 ...|$|R
40|$|Backup Metadata As Data (MAD) is a user-level {{solution}} that enables commodity file systems to replicate their critical metadata and {{to recover from}} disk pointer corruptions. More specifically, it extracts disk <b>pointers</b> from <b>file</b> system and saves them as user data. When some data blocks become inaccessible due to pointer corruptions, Backup MAD re-stores access paths to them either by copying the blocks to another file system or by di-rectly updating on-disk structures of file system. The latter technique helps Backup MAD restore lost files faster than any other recovery solution because data blocks are not moved during restoration. Also, as the technique relies on disk pointers extracted from a consis-tent file system state, it can rescue up to 50 % more files than a scan-based recovery tool that infers block dependencies from a corrupted partition. We demonstrate the effective-ness of our technique by two real implementations, MAD-NTFS and MAD-ext 2. Backup MAD enhances dependability of file system by protecting disk pointers on behalf of file system...|$|R
5000|$|A File Record stores {{a variety}} of {{metadata}} about the file including its CNID, {{the size of the}} file, three timestamps (when the file was created, last modified, last backed up), the first file extents of the data and resource forks and <b>pointers</b> to the <b>file's</b> first data and resource extent records in the Extent Overflow File. The File Record also stores two 16 byte fields that are used by the Finder to store attributes about the file including things like its creator code, type code, the window the file should appear in and its location within the window.|$|R
40|$|Recent {{measurement}} {{studies of}} file-sharing peer-to-peer networks {{have demonstrated the}} presence of semantic proximity between peers and between shared files. In this paper we tackle the problem of exploiting the semantic locality of peer requests to improve {{the performance of a}} P 2 P network by the use of semantic caches. Such caches group together peers with similar interests as well as files with similar request patterns. The resulting two-level caching infrastructure can be integrated in a very natural way with the superpeer concept. The super-peers in our system cache <b>pointers</b> to <b>files</b> recently requested by their client peers. The client peers, on the other hand, keep caches of super-peers that answered most of their requests in the past. As a consequence, peers with similar interests are grouped (clustered) under the same super-peers, and also files with similar request patterns are indexed by the same super-peers. We discuss the design choices and optimizations of the presented model. We also evaluate our system versus the network that uses only one level of semantic caches. 1...|$|R
40|$|Abstract. Some recent {{measurement}} {{studies of}} file-sharing peer-to-peer networks {{have demonstrated the}} presence of semantic proximity between peers and between shared files. This observation {{may be used for}} improving the performance of searching by introducing semantic caches. One type of such caches links peers that are interested in similar files. The query routing mechanism uses this information by forwarding queries first to peers which are semantically close. The second type of semantic caches groups similar content instead of similar nodes. In this paper we show how to combine both methods by introducing a two-level caching infrastructure based on super-peers. The super-peers in our system cache <b>pointers</b> to <b>files</b> recently requested by their client peers. The client peers, on the other hand, constantly look for the super-peers that are most suitable for them. We propose a simple, yet powerful cache management policy that guarantees high cache hit ratios also for the less popular files. Further, we discuss the design choices and optimizations of the presented model. Finally, we evaluate our system versus the symmetric network that uses only one level of semantic caches. ...|$|R
