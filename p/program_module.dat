179|1114|Public
5000|$|CE-1600M <b>program</b> <b>module</b> {{providing}} 32K of battery backed storage ...|$|E
5000|$|... domain object {{represents}} a <b>program</b> <b>module</b> and contains references to subroutines and data ...|$|E
50|$|A process module, like a <b>program</b> <b>module,</b> {{has only}} an {{initialization}} section, and runs its start, full function and completion in that section. However, it gets its own thread for execution {{aside from the}} main thread that runs program modules. As such, it can only call monitor and share modules.|$|E
40|$|Abstract. Software {{understanding}} tools involve program modularization and visualization capabilities. However provided <b>program</b> <b>modules</b> do {{not always}} represent the accurate structure. Formal Concept Analysis and concept partition are methods to identify desirable <b>program</b> <b>modules.</b> Using concept partition, we define concept partitions to provide optimal <b>program</b> <b>modules</b> for software understanding. The optimality and applicability of our modularization method are illustrated with experimental results using C programs. ...|$|R
40|$|This paper {{looks at}} an {{artificial}} intelligence control program {{required for a}} system which accepts queries to a data base which consists of both data and <b>program</b> <b>modules.</b> Using a problem solving approach, the data base structure and the <b>program</b> <b>modules</b> specify the initial world model. The operators consist of functions which look through sets in the data base and the actual <b>program</b> <b>modules</b> themselves. The goal is the query which requests data and/or processes. The control program determines the path which maps through the data base and the <b>program</b> <b>modules</b> in a manner which satisfies the predicate calculus constraints and the goal. Real examples of how this system is being used for a large scale data base is included...|$|R
50|$|Finally, it has {{mechanisms}} for creating and managing <b>program</b> <b>modules</b> whose internal functions are invisible to <b>programs</b> calling those <b>modules.</b>|$|R
50|$|In the V-Model, Unit Test Plans (UTPs) are {{developed}} during module design phase. These UTPs are executed to eliminate bugs at code level or unit level. A unit {{is the smallest}} entity which can independently exist, e.g. a <b>program</b> <b>module.</b> Unit testing verifies that the smallest entity can function correctly when isolated {{from the rest of}} the codes/units.|$|E
50|$|In {{computer}} programming, {{a message}} broker is an intermediary <b>program</b> <b>module</b> that translates {{a message from}} the formal messaging protocol of the sender to the formal messaging protocol of the receiver. Message brokers are elements in telecommunication or computer networks where software applications communicate by exchanging formally-defined messages. Message brokers are a building block of message-oriented middleware.|$|E
5000|$|YGLP {{is based}} on the Four Step Leadership Theory {{formulated}} at Human Science Lab. According to the theory “the leadership achievement of an individual is proportional to the optimal use of four principal components that makes a leader - motivation, planning, energising and executing”. YGLP is designed to optimise this four key leadership component with each <b>program</b> <b>module</b> focusing on a single component.|$|E
50|$|Library Management, {{including}} promoting and demoting <b>program</b> <b>modules.</b>|$|R
40|$|A manual is {{presented}} for correctly submitting program runs in aerodynamics on the UNIVAC 1108 computer system. All major <b>program</b> <b>modules</b> are included. Control cards are documented for the user's convenience, and card parameters {{are included in}} order to provide some idea as to reasonable time estimates for the <b>program</b> <b>modules...</b>|$|R
40|$|One of the {{greatest}} areas of difficulty in the acquisition and installation of Hospital Information Systems is the system testing and validation. These systems are complex, consisting {{of a large number}} of <b>program</b> <b>modules.</b> These <b>program</b> <b>modules</b> tend to have a high degree of dependency upon one another and the system's data files...|$|R
50|$|RUCAPS {{consisted}} of 38 different programs. For example, {{there was a}} program to generate the geometry for building components, another to assemble them into groups, and another to assemble those sub-assemblies into {{a model of the}} building. A dozen or more modules took care of printing, copying of floors, printing schedules, and so on. In the way of the time, the user directed operations by calling up the relevant <b>program</b> <b>module</b> rather than, as today, selecting from a menu.|$|E
50|$|Transient also {{refers to}} a module that, once loaded into main memory, is {{expected}} to remain in memory for a short time. Today, the term is rarely used, and may be obsolete. The term Overlay is commonly used instead, and refer to a <b>program</b> <b>module</b> that is brought to memory when it is needed by the running program and then replaced with another when {{it is no longer}} needed, so a program had lower memory requirements. Program modules were written to allow different modules to share the same memory region and the main program itself was responsible of exchanging modules between disk and memory as necessary.|$|E
50|$|The branch {{instructions}} include conditional and unconditional relativebranches. A branch {{using the}} address in a register is provided; arelative branch which adds a scaled register operand to the programcounter is provided to support jump tables. Branches {{to up to}} instructions distance are encoded in a single word.The procedure calling instructions include relative calls, calls via theconstant pool, indexed calls via a dedicated register and calls via aregister. Most calls within a single <b>program</b> <b>module</b> can be encoded in asingle instruction; inter-module calling requires at most two instructions.It {{is up to the}} callee to save the link-register if it is not a leaf-function, a single instruction extends the stack and saves the link register.|$|E
40|$|In the {{development}} of integrated software systems for assisting engineers {{in the design of}} structure particular program are often observed to be similar to a large extent. To reduce development costs these <b>program</b> <b>modules</b> should be designed for reusability. The design of such <b>program</b> <b>modules</b> is supported by so-called design patterns. They provide instructions and guidelines for supported by so-called design patterns. They provide instructions and guidelines for conceiving reusable <b>program</b> <b>modules</b> and for allowing programmers to utilize the experience of design experts. This thesis presents two interdependent desing patterns for the design of integrated software systems which especially emphasize reusability of <b>program</b> <b>modules.</b> The application of the developed design patterns is then shown in the field of structural analysis by the implementation of a reusable structural analysis module. Examples are provided to demonstrate the feasability of the implemented system. (orig.) Available from TIB Hannover: RA 3043 (96 - 1) / FIZ - Fachinformationszzentrum Karlsruhe / TIB - Technische InformationsbibliothekSIGLEDEGerman...|$|R
5000|$|F {{places a}} heavy {{emphasis}} on modular <b>programming.</b> <b>Modules</b> in F are called [...] "programs": ...|$|R
5000|$|Xpediter/Xchange {{provides}} {{full support}} for multiple date access methods without requiring any {{changes to the}} <b>program</b> <b>modules</b> or JCL ...|$|R
5000|$|Ciao {{provides}} a full Prolog system (supporting ISO-Prolog),declarative subsets and extensions of Prolog, functional programming (including lazy evaluation), higher-order (with predicate abstractions), constraint programming, and objects, {{as well as}} feature terms(records), persistence, several control rules (breadth-first search, iterative deepening, ...), concurrency (threads/engines), distributed execution (agents), and parallel execution. Libraries also support WWW programming, sockets, external interfaces (C, Java, TclTk, relational databases, etc.), etc. Ciao is built on a kernel with an extensible modular design whichallows both restricting and extending the language — {{it can be seen}} as a language building language. These restrictions and extensions can be activated separately on each <b>program</b> <b>module</b> so that several extensions can coexist in the same application for different modules.|$|E
5000|$|In 2013, Iași International Airport {{started a}} long-term, {{multi-stage}} upgrade <b>program.</b> <b>Module</b> I {{of the project}} (an estimated €57 million investment) was completed in November 2015, and involved {{the construction of a}} new runway, a terminal building, and the extension of the apron. On 20 August 2014, the first 1800 m of the new runway 14/32 went into operation, whilst the entire length of 2400 m became fully operational on 16 October 2014. The old runway 15/33 was converted into a taxiway. On 17 October 2015, the third terminal building (T3) with a processing capacity of 320 pax/hour, was inaugurated. A project which includes the expansion of T2 (that would double the terminal's area) was also proposed, in October 2015.|$|E
50|$|A {{common cause}} of {{software}} failure (real or perceived) {{is a lack of}} its compatibility with other application software, operating systems (or operating system versions, old or new), or target environments that differ greatly from the original (such as a terminal or GUI application intended to be run on the desktop now being required to become a web application, which must render in a web browser). For example, {{in the case of a}} lack of backward compatibility, this can occur because the programmers develop and test software only on the latest version of the target environment, which not all users may be running. This results in the unintended consequence that the latest work may not function on earlier versions of the target environment, or on older hardware that earlier versions of the target environment was capable of using. Sometimes such issues can be fixed by proactively abstracting operating system functionality into a separate <b>program</b> <b>module</b> or library.|$|E
40|$|Assessment plays a very {{important}} role in how students learn. There has been extensive research done on different modes of assessments in higher education. This paper reports on how that research applies to <b>programming</b> <b>modules</b> in Software Engineering education. The paper also discusses the author’s experience and the student perceptions of several assessment modes in <b>programming</b> <b>modules.</b> A questionnaire survey was conducted among 167 undergraduate computing students to get their perceptions on the preferred mode of assessment for <b>programming</b> <b>modules</b> in Software Engineering education. The paper also investigates the effect automated marking systems could have on programming assessments by gathering student perceptions. Student perceptions sought reveal that they would complete more weekly lab exercises if they were to get instant feedback on their submissions from an automated tool...|$|R
50|$|Though {{useful for}} {{planning}} <b>programs,</b> <b>modules</b> and routines, or describing algorithms {{it is less}} useful when numerous decisions need to be made.|$|R
40|$|AbstractAs the {{existence}} of objective and subjective factors in developing software, changes in requirements is inevitable, often lead to changes in <b>program</b> <b>modules</b> also. Because of correlation among <b>program</b> <b>modules,</b> to modify a module may lead errors to related modules. Put forward to establish association diagrams of modules, and use methods of traversal of graphs, to fast track, positioning error or affected modules, and narrow test range, to some extent which improve the efficiency of software testing...|$|R
5000|$|A {{compiler}} {{can thus}} make {{almost all the}} conversions from source code semantics to the machine level {{once and for all}} (i.e. until the program has to be changed) while an interpreter has to do some of this conversion work every time a statement or function is executed. However, in an efficient interpreter, much of the translation work (including analysis of types, and similar) is factored out and done only the first time a <b>program,</b> <b>module,</b> function, or even statement, is run, thus quite akin to how a compiler works. However, a compiled program still runs much faster, under most circumstances, in part because compilers are designed to optimize code, and may be given ample time for this. This is especially true for simpler high level languages without (many) dynamic data structures, checks, or type-checks. In traditional compilation, the executable output of the linkers (.exe files or [...]dll files or a library, see picture) is typically relocatable when run under a general operating system, much like the object code modules are but with the difference that this relocation is done dynamically at run time, i.e. when the program is loaded for execution. On the other hand, compiled and linked programs for small embedded systems are typically statically allocated, often hard coded in a NOR flash memory, as there are often no secondary storage and no operating system in this sense. Historically, most interpreter-systems have had a self-contained editor built in. This is becoming more common also for compilers (then often called an IDE), although some programmers prefer to use an editor of their choice and run the compiler, linker and other tools manually. Historically, compilers predate interpreters because hardware at that time could not support both the interpreter and interpreted code and the typical batch environment of the time limited the advantages of interpretation.|$|E
5000|$|The {{following}} example opens {{an employee}} table ("empl"), gives every manager who supervises 1 or more employees a 10-percent raise, and then prints {{the names and}} salaries. USE empl REPLACE ALL salary WITH salary * 1.1 FOR supervisors > 0 LIST ALL fname, lname, salary TO PRINT * (comment: reserved words shown in CAPITALS for illustration purposes)Note how {{one does not have}} to keep mentioning the table name. The assumed ("current") table stays the same until told otherwise. Because of its origins as an interpreted interactive language, dBase used a variety of contextual techniques {{to reduce the amount of}} typing needed. This facilitated incremental, interactive development but also made larger-scale modular programming difficult. A tenet of modular programming is that the correct execution of a <b>program</b> <b>module</b> must not be affected by external factors such as the state of memory variables or tables being manipulated in other program modules. Because dBase was not designed with this in mind, developers had to be careful about porting (borrowing) programming code that assumed a certain context and it would make writing larger-scale modular code difficult. Work-area-specific references were still possible using the arrow notation ("B->customer") so that multiple tables could be manipulated at the same time. In addition, if the developer had the foresight to name their tables appropriately, they could clearly refer to a large number of tables open at the same time by notation such as ("employee->salary") and ("vacation->start_date"). Alternatively, the alias command could be appended to the initial opening of a table statement which made referencing a table field unambiguous and simple. For example. one can open a table and assign an alias to it in this fashion, [...] "use EMP alias Employee", and henceforth, refer to table variables as [...] "Employee->Name".|$|E
40|$|A {{method for}} statically {{checking}} an object-oriented computer <b>program</b> <b>module</b> includes the step of identifying objects within a computer <b>program</b> <b>module,</b> {{at least one}} of the objects having a plurality of references thereto, possibly from multiple clients. A discipline of permissions is imposed on the objects identified within the computer <b>program</b> <b>module.</b> The permissions enable tracking, from among a discrete set of changeable states, a subset of states each object might be in. A determination is made regarding whether the imposed permissions are violated by a potential reference to any of the identified objects. The results of the determination are output to a user...|$|E
5000|$|Many home {{automation}} systems {{are ready to}} use with Integra products {{out of the box}} or have support or <b>programming</b> <b>modules</b> available for Integra products ...|$|R
40|$|Program {{partitioning}} {{is a task}} of splitting a large, complex {{software system}} into functionally independent <b>program</b> <b>modules.</b> It is a key step in program understanding, software maintenance and software reuse. Traditional program partitioning methods are nonlinear. In most cases, the computational efforts needed for partitioning a source program will increase exponentially {{with the size of}} the source program. The NP-hard complexity constitutes a computational barrier for partitioning legacy software systems properly and efficiently. In this paper, we propose a new method that can partition a source <b>program</b> into <b>program</b> <b>modules</b> within a timescale that is linear with the size of the program. Our method uses special heuristic knowledge, based on psychological analysis on human programming styles, to partition a source program into domain-oriented <b>program</b> <b>modules.</b> A case study on a legacy C program that consists of 92 functions is reported to demonstrate the efficiency and effectiveness of this method...|$|R
5000|$|Cartridge slot (44-pin slot for edge {{connector}} with 6510 CPU address/data bus lines and control signals, {{as well as}} GND and voltage pins; used for <b>program</b> <b>modules)</b> ...|$|R
30|$|The program {{adopts a}} modular design. Each <b>program</b> <b>module</b> can operate on one machine or more as needed. Data can be {{exchanged}} via network communication between modules.|$|E
40|$|This {{document}} {{describes the}} algorithms and mechanisms of the MODEL Processor, {{which is a}} software system performing a program writing function. It also documents the program structure and procedures of the Processor. The MODEL Processor {{has been designed to}} automate the program design, coding and debugging of software development, based on a non-procedural specifications of a <b>program</b> <b>module</b> in the MODEL language. A <b>program</b> <b>module</b> is formally described and specified in the MODEL language, whose statements are then submitted to the Processor. The set of MODEL statements describing a <b>program</b> <b>module</b> is referred to as a specification. The Processor, performs the analysis (including checking for the completeness and consistency of the entire specification), <b>program</b> <b>module</b> design (including generating a flowchart-like sequence of events for the module), and code generation functions, thus replacing the tasks of an application programmer/coder. The Processor 2 ̆ 7 s capability to process a non-procedural specification language is built on application of graph theory to the analysis of such specification and to the program generation task. Another important function of the Processor is to interact with the specifier to indicate necessary supplements or changes to the submitted statements. The Processor produces a complete PL/ 1 program ready for compilation as well as various reports concerning the specification and the generated program. The Processor output reports include a listing of the specification, a cross-reference report, subscript range report, a flowchart-like report of the generated program, and a listing of the generated program...|$|E
40|$|Results on {{modeling}} of electronic information resources of {{training on the}} basis of Wiki-technologies are presented. Application of such model is illustrated on an example of working out of the <b>program</b> <b>module</b> of distance learning system «Kherson virtual university» for creation and use of Wiki-documents...|$|E
40|$|Abstract: Performance in {{computer}} <b>programming</b> <b>modules</b> at Higher Education Institutions {{has traditionally been}} low. Within the context of world-wide shortages of skilled programmers, it becomes imperative that greater success is achieved in HEIs. The low success rate in <b>programming</b> <b>modules</b> is ascribed to the abstract nature and content of programming courses, and the inadequacy of pre-university education {{to prepare students for}} the cognitive skills required for success in such courses. This study identifies and relates the pre-entry attributes of students at universities in Johannesburg and Pretoria, South Africa before enrolling for computer programming courses. In the quest for identifying those attributes that may have impacted on student success in the <b>programming</b> <b>modules,</b> their problem solving ability, socio-economic status, educational background, performance in school mathematics, English language proficiency, digital literacy and previous programming experience, were explored using a survey research method. The dataset comprised of four programming aptitude tests, a student profile questionnaire and Development Software 1 examination results of 379 students studying the National Diploma Business Information Technology at a Johannesburg City University* (JCU) and the National Diploma Information Technology at a Pretoria City University* (PCU). The data analysed indicates that there is a correlation between the variables problem solving, digital literacy and previous programming experience and performance in <b>programming</b> <b>modules.</b> There was no correlation found between the variables socio-economic status, educational background, Grade 12 mathematics marks and Grade 12 English marks and performance in <b>programming</b> <b>modules.</b> The research concluded that the marks achieved for school mathematics and English cannot be considered as a valid admission criterion for programming courses in the South African context and an alternate requirement should be found. Ph. D...|$|R
40|$|A Monte Carlo {{simulation}} {{program for}} the modeling of image formation in scanning electron microscopy is presented. A key feature {{of the program is}} its modular design, so the different aspects of image formation (i. e. forming of the electron probe, specimen topography model, probe-sample-interaction, electron detector model, image processing) are arranged in separate <b>program</b> <b>modules.</b> The <b>program</b> is written in C++ and uses object-oriented programming techniques. Data exchange between the different <b>program</b> <b>modules</b> is performed by defined software interfaces. Thus, third party simulation code can easily be integrated into the program...|$|R
40|$|Developed {{have been}} the methods of {{structure}} of all-modes model of the heat-exchange processed in the heat-exchanger: the recurrence integral design formulae, the combined networks of discretization have been obtained. The <b>program</b> <b>modules</b> of the method realization in the Pascal language for the personal computer have been developed, {{they can be used}} in the design, adjustment, research and training problems of the dynamic models of the power heat-exchengers. The <b>program</b> <b>modules</b> have been used in the designs of the real heat-exchangersAvailable from VNTIC / VNTIC - Scientific & Technical Information Centre of RussiaSIGLERURussian Federatio...|$|R
