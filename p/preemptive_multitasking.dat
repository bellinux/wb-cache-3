137|18|Public
25|$|On many {{single user}} {{operating}} systems cooperative multitasking is perfectly adequate, as home computers generally run {{a small number}} of well tested programs. The AmigaOS is an exception, having <b>preemptive</b> <b>multitasking</b> from its very first version. Windows NT was the first version of Microsoft Windows which enforced <b>preemptive</b> <b>multitasking,</b> but it didn't reach the home user market until Windows XP (since Windows NT was targeted at professionals).|$|E
25|$|Introduction of {{operating}} systems with <b>preemptive</b> <b>multitasking</b> and windowing capabilities and menu-driven user interfaces (with Digital Research): MP/M, Concurrent CP/M, Concurrent DOS, DOS Plus, FlexOS, GEM, ViewMAX.|$|E
25|$|A single-tasking {{system can}} only run one {{program at a}} time, while a multi-tasking {{operating}} system allows more than one program to be running in concurrency. This is achieved by time-sharing, dividing the available processor time between multiple processes that are each interrupted repeatedly in time slices by a task-scheduling subsystem of the operating system. Multi-tasking may be characterized in preemptive and co-operative types. In <b>preemptive</b> <b>multitasking,</b> the operating system slices the CPU time and dedicates a slot {{to each of the}} programs. Unix-like operating systems, e.g., Solaris, Linux, as well as AmigaOS support <b>preemptive</b> <b>multitasking.</b> Cooperative multitasking is achieved by relying on each process to provide time to the other processes in a defined manner. 16-bit versions of Microsoft Windows used cooperative multi-tasking. 32-bit versions of both Windows NT and Win9x, used preemptive multi-tasking.|$|E
40|$|Cache {{memories}} {{are widely used}} to improve computer performance, but their inherent unpredictability presents new problems when cached systems must be analysed. In <b>preemptive,</b> <b>multitask</b> real-time systems, the cache memories have been analysed from two complementary points of view. First, calculating the Worst Case Execution Time #WCET# of each task considering no preemptions. Second, making the schedulability analysis considering the e#ect of cache when tasks are preempted...|$|R
40|$|Unpredictable {{behavior}} of cache memory {{makes it difficult}} to statically analyze the worst-case performance of real-time systems. This problem is exacerbated in case of <b>preemptive</b> <b>multitask</b> systems due to intertask cache interference, called Cache-Related Preemption Delay (CRPD). This paper proposes an approach to analysis of the tight upper bound on CRPD which a task might impose on lower-priority tasks. Our method determines the program execution path of the task which requires the maximum number of cache blocks using an integer linear programming technique. Experimental results show that our approach provides up to 69 % tighter bounds on CRPD than a previous approach...|$|R
50|$|DioneOS (pronounced /djoneos/) is <b>multitasking</b> <b>preemptive,</b> {{real-time}} operating system. The {{system is}} designed for Texas Instruments MSP430x microcontrollers.|$|R
25|$|As a {{sophisticated}} computer for its day (Amiga used 25 DMA channels and a coprocessor), Sassenrath {{decided to create}} a <b>preemptive</b> <b>multitasking</b> operating system within a microkernel design. This was a novel approach for 1983 when other personal computer operating systems were single tasking such as MS-DOS (1981) and the Macintosh (1984).|$|E
25|$|Copland is an {{unreleased}} {{operating system}} prototype for Apple Macintosh computers {{of the late}} 1990s, intended to be released as the modern System 8 successor to the aging but venerable System 7. It introduced protected memory, <b>preemptive</b> <b>multitasking,</b> {{and a number of}} new underlying operating system features, while retaining compatibility with existing Mac applications. Copland's planned successor, codenamed Gershwin, was intended to add advanced features such as application-level multithreading.|$|E
25|$|Generally {{considered}} a failure, the Lisa nevertheless introduced {{a number of}} advanced features that would not re-appear on the Macintosh {{for a number of}} years. Among these was an operating system which featured protected memory and <b>preemptive</b> <b>multitasking,</b> and a more document-oriented workflow. The hardware itself was also much more advanced than the Macintosh, with a hard drive and support for up to 2megabytes (MB) of RAM, expansion slots and a larger higher-resolution display. The main exception being that while the Macintosh also used the 68000 processor, the Macintosh initially used a version clocked at 7.89Mhz, compared to the 5Mhz version used in the Lisa. The complexity of the Lisa operating system and its associated programs overtaxed the slower processor enough that users perceived it to be sluggish, particularly when scrolling in documents.|$|E
40|$|The {{networked}} application {{environment has}} motivated {{the development of}} multitasking operating systems for sensor networks and other low-power electronic devices, but their multitasking capability is severely limited because traditional stack management techniques perform poorly on small-memory systems without virtual memory support. In this paper, we show that combining binary translation and a new kernel runtime can lead to efficient OS designs on resource constrained platforms. We introduce SenSmart, a multitasking OS for sensor networks, and present new OS design techniques for supporting <b>preemptive</b> <b>multitask</b> scheduling, memory isolation, and adaptive stack management. Our solution provides memory isolation and automatic stack relocation on usual sensornet platforms. The adaptive stack management frees programmers from the burden of estimating tasks' stack usage, yet it enables SenSmart to schedule and run more tasks than other multitasking OSes for sensor networks. We have implemented SenSmart on MICA 2 /MICAz motes. Evaluation shows that SenSmart has a significantly better capability in managing concurrent tasks than other sensornet operating systems...|$|R
40|$|Abstract—The {{networked}} application {{environment has}} motivated {{the development of}} multitasking operating systems for sensor networks and other low-power electronic devices, but their multitasking capability is severely limited because traditional stack management techniques perform poorly on small-memory systems without virtual memory support. In this paper, we show that combining binary translation and a new kernel runtime can lead to efficient OS designs on resource constrained platforms. We introduce SenSmart, a multitasking OS for sensor networks, and present new OS design techniques for supporting <b>preemptive</b> <b>multitask</b> scheduling, memory isolation, and adaptive stack management. Our solution provides memory isolation and automatic stack relocation on usual sensornet platforms. The adaptive stack management frees programmers from the burden of estimating tasks’ stack usage, yet it enables SenSmart to schedule and run more tasks than other multitasking OSes for sensor networks. We have implemented SenSmart on MICA 2 /MICAz motes. Evaluation shows that SenSmart has a significantly better capability in managing concurrent tasks than other sensornet operating systems. Index Terms—Multitasking, memory management, stack adaptivity, binary translation, kernel...|$|R
40|$|In <b>multitask,</b> <b>preemptive</b> {{real-time}} systems, {{the use of}} cache memories make difficult {{the estimation}} of the response time of tasks, due to the dynamic, adaptive and nonpredictable behaviour of cache memories. But many embedded and critical applications need the increase of performance provided by cache memories...|$|R
25|$|The Virtual Machine Manager (VMM) is the 32-bit {{protected}} mode kernel {{at the core}} of Windows 9x. Its primary responsibility is to create, run, monitor and terminate virtual machines. The VMM provides services that manage memory, processes, interrupts and protection faults. The VMM works with virtual devices (loadable kernel modules, which consist mostly of 32-bit ring 0 or kernel mode code, but may include other types of code, such as a 16-bit real mode initialisation segment) to allow those virtual devices to intercept interrupts and faults to control the access that an application has to hardware devices and installed software. Both the VMM and virtual device drivers run in a single, 32-bit, flat model address space at privilege level 0 (also called ring 0). The VMM provides multi-threaded, <b>preemptive</b> <b>multitasking.</b> It runs multiple applications simultaneously by sharing CPU (central processing unit) time between the threads in which the applications and virtual machines run.|$|E
2500|$|The OS is single-user and employs {{cooperative}} multitasking (CMT). While most current desktop OSes use <b>preemptive</b> <b>multitasking</b> (PMT) and multithreading, [...] remains with a CMT system. By 2003, many users {{had called for}} the OS to migrate to PMT. The OS memory protection is not comprehensive.|$|E
2500|$|... {{real-time}} {{programs such}} as simulations, flight navigation systems, and medical equipment. For example, in a fly-by-wire system, telemetry must be interpreted and acted upon within strict time constraints. Such systems must eliminate sources of unpredictable delays, which may be created by (some) interpreted languages, automatic garbage collection, paging operations, or <b>preemptive</b> <b>multitasking.</b> However, some higher-level languages incorporate run-time components and operating system interfaces that can introduce such delays. Choosing assembly or lower-level languages for such systems gives programmers greater visibility and control over processing details.|$|E
40|$|Embedded {{microcontroller}} modules offer {{many advantages}} over the standard PC such as low cost, small size, low power consumption, {{direct access to}} hardware, and if available, access to an efficient <b>preemptive</b> real-time <b>multitasking</b> kernel. Typical difficulties associated with an embedded solution include long development times, limited memory resources, and restricted memory management capabilities. This paper presents a case study on the successes and challenges in developing a control system for a remotely controlled, Alt-Az steerable, water vapour detector using the Rabbit 2000 family of 8 -bit microcontroller modules {{in conjunction with the}} MicroC/OS-II multitasking real-time kernel...|$|R
50|$|Based on {{the source}} code written for µC/OS, and {{introduced}} {{as a commercial}} product in 1998, µC/OS-II is a portable, ROM-able, scalable, <b>preemptive,</b> real-time, deterministic, <b>multitasking</b> kernel for microprocessors, and digital signal processors (DSPs). It manages up to 255 application tasks. Its size can be scaled (between 5 to 24 Kbytes) to only contain the features needed for a given use.|$|R
50|$|Contrary {{to early}} 8-bit {{operating}} systems {{it is based}} on a microkernel, which provides <b>preemptive</b> and priority-oriented <b>multitasking</b> and manages random-access memory (RAM) with a size of up to 1024 KB. SymbOS contains a Microsoft Windows like graphical user interface (GUI), supports hard disks with a capacity of up to 128 GB and can already be booted on an unexpanded Amstrad CPC-6128, a 128K-MSX2 and an Amstrad PCW.|$|R
2500|$|The {{philosophy}} governing <b>preemptive</b> <b>multitasking</b> is that {{of ensuring}} that all programs are given regular time on the CPU. This implies that all programs must be limited in how much time {{they are allowed to}} spend on the CPU without being interrupted. To accomplish this, modern operating system kernels make use of a timed interrupt. A protected mode timer is set by the kernel which triggers a return to supervisor mode after the specified time has elapsed. (See above sections on Interrupts and Dual Mode Operation.) ...|$|E
2500|$|After Windows 3.11, Microsoft {{began to}} develop a new {{consumer}} oriented version of the operating system code-named Chicago. Chicago was designed to have support for 32-bit <b>preemptive</b> <b>multitasking</b> like OS/2 and Windows NT, although a 16-bit kernel would remain for the sake of backward compatibility. The Win32 API first introduced with Windows NT was adopted as the standard 32-bit programming interface, with Win16 compatibility being preserved through a technique known as [...] "thunking". A new GUI was not originally planned as part of the release, although elements of the Cairo user interface were borrowed and added as other aspects of the release (notably Plug and Play) slipped.|$|E
2500|$|In November 1988, a new {{development}} team within Microsoft (which included former Digital Equipment Corporation developers Dave Cutler and Mark Lucovsky) began work on a revamped version of IBM and Microsoft's OS/2 operating system known as [...] "NT OS/2". NT OS/2 {{was intended to be}} a secure, multi-user operating system with POSIX compatibility and a modular, portable kernel with <b>preemptive</b> <b>multitasking</b> and support for multiple processor architectures. However, following the successful release of Windows 3.0, the NT development team decided to rework the project to use an extended 32-bit port of the Windows API known as Win32 instead of those of OS/2. Win32 maintained a similar structure to the Windows APIs (allowing existing Windows applications to easily be ported to the platform), but also supported the capabilities of the existing NT kernel. Following its approval by Microsoft's staff, development continued on what was now Windows NT, the first 32-bit version of Windows. However, IBM objected to the changes, and ultimately continued OS/2 development on its own.|$|E
40|$|Abstract—The uClinux port is a {{derivative}} of Linux kernel intended for microcontrollers without memory management units (MMU) [1]. It provides a single shared address space for all processes. Whereas, uC/OS-II is a portable, ROMable, scalable, <b>preemptive,</b> real-time deterministic <b>multitasking</b> kernel for mi-croprocessors, microcontrollers and DSPs [2]. In this paper, we implemented uCos and uClinux kernels {{on the same}} NIOS-II platform and compared the performance. Index Terms—Embedded OS, uClinux, uCos, benchmarks, performance...|$|R
50|$|For task management, a {{combination}} of <b>preemptive</b> and cooperative <b>multitasking</b> was chosen, which makes different task priorities possible. Preemptive means that tasks are interrupted after {{a certain amount of}} time by the operating system, in order to share the CPU time with other tasks. Cooperatively means that a task stops using CPU time by itself. It does that, if it's finished with its current job or waiting for a certain event. Because of this combination it is possible to assign priorities. Tasks with low priority get CPU time only if all tasks with higher priorities are not then working.|$|R
40|$|Locking caches are {{a useful}} {{alternative}} to standard cache memories {{in order to}} reach both predictability and high performance for <b>multitasking,</b> <b>preemptive,</b> fixedpriority real-time systems. Two schemes of locking cache are possible: static and dynamic use. Both schemas present a high degree of predictability and like-cache performance. But these two schemes are not equivalent. Each one performs better for systems with particular characteristics. This work show that static use presents a greater degree of predictability than dynamic use, but dynamic use offers better performance for the major part of the cases. Systems are grouped {{as a function of the}} relationship between cache size and code size, allowing a fast and easy prediction about the gain or loss of performance given by each use of locking caches...|$|R
2500|$|The Lisa {{operating}} system featured <b>preemptive</b> <b>multitasking</b> and protected memory, then extremely advanced features {{for a personal}} computer. Based in part on advanced elements from the failed Apple III SOS {{operating system}} released three years earlier, the Lisa also organized its files in hierarchal directories, making the use of large hard drives practical. The Macintosh would eventually adopt this disk organizational design as well for its HFS filing system. Conceptually, the Lisa resembles the Xerox Star {{in the sense that}} it was envisioned as an office computing system; consequently, Lisa has two main user modes: the Lisa Office System and the Workshop. The Lisa Office System is the GUI environment for end users. The Workshop was a program development environment, and was almost entirely text-based, though it used a GUI text editor. The Lisa Office System was eventually renamed [...] "7/7", in reference to the seven supplied application programs: LisaWrite, LisaCalc, LisaDraw, LisaGraph, LisaProject, LisaList, and LisaTerminal.|$|E
2500|$|The {{next major}} consumer-oriented release of Windows, Windows 95, was {{released}} on August 24, 1995. While still remaining MS-DOS-based, Windows 95 introduced support for native 32-bit applications, plug and play hardware, <b>preemptive</b> <b>multitasking,</b> long file names of up to 255 characters, and provided increased stability over its predecessors. Windows 95 also introduced a redesigned, object oriented user interface, replacing the previous Program Manager with the Start menu, taskbar, and Windows Explorer shell. Windows 95 was a major commercial success for Microsoft; Ina Fried of CNET remarked that [...] "by the time Windows 95 was finally ushered off the market in 2001, {{it had become a}} fixture on computer desktops around the world." [...] Microsoft published four OEM Service Releases (OSR) of Windows 95, each of which was roughly equivalent to a service pack. The first OSR of Windows 95 was also the first version of Windows to be bundled with Microsoft's web browser, Internet Explorer. Mainstream support for Windows 95 ended on December 31, 2000, and extended support for Windows 95 ended on December 31, 2001.|$|E
2500|$|Mac OS {{continued}} to evolve up to version 9.2.2, including retrofits {{such as the}} addition of a nanokernel and support for Multiprocessing Services 2.0 in Mac OS 8.6, though its dated architecture made replacement necessary. Initially developed in the Pascal programming language, it was substantially rewritten in C++ for System 7. From its beginnings on an 8MHz machine with 128KB of RAM, it had grown to support Apple's latest 1GHz G4-equipped Macs. Since its architecture was laid down, features that were already common on Apple's competition, like <b>preemptive</b> <b>multitasking</b> and protected memory, had become feasible on the kind of hardware Apple manufactured. As such, Apple introduced Mac OS X, a fully overhauled Unix-based successor to Mac OS 9. OS X uses Darwin, XNU, and Mach as foundations, and is based on NeXTSTEP. It was released to the public in September 2000, as the Mac OS X Public Beta, featuring a revamped user interface called [...] "Aqua". At US$29.99, it allowed adventurous Mac users to sample Apple's new operating system and provide feedback for the actual release. The initial version of Mac OS X, 10.0 [...] "Cheetah", was released on March 24, 2001. Older Mac OS applications could still run under early Mac OS X versions, using an environment called [...] "Classic". Subsequent releases of Mac OS X included 10.1 [...] "Puma" [...] (2001), 10.2 [...] "Jaguar" [...] (2002), 10.3 [...] "Panther" [...] (2003) and 10.4 [...] "Tiger" [...] (2005).|$|E
40|$|In <b>multitask,</b> <b>preemptive</b> {{real-time}} systems, {{the use of}} cache memories make difficult {{the estimation}} of the response time of tasks, due to the dynamic, adaptive and non predictable behavior of cache memories. But many embedded and critical applications need the increase of performance provided by cache memories. Recent studies indicate that for application-specific embedded systems, static cache-locking helps determining the worst case execution time (WCET) and cache-related pre-emption delay. The determination of upper bounds on execution times, commonly called Worst-Case Execution Times (WCETs), is a necessary step {{in the development and}} validation process for hard real-time systems. This problem is hard if the underlying processor architecture has components such as caches, pipelines, branch prediction, and other speculative components. This article describes different approaches to this problem and surveys several commercially available tools and research prototype...|$|R
40|$|In <b>multitask,</b> <b>preemptive</b> {{real-time}} systems, {{the use of}} cache memories makes {{estimating the}} response time of tasks difficult, due to the dynamic, adaptive and non-predictable behaviour of cache memories. This work presents a comprehensive method for attaining predictability {{on the use of}} caches in real-time systems through the use of locking caches, which ensure cache contents will remain unchanged during the execution of each task. Nowadays, locking caches are present in several commercial processors. In order to select the contents to be locked in cache, a genetic algorithm has been developed. Experimental results indicate that this scheme has a high level of predictability, and that the performance loss is negligible for around 70 % of the tasks. Copyright 2002 IFAC Keywords: Cache Memories, Response Times, Execution Times, Algorithms 1...|$|R
40|$|In recent years, {{approaches}} to control performance and resource optimization for embedded control {{systems have been}} receiving increased attention. Most of them focus on theory, whereas practical aspects are omitted. Theoretical advances demand flexible real-time kernel support for multitasking and preemption, thus requiring more sophisticated and expensive software/ hardware solutions. On the other hand, embedded control systems often have cost constraints related with mass production and strong industrial competition, thus demanding low-cost solutions. In this paper, it is shown that these conflicting demands can be softened and that a compromise solution can be reached. We advocate that recent research results on optimal resource management for control tasks can be implemented on simple <b>multitasking</b> <b>preemptive</b> real-time kernels targeting low-cost microprocessors, which can be easily built in-house and tailored to actual application needs. The experimental evaluation shows that significant control performance improvement can be achieved without increasing hardware costs. Peer ReviewedPostprint (published version...|$|R
50|$|Early PC {{operating}} {{systems such as}} MS-DOS and PC DOS, did not support multitasking at all, however alternative {{operating systems}} such as MP/M-86 (1981) and Concurrent CP/M-86 did support <b>preemptive</b> <b>multitasking.</b> Other Unix-like systems including MINIX and Coherent provided <b>preemptive</b> <b>multitasking</b> on 1980s-era personal computers.|$|E
5000|$|... #Subtitle level 3: <b>Preemptive</b> <b>multitasking</b> or multi-threading ...|$|E
50|$|The {{countdown}} timer provided the hardware necessary for <b>preemptive</b> <b>multitasking.</b> The Macintosh operating system did not feature standard multitasking until 1987 {{with the release}} of the MultiFinder, unlike the Lisa, which used cooperative multitasking. <b>Preemptive</b> <b>multitasking</b> was only later adopted on the Apple Macintosh by Mac OS 9.x as an additional API, i.e. the application could be programmed to use the preemptive or cooperative model, and all legacy applications were multitasked cooperatively within a single process. Mac OS X, being a Unix-like system, uses <b>preemptive</b> <b>multitasking</b> for all native applications.|$|E
40|$|Abstract—In recent years, {{approaches}} to control performance and resource optimization for embedded control {{systems have been}} receiving increased attention. Most of them focus on theory, whereas practical aspects are omitted. Theoretical advances demand flexible real-time kernel support for multitasking and preemption, thus requiring more sophisticated and expensive software/hardware solutions. On the other hand, embedded control systems often have cost constraints related with mass production and strong industrial competition, thus demanding low-cost solutions. In this paper, it is shown that these conflicting demands can be softened and that a compromise solution can be reached. We advocate that recent research results on optimal resource management for control tasks can be implemented on simple <b>multitasking</b> <b>preemptive</b> real-time kernels targeting low-cost microprocessors, which can be easily built in-house and tailored to actual application needs. The experimental evaluation shows that significant control performance improvement can be achieved without increasing hardware costs. Index Terms—Adaptive resource management, control systems, embedded systems, microcontroller, real-time kernel. I...|$|R
40|$|Abstract [...] In <b>multitask,</b> <b>preemptive</b> {{real-time}} systems, use of cache memories make difficult {{the estimation}} of the response time of tasks, due to the dynamic, adaptive and non-predictable behavior of cache memories. But embedded and critical applications need the increase of performance provided by cache memories. This work presents a comprehensive method to use locking caches is these scenarios. Locking cache mechanisms allows to load and lock {{the content of the}} cache to ensure it will remain unchanged during execution. By ensuring this, the cache is totally predictable, thus conventional algorithms can be used to accomplish the schedulability analysis. In addition, a predictable cache allows a more accurate estimation of response time of tasks. Nowadays, locking cache scheme is present is several commercial processors, and only minor hardware modifications would be necessary in order to obtain the best performance. To select the contents to be preloaded in cache, a genetic algorithm is developed. This algorithm selects the set of instructions to be locked in cache that give the better performance, and simultaneously estimate a tight upperbound of the response time of tasks, making simultaneously the schedulability analysis. Experimental results show that in a variety of scenarios, this method obtains better performance than non-locking caches in addition to simplify the analysis. C Using locking caches in preemptive real-time systems I...|$|R
40|$|Energy {{consumption}} of real-time embedded systems {{becomes more important}} as such systems are widely used in many applications. In those systems, the core processor consumes {{a large amount of}} the total energy. Dynamic voltage scaling (DVS) is accepted as the key technique to reduce energy dissipation of the core by lowering the supply voltage and operating frequency. Currently, most DVS heuristics are based on average values of the past utilization, either with or without real-time constraint guarantees. This thesis is aimed at exploring the possibility to apply a classical control-systems technique, namely PID controller, to a DVS heuristic. The PID controller is able to find a good average value that represents the past, the present, and the changing workload of the system. By applying the characteristics of real-time application programs, the technique can also meet the real-time constraints. The technique is integrated into µC/OS II, a <b>multitasking</b> <b>preemptive</b> real-time operating system running on a Motorola M-CORE processor model. The applications used in the experiments are all members of the MediaBench benchmark suite. The experimental results show that the technique can reduce significantly energy consumption by consuming only 5 % above the PERFECT case, and consuming only half of the energy consumed by the AVGN algorithm. Besides, the technique also guarantees the real-time constraints by preserving both jitters and miss-deadline rates below 5 %...|$|R
