675|10000|Public
500|$|Due to {{the reverse}} topological {{ordering}} and the skew-symmetry, when a literal {{is set to}} true, all literals that can be reached from it via a chain of implications will already have been set to true. Symmetrically, when a literal [...] is set to false, all literals that lead to it via a chain of implications will themselves already have been set to false. Therefore, the truth assignment constructed by this procedure satisfies the given formula, which also completes the <b>proof</b> <b>of</b> <b>correctness</b> of the necessary and sufficient condition identified by Aspvall et al.|$|E
2500|$|The <b>proof</b> <b>of</b> <b>correctness</b> {{for this}} test {{presented}} here is simpler {{than the original}} proof given by Lehmer. Recall the definition ...|$|E
2500|$|An {{interesting}} early {{case is that}} of what we {{now call}} the Euclidean algorithm. In its basic form (namely, as an algorithm for computing the greatest common divisor) it appears as Proposition 2 of Book VII in Elements, together with a <b>proof</b> <b>of</b> <b>correctness.</b> However, in the form that is often used in number theory (namely, as an algorithm for finding integer solutions to an equation , ...|$|E
3000|$|... can be {{compromised}} by the adversary. The <b>proofs</b> <b>of</b> <b>correctness</b> <b>of</b> the proposed protocols extend the presentations of [9] and [8].|$|R
5000|$|In contrast, {{there is}} {{increasing}} interest in producing <b>proofs</b> <b>of</b> <b>correctness</b> <b>of</b> such systems by automated means. Automated techniques fall into three general categories: ...|$|R
40|$|This {{paper is}} a {{companion}} technical {{report to the}} article "Continuation-Passing C: from threads to events through continuations". It contains the complete version <b>of</b> the <b>proofs</b> <b>of</b> <b>correctness</b> <b>of</b> lambda-lifting and CPS-conversion presented in the article. Comment: arXiv admin note: substantial text overlap with arXiv: 1011. 455...|$|R
2500|$|The {{implementation}} of exception handling in programming languages typically involves {{a fair amount}} of support from both a code generator and the runtime system accompanying a compiler. (It was the addition of exception handling to C++ that ended the useful lifetime of the original C++ compiler, Cfront.) [...] Two schemes are most common. The first, dynamic registration, generates code that continually updates structures about the program state in terms of exception handling. [...] Typically, this adds a new element to the stack frame layout that knows what handlers are available for the function or method associated with that frame; if an exception is thrown, a pointer in the layout directs the runtime to the appropriate handler code. This approach is compact in terms of space, but adds execution overhead on frame entry and exit. It was commonly used in many Ada implementations, for example, where complex generation and runtime support was already needed for many other language features. Dynamic registration, being fairly straightforward to define, is amenable to <b>proof</b> <b>of</b> <b>correctness.</b>|$|E
50|$|The {{following}} lemma {{completes the}} <b>proof</b> <b>of</b> <b>correctness</b> of the ORAM scheme.|$|E
5000|$|... #Subtitle level 2: Desnanot-Jacobi {{identity}} and <b>proof</b> <b>of</b> <b>correctness</b> of the condensation algorithm ...|$|E
5000|$|Regev {{proposed}} a public-key cryptosystem {{based on the}} hardness of the LWE problem. The cryptosystem {{as well as the}} <b>proof</b> <b>of</b> security and <b>correctness</b> are completely classical. The system is characterized by [...] and a probability distribution [...] on [...] The setting of the parameters used in <b>proofs</b> <b>of</b> <b>correctness</b> and security is ...|$|R
40|$|This paper takes {{first steps}} towards a {{formalization}} of graph transformations {{in a general}} setting of interactive theorem provers, which will {{form the basis for}} <b>proofs</b> <b>of</b> <b>correctness</b> <b>of</b> graph transformation systems. We present parts of our formalization and take a glimpse at some strategies for simplifying proof obligations...|$|R
5000|$|... #Subtitle level 3: <b>Proof</b> <b>of</b> the <b>correctness</b> <b>of</b> Dodgson {{condensation}} ...|$|R
50|$|Alexander Reinefeld invented NegaScout {{several decades}} after the {{invention}} of alpha-beta pruning. He gives a <b>proof</b> <b>of</b> <b>correctness</b> of NegaScout in his book.|$|E
5000|$|Sanity check, {{a simple}} {{test of the}} {{correctness}} of an output or intermediate result that {{is not required to}} be a complete <b>proof</b> <b>of</b> <b>correctness</b> ...|$|E
50|$|Despite the {{intuitive}} explanation, the algorithm {{was not easy}} to prove correct, however due to its favorable properties a <b>proof</b> <b>of</b> <b>correctness</b> was desirable and multiple proofs have been presented.|$|E
40|$|A Hoare-style proof {{system for}} LOTOS, {{defined in terms}} <b>of</b> <b>proof</b> rules based on the {{structure}} of processes, is presented. Hoare's satisfaction relation is used to define these rules. This system is based on the failures model. It is shown to be adequate to allow <b>proofs</b> <b>of</b> <b>correctness</b> <b>of</b> compound processes to be constructed from <b>proofs</b> <b>of</b> <b>correctness</b> <b>of</b> its parts. An example, consisting <b>of</b> the <b>proof</b> <b>of</b> a property of the failure set of a two-slot buffer is presented. 1 INTRODUCTION The established method for proving properties of LOTOS processes is bisimulation. This method, well-known in process algebras (see among others [Par 81, Mil 80, Mil 89]) has been extended to LOTOS in a number of papers [BC 89], among which one of the most complete is the PhD thesis of Brinksma [Bri 88 a]. By using bisimulation, one can prove a LOTOS process equivalent to another LOTOS process. An example of this way of proceeding is presented in papers by [Naj 87] and by Shiratori et al. [SKTN 90], where service proce [...] ...|$|R
40|$|In this article, we {{summarize}} {{several new}} results concerning short 2 -bases for Boolean algebra {{in terms of}} the Sheffer stroke. Two especially short bases are presented, each consisting of a pair of equations having a total of only six applications of the Sheffer stroke operator. Our <b>proofs</b> <b>of</b> <b>correctness</b> <b>of</b> these new results relied heavily on the use of an automated reasoning program...|$|R
50|$|At Microsoft, a {{critical}} bug {{was discovered in}} the Xbox 360 memory module {{during the process of}} writing a specification in TLA+. TLA+ was used to write formal <b>proofs</b> <b>of</b> <b>correctness</b> for Byzantine Paxos and components of the Pastry distributed hash table.|$|R
5000|$|The <b>proof</b> <b>of</b> <b>correctness</b> {{for this}} test {{presented}} here is simpler {{than the original}} proof given by Lehmer. Recall the definitionThe goal {{is to show that}} Mp is prime iff ...|$|E
5000|$|The scheme {{allows the}} {{correctness}} {{of an election}} result to be verifiably proved relying only on {{the integrity of the}} in-booth random number generators (hence [...] "trusted"); the <b>proof</b> <b>of</b> <b>correctness</b> does not rely on, still less need to prove, the integrity of the electronic voting machines themselves.|$|E
5000|$|In {{response}} {{to some of}} these variants, and to other feedback, the paper [...] "PRIMES is in P" [...] was updated with a new formulation of the AKS algorithm and of its <b>proof</b> <b>of</b> <b>correctness.</b> (This version was eventually published in Annals of Mathematics.) While the basic idea remained the same, r was chosen in a new manner, and the <b>proof</b> <b>of</b> <b>correctness</b> was more coherently organized. While the previous proof had relied on many different methods, the new version relied almost exclusively on the behavior of cyclotomic polynomials over finite fields. The new version also allowed for an improved bound on the time complexity, which can now be shown by simple methods to be [...] Using additional results from sieve theory, this can be further reduced to [...]|$|E
40|$|In {{this paper}} we give a {{compositional}} (or inductive) construction of monitoring automata for LTL formulas. Our construction {{is similar in}} spirit to the compositional construction of Kesten and Pnueli [5]. We introduce the notion of hierarchical Büchi automata and phrase our constructions {{in the framework of}} these automata. We give detailed constructions for all the principal LTL operators including past operators, along with <b>proofs</b> <b>of</b> <b>correctness</b> <b>of</b> the constructions...|$|R
40|$|Abstract. This {{technical}} report {{consists of two}} sections that expose <b>proofs</b> <b>of</b> <b>correctness</b> for the partial composition operators and the contract derivation function defined in our theoretical paper [1]. The definitions, sections, and algorithms referred in this report relate {{to those of the}} theoretical paper...|$|R
40|$|The Bulk Synchronous Parallel ML (BSML) is a {{functional}} language for Bulk Synchronous Parallel (BSP) programming. It {{is based on}} an extension of the #-calculus by parallel operations on a parallel data structure named parallel vector, which is given by intention. We present the formal <b>proofs</b> <b>of</b> <b>correctness</b> <b>of</b> BSML programs in the Coq proof assistant. Such development demonstrates the usefulness of higher-order logic in the process of software certification and parallel applications. They also show that <b>proof</b> <b>of</b> rather complex parallel algorithms may be made with inductive types by using the certified programs...|$|R
5000|$|The <b>proof</b> <b>of</b> <b>correctness</b> {{follows from}} choice of {{parameters}} and some probability analysis. The proof of security is by reduction {{to the decision}} version of LWE: an algorithm for distinguishing between encryptions (with above parameters) of [...] and [...] {{can be used to}} distinguish between [...] and the uniform distribution over ...|$|E
50|$|That the {{generated}} {{numbers are}} not predictable by the election authority is the pre-condition for {{the proof of}} the correctness of elections: Only if the in-booth random number generators can be trusted is the <b>proof</b> <b>of</b> <b>correctness</b> valid. One of the authors {{makes the point that}} a separate random number generator can be more effectively protected from manipulation than can a voting machine.|$|E
50|$|While {{the word}} {{algorithm}} goes back only to certain readers of al-Khwārizmī, careful descriptions of methods of solution {{are older than}} proofs: such methods (that is, algorithms) are as old as any recognisable mathematics—ancient Egyptian, Babylonian, Vedic, Chinese—whereas proofs appeared only with the Greeks of the classical period.An interesting early case is that of {{what we now call}} the Euclidean algorithm. In its basic form (namely, as an algorithm for computing the greatest common divisor) it appears as Proposition 2 of Book VII in Elements, together with a <b>proof</b> <b>of</b> <b>correctness.</b> However, in the form that is often used in number theory (namely, as an algorithm for finding integer solutions to an equation ,or, what is the same, for finding the quantities whose existence is assured by the Chinese remainder theorem) it first appears in the works of Āryabhaṭa (5th-6th century CE) as an algorithm calledkuṭṭaka ("pulveriser"), without a <b>proof</b> <b>of</b> <b>correctness.</b>|$|E
40|$|We devise an {{algorithm}} using normalization by evaluation (NbE) {{for deciding}} equality between terms in a λ-calculus equipped with strong sums. While <b>proofs</b> <b>of</b> <b>correctness</b> and completeness are still work in progress, the originality of this algorithm is {{its use of}} exceptions, which yields a particularly simple solution to this intricate problem. 1...|$|R
40|$|Abstract. It {{has been}} shown in recent years that quantum {{information}} has a topological nature ([1], [2], [3]). In [7], Vicary undergoes the study of quantum algorithms using this new topological approach. The advantage of this new formalism is that it allows new <b>proofs</b> <b>of</b> <b>correctness</b> <b>of</b> the algorithms such as Deutsch-Jozsa, hidden subgroup and single-shot Grover algorithms. It also provide more clear insight to the generalizations of these algorithms. In this paper, we consider (multi-step) Grover algorithm from this new perspective. 1...|$|R
40|$|An {{account is}} given of a {{rigorous}} study of concurrent operations on {{a variant of}} the B-tree in the framework of a general theory of concurrent systems, an extension of the pi-calculus. The assertion <b>of</b> <b>correctness</b> <b>of</b> the algorithms is that the agent representing the system is behaviourally equivalent to an agent whose observable behaviour describes simply the expected interactions of the system with its environment. An outline <b>of</b> the <b>proofs</b> <b>of</b> <b>correctness</b> <b>of</b> algorithms for insertion and search is given. Algorithms for deletion and compression are considered briefly. The main theoretical contribution is an extension of the theory,of partial confluence of agents...|$|R
50|$|A subresultant {{sequence}} can be also computed with pseudo-remainders. The process {{consists in}} choosing α {{is such a}} way that every ri is a subresultant polynomial. Surprisingly, the computation of α is very easy (see below). On the other hand, the <b>proof</b> <b>of</b> <b>correctness</b> of the algorithm is difficult, because it should take into account all the possibilities for the difference of degrees of two consecutive remainders.|$|E
50|$|The primary {{aim of the}} PhoX project {{creating}} a user friendly proof checker using the type system developed by Jean-Louis Krivine at University Paris VII. It {{is meant to be}} more intuitive than other systems while remaining extensible, efficient, and expressive. Compared to other systems, the proof-building syntax is simplified and closer to natural language. Other features include GUI-driven proof construction, rendering formatted output, and <b>proof</b> <b>of</b> <b>correctness</b> of programs in the ML programming language.|$|E
5000|$|Due to {{the reverse}} topological {{ordering}} and the skew-symmetry, when a literal {{is set to}} true, all literals that can be reached from it via a chain of implications will already have been set to true. Symmetrically, when a literal [...] is set to false, all literals that lead to it via a chain of implications will themselves already have been set to false. Therefore, the truth assignment constructed by this procedure satisfies the given formula, which also completes the <b>proof</b> <b>of</b> <b>correctness</b> of the necessary and sufficient condition identified by Aspvall et al.|$|E
40|$|Two {{classes of}} the {{bottleneck}} transportation problem {{with an additional}} budget constraint are introduced. An exact approach was proposed to solve both problem classes with <b>proofs</b> <b>of</b> <b>correctness</b> and complexity. Moreover, the approach was extended to solve a class of multi-commodity transportation network with a special case of the multi-period constrained bottleneck assignment problem...|$|R
5000|$|Sometimes, the {{motivation}} for proving the <b>correctness</b> <b>of</b> a system is not the obvious need for re-assurance <b>of</b> the <b>correctness</b> <b>of</b> the system, but a desire to understand the system better. Consequently, some <b>proofs</b> <b>of</b> <b>correctness</b> are produced {{in the style of}} mathematical proof: handwritten (or typeset) using natural language, using a level of informality common to such proofs. A [...] "good" [...] proof is one which is readable and understandable by other human readers.|$|R
50|$|An {{important}} use of specification languages is {{enabling the}} creation <b>of</b> <b>proofs</b> <b>of</b> program <b>correctness</b> (see theorem prover).|$|R
