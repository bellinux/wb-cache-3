691|8|Public
25|$|By {{the later}} 1890s he was devising existential graphs, a {{diagrammatic}} notation for the <b>predicate</b> <b>calculus.</b> Based on them are John F. Sowa's conceptual graphs and Sun-Joo Shin's diagrammatic reasoning.|$|E
25|$|The validities of monadic <b>predicate</b> <b>calculus</b> with {{identity}} are decidable, however. This {{system is}} first-order logic restricted to signatures {{that have no}} function symbols and whose relation symbols other than equality never take more than one argument.|$|E
25|$|This {{became the}} topic that Gödel chose for his {{doctoral}} work. In 1929, {{at the age}} of 23, he completed his doctoral dissertation under Hans Hahn's supervision. In it, he established the completeness of the first-order <b>predicate</b> <b>calculus</b> (Gödel's completeness theorem). He was awarded his doctorate in 1930. His thesis, along with some additional work, was published by the Vienna Academy of Science.|$|E
50|$|Attributional {{calculus}} is a {{logic and}} representation system defined by Ryszard S. Michalski. It combines elements of <b>predicate</b> logic, propositional <b>calculus,</b> and multi-valued logic. Attributional calculus provides a formal language for natural induction, an inductive learning process whose {{results are in}} forms natural to people.|$|R
50|$|Language-like only in {{the sense}} that they {{manipulate}} symbols as a language does. The language of thought cannot be thought of as a natural language; it can only be a formal language that applies across different linguistic subjects, it therefore must be a language common to mind rather than culture, must be organizational rather than communicative. Thus Mentalese is best expressed through <b>predicate</b> and propositional <b>calculus.</b>|$|R
40|$|Assertional methods {{tend to be}} useable for abstract, {{coarse-grained}} {{versions of}} concurrent algorithms, but quickly become intractable for more realistic, finer-grained implementations. Various trace-reduction methods have been proposed to transfer properties of coarse-grained versions to finer-grained versions. We show that a more direct approach, involving the explicit construction of an (inductive) invariant for the finer-grained version, is theoretically more powerful, and also more appropriate for computer-aided verification. 1 Introduction Recents improvements in methods and tools for testing the validity of propositional and predicate logic formulas have revived the interest in assertional methods for concurrent system verification. Indeed, {{at least as far}} as safety properties are concerned, Hoare's logic and Dijkstra's <b>predicate</b> transformer <b>calculus</b> reduce the correctness problem for programs to the validity problem for logical formulas. However, as soon as loops occur in pro [...] ...|$|R
25|$|Gentzen-style {{systems have}} {{significant}} practical and theoretical advantages compared to Hilbert-style systems. For example, both natural deduction and sequent calculus systems facilitate the elimination and introduction of universal and existential quantifiers so that unquantified logical expressions {{can be manipulated}} according to the much simpler rules of propositional calculus. In a typical argument, quantifiers are eliminated, then propositional calculus is applied to unquantified expressions (which typically contain free variables), and then the quantifiers are reintroduced. This very much parallels {{the way in which}} mathematical proofs are carried out in practice by mathematicians. <b>Predicate</b> <b>calculus</b> proofs are generally much easier to discover with this approach, and are often shorter. Natural deduction systems are more suited to practical theorem-proving. Sequent calculus systems are more suited to theoretical analysis.|$|E
2500|$|Dijkstra, Edsger W.; Scholten, Carel S.: <b>Predicate</b> <b>Calculus</b> and Program Semantics (Texts and Monographs in Computer Science). New York: Springer-Verlag, 1990, 220pp ...|$|E
2500|$|There {{is a big}} {{difference}} between the kinds of formulas seen in traditional term logic and the <b>predicate</b> <b>calculus</b> that is the fundamental advance of modern logic. [...] The formula A(P,Q) (all Ps are Qs) of traditional logic corresponds to the more complex formula [...] in predicate logic, involving the logical connectives for universal quantification and implication rather than just the predicate letter A and using variable arguments [...] where traditional logic uses just the term letter P. [...] With the complexity comes power, and the advent of the <b>predicate</b> <b>calculus</b> inaugurated revolutionary growth of the subject.|$|E
40|$|Hoare's {{logic and}} Dijkstra's <b>predicate</b> {{transformer}} <b>calculus</b> have proved adequate {{for reducing the}} correctness problem for programs to the validity problem for logical formulas. However, {{the size of the}} logical formulas to be validated grows faster than the size of the program, and, even in the propositional case, the validation problem is NPcomplete and becomes practically intractable for large programs. We introduce a strategy for dealing with this problem. The principle is to write the formulas in the form (h 1 ΔΔΔ hn)) c, and to use efficiently computable criteria to select a small subset I ae f 1; : : :; ng such that c remains a logical consequence of H I = fh i : i 2 Ig. These criteria are motivated and the efficiency of the method is investigated...|$|R
40|$|Abstract. Walther’s {{estimation}} calculus {{was designed}} to prove the termination of functional programs, and {{can also be used}} to solve the similar problem of proving the well-foundedness of induction rules. However, there are certain features of the goal formulae which are more common to the problem of induction rule well-foundedness than the problem of termination, and which the calculus cannot handle. We present a sound extension of the calculus that is capable of dealing with these features. The extension develops Walther’s concept of an argument bounded function in two ways: firstly, so that the function may be bounded below by its argument, and secondly, so that a bound may exist between two arguments of a <b>predicate.</b> Our <b>calculus</b> enables automatic proofs of the well-foundedness of a large class of induction rules not captured by the original calculus. ...|$|R
40|$|Walther's {{estimation}} calculus {{was designed}} to prove the termination of functional programs, and {{can also be used}} to solve the similar problem of proving the well-foundedness of induction rules. However, there are certain features of the goal formulae which are more common to the problem of induction rule well-foundedness than the problem of termination, and which the calculus cannot handle. We present a sound extension of the calculus that is capable of dealing with these features. The extension develops Walther's concept of an argument bounded function in two ways: firstly, so that the function may be bounded below by its argument, and secondly, so that a bound may exist between two arguments of a <b>predicate.</b> Our <b>calculus</b> enables automatic proofs of the well-foundedness of a large class of induction rules not captured by the original calculus. 1 Introduction An induction rule is well-founded iff there is a well-founded order such that each step case of the rule the indu [...] ...|$|R
2500|$|The first-order <b>predicate</b> <b>calculus</b> avoids such {{ambiguity}} {{by using}} formulae that carry no existential import {{with respect to}} universal statements. Existential claims must be explicitly stated. Thus, natural language statements—of the forms All A is B, No A is B, Some A is B, and Some A is not B—can be represented in first order <b>predicate</b> <b>calculus</b> in which any existential import with respect to terms A and/or B is either explicit or not made at all. Consequently, the four forms AaB, AeB, AiB, and AoB can be represented in first order predicate in every combination of existential import—so it can establish which construal, if any, preserves the square of opposition and {{the validity of the}} traditionally valid syllogism. [...] Strawson claims such a construal is possible, but the results are such that, in his view, the answer to question (e) above is no.|$|E
2500|$|The second notion {{was derived}} from work in <b>predicate</b> <b>calculus</b> (predicate logic, first order logic) and is {{prominent}} in modern theories of syntax and grammar. In this approach, the predicate of a sentence mostly corresponds to the main verb and any auxiliaries that accompany the main verb; whereas the arguments of that predicate (e.g. the subject [...] and object noun phrases) are outside the predicate.|$|E
2500|$|Today, some {{academics}} {{claim that}} Aristotle's system is generally {{seen as having}} little more than historical value (though there is some current interest in extending term logics), regarded as made obsolete by the advent of propositional logic and the <b>predicate</b> <b>calculus.</b> Others use Aristotle in argumentation theory to help develop and critically question argumentation schemes {{that are used in}} artificial intelligence and legal arguments.|$|E
40|$|International audienceThis paper {{deals with}} formal {{specification}} and verification of Java bytecode update. Programs update for java applications {{has gained a}} wide interest since it is used for several purposes: transforming semantics of a program, adding features to a program or performing optimizations. In this paper, we focus on program transformations for java programs at the bytecode level. Because these transformations may introduce errors, {{our goal is to}} provide a formal way to verify the update and establish its correctness. Our approach for formal specification and verification of updated Java bytecode programs is based on four ingredients: a formal interpretation of the semantics of update operations, a functional representation of bytecode, bytecode annotation and <b>predicate</b> transformation <b>calculus.</b> We use the concept of Hoare predicate transformation to derive a specification of an annotated bytecode. Annotations are used to express update operations within the code. A functional representation is used to model annotations and bytecode. The approach derives then a new specification for the annotated bytecode using a weakest precondition calculus defined to deal with update operations. Verification conditions are then generated and proved to establish the correction of the update...|$|R
2500|$|... "A {{property}} is definite in Skolem's sense {{if it is}} expressed [...] [...] [...] by a well-formed formula in the simple <b>predicate</b> <b>calculus</b> of first order in which the sole predicate constants are ε and possibly, =. ... Today an axiomatization of set theory is usually embedded in a logical calculus, and it is Weyl's and Skolem's approach to the formulation of the axiom of separation that is generally adopted.|$|E
2500|$|... {{defines the}} words as follows: [...] "In word languages, a {{proposition}} is expressed by a sentence. Then a 'predicate' is expressed by an incomplete sentence or sentence skeleton containing an open place. For example, [...] "___ is a man" [...] expresses a predicate ... The predicate is a propositional function of one variable. Predicates are often called 'properties' ... The <b>predicate</b> <b>calculus</b> will treat of the logic of predicates in this general sense of 'predicate', i.e., as propositional function".|$|E
2500|$|More {{recently}} (circa 1997), Bandler has claimed, [...] "NLP {{is based}} on finding out what works and formalizing it. In order to formalize patterns I utilized everything from linguistics to holography...The models that constitute NLP are all formal models based on mathematical, logical principles such as <b>predicate</b> <b>calculus</b> and the mathematical equations underlying holography." [...] However, {{there is no mention}} of the mathematics of holography nor of holography in general in McClendon's, Spitzer's, or Grinder's account of the development of NLP.|$|E
2500|$|Most modern {{theories}} of syntax and grammar take their {{inspiration for the}} theory of predicates from <b>predicate</b> <b>calculus</b> as associated with Gottlob Frege. This understanding sees predicates as relations or functions over arguments. The predicate serves either to assign a property to a single argument or to relate two or more arguments to each other. Sentences consist of predicates and their arguments (and adjuncts) and are thus predicate-argument structures, whereby a given predicate is seen as linking its arguments into a greater structure. This understanding of predicates sometimes renders a predicate and its arguments in the following manner: ...|$|E
2500|$|First-order logic—also {{known as}} first-order <b>{{predicate}}</b> <b>calculus</b> and predicate logic—is {{a collection of}} formal systems used in mathematics, philosophy, linguistics, and computer science. First-order logic uses quantified variables over non-logical objects and allows the use of sentences that contain variables, so that rather than propositions such as Socrates is a man one can have expressions in the form [...] "there exists X such that X is Socrates and X is a man" [...] and there exists is a quantifier while X is a variable. This distinguishes it from propositional logic, which does not use quantifiers or relations.|$|E
2500|$|Based upon {{work of the}} German {{mathematician}} Leopold Löwenheim (1915) the Norwegian logician [...] Thoralf Skolem {{showed in}} 1922 that every consistent theory of first-order <b>predicate</b> <b>calculus,</b> such as set theory, has an at most countable model. However, Cantor's theorem proves that there are uncountable sets. The root of this seeming paradox is that the countability or noncountability of a set is not always absolute, but can depend on the model in which the cardinality is measured. It is possible for a set to be uncountable in one model of set theory but countable in a larger model (because the bijections that establish countability are in the larger model but not the smaller one).|$|E
5000|$|Monadic <b>predicate</b> <b>calculus</b> can be {{contrasted with}} polyadic <b>predicate</b> <b>calculus,</b> which allows {{relation}} symbols that take {{two or more}} arguments.|$|E
5000|$|In {{mathematical}} logic Frege's propositional calculus {{was the first}} axiomatization of propositional calculus. It was invented by Gottlob Frege, who also invented <b>predicate</b> <b>calculus,</b> in 1879 {{as part of his}} second-order <b>predicate</b> <b>calculus</b> (although Charles Peirce was the first to use the term [...] "second-order" [...] and developed his own version of the <b>predicate</b> <b>calculus</b> independently of Frege).|$|E
50|$|The {{absence of}} polyadic {{relation}} symbols severely restricts {{what can be}} expressed in the monadic <b>predicate</b> <b>calculus.</b> It is so weak that, unlike the full <b>predicate</b> <b>calculus,</b> it is decidable—there is a decision procedure that determines whether a given formula of monadic <b>predicate</b> <b>calculus</b> is logically valid (true for all nonempty domains). Adding a single binary relation symbol to monadic logic, however, results in an undecidable logic.|$|E
5000|$|... #Subtitle level 3: Extension to first-order <b>predicate</b> <b>calculus</b> with {{equality}} ...|$|E
50|$|A <b>predicate</b> <b>calculus</b> {{will usually}} {{include all the}} same rules as a propositional calculus, with the {{addition}} of quantifiers such that if we take Φ to be a formula of propositional logic and α as a variable then we can take (α)Φ and (α)Φ each to be formulas of our <b>predicate</b> <b>calculus.</b>|$|E
50|$|We axiomatize <b>predicate</b> <b>calculus</b> without {{equality}} (sometimes confusingly called without identity), i.e. {{there are}} no special axioms expressing the properties of (object) equality as a special relation symbol. After the basic form of the theorem has been proved, it will be easy to extend it {{to the case of}} <b>predicate</b> <b>calculus</b> with equality.|$|E
5000|$|... can be notated in the {{language}} of monadic <b>predicate</b> <b>calculus</b> as ...|$|E
5000|$|Abstract {{machines}} for logic programming languages. These {{are based on}} <b>predicate</b> <b>calculus.</b>|$|E
50|$|Using modern <b>predicate</b> <b>calculus,</b> {{we quickly}} {{discover}} that the statement is ambiguous.|$|E
5000|$|Database for {{beliefs about}} the world, {{represented}} using first order <b>predicate</b> <b>calculus.</b>|$|E
5000|$|... #Subtitle level 2: Gödel (1930): The {{first order}} <b>predicate</b> <b>calculus</b> is {{complete}} ...|$|E
5000|$|The {{ability to}} prove {{completeness}} for <b>predicate</b> <b>calculus</b> {{when it is}} expressed in this way.|$|E
50|$|In this approach, {{a formula}} in first-order logic (<b>predicate</b> <b>calculus)</b> is {{represented}} by a labeled graph.|$|E
5000|$|... 153 Marcel Guillaume, Les tableaux sémantiques du calcul des prédicats {{restreint}} (semantic tableaux in <b>predicate</b> <b>calculus)</b> ...|$|E
