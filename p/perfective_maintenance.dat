39|8|Public
50|$|Software {{maintenance}} tasks {{have five}} categories: adaptive maintenance, corrective maintenance, <b>perfective</b> <b>maintenance,</b> code reuse, and code leverage.|$|E
5000|$|<b>Perfective</b> <b>maintenance</b> [...] - [...] Enhancements (modifications) {{to improve}} the safety, reliability, {{efficiency}} or cost-effectiveness of operation.|$|E
40|$|Information systems tend to {{last several}} years. But {{they have to}} be updated over time to meet the new {{business}} needs, originating new requirements. Maintenance {{plays an important role in}} the software's life cycle, incorporating the new needs into the existing product, through a controlled, defined and effective development process. Unfortunately this is not an easy task. Most of the projects slipped, exceeding their initial budgets and schedules. Additionally, maintenance costs are rising, with estimated cost from 60 % to 80 % of the total software budget. Maintenance is an extended subject. This study is focused only in the <b>perfective</b> <b>maintenance</b> process. A few techniques (such as IEEE Standard 1219, CMM, Scrum and ITIL) are being used in order to reduce the costs and gain control over the process. Besides that it is necessary an excellent knowledge of the <b>perfective</b> <b>maintenance</b> process, as well a management tool with good control mechanisms, aligned with the process. With this study we propose to elicit the <b>perfective</b> <b>maintenance</b> process and to create a management tool which reflects the process needs and integrates the old systems used by OutSystems. Working close to OutSystems ' professionals, it was defined and evaluated their main needs during th...|$|E
40|$|This paper {{presents}} a quantitative comparison of corrective and <b>perfective</b> software <b>maintenance</b> activities. The comparison utilizes basic data collected throughout the maintenance process. The data collected are extensive {{and allow the}} impact of both types of maintenance to be quantitatively evaluated and compared. Basic statistical techniques test relationships between and among process and product data. The results show interesting similarities and important differences in both process and product characteristics...|$|R
40|$|This paper {{presents}} the results of a hybrid estimation model for <b>perfective</b> software <b>maintenance</b> applied in a real context. The resulting model integrates heuristics and parametric methods to improve the maintenance estimation. One of the main objectives of this model is the inclusion of functionalities that provide zero function points. These functionalities can be supported by the model through impact points. Likewise, the micro function points and weighted risks have been included to provide a more realistic estimate. Finally, the model was implemented in a SME where the estimates were very approximates to the real effort. As result, the model could be implemented in a small organization with a stable maintenance process and effort deviation was 11 % after applying the model. Presentado en el VIII Workshop Ingeniería de Software (WIS...|$|R
40|$|In the {{conventional}} {{view of the}} software life cycle, software is produced, delivered to the user, and then enters a maintenance stage. Maintenance is the more expensive and extensive activity, and many surveys exist that analyze {{it in terms of}} constituent activities such as corrective, <b>perfective,</b> adaptive <b>maintenance,</b> etc. In this paper, we suggest a different view that partitions {{the conventional}} maintenance phase in a more useful, relevant and constructive way. We retain initial development, but then propose an explicit evolution stage. Next is a service stage, consisting of simple tactical activities. Later still, the software moves to a phase-out stage and finally to a close-down. The key point is that software evolution is quite different and separate from servicing, from phase-out, and from close-down, and this distinction is crucial in clarifying both the technical and business consequences. This perspective, by adopting both technical and business roles, is useful in planning [...] ...|$|R
40|$|INTRODUCTION Software {{maintenance}} is {{the design and}} integration of consistent changes to an existing software system and consists of various activities [Gallagher 1991]. One such activity, <b>perfective</b> <b>maintenance,</b> is concerned with improving the eciency of software and increasing its maintainability [Burch 1992; Schach 1999]. Apart from these gains, <b>perfective</b> <b>maintenance</b> also aects the other activities of corrective and adaptive maintenance. First, a system that can be eciently maintained allows one to quickly isolate and correct errors (corrective maintenance). Second, such a system ensures that new functionality can be added more easily to address the changing needs of users (adaptive maintenance). Restructuring, also called refactoring when used {{in the context of}} object-oriented frameworks [Opdyke 1992; Fowler 2000], is one technique that may be applied to improve the structure, and therefore the maintainability, of a software system. Restructuring is the process of re-organizin...|$|E
40|$|Software {{maintenance}} involves {{different categories}} of activities: corrective, adaptive, perfective, and preventive. However, research regarding these distinct activities is hampered {{by lack of}} empirical data that is labeled to identify the type of maintenance being performed. A promising dataset {{is provided by the}} more than 800 releases of the Linux kernel that have been made since 1994. The Linux release scheme differentiates between development versions (which may be expected to undergo <b>perfective</b> <b>maintenance)</b> and production versions (probably dominated by corrective maintenance). The structure of the codebase also distinguishes code involved in handling different architectures and devices (where additions reflect adaptive maintenance) from the core of the system’s kernel. Assuming that these dissections of the codebase indeed reflect different types of activity, we demonstrate that corrective maintenance does not necessarily lead to code deterioration, that adaptive maintenance may improve some quality metrics, and that growth is largely the result of continued development as part of <b>perfective</b> <b>maintenance...</b>|$|E
40|$|Abstract—As energy {{efficiency}} {{has become a}} key consideration in the engineering of mobile applications, {{an increasing number of}} <b>perfective</b> <b>maintenance</b> tasks are concerned with optimizing energy consumption. However, optimizing a mobile application to reduce its energy consumption is non-trivial due to the highly volatile nature of mobile execution environments. Mobile applications commonly run on a variety of mobile devices over mobile networks with divergent characteristics. Therefore, no single, static energy consumption optimization is likely to yield across-the-board benefits, and may even turn to be detrimental in some scenarios. In this paper, we present a novel approach to <b>perfective</b> <b>maintenance</b> of mobile applications to reduce their energy consumption. The maintenance programmer declaratively specifies the suspected energy consumption hotspots in a mobile application. Based on this input, our approach then automatically transforms the application to enable it to offload parts of its functionality to the cloud. The offloading is highly adaptive, being driven by a runtime system that dynamically determines both the state-to-offload and its transfer mechanism based on the execution environment in place. In addition, the runtime system continuously improves its effectiveness due to a feedback-loop mechanism. Thus, our approach flexibly reduces the energy con-sumption of mobile applications behind the scenes. Applying our approach to third-party Android applications has shown that it can effectively reduce the overall amount of energy consumed by these applications, with the actual numbers ranging between 25 % and 50 %. These results indicate that our approach represents a promising direction in developing pragmatic and systematic tools for the <b>perfective</b> <b>maintenance</b> of mobile applications. I...|$|E
40|$|The {{problem of}} change as {{manifested}} in <b>perfective</b> and adaptive <b>maintenance</b> is presented {{along with some}} of the qualities that software must possess in order to minimise the effects of change. These qualities can be provided by the Object Oriented paradigm. This paper describes the current work on a Method for Object Oriented Software Engineering (MOOSE) that has ease of maintenance and re-use as primary design objectives. A prototype CASE tool to support the method has also been developed: details and proposals for its re-engineered capabilities are given. No attempt is made to completely define the method, instead a general description of its features, particularly those pertinent to maintainability, is presented...|$|R
40|$|Enterprise Resource Planning (ERP) {{systems have}} reached {{a high level of}} maturity, and {{maintenance}} and improvement of implemented systems is becoming increasingly important. This paper proposes to analyze the ERP maintenance problem along three interrelated dimensions: software maintenance (SM), business process management (BPM) and process improvement (PI). It is argued that BPM and PI practices facilitate maintenance of ERP systems. The proposed analysis framework is applied to study maintenance of the ERP system at a large energy company. The analysis suggests that relatively high level of maturity has been achieved in corrective and adaptive maintenance. However, the level of maturity is lower in <b>perfective</b> and preventive <b>maintenance,</b> and links between maintenance of the ERP system and BPM should be improved...|$|R
40|$|The ISO/IEC 14764 {{standard}} specifies {{four types}} of software maintenance activities spanning the different motivations that software engineers have while performing changes to an existing software system. Undoubtedly, this classification has helped in organizing the workow within software projects, however for planning purposes the relative time differences for the respective tasks remains largely unexplored. In this empirical study, we investigate the inuence of the maintenance type on issue resolution time. From GitHub's issue repository, we analyze more than 14000 issue reports taken from 34 open source projects and classify them as corrective, adaptive, <b>perfective</b> or preventive <b>maintenance.</b> Based on this data, we show that the issue resolution time depends on the maintenance type. Moreover, we propose a statistical model to describe {{the distribution of the}} issue resolution time for each type of maintenance activity. Finally, we demonstrate the usefulness of this model for scheduling the maintenance workload. Copyright 2014 ACM...|$|R
40|$|Background Software {{maintenance}} {{is an important}} activity in the development process where maintenance team members leave and new members join over time. The identification of files which are changed together frequently has been proposed several times. Yet, existing studies about coupled file changes ignore the feedback from developers {{as well as the}} impact of these changes on the performance of maintenance and rather these studies rely on the analysis findings and expert evaluation. Methods We investigate the usefulness of coupled file changes during <b>perfective</b> <b>maintenance</b> tasks when developers are inexperienced in programming or when they were new on the project. Using data mining on software repositories we identify files that are changed most frequently together in the past. We extract coupled file changes from the Git repository of a Java software system and join them with corresponding attributes from the versioning and issue tracking system and the project documentation. We present a controlled experiment involving 36 student participants in which we investigate if coupled file change suggestions influence the correctness of the task solutions and the required time to complete them. Results The results show that the use of coupled file change suggestions significantly increases the correctness of the solutions. However, there is only a minor effect on the time required to complete the <b>perfective</b> <b>maintenance</b> tasks. We also derived a set of the most useful attributes based on the developers’ feedback. Discussion Coupled file changes and a limited number of the proposed attributes are useful for inexperienced developers working on <b>perfective</b> <b>maintenance</b> tasks where although the developers using these suggestions solved more tasks, they still need time to understand and organize this information...|$|E
40|$|Purpose: Enterprise systems (ESs) {{are hard}} to maintain, since they embed a large {{fraction}} of organisational data and tasks, which are often intertwined and highly interdependent. The {{purpose of this paper}} is to propose a methodology for enterprise resource planning (ERP) post-implementation change management to support business analysts during <b>perfective</b> <b>maintenance.</b> Design/methodology/approach: The methodology draws a parallel line with engineering change management and considers the steps of mapping the dependencies among ES components, understanding the ripple effects of change, and defining metrics to quantify and assess the impact of change. The methodology is instantiated in the case of ERP systems, for which a tool has also been implemented and evaluated by ERP implementation experts. Findings: Experts positively evaluated the proposed methodology. General design principles to instantiate the methodology in the case of systems other than ERP have been derived. Originality/value: While existing ESs change management methodologies help to identify the need for change, the proposed methodology help to structure the change process, supporting the task of <b>perfective</b> <b>maintenance</b> in an efficient way...|$|E
40|$|Abstract. Software can be {{considered}} an organizations asset, because it evolves and incorporates value as business rules change. So, {{it is important that}} good techniques be used in software development, in order to assure that its lifecyle is extended. One of these techniques is Design Rationale, which documents all the project decisions made during software development in order to ease revision, maintenance, documentation, evaluation and project learning. Design Rationale has been used in this paper in a context different than software development, in the reengineering of an electronic repair shop control legacy system, and the term Reengineering Rationale (RR) is used. In order to observe the behaviour of that technique in this context, a pilot case study has been conducted for analysing its importance to <b>perfective</b> <b>maintenance</b> of systems, resulting of reengineering. For this pilot case study two hypotheses have been formulated, one concerning the support provided by RRs to <b>perfective</b> <b>maintenance</b> and the other to maintenance time reduction. This paper discusses the results obtained and the lessons learned of a pilot case study conducted in academic environment...|$|E
40|$|In a grid application, some {{requirements}} {{may change}} while the execution is in progress. This paper presents invivo enhancement, changing running grid applications, to facilitate their <b>perfective</b> and adaptive <b>maintenance.</b> Because applications in this domain {{are not only}} typically long-running, but also time-consuming to deploy, we propose a dynamic update technique that can change a running application flexibly and efficiently. Specifically, this paper presents a novel technique for dynamically updating grid applications that are deployed on the Java Virtual Machine (JVM). Our technique overcomes constraints of JVM HotSwap, a facility for replacing classes at runtime. While HotSwap precludes the programmer from adding new methods and fields, changing the signatures of existing methods, and has no support for transferring state between old and new objects, our approach effectively removes these constraints by rewriting program bytecode. Further, the rewritten programs incur only minimal performance overhead (less than 2 % on average). We demonstrate the efficiency and extensibility of our approach through micro and macro benchmarks, {{as well as through}} a case study of dynamically updating a parallel bioinformatics application. 1...|$|R
40|$|Predictive {{models for}} {{software}} projects' characteristics have been traditionally based on project-level metrics, employing only little developer-level information, {{or none at}} all. In this work we suggest novel metrics that capture temporal and semantic developer-level information collected on a per developer basis. To address the scalability challenges involved in computing these metrics for each and every developer for {{a large number of}} source code repositories, we have built a designated repository mining platform. This platform was used to create a metrics dataset based on processing nearly 1000 highly popular open source GitHub repositories, consisting of 147 million LOC, and maintained by 30, 000 developers. The computed metrics were then employed to predict the corrective, <b>perfective,</b> and adaptive <b>maintenance</b> activity profiles identified in previous works. Our results show both strong correlation and promising predictive power with R-squared values of 0. 83, 0. 64, and 0. 75. We also show how these results may help project managers to detect anomalies in the development process and to build better development teams. In addition, the platform we built has the potential to yield further predictive models leveraging developer-level metrics at scale. Comment: Postprint, ICSME 2016 proceeding...|$|R
40|$|This {{paper is}} a {{contribution}} to the empirical literature on distributions of software maintenance amongst the primary activities of adaptive, corrective and <b>perfective</b> <b>maintenance.</b> Unusually, the software process under study here maintains detailed information on predicted versus actual effort and is therefore able to shed some light on how accurately engineers predict both the type of maintenance necessary and the duration. The quality of these predictions is subjected to formal statistical analysis, wit...|$|E
40|$|Approved {{for public}} release; {{distribution}} is unlimitedThis study discusses briefly {{the history of}} technical figure illustration in the Computer Science Department of the Naval Postgraduate School. The single system experiencing the most usage is the fully automated interactive graphics figure illustrator- OZDRAW. During its short and active life, the need for <b>perfective</b> <b>maintenance</b> to include generalized documentation has been recognized. The result is a technical graphics figure illustrator with an improved user interface titled NPSDRAW and supporting documentation. [URL] Commander, United States Nav...|$|E
40|$|Approved {{for public}} release; {{distribution}} is unlimitedThe Computer Performance Modeling Tool (CPMT) is a queueing network simulator {{to be used}} in support of Computer Performance and Evaluation courses like CS 4400. This thesis is a continuation of the CPMT development project and consists of adaptive and <b>perfective</b> <b>maintenance</b> work to modify the existing simulator to add extended modeling capability and to improve simulator performance. The thesis effort also included rewriting the CPMT's user's manual to reflect new features, establishing a change log for the program and continuing validation of the simulator. [URL] Commander, Portuguese Nav...|$|E
40|$|This study {{discusses}} briefly {{the history}} of technical figure illustration in the Computer Science Department of the Naval Postgraduate School. The single system experiencing the most usage is the fully automated interactive graphics figure illustrator [...] OZDRAW. During its short and active life, the need for <b>perfective</b> <b>maintenance</b> to include generalized documentation has been recognized. The result is a technical graphics figure illustrator with an improved user interface titled NPSDRAW and supporting documentationsupported by the U. S. Army Combat Development Experimentation Center, Fort Ord, California (ATEC 44 - 97) and {{a grant from the}} Naval Ocean Systems Center, San Diego, California (Ref. #N 0001486 WR 4 B 123 AC). [URL]...|$|E
40|$|In this paper, {{we propose}} a Round-Trip Engineering-based {{approach}} of optimizing the corrective, adaptive, evolutionary or <b>perfective</b> <b>maintenance</b> of applications on the OptimaDev, a MDA engine. It {{is a method}} which allows the automatic synchronization of updates between the model of an application and its source code when changes are brought vice-versa to the one or the other. The modifications made either on the model or in the source code and intervening afterthe source code generation from the MDA engines are not reflected mutually. In {{the context of the}} model-driven architectures (MDA), the ideal is to constantly have a model of the application which reflects its source code. Our approach helps to significantly reduce the quota of the total budget of the software development affected to maintenance...|$|E
30|$|There {{has been}} {{more than a decade of}} {{research}} in the field of software clones. To understand the growth and trends in different dimensions of cloning research, we carried out a quantitative review of related publications. Clone detection research has proved that software systems have 9 %- 17 % of duplicated code (Zibran et al. [2011]). (Thummalapenta et al. [2009]) indicated that in most of the cases, clones are changed consistently and for the remaining inconsistently changed cases, clones undergo independent evolution. Effective code clone detection will support <b>perfective</b> <b>maintenance.</b> Up to the present, several code clone detection methods have been proposed (Petersen [2012]; Al-Batran [2011]; Leitner et al. [2013]). Comparison and evaluation of code clone detection techniques and tools have been carried out by (Bellon and Koschke [2014]; Bellon et al. [2007]) and (Roy and Cordy [2007]; Roy et al. [2009]).|$|E
40|$|A central {{feature of}} the {{evolution}} of large software systems is that change [...] which is necessary to add new functionality, accommodate new hardware and repair faults [...] becomes increasingly difficult over time. In this paper we approach this phenomenon, which we term code decay, scientifically and statistically. We define code decay, and propose a number of measurements (code decay indices) on software, and on the organizations that produce it, that serve as symptoms, risk factors and predictors of decay. Using an unusually rich data set (the fifteen-plus year change history of the millions of lines of software for a telephone switching system), we find mixed but on the whole persuasive statistical evidence of code decay, which is corroborated by developers of the code. Suggestive indications that <b>perfective</b> <b>maintenance</b> can retard code decay are also discussed...|$|E
40|$|Abstract — Perfective {{changes in}} {{well-established}} software systems {{are easier to}} perform when the development team has a solid understanding of the internals. However, {{it is reasonable to}} assume that the use of an open source system to incorporate new features and obtain a new software product is an appealing approach instead of coding a new product from scratch. Considering this scenario, and considering that it is not uncommon that systems are poorly documented, there is no widely accepted approach to guide the <b>perfective</b> <b>maintenance</b> for developers with low understanding of the system. This work proposes a new method based on the analysis of execution traces for locating evolution points in the source code where changes should be performed. The proposed method was evaluated with three open source systems and the conclusion suggests a significant impact on effort reduction...|$|E
40|$|International audienceThis paper {{presents}} {{an analysis of}} technical debt management through resources allocation policies in software maintenance process during its operation to demonstrate how different strategies leads {{to the emergence of}} different behaviors along the evolution path. To achieve this objective, this work used the System Dynamic approach for building a computational simulation model based on extensive literature review and secondary data. Most of the works that applied the System Dynamics on software projects research, focused on initial phases of its life cycle, leaving a gap to be explored regarding the long-term behaviors of the operation and maintenance phases. The results demonstrated that the excessive focus on the <b>perfective</b> <b>maintenance</b> activities could be more costly than performing regular preventive maintenance to reduce the technical debt incurred, ending up with fewer functionalities deployed, higher backlog, lower productivity, lower maintainability and higher technical principal...|$|E
40|$|Software maintenance, {{although}} {{widely recognized}} as the most costly period {{in the life of}} a system, is given only passing consideration in life-cycle models. An extensive literature review shows the relationship between the development and maintenance phases to be ignored to a large extent. The Abstraction Refinement Model (ARM) describes the dependency of software maintenance on the quality of the documentation and depicts the adaptive and <b>perfective</b> <b>maintenance</b> forms as relying on earlier design and requirements documents to a greater degree than corrective and preventative maintenance. The ARM is effective in laying the foundations for a software maintenance methodology, particularly in explaining the role of reverse engineering. Coupling the ARM with the Objectives/Principles/Attributes procedure for the evaluation for software development methodologies proves effective in drawing the contrast with maintenance requirements. which are specifically identified for further study and assessment...|$|E
40|$|This paper {{provides}} an overview of the relationship between recent work in logic programming and recent developments in software engineering. The relationship to software engineering is more specifically concerned with how formal specifications can be used to explain and represent the basis of software maintenance and evolution. Some of the results reviewed here have appeared in [5] and [13]. These previous results are summarized, extended, and made more general in this paper. 1 Introduction Maintenance activities can be divided into three distinct classes: corrective, perfective, and adaptive. Corrective maintenance largely reflects the failure of software engineers to validate and verify software specifications and programs with respect to software specifications, respectively. <b>Perfective</b> <b>maintenance</b> is traditionally viewed as a form of maintenance necessary to improve or change the performance of a system, but not its functionality. Adaptive software maintenance alters the function [...] ...|$|E
40|$|Software {{design is}} a {{difficult}} creative task learnt from long experience. Reusable object-oriented design aims to describe and classify designs and design fragments so that designers may learn from other peoples' experience. Thus, it provides leverage for the design process. This paper surveys the field, discussing software architectures, application frameworks, design patterns, and the design of class libraries. The field is young with many open problems that {{still need to be}} researched. 1 Introduction The drive for productivity in the software industry is forcing major changes in the ways that software development and maintenance are being done. Traditionally, over 80 % of total expenditure is directed to software maintenance (including corrective, adaptive, and <b>perfective</b> <b>maintenance),</b> and about 60 - 70 % of the effort of maintenance is directed towards understanding the software (requirements, architecture, design, and code). Hence, lowering the effort and costs of maintenance and und [...] ...|$|E
30|$|After the training, {{subjects}} {{received some}} artifacts {{that could be}} used during the study. They received a list with {{a brief description of the}} types of design problems presented in the training session. They also received a list with the description of basic principles of object-oriented programming and software design. They received a document containing (i) a brief description of both project systems and (ii) a very high level description of their design blueprint. We gave these documents because when they have to conduct <b>perfective</b> <b>maintenance</b> tasks, they need to have some minimal information about the systems to be maintained. The design blueprint represented the high-level design in the view of the project managers, but it was not detailed enough to support the identification of design problems. As it often occurs in practice, the analysis of the source code is inevitably required to identify a design problem.|$|E
40|$|Information needed {{during an}} {{iterative}} process of a software maintenance process {{is much different}} from that of a software development process. Without up-dated documents, software maintainers need to gain information required to solve different maintenance categories through source codes hence consuming more time and effort. With the emergence of reverse engineering tools, the process of understanding source codes to solve maintenance tasks in different maintenance categories can be improved. Such tools employ diverse software visualisation methods that generate graph representations of parsed software artifacts. This paper discusses on how the graph representations provided by the proposed DocLike Modularised Graph (DMG) method employed in DocLike Viewer prototype tool can serve different levels of information needed by software maintainers in the case of corrective, adaptive and <b>perfective</b> <b>maintenance</b> category. It is observed that not only do software maintainers require diverse level of information; the necessity of the information is also not exactly of the same degree...|$|E
40|$|Software {{maintenance}} {{is the most}} expensive activity in software development. Many software companies spent a large amount of cost to maintain the existing software systems. In <b>perfective</b> <b>maintenance,</b> refactoring has often been applied to the software to improve the understandability and complexity. One of the targets of refactoring is code clone. A code clone is a code fragment in a source code that is identical or similar to another. In an actual software development process, code clones are introduced because of various reasons such as reusing code by `copy-and-paste' and so on. Code clones are one of the factors that make software maintenance di#cult. In this paper, we propose a method which removes code clones from object oriented software by using existing refactoring patterns, especially "Extract Method" and "Pull Up Method". Then, we have implemented a refactoring supporting tool based on the proposed method. Finally, we have applied the tool to an open source program and actually perform refactoring...|$|E
40|$|In this study, we {{investigated}} {{the use of}} virtual communities for involving distributed customers in the maintenance of packaged software. On {{the basis of an}} empirical study, we suggest that virtual communities can be usefully leveraged for corrective, adaptive, and perfective software maintenance. Specifically, the virtual community al-lowed for quick discovery of bugs and a rich interaction between developers and cus-tomers in the categories of corrective and adaptive software maintenance. However, although contributing also to the perfective category of software maintenance, this was the category in which several customer suggestions for modification were actually ig-nored by the developers. This implies that community use is indeed beneficial for maintenance related to coding and design errors as well as for maintenance of an adap-tive character. However, it has limitations when associated with major changes such as software functionality addition or modification as those experienced in the category of <b>perfective</b> <b>maintenance.</b> packaged software, software maintenance, virtual communities 1...|$|E
40|$|This paper {{presents}} {{an analysis of}} technical debt management through resources allocation policies in software maintenance process during its operation to demonstrate how different strategies leads {{to the emergence of}} different behaviors along the evolution path. To achieve this objective, this work used the System Dynamic approach for building a computational simulation model based on extensive literature review and secondary data. Most of the works that applied the System Dynamics on software projects research, focused on initial phases of its life cycle, leaving a gap to be explored regarding the long-term behaviors of the operation and maintenance phases. The results demonstrated that the excessive focus on the <b>perfective</b> <b>maintenance</b> activities could be more costly than performing regular preventive maintenance to reduce the technical debt incurred, ending up with fewer functionalities deployed, higher backlog, lower productivity, lower maintainability and higher technical principal. Comment: in Proceedings of the 34 th International Conference of the System Dynamics Society, Jul 2016, Delft, Netherlands. 201...|$|E
40|$|The {{tremendous}} {{growth of}} the area of software measurement requires new model for measurement roles. Changes to software maintenance (SM) process measurement of corrective, preventive, adaptive and <b>perfective</b> <b>maintenance</b> may affect the way of users use the measurement. As well as most of an existing measurement models does not truly or accurately reflect process maturity and tasks difficulty. To verify and solve the current problem issues, we propose a model of SM based on CMMI KPAs (Capability Maturity Model Integration Key Process Areas) and demonstrates these measurement roles into a system of Multi Agent System (MAS) to identify the processes measurement of SM. This model composed of three layers of CMMI layer, Agent layer and SM layer and its architecture consists of four types of agents: Personal Agent (PA), Maintenance Type Agent (MTA), Key Process Area Agent (KPAA) and Ruler Agent (RA). The expected output of our model is to translate the ordinal scale of SM to interval scale to be more accrue and clearly...|$|E
40|$|The area of {{software}} evolution has gained tremendous {{interest in the}} software research and industry communities during the last decade. This is not surprising considering the fact that, according to a 1988 {{study conducted by the}} National Institute of Standards and Technology (NIST) 60 to 85 percent of the total cost {{of software}} is due to maintenance, and of this, about 60 percent is invested for so-called <b>perfective</b> <b>maintenance,</b> continued development and evolution of a software system after it has become operational. Any change to a software system is a prodigious source of new software faults and inconsistencies {{in other parts of the}} system. The arising inconsistencies can be conceptual, structural, or behavioral, depending on whether they affect the schema, the objects, or the methods, respectively. The evolution process must resolve such inconsistencies in order to keep the system operational. Therefore, changes potentially trigger other changes which in turn may trigger yet other [...] ...|$|E
