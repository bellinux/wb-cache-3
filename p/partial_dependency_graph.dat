0|1269|Public
40|$|Abstract — We {{propose a}} method of synthesizing {{pipeline}} controllers as four-phase asynchronous circuits from specifications described as two-phase <b>dependency</b> <b>graphs.</b> Pipeline twophase <b>dependency</b> <b>graphs</b> are transformed into four-phase ones by applying a transformation rule to each simple loop in the <b>graphs.</b> Four-phase <b>dependency</b> <b>graphs</b> are easily mapped onto four-phase asynchronous control circuits. We also discuss some simplification of four-phase <b>dependency</b> <b>graphs.</b> I...|$|R
40|$|The <b>dependency</b> <b>graph</b> is a data {{architecture}} that models all the dependencies {{between the different}} types of assets in the game. It depicts the dependency-based relationships between the assets of a game. For example, a player must construct an arsenal before he can build weapons. It is vital that the <b>dependency</b> <b>graph</b> of a game is designed logically to ensure a logical sequence of game play. However, a mere logical <b>dependency</b> <b>graph</b> is not sufficient in sustaining the players' enduring interests in a game, which brings the problem of game balancing into picture. The issue of game balancing arises when the players do not feel the chances of winning the game over their AI opponents who are more skillful in the game play. At the current state of research, the architecture of <b>dependency</b> <b>graph</b> is monolithic for the players. The sequence of asset possession is always foreseeable because there is only a single <b>dependency</b> <b>graph.</b> Game balancing is impossible when the assets of AI players are overwhelmingly outnumbering that of human players. This paper proposes a parallel architecture of <b>dependency</b> <b>graph</b> for the AI players and human players. Instead of having a single <b>dependency</b> <b>graph,</b> a parallel architecture is proposed where the <b>dependency</b> <b>graph</b> of AI player is adjustable with that of human player using a support dependency as a game balancing mechanism. This paper exhibits that the parallel <b>dependency</b> <b>graph</b> helps to improve game balancing. Comment: 5 page...|$|R
40|$|<b>Dependency</b> <b>graphs</b> {{are used}} as {{intermediate}} representations in optimizing compilers and software-engineering. In a transformational design approach, optimization and refinement transformations are used to transform dependencygraph -based specifications at higher abstraction levels to those at lower abstraction levels. An informal representation would lead to subtle errors, {{making it difficult to}} guarantee the correctness of the transformations. In this work, we investigated the formal specification and efficient mechanical verification of transformations on <b>dependency</b> <b>graphs.</b> 1 Introduction <b>Dependency</b> <b>graphs</b> 1 are used to model model data and control flow in software and hardware design. A <b>dependency</b> <b>graph</b> consists of nodes representing operations or processes, and directed edges representing data dependencies and data flow through the system. In addition, control flow could also be represented in a <b>dependency</b> <b>graph</b> in several ways. We show an example of such a graph in Figure 1. In [...] ...|$|R
40|$|The {{mapping of}} array {{operations}} in VAI, programs on a static {{data flow machine}} with array memory is studied. The flow <b>dependency</b> <b>graph</b> is introduced {{as a model of}} array operations in VAL programs. The balancing and optimization of the flow <b>dependency</b> <b>graphs</b> is presented. The class of well-behaved VAL prograins which can be modeled by flow <b>dependency</b> <b>graphs</b> is specified. Schemes for pipelined mapping of forall and for-iter array operation constructs in well-behaved VAL programs are formulated Thesis Supervisor: Jack B. Dennis Title: Professor of Electrical Engineering and Computer Science key words:. parallel processing, flow <b>dependency</b> <b>graph,</b> pipelined computation, data flow architecture, functional programming, VAL...|$|R
40|$|Abstract. Many search-based QBF solvers {{implementing}} the DPLL algorithm for QBF (QDPLL) process formulae in prenex {{conjunctive normal form}} (PCNF). The quantifier prefix of PCNFs often results in strong variable dependencies which can influence solver performance negatively. A common approach to overcome this problem is to reconstruct quantifier structure e. g. by quantifier trees. Dependency schemes are a generalization of quantifier trees {{in the sense that}} more general <b>dependency</b> <b>graphs</b> can be obtained. So far, <b>dependency</b> <b>graphs</b> have not been applied in QBF solving. In this work we consider the problem of efficiently integrating <b>dependency</b> <b>graphs</b> in QDPLL. Thereby we generalize related work on integrating quantifier trees. By analyzing the core parts of QDPLL, we report on modifications necessary to profit from general <b>dependency</b> <b>graphs.</b> In comprehensive experiments we show that QDPLL using a particular <b>dependency</b> <b>graph,</b> despite of increased overhead, outperforms classical QDPLL relying on quantifier prefixes of PCNFs. ...|$|R
40|$|In {{this thesis}} {{we present a}} novel {{approach}} {{to the analysis of}} <b>dependency</b> <b>graphs</b> of object-oriented programs, and we describe a tool that has been implemented for this purpose. A graph-theoretical clustering algorithm is used in order to compute the modular structure of programs. This can be used to assist software engineers to redraw component boundaries in software in order to improve the level of reuse and maintainability. The analysis of the <b>dependency</b> <b>graph</b> of an object-oriented program is useful for assessing the quality of software design. The <b>dependency</b> <b>graph</b> can be extracted from a program using various different methods, including source code, byte code, and dynamic (behavioral) analysis. The nodes in the <b>dependency</b> <b>graph</b> are classes, members, packages and other artifacts, while the edges represent uses and extends relationships between those artifacts. Once the <b>dependency</b> <b>graph</b> has been extracted, it can be analysed in order to quantify certain characteristics of the respective program. Examples include the detection of circular dependencies and measurements of the responsibility or independence of units based on their relationships. Tools like JDepend 1 implementing these principles have become very popular in recent years. Our work includes grouping types in <b>dependency</b> <b>graphs</b> using di erent clustering methods: Grouping into namespaces; Grouping into clusters using graph clustering algorithms; Grouping into clusters using rules. The detected mismatches are candidates for refactoring. We have developed a tool for processing <b>dependency</b> <b>graphs</b> clustering and producing results where users can outline possible design violations...|$|R
25|$|File:Ann {{dependency}} (graph).svg|An ANN <b>dependency</b> <b>graph.</b>|$|R
40|$|Causal Models {{are like}} <b>Dependency</b> <b>Graphs</b> and Belief Nets {{in that they}} provide a {{structure}} {{and a set of}} assumptions from which a joint distribution can, in principle, be computed. Unlike <b>Dependency</b> <b>Graphs,</b> Causal Models are models of hierarchical and/or parallel processes, rather than models of distributions (partially) known to a model builder through some sort of gestalt. As such, Causal Models are more modular, easier to build, more intuitive, and easier to understand than <b>Dependency</b> <b>Graph</b> Models. Causal Models are formally defined and <b>Dependency</b> <b>Graph</b> Models are shown to be a special case of them. Algorithms supporting inference are presented. Parsimonious methods for eliciting dependent probabilities are presented. Comment: Appears in Proceedings of the Ninth Conference on Uncertainty in Artificial Intelligence (UAI 1993...|$|R
5|$|<b>Dependency</b> <b>graphs</b> without {{circular}} <b>dependencies</b> form DAGs.|$|R
50|$|In mathematics, {{computer}} science and digital electronics, a <b>dependency</b> <b>graph</b> is a directed <b>graph</b> representing <b>dependencies</b> of several objects towards each other. It {{is possible to}} derive an evaluation order or {{the absence of an}} evaluation order that respects the given dependencies from the <b>dependency</b> <b>graph.</b>|$|R
5000|$|Dependency Visualization (using <b>dependency</b> <b>graphs,</b> and <b>dependency</b> matrix) ...|$|R
40|$|In {{packetized}} media streaming systems, packet dependencies {{are often}} modeled as a directed acyclic <b>graph</b> called the <b>dependency</b> <b>graph.</b> We consider {{the situation where}} the <b>dependency</b> <b>graph</b> is reducible to a tree. This occurs, for instance, in MPEG 1 video streams that are packetized at the frame level. Other video coding standards such as H. 264 also allow tree-reducible dependencies. We propose in this context efficient dynamic programming algorithms for finding rate-distortion optimal transmission policies. The proposed algorithms are much faster than previous exact algorithms developed for arbitrary <b>dependency</b> <b>graphs.</b> © 2006 SPIE-IS&T. info:eu-repo/semantics/publishe...|$|R
40|$|AbstractThis paper {{describes}} a new evaluator {{capable of handling}} noncircular or circular attribute grammars. The evaluator combines recursive evaluation of attribute instances and dynamic determination of paths in the compound <b>dependency</b> <b>graph</b> for a given input. The compound <b>dependency</b> <b>graph</b> is not constructed. Instead, the production-labelled semantic tree of the input and the <b>dependency</b> <b>graphs</b> of the productions which implicitly represent the compound <b>dependency</b> <b>graph</b> are used. The incremental version of the evaluator is obtained by a simple modification. It avoids re-evaluation of those attribute instances whose values are not affected by the modifications of the input. The evaluator has time complexity linear {{in the number of}} attributes needed to specify the meaning of the input string, and has space complexity linear {{in the size of the}} parse tree...|$|R
40|$|Dataflow {{constraints}} allow programmers {{to easily}} specify relationships among application objects in a natural, declarative manner. Most constraint solvers represent these dataflow relationships as directed edges in a <b>dependency</b> <b>graph.</b> Unfortunately, <b>dependency</b> <b>graphs</b> require {{a great deal}} of storage. Consequently, an application with a large number of constraints can get pushed into virtual memory and performance degrades in interactive applications. Our solution is based on the observation that objects derived from the same prototype use the same constraints and thus have the same <b>dependency</b> <b>graphs.</b> We represent the common dependency patterns in a model <b>dependency</b> <b>graph</b> that is stored in a prototype. Instance objects may derive explicit <b>dependencies</b> from this <b>graph</b> when the <b>dependencies</b> are needed. Model dependencies provide a useful new mechanism for improving the storage efficiency of dataflow constraint systems, especially when a large number of constrained objects must be managed. [...] ...|$|R
5000|$|... #Caption: A <b>dependency</b> <b>graph</b> for the C3 {{linearization}} example.|$|R
5000|$|A novel {{visualization}} of traditional Arabic grammar through <b>dependency</b> <b>graphs.</b>|$|R
5000|$|Code exploration: call graphs, CRUD matrix, cross-references, <b>dependency</b> <b>graphs</b> [...]|$|R
40|$|A new {{approach}} for parallelism analysis and extraction of {{digital signal processing}} algorithms is introduced. The high level description of the input is given in CIRCAL. A <b>dependency</b> <b>graph</b> {{of the problem is}} constructed to check existence of cycles. Loops in the <b>dependency</b> <b>graph</b> are parallelized. The approach is illustrated by an exampl...|$|R
40|$|Abstract. We {{present a}} {{symbolic}} extension of <b>dependency</b> <b>graphs</b> by Liu and Smolka {{in order to}} model-check weighted Kripke structures against the logic CTL with upper-bound weight constraints. Our extension introduces {{a new type of}} edges into <b>dependency</b> <b>graphs</b> and lifts the computation of fixed-points from boolean domain to nonnegative integers in order to cope with the weights. We present both global and local algorithms for the fixed-point computation on symbolic <b>dependency</b> <b>graphs</b> and argue for the advantages of our approach compared to the direct encoding of the model checking problem into <b>dependency</b> <b>graphs.</b> We implement all algorithms in a publicly available tool prototype and evaluate them on several experiments. The principal conclusion is that our local algorithm is the most efficient one with an order of magnitude improvement for model checking problems with a high number of “witnesses”. ...|$|R
40|$|Abstract. This paper {{describes}} a methodology based on <b>dependency</b> <b>graphs</b> for doing concurrent run-time error detection in systolic arrays and wavefront processors. It combines the projection method of deriving systolic arrays from <b>dependency</b> <b>graphs</b> {{with the idea}} of input-triggered testing. We call the method ITRED, for Input-driven 7 ~me-Redundancy Error Detection. Tests are triggered by inserting special symbols in the input, and so the approach gives the user flexibility in trading off throughput for error coverage. Correctness of timing is proved at the <b>dependency</b> <b>graph</b> level. The method requires no extra PEs and little extra hardware. We propose several variations of the general approach and derive corresponding constraints on the modified <b>dependency</b> <b>graphs</b> that guarantee correct-ness. One variation performs run-time error correction using majority voting. Examples are given, including a dynamic programming algorithm, convolution, and matrix multiplication. 1...|$|R
40|$|<b>Dependency</b> <b>graphs</b> {{are used}} to model data and control flow in {{hardware}} and software design. In a transformational design approach, optimization and refinement transformations {{are used to}} transform dependency-graph-based specifications at higher abstraction levels to those at lower abstraction levels. In this dissertation, we investigate the formal specification and mechanical verification of transformations on <b>dependency</b> <b>graphs.</b> Among formal methods, the axiomatic method provides a mechanism to specify an object by asserting properties it should satisfy. We show that an axiomatic specification coupled with an efficient mechanical verification is the most suitable formal approach to address the verification of transformations on <b>dependency</b> <b>graphs.</b> We have provided a formal specification of <b>dependency</b> <b>graphs,</b> and verified the correctness {{of a variety of}} transformations used in an industrial synthesis framework. Errors have been discovered in the transformations, and modifications have bee [...] ...|$|R
40|$|This work weakens {{well-known}} consistency models using graphs {{that capture}} applications' characteristics. The weakened models not only respect application semantic, but also yield a performance benefit. We introduce {{a notion of}} <b>dependency</b> <b>graphs,</b> which specify relations between events that are important with respect to application semantic, and then weaken traditional consistency models (e. g., causal consistency) using these graphs. Particularly, we consider two types of graphs: intra-process and inter-process <b>dependency</b> <b>graphs,</b> where intra-process <b>dependency</b> <b>graphs</b> specify how events in a single process are related, and inter-process <b>dependency</b> <b>graphs</b> specify how events across multiple processes are related. Then, based on {{these two types of}} graphs, we define new consistency model, namely application-aware consistency. We also discuss why such application-aware consistency can be useful in social network applications. This is a work in progress, and we present early ideas regarding application-aware consistency here...|$|R
5000|$|... #Caption: [...] Two {{separate}} {{depictions of}} the recurrent ANN <b>dependency</b> <b>graph</b> ...|$|R
40|$|In {{this paper}} a new {{approach}} for parallelism analysis and extraction of Digital Signa! Processing algorithms is introduced. The high level description of the input is given in CIRCAL. A <b>dependency</b> <b>graph</b> {{of the problem is}} constructed to check existence of cycles. Loops in the <b>dependency</b> <b>graph</b> are parallelized The approach is illustrated by an example. ...|$|R
40|$|This paper {{describes}} a methodology based on <b>dependency</b> <b>graphs</b> for doing concurrent runtime error detection in systolic arrays and wavefront processors. It combines the projection method of deriving systolic arrays from <b>dependency</b> <b>graphs</b> {{with the idea}} of input-triggered testing. We call the method ITRED, for Input-driven Time-Redundancy Error Detection. Tests are triggered by inserting special symbols in the input, and so the approach gives the user flexibility in trading off throughput for error coverage. Correctness of timing is proved at the <b>dependency</b> <b>graph</b> level. The method requires no extra PE's and little extra hardware. We propose several variations of the general approach and derive corresponding constraints on the modified <b>dependency</b> <b>graphs</b> that guarantee correctness. One variation performs run-time error correction using majority voting. Examples are given, including a dynamic programming algorithm, convolution, and matrix multiplication. y This work {{was supported in part by}} [...] ...|$|R
40|$|To {{reduce the}} {{down-time}} of software systems and maximise {{the set of}} available services during reconfiguration, we propose exploiting component protocol information. This is achieved by knowing the state of a running system and determining the component dependencies for the time interval from receiving a reconfiguration request until reconfiguration completion. For this forecast we use the architectural descriptions that specify static dependencies, as well as component protocol information. By considering only component interactions for the time interval of reconfiguration we can exclude past and future dependencies from our runtime <b>dependency</b> <b>graphs.</b> We show that such change-request-specific runtime <b>dependency</b> <b>graphs</b> may be considerably smaller than the corresponding static architecture based <b>dependency</b> <b>graph...</b>|$|R
5000|$|They detect {{dependencies}} {{by observing}} whether the result obtained by evaluation matches the parameter values observed at runtime. Malware is detected {{by comparing the}} <b>dependency</b> <b>graphs</b> of the training and test sets. Fredrikson et al. describe an approach that uncovers distinguishing features in malware system call <b>dependency</b> <b>graphs.</b> They extract significant behaviors using concept analysis and leap mining. [...] Babic et al. recently proposed a novel approach for both malware detection and classification based on grammar inference of tree automata. Their approach infers an automaton from <b>dependency</b> <b>graphs,</b> and they show how such an automaton {{could be used for}} detection and classification of malware.|$|R
5000|$|<b>Dependency</b> <b>graph</b> is a {{directed}} <b>graph</b> representing <b>dependencies</b> {{of several}} objects towards each other.|$|R
5000|$|... makeppgraph is a <b>dependency</b> <b>graph</b> {{generator}} (at module level) for builds {{performed with}} makepp.|$|R
40|$|<b>Dependency</b> <b>graph,</b> as a {{heterogeneous}} graph representing the intrinsic relationships between different pairs of system entities, {{is essential to}} many data analysis applications, such as root cause diagnosis, intrusion detection, etc. Given a well-trained <b>dependency</b> <b>graph</b> from a source domain and an immature <b>dependency</b> <b>graph</b> from a target domain, how can we extract the entity and dependency knowledge from the source to enhance the target? One way is to directly apply a mature <b>dependency</b> <b>graph</b> learned from a source domain to the target domain. But due to the domain variety problem, directly using the source <b>dependency</b> <b>graph</b> often can not achieve good performance. Traditional transfer learning methods mainly focus on numerical data and are not applicable. In this paper, we propose ACRET, a knowledge transfer based model for accelerating <b>dependency</b> <b>graph</b> learning from heterogeneous categorical event streams. In particular, we first propose an entity estimation model to filter out irrelevant entities from the source domain based on entity embedding and manifold learning. Only the entities with statistically high correlations are transferred to the target domain. On the surviving entities, we propose a dependency construction model for constructing the unbiased dependency relationships by solving a two-constraint optimization problem. The experimental results on synthetic and real-world datasets demonstrate the effectiveness and efficiency of ACRET. We also apply ACRET to a real enterprise security system for intrusion detection. Our method is able to achieve superior detection performance at least 20 days lead lag time in advance with more than 70 % accuracy...|$|R
40|$|The Spoken Dutch Corpus assigns {{1 million}} of its 9 million total words a syn- tactic {{annotation}} {{in the form of}} <b>dependency</b> <b>graphs.</b> We will look at strategies for automatically extracting a lexicon of type-logical supertags from these <b>dependency</b> <b>graphs</b> and investigate how different levels of lexical detail affect the size of the resulting lexicon as well as the performance with respect to supertag disambiguation...|$|R
40|$|This note is a {{response}} to Bas Spitter's email of 28 February 2014 about ML 4 PG: "We (Jason actually) are adding <b>dependency</b> <b>graphs</b> to our HoTT library: [URL] I seem to recall that finding the <b>dependency</b> <b>graph</b> was a main obstacle preventing machine learning to be used in Coq. However, you seem to have made progress on this. What tool are you using? [URL] ? Or another tool? Would it be easy to use your ML 4 PG on the HoTT library?" This note gives explanation of how ML 4 PG can be used in the HoTT library and how ML 4 PG relates to the two kinds of <b>Dependency</b> <b>graphs</b> available in Coq...|$|R
40|$|In [3], we have {{developed}} a strategy which allows investigating the effectiveness of several optimisations on the code execution time and {{the choice of the}} best one to apply. This strategy is based on modelling the data <b>dependency</b> <b>graph</b> of the hot part of a code using the stochastic process algebra PEPA. In this paper, we present the algorithm allowing the translation of a data <b>dependency</b> <b>graph</b> into a PEPA model. ...|$|R
50|$|Published 2000. This is an {{improvement}} over the first reaction method where the unused reaction times are reused. To make the sampling of reactions more efficient, an indexed priority queue is used to store the reaction times. On the other hand, to make the recomputation of propensities more efficient, a <b>dependency</b> <b>graph</b> is used. This <b>dependency</b> <b>graph</b> tells which reaction propensities to update after a particular reaction has fired.|$|R
5000|$|Lemma (asymmetric version). Let [...] be {{a finite}} set {{of events in}} the {{probability}} space Ω. For [...] let [...] denote the neighbours of [...] in the <b>dependency</b> <b>graph</b> (In the <b>dependency</b> <b>graph,</b> event A is not adjacent to events which are mutually independent). If there exists an assignment of reals [...] to the events such that:then the probability of avoiding all events in [...] is positive, in particular: ...|$|R
40|$|AbstractWeakening the {{functional}} dependencies introduced by Amstrong {{we get the}} notion of the <b>partial</b> <b>dependencies</b> defined on the relational databases. We show that the <b>partial</b> <b>dependencies</b> can be characterized by the closure operations of the poset formed by the partial functions on the attributes of the databases. On the other hand, we give necessary and sufficient conditions so that for such a closure operation one can find on the given set of attributes a database whose <b>partial</b> <b>dependencies</b> generate the given closure operation. We also investigate some questions about how to realize certain structures related to databases by a database of minimal number of rows, columns or elements...|$|R
