138|420|Public
5000|$|In query languages, path {{expressions}} identify {{an object}} by describing {{how to navigate}} to itin some graph (possibly implicit) of objects. For example, the <b>path</b> <b>expression</b> [...] might refer the city of residence of someone's manager.Path expressions have been extended to support regular expression-like flexibility.XPath {{is an example of}} a <b>path</b> <b>expression</b> language.|$|E
50|$|No axis step allowed at the {{beginning}} of a relative <b>path</b> <b>expression.</b>|$|E
5000|$|In {{concurrency}} control, path expressions are {{a mechanism}} for expressing permitted sequences of execution. For example, a <b>path</b> <b>expression</b> like [...] "" [...] might specify that either multiple simultaneous executions of [...] or a single execution of [...] but not both are allowed {{at any point in}} time.|$|E
40|$|<b>Path</b> <b>expressions</b> are {{ubiquitous}} in XML processing languages such as XPath, XQuery, and XSLT. Expressions in these languages typically include multiple <b>path</b> <b>expressions,</b> {{some of them}} correlated. Existing approaches evaluate these <b>path</b> <b>expressions</b> one-at-a-time and miss the optimization opportunities that may be gained by exploiting the correlations among them. In this paper, we address the evaluation and optimization of correlated <b>path</b> <b>expressions.</b> In particular, we propose two types of optimization techniques: integrating correlated <b>path</b> <b>expressions</b> into a single pattern graph, and rewriting the pattern graph according {{to a set of}} rewriting rules. The first optimization technique allows the query optimizer to choose an execution plan that is impossible by using the existing approaches. The second optimization technique rewrites pattern graphs at a logical level and produce a set of equivalent pattern graphs from which a physical optimizer can choose given an appropriate cost function. Under certain conditions that we identify, the graph pattern matching-based execution approach that we propose may be more efficient than the join-based approaches. ...|$|R
40|$|Query {{processing}} {{remains one}} of the important challenges of Object-Oriented Database Management Systems. Cost based query optimization involves creating alternative executing plans for a given query and executing the least costly one within a cost model framework. In Object-Oriented Database Management Systems (OODBMSs) objects may store references to other objects (precomputed joins), and <b>path</b> <b>expressions</b> are used in query languages. Although the cost fomulas for explicit joins and the selectivities of attributes and joins are well-known in the relational model, there is no similar work involving <b>path</b> <b>expressions</b> for OODBMSs. However in order to optimize object-oriented queries involving <b>path</b> <b>expressions,</b> a cost model is essential. This information is necessary for deciding whether to use pointer chasing or to convert the <b>path</b> <b>expressions</b> into explicit joins and also for deciding the execution order of <b>path</b> <b>expressions.</b> In this paper, we provide a cost model that includes the formulas for the costs and selectivities of forward and backward path traversals. 1...|$|R
40|$|Although <b>path</b> <b>expressions</b> in {{object-oriented}} query languages have materialized {{the capability}} of concisely manipulating the nested structures, their presence in query expressions require complex semantic considerations. However, none of currently existing visual query languages models such complex query expressions in a concise and intuitive way partly due to either the lackofwell-defined syntax and semantics of languages or improper representation of visual constructs for <b>path</b> <b>expressions.</b> In this paper, we present visual modeling of <b>path</b> <b>expressions</b> in a visual object-oriented database query language called Visual Object Query Language (VOQL) and proper modeling of the key features related to multi-valued <b>path</b> <b>expressions.</b> VOQL directly specifies the semantics of multi-valued <b>path</b> <b>expressions</b> by employing the visual notation capable of representing a set inclusion in addition to functional relationships. Specifically, the basic visual constructs called blobs, nested blobs, binding edges, and flattening edges are introduced. Blobs and nestedblobsare used to denote sets of objects that <b>path</b> <b>expressions</b> represent. Binding edges and flattening edges are designed to visually simulate the notion of variable binding {{and the notion of}} dot functions in <b>path</b> <b>expressions.</b> The grammar of these constructs defines the syntactic components suchasVOQL terms, VOQL formulas, and VOQL query expressions in a way as in tuple relational calculus. Their semantics are provided bysyntax directed translation to corresponding counterparts in Object-Oriented Predicate Calculus (OOPC). Also, in combination with a visual scoping box for universal quantification, the constructs allow explicit visual scoping and expressing the queries with nested quantification and recursion with [...] ...|$|R
40|$|Abstract: <b>Path</b> <b>expression</b> {{is one of}} {{the core}} {{components}} of most XML query languages, and many evaluation methods for <b>path</b> <b>expression</b> queries are proposed recently. However, there are few researches on the issue of <b>path</b> <b>expression</b> optimization. In this paper, two kinds of <b>path</b> <b>expression</b> optimizing principles are proposed, named path shorten and path complementing, respectively. The path shorten principle reduces the querying cost by shortening the path expressions with the knowledge of XML schema. While the path complementing principle tends to substitute the user queries with the equivalent lower-cost path expressions. The experimental results show that these two techniques can work on most <b>path</b> <b>expression</b> queries and largely improve the efficiency of <b>path</b> <b>expression</b> query processing...|$|E
40|$|Abstract. Regular <b>path</b> <b>expression</b> {{is one of}} {{the core}} {{components}} of XML query languages, and several approaches to evaluating regular path expressions have been proposed. In this paper, a new <b>path</b> <b>expression</b> evaluation approach, extent join, is proposed to compute both parent-children (‘/’) and ancestor-descendent (‘//’) connectors between path steps. Furthermore, two <b>path</b> <b>expression</b> optimization rules, pathshortening and path-complementing, are proposed. The former reduces the number of joins by shortening the path while the latter optimizes the execution of a path by using an equivalent complementary <b>path</b> <b>expression</b> to compute the original path. Experimental results show that the algorithms proposed in this paper are much more efficient than conventional ones. ...|$|E
40|$|Use of path {{expressions}} is {{a common}} feature in most XML query languages, and many evaluation methods for <b>path</b> <b>expression</b> queries have been proposed recently. However, there are few researches {{on the issue of}} optimizing regular <b>path</b> <b>expression</b> queries. In this paper, two kinds of <b>path</b> <b>expression</b> optimization principles are proposed, named path shortening and path complementing, respectively. The path shortening principle reduces the querying cost by shortening the path expressions with the knowledge of XML schema. While the path complementing principle substitutes the user queries with the equivalent lower-cost path expressions. The experimental results show that these two techniques can largely improve the performance of <b>path</b> <b>expression</b> query processing. ...|$|E
40|$|Managing and {{relating}} temporal {{information at}} different time units {{is an important}} issue in many applications and research areas, among them temporal object-oriented databases. Due to the semantic richness of the objectoriented data model, the introduction of multiple temporal granularities in such a model poses several interesting issues. In particular, object-oriented query languages provide a navigational approach to data access, performed via <b>path</b> <b>expressions.</b> In this paper we present an extension to <b>path</b> <b>expressions</b> to a multi-granularity context. The syntax and semantics of the proposed <b>path</b> <b>expressions</b> are formally defined...|$|R
40|$|Abstract. This paper {{discusses}} several {{mechanisms for}} creating relations out of XML documents. A relation generator {{consists of two}} parts: (1) a tuple of <b>path</b> <b>expressions</b> and (2) an index indicating which <b>path</b> <b>expressions</b> may not be assigned the null value. Evaluating a relation generator involves finding tuples of nodes that satisfy the <b>path</b> <b>expressions</b> and are related {{to one another in}} a meaningful fashion. Different semantics for evaluation are given that take into account the possible presence of incomplete information. The complexity of generating relations from documents is analyzed and evaluation algorithms are described. ...|$|R
40|$|Abstract. XQuery {{expressions}} {{can manipulate}} {{two kinds of}} order: document order and sequence order. While the user can impose or observe the order of items within a sequence, the results of <b>path</b> <b>expressions</b> must always be returned in document order. Correctness {{can be obtained by}} inserting explicit (and expensive) operations to sort and remove duplicates after each XPath step. However, many such operations are redundant. In this paper, we present a systematic approach to remove unnecessary sorting and duplicate elimination operations in <b>path</b> <b>expressions</b> in XQuery 1. 0. The technique uses an automaton-based algorithm which we have applied successfully to <b>path</b> <b>expressions</b> within a complete XQuery implementation. Experimental results show that the algorithm detects and eliminates most redundant sorting and duplicate elimination operators and is very effective on common XQuery <b>path</b> <b>expressions.</b> ...|$|R
40|$|Regular <b>path</b> <b>expression</b> {{is one of}} {{the core}} {{components}} of XML query languages, and several approaches to evaluating regular path expressions have been proposed. In this paper, a new <b>path</b> <b>expression</b> evaluation approach, extent join, is proposed to compute both parent-children (`/') and ancestor-descendent (`//') connectors between path steps. Furthermore, two <b>path</b> <b>expression</b> optimization rules, pathshortening and path-complementing, are proposed. The former reduces the number of joins by shortening the path while the latter optimizes the execution of a path by using an equivalent complementary <b>path</b> <b>expression</b> to compute the original path. Experimental results show that the algorithms proposed in this paper are much more e#cient than conventional ones...|$|E
40|$|AbstractThe {{evaluation}} of <b>path</b> <b>expression</b> queries on semistructured {{data in a}} distributed asynchronous environment is considered. The {{focus is on the}} use of local information expressed in the form of path constraints in the optimization of <b>path</b> <b>expression</b> queries. In particular, decidability and complexity results on the implication problem for path constraints are established...|$|E
40|$|Query {{language}} and querying facilities are critical factors for wide acceptance of Object-Oriented Database Management Systems (OODBMS) in the market. In this paper, {{we focus on}} query model on an aggregation hierarchy. We call this query "Aggregation Query". Query on an aggregation hierarchy is unique and differs from general query on association relationships. The latter is often known as <b>path</b> <b>expression</b> query. The difference {{is analogous to the}} distinction between association and aggregation in object modelling. In our proposal, we present three important elements of aggregation query, particularly (i) aggregation query hierarchy, (ii) shorthand <b>path</b> <b>expression</b> for aggregation query utility, and (iii) retrieving aggregation tree. Whilst the first element above is adopted from <b>path</b> <b>expression</b> queries, the second element is an extension to general <b>path</b> <b>expression</b> query, and the third element is unique to aggregation, as aggregation resembles a Part-Of relationship, which is more specialized than association relationships...|$|E
40|$|Efficient {{evaluation}} of <b>path</b> <b>expressions</b> {{has been studied}} extensively. However, evaluating more complex FLWOR expressions that contain multiple <b>path</b> <b>expressions</b> has not been well studied. In this paper, we propose a novel pattern matching approach, called BlossomTree, to evaluate a FLWOR expression that contains correlated <b>path</b> <b>expressions.</b> BlossomTree is a formalism to capture the semantics of the <b>path</b> <b>expressions</b> and their correlations. These correlations include variable referencing, structural relationship, value-based relationship, or a mixture of structural and value-based relationship. We propose a general algebraic framework (abstract data types and logical operators) to evaluate BlossomTree pattern matching that facilitates efficient evaluation and experimentation. We design efficient data structures and algorithms to implement the abstract data types and logical operators. Our experimental studies demonstrate that the BlossomTree pattern matching approach can generate highly efficient query plans. ...|$|R
40|$|Abstract. Various {{techniques}} for the navigation and matching of data structures using <b>path</b> <b>expressions</b> {{have been the}} subject of extensive investigations. No mat-ter whether such techniques are based on type information, indexing, automata, it is desirable to synthesize implementations automatically, starting from a high-level description of the <b>path</b> <b>expressions</b> to be traversed. In this paper we present a library of C++ templates for the representation of regu-lar <b>path</b> <b>expressions</b> and their compilation into efficient backtracking algorithms. The resulting code can be used to implement visitors, pattern matchers, node col-lectors on regular paths over possibly heterogeneous, linked data structures. The point of the paper is on the path compilation technique, which was inspired by a continuation-passing, functional semantics of the <b>path</b> <b>expressions.</b> We rely on some peculiar aspects of C++ templates to create a compilation framework that closely follows the given semantics. ...|$|R
40|$|<b>Path</b> <b>expressions</b> {{form the}} basis of most query {{languages}} for semistructured data and XML, specifying traversals through graph-based data. We consider the query optimization problem for <b>path</b> <b>expressions</b> that "branch," or specify traversals through two or more related subgraphs; such expressions are common in nontrivial queries over XML data. Searching the entire space of query plans for branching <b>path</b> <b>expressions</b> is generally infeasible, so we introduce several heuristic algorithms and postoptimizations that generate query plans for branching <b>path</b> <b>expressions.</b> All of our algorithms have been implemented in the Lore database system for XML, and we report experimental results over a variety of database and query shapes. We compare optimization and execution times across our suite of algorithms and post-optimizations, and for small queries we compare against the optimal plan produced by an exhaustive search of the plan space. 1 Introduction Wo r k i n semistructured data [Abi 97, [...] ...|$|R
40|$|An extent join {{to compute}} path {{expressions}} containing parent-children and ancestordescendent operations and two <b>path</b> <b>expression</b> optimization rules, path-shortening and path-complementing, {{are presented in}} this paper. Path-shortening reduces the number of joins by shortening the path while path-complementing optimizes the path execution by using an equivalent complementary <b>path</b> <b>expression</b> to compute the original one. Experimental {{results show that the}} algorithms proposed are more efficient than traditional algorithms...|$|E
40|$|An object query {{can include}} a <b>path</b> <b>expression</b> to {{traverse}} {{a number of}} related collections. The order of collection traversals given by the <b>path</b> <b>expression</b> {{may not be the}} most efficient to process the query. This generates a critical problem for an object query optimizer to select the best execution plan. This paper studies the different algorithms to process path expressions with predicates, including depth first navigation, forward and reverse joins. Using a cost model, it then compares their performances in different cases, according to memory size, selectivity of predicates, fan out between collections, etc [...] It also presents a heuristic-based algorithm to find profitable n-ary operators for traversing collections, thus reducing the search space of query plans to process a query with a qualified <b>path</b> <b>expression.</b> An implementation based on the 02 system demonstrates the validity of the results. 1...|$|E
40|$|We {{consider}} {{the problem of}} translating XML queries into SQL when XML documents have been stored in an RDBMS using a schema-based relational decomposition. Surprisingly, there is no published XML-to-SQL query translation algorithm for this scenario that handles recursive XML schemas. We present a generic algorithm to translate <b>path</b> <b>expression</b> queries into SQL {{in the presence of}} recursion in the schema and queries. This algorithm handles a general class of XML-to-Relational mappings, which includes all techniques proposed in literature. Some of the salient features of this algorithm are: (i) It translates a <b>path</b> <b>expression</b> query into a single SQL query, irrespective of how complex the XML schema is, (ii) It uses the "with" clause in SQL 99 to handle recursive queries even over non-recursive schemas, (iii) It reconstructs recursive XML subtrees with a single SQL query and (iv) It shows that the support for linear recursion in SQL 99 is sufficient for handling <b>path</b> <b>expression</b> queries over arbitrarily complex recursive XML schema...|$|E
5000|$|The [...] "/", [...] "//" [...] and [...] "..." [...] operators, used in <b>path</b> <b>expressions,</b> as {{described}} above.|$|R
40|$|AbstractThe Object Constraint Language OCL is an {{integral}} part of UML, the Unified Modeling Language standard. It has been added to UML as a logic-based sublanguage for the definition of class invariants and pre-/postconditions of operations. OCL is rather similar to a subset of the graph transformation language PROGRES, the so-called <b>path</b> <b>expressions.</b> These <b>path</b> <b>expressions</b> are used for similar purposes as OCL. In contrast to OCL, <b>path</b> <b>expressions</b> support functional abstraction and offer additional operators for conditional iteration and transitive closure. Furthermore, PROGRES possesses a visual query sublanguage and is equipped with a precise semantics definition. Based on our experiences with the development of PROGRES a number of modifications and extensions of OCL are suggested as recommendations for its forthcoming version 2. 0...|$|R
40|$|Recently, {{there has}} {{been a great deal of}} {{interest}} in the development of techniques to evaluate <b>path</b> <b>expressions</b> over collections of XML documents. In general, these <b>path</b> <b>expressions</b> contain both structural and keyword components. Several methods have been proposed for processing <b>path</b> <b>expressions</b> over graph/tree-structured XML data. These methods can be classified into two broad classes. The first involves graph traversal where the input query is evaluated by traversing the data graph or some compressed representation. The other class involves information-retrieval style processing using inverted lists. In this framework, structure indexes have been proposed to be used as a substitute for graph traversal. These structure indexes are proven to be very effective when applied to queries that examine the “coarse ” structure of documents. For example, for man...|$|R
40|$|Extensible Markup Language (XML) {{has become}} the de facto {{standard}} for data representation, exchange and publishing over the Internet. As more and more XML data is gathered and processed by database management systems, we need innovative approaches to efficiently manage and query it. However, XML queries possess some unique features, which distinguish them from the traditional RDBMS queries and pose {{a challenge to the}} XML research community. This dissertation investigates {{the problem of how to}} improve the XML <b>path</b> <b>expression</b> performance by considering the unique features of <b>path</b> <b>expression,</b> since <b>path</b> <b>expression</b> is the core part of XML queries. By fully exploiting these features, we are able to propose some novel algorithms to significantly improve XML <b>path</b> <b>expression</b> performance. We first investigate the issue of optimizing XML path expressions without considering the workload. A basic kind of XML <b>path</b> <b>expression</b> is the structural query, which retrieves all descendants of a specific XML element. Structural queries are important because they constitute the building block of various complex XML path expressions. Among proposed XML query processing techniques for structural queries, structural join outperforms most other graph-traversal based approaches as it minimizes the number of nodes accessed to evaluate a structural query. In the first part of this dissertation we show that general path expressions, involving conditions on attributes, possess inherent multi-dimensional characteristics that are not captured by existing XML query processing methods based on 1 D ordering. Motivated by this, we index XML data with multi-dimensional access methods and develop efficient algorithms to minimize the query cost. Extensive experimental evaluations confirm that our algorithms provide significant performance gains for numerous query types. Our next goal is to further improve the <b>path</b> <b>expression</b> performance by considering the query workload. All existing indices for structural join focus on indexing the encoding information of XML elements so as to improve the XML <b>path</b> <b>expression</b> performance. Consequently, such indices utilize only data characteristics, but ignore query characteristics that are important for the further improvement of the query performance. In this thesis, we propose AC-tree (Adaptive Cluster B+-tree), which is a fully workload-aware structural join index, to provide a simple, but efficient way to exploit the XML query characteristics for performance improvement. To the best of our knowledge, AC-tree is the first structural join index to take the workload into consideration. An extensive set of experiments confirm that AC-tree outperforms competitors significantly for both simple (i. e., non-branching) XML path expressions and branching path expressions...|$|E
40|$|The goal of {{this work}} is to extend the use of {{existing}} <b>path</b> <b>expression</b> theory and methodologies to ensure that critical software event sequences are maintained {{even in the face}} of malevolent attacks and harsh or unstable operating environments. This will be accomplished by providing dynamic fault management measures directly to the software developer and to their varied development environments. This paper discusses the perceived problems, a brief overview of path expressions, and the author`s proposed extension areas. The authors discuss how the traditional <b>path</b> <b>expression</b> usage and implementation differs from the intended usage and implementation...|$|E
40|$|Aspects require {{access to}} the join point context in order to select and adapt join points. For this purpose, current aspect-oriented systems offer {{a large number of}} pointcut {{constructs}} that provide access to join point information that is local to the join point context, like parameters in method call join points. However, these systems are quite miserly with non-local information that cannot directly be derived from the local execution context. Recently, there have been some proposals that offer access to some kind of non-local information. One such proposal is the <b>path</b> <b>expression</b> pointcut that permits to abstract over non-local object information. Path pointcuts expose non-local objects that are specified in corresponding <b>path</b> <b>expression</b> patterns. In this paper, we show recurrent situations where developers need to access the whole object paths, and consequently, they add workarounds other than pointcut constructs to get the required accesses. Then, we present and study an extension to the <b>path</b> <b>expression</b> pointcuts to permit exposing the object paths and show how this extension overcomes the problem...|$|E
40|$|CONTENTS i Contents 1 Introduction 1 2 Flora Shell Commands 2 3 F-logic and Flora by Example 3 4 Inside Flora 3 4. 1 How Flora Works..................................... 4 4. 2 Flora vs. Florid..................................... 5 5 Syntax of Flora 5 5. 1 Basic F-logic Syntax.................................... 6 5. 2 <b>Path</b> <b>Expressions</b> in the Rule Body............................ 7 5. 3 <b>Path</b> <b>Expressions</b> in the Rule Head............................ 9 5. 4 References: Truth Value vs. Object Value........................ 9 5. 5 Symbols, Strings, Comments........................... ...|$|R
40|$|The {{authors have}} {{previously}} described {{the use of}} data <b>path</b> <b>expressions</b> and predecessor automata in debugging concurrent systems. In this paper we examine the relationship of these models to two traditional models of concurrent processes: pomset languages and k-safe Petri net systems. We explore the regularity and safety of the concurrent languages described by {{each of the four}} models. Our main result is the equivalence of regular safe pomset languages and the languages described by safe data <b>path</b> <b>expressions,</b> safe predecessor automata and k-safe Petri net systems...|$|R
40|$|We {{consider}} {{the problem of}} storing and accessing documents (SGML and HTML, in particular) using database technology. To specify the database image of documents, we use structuring schemas that consist in grammars annotated with database programs. To query documents, we introduce an extension of OQL, the ODMG standard query language for object databases. Our extension (named OQL-doc) allows to query documents without a precise knowledge of their structure using in particular generalized <b>path</b> <b>expressions</b> and pattern matching. This allows us to introduce in a declarative language (in the style of SQL or OQL), navigational and information retrieval styles of accessing data. Query processing {{in the context of}} documents and <b>path</b> <b>expressions</b> leads to challenging implementation issues. We extend an object algebra with new operators to deal with generalized <b>path</b> <b>expressions.</b> We then consider two essential complementary optimization techniques: 1. we show that almost standard database optim [...] ...|$|R
40|$|We {{consider}} the scenario where existing relational data is exported as XML. In this context, {{we look at}} the problem of translating XML queries into SQL. XML query languages have two di#erent notions of duplicates: node-identity based and value-based. <b>Path</b> <b>expression</b> queries have an implicit node-identity based duplicate elimination built into them. On the other hand, SQL only supports value-based duplicate elimination. In this paper, using a simple <b>path</b> <b>expression</b> query we illustrate the problems that arise when we attempt to simulate the node-identity based duplicate elimination using value-based duplicate elimination in the SQL queries. We show how a general solution for this problem covering the class of views considered in published literature requires a fairly complex mechanism...|$|E
40|$|We have {{developed}} a transaction-based approach to distributed shared memory(DSM) that supports object caching and gener-ates <b>path</b> <b>expression</b> prefetches. A <b>path</b> <b>expression</b> specifies {{a path through the}} heap that traverses the objects to be prefetched. To our knowledge, this is the first prefetching approach that can prefetch objects whose addresses have not been computed or predicted. Our DSM uses both prefetching and caching of remote objects to hide network latency while relying on the two-phase transaction commit mechanism to preserve the simple transactional consistency model that we present to the developer. We have evaluated this approach on a matrix multiply benchmark. We have found that our approach enables to effectively utilize multiple machines in a cluster and also benefit from prefetching and caching of objects...|$|E
40|$|We propose an {{augmented}} Web {{space and}} its query language to support geographical querying and sequential plan creation utilizing a digital {{city that is}} a city-based information space on the Internet. The augmented Web space involves {{a new approach to}} integrate the World Wide Web (WWW) and a geographic information system (GIS). The augmented Web space consists of home pages (HP), hyperlinks, and generic links that represent geographical relations between HPs. The generic links are created dynamically using geographical evaluation functions included in a user's search query each time one is issued. A query also includes a <b>path</b> <b>expression</b> showing how to navigate the HPs, hyperlinks, and generic links. Since the <b>path</b> <b>expression</b> is an extended regular expression, we can describe an arbitrary sequence of users' search actions for navigating the augmented Web space. We have applied the proposed augmented Web space to Digital City Kyoto, a city information service system that is accessed through a 3 D walk-through implementation and a map-based interface. Each time a user's query is issued through the 3 D and 2 D interfaces, Digital City Kyoto creates an augmented Web space, and navigates the Web information space based on the <b>path</b> <b>expression</b> in the query. 1...|$|E
40|$|In {{the past}} few years, query {{languages}} featuring generalized <b>path</b> <b>expressions</b> have been proposed. These languages allow the interrogation of both data and structure. They are powerful and essential {{for a number of}} applications. However, until now, their evaluation has relied on a rather naive and inefficient algorithm. In this paper, we extend an object algebra with two new operators and present some interesting rewriting techniques for queries featuring generalized <b>path</b> <b>expressions.</b> We also show how a query optimizer can integrate the new techniques. 1 Introduction In {{the past few}} years there has been a growing interest in query languages featuring generalized <b>path</b> <b>expressions</b> (GPE) [BRG 88, KKS 92, CACS 94, QRS + 95]. With these languages, one may issue queries on data without exact knowledge of its structure. A GPE queries data and structure at the same time. Although very useful for standard database applications, these languages are vital for new applications dedicated, for insta [...] ...|$|R
40|$|<b>Path</b> <b>expressions</b> are the {{principal}} means of locating data in a hierarchical model. But <b>path</b> <b>expressions</b> are brittle because they often depend {{on the structure of}} data and break if the data is structured differently. The structure of data could be unfamiliar to a user, may differ within a data collection, or may change over time as the schema evolves. This paper proposes a novel construct that locates related nodes in an instance of an XML data model, independent of a specific structure. It can augment many XPath expressions and can be seamlessly incorporated in XQuery or XSLT...|$|R
40|$|Several {{database}} query languages {{have recently}} been developed to locate and retrieve documents in the vast network of World-Wide Web pages. These languages combine <b>path</b> <b>expressions,</b> which specify {{the structure of a}} path through the network to the desired information, with content predicates, which force the path to pass through pages with particular content. The straightforward implementation of these languages is based on breadth-first search of the network, with heavy reliance placed on the user's understanding of network topology to both direct and constrain the search via the appropriate use of the <b>path</b> <b>expressions.</b> In this paper w...|$|R
