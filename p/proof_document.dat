18|156|Public
50|$|Article 17 The uniform forms made by Chinese {{copyright}} protection center are used when applying for registration, and seal (signature) of the Applicant is needed.The application forms should be filled in Chinese. The Chinese version of all certificates and <b>proof</b> <b>document</b> {{must be provided}} if they are foreign language.The documents used to apply for registration must be printed on A4 papers with 297 mm x 210 mm (length x wide).|$|E
50|$|Article 21 No {{registration}} will be {{made and}} will notice the Applicant {{if one of the}} following exists:1. Forms submitted are uncompleted and nonstandard, and no revise is made within the specified time limited;2. Materials submitted are not software program and document stipulated in the <<Regulation>>;3. The title of program are not square with obligee’s signature, and no <b>proof</b> <b>document</b> is provided;4. There is ownership dispute on the software be applied for registration.|$|E
5000|$|Vyāsa {{describes}} the following kinds of decisions: by valid means of <b>proof</b> (<b>document,</b> witnesses, possession), by motives (inferences and logical speculation), by customs (local rules established {{for a long}} time), by an oath, by a royal decree, or by reconciliation of the parties. Nārada classifies the decisions in a different way, differentiating between sacred law, positive law, custom, and royal decrees. Sacred law refers to a decision in which “a case has been duly investigated, decided in accordance with circumstance, and examined by means of oaths, it should {{be known as a}} decision by the sacred law.” Positive law, on the other hand, is a decision made based upon the prescriptions. A decision is determined by custom if it is made according to local rules and the customs of the people. A royal decree is “when kings consider a particular custom to be contrary to equity, in the same way this custom should be annulled by a royal decree.” The punishment of the defeated party is related to the reply of the accused. A defendant who lost the case after delivering a reply by way of denial, exception, or former judgment should pay the disputed amount to the plaintiff and an equal amount to the king. If the defendant wins, the plaintiff should pay a fine twice as high as the amount mentioned in the plaint. In the case of a confession, the defendant pays half the fine he would pay if he had denied the plaint and was defeated. Certain guidelines must be followed in determining the fine for the defeated party. For example, Kātyāyana explains the fines to be given in trials of ordeals: “In case of poison, water, fire, the balance, holy water, rice, and the ordeal by the hot piece of gold, he should inflict fine on the defeated according to the following gradation: a thousand, six hundred, five hundred, four, three, two, and one hundred, and less.” ...|$|E
5000|$|... #Subtitle level 2: Exemptions from <b>proof</b> <b>documents</b> and GDGS Immigration {{pre-approval}} ...|$|R
50|$|Proofs {{would be}} stored by saving scans or photos of <b>proof</b> <b>documents.</b> However {{this would be}} for {{backward}} compatibility, because digitally signed attestations remove the need for proofs {{as we know them}} today.|$|R
50|$|Clay {{claims to}} have <b>proof,</b> <b>documented</b> in a book, that Roy Stuart is {{responsible}} for the rustling. Clay arrives in town by stagecoach, as does Jeanne Starr, who is taking a job as a singer in Stuart's saloon.|$|R
40|$|UI keeps proof {{script for}} batch replay • Linear processing, {{commands}} become “locked” • Focus on mechanics of proving – user-friendly? H. Gast Asynchronous <b>Proof</b> <b>Document</b> Management (UITP ’ 08, 22. 8. 2008) 2 Document-Centered View • Metaphor “proof document” • User edits human-readble a <b>proof</b> <b>document</b> • Prover checks the consistency • Assisted authoring [2] • Isar as human-readable proof language [8] • Backflow: Assistance by prover for editing • Processing linear • PlatΩ approach [6] • Near-natural, text-book style input language • Front-end parses structure & computes structural diff • Triggers necessary (re-) checking by Ωmega prover H. Gast Asynchronous <b>Proof</b> <b>Document</b> Management (UITP ’ 08, 22. 8. 2008) 3 Asynchronous Proof Processing [7...|$|E
40|$|Abstract. A <b>proof</b> <b>document</b> for origami {{theorem proving}} {{is a record}} of entire process of {{reasoning}} about origami construction and theorem proving. It is produced {{at the completion of}} origami theorem proving as a kind of proof certificate. It describes in detail how the whole process of an origami construction and the subsequent theorem proving are carried out in our computational origami system. In particular, it describes logical and algebraic transformations of the prescription of origami construction into mathematical models that in turn become amenable to computation and verification. The structure of the <b>proof</b> <b>document</b> is detailed using an illustrative example that reveals the importance of such a document in the analysis of origami construction and theorem proving. ...|$|E
40|$|Binary multirelations {{associate}} {{elements of}} a set with its subsets; hence they are binary relations of type A × 2 A. Applications include alternating automata, models and logics for games, program semantics with dual demonic and angelic nondeterministic choices and concur-rent dynamic logics. This <b>proof</b> <b>document</b> supports an arXiv article that formalises the basic algebra of multirelations and proposes axiom systems for them, ranging from weak bi-monoids to weak bi-quantales...|$|E
50|$|The main use of {{bromides}} is for <b>proofing</b> <b>documents</b> before expensive lithography {{plates are}} made. Proofing on bromide paper {{is much easier}} than film, since it doesn't require a light table or other backlighting in order to read. Because of the uptake of platesetters, this function of imagesetters in modern printing houses has been reduced, although not completely eliminated, with proofs made on special proofing printers instead.|$|R
40|$|Mortgage {{practice}} in Indonesian society is universal sociological phenomenon and occurs in every place. It is conventional and carries out {{from generation to}} generation. For citizen of Bogor, the mortgage land has been done since long time ago. This goes without <b>proof</b> <b>documents</b> as legal certainty. Meanwhile, academically, legal certainty is a theory {{that has not been}} developed by Islamic jurists. DOI: 10. 15408 /ajis. v 15 i 2. 286...|$|R
40|$|Refactoring is an {{important}} Software Engineering technique for improving {{the structure of a}} program after it has been written. Refactorings improve the maintainability, readability, and design of a program without affecting its external behaviour. In analogy, this thesis introduces proof refactoring to make structured, semantics preserving changes to the <b>proof</b> <b>documents</b> constructed by interactive theorem provers as part of a formal proof development. In order to formally study proof refactoring, {{the first part of this}} thesis constructs a proof language framework, Hiscript. The Hiscript framework consists of a procedural tactic language, a declarative proof language, and a modular theory language. Each level of this framework is equipped with a formal semantics based on a hierarchical notion of proof trees. Furthermore, this framework is generic as it does not prescribe an underlying logical kernel. This part contributes an investigation of semantics for formal <b>proof</b> <b>documents,</b> which is proved to construct valid proofs. Moreover, in analogy with type-checking, static well-formedness checks of <b>proof</b> <b>documents</b> are separated from evaluation of the proof. Furthermore, a subset of the SSReflect language for Coq, called eSSence, is also encoded using hierarchical proofs. Both Hiscript and eSSence are shown to have language elements with a natural hierarchical representation. In the second part, proof refactoring is put on a formal footing with a definition using the Hiscript framework. Over thirty refactorings are formally specified and proved to preserve the semantics in a precise way for the Hiscript language, including traditional structural refactorings, such as rename item, and proof specific refactorings such as backwards proof to forwards proof and declarative to procedural. Finally, a concrete, generic refactoring framework, called Polar, is introduced. Polar is based on graph rewriting and has been implemented with over ten refactorings and for two proof languages, including Hiscript. Finally, the third part concludes with some wishes for the future...|$|R
40|$|Isabelle. It {{has been}} {{developed}} in ML and Scala in the past 4 – 5 years for this particular proof assistant, but {{with an open mind}} towards other systems. PIDE is based on an asynchronous document model, where the prover receives edits continuously and updates its internal state accordingly. The interpretation of edits and the policies for <b>proof</b> <b>document</b> processing are determined by the prover. The editor front-end merely takes care of visual rendering of formal document content. Here we report on an experiment to connect Coq to the PIDE infrastructure of Isabelle. This requires to re-implement the core PIDE protocol layer of Isabelle/ML in OCaml. The payload for semantic processing of <b>proof</b> <b>document</b> content is restricted to lexical analysis in the sense of existing CoqIde functionality. This is sufficient as proof-of-concept for PIDE connectivity. Actual proof processing is then a matter of improving Coq towards timeless and stateless proof processing, independently of PIDE technicalities. The implementation worked out smoothly and required minimal changes to the refined PIDE architecture of Isabelle 2013. This experiment substantiates PIDE as general approach to prover interaction. It illustrates how other provers of the greater ITP family can participate by following similar reforms of the classic TTY loop as was done for Isabelle in the past few years. ...|$|E
40|$|Isabelle/PIDE is {{the current}} Prover IDE {{technology}} for Isabelle. It has been developed in ML and Scala in the past 4 – 5 years for this par-ticular proof assistant, but {{with an open mind}} towards other systems. PIDE is based on an asynchronous document model, where the prover re-ceives edits continuously and updates its internal state accordingly. The interpretation of edits and the policies for <b>proof</b> <b>document</b> processing are determined by the prover. The editor front-end merely takes care of visual rendering of formal document content. Here we report on an experiment to connect Coq to the PIDE infras-tructure of Isabelle. This requires to re-implement the core PIDE protocol layer of Isabelle/ML in OCaml. The payload for semantic processing of <b>proof</b> <b>document</b> content is restricted to lexical analysis in the sense of ex-isting CoqIde functionality. This is sufficient as proof-of-concept for PIDE connectivity. Actual proof processing is then a matter of improving Coq towards timeless and stateless proof processing, independently of PIDE technicalities. The implementation worked out smoothly and required minimal changes to the refined PIDE architecture of Isabelle 2013. This experiment substantiates PIDE as general approach to prover interaction. It illustrates how other provers of the greater ITP family can participate by following similar reforms of the classic TTY loop as was done for Isabelle in the past few years. ...|$|E
40|$|We {{present a}} {{complete}} formalization of the Hahn-Banach theorem in the simply-typed set-theory of Isabelle/HOL, such {{that both the}} modeling of the underlying mathematical notions and the full proofs are intelligible to human readers. This is achieved {{by means of the}} Isar environment, which provides a framework for high-level reasoning based on natural deduction. The final result is presented as a readable formal <b>proof</b> <b>document,</b> following usual presentations in mathematical textbooks quite closely. Our case study demonstrates that Isabelle/Isar is capable to support this kind of application of formal logic very well, while being open for an even larger scope...|$|E
500|$|All {{visitors}} {{must apply}} in person at an Embassy or a General Consulate of the Republic of Lebanon, {{fill in the}} application form and pay the application processing fee at a visa application center. Citizens of the 7 visa-exempt countries and territories or the 79 countries and territories whose citizens are eligible for a visa on arrival can obtain the visa before travel but are exempted from submitting <b>proof</b> <b>documents</b> but {{will be required to}} pay a processing free ...|$|R
50|$|Groden {{has stated}} that his next book, JFK: Absolute <b>Proof,</b> <b>documents</b> his {{interview}} with a Dealey Plaza witness who was standing with Lee Harvey Oswald {{on the second floor}} of the Texas School Book Depository when they both heard shots being fired outside. Video documentaries he has released are JFK: The Case for Conspiracy: Assassination and Medical Evidence, The Assassination Films: The Case for Conspiracy, Volume II, and The Killing of a President: A Video Magazine.|$|R
50|$|Ortwin {{was born}} in Holtwick (now in the District of Coesfeld, Westphalia) and died in Cologne, Germany. He was raised by his uncle, Johannes von Grätz, in Deventer. In 1501 he left to pursue {{philosophical}} studies at the University of Cologne. After joining Kyuk Burse, Ortwin became licensed in 1505, attained Masters level in 1506, and became an Art Professor in 1507. He supplemented his salary by <b>proofing</b> <b>documents</b> for Quentell printers and wrote introductions and poetic dedications in the volumes of classical authors of the Middle Ages.|$|R
40|$|Abstract. Historically, the LCF {{tradition}} of interactive theorem proving {{was tied to}} the read-eval-print loop, with sequential and synchronous evaluation of prover commands given on the command-line. This userinterface technology was adequate when R. Milner introduced his LCF proof assistant in the 1970 -ies, but it severely limits the potential of current multicore hardware and advanced IDE front-ends. Isabelle/PIDE breaks this loop and retrofits the read-eval-print phases into an asynchronous model of document-oriented proof processing. Instead of feeding a sequence of individual commands into the prover process, the primary interface works via edits over a family of document versions. Execution is implicit and managed by the prover on its own account in a timeless and stateless manner. Various aspects of interactive proof checking are scheduled according to requirements determined by the front-end perspective on the <b>proof</b> <b>document,</b> while making adequate use of the CPU resources on multicore hardware on the back-end. Recent refinements of Isabelle/PIDE provide an explicit concept of asynchronous print functions over existing proof states. This allows to integrate long-running or potentially non-terminating tools into the document-model. Applications range from traditional proof state output (which may consume substantial time in interactive development) to automated provers and dis-provers that report on existing <b>proof</b> <b>document</b> content (e. g. Sledgehammer, Nitpick, Quickcheck in Isabelle/HOL). Moreover, {{it is possible to}} integrate query operations via additional GUI panels with separate input and output (e. g. for Sledgehammer or findtheorems). Thus the Prover IDE provides continuous proof processing, augmented by add-on tools that help the user to continue writing proofs. ...|$|E
40|$|Asynchronous proof {{processing}} is {{a recent}} approach at improving the usability and performance of interactive theorem provers. It builds on a simple metaphor: the user edits a <b>proof</b> <b>document</b> while the prover checks its consistency in the background without explicit requests from the user. This paper presents a software architecture for asynchronous proof processing. Its foundation is a novel state model for commands that synchronizes the possibly parallel accesses of the user interface and prover. The state model is complemented by a communication protocol that places minimal requirements on the prover. The model also allows asynchronous processing to be emulated by existing linear-processing proof engines, such that the migration to the new communication protocol is simplified. A prototype implementation that works with the current development version of Isabelle is presented...|$|E
40|$|This paper {{presents}} the mechanization {{of a process}} algebra for Mobile Ad hoc Networks and Wireless Mesh Networks, {{and the development of}} a compositional framework for proving invariant properties. Mechanizing the core process algebra in Isabelle/HOL is relatively standard, but its layered structure necessitates special treatment. The control states of reactive processes, such as nodes in a network, are modelled by terms of the process algebra. We propose a technique based on these terms to streamline proofs of inductive invariance. This is not sufficient, however, to state and prove invariants that relate states across multiple processes (entire networks). To this end, we propose a novel compositional technique for lifting global invariants stated at the level of individual nodes to networks of nodes. Comment: The Isabelle/HOL source files, and a full <b>proof</b> <b>document,</b> are available in the Archive of Formal Proofs, at [URL]...|$|E
5000|$|<b>Proof</b> of Identity <b>documents</b> {{mentioned}} above bearing {{address of the}} applicant or ...|$|R
40|$|Isabelle/Isar is {{a generic}} {{framework}} for human-readable formal <b>proof</b> <b>documents,</b> based on higher-order natural deduction. The Isar proof language provides general principles {{that may be}} instantiated to particular object-logics and applications. We discuss specific Isar language elements that support complex induction patterns of practical importance. Despite the additional bookkeeping required for induction with local facts and parameters, definitions, simultaneous goals and multiple rules, the resulting Isar proof texts turn out well-structured and readable. Our techniques {{can be applied to}} non-standard variants of induction as well, such as co-induction and nominal induction. This demonstrates that Isar provides a viable platform for building domain-specific tools that support fully-formal mathematical proof composition...|$|R
40|$|The basic {{motivation}} {{of this work}} is to make formal theory developments with machine-checked proofs accessible to a broader audience. Our particular approach is centered around the Isar formal proof language that is intended to support adequate composition of <b>proof</b> <b>documents</b> that are suitable for human consumption. Such primary proofs written in Isar may be both checked by the machine and read by human-beings; final presentation merely involves trivial pretty printing of the sources. Sound logical foundations of Isar are achieved by interpretation within the generic Natural Deduction framework of Isabelle, reducing all high-level reasoning steps to primitive inferences. The resulting Isabelle/Isar system [...] ...|$|R
40|$|Intelligible semi-automated {{reasoning}} (Isar) is {{a generic}} approach to readable formal proof documents. It {{sets out to}} bridge the semantic gap between any internal notions of proof based on primitive inferences and tactics, and an appropriate level of abstraction for user-level work. The Isar formal proof language {{has been designed to}} satisfy quite contradictory requirements, being both "declarative" and immediately "executable", by virtue of the Isar/VM interpreter. The current version of Isabelle o#ers Isar as an alternative proof language interface layer. The Isabelle/Isar system provides an interpreter for the Isar formal <b>proof</b> <b>document</b> language. The input may consist either of proper document constructors, or improper auxiliary commands (for diagnostics, exploration etc.). Proof texts consisting of proper document constructors only, admit a purely static reading, thus being intelligible later without requiring dynamic replay that is so typical for traditional proof scripts. Any of [...] ...|$|E
40|$|A new {{paradigm}} for designing and implementing user-interfaces for theorem proving assistants is presented. In the paradigm, we regard the process of constructing a proof as that of editing a <b>proof</b> <b>document,</b> where proofs are represented by constraints that relate pieces of information on a document with one another. By adding functions for solving such constraints to a text-editor, we can smoothly and naturally unify our thinking ability and computation by a prover. Consequently, the text-editor simultaneously {{plays the role of}} a sheet of paper for brain-storming ideas, that of an ordinary text-editor for making a final document shown to a proof reader, and that of an interface for doing computation by a computer. In the paper, we also describe two user-interfaces which have actually been developed by the authors and from which the paradigm has grown up. One is a proof checker based on typed -calculi, and the other is a user-interface for Mathematica. 1 Introduction When we construct [...] ...|$|E
40|$|After several decades, most proof assistants {{are still}} {{centered}} around TTY-based interaction {{in a tight}} read-eval-print loop. Even well-known Emacs modes for such provers follow this synchronous model based on single commands with immediate response, meaning that the editor waits for the prover after each command. There have been some attempts to re-implement prover interfaces in big IDE frameworks, while keeping the old interaction model. Can we do better than that? Ten years ago, the Isabelle/Isar proof language already emphasized the idea of <b>proof</b> <b>document</b> (structured text) instead of proof script (sequence of commands), although the implementation was still emulating TTY interaction {{in order to be}} able to work with the then emerging Proof General interface. After some recent reworking of Isabelle internals, to support parallel processing of theories and proofs, the original idea of structured document processing has surfaced again. Isabelle versions from 2009 or later already provide some support for interactive proof documents with asynchronous checking, which awaits to be connected to a suitable editor framework or full-scale IDE. The remaining problem is how to do that systematically, without having to specify and implement complex protocols for prover interaction...|$|E
50|$|Patrick Nagatani - Excavations, A {{series of}} {{photographs}} <b>documenting</b> <b>proof</b> of a worldwide ancient automobile culture.|$|R
40|$|The THedu' 11 {{workshop}} received thirteen submissions, {{twelve of}} which were accepted and presented during the workshop. For the post-conference proceedings nine submission where received and accepted. The submissions are {{within the scope of}} the following points, which have been announced in the call of papers: CTP-based software tools for education; CTP technology combined with novel interfaces, drag and drop, etc.; technologies to access ITP knowledge relevant for a certain step of problem solving; usability considerations on representing ITP knowledge; combination of deduction and computation; formal problem specifications; effectiveness of ATP in checking user input; formats for deductive content in <b>proof</b> <b>documents,</b> geometric constructions, etc; formal domain models for e-learning in mathematics and applications...|$|R
40|$|Security in {{information}} systems has increased importance, as end users {{have become more}} responsive of securely sharing or exchanging the vast amount of information. The organizations that do sensitive work such as those with defense contracts, passport issuing agencies, military activities, and health care data at health-insurance, {{are in need of}} protecting their information. Nowadays, financial institutions providing various online services to customers are facing situation with customers who submit fake documents for getting services. To defend from that situation, financial institutions enquire customer information at various government departments against the customer submitted <b>proof</b> <b>documents</b> to rovide service to customer. In this study, secure and trusted information sharing environment is a vital requirement t...|$|R
40|$|Encodings or {{the proof}} of their absence are the main way to compare process calculi. To analyse the quality of {{encodings}} and to rule out trivial or meaningless encodings, they are augmented with quality criteria. There exists a bunch of different criteria and different variants of criteria in order to reason in different settings. This leads to incomparable results. Moreover {{it is not always}} clear whether the criteria used to obtain a result in a particular setting do indeed fit to this setting. We show how to formally reason about and compare encodability criteria by mapping them on requirements on a relation between source and target terms that is induced by the encoding function. In particular we analyse the common criteria full abstraction, operational correspondence, divergence reflection, success sensitiveness, and respect of barbs; e. g. we analyse the exact nature of the simulation relation (coupled simulation versus bisimulation) that is induced by different variants of operational correspondence. This way we reduce the problem of analysing or comparing encodability criteria to the better understood problem of comparing relations on processes. Comment: In Proceedings EXPRESS/SOS 2015, arXiv: 1508. 06347. The Isabelle/HOL source files, and a full <b>proof</b> <b>document,</b> are available in the Archive of Formal Proofs, at [URL]...|$|E
40|$|AbstractAfter several decades, most proof assistants {{are still}} {{centered}} around TTY-based interaction {{in a tight}} read-eval-print loop. Even well-known Emacs modes for such provers follow this synchronous model based on single commands with immediate response, meaning that the editor waits for the prover after each command. There have been some attempts to re-implement prover interfaces in big IDE frameworks, while keeping the old interaction model. Can we do better than that?Ten years ago, the Isabelle/Isar proof language already emphasized the idea of <b>proof</b> <b>document</b> (structured text) instead of proof script (sequence of commands), although the implementation was still emulating TTY interaction {{in order to be}} able to work with the then emerging Proof General interface. After some recent reworking of Isabelle internals, to support parallel processing of theories and proofs, the original idea of structured document processing has surfaced again. Isabelle versions from 2009 or later already provide some support for interactive proof documents with asynchronous checking, which awaits to be connected to a suitable editor framework or full-scale IDE. The remaining problem is how to do that systematically, without having to specify and implement complex protocols for prover interaction. This is the point where we introduce the new Isabelle/Scala layer, which is meant to expose certain aspects of Isabelle/ML to the outside world. The Scala language (by Martin Odersky) is sufficiently close to ML in order to model well-known prover concepts conveniently, but Scala also runs on the JVM and can access existing Java libraries directly. By building more and more external system wrapping for Isabelle in Scala, we eventually reach the point where we can integrate the prover seamlessly into existing IDEs (say Netbeans). To avoid getting side-tracked by IDE platform complexity, our current experiments are focused on jEdit, which is a powerful editor framework written in Java that can be easily extended by plugin modules. Our plugins are written again in Scala for our convenience, and to leverage the Scala actor library for parallel and interactive programming. Thanks to the Isabelle/Scala layer, the Isabelle/jEdit implementation is very small and simple...|$|E
40|$|This report {{outlines}} {{the rules on}} the taking and using of evidence in Austrian civil procedure law. On the basis of principles such as the free disposition of parties, the attenuated inquisitorial principle or the principles of orality and directness, the judge and the parties form a “working group” when investigating the matter in dispute. The Austrian concept of an active judge, however, goes along with the judge’s duty to do case-management and especially to induce a truthful fact-finding using judicial discretion. While only five means of <b>proof</b> (<b>documents,</b> witnesses, expert opinions, evidence by inspection and the examination of parties) are explicitly listed the Austrian civil procedure code, there is no numerus clausus regarding the means of evidence. Evidence may be freely assessed by the judge...|$|R
40|$|Isabelle/Isar is {{a generic}} {{framework}} for human-readable formal <b>proof</b> <b>documents,</b> both like and unlike Mizar. The Isar proof language provides general principles {{that may be}} instantiated to particular object-logics and applications. The design of Isar has emerged from careful analysis of some inherent virtues of the existing logical framework of Isabelle/Pure, notably composition of higher-order natural deduction rules, which is a generalization of Gentzen’s original calculus. Thus Isar proof texts may be understood as structured compositions of formal entities of the Pure framework, namely propositions, facts, and goals. This paper provides an extensive overview of the combined Pure + Isar framework, including a full object-logic definition as a working example. Hereby we hope to illustrate the present stage of our particular journey from insight into the logical framework, to proofs written in Isabelle/Isar...|$|R
40|$|We are {{developing}} a CMS including document authoring feature based on wiki to publish structural mathematical documents on the Web. Using this system, users can write documents including mathematical expressions written in LATEX notation and explicitly stated characteristic structures of mathematical articles such as definitions, theorems, and <b>proofs.</b> <b>Documents</b> input to the system is published on the Web as not only XHTML files to be browsed but also XML files complying with NLM-DTD, {{which is used to}} exchange articles electronically. Not only single wiki page document, users can build a document which consist of more than one pages and is described its structure semantically by the system. In order to do this, we also propose an application of OAI-ORE and RDF vocabularies to describe structures of documents consisting of several resources. ...|$|R
5000|$|A third says [...] "Beware of {{the many}} phony GH3's ... {{we are the only}} company willing and able to supply <b>documented</b> <b>proof</b> of our GH3's authenticity." ...|$|R
