7|45|Public
50|$|The {{majority}} of campaign furniture was commissioned or retailed as individual pieces but Ross very cleverly gave {{the option of}} buying a suite of furniture. Such a suite would have {{a combination of a}} short set of Dining Chairs, an Easy Chair, a Couch, a Center Table and a Chiffonier or Sideboard which broke down to become the packing case. On the inside door of the cabinet furniture would be a label, giving <b>packing</b> <b>instructions.</b> The packing case cabinets were often adorned with carved decoration and moulding, which again was unusual for campaign furniture that mostly considered flat surfaces and square edges to be a pre-requisite. However, when it came to packing the cabinet, the moulding would be removed and the carved show wood protected with a bolt on panel so no sacrifice was made for the added decoration.|$|E
50|$|When {{considering}} outgoing loans, {{institutions can}} also request a General Facility Report form {{to verify that}} the borrowing museum meets the lending institution's minimum standards of climate control and security. Once a loan is approved, a loan agreement is drafted, which is a binding legal document detailing the minimum requirements of care while the object is in the borrower's possession, packing and transportation arrangements, insurance requirements, guidelines for reproduction and credit, and any other special provisions agreed upon by both institutions. Additional documentation that can accompany travelling objects could also include specific <b>packing</b> <b>instructions</b> with diagrams and an itemized shipping receipt or bill of lading. Copies {{of all of these}} documents are stored in the exhibition files, as well as the object's permanent file. An exhibition file could also contain checklists, gallery layouts and lists of object locations, conservation records, computer reports, installation photographs, gallery climate and pest-monitoring records, purchase requisitions, and correspondence relating to the exhibition.|$|E
40|$|Abstract—A {{new breed}} of {{processors}} like the Cell Broadband Engine, the Imagine stream processor and the various GPU processors emphasize data-level parallelism (DLP) and threadlevel parallelism (TLP) as opposed to traditional instructionlevel parallelism (ILP). This allows them to achieve order-ofmagnitude improvements over conventional superscalar processors for many workloads. However, it is unclear {{as to how much}} parallelism of these types exists in current programs. Most earlier studies have largely concentrated on the amount of ILP in a program, without differentiating DLP or TLP. In this study, we investigate the extent of data-level parallelism available in programs in the MediaBench suite. By <b>packing</b> <b>instructions</b> in a SIMD fashion, we observe reductions of up to 91 % (84 % on average) in the number of dynamic instructions, indicating a very high degree of DLP in several applications. I...|$|E
40|$|The Instruction Register File (IRF) is an {{architectural}} extension for providing improved access to frequently occurring instructions. An optimizing compiler can exploit an IRF by <b>packing</b> an application’s <b>instructions,</b> resulting in decreased code size, {{reduced energy consumption}} and improved execution time primarily due to a smaller footprint in the instruction cache. The nature of the IRF also allows the execution of <b>packed</b> <b>instructions</b> to overlap with instruction fetch, thus providing a means for tolerating increased fetch latencies, like those experienced by encrypted ICs {{as well as the}} presence of low-power L 0 caches. Although previous research has focused on the direct benefits of <b>instruction</b> <b>packing,</b> this paper explores the use of increased fetch bandwidth provided by <b>packed</b> <b>instructions.</b> Small L 0 caches improve energy efficiency but can increase execution time due to frequent cache misses. We show that this penalty can be significantly reduced by overlapping the execution of <b>packed</b> <b>instructions</b> with miss stalls. The IRF {{can also be used to}} supply additional instructions to a more aggressive execution engine, effectively reducing dependence on instruction cache bandwidth. This can improve energy efficiency, in addition to providing additional flexibility for evaluating various design tradeoffs in a pipeline with asymmetric instruction bandwidth. Thus, we show that the IRF is a complementary technique, operating as a buffer tolerating fetch bottlenecks, as well as providing additional fetch bandwidth for an aggressive pipeline backend...|$|R
5000|$|Executing partial-width <b>packed</b> data <b>instructions</b> Method and {{apparatus}} {{for processing}} 2D operations in a tiled graphics architecture ...|$|R
40|$|The {{architectural}} design of embedded systems {{is becoming increasingly}} idiosyncratic to meet varying constraints regarding energy consumption, code size, and execution time. Traditional compiler optimizations are often tuned for improving general architectural constraints, yet these heuristics {{may not be as}} beneficial to less conventional designs. <b>Instruction</b> <b>packing</b> is a recently developed compiler/architectural approach for reducing energy consumption, code size, and execution time by placing the frequently occurring instructions into an Instruction Register File (IRF). Multiple IRF instructions are made accessible via special <b>packed</b> <b>instruction</b> formats. This paper presents the design and analysis of a compilation framework and its associated optimizations for improving the efficiency of <b>instruction</b> <b>packing.</b> We show that several new heuristics can be developed for IRF promotion, instruction selection, register re-assignment and instruction scheduling, leading to significant reductions in energy consumption, code size, and/or execution time when compared to results using a standard optimizing compiler targeting the IRF...|$|R
40|$|New processors, both {{embedded}} {{and general}} purpose, often have conflicting design requirements involving space, power, and performance. Architectural features and compiler optimizations often target {{one or more}} design goals {{at the expense of}} the others. This paper presents a novel architectural and compiler approach to simultaneously reduce power requirements, decrease code size, and improve performance by integrating an instruction register file (IRF) into the architecture. Frequently occurring instructions are placed in the IRF. Multiple entries in the IRF can be referenced by a single packed instruction in ROM or L 1 instruction cache. Unlike conventional code compression, our approach allows the frequent instructions to be referenced in arbitrary combinations. The experimental results show significant improvements in space and power, as well as some improvement in execution time when using only 32 entries. These advantages make <b>packing</b> <b>instructions</b> into registers an effective approach for improving overall efficiency. 1...|$|E
40|$|Metso Minerals is {{a global}} {{corporation}} that has numerous shipping locations all over the world. Metso Minerals is also constantly acquiring new customers while paying special attention to customer retention. According {{to a study by}} a marketing research over 40 % of all customers in today’s market economy take their business elsewhere/change over to a competitor due simply to a lack of contact. Every day hundreds of packages are shipped and received from numerous different manufacturers, Metso Minerals ' warehouses and customers. No unified <b>packing</b> <b>instructions</b> exist. It is the purpose of this thesis to analyse and compare the current methods of packing and introduce some new ideas of improvement for the future. Additionally, if a form of consistency is globally assumed in packing critical, sensitive and fragile parts, the cost in damages and shipping processes will reduce, damages will be minimized and the quality and customer satisfaction will improve. This work will also make it easier to compile a shipping manual to be use...|$|E
40|$|This {{thesis is}} about educating the packing {{engineers}} at Scania to their best potential. The education {{is made by}} developing an E-course adapted specially for the packing engineers at Scania. Content of the E-course was defined through analysis of literature, science articles and interviews with the packing engineers it was also decided from analysis. Reason why the packing engineers needed this education is because the packing engineers decisions has {{a big impact on}} the company. So it is therefore important that the packing engineers consider different parameters when deciding how the final package should look. One way to improve the packing engineers work is by the virtual packing software Pack-Assistant which is used to pack CAD-files, which is much more quicker then manual packing and efficient. The main purpose with this thesis is to investigate which parameters has to be taken in to consideration for the most efficient packing (and what is efficient from different perspectives). How do packaging influence logistic and vice versa and how to adapt the E-course in the most optimal way. The projects main purpose was to study different E-course educational methods, analysis of how Pack-Assistant works, observation of packages in Scania, experiments was conducted to see how real packages differ when the same parts was simulated in Pack-Assistant. Where it was concluded that Pack-Assistant was a more pack efficient {{for the majority of the}} tested parts. From the comparison it was also concluded that Scania could save 13 % of their freight cost, container cost and internal handling cost just from packing in Pack-Assistant. One other major result from the analysis is that packing engineers prefer to pack the number of parts with even “nice” numbers like 10, 20, 50, 100, etc. Which is a great problem economically for Scania, sometimes it is more efficient to pack with 11 parts instead of 10 parts. It was also observed how the setting in Pack-Assistant had for effect on the packing and also in which circumstances to use the different packing structures in the software. When the course was finish the main subjects is The packaging working process, number of parts in the package, package handle ability and packing structure. The course consist of two parts:Part 1 : Which different parameters to consider in the making of <b>packing</b> <b>instructions.</b> Part 2 : How to use the software Pack-Assistant and what in the software is of great importance for the packing engineer at Scania. Validerat; 20151214 (global_studentproject_submitter...|$|E
40|$|Abstract- This work {{proposed}} a design {{and development of}} a 32 -bit stack-based processor for embedded systems. A reference processor has a 32 -bit stack-based instruction set. This work {{proposed a}} technique of <b>instruction</b> <b>packing</b> which <b>packs</b> several <b>instructions</b> into one 32 -bit instruction unit. Therefore, the instruction size is reduced. The result of the experiment shows that the proposed technique achieves around 30 % reduction in code size...|$|R
50|$|SSE {{introduced}} both scalar and <b>packed</b> {{floating point}} <b>instructions.</b>|$|R
40|$|This paper {{illustrates}} {{the strong interaction between}} background data format organization and foreground {{data in the}} context of speed and power efficient Sub-Word level Parallel (SWP) program generation. Such interaction, if not considered well, results in an (un) packing and reordering overhead that is typically required to match the format of data stored in memory and the one required by the subword parallel processing units. We propose a conceptual methodology to minimize this overhead. The approach is demonstrated on two real-life application kernels. A significant reduction in <b>packing</b> <b>instruction</b> overhead, data- (up to a factor 12) and instruction memory accesses (up to a factor 6) is obtained. ...|$|R
40|$|As {{prices for}} {{computers}} and software fall, more companies {{are able to}} use them to make their business more efficient. However, a lot of companies do not use the full potential of their software. The purpose of this report is to describe how information technology in general, and knowledge based engineering in particular, can be used in smaller companies. A literary survey and two case studies have been used to investigate this. One of the case studies was performed at Clamason Industries: they produce high volume precision bending. The other case study was performed at Leslie Group: they produce hot forgings. Both the companies are situated in the outskirts of Birmingham. Results indicate that knowledge based engineering {{can be used as a}} labour saving device, by collecting process information in a database. This database can be used to generate four different reports for process control to fulfil QS 9000 requirements. The same database can also be used as a decision support system for strategic quality planning. The recommendation for Clamason Industries is to continue the development of this database. This will give them a powerful tool to fulfil the requirements for QS 9000. Clamason may need some assistance to develop the management of process data. The KEM Centre at Coventry University or any other organisation with experience of product data management may perform this work. KEM Centre can also use the demonstrator to create a commercial application for other SMEs. The staff at Clamason can perform other development that is specific for their company, such as creating more reports and forms needed for warranties and <b>packing</b> <b>instructions.</b> The tool for strategic quality planning also needs further development. Today, this is just included in the demonstrator to view the possibilities. By developing the query used to create the pareto charts, the information can be filtered in different ways. This means that can be possible to create pareto charts not only for all products, but also to limit the chart to potential failures specific for a customer, machine, safety critical products or any other feature that need to be investigated. This can be developed by an external organisation or by the staff at Clamason after some training in Access and Excel. Further investigation is required to be able to give an appropriate recommendation for Leslie Group. Their current awareness of information technology is not enough to introduce any KBE application. However, there are probably areas in the company where convenient KBE application can be used, but further education from the KEM Centre is required. The thesis illustrates that the method used to develop knowledge based engineering can be a determining factor for its usefulness. The conclusion of the project is that knowledge based engineering can be used in small and medium sized enterprises. However, the company's awareness of information technology is crucial for success. Validerat; 20101217 (root...|$|E
40|$|<b>Instruction</b> <b>packing</b> is a {{combination}} compiler/architectural approach that allows for decreased code size, reduced power consumption and improved performance. The packing is obtained by placing frequently occurring instructions into an Instruction Register File (IRF). Multiple IRF entries can then be accessed using special <b>packed</b> <b>instructions.</b> Previous IRF efforts focused on using a single 32 -entry register file {{for the duration of}} an application. This paper presents software and hardware extensions to the IRF supporting multiple instruction register windows to allow a greater number of relevant instructions to be available for packing in each function. Windows are shared among similar functions to reduce the overall costs involved in such an approach. The results indicate that significant improvements in instruction fetch cost can be obtained by using this simple architectural enhancement. We also show that using an IRF with a loop cache, which is also used to reduce energy consumption, results in much less energy consumption than using either feature in isolation. ...|$|R
25|$|Although dry ice is not {{classified}} as a dangerous substance by the European Union, or as a hazardous material by the United States Department of Transportation for ground transportation, when shipped by air or water, it is regulated as a dangerous good and IATA <b>packing</b> <b>instruction</b> 954 (IATA PI 954) requires that it be labeled specially, including a diamond-shaped black-and white label, UN 1845. Also, arrangements must be in place to ensure adequate ventilation so that pressure build-up does not rupture the packaging. The Federal Aviation Administration in the US allows airline passengers to carry up to 2.5kg per person either as checked baggage or carry-on baggage, when used to refrigerate perishables.|$|R
5000|$|Added {{document}} types for fulfillment: Bill of Lading, Certificate of Origin, Forwarding <b>Instructions,</b> <b>Packing</b> List, Transportation Status, Waybill ...|$|R
40|$|We {{describe}} a diagnostic specimen transport container that {{is appropriate for}} limited resource or emergency settings. The transport container is constructed from polyvinyl chloride (PVC) plumbing pipe, which is readily available and inexpensive (US$ 1 - 2, depending on size) and has wide flexibility of size due to the range of PVC pipe dimensions available. The PVC transporters are durable, water-resistant and may be easily decontaminated. They have been adapted for the transport of blood culture bottles from provincial hospitals in Laos, where, during a 2 -year period, 380 PVC tubes containing blood culture bottles were transported without any leakage or breakage. We have found the PVC transporter to be a useful and cost-efficient durable alternative that meets IATA <b>Packing</b> <b>Instruction</b> 650 biological transport container requirements...|$|R
40|$|Abstract—We propose several {{schemes to}} improve the scalability, reduce the {{complexity}} and delays, and increase the throughput of dynamic scheduling in SMT processors. Our first design is an adaptation of the recently proposed <b>instruction</b> <b>packing</b> to SMT. <b>Instruction</b> <b>packing</b> opportunistically <b>packs</b> two <b>instructions</b> (possibly from different threads), each with at most one nonready source operand {{at the time of}} dispatch, into the same issue queue entry. Our second design, termed 2 OP_BLOCK, takes these ideas one step further and completely avoids the dispatching of the instructions with two nonready source operands. This technique has several advantages. First, it reduces the scheduling complexity (and the associated delays) as the logic needed to support the instructions with two nonready source operands is eliminated. More surprisingly, 2 OP_BLOCK simultaneously improves the performance as the same issue queue entry may be reallocated multiple times to the instructions with at most one nonready source (which usually spends fewer cycles in the queue) as opposed to hogging the entry with an instruction which enters the queue with two nonready sources. For schedulers with the capacity to hold 64 instructions on a 4 -way SMT, the 2 OP_BLOCK design outperforms the traditional queue by 14 percent, on average, {{and at the same time}} results in a 10 percent reduction in the overall scheduling delay. We also present mechanisms to support speculative scheduling with 2 OP_BLOCK and introduce the hybrid scheme that dynamically switches between 2 OP_BLOCK and <b>instruction</b> <b>packing</b> modes depending on the workload characteristics, to achieve further performance gains. Index Terms—Issue queue, simultaneous multithreading. Ç...|$|R
40|$|We propose dynamic {{scheduler}} {{designs to}} improve the scheduler scalability and reduce its complexity in the SMT processors. Our first design is an adaptation of the recently proposed <b>instruction</b> <b>packing</b> to SMT. <b>Instruction</b> <b>packing</b> opportunistically <b>packs</b> two <b>instructions</b> (possibly from different threads), each with at most one non-ready source operand {{at the time of}} dispatch, into the same issue queue entry. Our second design, termed 2 OP_BLOCK, takes these ideas one step further and completely avoids the dispatching of the instructions with two non-ready source operands. This technique has several advantages. First, it reduces the scheduling complexity (and the associated delays) as the logic needed to support the instructions with 2 non-ready source operands is eliminated. More surprisingly, 2 OP_BLOCK simultaneously improves the performance as the same issue queue entry may be reallocated multiple times to the instructions with at most one non-ready source (which usually spend fewer cycles in the queue) as opposed to hogging the entry with an instruction which enters the queue with two non-ready sources. For the schedulers with the capacity to hold 64 instructions, the 2 OP_BLOCK design outperforms the traditional queue by 11 %, on the average, {{and at the same time}} results in a 10 % reduction in the overall scheduling delay...|$|R
40|$|Small filter caches (L 0 caches) {{can be used}} {{to obtain}} {{significantly}} reduced energy consumption for embedded systems, but this benefit comes at the cost of increased execution time due to frequent L 0 cache misses. The Instruction Register File (IRF) is an architectural extension for providing improved access to frequently occurring instructions. An optimizing compiler can exploit an IRF by <b>packing</b> an application’s <b>instructions,</b> resulting in decreased code size, reduced energy consumption and improved execution time primarily due to a smaller footprint in the instruction cache. The nature of the IRF also allows the execution of <b>packed</b> <b>instructions</b> to overlap with instruction fetch, thus providing a means for tolerating increased fetch latencies. This paper explores the use of an L 0 cache enhanced with an IRF to provide even further reduced energy consumption with improved execution time. The results indicate that the IRF is an effective means for offsetting execution time penalties due to pipeline frontend bottlenecks. We also show that by combining an IRF and an L 0 cache, we are able to achieve reductions in fetch energy that is greater than using either feature in isolation...|$|R
5000|$|Instructions {{were six}} {{alphanumeric}} characters, <b>packed</b> two <b>instructions</b> per word. The addition time was 525 microseconds and the multiplication time was 2150 microseconds. A non-standard modification called [...] "Overdrive" [...] did exist, that allowed for three four-character instructions per word under some circumstances. (Ingerman's simulator for the UNIVAC, referenced below, also makes this modification available.) ...|$|R
40|$|Driven {{primarily}} by the needs of multimedia, {{a number of recent}} processors have instructions which operate in a SIMD fashion on multiple data values packed into a single machine word. Here we outline techniques which could be used by a compiler or interactive programming tool to calculate the sizes of such data {{to take advantage of the}} available <b>packed</b> <b>instruction</b> sets. In our results we show three examples of programs in which variables and intermediate results have been automatically calculated by the compiler front-end. The compiler successfully deduces minimal intermediate ranges and results in all cases. In our colour conversion program, for example, the intermediate results are deduced to be 24 bits with a 16 bit fractional part. Keywords: interval arithmetic; packed arithmetic; fixed point; multimedia; compiler. 1 Introduction As the demand for low-cost performance computing increases, the latest generation of processors have increased their data widths to 64 bits, and this tr [...] ...|$|R
40|$|This project {{lays the}} groundwork for porting an {{existing}} Java JIT compiler to the IA- 64 architecture. There are three main tasks involved in this port, all of which involve only the back-end (machine-dependent portion) of the existing compiler: (1) efficient <b>instruction</b> <b>packing</b> of IA- 64 native code into the IA- 64 long instruction word, (2) implementing a dynamic method-translation subsystem (trampolines) for the IA- 64 processor, and (3) implementing translation of compiler intermediate instructions into native IA- 64 instructions. We have documented all three tasks, and have implemented IA- 64 <b>instruction</b> <b>packing</b> using state-of-the-art search techniques, obtaining optimization competitive with a recently-released IA- 64 C compiler. Chapter...|$|R
5000|$|Structure of arrays (or SoA) is a layout {{separating}} {{elements of}} a record (or 'struct' in the C programming language) into one parallel array per field. The motivation is easier manipulation with <b>packed</b> SIMD <b>instructions</b> in most instruction set architectures, since a single SIMD register can load homogeneous data, possibly transferred by a wide internal datapath (e.g. 128-bit). The downside is requiring more cache ways when traversing data, and inefficient indexed addressing. (see also: planar image format) ...|$|R
50|$|Certain {{embedded}} RISC ISAs like Thumb and AVR32 typically exhibit {{very high}} density owing to {{a technique called}} code compression. This technique <b>packs</b> two 16-bit <b>instructions</b> into one 32-bit instruction, which is then unpacked at the decode stage and executed as two instructions.|$|R
25|$|The CIA Deer gun was a single-shot 9×19 mm Parabellum pistol, {{made by the}} U.S. {{during the}} Vietnam War. It was {{packaged}} with three rounds of ammunition in the grip, and <b>packed</b> with <b>instructions</b> in a plastic box. If air-dropped into water, the plastic box containing the pistol would float. Like the earlier FP-45 Liberator, it was designed primarily for assassination of enemy soldiers, with the intention {{that it would be}} replaced by an enemy soldier's left-over equipment. The instructions for the Deer Gun were pictorial, with text in Vietnamese.|$|R
40|$|This paper {{illustrates}} {{the strong interaction between}} background data format organization and foreground {{data in the}} context of speed and power efficient Sub-Word level Parallel (SWP) program generation. Such interaction, if not considered well, results in an excess of (un) packing operations that are typically required to match the format of data stored in memory to the one required by the sub-word parallel processing units. To avoid this overhead a careful selection of the data format for background storage is needed. We propose a conceptual methodology for efficiently exploiting such degree of freedom. The approach is demonstrated on two real-life application kernels, where source code level data format transformations are applied to the data in background memory such that a substantially better exploitation of the sub-word level functional units can be achieved by the compiler. A significant reduction in <b>packing</b> <b>instruction</b> overhead, data (up to a factor 4) and instruction memory accesses (up to 50 %) is obtained. This results in a substantial reduction of power consumed by the register file (less (un) packing operations), the data bus (less bus transactions), the data memory hierarchy (less accesses) and the instruction memory hierarchy (less accesses and more compact code). Also the execution time for the optimized application running on a TriMedia TM 1300 evaluation board shows substantial gains. ...|$|R
40|$|A {{comprehensive}} {{series of}} dependable recipes to design, build, {{and implement a}} PostgreSQL server architecture free of common pitfalls that can operate for years to come. Each chapter is <b>packed</b> with <b>instructions</b> and examples to simplify even highly complex database operations. If you are a PostgreSQL DBA working on Linux systems who want a database that never gives up, this book is for you. If you've ever experienced a database outage, restored from a backup, spent hours trying to repair a malfunctioning cluster, or simply want to guarantee system stability, this book is definitely for you...|$|R
40|$|We {{introduce}} the first DSP core {{developed at the}} Analog Devices and Intel Joint DSP Development Center. The 16 -bit fixed-point core combines {{some of the best}} features of traditional DSPs and micro-controllers and compares favorably with dual-MAC DSPs on DSP specific benchmarks and with micro-controllers on micro-controller specific benchmarks. In addition, the core supports a rich set of alignment independent <b>packed</b> byte <b>instructions</b> to enable an efficient implementation of 3 G algorithms in next-generation wireless applications. The deep and fully interlocked pipeline allows the core to run at 333 MHz in the 0. 18 -um TSMC process...|$|R
40|$|The {{instruction}} scheduling logic used in modern superscalar microprocessors often relies on associative searching {{of the issue}} queue entries to dynamically wakeup instructions for the execution. Traditional designs use one issue queue entry for each instruction, regardless of {{the actual number of}} operands actively used in the wakeup process. In this paper we propose <b>Instruction</b> <b>Packing</b> – a novel microarchitectural technique that reduces both the delay and the power consumption of the issue queue by sharing the associative part of an issue queue entry between two instructions, each with at most one non-ready register source operand at the time of dispatch. Our results show that <b>Instruction</b> <b>Packing</b> provides a 39 % reduction of the whole issue queue power and 21. 6 % reduction in the wakeup delay with as little as 0. 4 % IPC degradation on the average across the simulated SPEC benchmarks...|$|R
50|$|Japanese garage kits {{are usually}} cast as {{separate}} parts which are <b>packed</b> with <b>instructions</b> and sometimes {{photographs of the}} final product. Most professionally manufactured kits come in a box while amateur-produced kits sold at conventions come in a plastic bags, blank boxes or even boxes with copied sheet information glued onto it. They are not painted, {{but some of them}} do have decals provided by the sculptor or circle. The builder has to paint and assembled the model, preferably with an airbrush. However, they can also be painted with a regular brush using a variety of techniques to achieve similar effects as when painting with a conventional airbrush.|$|R
5000|$|Packed decimal {{numbers are}} stored as 1-16 8-bit bytes {{containing}} an odd number of decimal digits {{followed by a}} 4-bit sign. Sign values of hexadecimal A, C, E and F are positive and sign values of hexadecimal B and D are negative. Digit values of hexadecimal A-F and sign values of 0-9 are invalid, but the <b>PACK</b> and UNPK <b>instructions</b> do not test for validity.|$|R
40|$|Submitted to 2 nd Euromicro Workshop on Parallel and Distributed Processing, Spain, 1994 This paper {{presents}} the results of an investigation into the performance of a new statically scheduled multiple-instruction-issue architecture and its compiler. HARP is a Long Instruction Word Architecture developed in conjunction with a simple compile-time scheduling technique called conditional compaction. The architecture is characterised by a conditional execution mechanism which is used by the scheduler to <b>pack</b> the <b>instructions</b> within a procedure into long instruction words. The study compares the speedups obtained for the C and Modula- 2 versions of a set of short, general purpose, integer benchmarks, running on simulations of the architecture with different functional unit configurations...|$|R
40|$|In {{the packed}} string {{matching}} problem, each machine word accommodates α characters, thus an n-character text occupies n/α memory words. We extend the Crochemore-Perrin constantspace O(n) -time string matching algorithm {{to run in}} optimal O(n/α) time and even in real-time, achieving a factor α speedup over traditional algorithms that examine each character individually. Our solution can be efficiently implemented, unlike prior theoretical packed string matching work. We adapt the standard RAM model and only use its AC 0 instructions (i. e., no multiplication) plus two specialized AC 0 <b>packed</b> string <b>instructions.</b> The main string-matching instruction is available in commodity processors (i. e., Intel’s SSE 4. 2 and AVX Advanced String Operations); the other maximal-suffix instruction is only required during pattern preprocessing. In the absence of these two specialized instructions, we propose theoretically-efficient emulation using integer multiplication (not AC 0) and table lookup...|$|R
40|$|Power is {{becoming}} a critical constraint for designing embedded applications. Current power analysis techniques based on circuit-level or architectural-level simulation are either impractical or inaccurate to estimate the power cost for a given piece of application software. In this paper, an instruction-level power analysis model is developed for an embedded DSP processor based on physical current measurements. Significant points of difference have been observed between the software power model for this custom DSP processor and the power models {{that have been developed}} earlier for some general-purpose commercial microprocessors [1, 2]. In particular, the effect of circuit state on the power cost of an instruction stream is more marked in the case of this DSP processor. In addition, the processor has special architectural features that allow dual-memory accesses and <b>packing</b> of <b>instructions</b> into pairs. The energy reduction possible through the use of these features is studied. The on-chi [...] ...|$|R
40|$|Social {{networks}} enable {{anyone with}} a computer and Internet connection {{to stay in touch}} with friends and family across the globe, and rediscover old acquaintances.   Social Networking for the Older and Wiser starts with the basics of social networks, before moving onto intermediate topics, all whilst highlighting ways to protect your privacy and keep your details secure. The book is <b>packed</b> with step-by-step <b>instructions</b> on how to use Facebook, Twitter, Friends Reunited, Saga Zone, and other social networks to:Create an account on your chosen social networkReconnect and stay-in-touch with old f...|$|R
