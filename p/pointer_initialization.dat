3|3|Public
5000|$|Default {{initialization}} of {{derived type}} components, including <b>pointer</b> <b>initialization</b> ...|$|E
40|$|Abstract. Source-to-source {{translation}} {{is an important}} code generation strategy commonly used by parallelizing compilers and compilers for parallel languages. In this paper, we investigate the performance impact of using different Fortran 90 representations for local and remote accesses on scalable shared-memory multiprocessors when generating SPMD code for Co-array Fortran. Our aim is to deliver the full power of the hardware platform to the application when operating on local data and when accessing remote data using either coarse-grain or fine-grain communication. We explored the performance impact of several different representations for shared data and several different ways of implementing communication. Using CAF variants of the STREAM, Random Access, and NAS MG & SP benchmarks, we compared the performance of library-based implementations of one-sided communication with fine-grain communication that uses pointers to access remote data using load and store operations. Our experiments showed that using pointer-based fine-grain communication improved performance {{as much as a}} factor of 24 on an SGI Altix and as much as a factor of five on an SGI Origin, when <b>pointer</b> <b>initialization</b> is hoisted out of a loop performing data accesses. ...|$|E
40|$|Due to the {{significant}} limitations of static analysis and the dynamic nature of pointers in weakly typed programming languages like C and C++, the points-to sets obtained at compile time are quite conservative. Most static pointer analysis methods trade the precision {{for the analysis}} speed. The methods that perform the analysis in {{a reasonable amount of}} time are often context and/or flow insensitive. Other methods that are context, flow, and field sensitive have to perform the whole program inter-procedural analysis, and do not scale with respect to the program size. A large class of problems involving optimizations such as instruction prefetching, control and data speculation, redundant load/store instructions removal, instruction scheduling, and memory disambiguation suffer due to the imprecise and conservative points-to sets computed statically. One could possibly live without optimizations, but in domains involving memory security and safety, lack of the precise points-to sets can jeopardize the security and safety. In particular, the lack of dynamic points-to sets drastically reduce the ability to reason about a program's memory access behavior, and thus illegal memory accesses can go unchecked leading to bugs as well as security holes. On the other hand, the points-to sets can be very useful for other domains such as the heap shape analysis and garbage collection. The knowledge of precise points-to sets is therefore becoming very important, but has received little attention so far beyond a few studies, which have shown that the pointers exhibit very interesting behaviors during execution. How to track such behaviors dynamically and benefit from them is the topic covered by this research. In this work, we propose a technique to compute the precise points-to sets through dynamic pointer tracking. First, the compiler performs the pointer analysis to obtain the static points-to sets. Then, the compiler analyzes the program, and inserts the necessary instructions to refine the points-to sets. At runtime, the inserted instructions automatically update the points-to sets. Dynamic pointer tracking in software can be expensive and can be a barrier to the practicality of such methods. Several optimizations including removal of redundant update, post-loop update, special pattern driven update removal, <b>pointer</b> <b>initialization</b> update removal, update propagation, invariant removal, and on demand update optimization are proposed. Our experimental results demonstrate that our mechanism is able to compute the points-to sets dynamically with tolerable overheads. Finally, the memory protection and garbage collection work are presented as the consumers of dynamic pointer tracking to illustrate its importance. In particular, it is shown how different memory properties can be easily tracked using the dynamic points-to sets opening newer possibilities. Ph. D. Committee Chair: Santosh Pande; Committee Member: Hsien-Hsin S. Lee; Committee Member: Hyesoon Kim; Committee Member: Jonathon Giffin; Committee Member: Nathan Clar...|$|E
5000|$|Data {{manipulation}} enhancements: allocatable components (incorporating TR 15581), deferred type parameters, [...] attribute, explicit type specification {{in array}} constructors and allocate statements, <b>pointer</b> enhancements, extended <b>initialization</b> expressions, and enhanced intrinsic procedures ...|$|R
5000|$|A non-valid object pointer has {{the value}} nil; {{conditional}} statements like [...] "if" [...] treat nil like a null <b>pointer,</b> so the <b>initialization</b> code {{will not be}} executed if init returned nil. If there is an error in initialization the init method should perform any necessary cleanup, including sending a [...] "release" [...] message to self, and return nil to indicate that initialization failed. Any checking for such errors must only be performed after having called the superclass initialization to ensure that destroying the object will be done correctly.|$|R
40|$|Mutual {{dependencies}} between objects arise {{frequently in}} programs, and programmers must typically resort to manually filling “initialization holes ” to help construct the corresponding object graphs, i. e. null values and/or explicitly mutable locations. This report describes a “base-line ” {{proposal for a}} generalized form of value recursion in an ML-like language called initialization graphs, where value recursion is given the simplistic semantics of a graph of lazy computations whose nodes are sequentially forced, with uses of recursive values checked for initialization-soundness at runtime. We then develop examples using this mechanism to show how problematic the issue of value recursion is for ML-like languages, and in particular how sophisticated reactive objects cannot be defined in the language without using initialization holes, and how this forces ML programmers to break abstraction boundaries. At {{the same time we}} show how OO languages rely extensively on null <b>pointers</b> during <b>initialization.</b> We propose that a general, semi-safe mechanism allows value recursion to be used in conjunction with existing sophisicated abstract APIs such GUI libraries, and allows freshly defined APIs to be both abstract and yet not require clients to use explicit initialization holes. We propose that the initialization mechanism permits more programs to be expressed in the mutation-free fragment of ML, though we do not formally prove this result. ...|$|R

