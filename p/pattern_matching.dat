5439|1785|Public
25|$|Control {{statements}} while, if, {{and switch}} are similar, but have extended functions, e.g., a switch that takes non-integer cases, while and if supporting <b>pattern</b> <b>matching</b> and conditionally unwrapping optionals, etc.|$|E
25|$|<b>Pattern</b> <b>matching</b> to schema—prototypical {{states of}} the mental model—that {{provides}} rapid retrieval of comprehension and projection relevant to the recognized situation {{and in many cases}} single-step retrieval of appropriate actions for the situation.|$|E
25|$|Another defense {{approach}} is to use automated tools that will remove XSS malicious code in web pages, these tools use static analysis and/or <b>pattern</b> <b>matching</b> methods to identify malicious codes potentially and secure them using methods like escaping.|$|E
40|$|Programs {{written in}} Haskell may fail at runtime {{with either a}} <b>pattern</b> <b>match</b> error, or with non-termination. Both of these {{can be thought of}} as giving the value ⊥ as a result. Other forms of failure, for example heap exhaustion, are not considered. The first section of this {{document}} reviews previous work, including total functional programming and sized types. Attention is paid to termination checkers for both Prolog and various functional languages. The main result from work so far is a static checker for <b>pattern</b> <b>match</b> errors that allows non-exhaustive patterns to exist, yet ensures that a <b>pattern</b> <b>match</b> error does not occur. It includes a constraint language that can be used to reason about <b>pattern</b> <b>matches,</b> along with mechanisms to propagate these constraints between program components. The proposal deals with future work to be done. It gives an approximate timetable for the design and implementation of a static checker for termination and <b>pattern</b> <b>match</b> errors...|$|R
5000|$|... {{supports}} exact, range, part key and <b>pattern</b> <b>matches</b> efficiently.|$|R
40|$|Abstract: A Haskell {{program may}} fail at runtime with a pattern-match error {{if the program}} has any {{incomplete}} (non-exhaustive) patterns in definitions or case alternatives. This paper describes a static checker that allows non-exhaustive patterns to exist, yet ensures that a pattern-match error does not occur. It describes a constraint language {{that can be used}} to reason about <b>pattern</b> <b>matches,</b> along with mechanisms to propagate these constraints between program components. Often it is useful to define <b>pattern</b> <b>matches</b> which are incomplete, for example head fails on the empty list. Unfortunately programs with incomplete <b>pattern</b> <b>matches</b> may fail at runtime...|$|R
25|$|CoffeeScript, an {{alternate}} syntax for JavaScript {{intended to be}} more concise and readable. It adds features like array comprehensions (also available in JavaScript since version 1.7) and <b>pattern</b> <b>matching.</b> Like Objective-J, it compiles to JavaScript. Ruby and Python have been cited as influential on CoffeeScript syntax.|$|E
25|$|Haskell {{features}} lazy evaluation, <b>pattern</b> <b>matching,</b> list comprehension, type {{classes and}} type polymorphism. It is a purely functional language, {{which means that}} functions generally have no side effects. A distinct construct exists to represent side effects, orthogonal {{to the type of}} functions. A pure function can return a side effect that is subsequently executed, modeling the impure functions of other languages.|$|E
25|$|Some syntax issues (changes in {{the formal}} grammar) were fixed: pattern guards were added, {{allowing}} <b>pattern</b> <b>matching</b> within guards; resolution of operator fixity was specified in a simpler way that reflected actual practice; an edge case in {{the interaction of the}} language's lexical syntax of operators and comments was addressed; and the interaction of do-notation and if-then-else was tweaked to eliminate unexpected syntax errors.|$|E
5000|$|To learn {{whether an}} actual spatial <b>pattern</b> <b>matches</b> some {{expected}} <b>pattern.</b>|$|R
40|$|<b>Pattern</b> <b>matches</b> {{for each}} of the {{sequence}} patterns in PROSITE, a database of sequence patterns, were searched in all protein sequences in the Brookhaven Protein Data Bank (PDB). The three-dimensional structures of the <b>pattern</b> <b>matches</b> for the 20 patterns with the largest numbers of hits were analysed. We found that the true positives have a common three-dimensional structure for each pattern; the structures of false positives, found for six of the 20 patterns, were clearly {{different from those of the}} true positives. The results suggest that the true <b>pattern</b> <b>matches</b> each have a characteristic common three-dimensional structure, which could be used to create a template to define a three-dimensional functional pattern...|$|R
40|$|The growing {{popularity}} of graph databases has generated interesting data management problems, such as subgraph search, shortest-path query, reachability verification, and <b>pattern</b> <b>match.</b> Among these, a <b>pattern</b> <b>match</b> query is more flexible compared to a subgraph search and more informative compared to a shortest-path or reachability query. In this paper, we address <b>pattern</b> <b>match</b> problems over a large data graph G. Specifically, given a pattern graph (i. e., query Q), {{we want to find}} all matches (in G) that have the similar connections as those in Q. In order to reduce the search space significantly, we first transform the vertices into points in a vector space via graph embedding techniques, coverting a <b>pattern</b> <b>match</b> query into a distance-based multi-way join problem over the converted vector space. We also propose several pruning strategies and a join order selection method to process join processing efficiently. Extensive experiments on both real and synthetic datasets show that our method outperforms existing ones by orders of magnitude. 1...|$|R
25|$|These are, if necessary, {{converted}} {{to the middle}} end's input representation, called GENERIC form; the middle end then gradually transforms the program towards its final form. Compiler optimizations and static code analysis techniques (such as FORTIFY_SOURCE, a compiler directive that attempts to discover some buffer overflows) are applied to the code. These work on multiple representations, mostly the architecture-independent GIMPLE representation and the architecture-dependent RTL representation. Finally, machine code is produced using architecture-specific <b>pattern</b> <b>matching</b> originally based on an algorithm of Jack Davidson and Chris Fraser.|$|E
25|$|The {{simplest}} AI applications can {{be divided}} into two types: classifiers ("if shiny then diamond") and controllers ("if shiny then pick up"). Controllers do, however, also classify conditions before inferring actions, and therefore classification forms a central part of many AI systems. Classifiers are functions that use <b>pattern</b> <b>matching</b> to determine a closest match. They can be tuned according to examples, making them very attractive for use in AI. These examples are known as observations or patterns. In supervised learning, each pattern belongs to a certain predefined class. A class {{can be seen as a}} decision that has to be made. All the observations combined with their class labels are known as a data set. When a new observation is received, that observation is classified based on previous experience.|$|E
25|$|In Western music, dissonance is {{the quality}} of sounds that seems {{unstable}} and has an aural need to resolve to a stable consonance. Both consonance and dissonance are words applied to harmony, chords, and intervals and, by extension, to melody, tonality, and even rhythm and metre. Although there are physical and neurological facts important to understanding the idea of dissonance, the precise definition of dissonance is culturally conditioned—definitions of and conventions of usage related to dissonance vary greatly among different musical styles, traditions, and cultures. Nevertheless, the basic ideas of dissonance, consonance, and resolution exist in some form in all musical traditions that have a concept of melody, harmony, or tonality. Dissonance being the complement of consonance it may be defined, as above, as non-coincidence of partials, lack of fusion or <b>pattern</b> <b>matching,</b> or as complexity.|$|E
40|$|We present ViteX, an XPath {{processing}} system on XML streams with polynomial time complexity. ViteX uses a polynomial-space data structure to encode an exponential number of <b>pattern</b> <b>matches</b> (in the query size) which {{are required to}} process queries correctly during a single sequential scan of XML. Then ViteX computes query solutions by probing the data structure in a lazy fashion without enumerating <b>pattern</b> <b>matches.</b> ...|$|R
5000|$|The tilde {{is used in}} the AWK {{programming}} language as part of the <b>pattern</b> <b>match</b> operators for regular expressions: ...|$|R
5000|$|... 3. Automatically queues analysts {{based on}} partial <b>pattern</b> <b>matches</b> and has <b>patterns</b> that cover 90% of all {{previously}} known foreign terrorist attacks ...|$|R
25|$|One {{class of}} problem that {{can benefit from}} the fully quantum {{approach}} is that of 'learning' unknown quantum states, processes or measurements, {{in the sense that}} one can subsequently reproduce them on another quantum system. For example, one may wish to learn a measurement that discriminates between two coherent states, given not a classical description of the states to be discriminated, but instead a set of example quantum systems prepared in these states. The naive approach would be to first extract a classical description of the states and then implement an ideal discriminating measurement based on this information. This would only require classical learning. However, one can show that a fully quantum approach is strictly superior in this case. (This also relates to work on quantum <b>pattern</b> <b>matching.)</b> The problem of learning unitary transformations can be approached in a similar way.|$|E
500|$|The initial {{development}} of this technique occurred in 1969 by Vernon Dvorak, using satellite pictures of tropical cyclones within the northwest Pacific Ocean. [...] The system as it was initially conceived involved <b>pattern</b> <b>matching</b> of cloud features with a development and decay model. [...] As the technique matured through the 1970s and 1980s, measurement of cloud features became dominant in defining tropical cyclone intensity and central pressure of the tropical cyclone's low-pressure area. [...] Use of infrared satellite imagery led to a more objective assessment {{of the strength of}} tropical cyclones with eyes, using the cloud top temperatures within the eyewall and contrasting them with the warm temperatures within the eye itself. [...] Constraints on short term intensity change are used less frequently than they were back in the 1970s and 1980s. [...] The central pressures assigned to tropical cyclones have required modification, as the original estimates were 5–10hPa (0.15–0.29inHg) too low in the Atlantic and up to 20hPa (0.59inHg) too high in the northwest Pacific. [...] This led to the {{development of}} a separate wind-pressure relationship for the northwest Pacific, devised by Atkinson and Holliday in 1975, then modified in 1977.|$|E
2500|$|... array {{and object}} destructuring (limited form of <b>pattern</b> <b>matching)</b> ...|$|E
5000|$|Recognition of Pattern Identified Entities: Features such as {{telephone}} numbers, e-mail addresses, quantities (with units) can {{be discerned}} via regular expression or other <b>pattern</b> <b>matches.</b>|$|R
5000|$|In Haskell, the tilde {{is used in}} type {{constraints}} {{to indicate}} type equality. [...] Also, in pattern-matching, the tilde is used to indicate a lazy <b>pattern</b> <b>match.</b>|$|R
50|$|A visual {{search engine}} {{searches}} images, patterns {{based on an}} algorithm which it could recognize and gives relative information based on the selective or apply <b>pattern</b> <b>match</b> technique.|$|R
2500|$|The {{problem of}} {{coloring}} a graph arises in many practical {{areas such as}} <b>pattern</b> <b>matching,</b> sports scheduling, designing seating plans, exam timetabling, the scheduling of [...] taxis, and solving Sudoku puzzles.|$|E
2500|$|The heavy {{demands on}} limited working memory restricting SA for novices {{and for those}} in novel situations, but the {{tremendous}} advantages of mental models and <b>pattern</b> <b>matching</b> to prototypical schema that largely circumvent these limits, ...|$|E
2500|$|Prolog {{has been}} used in Watson. Watson uses IBM's DeepQA {{software}} and the Apache UIMA (Unstructured Information Management Architecture) framework. The system was written in various languages, including Java, C++, and Prolog, and runs on the SUSE Linux Enterprise Server 11 operating system using Apache Hadoop framework to provide distributed computing. Prolog is used for <b>pattern</b> <b>matching</b> over natural language parse trees. The developers have stated: [...] "We required a language in which we could conveniently express <b>pattern</b> <b>matching</b> rules over the parse trees and other annotations (such as named entity recognition results), and a technology that could execute these rules very efficiently. We found that Prolog was the ideal choice for the language due to its simplicity and expressiveness." ...|$|E
40|$|Streaming XPath {{evaluation}} algorithms must {{record a}} potentially exponential number of <b>pattern</b> <b>matches</b> when both predicates and descendant axes {{are present in}} queries, and the XML data is recursive. In this paper, we use a compact data structure to encode these <b>pattern</b> <b>matches</b> rather than storing them explicitly. We then propose a polynomial time streaming algorithm to evaluate XPath queries by probing the data structure in a lazy fashion. Extensive experiments show that our approach not only has a good theoretical complexity bound but is also efficient in practice. ...|$|R
5000|$|This example {{illustrates}} {{one of the}} arguably {{less desirable}} quirks of QUEL, namely that all string comparisons are potentially <b>pattern</b> <b>matches.</b> [...] matches all y.str values starting with ii.|$|R
5000|$|<b>Pattern</b> <b>match</b> - in {{this case}} the tools is given a set of lexical {{patterns}} that it can match. For example, the tools may search for [...] "*gender*" [...] or [...] "*sex*" ...|$|R
2500|$|NFAs were {{introduced}} in 1959 by Michael O. Rabin and Dana Scott, [...] who also showed their equivalence to DFAs. NFAs {{are used in the}} implementation of regular expressions: Thompson's construction is an algorithm for compiling a regular expression to an NFA that can efficiently perform <b>pattern</b> <b>matching</b> on strings.|$|E
2500|$|For the {{customary}} bridal themes of [...] "Something old, something new, something borrowed, something blue", Middleton's gown had lace appointments (the [...] "old"), diamond earrings given {{by her parents}} (the [...] "new"), the Queen's tiara (the [...] "borrowed"), and a blue ribbon sewn into the bodice (the [...] "blue"). The shoes were also from Alexander McQueen and had a lace <b>pattern</b> <b>matching</b> the dress with appliques made by the Royal School of Needlework.|$|E
2500|$|Via C++'s influence, {{catch is}} the keyword {{reserved}} for declaring a pattern-matching exception handler in other languages popular today, like Java or C#. Some other languages like Ada use the keyword exception to introduce an exception handler and then may even employ a different keyword (when in Ada) for the <b>pattern</b> <b>matching.</b> A few languages like AppleScript incorporate placeholders in the exception handler syntax to automatically extract several {{pieces of information}} when the exception occurs. This approach is exemplified below by the on error construct from AppleScript: ...|$|E
40|$|AbstractGenerating {{functions}} which count {{occurrences of}} consecutive sequences in a permutation or a word which <b>matches</b> a given <b>pattern</b> are studied by exploiting the combinatorics associated with symmetric functions. Our theorems take the generating function {{for the number}} of permutations which do not contain a certain pattern and give generating functions refining permutations by the both the total number of <b>pattern</b> <b>matches</b> and the number of non-overlapping <b>pattern</b> <b>matches.</b> Our methods allow us to give new proofs of several previously recorded results on this topic as well as to prove new extensions and new q-analogues of such results...|$|R
50|$|The {{underscore}} is {{a special}} SQL <b>pattern</b> <b>match</b> to a single character and should be escaped {{if you are in}} fact looking for an underscore character in the LIKE clause of a query.|$|R
50|$|The Nashville Predators add a {{slightly}} tapered gold stripe to the pants and they reverse the color pattern on their road socks. Previously, the color <b>pattern</b> <b>matched</b> {{that of the}} ends of the sleeves.|$|R
