82|128|Public
50|$|The {{developer}} {{creates a}} <b>pull</b> <b>request</b> to notify maintainers {{of a new}} change; a comment thread is associated with each <b>pull</b> <b>request.</b> This allows for focused discussion of code changes. Submitted pull requests are visible to anyone with repository access. A <b>pull</b> <b>request</b> can be accepted or rejected by maintainers.|$|E
50|$|It {{will also}} {{automatically}} schedule builds for GitHub pull requests, {{and leave a}} pass/fail comment on the <b>pull</b> <b>request,</b> so that project owners can know whether pull requests pass all the tests before merging them, and contributors {{do not have to}} wait for all tests to run on their own machine before submitting a <b>pull</b> <b>request.</b>|$|E
5000|$|Contributions to {{a source}} code {{repository}} that uses a distributed version control system are commonly made {{by means of a}} <b>pull</b> <b>request.</b> The contributor requests that the project maintainer [...] "pull" [...] the source code change, hence the name [...] "pull request". The maintainer has to merge the <b>pull</b> <b>request</b> if the contribution should become part of the source base.|$|E
30|$|From the figures, it {{is first}} {{possible}} {{to see that the}} maintainers do a great job in processing <b>pull</b> <b>requests,</b> given the small number of <b>pull</b> <b>requests</b> kept open. Projects electron, git-lfs, and hubot present low rates of open <b>pull</b> <b>requests,</b> 0.88, 0.13, and 0.08 %(!), respectively. For the latter, at the time of data collection, only 3 <b>pull</b> <b>requests</b> were left open.|$|R
30|$|Additionally, we also {{investigated}} {{the proportion of}} <b>pull</b> <b>requests</b> submitted by internals that are also processed by internals (and vice-versa). We observed that 86.4 % of the <b>pull</b> <b>requests</b> submitted by internals are also processed by internals. In comparison, 55.4 % of the <b>pull</b> <b>requests</b> submitted by externals are also processed by externals.|$|R
30|$|As aforementioned, {{we focus}} on {{understanding}} how <b>pull</b> <b>requests</b> of internal and external are received. We analyzed the reception in terms of acceptance rate and time to process the <b>pull</b> <b>requests</b> from internal and external members.|$|R
50|$|Once the <b>pull</b> <b>request</b> is {{reviewed}} and approved, it is merged into the repository. Depending on the established workflow, the code {{may need to}} be tested before being included into official release. Therefore, some projects contain a special branch for merging untested pull requests. Other projects run an automated test suite on every <b>pull</b> <b>request,</b> and the reviewer checks that any new code has appropriate test coverage.|$|E
50|$|On September 14, 2016, Greg K-H {{submitted}} a <b>pull</b> <b>request</b> for Greybus for inclusion into Linux 4.9. The code to be merged is viewable in cgit: http://git.kernel.org/cgit/linux/kernel/git/gregkh/char-misc.git/log/?h=greybus.|$|E
50|$|On 16 October 2013, Pablo Neira Ayuso {{submitted}} a nftables core <b>pull</b> <b>request</b> to the Linux kernel mainline tree. It was merged into the kernel mainline on 19 January 2014, {{with the release}} of Linux kernel version 3.13.|$|E
5000|$|JavaForge (with <b>pull</b> <b>requests</b> {{to control}} source code contribution) ...|$|R
50|$|Immediate {{feedback}} on <b>Pull</b> <b>Requests.</b> SideCI automatically and immediately scans your PRs for issues of style, complexity, duplication, security. On using GitHub <b>Pull</b> <b>Requests,</b> SideCI will point out any issues {{so that you}} can discuss and fix them before merging. Moreover, {{you do not have to}} change the flow of existing code review.|$|R
30|$|Approach: To {{answer this}} RQ, we quantitatively {{compared}} {{the number of}} internal and external contributors, {{as well as the}} number of <b>pull</b> <b>requests</b> submitted by them. In addition to characterizing and discussing the values using descriptive statistics, we compared the evolution of the number of <b>pull</b> <b>requests</b> submitted monthly by external and internal members, in a per project basis. It is important to mention that we computed the number of <b>pull</b> <b>requests</b> submitted per state (open, closed, merged). Since we compared the number of <b>pull</b> <b>requests</b> per month by two different samples, we applied the Wilcoxon signed-rank test for paired samples [6] to perform this comparison. We used Cliff’s delta to verify how often values in one distribution are larger than values in another distribution. The thresholds are defined as follows: delta< 0.147 (negligible), delta< 0.33 (small), delta< 0.474 (medium), and delta>= 0.474 (large) [7].|$|R
50|$|The ZeroMQ {{community}} mostly {{uses the}} Collective Code Construction Contract (C4) as a development contract. C4 {{is inspired by}} Wikipedia processes and GitHub's fork + <b>pull</b> <b>request</b> model. It focuses on making it simpler for new contributors to participate and reducing dependency on older contributors.|$|E
50|$|SideCI is an {{automated}} code review tool with GitHub. It {{is based on}} static code analysis and integrates {{with a number of}} open source static analysis tools. It checks style violations, code quality, security and dependencies and provides results as a comment on GitHub <b>pull</b> <b>request.</b>|$|E
50|$|Documentation {{about the}} GCN-hardware is {{available}} from AMD without the requirement to sign some NDA, with development mainly driven by AMD employees.The entire development should flow together into Alex Deucher's git-tree: http://cgit.freedesktop.org/~agd5f/linux/log/?h=amdgpuDavid Airlie is the overall maintainer for the entire DRM-tree. He sends his <b>pull</b> <b>request</b> directly to Torvalds.|$|E
30|$|As {{we can see}} in the figure, for all studied projects, on average, <b>pull</b> <b>requests</b> {{submitted}} by internals are process faster than the ones {{submitted by}} externals; a small effect size confirmed this trend (p value = 0.001, delta = 0.243). In particular, projects hubot and linguist are the ones that take more time to process <b>pull</b> <b>requests,</b> either from internals (333 and 426 days for hubot and linguist, respectively) or externals (1144 and 832 days for hubot and linguist, respectively). To better understand why these <b>pull</b> <b>requests</b> made by externals are taking too much time to be processed, we investigated the ones that lasted the most.|$|R
30|$|Regarding the {{acceptance}} rate, when studying the merged <b>pull</b> <b>requests</b> (the accepted ones) in RQ 1, {{we can see}} that both groups are also fairly active in all the five projects analyzed. We can observe, though, different patterns depending on the project. For example, for linguist, {{we can see that}} the number of <b>pull</b> <b>requests</b> from externals outperforms those from employees by far, and for every month. However, analyzing the closed but unmerged <b>pull</b> <b>requests</b> (the ones that were not accepted), we could notice that many external developers {{are having a hard time}} attempting to get their contributions accepted. This is noticeable in the second column of graphics in Fig.  2. In Table  2, we could confirm that most of the unmerged (closed) <b>pull</b> <b>requests</b> were done by external developers for 4 out of 5 projects (p value ≤[*] 0.001), with a medium or large (negative) effect size. A possible explanation is that employees work on critical and follow project directions (defined inside the company), while external submissions are, sometimes, motivated by specific needs, not necessarily aligned with the project’s direction.|$|R
50|$|In {{both cases}} - Android and iOS - <b>pull</b> <b>requests</b> from outside {{contributors}} may be accepted under MIT license.|$|R
5000|$|When Travis CI {{has been}} {{activated}} {{for a given}} repository, GitHub will notify it whenever new commits are pushed to that repository or a <b>pull</b> <b>request</b> is submitted. It can also be configured to only run for specific branches, or branches whose names match a specific pattern. Travis CI will then check out the relevant branch and run the commands specified in [...]travis.yml, which usually build the software and run any automated tests. When that process has completed, Travis notifies the developer(s) {{in the way it}} has been configured to do so—for example, by sending an email containing the test results (showing success or failure), or by posting a message on an IRC channel. In the case of pull requests, the <b>pull</b> <b>request</b> will be annotated with the outcome and a link to the build log, using a GitHub integration.|$|E
50|$|Fork {{and pull}} model {{refers to a}} {{software}} development model mostly used on GitHub, where multiple developers working on an open shared project make their own contributions by sharing a main repository and pushing changes after granted <b>pull</b> <b>request</b> by integrator users. Followed {{by the appearance of}} distributed version control systems (DVCS), Git naturally enables the usage of a pull-based development model, in which developers can copy the project onto their own repository, and push their changes to the original repository, where the integrators will determine the validity of the <b>pull</b> <b>request.</b> Ever since its appearance, pull-based development received large popularity within the open software development community. On GitHub, about more than 400000 pull-requests emerged per month on average in 2015. It is also model shared on most collaborative coding platforms, like BitBucket, Gitorious etc. More and more functionalities are added to facilitate pull-based model.|$|E
50|$|There {{are many}} other ways of {{deploying}} applications too. For example, developers can enable GitHub integration so that each new <b>pull</b> <b>request</b> is associated with its own new application, which enables all sorts of continuous integration scenarios. Dropbox Sync lets developers deploy the contents of Dropbox folders to Heroku, or the Heroku API {{can be used to}} build and release apps.|$|E
30|$|In this paper, we {{analyzed}} the contribution behavior of {{internal and external}} developers of five well-known company-owned open-source projects: atom, electron, git-lfs, linguist, and hubot projects. We found that these projects are very receptive for external developers: many externals play {{important role in the}} studied projects, such as reviewing and integrating <b>pull</b> <b>requests.</b> Considering all the projects, internal developers are responsible for 43.3 % of the <b>pull</b> <b>requests</b> performed (external developers placed 56.7 %). Analyzing just hubot project, we observed that only 18 % of the <b>pull</b> <b>requests</b> had been placed by internal developers. However, the absolute number of external members is many more times greater than internal ones. As a consequence, many externals are casual contributors (i.e., developers that only contributed once (although we also identified internals that are also casual contributors).|$|R
30|$|The {{number of}} unique integrators for both kind of {{contributors}} is roughly similar in {{four out of}} the five analyzed project (e.g., the linguist project has 15 internal integrators and 17 external). The only exception to this trend is the project hubot, in which 11 (78 %) of the integrators are external developers (which corroborates {{with the findings of}} the “RQ 1.1. Are internals the top contributors of company-owned OSS projects?” section, that indicates a large proportion of internals are casual contributors for this particular project). Regarding the amount of work devoted to each kind of contributor (either internal or external), we observed that internal integrators processed more <b>pull</b> <b>requests</b> on projects atom, hubot, and electron. In particular, internal integrators of project electron processed 28 × more <b>pull</b> <b>requests</b> than their counterparts. Moreover, although the project hubot has more unique external integrators (11 externals and 3 internals), internal integrators are responsible for managing the majority of the <b>pull</b> <b>requests</b> (internals integrators processed 3 × more than external ones). On the other hand, on projects linguist and git-lfs, external integrators processed more <b>pull</b> <b>requests</b> than internals (3.26 × and 1.82 ×, respectively).|$|R
30|$|In this RQ, we are {{interested}} in exploring how internal and external members participate in the process by both commenting/discussing <b>pull</b> <b>requests</b> and acting as integrators.|$|R
50|$|The Payara Server {{project is}} hosted on GitHub, {{allowing}} the community access to view and edit the source code. Payara encourages {{the community to}} contribute through raising bugs, suggesting new features and enhancements on GitHub. Payara uses the Fork and Pull model. This means that if community members want to make any changes, they need to fork the Payara project and make their changes in their own repository. They will then {{need to create a}} <b>pull</b> <b>request</b> back into the Payara project's master branch to merge the changes into the main project. Payara Services Ltd commercial support subscriptions also fund development and engineering effort of the Payara Server open source project.|$|E
5000|$|Bountysource is {{a website}} for open source bounties and since 2012 also for crowdfunding. Users (called [...] "backers") can pledge money for tasks using {{micropayment}} services that {{open source software}} developers can pick up and solve to earn the money. It also allows large-scale fundraising for big improvements on the project. It integrates with GitHub using its bug tracker to check if the problem is resolved and connect the resolution with GitHub's <b>pull</b> <b>request</b> system to identify the patch. When the users agree that they are satisfied and the project maintainer merged the proposed changes to the source-code, Bountysource will transfer the money acting as a trustee during the whole process.|$|E
50|$|In October 2013, Chou {{attended}} the annual Grace Hopper Celebration of Women in Computing, where she became {{curious about the}} issue of female representation in technology companies, and decided to gather data to assess the severity of the issue. This led her to write a blog post urging technology companies to disclose the numbers of women they had in technical roles. To facilitate sharing of the responses she received, Chou set up a repository on code-sharing site GitHub which allows anyone to submit a <b>pull</b> <b>request.</b> Within a week, the repository had statistics on over 50 firms, and by January 2016, it had statistics on 250 firms. Chou's focus on the issue is also credited with pressuring larger companies such as Google, Facebook, and Microsoft to release diversity reports. In July 2014, Chou published an update on Pinterest's engineering blog describing the company's progress so far on diversity and inclusion.|$|E
50|$|<b>Pull</b> <b>requests</b> {{form the}} {{foundation}} of network computing, where many clients request data from centralised servers. Pull is used extensively on the Internet for HTTP page requests from websites.|$|R
50|$|However, Wladimir van der Laan, the Chief Maintainer of Bitcoin Core, {{is funded}} by MIT's Digital Currency Initiative and only merges <b>pull</b> <b>requests</b> to Bitcoin Core that have {{widespread}} technical consensus.|$|R
30|$|Rationale: In this {{research}} question, we focus our interest on understanding the how <b>pull</b> <b>requests</b> of {{internal and external}} are received. We focused on (i) acceptance and rejection rates and (ii) on the priority given to the <b>pull</b> <b>requests.</b> As the literature suggests, {{it is not always}} easy to contribute to open-source projects [8]. We, therefore, explore whether external developers are facing a harder time in terms of rejections and time to process when compared to their internal peers. If that is the case, answers to this question might help improve how company-owned OSS projects treat external developers.|$|R
50|$|The {{increasing}} {{popularity of}} open source DVCSs such as git, and then, later, DVCS hosting sites, {{the most popular}} of which is GitHub (founded 2008), incrementally reduced the barriers to participation in free software projects still further. With sites like GitHub, no longer did potential contributors have to do things like hunt for the URL for the source code repository (which could be in different places on each website, or sometimes tucked away in a README file or developer documentation), or work out how to generate a patch, and if necessary subscribe to the right mailing list so that their patch email would get to the right people. Contributors can simply fork their own copy of a repository with one click, and issue a <b>pull</b> <b>request</b> from the appropriate branch when their changes are ready. GitHub has become the most popular hosting site in the world for open source software, and this, together with the ease of forking and the visibility of forks has made it a popular way for contributors to make changes, large and small.|$|E
30|$|The <b>pull</b> <b>request</b> # 678 {{submitted}} to hubot project was aimed {{to improve the}} documentation (it adds 32 lines in a Markdown file); five commits {{had been made to}} this <b>pull</b> <b>request.</b> Although project maintainers needed some time to review the contribution (the final modification suggested was about 300 days after the <b>pull</b> <b>request</b> was created), it seems that the <b>pull</b> <b>request</b> was forgotten, and only 2 years after the last change was made, another project maintainer passed through the <b>pull</b> <b>request</b> and merged the patch. On the other hand, the <b>pull</b> <b>request</b> # 2070 {{submitted to}} the project linguist is a bit more complex. It was aimed to introduce PEP 8 support, which is the code convention for writing Python code. Similar to the previous <b>pull</b> <b>request,</b> in this one, the maintainers also seem to forgot to follow-up with the code review. The external member brought back the attention to this <b>pull</b> <b>request,</b> mentioning: “I’m recalling this <b>pull</b> <b>request</b> has been open for over a year now (wow, nearly two, time flies), is there anything I can do to help it being merged into master aside from fixing the conflicts that have arisen since its opening?”. Four months after this message, another maintainer provided additional comments, and 1 month after the <b>pull</b> <b>request</b> was merged.|$|E
30|$|To infer the IFT, we {{used the}} {{approach}} proposed by Murgia et al. (2014). We computed the time interval between the last time an issue had been merged {{and the last time}} it had been subscribed to by an assignee (issues and pull requests are dual on Github; for each opened <b>pull</b> <b>request,</b> an issue is opened automatically (Gousios 2013)). The closed issues are considered as such because they are merged <b>pull</b> <b>request.</b> Since each <b>pull</b> <b>request</b> is an issue, and we considered the merged ones (the branch of the <b>pull</b> <b>request</b> has been merged with the main branch, therefore issues are closed). In the case that we could not obtain such dates, we used a conservative approach (i.e., if the subscribed date was missing we used assigned data and so on).|$|E
3000|$|... the Queries API {{allows for}} {{location}} applications (web and rich clients) to: i) {{ask for a}} person or object location (<b>pull</b> <b>requests),</b> ii) manage access control location policies, and iii) manage notification policies; [...]...|$|R
30|$|As an {{open-source}} project, {{the participation}} of other interested programmers {{in the development of}} Starfish is also possible. The Git system allows programmers to send <b>pull</b> <b>requests,</b> which if proved beneficial, are applied to Starfish code.|$|R
40|$|Due to the {{difficulties}} in replicating and scaling up qualitative studies, such studies are rarely verified. Accordingly, in this paper, we leverage the advantages of crowdsourcing (low costs, fast speed, scalable workforce) to replicate and scale-up one state-of-the-art qualitative study. That qualitative study explored 20 GitHub <b>pull</b> <b>requests</b> to learn factors that influence the fate of <b>pull</b> <b>requests</b> with respect to approval and merging. As a secondary study, using crowdsourcing {{at a cost of}} $ 200, we studied 250 <b>pull</b> <b>requests</b> from 142 GitHub projects. The prior qualitative findings are mapped into questions for crowds workers. Their answers were converted into binary features to build a predictor which predicts whether code would be merged with median F 1 scores of 68 %. For the same large group of <b>pull</b> <b>requests,</b> the median F 1 scores could achieve 90 % by a predictor built with additional features defined by prior quantitative results. Based on this case study, we conclude that there is much benefit in combining different kinds of research methods. While qualitative insights are very useful for finding novel insights, they can be hard to scale or replicate. That said, they can guide and define the goals of scalable secondary studies that use (e. g.) crowdsourcing+data mining. On the other hand, while data mining methods are reproducible and scalable to large data sets, their results may be spectacularly wrong since they lack contextual information. That said, they can be used to test the stability and external validity, of the insights gained from a qualitative analysis. Comment: Submitted to FSE' 17, 12 page...|$|R
