291|584|Public
25|$|Failure: the {{inability}} of an operation to fulfill its contract. For example, an addition may produce an arithmetic overflow (it does not fulfill its contract of computing a good approximation to the mathematical sum); or a routine may fail to meet its <b>postcondition.</b>|$|E
2500|$|The {{bold print}} {{is not part}} of the input; it is {{included}} here to show which words are recognized as formal language. JBehave recognizes the terms Given (as a precondition which defines the start of a scenario), When (as an event trigger) and Then (as a <b>postcondition</b> which must be verified as the outcome of the action that follows the trigger). Based on this, JBehave is capable of reading the text file containing the scenario and parsing it into clauses (a set-up clause and then three event triggers with verifiable conditions). JBehave then takes these clauses and passes them on to code that is capable of setting a test, responding to the event triggers and verifying the outcome. This code must be written by the developers in the project team (in Java, because that is the platform JBehave is based on). In this case, the code might look like this: ...|$|E
5000|$|The {{following}} example {{written in}} Eiffel sets {{the value of}} a class attribute [...] based on a caller-provided argument [...] The <b>postcondition</b> follows the keyword [...] In this example, the <b>postcondition</b> guarantees, in cases in which the precondition holds (i.e., when [...] represents a valid hour of the day), that after the execution of , the class attribute [...] will have the same value as [...] The tag [...] "" [...] describes this <b>postcondition</b> clause and serves to identify it in case of a runtime <b>postcondition</b> violation.|$|E
40|$|We have {{augmented}} {{user interface}} objects (i. e. windows, menus, buttons, sliders, etc.) with preconditions that determine their visibility and their enabled/disabled status and <b>postconditions</b> that are asserted when certain actions are {{performed on the}} object. <b>Postconditions</b> are associated with each functionally different action on the object. Attaching pre- and <b>postconditions</b> to interface objects provides several useful features, such as selective enabling of controls, rapid prototyping, and automatic generation of explanations and help text...|$|R
50|$|<b>Postconditions</b> {{cannot be}} {{weakened}} in a subtype.|$|R
5000|$|... #Subtitle level 2: <b>Postconditions</b> in {{object-oriented}} programming ...|$|R
50|$|The <b>postcondition</b> for any {{routine is}} a {{declaration}} of the properties which are guaranteed {{upon completion of the}} routine's execution. As it relates to the routine's contract, the <b>postcondition</b> offers assurance to potential callers that in cases in which the routine is called in a state in which its precondition holds, the properties declared by the <b>postcondition</b> are assured.|$|E
5000|$|... ensures {{indicates}} a <b>postcondition</b> {{that must be}} followed in the code.|$|E
5000|$|... wait [...] : {{precondition}} [...] modifies {{the state}} of the monitor <b>postcondition</b> ...|$|E
5000|$|Structures for code {{contract}} like preconditions and <b>postconditions.</b>|$|R
5000|$|Compile-time {{enforcement}} of assertions, preconditions, <b>postconditions,</b> and class invariants.|$|R
5000|$|... <b>postconditions</b> (what is {{established}} after {{the action is}} performed).|$|R
5000|$|... and, {{that the}} final state of all {{terminating}} execution satisfies the <b>postcondition.</b>|$|E
50|$|The {{conditional}} rule {{states that}} a <b>postcondition</b> Q common to then and else part {{is also a}} <b>postcondition</b> of the whole if...endif statement.In the then and the else part, the unnegated and negated condition B {{can be added to}} the precondition P, respectively.The condition, B, must not have side effects.An example is given in the next section.|$|E
5000|$|... wait : {{precondition}} [...] modifies {{the state}} of the monitor <b>postcondition</b> [...] and ...|$|E
40|$|We have {{augmented}} {{user interface}} objects (i. e. windows, menus, buttons, sliders, etc.) with preconditions that determine their visibility and their enabled/disabled status and <b>postconditions</b> that are asserted when certain actions are {{performed on the}} object. <b>Postconditions</b> are associated with each functionally different action on the object. Attaching pre- and <b>postconditions</b> to interface objects provides several useful features, such as selective enabling of controls, rapid prototyping, and automatic generation of explanations and help text. Introduction Several techniques {{can be used to}} describe the dialogue of an application. Some of the best known techniques are transition diagrams, grammars and event languages. As discussed by Green [GREE 86], the event model has a greater descriptive power than the former two. A particularly useful form of the event model is to associate pre- and <b>postconditions</b> with dialogue components (actions and/or interface objects). The preconditions of a dia [...] ...|$|R
30|$|The service {{composition}} module implements a breadth-first forward search algorithm [20]. It considers only formal specifications {{in terms}} of pre- and <b>postconditions</b> (effects). It does not only consider goals that exactly satisfy a user’s <b>postconditions,</b> but also goals {{that are likely to}} be the actual goal of a user, by accepting states as goal states, that are supersets of the specified <b>postconditions.</b> In contrast to the recommendation module, the composition module is memoryless. Each composition process starts from scratch without relying on knowledge from previous composition processes. In order to identify the most up to date actions (services) during the search process, the composition module interacts with the service discovery.|$|R
25|$|<b>Post{{conditions}}</b> are {{conditions that}} are ensured to be correct when a method has been executed.|$|R
50|$|The {{precondition}} and <b>postcondition</b> together form {{a contract}} that to be satisfied by any program claiming to implement the function. The precondition records the assumptions under which the function guarantees to return a result satisfying the <b>postcondition.</b> If a function is called on inputs that do not satisfy its precondition, the outcome is undefined (indeed, termination is not even guaranteed).|$|E
5000|$|... : Defines a <b>postcondition</b> {{for when}} a given Exception is thrown by the method that follows.|$|E
5000|$|Finally, the [...] clause is a <b>postcondition,</b> which {{specifies}} {{that the}} value [...] is incremented by one.|$|E
40|$|The Object Constraint Language OCL {{is part of}} the Unified Modeling Language UML. OCL allows to {{describe}} system structure by invariants and system behavior by pre- and <b>postconditions.</b> This paper explains the functionality of the UML Specification Environment USE which allows to validate and verify aspects of formal OCL specifications. The paper also uses a new approach to handle UML statecharts by OCL pre- and <b>postconditions...</b>|$|R
40|$|The cost of {{developing}} and maintaining high quality software remains at a premium. In this paper we introduce a practical approach for enhancement of software quality, based on calculation of strongest <b>postconditions</b> of program components. The method provides a powerful means for detecting and removing by transformation {{various forms of}} redundancy and inconsistency in programs. The feasibility of this approach depends upon calculations of strongest <b>postconditions</b> for iterative constructs and assignments...|$|R
40|$|Abstract: Efficient model {{validation}} and verification techniques are {{strong in the}} anal-ysis of systems describing static structures, for example, UML class diagrams and OCL invariants. However, general UML and OCL models can involve dynamic as-pects in form of OCL pre- and <b>postconditions</b> for operations. This paper describes the automatic transformation of a UML and OCL model with invariants and pre- and post-conditions into an equivalent model with only invariants. We call the first model (with pre- and <b>postconditions)</b> the application model and the second model (with invariants only) the filmstrip model, because a sequence of system states in the application model becomes a single system state in the filmstrip model. This single system state {{can be thought of}} as being a filmstrip presenting snapshots from the application model with different logical time stamps. Pre- and <b>postconditions</b> from the application model be-come invariants in the filmstrip model. Providing a proper context, the text of the pre-and <b>postconditions</b> can be used in the filmstrip model nearly unchanged. The filmstrip model can be employed for automatically constructing dynamic test scenarios and for checking temporal properties. ...|$|R
5000|$|Debugging {{facilities}} such as safe iterators, precondition and <b>postcondition</b> checking, and {{the ability}} to generate stack traces ...|$|E
5000|$|While a given <b>postcondition</b> P uniquely {{determines the}} {{precondition}} PE/x, the converse is not true. For example: ...|$|E
5000|$|... {{which is}} easily {{obtained}} by the assignment rule.Finally, the <b>postcondition</b> {¬x<10 ∧ x≤10} can be simplified to {x=10}.|$|E
40|$|Abstract — Behavior state {{machines}} {{are commonly used}} as executives for a robot operating in a human environment since it provides overall robust behavior controls with failure recovery features as well as easy extendibility and reuseability of devel-oped module in future applications. In this paper, we describe new framework called “Task Compiler ” that automatically generates state-machine based behavior executives from a high-level symbolic description of robotic task to constructs such complex robotics application. We introduce new <b>postconditions</b> that is established after the action is fall into failure and propose an algorithm to generate state machine description considering both nominal operation <b>postconditions</b> and failure operation <b>postconditions.</b> Finally, a real world robotic application of a humanoid robot is presented {{as an example of}} the proposed system. I...|$|R
50|$|In some {{software}} design approaches, <b>postconditions,</b> along with preconditions and class invariants, are {{components of the}} software construction method design by contract.|$|R
50|$|In the {{presence}} of inheritance, the routines inherited by descendant classes (subclasses) do so with their contracts, that is their preconditions and <b>postconditions,</b> in force. This means that any implementations or redefinitions of inherited routines {{also have to be}} written to comply with their inherited contracts. <b>Postconditions</b> can be modified in redefined routines, but they may only be strengthened. That is, the redefined routine may increase the benefits it provides to the client, but may not decrease those benefits.|$|R
5000|$|... signal [...] {{precondition}} (not empty (...) and [...] ) or (empty (...) and [...] ) modifies {{the state}} of the monitor <b>postcondition</b> ...|$|E
50|$|All {{preconditions}} {{that are}} not modified by the expression can be carried over to the <b>postcondition.</b> In the first example, assigning y:=x+1 {{does not change the}} fact that x+1=43, so both statements may appear in the <b>postcondition.</b> Formally, this result is obtained by applying the axiom schema with P being (y=43 and x+1=43), which yields P(x+1)/y being (x+1=43 and x+1=43), which can in turn be simplified to the given precondition x+1=43.|$|E
5000|$|Routine postcondition: The <b>postcondition</b> {{can only}} be {{strengthened}} by inheritance; any result guaranteed by the ancestor is still provided by the descendant.|$|E
5000|$|If {{the formal}} {{specification}} {{is in an}} axiomatic semantics, the preconditions and <b>postconditions</b> of the specification may become assertions in the executable code.|$|R
5000|$|Conditions - precondition(s) {{that must}} be true for a scene (event) to be executable, and <b>postcondition(s)</b> (effects) {{that must be}} true after a scene ...|$|R
40|$|We {{introduce}} {{the notions of}} nested constraints and application conditions, short nested conditions. For a category associated with a graphical representation such as graphs, conditions are a graphical and intuitive, yet precise formalism, well-suited to describe structural properties. We show that nested graph conditions are expressively equivalent to first-order graph formulas. A part of the proof includes transformations between two satisfiability notions of conditions, namely M-satisfiability and A-satisfiability. We consider a number of transformations on conditions that can be composed to construct constraint-guaranteeing and constraint-preserving application conditions, weakest preconditions, and strongest <b>postconditions.</b> The restriction of rule applications by conditions {{can be used to}} correct transformation systems by pruning transitions leading to states violating given constraints. Weakest preconditions and strongest <b>postconditions</b> can be used to verify the correctness of transformation systems with respect to pre- and <b>postconditions...</b>|$|R
