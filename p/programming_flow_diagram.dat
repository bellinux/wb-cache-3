0|3683|Public
5000|$|VisSim viewer - {{graphically}} <b>programmed</b> data <b>flow</b> <b>diagrams</b> for {{simulation of}} dynamical systems ...|$|R
40|$|A {{formulation}} {{is given}} for calculating flutter frequency and flutter speed for {{a problem with}} two degrees of freedom. Two different solutions for evaluating the flutter determinant are presented and the results for each method are compared. A <b>program</b> <b>flow</b> <b>diagram,</b> partial <b>program</b> listing, and a sample problem with input and output for the two different methods are included. Although the method was developed for computing flutter characteristics of a pylon installed in the NASA Langley VSTOL tunnel, it is sufficiently general to solve any flutter system that can be characterized by two degrees of freedom...|$|R
40|$|The ROBOT {{display and}} control program (ROBDAC) to be written for the Adage 340 {{computer}} is designed {{to communicate with the}} Univac 1110 computer with the aid of the graphic support communications programs. ROBDAC and the Adage computer act as an input/output device for the program ROBOT, which is run on the Univac 1110. ROBDAC controls the input to ROBOT by displaying images of the inputs, providing an editing technique for these inputs, shipping the input data to the Univac, and then commanding ROBOT to start execution. The output is done in a similar manner after receiving the output data from the Univac. This data will be displayed numerically as well as by plotted graphs. All of the input/output will be done interactively with practically 'finger tip' control. A general <b>program</b> <b>flow</b> <b>diagram</b> of ROBDAC is included...|$|R
40|$|This report {{presents}} {{a description of}} a computer program mechanized to perform the Paull and Unger process of simplifying incompletely specified sequential machines. An understanding of the process, as given in Ref. 3, is a prerequisite {{to the use of the}} techniques presented in this report. This process has specific application in the design of asynchronous digital machines and was used in the design of operational support equipment for the Mariner 1966 central computer and sequencer. A typical sequential machine design problem is presented to show where the Paull and Unger process has application. A description of the Paull and Unger process together with a description of the computer algorithms used to develop the program mechanization are presented. Several examples are used to clarify the Paull and Unger process and the computer algorithms. <b>Program</b> <b>flow</b> <b>diagrams,</b> <b>program</b> listings, and a program user operating procedures are included as appendixes...|$|R
40|$|In {{this paper}} we present the {{language}} G-KARL. G-KARL allows {{to describe the}} static, the functional and the dynamic view to a knowledge based system (kbs) graphically. This graphical representation makes the communication between the expert and the knowledge engineer easier. The underlying conceptual model for G-KARL {{is derived from the}} KADS model of expertise. Every primitive of G-KARL may be mapped to a language primitive of the language KARL (Knowledge Acquisition and Representation Language). KARL is a formal language, so every primitive of G-KARL has a defined formal semantics. KARL is an executable language, so G-KARL is also executable which supports the validation of the model of expertise by testing and thus allows the model of expertise to be built by prototyping. G-KARL allows to visualize the execution of this model which additionally supports the validation process. While G-KARL contains well established graphical means for the different views like the OMT-notation for the static view, data <b>flow</b> <b>diagrams</b> for the functional view and <b>program</b> <b>flow</b> <b>diagrams</b> for the dynamic view, G-KARL also offers new graphical primitives for specifying elementary inference actions within data <b>flow</b> <b>diagrams</b> and for specifying sufficient and necessary conditions within the static view. In KARL these model elements are described by L-KARL, a logical language enriched by additional modeling primitives...|$|R
40|$|The APAS {{program a}} {{multistation}} structural synthesis procedure developed to evaluate material, geometry, and configuration with various design criteria usually {{considered for the}} primary structure of transport aircraft is described and evaluated. Recommendations to improve accuracy and extend {{the capabilities of the}} APAS <b>program</b> are given. <b>Flow</b> <b>diagrams</b> are included...|$|R
40|$|This paper {{describes}} {{the integration of}} an information visualization tool, called SHriMP Views, with IBM WebSphere Studio Application Developer Integration Edition, which was developed with Eclipse technology. Although SHriMP was originally developed for visualizing programs, it is content-independent. We have re-targeted SHriMP for visualizing <b>flow</b> <b>diagrams.</b> <b>Flow</b> <b>diagrams,</b> as supported by WebSphere Studio Application Developer Integration Edition, can be hierarchically composed, thus leveraging the key features of SHriMP that allow a user to easily navigate hierarchically composed information spaces. We discuss the di#erences between <b>programs</b> and <b>flow</b> <b>diagrams,</b> {{in terms of their}} semantics and their visual representation. We also report on the main technical challenges we faced, due to the di#erent widget sets used by SHriMP (Swing/awt) and Eclipse (swt) ...|$|R
5000|$|A data <b>flow</b> <b>diagram</b> (DFD) is a {{graphical}} {{representation of the}} [...] "flow" [...] of data through an information system. It differs from the flowchart as it shows the data flow instead of the control <b>flow</b> of the <b>program.</b> A data <b>flow</b> <b>diagram</b> {{can also be used}} for the visualization of data processing (structured design). Data <b>flow</b> <b>diagrams</b> were invented by Larry Constantine, the original developer of structured design, based on Martin and Estrin's [...] "data flow graph" [...] model of computation.|$|R
40|$|This paper {{provides}} an experience report for researchers {{who are interested}} in integrating their tools with the new IBM WebSphere Studio Workbench. The Workbench (open source at www. eclipse. org) {{provides an}} open framework for building integrated development environments. We report on our experience integrating an information visualization tool (called SHriMP Views) with the IBM Workbench. Although SHriMP was originally developed for visualizing programs, it is content independent. We have re-targeted SHriMP for visualizing <b>flow</b> <b>diagrams.</b> <b>Flow</b> <b>diagrams</b> can be hierarchically composed, thus leveraging the key features of SHriMP that allow a user to easily navigate hierarchically composed information spaces. We discuss the di#erences between <b>programs</b> and <b>flow</b> <b>diagrams</b> both in terms of their semantics and in their visual representation. Terminals, which are a first-class entity that mediate between nodes and arcs in <b>flow</b> <b>diagrams,</b> presented the main challenges here. We also report on the main technical challenges we faced, due to the di#erent widgets sets used by SHriMP (Swing/awt) and the Workbench (swt) ...|$|R
40|$|Available {{statistical}} data {{shows that the}} cost of repairing software faults rises dramatically in later development stages. It is important to reduce software faults {{in the early stages of}} software development, such as requirement and design specification. In particular, the new technology of generating implementation code from specification requires highly reliable design specifications. Much research has been done on verification and validation, such as model checking [11. We believe such approaches are similar to software testing. We apply our state-of-the-art technology in software coverage testing, program diagnosis and understanding to stages as early as software requirements and designs. Early analysis provides many benefits, including 1) early detection and recovery of software faults, 2) visualization and simulation of the software specifications, 3) improvement of the confidence on the specification, 4) making programming on the specification level more possible, and 5) reduction of the number of introduced faults. This paper presents the technology and the accompanying tool suite to the diagnosis and understanding of software specifications. We use the simulation of the specifications to collect the execution trace for computing the coverage and slicing data. Our technology is based on both the control flow and the data flow of the executable specifications. It first generates a <b>program</b> <b>flow</b> <b>diagram</b> from the specification and then automatically analyses the coverage features of the diagram. It collects the corresponding flow data during the simulation time to be mapped to the <b>flow</b> <b>diagram.</b> The coverage information for the original specification is then obtained from the coverage information of the flo...|$|R
40|$|This {{bachelor}} thesis introduces microcontroller MC 9 S 08 LH 64 and its modules such as analog {{to digital}} converter, internal clock source, {{liquid crystal display}} driver, serial communication interface and time of day module. It also containes some basic information about peripheries, which are on the development board TWR-S 08 LH 64 together with the microcontroller. The peripheries are LCD display GD- 5306 P and accelerometer MMA 7361 L. Thesis continues with elaboration of five laboratory exercises in which microcontroller, LCD display, accelerometer and A/D converter are used. The description of time of day module and serial communication interface using is contained. Each of laboratory exercise contains problem description, functions of indicators and buttons, <b>program</b> description, <b>flow</b> <b>diagram</b> and <b>programming</b> technique. All the techniques are proved and lead programmer step-by-step through programming of the exercise from creating a new project to functional program. One part of the thesis describes libraries and procedures for driving A/D converter, LCD display, internal clock source, interrupts, serial communication interface and time of day module are included. Most of the procedures initialize the modules at the begining of the program. The result of this thesis is five programmed and debuged programs for microcontroller. The operating of the programs is described in <b>flow</b> <b>diagrams.</b> In addition two programs for computer, which communicate with some programs for microcontroller, was programmed. This computer programs are very {{easy to use and}} they are debuged and tested on several computers running WinXP and Win 7...|$|R
40|$|Xiang Guoliang. Thesis (M. Phil.) [...] Chinese University of Hong Kong, 2001. Includes bibliographical {{references}} (leaves 51 - 53). Abstracts in English and Chinese. Acknowledgement [...] - p. 1 Abstract [...] - p. 6 Chapter 1 [...] - Introduction [...] - p. 9 Chapter 2 [...] - The Pulse Detection Sensor [...] - p. 14 Chapter 2. 1 [...] - Pulse Diagnosis in Traditional Chinese Medicine [...] - p. 14 Chapter 2. 2 [...] - The Pulse Detection Sensor [...] - p. 15 Chapter 2. 2. 1 [...] - The Sensor Design [...] - p. 16 Chapter 2. 2. 2 [...] - Pulse Signal Acquisition [...] - p. 20 Chapter 2. 2. 3 [...] - Experiment Results [...] - p. 21 Chapter 3 [...] - Internet Communication [...] - p. 22 Chapter 3. 1 [...] - Network Basics [...] - p. 22 Chapter 3. 2 [...] - Java [...] - p. 24 Chapter 3. 3 [...] - <b>Program</b> <b>Flow</b> <b>Diagram</b> [...] - p. 24 Chapter 3. 4 [...] - Results [...] - p. 27 Chapter 4 [...] - The Haptic Device [...] - p. 28 Chapter 4. 1 [...] - Overview [...] - p. 28 Chapter 4. 2 [...] - The Design [...] - p. 29 Chapter 4. 2. 1 [...] - The First Design [...] - p. 31 Chapter 4. 2. 2 [...] - The Prototype [...] - p. 32 Chapter 4. 3 [...] - The Kinematics [...] - p. 34 Chapter 4. 4 [...] - The Dynamics [...] - p. 35 Chapter 4. 5 [...] - Reproducing Pulses by Position Control [...] - p. 37 Chapter 4. 5. 1 [...] - The Motor Controller [...] - p. 37 Chapter 4. 5. 2 [...] - Trajectory Following [...] - p. 40 Chapter 4. 5. 3 [...] - Experiment Results [...] - p. 41 Chapter 4. 6 [...] - Reproducing Pulses by Force Control [...] - p. 45 Chapter 4. 6. 1 [...] - The Desired Forces [...] - p. 46 Chapter 4. 6. 2 [...] - The Force Controller Design [...] - p. 46 Chapter 4. 6. 3 [...] - Experiment Results [...] - p. 47 Chapter 5 [...] - Conclusions and Future works [...] - p. 49 Bibliography [...] - p. 5...|$|R
40|$|An Interpretive Computer Simulator (ICS) for the NASA Standard Spacecraft Computer-II (NSSC-II) was {{developed}} as a code verification and testing tool for the Annular Suspension and Pointing System (ASPS) project. The simulator is written in the higher level language PASCAL and implented on the CDC CYBER series computer system. It {{is supported by a}} metal assembler, a linkage loader for the NSSC-II, and a utility library to meet the application requirements. The architectural design of the NSSC-II is that of an IBM System/ 360 (S/ 360) and supports all but four instructions of the S/ 360 standard instruction set. The structural design of the ICS is described with emphasis on the design differences between it and the NSSC-II hardware. The <b>program</b> <b>flow</b> is <b>diagrammed,</b> with the function of each procedure being defined; the instruction implementation is discussed in broad terms; and the instruction timings used in the ICS are listed. An example of the steps required to process an assembly level language program on the ICS is included. The example illustrates the control cards necessary to assemble, load, and execute assembly language code; the sample program to to be executed; the executable load module produced by the loader; and the resulting output produced by the ICS...|$|R
50|$|Process <b>flow</b> <b>diagrams</b> of {{multiple}} process units within a large industrial plant will usually contain less detail {{and may be}} called block <b>flow</b> <b>diagrams</b> or schematic <b>flow</b> <b>diagrams.</b>|$|R
5000|$|Such {{chemical}} processes can be illustrated generally as block <b>flow</b> <b>diagrams</b> or {{in more detail}} as process <b>flow</b> <b>diagrams.</b> Block <b>flow</b> <b>diagrams</b> show the units as blocks and the streams flowing between them as connecting lines with arrowheads to show direction of flow.|$|R
5000|$|Common {{alternative}} names include: flow chart, process flowchart, functional flowchart, process map, process chart, functional process chart, {{business process}} model, process model, process <b>flow</b> <b>diagram,</b> work <b>flow</b> <b>diagram,</b> business <b>flow</b> <b>diagram.</b> The terms [...] "flowchart" [...] and [...] "flow chart" [...] are used interchangeably.|$|R
50|$|The Functional <b>flow</b> block <b>diagram</b> (FFBD) is a multi-tier, time-sequenced, {{step-by-step}} <b>flow</b> <b>diagram</b> of the system’s functional flow.The diagram {{is developed}} in the 1950s and widely used in classical systems engineering. The Functional <b>Flow</b> Block <b>Diagram</b> is {{also referred to as}} Functional <b>Flow</b> <b>Diagram,</b> functional block <b>diagram,</b> and functional <b>flow.</b>|$|R
5000|$|The process <b>flow</b> <b>diagram</b> {{below is}} an example of a {{schematic}} or block <b>flow</b> <b>diagram</b> and depicts the various unit processes within a typical oil refinery: ...|$|R
50|$|Data <b>flow</b> <b>diagrams</b> (DFDs) {{are one of}} {{the three}} {{essential}} perspectives of structured systems analysis and design method (SSADM). The sponsor of a project and the end users will need to be briefed and consulted throughout all stages of a system's evolution. With a data <b>flow</b> <b>diagram,</b> users are able to visualize how the system will operate, what the system will accomplish, and how the system will be implemented. The old system's data <b>flow</b> <b>diagrams</b> can be drawn up and compared with the new system's data <b>flow</b> <b>diagrams</b> to draw comparisons to implement a more efficient system. Data <b>flow</b> <b>diagrams</b> can be used to provide the end user with a physical idea of where the data they input ultimately has an effect upon the structure of the whole system from order to dispatch to recook. How any system is developed can be determined through a data <b>flow</b> <b>diagram.</b>|$|R
40|$|To {{consider}} possible ways {{to develop}} data <b>flow</b> <b>diagrams</b> • To identify problems with data <b>flow</b> <b>diagrams</b> • To see extensions of data <b>flow</b> <b>diagrams</b> to include control elements as control <b>flow</b> <b>diagrams</b> • To describe control {{in terms of}} state transition systems 29 April 2003 31 T 4 /IT 52 Commercial Systems Development 2 Developing data <b>flow</b> <b>diagrams</b> • No fixed rules about how to develop a data <b>flow</b> <b>diagram</b> in a given situation • At best, we can suggest methods dependent on the particular situation • Complication {{since there is no}} one DFD for each situation – if the DFDs of two individuals are identical then some replication has taken place – two analysts working independently may choose the same external entities, the same data stores, and same data items entering the system • A DFD is complete only when it feels right (Always ask a friend!...|$|R
50|$|Control <b>flow</b> <b>diagrams</b> were {{developed}} in the 1950s, and are widely used in multiple engineering disciplines. They {{are one of the}} classic business process modeling methodologies, along with flow charts, data <b>flow</b> <b>diagrams,</b> functional <b>flow</b> block <b>diagram,</b> Gantt charts, PERT diagrams, and IDEF.|$|R
40|$|The {{overall goal}} of the DOE Industrial Heat Pump Program is to foster {{research}} and development which will allow more efficient and economical recovery of waste energy in industry. Specifically, the program includes the identification of appropriate heat pump applications within the industrial sector and the subsequent development of heat pump technologies to meet the industrial requirements. The initial phases of the program were directed towards extending the technology of the more conventional heat pump systems, such as, Rankine and Brayton cycles so as to provide near-term results. In addition to system studies, material and component developmental programs were undertaken that would potentially result in enhanced performance and reduced costs. Research in more sophisticated and higher risk heat pump systems are being pursued on a longer term schedule. Novel mechanical systems, such as sterling cycles and magnetic heat pumps and advanced chemical systems, such as zeolite-water absorption cycles and heat of reaction systems are currently being investigated. This paper provides the program rationale and details the logic employed in designing a sound and cost-effective R&D <b>program.</b> A R&D <b>flow</b> <b>diagram</b> is structured {{with a series of}} major milestones or go/no go decision points. The paper traces the systematic progress of a technology from conception, through the various developmental phases until final prototype tests...|$|R
25|$|The Functional <b>flow</b> block <b>diagram</b> (FFBD) is a multi-tier, time-sequenced, {{step-by-step}} <b>flow</b> <b>diagram</b> of the system’s functional flow.|$|R
40|$|This report {{looks at}} the need for {{structured}} techniques and more, the need for computer implementations of these techniques. In particular I look at data <b>flow</b> <b>diagrams</b> (refer chapter 3), {{one of the most}} important analysis tools and document my own design and implementation of a computer tool for creating and manipulating data <b>flow</b> <b>diagrams.</b> MacDaffy (Macintosh data flow diagrammer) is aimed at increasing the productiveness of data <b>flow</b> <b>diagrams</b> as an analysis tool...|$|R
40|$|The Department of Energy Office of Fissile Materials Disposition (DOE-MD) is {{planning}} a facility to disassemble pits and convert the plutonium in the pits into a form suitable for international inspection. The facility, called the Advanced Recovery and Integrated Extraction System (ARIES) Facility, must handle much of the 38. 2 metric tons of plutonium declared excess to national security needs in ten years of operation. A process logic <b>flow</b> <b>diagram</b> for the ARIES Facility is presented here. This <b>flow</b> <b>diagram</b> is based on and supported by a library of fact sheets on topics that impact {{the design of the}} facility. Developing the <b>flow</b> <b>diagram</b> raised issues that significantly impact the design of the facility. These issues are discussed later in this document, and for some issues, discussed in greater detail in the appropriate fact sheets. The <b>flow</b> <b>diagram</b> is designed to show requirements that dictate the need for space and/or equipment. In physically designing the facility, the same space or equipment may be used to meet several requirements. The <b>flow</b> <b>diagram</b> merely shows the activities that need to occur to meet requirements for the facility. The <b>flow</b> <b>diagram</b> is not associated with any DOE site. The requirements shown on the <b>flow</b> <b>diagram</b> may be met by an existing facilities at a given site. The <b>flow</b> <b>diagram</b> and this write up do not contain a great deal of detail on how each step in the diagram is performed. At this stage of design, the <b>flow</b> <b>diagram</b> merely identifies the need for the activity. Examples for some of the activities are given in the appropriate fact sheet. How the steps are performed becomes more defined as the design of the facility progresses...|$|R
40|$|Designers of {{software}} for real-time systems often use models, {{in the form}} of data flow/control <b>flow</b> <b>diagrams,</b> to express system behavior in a graphical notation that can be understood easily by users and by programmers, and from which designers can generate a software architecture. The research described in this paper is motivated by the desire to provide an automated designer's assistant that can generate software architectures for real-time systems directly from models expressed as data flow/control <b>flow</b> <b>diagrams.</b> To achieve this goal, an automated designer's assistant must be capable of interpreting <b>flow</b> <b>diagrams</b> in semantic, rather than syntactic, terms. Unfortunately, <b>flow</b> <b>diagrams,</b> with a limited number of syntactic elements, are seldom expressive enough to depict the semantic concepts that a designer intends; instead, most design methods that include <b>flow</b> <b>diagrams</b> allow the designer to augment those diagrams with a textual description to express semantic information. This pape [...] ...|$|R
5000|$|<b>Flow</b> <b>diagram</b> is a {{collective}} {{term for a}} <b>diagram</b> representing a <b>flow</b> or set of dynamic relationships in a system. The term <b>flow</b> <b>diagram</b> is also used as a synonym for flowchart, and sometimes as a counterpart of the flowchart.|$|R
40|$|Using {{operational}} semantic techniques, {{an extended}} variant of structured analysis style data <b>flow</b> <b>diagrams</b> {{is given a}} formal semantics. This semantics allows one to describe both how information is processed and the dynamic behavior of the system. The ability to describe dynamic behavior is an extension to the traditional notion of data <b>flow</b> <b>diagrams.</b> This semantics {{can serve as a}} target for giving meaning to specification languages that use a graphical notation similar to data <b>flow</b> <b>diagrams...</b>|$|R
40|$|It {{has been}} shown in [SB 96] that a {{particular}} subclass of Formalized Data <b>Flow</b> <b>Diagrams</b> (FDFD's) is Turing equivalent. We call this Turing equivalent subclass of FDFD's persistent flow [...] free Reduced Data <b>Flow</b> <b>Diagrams</b> (PFF [...] RDFD's). PFF [...] RDFD's do not contain persistent flows, reference only values whose types have finite domains, and have enabling conditions that contain no tests for empty flows. In addition, FDFD's do not contain (direct) representations of stores. This raises the question whether any of these common features of traditional Data <b>Flow</b> <b>Diagrams</b> elevates the expressive power of FDFD's, or whether the various subclasses have the same expressive power as FDFD's with these features. This paper addresses this issue of whether persistent flows, arbitrary domains, tests for empty flows or stores are essential features with respect to the expressive power of Formalized Data <b>Flow</b> <b>Diagrams.</b> 2 1. 1 Introduction Traditional Data <b>Flow</b> <b>Diagrams</b> (DFD's) are probably the most widely [...] ...|$|R
50|$|The FFBD {{notation}} {{was developed}} in the 1950s, and is widely used in classical systems engineering. FFBDs are one of the classic business process modeling methodologies, along with flow charts, data <b>flow</b> <b>diagrams,</b> control <b>flow</b> <b>diagrams,</b> Gantt charts, PERT diagrams, and IDEF.|$|R
40|$|This {{calculation}} {{justifies the}} numbers {{used for the}} material balance on the process <b>flow</b> <b>diagrams</b> for the KW Basin Fuel Retrieval Subproject. The purpose of these calculations is to develop the material balances that are documented in the Fuel Retrieval System (FRS) Process <b>Flow</b> <b>Diagrams</b> for future reference. The attached mass calculations were prepared in support of revising the fuel retrieval system process <b>flow</b> <b>diagrams</b> for the 105 K West Basin. The calculations refer to diagram H- 1 - 81164...|$|R
40|$|We {{propose a}} method to {{automatically}} transform synchronous data <b>flow</b> <b>diagrams</b> into synchronous block diagrams. The idea is to use triggers, a mechanism that allows a block to be fired only at selected times. We discuss how to extend the transformation to also cover dynamic data <b>flow</b> <b>diagrams</b> where the number of tokens produced and consumed by blocks is variable. Our method allows widespread tools such as Simulink {{which are based on}} the synchronous block diagram model to be used for data <b>flow</b> <b>diagrams</b> as well. ...|$|R
40|$|In {{this paper}} we {{describe}} {{a part of}} our work on the automatic generation of target code from Stateflow models. We focus on the <b>flow</b> <b>diagrams</b> from the Stateflow component of MATLAB and describe how <b>flow</b> <b>diagram</b> models can be compiled into target code for embedded systems. Moreover, the paper describes a method for analyzing <b>flow</b> <b>diagrams,</b> allowing an efficient code generation. The method described has been implemented as a code generator for Stateflow models and integrated into the TargetLink environment from dSPACE [3, 4]. ...|$|R
5000|$|Chemical Engineering Collection for {{realistic}} process <b>flow</b> <b>diagrams</b> ...|$|R
5000|$|... #Caption: <b>Flow</b> <b>diagram</b> of the split-mix {{combinatorial}} synthesis ...|$|R
50|$|OTMs {{are built}} with {{end-to-end}} data <b>flow</b> <b>diagrams</b> {{very similar to}} traditional DFDs. End to end data <b>flow</b> <b>diagrams</b> decompose an IT system into its various independent, grouped, and shared components. Each component is {{described in terms of}} specific attributes. Components are then connected by communication pathways and protocols.|$|R
