5094|64|Public
5|$|In 1981, the Japanese Ministry of International Trade and Industry {{set aside}} $850 {{million for the}} Fifth {{generation}} computer project. Their objectives were to write programs and build machines that could carry on conversations, translate languages, interpret pictures, and reason like human beings. Much {{to the chagrin of}} scruffies, they chose <b>Prolog</b> as the primary computer language for the project.|$|E
5|$|Watson uses IBM's DeepQA {{software}} and the Apache UIMA (Unstructured Information Management Architecture) framework. The system {{was written in}} various languages, including Java, C++, and <b>Prolog,</b> and runs on the SUSE Linux Enterprise Server 11 operating system using the Apache Hadoop framework to provide distributed computing.|$|E
5|$|In 1963, J. Alan Robinson had {{discovered}} a simple method to implement deduction on computers, the resolution and unification algorithm. However, straightforward implementations, like those attempted by McCarthy and his students in the late 60s, were especially intractable: the programs required astronomical numbers of steps to prove simple theorems. A more fruitful approach to logic {{was developed in the}} 1970s by Robert Kowalski at the University of Edinburgh, and soon this led to the collaboration with French researchers Alain Colmerauer and Philippe Roussel who created the successful logic programming language <b>Prolog.</b>|$|E
25|$|Erlang began {{life with}} a Prolog-based {{implementation}} and maintains much of <b>Prolog's</b> unification-based syntax.|$|R
25|$|<b>Prolog's</b> single {{data type}} is the term. Terms are either atoms, numbers, {{variables}} or compound terms.|$|R
50|$|Contrary {{to other}} languages, it is {{possible}} to give symbols some meaning by creating some <b>Prolog's</b> facts and/or rules.|$|R
25|$|<b>Prolog</b> {{systems that}} provide a {{graphics}} library are SWI-prolog, Visual-prolog, LPA <b>Prolog</b> for Windows and B-Prolog.|$|E
25|$|<b>Prolog</b> is not purely declarative: {{because of}} {{constructs}} like the cut operator, a procedural reading of a <b>Prolog</b> program {{is needed to}} understand it. The order of clauses in a <b>Prolog</b> program is significant, as the execution strategy of the language depends on it. Other logic programming languages, such as Datalog, are truly declarative but restrict the language. As a result, many practical <b>Prolog</b> programs are written to conform to Prolog's depth-first search order, rather than as purely declarative logic programs.|$|E
25|$|European AI {{researchers}} favored <b>Prolog</b> while Americans favored Lisp, reportedly causing many nationalistic {{debates on}} the merits of the languages. Much of the modern development of <b>Prolog</b> came from the impetus of the Fifth Generation Computer Systems project (FGCS), which developed a variant of <b>Prolog</b> named Kernel Language for its first operating system.|$|E
50|$|Nominal {{unification}} is efficiently decidable. This fact led to {{the development}} of alphaProlog, a Prolog-like logic programming language with facilities for binding names in terms, where <b>Prolog's</b> standard first-order unification algorithm is replaced with nominal unification.|$|R
5000|$|There are {{advantages}} and disadvantages to this simpler syntax. On the positive side, it renders predicates such as <b>Prolog's</b> [...] (which maps between lists and clauses) unnecessary, as a clause is a list. On the other hand, {{it is more difficult}} to read.|$|R
40|$|Logic {{programming}} is generally {{taken to be}} synonymous with relational programming; however, this paper argues why a broader basis for logic {{programming is}} needed, why existing combinations of equations, relations, and functions do not entirely meet the need, and a promising approach for the broader basis. The proposed broader basis consists of three logical forms: equations, relations, and subset assertions, along with an accompanying set of matching and unification operations. Equations provide the ability to define deterministic operations without <b>Prolog's</b> cut. Subset assertions {{can be used to}} define more declaratively <b>Prolog's</b> setof as well as transitive-closure operations, both of which are traditionally expressed using assert and retract. Because functions defined by subset assertions must be invoked with ground arguments, formulating relational clauses by subset assertions allows one to declaratively specify which arguments of a relation are ground, thereby obviating the need for [...] ...|$|R
25|$|Logtalk {{extends the}} <b>Prolog</b> {{programming}} language with support for objects, protocols, and other OOP concepts. Highly portable, it supports most standard-complaint <b>Prolog</b> systems as backend compilers.|$|E
25|$|Some <b>Prolog</b> systems, such as LPA <b>Prolog</b> and SWI-Prolog, now {{implement}} hashing to help handle large datasets more efficiently. This {{tends to}} yield very large performance gains {{when working with}} large corpora such as WordNet.|$|E
25|$|The syntax of <b>Prolog</b> {{does not}} specify which {{arguments}} of a predicate are inputs {{and which are}} outputs. However, this information is significant and {{it is recommended that}} it be included in the comments. Modes provide valuable information when reasoning about <b>Prolog</b> programs and {{can also be used to}} accelerate execution.|$|E
40|$|Abstract. This paper proposes {{two ways}} to {{instantiate}} general games specified in the game description language GDL to enhance exploration efficiencies of ex-isting players. One uses <b>Prolog’s</b> inference mechanism to find supersets of reach-able atoms and moves; the other one utilizes dependency graphs, a datastructure that can calculate the dependencies of the arguments of predicates by evaluating the various formulas from the game’s description. ...|$|R
5000|$|In the Hewlett-Packard/Intel IA-64 architecture, most {{instructions}} are predicated. The predicates {{are stored in}} 64 special-purpose predicate registers; {{and one of the}} predicate registers is always true so that unpredicated {{instructions are}} simply instructions predicated with the value true. The use of predication is essential in IA-64's implementation of software pipelining because it avoids the need for writing separated code for <b>prologs</b> and epilogs.|$|R
5000|$|The {{arguments}} to each functor, such as [...] and [...] are difference lists; difference lists {{are a way}} of representing a prefix of a list as the difference between its two suffixes (the bigger including the smaller one). Using <b>Prolog's</b> notation for lists, a singleton list prefix [...] {{can be seen as}} the difference between [...] and , and thus represented with the pair , for instance.|$|R
25|$|Here follow some example {{programs}} {{written in}} <b>Prolog.</b>|$|E
25|$|F-logic extends <b>Prolog</b> with frames/objects for {{knowledge}} representation.|$|E
25|$|Higher-order {{programming}} {{style in}} <b>Prolog</b> was pioneered in HiLog and λProlog.|$|E
2500|$|Finding clauses {{that are}} unifiable with a term in a query is linear {{in the number}} of clauses. [...] Term {{indexing}} uses a data structure that enables sub-linear-time lookups. [...] Indexing only affects program performance, it does not affect semantics. Most <b>Prologs</b> only use indexing on the first term, as indexing on all terms is expensive, but techniques based on field-encoded words or superimposed codewords provide fast indexing across the full query and head.|$|R
40|$|A {{technique}} to detect that pairs of rules are exclusive &quot; in a logic program is described. In contrast to previous work our algorithm derives mutual exclusion by looking {{not only on}} built-in, but also user-de ned predicates. This technique has applications to optimization of the execution of programs containing these rules. Additionally, the programmer is less dependent on non-logical language features, such as <b>Prolog's</b> &quot;, thus creating more opportunities for parallel execution strategies...|$|R
40|$|Abstract. Tabling is an {{implementation}} {{technique that}} solves some limitations of <b>Prolog’s</b> operational semantics {{in dealing with}} recursion and redundant sub-computations. Arguably, the SLDT and DRA strategies {{are the two most}} successful extensions to standard linear tabled evaluation. In this work, we propose a new strategy for linear tabling, named DRS, and we present a framework, on top of the Yap system, that supports the combination of variants of these three strategies. ...|$|R
25|$|Logico-linguistic modeling. A {{method for}} {{building}} knowledge-based system that uses <b>Prolog.</b>|$|E
25|$|AgentSpeak is {{a variant}} of <b>Prolog</b> for {{programming}} agent behavior in multi-agent systems.|$|E
25|$|M. S. Dawe and C.M.Dawe, <b>Prolog</b> for Computer Sciences, Springer Verlag 1992.|$|E
5000|$|Finding clauses {{that are}} unifiable with a term in a query is linear {{in the number}} of clauses. Term {{indexing}} uses a data structure that enables sub-linear-time lookups. [...] Indexing only affects program performance, it does not affect semantics. Most <b>Prologs</b> only use indexing on the first term, as indexing on all terms is expensive, but techniques based on field-encoded words or superimposed codewords provide fast indexing across the full query and head.|$|R
40|$|We {{consider}} an extended definition of well-typed programs to general logic programs, i. e. logic programs with negated literals {{in the body}} of the clauses. This is a quite large class of programs which properly includes all the well-moded ones. We study termination properties of well-typed general programs while employing the <b>Prolog's</b> left-to-right selection rule. We introduce the notion of typed acceptable program and provide an algebraic characterization for the class of well-typed programs which terminate on all well-typed queries...|$|R
50|$|In addition, {{six of the}} fabillis in {{the cycle}} are tales based on Reynardian beast epic sources. These are denoted by the lighter colour. It can {{be noted that the}} {{distribution}} of these (in two groups of three embedded within the seven fabillis from Aesop) is symmetrical, and that the distribution of the <b>prologs</b> - some apparently introductory material embedded in the centre of the poem - may begin to make better sense when these larger structures are taken into account.|$|R
25|$|If {{we think}} of the stable model {{semantics}} as a description of the behavior of <b>Prolog</b> in the presence of negation then programs without a unique stable model can be judged unsatisfactory: they do not provide an unambiguous specification for Prolog-style query answering. For instance, the two programs above are not reasonable as <b>Prolog</b> programs— SLDNF resolution does not terminate on them.|$|E
25|$|Objlog was a {{frame-based}} language combining {{objects and}} <b>Prolog</b> II from CNRS, Marseille, France.|$|E
25|$|<b>Prolog</b> is a {{general-purpose}} {{logic programming}} language associated with artificial intelligence and computational linguistics.|$|E
40|$|AbstractA {{mathematical}} puzzle from {{a recent}} issue of the New Scientist magazine is solved by combining the theory of permutations with <b>Prolog's</b> symbolic and other computational facilities. The scheme studied is interesting because it shows that the power of the generate-and-test approach, a rather crude approach known from Artificial Intelligence, is greatly enhanced if it is supplemented by some topical knowledge from the field of study. The puzzle involves searching for matrices with certain patterns, leading to the study of permutation types. The suggested route allows for the solution of a generalized version of the original puzzle...|$|R
40|$|Abstract. Critical or {{scientific}} editions are a promising {{field for the}} application of declarative programming, which can facilitate the parsing and the markup of texts, and the transformation of XML documents. We have used a logic programming–based approach for the production of critical editions: In particular, we propose a transformation of XML documents based on a compact and intuitive substitution formalism. Moreover, we have developed a new XML update language FNUPDATE for adding navigation facilities. We have implemented a transformation tool in SWI–PROLOG, which integrates and interleaves <b>PROLOG’s</b> well–known definite clause grammars and the new substitution formalism...|$|R
5000|$|Hamid R. Moghadam (born August 26, 1956) is an Iranian-born American {{business}} {{executive and}} philanthropist. In 1983, Moghadam co-founded Abbey, Moghadam & Company, an investment manager headquartered in San Francisco, California. [...] After the company became AMB Property Corporation, Moghadam took AMB public in 1997, [...] becoming CEO. In 2011 Moghadam orchestrated the “merger of equals” between AMB and ProLogis to create Prologis, the largest logistics {{real estate company}} in the world. Moghadam currently serves as <b>Prologs</b> chairman and CEO, with Prologis operating as a multinational logistics {{real estate investment trust}} (REIT) and S&P 500 company.|$|R
