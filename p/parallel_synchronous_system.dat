0|2081|Public
40|$|This paper {{describes}} {{the development and}} implementation of automatic <b>paralleling</b> of <b>synchronous</b> generator <b>system</b> using LabVIEW platform. The system comprises of the hardware and the software parts. The hardware part encapsulates the prime mover, synchronous alternator, excitation unit and other sundries that constitute a <b>synchronous</b> generator <b>system.</b> The software part comprises of the National Instruments LabVIEW software, PCI- 6014 Data Acquisition card, and the NI ELVIS devices. The overall system architecture is simple and cheap to implement and is recommended for <b>paralleling</b> of small <b>synchronous</b> generators (SSG) in the mission field of military establishment...|$|R
40|$|We have empirically {{discovered}} that the space of human actions has a linguistic structure. This is a sensory-motor space consisting {{of the evolution of}} the joint angles of the human body in movement. The space of human activity has its own phonemes, morphemes, and sentences. In kinetology, the phonology of human movement, we define atomic segments (kinetemes) that are used to compose human activity. In this paper, we present a morphological representation that explicitly contains the subset of actuators responsible for the activity, the synchronization rules modeling coordination among these actuators, and the motion pattern performed by each participating actuator. We model a human action with a novel formal grammar <b>system,</b> named <b>Parallel</b> <b>Synchronous</b> Grammar <b>System</b> (PSGS), adapted from Parallel Communicatin...|$|R
40|$|In this paper, {{we present}} the steps {{required}} {{for the construction of}} a praxicon, a structured lexicon of human actions, through the learning of grammar systems for human actions. The discovery of a Human Activity Language involves learning the syntax of human motion which requires the construction of this praxicon. The morphology inference process assumes that a non-arbitrary symbolic representation of the human movement is given. Thus, to analyze the morphology of a particular action, we are given a symbolic representation for the motion of each actuator associated with several repeated performances of this action. As a formal model, we propose a new <b>Parallel</b> <b>Synchronous</b> Grammar <b>System</b> where each component grammar corresponds to an actuator. We present a novel parallel learning algorithm to induce this grammar system. Our representation explicitly contains the set of joints (degrees of freedom) actually responsible for achieving the goal aimed by the activity, the motion performed by each participating actuator, and the synchronization rules modeling coordination among these actuators. We evaluated our inference approach with synthetic data and real human motion data. The algorithm manages to induce the correct grammar system even when the input contains noise. Therefore, our approach was successful in both representational and learning aspects, and may serve as a tool to parse movement, learn patterns, and to generate actions...|$|R
40|$|We have empirically {{discovered}} that the space of human actions has a linguistic structure. This is a sensory-motor space consisting {{of the evolution of}} the joint angles of the human body in movement. The space of human activity has its own phonemes, morphemes, and sentences. In kinetology, the phonology of human movement, we define atomic segments (kinetemes) that are used to compose human activity. In this paper, we present a morphological representation that explicitly contains the subset of actuators responsible for the activity, the synchronization rules modeling coordination among these actuators, and the motion pattern performed by each participating actuator. We model a human action with a novel formal grammar <b>system,</b> named <b>Parallel</b> <b>Synchronous</b> Grammar <b>System</b> (PSGS), adapted from Parallel Communicating Grammar Systems (PCGS). We propose a heuristic PArallel Learning (PAL) algorithm for the automatic inference of a PSGS. Our algorithm is used in the learning of human activity. Instead of a sequence of sentences, the input is a single string for each actuator in the body. The algorithm infers the components of the grammar system as a subset of actuators, a CFG grammar for the language of each component, and synchronization rules. Our framework is evaluated with synthetic data and real motion data from a large scale motion capture database containing around 200 different actions corresponding to verbs associated with voluntary observable movement. On synthetic data, our algorithm achieves 100 % success rate with a noise level up to 7 %...|$|R
40|$|Series Title: IFIP - The International Federation for Information Processing, ISSN 1868 - 4238 "Petri Nets (PNs) {{prove to}} be an e cient {{methodology}} to model discrete-event systems with parallel activities. The main advantages lie on the graphical interface and {{on the availability of}} a set of techniques for formal analysis, including the validation and the test of the modelled system. A proposal to modify the normal PN behaviour is presented, which aims a fast speci cation of <b>synchronous</b> <b>parallel</b> digital <b>systems,</b> including both the data path and the control unit. A CAD environment, SOFHIA, was developed to model digital systems, to validate their properties and to simulate their behaviour. The environment includes the automatic generation of VHDL code to allow simulation and synthesis on existing CAD tools...|$|R
40|$|A <b>synchronous</b> <b>parallel</b> <b>system</b> for {{emulation}} and discrete event simulation having parallel nodes {{responds to}} received messages at each node by generating event objects having individual time stamps, stores only {{the changes to}} state variables of the simulation object attributable to the event object, and produces corresponding messages. The system refrains from transmitting the messages and changing the state variables while it determines whether the changes are superseded, and then stores the unchanged state variables in the event object for later restoral to the simulation object if called for. This determination preferably includes sensing the time stamp of each new event object and determining which new event object has the earliest time stamp as the local event horizon, determining the earliest local event horizon of the nodes as the global event horizon, and ignoring the events whose time stamps are less than the global event horizon. Host processing between the system and external terminals enables such a terminal to query, monitor, command or participate with a simulation object during the simulation process...|$|R
40|$|Petri Nets (PNs) {{prove to}} be an {{efficient}} methodology to model discrete-event systems with parallel activities. The main advantages lie on the graphical interface and {{on the availability of}} a set of techniques for formal analysis, including the validation and the test of the modelled system. A proposal to modify the normal PN behaviour is presented, which aims a fast specification of <b>synchronous</b> <b>parallel</b> digital <b>systems,</b> including both the data path and the control unit. A CAD environment, SOFHIA, was developed to model digital systems, to validate their properties and to simulate their behaviour. The environment includes the automatic generation of VHDL code to allow simulation and synthesis on existing CAD tools. Keywords Petri Nets, Digital Control Systems, VHDL, CAD Tools SUMMARY A new PN model, shobi-PN (synchronous, hierarchical, object-oriented and interpreted PN), was developed to support the use of hierarchy and to model the control unit and the data path in the specificati [...] ...|$|R
40|$|Abstract. The paper {{considers}} the consensus {{problem in a}} partially <b>synchronous</b> <b>system</b> with Byzantine faults. It turns out that, in the partially <b>synchronous</b> <b>system,</b> all deterministic algorithms that solve consensus with Byzantine faults are leader-based. This {{is not the case}} of benign faults, which raises the following fundamental question: is it possible to design a deterministic Byzantine consensus algorithm for a partially <b>synchronous</b> <b>system</b> that is not leader-based? The paper gives a positive answer to this question, and presents a leader-free algorithm that is resilient-optimal and signature-free. ...|$|R
40|$|We {{introduce}} {{and study}} error correcting codes for <b>parallel</b> <b>synchronous</b> communication via asymmetric channels. Constructions for error detecting/correcting codes are presented. More generally, we consider array codes for binary asymmetric channels. Index Terms – Asymmetric error correcting codes, parallel channel, asymmetric parallel channel, array code...|$|R
50|$|The {{front panel}} data port (FPDP) is a bus that {{provides}} high speed data transfer between {{two or more}} VMEbus boards at up to 160 MB/sec with low latency. The FPDP bus uses a 32-bit <b>parallel</b> <b>synchronous</b> bus wired with an 80-conductor ribbon cable.|$|R
40|$|AbstractThe {{design of}} frequency-load {{controller}} greatly affects {{the performance of}} a ship power station. A common strategy to control frequency and load of the ship power station is to use speed regulator with a PI controller, these schemes require proper and continuous tuning, frequency and load of the diesel-generator are separately controlled, but frequency regulation and load distribution among <b>parallel</b> <b>synchronous</b> generators are interacted. A new parallel PID control technique based on auto-tuning neurons used as a modified hyperbolic tangent function is proposed in this paper, which specialized for frequency-load regulation of the ship power station. Simulation and experimental results show that proposed scheme can achieve an appropriate frequency-load control among <b>parallel</b> <b>synchronous</b> generators, and ensure their stable and economical performances...|$|R
5000|$|... {{transition}} from plesiochronous transmission to <b>synchronous</b> <b>systems</b> like SONET/SDH ...|$|R
40|$|We give in {{this paper}} a {{convergence}} result concerning <b>parallel</b> <b>synchronous</b> algorithm for nonlinear fixed point problems {{with respect to the}} euclidean norm in Rn. We then apply this result to some problems related to convex analysis like minimization of functionals, calculus of saddle point, convex programming [...] ...|$|R
5000|$|If the phasors V were a {{perfectly}} <b>synchronous</b> <b>system,</b> the vertex {{of the outer}} triangle not on the base line {{would be at the}} same position as the corresponding vertex of the equilateral triangle representing the <b>synchronous</b> <b>system.</b> Any amount of inverse component would mean a deviation from this position. The deviation is exactly 3 times the inverse phase component.|$|R
40|$|In {{this paper}} {{we present a}} {{flexible}} mechanism for symbolic execution of <b>synchronous</b> <b>parallel</b> programs. The <b>synchronous</b> <b>parallel</b> operator we use allows for techniques like modular reasoning and abstraction of single components. Furthermore, symbolic execution provides intuitive proofs. The operator is included into the interactive higher order theorem prover KIV. We show how to apply our approach using the Asbru medical planning language as an example. This language decomposes medical treatments into many components, which are then executed <b>synchronous</b> <b>parallel...</b>|$|R
40|$|In modern digital systems, off-chip and intra-chip {{electrical}} interconnections {{suffer from}} a multitude of limitations as integrated circuits (ICs) continue to grow in size and processing capacity. Optical interconnects are capable of meeting the increasing I/O bandwidth needs in these systems. Optoelectronic-VLSI (OE-VLSI) technology incorporates optical I/O with ICs through the integration of arrays of optoelectronic devices with on-chip receiver and transmitter circuits. These optical I/Os are intended to replace or complement electrical interconnects for off-chip connections, and for connections between processing modules on the same chip or in a multi-chip module. The design of receivers, transmitters, and OE-VLSI application-specific integrated circuits (ASICs) are described from a system implementation perspective. Numerous techniques to overcome technological problems and allow the successful operation of large receiver and transmitter arrays are considered. The use of a fully differential optical and electrical architecture is strongly advocated. The testing of receiver and transmitter circuits and skew in highly <b>parallel</b> and <b>synchronous</b> digital <b>systems</b> employing optical receivers is also considered. The major portion of this thesis details the design, construction, and optical and electrical testing of two OE-VLSI ASICs. The experiences obtained during the design and test of these ASICs, in conjunction with further analytical and simulation-based analyses, resulted in the conclusion that a fully differential optical and electrical architecture is optimal for OE-VLSI applications. The remainder of the thesis considers receiver and transmitter testing and the integration of testing methodologies at the ASIC level, and the management of skew in large receiver arrays...|$|R
50|$|Transparent latches are {{typically}} used as I/O ports or in asynchronous <b>systems,</b> or in <b>synchronous</b> two-phase <b>systems</b> (<b>synchronous</b> <b>systems</b> that use a two-phase clock), where two latches operating on different clock phases prevent data transparency as in a master-slave flip-flop.|$|R
40|$|A <b>synchronous</b> <b>system</b> {{model is}} a simple yet {{powerful}} distributed system model that reduces {{the complexity of the}} design and implementation of dependable distributed applications. However, a late message arrival or a missed deadline violates the properties of a completely <b>synchronous</b> <b>system.</b> Therefore, an application that depends upon these properties might violate its safety properties due to a late message or a missed deadline...|$|R
40|$|Given a <b>synchronous</b> <b>system,</b> {{we study}} the {{question}} whether the behaviour of that system can be exhibited by a (non-trivially) distributed and hence asynchronous implementation. In this paper we show, by counterexample, that <b>synchronous</b> <b>systems</b> cannot in general be implemented in an asynchronous fashion without either introducing an infinite implementation or changing the causal structure of the system behaviour. Comment: In Proceedings EXPRESS 2011, arXiv: 1108. 407...|$|R
40|$|AbstractThe Cone of Influence Reduction is a {{fundamental}} abstraction technique for reducing the size of models used in symbolic model checking. We develop coalgebraic representations of systems as composites of state transition maps and connectors. These representations include <b>synchronous</b> <b>systems,</b> asynchronous systems, asynchronous systems with synchronization by channels, and those with shared variables, probabilistic <b>synchronous</b> <b>systems</b> and so on. We schematically show the cone of influence reduction using these coalgebraic representations, which give a unified framework for providing the technique for various kinds of systems...|$|R
40|$|Thesis (Ph. D.) [...] Memorial University of Newfoundland, 2000. Computer ScienceBibliography: leaves 82 - 84 <b>Synchronous</b> <b>systems</b> {{are single}} purpose {{multiprocessor}} computing machines, which provide a realistic model of computation capturing {{the concepts of}} pipelining, parallelism and interconnection. The syntax of a <b>synchronous</b> <b>system</b> is specified by the synchronous scheme, which {{is in fact a}} directed, labelled, edge-weighted multi-graph. The vertices and their labels represent functional elements (the combinational logic) with some operation symbols associated with them, while the edges represent interconnections between functional elements. Each edge is weighted and the non- negative integer weight (register count) is the number of registers (clocked memory) placed along the interconnection between two functional elements. These notions allowed the introduction of transformations useful for the design and optimization of synchronous systems: retiming and slowdown. [...] Two <b>synchronous</b> <b>systems</b> are strongly equivalent if they have the same stepwise behavior under all interpretations. Retiming a functional element in a <b>synchronous</b> <b>system</b> means shifting one layer of registers {{from one side of the}} functional element to the other. Retiming equivalence is obtained as the reflexive and transitive closure of this primitive retiming relation. Slowdown is defined as follows: for any system G = V,E,w) and any positive integer c, the c-slow system cG = V,E,w') is the one obtained by multiplying all the register counts in G by c. Slowdown equivalence is obtained as the symmetric and transitive closure of this primitive slowdown relation. Strong retiming equivalence is the join of two basic equivalence relations on <b>synchronous</b> <b>systems,</b> namely strong equivalence and retiming equivalence. Slowdown retiming equivalence is the join of retiming and slowdown equivalence. Strong slowdown retiming equivalence is the join of strong, slowdown and retiming equivalence. It is proved that both slowdown retiming and strong slowdown retiming equivalence of <b>synchronous</b> <b>systems</b> (schemes), are decidable. [...] According to [Leiserson and Saxe, 1983 a, 1983 b], <b>synchronous</b> <b>systems</b> 5 and S' are equivalent if for every sufficiently old configuration c of 5, there exists a configuration d of S' such that when S started in configuration c and S' started in configuration c the two systems exhibit the same behavior. It is proved that two <b>synchronous</b> <b>systems</b> (schemes) are Leiserson equivalent if and only if they are strong retiming equivalent. [...] The semantics of <b>synchronous</b> <b>systems</b> can be specified by algebraic structures called feedback theories. Synchronous schemes and feedback theories have been ax-iomatized equationally in [Bartha, 1987]. Here we extend the existing set of axioms in order to capture strong retiming equivalence. [...] One of the fundamental features of <b>synchronous</b> <b>systems</b> is synchrony, that is, the computation of the network is synchronized by a global (basic) clock. Other, slower clocks can be defined in terms of boolean-valued flows. In order to describe the behavior of schemes with multiple regular clocks, we extend the existing algebra of schemes to include multiclocked schemes, and study the general idea of Leiserson equivalence in the framework of this algebra...|$|R
40|$|<b>Synchronous</b> <b>systems</b> {{are single}} purpose {{multiprocessor}} computing machines, which provide a realistic model of computation capturing {{the concepts of}} pipelining, parallelism and interconnection. The syntax of a <b>synchronous</b> <b>system</b> is specified by the synchronous scheme, which {{is in fact a}} directed, labelled, edge-weighted multi-graph. The vertices and their labels represent functional elements (the combinational logic) with some operation symbols associated with them, while the edges represent interconnections between functional elements. Each edge is weighted and the non- negative integer weight (register count) is the number of registers (clocked memory) placed along the interconnection between two functional elements. These notions allowed the introduction of transformations useful for the design and optimization of synchronous systems: retiming and slowdown. [...] Two <b>synchronous</b> <b>systems</b> are strongly equivalent if they have the same stepwise behavior under all interpretations. Retiming a functional element in a <b>synchronous</b> <b>system</b> means shifting one layer of registers {{from one side of the}} functional element to the other. Retiming equivalence is obtained as the reflexive and transitive closure of this primitive retiming relation. Slowdown is defined as follows: for any system G = (V,E,w) and any positive integer c, the c-slow system cG = (V,E,w') is the one obtained by multiplying all the register counts in G by c. Slowdown equivalence is obtained as the symmetric and transitive closure of this primitive slowdown relation. Strong retiming equivalence is the join of two basic equivalence relations on <b>synchronous</b> <b>systems,</b> namely strong equivalence and retiming equivalence. Slowdown retiming equivalence is the join of retiming and slowdown equivalence. Strong slowdown retiming equivalence is the join of strong, slowdown and retiming equivalence. It is proved that both slowdown retiming and strong slowdown retiming equivalence of <b>synchronous</b> <b>systems</b> (schemes), are decidable. [...] According to [Leiserson and Saxe, 1983 a, 1983 b], <b>synchronous</b> <b>systems</b> S and S' are equivalent if for every sufficiently old configuration c of S, there exists a configuration c' of S' such that when S started in configuration c and S' started in configuration c' the two systems exhibit the same behavior. It is proved that two <b>synchronous</b> <b>systems</b> (schemes) are Leiserson equivalent if and only if they are strong retiming equivalent. [...] The semantics of <b>synchronous</b> <b>systems</b> can be specified by algebraic structures called feedback theories. Synchronous schemes and feedback theories have been ax-iomatized equationally in [Bartha, 1987]. Here we extend the existing set of axioms in order to capture strong retiming equivalence. [...] One of the fundamental features of <b>synchronous</b> <b>systems</b> is synchrony, that is, the computation of the network is synchronized by a global (basic) clock. Other, slower clocks can be defined in terms of boolean-valued flows. In order to describe the behavior of schemes with multiple regular clocks, we extend the existing algebra of schemes to include multiclocked schemes, and study the general idea of Leiserson equivalence in the framework of this algebra...|$|R
40|$|Abstract We {{consider}} {{the problem of}} reaching agreement in distributed systems in which some processes may deviate from their prescribed behavior before they eventually crash. We call this failure model “mortal Byzantine”. After discussing some application examples where this model is justified, we provide matching {{upper and lower bounds}} on the number of faulty processes, and on the required number of rounds in <b>synchronous</b> <b>systems.</b> We then continue our study by varying different system parameters. On the one hand, we {{consider the}} failure model under weaker timing assumptions, namely for partially <b>synchronous</b> <b>systems</b> and asynchronous systems with unreliable failure detectors. On the other hand, we vary the failure model in that we limit the occurrences of faulty steps that actually lead to a crash in <b>synchronous</b> <b>systems...</b>|$|R
3000|$|..., {{which is}} less than the data rate in a <b>synchronous</b> <b>system</b> W/T for which the STBC is {{traditionally}} designed.|$|R
40|$|Asynchronous and partially-synchronous finite {{difference}} schemes are {{investigated for}} the one-dimensional steady-state and nonsteady-state heat equation, respectively. It is shown experimentally that the asynchronous scheme runs {{twice as fast}} as the <b>parallel</b> <b>synchronous</b> scheme. For relatively small values of time levels, however, the asynchronous scheme produces the least accurate results, while the partially-asynchronous scheme is almost as accurate as its synchronous counterpart...|$|R
40|$|The thesis {{describes}} {{a mathematical model}} of an electric drive composed of two <b>parallel</b> <b>synchronous</b> motors. Besides the equations there is mentioned a block scheme in the MATLAB program and simulation results of the starting of two synchronous motors supplied from the network. The next stage of the dissertation work {{is to create a}} mathematical model of synchronous motors supplied by one current type frequency converter. The model and the simulation of two motors with a source that would change the current and the frequency by use PI controller are presented. This work also includes the description of a model with constant current source and a model with the possibility to change current and frequency of supply. The description of a simulation software developed for the efficient simulation of two <b>parallel</b> <b>synchronous</b> motors with the same or different initial conditions supplied by one current type frequency converter is given. Available from STL Prague, CZ / NTK - National Technical LibrarySIGLECZCzech Republi...|$|R
40|$|Most machine {{learning}} and {{deep neural network}} algorithms rely on certain iterative algorithms to optimise their utility/cost functions, e. g. Stochastic Gradient Descent. In distributed learning, the networked nodes have to work collaboratively to update the model parameters, and the way how they proceed {{is referred to as}} <b>synchronous</b> <b>parallel</b> design (or barrier control). <b>Synchronous</b> <b>parallel</b> protocol is the building block of any distributed learning framework, and its design has direct impact on the performance and scalability of the system. In this paper, we propose a new barrier control technique - Probabilistic <b>Synchronous</b> <b>Parallel</b> (PSP). Com- paring to the previous Bulk <b>Synchronous</b> <b>Parallel</b> (BSP), Stale <b>Synchronous</b> <b>Parallel</b> (SSP), and (Asynchronous Parallel) ASP, the proposed solution e ectively improves both the convergence speed and the scalability of the SGD algorithm by introducing a sampling primitive into the system. Moreover, we also show that the sampling primitive can be applied atop of the existing barrier control mechanisms to derive fully distributed PSP-based <b>synchronous</b> <b>parallel.</b> We not only provide a thorough theoretical analysis 1 on the convergence of PSP-based SGD algorithm, but also implement a full-featured distributed learning framework called Actor and perform intensive evaluation atop of it...|$|R
50|$|The {{flywheel}} {{effect may}} be desirable, {{such as in}} phase-locked loops used in <b>synchronous</b> <b>systems,</b> or undesirable, such as in voltage-controlled oscillators.|$|R
40|$|International audienceThis article {{presents}} {{the benefits of}} asynchronous <b>systems</b> versus <b>synchronous</b> <b>systems</b> in term of energy reduction {{in the context of}} embedded systems and in particular for telecom equipments such as mobile communicating objects. The electrical consumption reduction is obtained at the hardware and software levels. The shutdown technique and the dynamic voltage scaling for asynchronous systems are studied and compared to <b>synchronous</b> <b>systems.</b> Finally, a power management policy is proposed for asynchronous microprocessors processing periodic and sporadic tasks...|$|R
40|$|APSS, a {{proactive}} secret sharing (PSS) protocol for asynchronous systems, is derived and proved correct. A PSS protocol enables {{a set of}} secret shares to be periodically refreshed with a new, independent set, thereby thwarting so-called mobile adversary attacks. APSS tolerates certain attacks that PSS protocols for <b>synchronous</b> <b>systems</b> cannot, because protocols for asynchronous systems are inherently less vulnerable to denial of service attacks, which slow processor execution or impede message delivery and thus violate the defining assumptions of a <b>synchronous</b> <b>system...</b>|$|R
40|$|We {{present a}} general {{approach}} for modeling <b>synchronous</b> component-based <b>systems.</b> These are <b>systems</b> of <b>synchronous</b> components strongly synchronized {{by a common}} action that initiates steps of each component. We propose a general model for <b>synchronous</b> <b>systems.</b> Steps are described by acyclic Petri nets equipped with data and priorities. Petri nets are used to model concurrent flow of computation. Priorities are instrumental for enforcing run-to-completion in the execution of a step. We study a class of well-triggered <b>synchronous</b> <b>systems</b> which are by construction deadlock-free and their computation within a step is confluent. For this class, the behavior of components is modeled by modal flow graphs. These are acyclic graphs representing three different types of dependency between two events p and q: strong dependency (p must follow q), weak dependency (p may follow q), conditional dependency (if both p and q occur then p must follow q). We propose a translation of Lustre into well-triggered <b>synchronous</b> <b>systems.</b> This translation is modular and exhibits not only data-flow connections between nodes but also their synchronization by using clocks...|$|R
40|$|In {{synchronous}} rewriting, the {{productions of}} two rewriting systems are paired and applied synchronously in the derivation {{of a pair}} of strings. We present a new <b>synchronous</b> rewriting <b>system</b> and argue that it can handle certain phenomena that are not covered by existing <b>synchronous</b> <b>systems.</b> We also prove some interesting formal/computational properties of our system. ...|$|R
30|$|The {{simplified}} equivalent {{models can}} only be used to study effects of wind power on EOMs of <b>synchronous</b> <b>systems,</b> rather than the stability of WT itself.|$|R
50|$|Metastable {{states are}} {{inherent}} features of asynchronous digital systems, and of systems {{with more than}} one independent clock domain. In self-timed asynchronous systems, arbiters are designed to allow the system to proceed only after the metastability has resolved, so the metastability is a normal condition, not an error condition.In <b>synchronous</b> <b>systems</b> with asynchronous inputs, synchronizers are designed to make the probability of a synchronization failure acceptably small. Metastable states are avoidable in fully <b>synchronous</b> <b>systems</b> when the input setup and hold time requirements on flip-flops are satisfied.|$|R
40|$|The {{demand of}} {{detectors}} able to efficiently mitigate crosstalk for large CDMA systems {{has led to}} the analysis of reduced rank detectors, especially multistage detectors. The increasing interest for this class of detectors is due to at least two reasons. Firstly, a low number of stages is sufficient for near-LMMSE performance, even as the system size grows large. Secondly, implementations with the same order of complexity of the single user matched filter are possible with random spreading using asymptotic weighting. However, the literature for linear detectors is mainly focused on <b>synchronous</b> <b>systems</b> and the multistage detectors have not been object of analysis in asynchronous scenarios yet. As known, the performance of the linear MMSE detector are lower in symbol asynchronous but chip <b>synchronous</b> <b>systems</b> than in <b>synchronous</b> <b>systems</b> due to the finite observation window. We propose the structure of a multistage detector whose performance in chip synchronous but chip synchronous scenarios equals the one of the multistage detector for <b>synchronous</b> <b>systems.</b> For completely asynchronous systems we adopt a fractionally spaced multistage detector with the structure mentioned above. A method to determine the asymptotic weights in case of fractionally spaced data input is presented and the performance of the corresponding asymptotic detector are assessed...|$|R
40|$|Immediately after power-up, <b>synchronous</b> {{distributed}} <b>systems</b> {{need some}} time until essential timing properties, which are required to operate correctly, are established. We say that <b>synchronous</b> <b>systems</b> are initially in asynchronous operation. In this paper, we present an algorithm and ar-chitectural guidelines that assure the transition from asyn-chronous to synchronous operation within a bounded dura-tion even in case of failures. ...|$|R
