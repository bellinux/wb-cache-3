330|1087|Public
25|$|Hardware {{exception}} {{mechanisms are}} processed by the CPU. It {{is intended to}} support error detection and redirects the <b>program</b> <b>flow</b> to error handling service routines. The state before the exception is saved on the stack.|$|E
25|$|Loop {{counters}} {{change with}} each iteration of a loop, providing a unique value {{for each individual}} iteration. The loop counter is used to decide when the loop should terminate and for the <b>program</b> <b>flow</b> to continue to the next instruction after the loop.|$|E
2500|$|Canonical {{flowchart}} symbols: The graphical aide {{called a}} flowchart offers {{a way to}} describe and document an algorithm (and a computer program of one). Like <b>program</b> <b>flow</b> of a Minsky machine, a flowchart always starts {{at the top of}} a page and proceeds down. Its primary symbols are only four: the directed arrow showing <b>program</b> <b>flow,</b> the rectangle (SEQUENCE, GOTO), the diamond (IF-THEN-ELSE), and the dot (OR-tie). The Böhm–Jacopini canonical structures are made of these primitive shapes. Sub-structures can [...] "nest" [...] in rectangles, but only if a single exit occurs from the superstructure. The symbols, and their use to build the canonical structures, are shown in the diagram.|$|E
5000|$|... {{inversion}} of control: In a framework, unlike in libraries or in standard user applications, the overall <b>program's</b> <b>flow</b> of control is not {{dictated by the}} caller, but by the framework.|$|R
5000|$|Jorgensen's {{more recent}} {{textbooks}} restate {{it in terms}} of a <b>program's</b> <b>flow</b> graph (called a [...] "program graph" [...] in that textbook). First define some preliminary notions: chain and a maximal chain. A chain is defined as a path in which: ...|$|R
50|$|Connie Chung Tonight is an American {{television}} newsmagazine {{hosted by}} Connie Chung. The hour-long series premiered on CNN on June 24, 2002. At first {{the show was}} live, then previously taped in a move the network hoped would improve the <b>program's</b> <b>flow.</b>|$|R
2500|$|A {{control break}} is a value change {{detection}} method used within ordinary loops to trigger processing {{for groups of}} values. [...] Values are monitored within the loop and a change diverts <b>program</b> <b>flow</b> to {{the handling of the}} group event associated with them.|$|E
2500|$|Alternative {{approaches}} to exception handling in software are error checking, which maintains normal <b>program</b> <b>flow</b> with later explicit checks for contingencies reported using special return values or some auxiliary global {{variable such as}} C's [...] or floating point status flags; or input validation to preemptively filter exceptional cases.|$|E
2500|$|Minsky {{describes}} a more congenial variation of Lambek's [...] "abacus" [...] model in his [...] "Very Simple Bases for Computability". Minsky's machine proceeds sequentially through its five (or six, {{depending on how}} one counts) instructions, unless either a conditional IF–THEN GOTO or an unconditional GOTO changes <b>program</b> <b>flow</b> out of sequence. Besides HALT, Minsky's machine includes three assignment (replacement, substitution) operations: ZERO (e.g. the contents of location replaced by 0: L ← 0), SUCCESSOR (e.g. L ← L+1), and DECREMENT (e.g. L ← L − 1). Rarely must a programmer write [...] "code" [...] with such a limited instruction set. But Minsky shows (as do Melzak and Lambek) that his machine is Turing complete with only four general types of instructions: conditional GOTO, unconditional GOTO, assignment/replacement/substitution, and HALT.|$|E
5000|$|In {{television}} <b>programming,</b> <b>flow</b> is how {{channels and}} networks {{try to hold}} their audience from program to program, or from one segment of a program to another. Thus, it is the [...] "flow" [...] of television material from one element to the next.|$|R
30|$|Algorithms and <b>programs</b> Information <b>flows,</b> debug operations, etc.|$|R
40|$|The {{increased}} demands {{placed on}} solution propulsion by <b>programmed</b> <b>flow</b> systems, such as sequential injection analysis, lab-on-value technology, bead injection and multi-commutation, has highlighted {{the inability of}} many conventional pumps to generate a smooth, consistent flow. A number of researchers have examined ways to overcome the inadvertent, uncontrolled pulsation caused by the mechanical action of peristaltic pumps. In contrast, we have developed instruments that exploit {{the characteristics of a}} reproducible pulsed flow of solution. In this paper, we discuss our instrumental approaches and some applications that have benefited from the use of a reproducible pulsed flow rather than the traditional linear flow approach. To place our approach {{in the context of the}} continuously developing field of flow analysis, an overview of other <b>programmed</b> <b>flow</b> systems is also presented. <br /...|$|R
50|$|Simulates <b>program</b> <b>flow</b> {{and logic}} using 3D {{characters}} and interaction.|$|E
5000|$|A RETURN command resumes <b>program</b> <b>flow</b> {{from the}} point at which GOSUB was invoked.|$|E
5000|$|... reduced {{requirement}} to test return codes individually (if used at call site to determine subsequent <b>program</b> <b>flow)</b> ...|$|E
5000|$|The archetypical {{example of}} a boxology is a {{corporate}} [...] "org chart", which describes lines of control through the corporation. Other boxologies include <b>programming</b> <b>flow</b> charts, system-level circuit diagrams for designing large complex circuits, and even economic models. Feynman diagrams are useful because they reduce the complicated mathematics of quantum mechanics to a simple boxology of particle interactions.|$|R
5000|$|VisSim viewer - {{graphically}} <b>programmed</b> data <b>flow</b> diagrams for {{simulation of}} dynamical systems ...|$|R
40|$|We {{consider}} {{the problem of}} gathering data from an energy-constrained, multi-hop sensor network to a single location. Specifically, we aim to balance {{the total amount of}} data received from the network against a requirement of fairness between the sensor. The task is formulated as two kinds of linear <b>programs</b> (<b>flow</b> and packing). In the packing problem form, it can be efficiently approximated. ...|$|R
5000|$|Software for {{industrial}} robots consists of data objects and lists of instructions, known as <b>program</b> <b>flow</b> (list of instructions). For example, ...|$|E
5000|$|Statements, {{which may}} have a {{persistent}} effect on schemata and data, or may control transactions, <b>program</b> <b>flow,</b> connections, sessions, or diagnostics.|$|E
50|$|An FSMD is {{a digital}} system {{composed}} of a finite-state machine, which controls the <b>program</b> <b>flow,</b> and a datapath, which performs data processing operations.|$|E
5000|$|Spatial {{interaction}} {{models are}} aggregate and top-down: they specify an overall governing relationship for flow between locations. This characteristic is also shared by urban models {{such as those}} based on mathematical <b>programming,</b> <b>flows</b> among economic sectors, or bid-rent theory. An alternative modeling perspective is to represent the system at the highest possible level of disaggregation and study the bottom-up emergence of complex patterns and relationships from behavior and interactions at the individual level.|$|R
5000|$|Underwriting credit pods must [...] "mirror the {{production}} {{values of the}} <b>program</b> and <b>flow</b> smoothly with <b>program</b> content and other packaging elements." ...|$|R
25|$|From the {{processing}} point of view, hardware interrupts {{are similar to}} resumable exceptions, though they are typically unrelated to the user <b>program's</b> control <b>flow.</b>|$|R
50|$|The {{scripting}} language is an imperative language, lacking most <b>program</b> <b>flow</b> control structures, but containing many features familiar to programmers, including variables, distinct datatypes, conditionals, and complex expressions.|$|E
50|$|The Control Structure Diagram {{automatically}} {{documents the}} <b>program</b> <b>flow</b> within the source code and adds indentation with graphical symbols. Thereby the source code becomes visibly structured without sacrificing space.|$|E
50|$|Control PanelControl {{panel of}} CER-12 allowed the {{operator}} {{to control and}} alter <b>program</b> <b>flow</b> and/or to eliminate errors detected by error-detection circuitry. It features a number of indicators and switches.|$|E
5000|$|Sometimes called MakerFlow {{or simply}} Flow, {{this is the}} {{component}} that allows the complete independence of the code, since the actions and business rules will be defined using a 100% visual approach, free from specifications of a <b>programming</b> language.The <b>programming</b> <b>flow</b> path allows only logic, allowing the team to concentrate efforts on implementing {{the details of what}} really matters to the customer: the business rules and not other details of the development software process, but must be followed reliable and stable application ...|$|R
5000|$|A {{statement}} might assign {{an expression}} to a variable {{or use the}} value of a variable to alter the <b>program's</b> control <b>flow</b> - for example: ...|$|R
5000|$|Event-driven {{programming}} - <b>program</b> control <b>flow</b> {{is determined}} by events, such as sensor inputs or user actions (mouse clicks, key presses) or messages from other programs or threads.|$|R
5000|$|The {{programming}} {{capabilities of}} the TI-57 were similar to a primitive macro assembler.Any keystroke could be stored, along with some simple <b>program</b> <b>flow</b> control commands and conditional tests. These included: ...|$|E
5000|$|Weighted Micro Function Points - One of {{the newer}} models (2009) which adjusts {{function}} points using weights derived from <b>program</b> <b>flow</b> complexity, operand and operator vocabulary, object usage, and algorithm.|$|E
5000|$|Program trace ... Branch tracing {{compresses}} program execution data, by emitting messages at branch or exception instructions only. Trace analysis reconstructs the <b>program</b> <b>flow</b> using a local {{image of}} code memory contents.|$|E
30|$|To better {{understand}} how to track implicit taint, the following will explain the privacy leakage method. Based on the implicit control flow analysis method of SSA form: (1) in the <b>program</b> control <b>flow</b> graph (CFG), there contains control dependence of code in judging block and assignment statements; and (2) calculate the point of code block of assignment statement and convert the <b>program</b> number <b>flow</b> into the form of SSA, in point count value of multiple versions of code block variables, finally according {{to the value of}} each variable to determine taint attribute of variables.|$|R
40|$|Parallel {{debugging}} {{is complex}} and difficult. Complex because the programmer {{has to deal with}} multiple <b>program</b> <b>flows</b> and process interactions, and difficult due to the very limited choice on effective and easy-touse debugging tools for parallel programming. Simple and necessary features for parallel debugging are absent even from commercial debuggers, such as a record-replay feature, that allows to re-execute multiple times a parallel application assuring that during each re-execution the internal race conditions are solved in the same way they were in the first time. Some work has been done on record [...] ...|$|R
40|$|The {{changing}} political sphere in 1989 and {{the subsequent}} 2004 European Union accession {{had a profound impact}} on Poland’s economic, political and social spheres. Both events are considered to have marked Poland’s ‘return to Europe’ and strengthened the relations with its Western neighbours. This article examines the changing patterns of television fiction <b>programming</b> <b>flow</b> in Poland in the post-Soviet era, exploring the impact of those two events on Poland’s audiovisual sector. This article therefore assesses whether, and if so – how, this metaphorical ‘return to Europe’ is manifested on Polish television screens. </span...|$|R
