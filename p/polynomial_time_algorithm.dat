2646|10000|Public
5|$|After many {{improvements}} to these results {{it is now}} known that, for every real number , {{there can be no}} <b>polynomial</b> <b>time</b> <b>algorithm</b> that approximates the maximum clique to within a factor better than , unless P = NP.|$|E
5|$|Although no <b>polynomial</b> <b>time</b> <b>algorithm</b> {{is known}} for this problem, more {{efficient}} algorithms than the brute-force search are known. For instance, the Bron–Kerbosch algorithm {{can be used to}} list all maximal cliques in worst-case optimal time, and it is also possible to list them in polynomial time per clique.|$|E
5|$|In some cases, these {{algorithms}} can {{be extended}} to other, non-perfect, classes of graphs as well. For instance, in a circle graph, the neighborhood of each vertex is a permutation graph, so a maximum clique in a circle graph can be found by applying the permutation graph algorithm to each neighborhood. Similarly, in a unit disk graph (with a known geometric representation), there is a <b>polynomial</b> <b>time</b> <b>algorithm</b> for maximum cliques based on applying the algorithm for complements of bipartite graphs to shared neighborhoods of pairs of vertices.|$|E
40|$|We {{consider}} the boolean {{complexity of the}} decomposition of matrix algebras over C and R with bases consisting of matrices over a number field. Deterministic <b>polynomial</b> <b>time</b> <b>algorithms</b> for the decomposition of semi-simple algebras over these fields and Las Vegas <b>polynomial</b> <b>time</b> <b>algorithms</b> for the decomposition of simple algebras are obtained...|$|R
40|$|Summary. Many {{real-world}} problems require graphs of {{such large}} size that <b>polynomial</b> <b>time</b> <b>algorithms</b> are too costly {{as soon as}} their runtime is superlinear. Examples include problems in VLSI-design or problems in bioinformatics. For such problems the question arises: What is the best solution that can be obtained in linear time? We survey linear <b>time</b> approximation <b>algorithms</b> for some classical problems from combinatorial optimization, e. g. matchings and branchings. For many combinatorial optimization problems arising from real-world applications, efficient, i. e., <b>polynomial</b> <b>time</b> <b>algorithms</b> are known for computing an optimum solution. However, there exist several applications for which the input size can easily exceed 10 9. In such cases <b>polynomial</b> <b>time</b> <b>algorithms</b> with a runtime that is quadrati...|$|R
5000|$|Formally, {{a digital}} {{signature}} scheme is a triple of probabilistic <b>polynomial</b> <b>time</b> <b>algorithms,</b> (G, S, V), satisfying: ...|$|R
25|$|Suppose that {{polynomial}} sized circuits for SAT {{not only}} exist, {{but also that}} they could be constructed by a <b>polynomial</b> <b>time</b> <b>algorithm.</b> Then this supposition implies that SAT itself could be solved by a <b>polynomial</b> <b>time</b> <b>algorithm</b> that constructs the circuit and then applies it. That is, efficiently constructible circuits for SAT would lead to a stronger collapse, P = NP.|$|E
25|$|There is a <b>polynomial</b> <b>time</b> <b>algorithm</b> {{for solving}} the graph {{automorphism}} problem for graphs where vertex degrees are bounded by a constant.|$|E
25|$|If {{the input}} size is n, the time taken can be {{expressed}} {{as a function of}} n. Since the time taken on different inputs of the same size can be different, the worst-case time complexity T(n) is defined to be the maximum time taken over all inputs of size n. If T(n) is a polynomial in n, then the algorithm {{is said to be a}} <b>polynomial</b> <b>time</b> <b>algorithm.</b> Cobham's thesis says that a problem can be solved with a feasible amount of resources if it admits a <b>polynomial</b> <b>time</b> <b>algorithm.</b>|$|E
40|$|In this paper, we {{consider}} the problem of solving integer range constraints. In particular, we present {{the first set of}} <b>polynomial</b> <b>time</b> <b>algorithms</b> for a general class of integer range constraints. In addition, we show hardness and decidability results on satisfiability of various natural extensions of the basic constraint language. We believe these <b>polynomial</b> <b>time</b> <b>algorithms</b> are useful in practice for implementing scalable program analysis and verification tools...|$|R
50|$|<b>Polynomial</b> <b>time</b> <b>algorithms</b> {{are known}} for {{determining}} whether the derived graph of a -voltage graph contains any directed cycles.|$|R
25|$|In some contexts, {{especially}} in optimization, one differentiates between strongly <b>polynomial</b> <b>time</b> and weakly <b>polynomial</b> <b>time</b> <b>algorithms.</b> These two concepts are only relevant if the inputs to the algorithms consist of integers.|$|R
25|$|The Robertson–Seymour theorem has an {{important}} consequence in computational complexity, due to the proof by Robertson and Seymour that, for each fixed graph G, there is a <b>polynomial</b> <b>time</b> <b>algorithm</b> for testing whether larger graphs have G as a minor. The running time of this algorithm can be expressed as a cubic polynomial {{in the size of}} the larger graph (although there is a constant factor in this polynomial that depends superpolynomially on the size of G), which has been improved to quadratic time by Kawarabayashi, Kobayashi, and Reed. As a result, for every minor-closed family F, there is <b>polynomial</b> <b>time</b> <b>algorithm</b> for testing whether a graph belongs to F: simply check, for each of the forbidden minors for F, whether the given graph contains that forbidden minor.|$|E
25|$|Similarly, a <b>polynomial</b> <b>time</b> <b>algorithm</b> is {{not always}} practical. If its running time is, say, n15, it is {{unreasonable}} to consider it efficient and it is still useless except on small instances. Indeed, in practice even n3 or n2 algorithms are often impractical on realistic sizes of problems.|$|E
25|$|An {{algorithm}} {{is said to}} run in quasilinear time (also referred to as log-linear time) if T(n) = O(n logk n) for some positive constant k; linearithmic time is the case knbsp&=nbsp&1. Using soft O notation these algorithms are Õ(n). Quasilinear time algorithms are also O(n1+ε) for every constant ε > 0, and thus run faster than any <b>polynomial</b> <b>time</b> <b>algorithm</b> whose time bound includes a term n'c for any cnbsp&>nbsp&1.|$|E
500|$|Under {{the same}} assumption, {{there are also}} {{essentially}} no other properties {{that can be used}} to get <b>polynomial</b> <b>time</b> <b>algorithms.</b> This is formalized as follows: ...|$|R
25|$|Because distance-hereditary graphs are circle graphs, they inherit <b>polynomial</b> <b>time</b> <b>algorithms</b> for circle graphs; for instance, it is {{possible}} determine in <b>polynomial</b> <b>time</b> the treewidth of any circle graph and therefore of any distance-hereditary graph.|$|R
2500|$|... and [...] {{describe}} <b>polynomial</b> <b>time</b> <b>algorithms</b> for coloring any graph with [...] colors, {{meeting the}} bound given by Vizing's theorem; see Misra & Gries edge coloring algorithm.|$|R
25|$|Because {{the problem}} of testing whether a graph is class 1 is NP-complete, there is no known <b>polynomial</b> <b>time</b> <b>algorithm</b> for edge-coloring every graph with an optimal number of colors. Nevertheless, a number of {{algorithms}} have been developed that relax {{one or more of}} these criteria: they only work on a subset of graphs, or they do not always use an optimal number of colors, or they do not always run in polynomial time.|$|E
25|$|For graph invariants {{with the}} {{property}} that, for each k, the graphs with invariant at most k are minor-closed, the same method applies. For instance, by this result, treewidth, branchwidth, and pathwidth, vertex cover, and the minimum genus of an embedding are all amenable to this approach, and for any fixed k {{there is a}} <b>polynomial</b> <b>time</b> <b>algorithm</b> for testing whether these invariants are at most k, in which the exponent in the running time of the algorithm {{does not depend on}} k. A problem with this property, that it can be solved in polynomial time for any fixed k with an exponent that does not depend on k, is known as fixed-parameter tractable.|$|E
25|$|However, other {{cryptographic}} algorithms do {{not appear}} to be broken by those algorithms. Some public-key algorithms are based on problems other than the integer factorization and discrete logarithm problems to which Shor's algorithm applies, like the McEliece cryptosystem based on a problem in coding theory. Lattice-based cryptosystems are also not known to be broken by quantum computers, and finding a <b>polynomial</b> <b>time</b> <b>algorithm</b> for solving the dihedral hidden subgroup problem, which would break many lattice based cryptosystems, is a well-studied open problem. It has been proven that applying Grover's algorithm to break a symmetric (secret key) algorithm by brute force requires time equal to roughly 2n/2 invocations of the underlying cryptographic algorithm, compared with roughly 2n in the classical case, meaning that symmetric key lengths are effectively halved: AES-256 would have the same security against an attack using Grover's algorithm that AES-128 has against classical brute-force search (see Key size). Quantum cryptography could potentially fulfill some of the functions of public key cryptography.|$|E
25|$|The {{characterizations}} of well-covered graphs with girth five or more, and of well-covered graphs that are 3-regular, {{also lead to}} efficient <b>polynomial</b> <b>time</b> <b>algorithms</b> to recognize these graphs.|$|R
50|$|This {{decision}} problem {{is known to}} be NP-complete; it is one of Karp's 21 NP-complete problems. There exist though <b>polynomial</b> <b>time</b> <b>algorithms</b> for that problem for dense hypergraphs.|$|R
5000|$|The {{existence}} of such algorithm for arbitrary groups is open. Quantum <b>polynomial</b> <b>time</b> <b>algorithms</b> exist for certain subclasses of groups, such as semi-direct products of some Abelian groups.|$|R
25|$|In {{computational}} complexity theory, several complexity {{classes have}} been defined {{in connection with}} implicit graphs, defined as above by a rule or algorithm for listing the neighbors of a vertex. For instance, PPA is the class of problems in which one is given as input an undirected implicit graph (in which vertices are -bit binary strings, with a <b>polynomial</b> <b>time</b> <b>algorithm</b> for listing the neighbors of any vertex) and a vertex of odd degree in the graph, and must find a second vertex of odd degree. By the handshaking lemma, such a vertex exists; finding one {{is a problem in}} NP, but the problems that can be defined in this way may not necessarily be NP-complete, as it is unknown whether PPA=NP. PPAD is an analogous class defined on implicit directed graphs that has attracted attention in algorithmic game theory because it contains the problem of computing a Nash equilibrium. The problem of testing reachability of one vertex to another in an implicit graph may also be used to characterize space-bounded nondeterministic complexity classes including NL (the class of problems that may be characterized by reachability in implicit directed graphs whose vertices are -bit bitstrings), SL (the analogous class for undirected graphs), and PSPACE (the class of problems that may be characterized by reachability in implicit graphs with polynomial-length bitstrings). In this complexity-theoretic context, the vertices of an implicit graph may represent the states of a nondeterministic Turing machine, and the edges may represent possible state transitions, but implicit graphs may also be used to represent many other types of combinatorial structure. PLS, another complexity class, captures the complexity of finding local optima in an implicit graph.|$|E
500|$|... {{describes}} a <b>polynomial</b> <b>time</b> <b>algorithm</b> that finds a clique of size [...] in any graph that has clique number [...] for any constant [...] By using this algorithm when the clique number {{of a given}} input graph is between [...] and , switching to a different algorithm of [...] for graphs with higher clique numbers, and choosing a two-vertex clique if both algorithms fail to find anything, Feige provides an approximation algorithm that finds a clique {{with a number of}} vertices within a factor of [...] of the maximum. Although the approximation ratio of this algorithm is weak, it is the best known to date. The results on hardness of approximation described below suggest {{that there can be no}} approximation algorithm with an approximation ratio significantly less than linear.|$|E
2500|$|An {{important}} {{consequence of}} this theorem is that if there exists a deterministic <b>polynomial</b> <b>time</b> <b>algorithm</b> for solving Boolean satisfiability, then every NP problem can be solved by a deterministic <b>polynomial</b> <b>time</b> <b>algorithm.</b> [...] The question of whether such an algorithm for Boolean satisfiability exists is thus equivalent to the P versus NP problem, which is widely considered the most important unsolved problem in theoretical computer science.|$|E
40|$|We present new <b>polynomial</b> <b>time</b> <b>algorithms</b> for {{inference}} {{problems in}} Bayesian networks (BNs) when restricted to instances that satisfy {{the following two}} conditions: they have bounded treewidth and the conditional probability table (CPT) at each node is specified concisely using an r-symmetric function for some constant r. Our <b>polynomial</b> <b>time</b> <b>algorithms</b> work directly on the unmoralized graph. Our results significantly ex-tend known results regarding inference problems on treewidth bounded BNs to a larger class of problem instances. We also show that relaxing either of the conditions used by our algorithms leads to computational intractability...|$|R
5000|$|Then for all {{non-uniform}} probabilistic <b>polynomial</b> <b>time</b> <b>algorithms</b> that output [...] and [...] {{of increasing}} length k, {{the probability that}} [...] and [...] is a negligible function in k.|$|R
5000|$|Schnorr, in 1987, {{showed that}} {{deterministic}} <b>polynomial</b> <b>time</b> <b>algorithms</b> can {{solve the problem}} for [...] Ajtai et al. showed that probabilistic algorithms can achieve a slightly better approximation factor of [...]|$|R
2500|$|The {{selection}} sort sorting algorithm on n integers performs [...] operations for some constant A. Thus it runs in time [...] {{and is a}} <b>polynomial</b> <b>time</b> <b>algorithm.</b>|$|E
2500|$|Quasi-polynomial time {{algorithms}} typically {{arise in}} reductions from an NP-hard problem to another problem. For example, one can take {{an instance of}} an NP hard problem, say 3SAT, and convert it to an instance of another problem B, but {{the size of the}} instance becomes [...] In that case, this reduction does not prove that problem B is NP-hard; this reduction only shows that there is no <b>polynomial</b> <b>time</b> <b>algorithm</b> for B unless there is a quasi-polynomial time algorithm for 3SAT (and thus all of NP). Similarly, there are some problems for which we know quasi-polynomial time algorithms, but no <b>polynomial</b> <b>time</b> <b>algorithm</b> is known. Such problems arise in approximation algorithms; a famous example is the directed Steiner tree problem, for which there is a quasi-polynomial time approximation algorithm achieving an approximation factor of [...] (n being the number of vertices), but showing the existence of such a <b>polynomial</b> <b>time</b> <b>algorithm</b> is an open problem.|$|E
2500|$|... 2002– Manindra Agrawal, Nitin Saxena, and Neeraj Kayal of IIT Kanpur {{present an}} {{unconditional}} deterministic <b>polynomial</b> <b>time</b> <b>algorithm</b> {{to determine whether}} a given number is prime (the AKS primality test).|$|E
40|$|In the {{probabilistic}} {{analysis of}} algorithms for the Satisfiability problem, the random-clausewidth model {{is one of}} the most popular for generating random instances. This model is parameterized and it is not difficult to show that virtually the entire parameter space is covered by a collection of <b>polynomial</b> <b>time</b> <b>algorithms</b> that find solutions to random instances with probability tending to 1 as instance size increases. But finding a collection of <b>polynomial</b> average <b>time</b> <b>algorithms</b> that cover the parameter space has proved much harder and such results have spanned approximately ten years. However, it can now be said that virtually the entire parameter space is covered by <b>polynomial</b> average <b>time</b> <b>algorithms.</b> This paper relates dominant, exploitable properties of random formulas over the parameter space to mechanisms of <b>polynomial</b> average <b>time</b> <b>algorithms.</b> The probabilistic discussion of such properties is new; main average-case results over the last ten years are reviewed. 1 Intr [...] ...|$|R
30|$|Since it is NP-hard to find optimal {{number of}} {{disjoint}} paths with balanced length, {{we focus on}} developing efficient heuristic and <b>polynomial</b> <b>time</b> <b>algorithms</b> to make agents work effectively in a WSN and produce near-optimal itineraries.|$|R
40|$|This {{paper is}} about {{planning}} {{in one of}} the simplest domains: the Blocks World (BW). We examine and compare some known <b>polynomial</b> <b>time</b> <b>algorithms</b> for BW planning and contribute ideas for getting closer to optimality while remaining polynomially bounded. In some cases we are able to improve the known complexity bounds of the <b>polynomial</b> <b>time</b> <b>algorithms.</b> We note that plans produced by the best of these algorithms are free of redundant moves, so although not necessarily optimal they are minimal in a reasonable sense. Our experimental investigation of the behaviour of these algorithms, also leads to observations and conjectures about the mathematical structure of BW...|$|R
