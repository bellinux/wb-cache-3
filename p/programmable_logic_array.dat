114|3044|Public
5000|$|Manhattan wiring {{is often}} used to {{represent}} a <b>programmable</b> <b>logic</b> <b>array.</b>|$|E
5000|$|The Signetics 82S100 FPLA (Field <b>Programmable</b> <b>Logic</b> <b>Array)</b> was {{the first}} commercially {{successful}} user programmable logic device, the forerunner of the modern FPGA.|$|E
50|$|A <b>{{programmable}}</b> <b>logic</b> <b>array</b> (PLA) has a programmable AND gate array, which {{links to}} a programmable OR gate array, which {{can then be}} conditionally complemented to produce an output.|$|E
5000|$|The C65 also {{contains}} {{one or two}} <b>programmable</b> <b>logic</b> <b>arrays</b> depending on the version: ...|$|R
50|$|Some of the industry's {{foundational}} {{concepts and}} technologies for <b>programmable</b> <b>logic</b> <b>arrays,</b> gates, and <b>logic</b> blocks are founded in patents awarded to David W. Page and LuVerne R. Peterson in 1985.|$|R
40|$|A {{design of}} multiple-valued {{circuits}} {{based on the}} multiple-valued <b>programmable</b> <b>logic</b> <b>arrays</b> (MV PLA’s) by generalized disjunctive decomposition is presented. Main subjects are 1) Generalized disjunctive decomposition of multiple-valued functions using multiple-terminal multiplevalued decision diagrams (MTMDD’s); 2) Realization of functions by MV PLA-based combinatorial circuits...|$|R
50|$|The I/O pins {{could be}} used as an 8-bit I/O port or {{programmed}} to generate enable signals for extra RAM, ROM or I/O ports. This was achieved by mask-programming a <b>Programmable</b> <b>Logic</b> <b>Array</b> in the 2656.|$|E
50|$|Many early systems {{used some}} form of an early <b>programmable</b> <b>logic</b> <b>array</b> to create a video system, {{examples}} include the ZX Spectrum and ZX-81 systems and Elektronika BK-0010 but there were many others. Early implementations are often very primitive, but later implementations could result in fairly advanced video systems {{like the one in}} the SAM Coupé.|$|E
5000|$|The control {{store on}} some {{minicomputers}} was {{one or more}} <b>programmable</b> <b>logic</b> <b>array</b> chips. The [...] "blank" [...] PLA from the chip manufacturer came with a diode matrix or transistor matrix with a diode (or transistor) at every intersection. A person would microprogram the control store on these computers by destroying the unwanted connections at selected intersections.|$|E
40|$|Abstract — The paper {{deals with}} {{designing}} fault tolerant finite state machines (FSMs) by nanoelectronic <b>programmable</b> <b>logic</b> <b>arrays</b> (PLAs). Two main critical {{parameters of the}} fault tolerant nano-PLAs, the area {{and the number of}} crosspoint devices, are considered as optimization criteria for the synthesis. The paper introduces a method for synthesizing fault tolerant nano-PLA based FSMs. The method is based on decomposing an initial PLA description of the FSM into a three interacting portions. The proposed solution provides significant reduction of the area without meaningful increasing of a number of crosspoint devices in comparison with known solutions and provides a trade-off between the area and the number of devices in designing FSMs by PLAs. <b>Programmable</b> <b>logic</b> <b>arrays</b> (PLAs) have a bright history i...|$|R
40|$|Considered a "manual" {{method of}} design {{automation}} systems using <b>programmable</b> <b>logic</b> <b>arrays</b> (PLA), {{which is based}} on the six stages of designing (on the algorithm of the system before its construction and programming), using automata theory and computer logic. Application of the method is demonstrated on a concrete example. ?????????? ???? "??????" ????? ?????????????? ?????? ?????????? ? ??????????? ??????????????? ?????????? ?????? (???), ?????????? ?? ????? ?????? ?????????????? (?? ????????? ?????? ??????? ? ?? ?????????? ? ????????????????), ????????? ?????? ????????? ? ???????????? ??????. ?????????? ?????? ?????????????????? ?? ?????????? ???????...|$|R
40|$|Abstract- A {{design of}} multiple-valued {{circuits}} {{based on the}} multiple-valued <b>programmable</b> <b>logic</b> <b>arrays</b> (MV PLA’s) by generalized disjunctive decomposition is presented. Main subjects are 1) Generalized disjunctive decomposition of multiple-valued functions using multiple-terminal multiplevalued decision diagrams (MTMDD’s); 2) Realization of functions by MV PLA-based combinatorial circuits. Key words- Multiple-valued logic, generalized disjunctive decomposition; combinational multiple-valued circuits (MV circuits). 1...|$|R
50|$|In 1970, Texas Instruments {{developed}} a mask-programmable IC {{based on the}} IBM read-only associative memory or ROAM. This device, the TMS2000, was programmed by altering the metal layer during {{the production of the}} IC. The TMS2000 had up to 17 inputs and 18 outputs with 8 JK flip flop for memory. TI coined the term <b>Programmable</b> <b>Logic</b> <b>Array</b> for this device.|$|E
50|$|Stored {{program control}} {{implementations}} may be organized into centralized and distributed approaches. Early electronic switching systems (ESS) {{developed in the}} 1960s and 1970s almost invariably used centralized control. Although many present day exchange design continue to use centralized SPC, with advent of low cost powerful microprocessors and VLSI chips such as <b>programmable</b> <b>logic</b> <b>array</b> (PLA) and programmable logic controllers (PLC), distributed SPC became widespread by the early 21st century.|$|E
5000|$|In 1973 National Semiconductor {{introduced}} a mask-programmable PLA device (DM7575) with 14 inputs and 8 outputs with no memory registers. This was {{more popular than}} the TI part but cost of making the metal mask limited its use. The device is significant {{because it was the}} basis for the field <b>programmable</b> <b>logic</b> <b>array</b> produced by Signetics in 1975, the 82S100. (Intersil actually beat Signetics to market but poor yield doomed their part.) ...|$|E
40|$|Digital {{electronic}} subsystem made of {{commercially available}} <b>programmable</b> <b>logic</b> <b>arrays</b> and discrete <b>logic</b> devices serves as interface between microprocessor and dual-channel MIL-STD- 1553 data bus. Subsystem consumes only 800 mW of power. Provides flexibility {{in that it}} is controllable via firmware. Includes only two reading-and-writing ports: one for status and control signals, other for transmission and reception of data...|$|R
40|$|The letter {{reports a}} new concept for {{transverse}} folding of <b>programmable</b> <b>logic</b> <b>arrays</b> (PLAs). With the new definitions for the compatibility and foldability of rows (columns) of a column-folded (row-folded) PLA, the transverse compatibility-cum-foldability matrix (TCFM) is plotted. From the TCFM, a transverse folding matrix (TFM) is found, from which the row (column) folding pairs and the resulting ordering of rows and columns are obtained...|$|R
5000|$|<b>Programmable</b> <b>Array</b> <b>Logic</b> and <b>Programmable</b> <b>logic</b> devices - {{no longer}} used for CPUs ...|$|R
50|$|The input for ESPRESSO is a {{function}} table of the desired functionality; {{the result is a}} minimized table, describing either the ON-cover or the OFF-cover of the function, depending on the selected options. By default, the product terms will be shared as much as possible by the several output functions, but the program can be instructed to handle each of the output functions separately. This allows for efficient implementation in two-level logic arrays such as a PLA (<b>Programmable</b> <b>Logic</b> <b>Array)</b> or a PAL (Programmable Array Logic).|$|E
50|$|PALs {{were not}} the first {{commercial}} programmable logic devices; Signetics had been selling its field <b>programmable</b> <b>logic</b> <b>array</b> (FPLA) since 1975. These devices were completely unfamiliar to most circuit designers and were perceived to be too difficult to use. The FPLA had a relatively slow maximum operating speed (due to having both programmable-AND and programmable-OR arrays), was expensive, and had a poor reputation for testability. Another factor limiting {{the acceptance of the}} FPLA was the large package, a 600-mil (0.6", or 15.24 mm) wide 28-pin dual in-line package (DIP).|$|E
5000|$|A [...] <b>{{programmable}}</b> <b>logic</b> <b>array</b> (PLA) {{is a kind}} of {{programmable logic}} device used to implement combinational logic circuits. The PLA has a set of programmable AND gate planes, which link to a set of programmable OR gate planes, which can then be conditionally complemented to produce an output. It has 2^N AND Gates for N input variables and for M outputs from PLA, there should be M OR Gates, each with programmable inputs from all of the AND gates. This layout allows for a large number of logic functions to be synthesized in the sum of products [...] canonical forms.|$|E
50|$|<b>Programmable</b> <b>logic</b> devices, such as <b>programmable</b> <b>array</b> <b>logic</b> {{and complex}} <b>programmable</b> <b>logic</b> devices, {{typically}} have a macrocell on every output pin.|$|R
40|$|Recently, it was {{demonstrated}} that the polarity of carbon nanotube eld effect transistors can be electrically controlled. In this paper we show how <b>Programmable</b> <b>Logic</b> <b>Arrays</b> (PLA) can be built out of these devices, and we illustrate how they outperform usual PLA by internal signal inversion. The simulations show an area sav-ing up to 21 % and decrease of the delay in PLA-based FPGA by 50 %. We also show that this architecture is suitable for high-performance design tools and defect-tolerance approaches...|$|R
50|$|Known {{applications}} of many-valued logic can be roughly classified into two groups. The first group uses many-valued logic domain to solve binary problems more efficiently. For example, a well-known approach {{to represent a}} multiple-output Boolean function is to treat its output part as a single many-valued variable and convert it to a single-output characteristic function (specifically, the indicator function). Other {{applications of}} many-valued logic include design of <b>programmable</b> <b>logic</b> <b>arrays</b> (PLAs) with input decoders, optimization of finite state machines, testing, and verification.|$|R
50|$|Engineers {{normally}} {{write the}} microcode during the design {{phase of a}} processor, storing it in a read-only memory (ROM) or <b>programmable</b> <b>logic</b> <b>array</b> (PLA) structure, or in a combination of both. However, machines also exist that have some or all microcode stored in SRAM or flash memory. This is traditionally denoted as writeable control store {{in the context of}} computers, which can be either read-only or read-write memory. In the latter case, the CPU initialization process loads microcode into the control store from another storage medium, with the possibility of altering the microcode to correct bugs in the instruction set, or to implement new machine instructions.|$|E
5000|$|Programmers develop microprograms, using basic {{software}} tools. A microassembler allows a programmer {{to define the}} table of bits symbolically. Because of its close relationship to the underlying architecture, [...] "microcode has several properties that {{make it difficult to}} generate using a compiler." [...] A simulator program is intended to execute the bits {{in the same way as}} the electronics, and allows much more freedom to debug the microprogram. After the microprogram is finalized, and extensively tested, it is sometimes used as the input to a computer program that constructs logic to produce the same data. This program is similar to those used to optimize a <b>programmable</b> <b>logic</b> <b>array.</b> No known computer program can produce optimal logic, but even good logic can vastly reduce the number of transistors from the number required for a ROM control store. This reduces the cost of producing, and the electricity consumed by, a CPU.|$|E
5000|$|The desired outputs {{for each}} {{combination}} of inputs could be programmed into a read-only memory, with the inputs being loaded onto the address bus and the outputs being read out as data. However, {{that would require}} a separate memory location for every possible combination of inputs, including combinations that are never supposed to occur, and also duplicating data for [...] "don't care" [...] conditions (for example, logic like [...] "if input A is 1, then, as far as output X is concerned, we don't care what input B is": in a ROM this {{would have to be}} written out twice, once for each possible value of B, and as more [...] "don't care" [...] inputs are added, the duplication grows exponentially); therefore, a <b>programmable</b> <b>logic</b> <b>array</b> can often implement a piece of logic using fewer transistors than the equivalent in read-only memory. This is particularly valuable when {{it is part of a}} processing chip where transistors are scarce (for example, the original 6502 chip contained a PLA to direct various operations of the processor).|$|E
40|$|Abstract — The {{proposed}} {{method is}} targeted on reduction of hardware amount in logic circuit of Moore finite-state machine implemented with <b>programmable</b> <b>logic</b> <b>arrays</b> (PLA). The method {{is based on}} using more than minimal amount of variables in codes of FSM internal states. The method includes two stages of state encoding. The second stage is connected with recoding of states inside each class of pseudoequivalent states. An example is given for proposed method application. Keywords- Moore FSM, graph-scheme of algorithm, pseudoequivalent states, PLA, logic circui...|$|R
40|$|After a brief {{review of}} the {{characteristics}} of electrical stress degradation of flexible, amorphous silicon thin film transistors, the implications for various types of flexible circuitry including active matrix backplanes, integrated drivers and general purpose digital circuitry are examined. A circuit modeling tool that enables the prediction of complex circuit degradation is presented. Experimental results for a variety of flexible digital circuits including <b>programmable</b> <b>logic</b> <b>arrays</b> and memories are presented. Finally, we discuss the principal remaining challenges to building a fully flexible electronic system...|$|R
40|$|<b>Programmable</b> <b>logic</b> <b>arrays</b> (PLAs) {{present an}} {{alternative}} to logic-gate based design. We propose the transistor level structure of a PLA for single-rail asynchronous applications. The geometrically regular layout together with the deployment of dynamic logic help us fine-tune the PLA to enhance its resistance to side-channel attacks, while parity prediction and checking is employed to protect against malicious fault injection. Finally, we demonstrate how our PLAs {{can be used as}} building blocks of large-scale systems with good security characteristics, when combined with special return-to-zero asynchronous latches. 1...|$|R
5000|$|In 1961 IBM started {{developing}} a low speed computer logic family that used selenium diodes with similar characteristics to silicon but {{cost less than}} one cent. The terminal development departments were begging for low cost and didn’t need speed. It was possible to punch eighth inch discs from a sheet of selenium diode. GE claimed they could make reliable selenium diodes. They could do better than the three to five year life of selenium rectifiers but TV manufacturers liked the shorter life. [...] A design was achieved for a DDTL circuit with two levels of diode logic feeding one alloy transistor and no series input resistor or speed up capacitor. The family was called SMALL for Selenium Matrix ALloy Logic. The alloy transistor proved to be too fast for the selenium diode recovery. To solve this problem a selenium diode was connected around the base-emitter to slow it down. The two level logic {{was similar to the}} PLAs <b>Programmable</b> <b>logic</b> <b>array</b> that would come on the market many years later. Nearly any static logic function that yielded one output could be achieved with one transistor and a handful of cheap diodes. Several years later the selenium diodes indeed were not reliable and were replaced by silicon diodes. The logic family was packaged on SMS cards.|$|E
40|$|E�cient {{parallel}} {{schemes for}} carry-propagation-free addition of modi®ed signed-digit trinary numbers are presented. The necessary minterms for implementation using an optical <b>programmable</b> <b>logic</b> <b>array</b> area are derived. The proposed schemes require only a truth table of 25 entries {{compared with an}} earlier scheme of 625 entries. The proposed schemes are amenable to optical implementation. Experimental results using an optical <b>programmable</b> <b>logic</b> <b>array</b> are demonstrated. The experiments show the problems of noise and crosstalk. This suggests some dc bias is necessary to increase the signal-to-noise ratio of th...|$|E
40|$|The Algorithmic State Machine (ASM) is {{a method}} used to solve more complex {{industrial}} problems. The basic advantage of this method is to convert these problems to simpler circuits which consist only from the basic elements which are AND, OR and NOT gates, which can be implemented easily by using the <b>Programmable</b> <b>Logic</b> <b>Array</b> (PLA) circuits. The entry variables (number of inputs and states) for such problems are large, this made the theoretical (manual) solution is hard to solve. This research constructs a computer package called (ASM-CAD) to make the entire design using C++ and TC++ programming languages. Key Words: Algorithmic State Machine (ASM) method. <b>Programmable</b> <b>Logic</b> <b>Array</b> (PLA) circuit. Quine-McCluskey is a programmable method. 1...|$|E
50|$|CPUs {{designed}} for high-performance markets might require custom designs {{for each of}} these items to achieve frequency, power-dissipation, and chip-area goals whereas CPUs {{designed for}} lower performance markets might lessen the implementation burden by acquiring some of these items by purchasing them as intellectual property. Control logic implementation techniques (logic synthesis using CAD tools) can be used to implement datapaths, register files, and clocks. Common logic styles used in CPU design include unstructured random logic, finite-state machines, microprogramming (common from 1965 to 1985), and <b>Programmable</b> <b>logic</b> <b>arrays</b> (common in the 1980s, no longer common).|$|R
40|$|Abstract. The system using a {{multi-wire}} proportional chamber in counting regime for {{the space}} parameters measurement of Nuclotron accelerator extracted beams at low intensity levels was developed. As the preamplifiers are used fast operational amplifiers, as shapers serve fast comparators with lock-in input and counter system is built {{on the base of}} the <b>programmable</b> <b>logic</b> <b>arrays.</b> For control and communication serves the built-in single board computer. In this contribution description of this measuring system and measured parameters of system are given. As an example a measured beam parameters are also mentioned...|$|R
50|$|In modern {{semiconductor}} memory, such as dynamic random-access memory, the two {{values of}} a bit may be represented by two levels of electric charge stored in a capacitor. In certain types of <b>programmable</b> <b>logic</b> <b>arrays</b> and read-only memory, a bit may be represented by {{the presence or absence}} of a conducting path at a certain point of a circuit. In optical discs, a bit is encoded as {{the presence or absence of}} a microscopic pit on a reflective surface. In one-dimensional bar codes, bits are encoded as the thickness of alternating black and white lines.|$|R
