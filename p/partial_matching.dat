386|724|Public
25|$|In Italy, <b>partial</b> <b>matching</b> {{has been}} used in the {{controversial}} murder of Yara Gambirasio Murder_of_Yara_Gambirasio, a child found dead about a month after her presumed kidnapping. In this case, the partial match {{has been used}} as the only incriminating element against the defendant, Massimo Bossetti, who has been subsequently condemned for the murder (waiting appeal by the Italian Supreme Court).|$|E
25|$|Partial DNA matches are not {{searches}} themselves, but are {{the result}} of moderate stringency CODIS searches that produce a potential match that shares at least one allele at every locus. <b>Partial</b> <b>matching</b> does not involve the use of familial search software, such as those used in the UK and United States, or additional Y-STR analysis, and therefore often misses sibling relationships. <b>Partial</b> <b>matching</b> has been used to identify suspects in several cases in the UK and United States, and has also been used as a tool to exonerate the falsely accused. Darryl Hunt was wrongly convicted in connection with the rape and murder of a young woman in 1984 in North Carolina. Hunt was exonerated in 2004 when a DNA database search produced a remarkably close match between a convicted felon and the forensic profile from the case. The partial match led investigators to the felon’s brother, Willard E. Brown, who confessed to the crime when confronted by police. A judge then signed an order to dismiss the case against Hunt.|$|E
25|$|In {{constructing}} matchings in undirected graphs, it {{is important}} to find alternating paths, paths of vertices that start and end at unmatched vertices, in which the edges at odd positions in the path are not part of a given <b>partial</b> <b>matching</b> and in which the edges at even positions in the path are part of the matching. By removing the matched edges of such a path from a matching, and adding the unmatched edges, one can increase the size of the matching. Similarly, cycles that alternate between matched and unmatched edges are of importance in weighted matching problems.|$|E
3000|$|Step 3 (Assembly) Each site finds all local <b>partial</b> <b>matches</b> in the {{corresponding}} fragment. The {{next step is}} to assemble <b>partial</b> <b>matches</b> to compute crossing matches and compute the final results. We propose two assembly strategies: centralized and distributed (or parallel). In centralized, all local <b>partial</b> <b>matches</b> are sent to a single site for assembly. For example, in a client/server system, all local <b>partial</b> <b>matches</b> may be sent to the server. In distributed/parallel, local <b>partial</b> <b>matches</b> are combined at a number of sites in parallel.|$|R
40|$|The {{study of}} <b>partial</b> <b>match</b> queries on random {{hierarchical}} multidimensional data structures {{dates back to}} Ph. Flajolet and C. Puech’s 1986 seminal paper on <b>partial</b> <b>match</b> retrieval. It was not until recently that fixed (as opposed to random) <b>partial</b> <b>match</b> queries were studied for random relaxed K-d trees, random standard K-d trees, and random 2 -dimensional quad trees. Based on those results it seemed natural to classify the general form {{of the cost of}} fixed <b>partial</b> <b>match</b> queries into two families: that of either random hierarchical structures or perfectly balanced structures, as conjectured by Duch, Lau and Martínez (On the Cost of Fixed Partial Queries in K-d trees Algorithmica, 75 (4) : 684 – 723, 2016). Here we show that the conjecture just mentioned does not hold by introducing relaxed K-dt trees and providing the average-case analysis for random <b>partial</b> <b>match</b> queries as well as some advances on the average-case analysis for fixed <b>partial</b> <b>match</b> queries on them. In fact this cost –for fixed <b>partial</b> <b>match</b> queries– does not follow the conjectured forms. Peer ReviewedPostprint (author's final draft...|$|R
30|$|We first {{define the}} {{conditions}} under which two <b>partial</b> <b>matches</b> are joinable. Obviously, crossing matches can only be formed by assembling <b>partial</b> <b>matches</b> from different fragments.|$|R
2500|$|Dr. Washington {{later wrote}} that Henry Rogers had {{encouraged}} projects {{with at least}} <b>partial</b> <b>matching</b> funds, as that way, two ends were accomplished: ...|$|E
2500|$|Washington {{told about}} Rogers' philanthropy: [...] "funding the {{operation}} of at least 65 small country schools for the education and betterment of African Americans in Virginia and other portions of the South, all unknown to the recipients." [...] Rogers had also generously provided support to Tuskegee Institute and Hampton Institute. [...] Rogers supported projects with at least <b>partial</b> <b>matching</b> funds, {{in order to achieve}} more work, and to ensure recipients were also stakeholders.|$|E
2500|$|A vertex {{that is not}} the {{endpoint}} of an edge in some <b>partial</b> <b>matching</b> [...] {{is called}} a free vertex. The basic concept that the algorithm relies on is that of an augmenting path, a path that starts at a free vertex, ends at a free vertex, and alternates between unmatched and matched edges within the path. It follows from this definition that, except for the endpoints, all other vertices (if any) in augmenting path must be non-free vertices. An augmenting path could consist of only two vertices (both free) and single unmatched edge between them.|$|E
30|$|In the {{centralized}} assembly, all local <b>partial</b> <b>matches</b> {{are sent}} to a final assembly site. We propose an iterative join algorithm to find all crossing matches. In each iteration, a pair of local <b>partial</b> <b>matches</b> is joined. When the join is complete (i.e., a match has been found), the result is returned; otherwise, it is joined with other local <b>partial</b> <b>matches</b> in the next iteration. In {{order to reduce the}} join space of the iterative join algorithm, we divide all local <b>partial</b> <b>matches</b> into multiple partitions such that two local <b>partial</b> <b>matches</b> in the same set cannot be joinable; we only consider joining local <b>partial</b> <b>matches</b> from different partitions. In the distributed assembly, we adopt Bulk Synchronous Parallel (BSP) model [28] to design a synchronous algorithm for distributed assembly. A BSP computation proceeds in a series of global supersteps, each of which consists of three components: local computation, communication and barrier synchronization. In the local computation step, each site adopts the iterative join algorithm to assemble local <b>partial</b> <b>matches</b> within the site. If a join result is a complete match of query graph Q, it will be returned directly; otherwise, these join results (i.e., the intermediate results) will be sent to the other sites in the communication step. The details about the communication and system termination condition are discussed in [23].|$|R
30|$|The first {{condition}} {{says that}} the same query vertex cannot be matched by different internal vertices in joinable <b>partial</b> <b>matches.</b> The second condition says that two local <b>partial</b> <b>matches</b> share at least one common crossing edge that corresponds to the same query edge.|$|R
40|$|Abstract. We {{consider}} random multivariate quadtries {{obtained from}} n points independently and uni-formly distributed {{on the unit}} cube of Rd. Let Nn(y) be {{the complexity of the}} standard <b>partial</b> <b>match</b> algorithm for fixed vector y, where y is a vector in Rs, 0 < s < d. We study Nn = supy Nn(y), the worst-case time for <b>partial</b> <b>match.</b> Among other things, we show that <b>partial</b> <b>match</b> is very stable, in the sense that supy Nn(y) / infy Nn(y) → 1 in probability...|$|R
2500|$|The {{algorithm}} {{was found}} by [...] As in previous methods for matching such as the Hungarian algorithm {{and the work of}} , the Hopcroft–Karp algorithm repeatedly increases the size of a <b>partial</b> <b>matching</b> by finding augmenting paths: sequences of edges that alternate between being {{in and out of the}} matching, such that swapping which edges of the path are in and which are out of the matching produces a larger matching. However, instead of finding just a single augmenting path per iteration, the algorithm finds a maximal set of shortest augmenting paths. As a result, only [...] iterations are needed. The same principle has also been used to develop more complicated algorithms for non-bipartite matching with the same asymptotic running time as the Hopcroft–Karp algorithm.|$|E
2500|$|It can {{be shown}} that each phase {{increases}} {{the length of the}} shortest augmenting path by at least one: the phase finds a maximal set of augmenting paths of the given length, so any remaining augmenting path must be longer. Therefore, once the initial [...] phases of the algorithm are complete, the shortest remaining augmenting path has at least [...] edges in it. However, the symmetric difference of the eventual optimal matching and of the <b>partial</b> <b>matching</b> M found by the initial phases forms a collection of vertex-disjoint augmenting paths and alternating cycles. If each of the paths in this collection has length at least , there can be at most [...] paths in the collection, {{and the size of the}} optimal matching can differ from the size of [...] by at most [...] edges. Since each phase of the algorithm increases the size of the matching by at least one, there can be at most [...] additional phases before the algorithm terminates.|$|E
5000|$|Prediction by <b>partial</b> <b>matching</b> (PPM) - Optimized for {{compressing}} {{plain text}} ...|$|E
40|$|In this paper, {{we propose}} an {{approach}} which can improve Inductive Logic Programming in multiclass problems. This approach {{is based on}} the idea that if a whole rule cannot be applied to an example, some <b>partial</b> <b>matches</b> of the rule can be useful. The most suitable class should be the class whose important <b>partial</b> <b>matches</b> cover the example more than those from other classes. Hence, the <b>partial</b> <b>matches</b> of the rule, called partial rules, are first extracted from the original rules...|$|R
3000|$|Let us recall query Q in Fig.  7. Figure  8 shows two {{different}} local <b>partial</b> <b>matches</b> PM_ 1 ^ 2 and PM_ 2 ^ 2. We also show the functions in Fig.  8. There {{do not exist}} {{two different}} vertices in the two local <b>partial</b> <b>matches</b> that match the same query vertex. Furthermore, they share a common crossing edge 008, 003, where 008 and 003 match query vertices v_ 3 and v_ 5 in the two local <b>partial</b> <b>matches,</b> respectively. Hence, they are joinable. Figure  8 also shows the join result of PM_ 1 ^ 2 [...] _fPM_ 2 ^ 2.|$|R
30|$|As {{mentioned}} earlier, we {{adopt the}} partial evaluation and assembly [15] strategy in our distributed RDF system design. Each site S_i treats fragment F_i as the known input s and other fragments as yet unavailable input G. Each site S_i finds all local <b>partial</b> <b>matches</b> of query Q within fragment F_i. We prove that an overlapping part between any crossing match and fragment F_i {{must be a}} local <b>partial</b> <b>match</b> in F_i. Then, these local <b>partial</b> <b>matches</b> are assembled into the complete matches of SPARQL query Q.|$|R
5000|$|Washington {{later wrote}} that Rogers had {{encouraged}} projects {{with at least}} <b>partial</b> <b>matching</b> funds so that two ends were accomplished: ...|$|E
5000|$|Dr. Washington {{later wrote}} that Henry Rogers had {{encouraged}} projects {{with at least}} <b>partial</b> <b>matching</b> funds, as that way, two ends were accomplished: ...|$|E
5000|$|His PPMd (<b>Partial</b> <b>Matching</b> by Dmitry) {{algorithms}} {{are used}} in the [...]ZIP format, and the 7-Zip archivers' PPMd method used in 7z files.|$|E
40|$|An {{important}} component of some data mining algorithms is determining the frequency of some set of attributes in an extremely large dataset. This requires <b>partial</b> <b>match</b> queries, in which some attributes have 't care " values. We present a <b>partial</b> <b>match</b> query algorithm that uses the codewords of error-correcting codes as signatures. 1...|$|R
40|$|Cartesian product files have {{recently}} been shown to exhibit attractive properties for <b>partial</b> <b>match</b> queries. This paper considers the file allocation problem for Cartesian product files, which can be stated as follows: Given a k-attribute Cartesian product file and an m-disk system, allocate buckets among the m disks {{in such a way}} that, for all possible <b>partial</b> <b>match</b> queries, the concurrency of disk accesses is maximis ed. The Risk Modulo (DM) allocation method is described first, and it is shown to be strict optimal under many conditions commonly occurring in practice, including all possible <b>partial</b> <b>match</b> queries when the number of disks is 2 or 3. It is also shown that although it has good performance, the DM allocation method is not strict optimal for all possible <b>partial</b> <b>match</b> queries when the number of disks is greater than 3. The General Disk Modulo (GDM) allocation method is then described, and a sufficient but not necessary condition for strict optimal&y of the GDM method for all <b>partial</b> <b>match</b> queries and any number of disks is then derived. Simulation studies comparing the DM and random allocation methods in terms of the average number of disk accesses, in response to various classes of <b>partial</b> <b>match</b> queries, show the former to be significantly more effective even when the number of disks is greater than 3, that is, even in cases where the DM method is not strict optimal. The results that have been derived formally and shown by simulation can be used for more effective design of optimal file systems for <b>partial</b> <b>match</b> queries. When considering multiple-disk systems with independent access paths, it is important to ensure that similar records are clustered into the same or similar buckets, while similar buckets should be dispersed uniformly among the disks...|$|R
30|$|The join {{result of}} two joinable local <b>partial</b> <b>matches</b> {{is defined as}} follows.|$|R
50|$|Dmitry Shkarin (Дмитрий Шкарин) is a Russian {{programmer}} and is {{the creator}} of several lossless data compression algorithms, notably using prediction by <b>partial</b> <b>matching.</b>|$|E
5000|$|PPMd - Dmitry Shkarin's 2002 PPMdH (PPMII/cPPMII) {{with small}} changes: PPMII is an {{improved}} {{version of the}} 1984 PPM compression algorithm (prediction by <b>partial</b> <b>matching).</b>|$|E
50|$|The best modern {{lossless}} compressors use probabilistic models, such as prediction by <b>partial</b> <b>matching.</b> The Burrows-Wheeler transform {{can also}} {{be viewed as an}} indirect form of statistical modelling.|$|E
40|$|We {{propose a}} simple direct {{approach}} for computing the expected cost of random <b>partial</b> <b>match</b> queries in random quadtrees. The approach gives {{not only an}} explicit expression for the leading constant in the asymptotic approximation of the expected cost but also more terms in the asymptotic expansion if desired. Key words. Quadtrees, <b>partial</b> <b>match</b> queries, binomial transform, Mellin transform, Euler transform, Rice's integral...|$|R
40|$|This paper {{proposes a}} cache {{management}} scheme for continuous <b>partial</b> <b>match</b> queries in mobile computing systems. Conventional cache management methods for mobile clients are record ID-based ones. However, since the <b>partial</b> <b>match</b> query is a content-based retrieval, the conventional record ID-based approach cannot properly manage the cache consistency. We show the predicate-based approach {{is an effective}} cache management in mobile environments...|$|R
40|$|This paper {{presents}} {{an analysis of}} Correlation Matrix Memory (CMM), a binary associative neural network. CMM has been proposed as an inference engine, which could be utilized in an expert system (Austin, 1994). In this role, CMM encodes Tensor Products (Smolensky, 1990) to support Dynamic Variable Binding. The ability to perform <b>partial</b> <b>match</b> efficiently, with {{a large body of}} stored information is important for a useful expert system. This paper extends the work on the storage v. error characteristics of CMM and presents new work on the <b>partial</b> <b>match</b> ability of the memory. A comparison is made with an efficient <b>partial</b> <b>match</b> method used in databases, Multi-level Superimposed Coding (Sacks-Davis & Ramamohanarao, 1983), and the <b>partial</b> <b>match</b> performance of CMM is shown to compare well. We conclude that CMM is well suited to its proposed use as an inference engine. page 1 Using Correlation Matrix Memories for Inferencing in Expert Systems 1. INTRODUCTION Rule-based reasoning has been [...] ...|$|R
50|$|His most cited {{work is in}} {{the fields}} of data compression, machine learning, and logic programming. In particular, he {{independently}} discovered arithmetic coding and invented the prediction by <b>partial</b> <b>matching</b> (PPM) compression technique.|$|E
50|$|In data compression, {{adaptive}} coding algorithms such as Adaptive Huffman coding or Prediction by <b>partial</b> <b>matching</b> {{can take a}} stream of data as input, and adapt their compression technique based on the symbols that they have already encountered.|$|E
5000|$|The heat kernel {{signature}} {{makes use}} of the eigen-decomposition of the heat kernel:For each point on the surface the diagonal of the heat kernel [...] is sampled at specific time values [...] and yields a local signature that {{can also be used}} for <b>partial</b> <b>matching</b> or symmetry detection.|$|E
40|$|The {{continuous}} <b>partial</b> <b>match</b> query is a <b>partial</b> <b>match</b> query whose result {{continues to}} exist consistently in the client's memory. Conventional cache management methods for mobile clients are record ID-based. However, since the <b>partial</b> <b>match</b> query uses a content-based retrieval, the conventional record ID-based approach cannot properly manage cache consistency. Therefore, in the paper, we propose a predicate-based cache management scheme for continuous <b>partial</b> <b>match</b> queries in mobile database systems. In the proposed cache management scheme, we represent the cache state of a mobile client as a predicate, and construct a cache invalidation report (CIR), which the server broadcasts to clients for cache management, with predicates. We show the predicate-based approach {{is an effective}} cache management method in mobile database systems. For {{reducing the amount of}} information that is needed in cache management, we propose a set of methods for CIR construction (in the server) and identi cation of invalidated data (in the client) ...|$|R
40|$|Abstract: We {{consider}} {{the problem of}} d-dimensional searching (d ≥ 3) for four query types: range, <b>partial</b> range, exact <b>match</b> and <b>partial</b> <b>match</b> searching. LetN be the number of points, s be the number of keys specified in a <b>partial</b> <b>match</b> and <b>partial</b> range query and t be the number of points retrieved. We present a data structure with worst case time complexities O(t +log d− 2 N), O(t +(d − s) +log s N), O(d + √ log N) and O(t +(d − s) +s √ log N) {{for each of the}} aforementioned query types respectively. We also present a second, more concrete solution for exact and <b>partial</b> <b>match</b> queries, which achieves the same query time but has different space requirements. The proposed data structures are considered in the RAM model of computation...|$|R
5000|$|Some {{intervals}} are points, {{the others}} full domains, {{and so the}} query is a <b>partial</b> <b>match</b> query.|$|R
