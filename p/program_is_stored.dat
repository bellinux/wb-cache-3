25|10000|Public
5000|$|When the <b>program</b> <b>is</b> <b>stored</b> in file HelloWorld.scala, {{the user}} compiles {{it with the}} command $ scalac HelloWorld.scalaand runs it with $ scala HelloWorld ...|$|E
5000|$|Execute:Program:Back action button: Execute {{will start}} a stored program {{of up to}} 40 commands. Program mode allows storing of commands, while Back removes the last command entered. The <b>program</b> <b>is</b> <b>stored</b> and played back by {{pressing}} the Execute button again.|$|E
50|$|PLC {{programs}} are typically {{written in a}} special application on a personal computer, then downloaded by a direct-connection cable or over a network to the PLC. The <b>program</b> <b>is</b> <b>stored</b> in the PLC either in battery-backed-up RAM or some other non- volatile flash memory. Often, a single PLC can be programmed to replace thousands of relays.|$|E
5000|$|... #Caption: In the 1950s, {{computer}} <b>programs</b> <b>were</b> <b>stored</b> on {{perforated paper}} tape ...|$|R
50|$|A {{table with}} the Stage as the root. All objects in the <b>program</b> <b>are</b> <b>stored</b> here as references.|$|R
50|$|During execution, user <b>{{programs}}</b> <b>are</b> swapped to fixed-head drum memory. When not executing, user <b>programs</b> <b>are</b> <b>stored</b> on moving-head cartridge- or pack-loaded disk storage. Privileged {{users can}} also store {{programs on the}} much-faster drum. The hard drive was backed up to magnetic tape.|$|R
50|$|A Forth {{environment}} {{combines the}} compiler with an interactive shell, where the user defines and runs subroutines called words. Words can be tested, redefined, and debugged {{as the source}} is entered without recompiling or restarting the whole program. All syntactic elements, including variables and basic operators, are defined as words. Forth environments vary in how the resulting <b>program</b> <b>is</b> <b>stored,</b> but ideally running the program has the same effect as manually re-entering the source.|$|E
5000|$|Atari BASIC uses a token {{structure}} to handle lexical processing for better performance and reduced memory size. The tokenizer converts lines {{using a small}} buffer in memory, and the <b>program</b> <b>is</b> <b>stored</b> as a parse tree. The token output buffer (addressed by a pointer at LOMEM [...] - [...] 80, 8116) is 256 bytes, and any tokenized statement larger than the buffer generates an error (14 [...] - [...] line too long). Indeed, the syntax checking described in the [...] "Program editing" [...] section is {{a side effect of}} converting each line into a tokenized form before it is stored.|$|E
50|$|Programming {{is done on}} a PC {{equipped}} with appropriate software that {{can be part of}} the machine or a connected external workstation. For generating a new program engineering data can be imported or pasted per mouse and keyboard. Through a graphic and menu-driven user interface previous CNC programming skills are not required. All the punches in a work piece are shown on the screen making programming mistakes easily detected. Ideally each <b>program</b> <b>is</b> <b>stored</b> in one database, in this manner it is easy to recover them by search and sort functions. When selecting a new piece, all the necessary tooling changes are displayed. Before transferring it to the control unit the software scans each program for possible collisions. This eliminates most handling errors.|$|E
5000|$|Executable <b>programs</b> <b>were</b> <b>stored</b> in the Core Image Library, {{which did}} not reclaim space when <b>programs</b> <b>were</b> deleted or {{replaced}} by newer versions. When the Core Image Library became full, {{it had to be}} compressed by one of the utility programs, and this could halt development work for as much as half a day.|$|R
25|$|The Manchester Small-Scale Experimental Machine (June 1948) was a stored-program {{computer}}. Programming transitioned {{away from}} moving cables and setting dials; instead, a computer <b>program</b> <b>was</b> <b>stored</b> in memory as numbers. Only three bits of memory <b>were</b> available to <b>store</b> each instruction, {{so it was}} limited to eight instructions. 32 switches <b>were</b> available for <b>programming.</b>|$|R
5000|$|Applesoft BASIC <b>programs</b> <b>were</b> <b>stored</b> as a {{linked list}} of lines; a [...] or [...] took O(n) (linear) time, and {{although}} Applesoft <b>programs</b> <b>were</b> {{not very long}} compared to today's software, on a 1 MHz 6502 this could create a significant bottleneck. Large <b>programs</b> <b>were</b> often written with the most-used subroutines {{at the top of}} the program to reduce the processing time for [...] calls.|$|R
50|$|Direct {{numerical}} control (DNC), {{also known as}} distributed {{numerical control}} (also DNC), is a common manufacturing term for networking CNC machine tools. On some CNC machine controllers, the available memory {{is too small to}} contain the machining program (for example machining complex surfaces), so in this case the <b>program</b> <b>is</b> <b>stored</b> in a separate computer and sent directly to the machine, one block at a time. If the computer is connected to a number of machines it can distribute programs to different machines as required. Usually, the manufacturer of the control provides suitable DNC software. However, if this provision is not possible, some software companies provide DNC applications that fulfill the purpose. DNC networking or DNC communication is always required when CAM programs are to run on some CNC machine control.|$|E
50|$|Programming {{is done on}} a PC {{equipped}} with dedicated software, {{which is part of}} the machine or connected to an external workstation. For generating a new program engineering data can be imported or pasted per mouse and keyboard. Through a graphic and menu-driven user interface previous CNC programming skills are not required. The software asks for all necessary values and checks all figures. Inputs can be corrected at any time and minimum distances are checked instantly to guard against improper inputs. The software automatically calculates the flat length of each part being bent and determines the exact position of the side stop. The part is shown on a screen.Ideally each <b>program</b> <b>is</b> <b>stored</b> in one database, in this manner it is easy to recover them by search and sort functions.|$|E
50|$|The company {{initially}} {{focused on}} using gene knockout technology {{to define the}} function of genes. This effort complemented and benefited from the international effort to sequence the human and mouse genomes (see Human Genome Project). Using its proprietary gene trapping and gene targeting technologies, the company created the world’s largest repository of genetically modified mouse embryonic stem cells, known as OmniBank, and established a large-scale mammalian knockout program to discover the physiological and behavioral functions of the most druggable mammalian genes. The information collected from this <b>program</b> <b>is</b> <b>stored</b> in the company’s LexVision database, which contains almost 5,000 gene knockouts studied. Over the years, Lexicon evolved from a genomics company into a drug discovery and development company focused on discovering and developing breakthrough treatments for human disease. The company currently has multiple drug candidates {{in various stages of}} clinical trials.|$|E
50|$|After 1956, {{he retired}} from {{performing}} {{and spent most of}} his time collecting materials and writing memoirs many of which remain unpublished. Much of his archives including music, photographs and concert <b>programs</b> <b>were</b> <b>stored</b> in a trunk he had left with a musicologist in Winnipeg and were destroyed during the Great Flood.|$|R
40|$|This paper {{describes}} {{platform for}} dynamic reconfiguration on an FPGA with embedded microcontroller. The platform is divided to the {{hardware and software}} parts. A microcontroller is initiator of the reconfiguration process. A reconfiguration controller drives autonomously the reconfiguration process. The ronfiguration bitstreams and <b>programs</b> <b>are</b> <b>stored</b> in an external memory connected to the FPGA...|$|R
50|$|Magnetic card {{readers were}} among the first {{persistent}} memory options available. The entered <b>programs</b> <b>are</b> <b>stored</b> on magnetic strips. Those were easy to transport, and the reader/writer was compact in size. However, the reader/writer as well as the magnetic strips were quite expensive. The last and most notable devices to use magnetic strips were the HP-41C and TI-59.|$|R
5000|$|In computing, a code segment, {{also known}} as a text segment or simply as text, is a portion of an object file or the {{corresponding}} section of the program's virtual address space that contains executable instructions. The term [...] "segment" [...] comes from the memory segment, which is a historical approach to memory management that has been succeeded by paging. When a <b>program</b> <b>is</b> <b>stored</b> in an object file, the code segment is a part of this file; when the loader places a program into memory so that it may be executed, various memory regions are allocated (in particular, as pages), corresponding to both the segments in the object files and to segments only needed at run time. For example, the code segment of an object file is loaded into a corresponding code segment in memory.|$|E
40|$|EP 993188 A UPAB: 20000624 NOVELTY - A {{received}} TV {{or radio}} <b>program</b> <b>is</b> <b>stored</b> in a buffer (12) without being transmitted {{in response to}} a control signal (16) identifying the scheduled broadcast. The program so stored, having scheduled transmission no longer, is routed to a TV or radio playback device (14). DETAILED DESCRIPTION - A buffer read-out occurs at a time staggered with writing the program into a buffer, so that the TV or radio program stored in the buffer is ready for playback, while a later part of the received TV or radio <b>program</b> <b>is</b> <b>stored</b> in a buffer and the predetermined broadcast suppressed in response to the control signal. USE - In TV and radio transmission editing. ADVANTAGE - A TV or radio program can be viewed while being broadcast without advertising transmissions and the like and without any interference caused by it...|$|E
40|$|A visual {{programming}} method is presented which is object-oriented, {{equivalent to a}} universal programming language and supports the imperative programming style. The visualization includes both the algorithmic and the architectural level of a system. Based on a fractal geometry, an entire software system can be displayed in form of a single compact graph. A close correspondence with the C++ and Java languages allows efficient code generation. The visual <b>program</b> <b>is</b> <b>stored</b> in an object data base from which different views can be generated and whic...|$|E
50|$|The TXE4 MCU <b>program</b> <b>was</b> <b>stored</b> in EPROM with {{capacity}} {{for up to}} 32k 16 bit instructions which were structured {{in a similar manner}} to mini-computers of that era. Each instruction took 2 microseconds to execute except those accessing Registers which were stretched to 6 microseconds. The higher performance enabled the maximum number of registers per MCU to be increased.|$|R
50|$|<b>Program</b> {{instructions}} <b>are</b> <b>stored</b> in non-volatile flash memory. Although the MCUs are 8-bit, each instruction {{takes one}} or two 16-bit words.|$|R
50|$|In the OS/2 {{subsystem}} of Windows NT, {{what appeared}} as CONFIG.SYS to OS/2 <b>programs</b> <b>was</b> actually <b>stored</b> in the registry.|$|R
40|$|Space age {{health care}} {{delivery}} is being delivered to both NASA astronauts and employees with primary emphasis on preventive medicine. The program relies heavily on comprehensive health physical exams, health education, screening programs and physical fitness programs. Medical data from the <b>program</b> <b>is</b> <b>stored</b> in a computer bank so epidemiological significance can be established and better procedures can be obtained. Besides {{health care delivery}} to the NASA population, NASA is working with HEW on a telemedicine project STARPAHC, applying space technology {{to provide health care}} delivery to remotely located populations...|$|E
40|$|We {{discuss the}} design of a {{universal}} 1 -dimensional reversible nearest-neighbour quantum cellular automaton, efficiently simulating arbitrary gate model computations. Program and data are both encoded in the preparation of the initial state, and no further classical control is needed to run the machine. In the proof we use the structure theorem for quantum cellular automata (Margolus partitioning) to convert any device, whose program is a classical sequence of different quantum cellular automaton steps, into an autonomously running device for which the <b>program</b> <b>is</b> <b>stored</b> in the quantum cells. We then describe an explicit example with cell-dimension 12...|$|E
40|$|A {{computer}} program {{that provides the}} geometry and boundary conditions appropriate for an analysis of a lifting, thin wing with control surfaces in linearized, subsonic, steady flow is presented. The kernel function method lifting surface theory is applied. The data which is generated by the <b>program</b> <b>is</b> <b>stored</b> on disk files or tapes for later use by programs which calculate an influence matrix, plot the wing planform, and evaluate the loads on the wing. In addition to processing data for subsequent use in a lifting surface analysis, the program is useful for computing area and mean geometric chords of the wing and control surfaces...|$|E
5000|$|<b>Programs</b> <b>were</b> <b>stored</b> as a [...]BAS source file, {{using the}} [...] "SAVE" [...] command. It could be [...] "compiled" [...] into a non-editable binary [...]BAC file, using the [...] "COMPILE" [...] command. This command {{did not produce}} true machine {{language}} programs, but rather a byte code called [...] "tokens". The tokens were interpreted upon execution, {{in a manner similar}} to the more modern Java.|$|R
50|$|The first {{computer}} using a {{multiprogramming system}} was the British Leo III owned by J. Lyons and Co. During batch processing, several different <b>programs</b> <b>were</b> loaded {{in the computer}} memory, {{and the first one}} began to run. When the first program reached an instruction waiting for a peripheral, the context of this <b>program</b> <b>was</b> <b>stored</b> away, and the second <b>program</b> in memory <b>was</b> given a chance to run. The process continued until all programs finished running.|$|R
50|$|Approximately 65 space suits {{from the}} Mercury, Apollo, and other US space <b>programs</b> had <b>been</b> <b>stored</b> at the {{facility}} in an environmentally-controlled room.|$|R
40|$|This paper proposes an {{incremental}} maintenance algorithm that e#ciently updates the materialized XPath/XSLT views defined using XPath expressions in XP{[],*,//,vars}. The algorithm {{consists of two}} processes. 1) The dynamic execution flow of an XSLT <b>program</b> <b>is</b> <b>stored</b> as an XT (XML Transformation) tree during the full transformation. 2) In response to a source XML data update, the impacted portions of the XT-tree are identified and maintained by partially re-evaluating the XSLT program. This paper discusses the XPath/XSLT features of incremental view maintenance for subtree insertion/deletion and applies them to the maintenance algorithm. Experiments show that the incremental maintenance algorithm outperforms full XML transformation algorithms by factors of up to 500...|$|E
40|$|With modern {{software}} systems, {{an important}} requirement {{is the ability}} to be auto adaptive, i. e. being able to adjust itself its changing environment. In line with this, a run time manager for dynamic feature integration of telecommunication systems, interaction detection and resolution is described in this paper with aspects being used to implement features. The manager manages the interaction of features/aspects by monitoring the managed program. The program is represented by a labelled transition system (LTS) model, stored in a flexible data structure, and executed by calling the action subroutine represented by the label of the LTS model, forming a reflective facility for the composition and analysis of features. It is the reflective mechanism that makes dynamic feature addition, run time model checking, as well as adaptive interaction resolution possible. Runtime model checking is possible because the checked <b>program</b> <b>is</b> <b>stored</b> within itself and the interaction resolution is done by selecting behaviour traces according to the resolution rules...|$|E
40|$|Data {{dependence}} {{analysis has}} become one of the most important constituents of loop-level parallelizing compilers. The information gathered from the analysis is needed to determine both the potential concurrency of loop nests and the legality of loop transformations concerning loop parallelization. The analysis is based on data dependence tests such as the constant test and the GCD test. Once the analysis is complete, the dependence information for the input <b>program</b> <b>is</b> <b>stored</b> for later demand. Since this dependence information is stored in memory, recalculation of the information in following passes is unnecessary, reducing the whole parallelizing compiler execution time. However because this information often requires so much memory space, sometimes up to thousands of Mbytes without strict memory management, it can run out of heap storage, and cause another problem: how do we store the information efficiently? Besides memory space, the time to fetch the necessary information is also another criterion of concern because faster access generally requires more memory space. In thi...|$|E
5000|$|A <b>program</b> could <b>be</b> <b>stored</b> on {{the system}} in an {{editable}} source file (a [...]BAS file) using the [...] "SAVE" [...] command, or ...|$|R
40|$|We {{present the}} design of a typed {{assembly}} language called TALT that supports heterogeneous tuples, disjoint sums, and a general account of addressing modes. TALT also implements the von Neumann model in which <b>programs</b> <b>are</b> <b>stored</b> in memory, and supports relative addressing. Type safety for execution and for garbage collection are shown by machine-checkable proofs. TALT is the first formalized typed assembly language to provide any of these features...|$|R
40|$|Polite Smalltalk {{is a small}} {{evolutionary}} mutation of the Smalltalk {{programming language}} that aims to encourage developers to think more about their programs as prose. The main mechanism by which Polite does {{this is what we}} define here as sentence case identifiers — a naming convention that allows spaces in identifier names. Unlike projection editors which can easily allow spaces in their identifiers, Polite <b>programs</b> <b>are</b> <b>stored</b> as text...|$|R
