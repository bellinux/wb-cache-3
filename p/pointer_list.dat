3|53|Public
5000|$|Hazard {{pointers}} {{can be used}} {{to address}} both of these problems. In a hazard-pointer system, each thread keeps a list of hazard pointers indicating which nodes the thread is currently accessing. (In many systems this [...] "list" [...] may be provably limited to only one or two elements.) Nodes on the hazard <b>pointer</b> <b>list</b> must not be modified or deallocated by any other thread.|$|E
40|$|AbstractWe {{reformulate}} the O(N) sigma {{model as}} a loop model whose configurations are the all-order strong coupling graphs {{of the original}} model. The loop configurations are represented by a <b>pointer</b> <b>list</b> in the computer and a Monte Carlo update scheme is proposed. Sample simulations are reported and the method {{turns out to be}} similarly efficient as the reflection cluster method, but it has greater potential for systematic generalization to other lattice field theories. A variant action suggested by the method is also simulated and leads to a rather extreme demonstration of the concept of universality of the scaling or continuum limit...|$|E
40|$|We {{reformulate}} the O(N) sigma {{model as}} a loop model whose configurations are the all-order strong coupling graphs {{of the original}} model. The loop configurations are represented by a <b>pointer</b> <b>list</b> in the computer and a Monte Carlo update scheme is proposed. Sample simulations are reported and the method {{turns out to be}} similarly efficient as the reflection cluster method, but it has greater potential for systematic generalization to other lattice field theories. A variant action suggested by the method is also simulated and leads to a rather extreme demonstration of the concept of universality of the scaling or continuum limit. Comment: 27 pages, 6 figures, 5 tables. The combinatoric derivation of the (unchanged) algorithm is corrected. Independently, all data in sect. 5 are revised due to a software error, with unchanged conclusions on universality...|$|E
25|$|First - Is {{the null}} <b>pointer</b> (empty <b>list).</b>|$|R
40|$|Abstract- The use of {{tangible}} {{models in}} the classroom (at all levels of instruction) is incredibly common; CS instruction is no exception. In this report, we discuss experiences in using the common Barrel of Monkeys ® toy to teach concepts related to dynamically allocated linked lists. Points of emphasis include pointer vs. object distinctions, copies of <b>pointers,</b> <b>list</b> manipulation algorithms, memory allocation and leaks, and classroom presentation tips...|$|R
5000|$|... routine void,node pointer (node <b>pointer</b> : <b>list)</b> for p in first:next {{do while}} p.val >< 20 exitfor return nil endfor return endroutine ...|$|R
5000|$|Set the Display <b>List</b> <b>pointer</b> Shadow address DLISTL/DLISTH to the {{starting}} address of the new Display List.|$|R
50|$|In {{functional}} programming languages that {{rely heavily on}} <b>lists,</b> <b>pointers</b> and references are managed abstractly by the language using internal constructs like cons.|$|R
50|$|The MM5 code {{itself has}} over 220 subroutines, {{with more than}} 55,000 lines of code. It uses Standard Fortran 77 with “Cray” <b>pointers.</b> A <b>list</b> of the subroutines {{of all of the}} {{functions}} within the MM5, with a short description and the routines that are called within it can be found here.|$|R
5000|$|The {{pointers}} will be unreadable if one isn't traversing {{the list}} [...] - [...] for example, if the <b>pointer</b> to a <b>list</b> item was contained in another data structure; ...|$|R
40|$|We {{prove that}} the graph {{isomorphism}} problem restricted to trees and to colored graphs with color multiplicities 2 and 3 is many-one complete for several complexity classes within NC². In particular we show that tree isomorphism, when trees are encoded as strings, is NC¹-hard under AC 0 -reductions. NC¹-completeness thus follows from Buss's NC¹ upper bound. By contrast, we prove that testing isomorphism of two trees encoded as <b>pointer</b> <b>lists</b> is L-complete. Concerning colored graphs we show that the isomorphism problem for graphs with color multiplicities 2 and 3 is complete for symmetric logarithmic space SL under many-one reductions. This result improves the existing upper bounds for the problem. We also show that the graph automorphism problem for colored graphs with color classes of size 2 is equivalent to deciding whether a graph {{has more than a}} single connected component and we prove that for color classes of size 3 the graph automorphism problem is contained in SL...|$|R
40|$|AbstractWe {{prove that}} the graph {{isomorphism}} problem restricted to trees and to colored graphs with color multiplicities 2 and 3 is many-one complete for several complexity classes within NC 2. In particular we show that tree isomorphism, when trees are encoded as strings, is NC 1 -hard under AC 0 -reductions. NC 1 -completeness thus follows from Buss's NC 1 upper bound. By contrast, we prove that testing isomorphism of two trees encoded as <b>pointer</b> <b>lists</b> is L-complete. Concerning colored graphs we show that the isomorphism problem for graphs with color multiplicities 2 and 3 is complete for symmetric logarithmic space SL under many-one reductions. This result improves the existing upper bounds for the problem. We also show that the graph automorphism problem for colored graphs with color classes of size 2 is equivalent to deciding whether a graph {{has more than a}} single connected component and we prove that for color classes of size 3 the graph automorphism problem is contained in SL...|$|R
40|$|Learn {{the basics}} of {{programming}} with C with this fun and friendly guide! C offers a reliable, strong foundation for programming {{and serves as a}} stepping stone upon which to expand your knowledge and learn additional programming languages. Written by veteran For Dummies author Dan Gookin, this straightforward-but-fun beginner's guide covers the fundamentals of using C and gradually walks you through more advanced topics including <b>pointers,</b> linked <b>lists,</b> file I/O, and debugging. With a special focus on the subject of an Integrated Development Environment, it gives you a solid understanding o...|$|R
50|$|When {{dealing with}} arrays, the {{critical}} lookup operation typically involves a stage called address calculation which involves constructing a pointer {{to the desired}} data element in the array. In other data structures, such as linked <b>lists,</b> <b>pointers</b> are used as references to explicitly tie one piece of the structure to another.|$|R
5000|$|... sel expects two list arguments, {{and pops}} a value from the stack. The first list is {{executed}} if the popped value was non-nil, the second list otherwise. Before {{one of these}} <b>list</b> <b>pointers</b> is made the new C, a pointer to the instruction following sel is saved on the dump.|$|R
30|$|However, {{more than}} one cell can be mapped to a same point in the span-space. To {{overcome}} this problem, each node in the quadtree also stores a <b>pointer</b> to a <b>list</b> of the volume data cells that were mapped to this point. Then, the queries can be made as usual, traversing the nodes corresponding to the active cells.|$|R
40|$|This {{proposal}} describes my work {{currently under}} way in the optimization of pointer-intensive programs. The term pointer-intensive refers to programs that spend a signi cant fraction of their CPU time manipulating data structures built out of <b>pointers,</b> such as <b>lists,</b> trees, and graphs. This work had its genesis in my background research in compiler transformations. It became obviou...|$|R
50|$|Because the struct node data {{structure}} is defined recursively, procedures that operate on {{it can be}} implemented naturally as recursive procedures. The list_print procedure defined below walks down the list until the list is empty (i.e., the <b>list</b> <b>pointer</b> has a value of NULL). For each node it prints the data element (an integer). In the C implementation, the list remains unchanged by the list_print procedure.|$|R
40|$|Abstract. This paper {{introduces}} the tool SeLoger, {{which is a}} rea-soner for satisfiability and entailment in a fragment of separation logic with <b>pointers</b> and linked <b>lists.</b> SeLoger builds upon and extends graph-based algorithms that have recently been introduced in order to settle both decision problems in polynomial time. Running SeLoger on stan-dard benchmarks shows that the tool outperforms current state-of-the-art tools by orders of magnitude. ...|$|R
5000|$|The [...] "current-arc" [...] data {{structure}} is {{a mechanism for}} visiting the in- and out-neighbors of a node in the flow network in a static circular order. If a singly linked list of neighbors is created for a node, the {{data structure}} {{can be as simple}} as a <b>pointer</b> into the <b>list</b> that steps through the list and rewinds to the head when it runs off the end.|$|R
50|$|Above {{the town}} is Hampsfield Fell (generally {{abbreviated}} to Hampsfell), crowned by 'Hampsfell Hospice', a sturdy limestone tower monument offering shelter to the rain-drenched walker, {{as well as the}} finest viewpoint of all the foothills of the outlying southern Lakeland fells. On the roof, a large compass <b>pointer</b> and <b>list</b> of peaks identify the greater and lesser landmarks in the magnificent panorama. Inside, painted boards commemorate its construction, praise the view and welcome the visitor. Hampsfell {{is the subject of a}} chapter of Wainwright's book The Outlying Fells of Lakeland. It reaches 727 ft. The summit of Hampsfell is surrounded by several flat, incised areas of exposed limestone, called limestone pavement. The best and most extensive pavements lie to the north of the hospice.|$|R
40|$|In the {{electric}} GIS, facilities in different voltage levels show a different proportion, and topological relations exist {{in line and}} point. According to the limitations in multi-scale representation and topological connection of traditional spatial index, an extended R-Tree model based on multi-scale clustering(MCER Tree) is proposed, which removed the restrictions of the same height of all leaf nodes, but increased <b>pointer</b> to line <b>list</b> of spatial object. This paper focused on the structure, generation algorithms and insertion algorithms of MCER Tree, and finally proposed the future research...|$|R
50|$|A buffer {{overflow}} {{occurring in the}} heap data area {{is referred to as}} a heap overflow and is exploitable in a manner different from that of stack-based overflows. Memory on the heap is dynamically allocated by the application at run-time and typically contains program data. Exploitation is performed by corrupting this data in specific ways to cause the application to overwrite internal structures such as linked <b>list</b> <b>pointers.</b> The canonical heap overflow technique overwrites dynamic memory allocation linkage (such as malloc meta data) and uses the resulting pointer exchange to overwrite a program function pointer.|$|R
40|$|The method {{presented}} in Calculating with pointer structures by Bernhard Möller to derive pointer algorithms {{has been shown}} well-applicable and easy-to-use in several various examples. We present the derivation of different <b>pointer</b> algorithms on <b>lists</b> from their functional specification. The intention {{of this paper is}} to show the advantages of the method on a number of medium-sized examples on the one hand. On the other hand we point out also problems and tasks to be solved to achieve a complete framework for the derivation of pointer algorithms working on inductively defined data structures...|$|R
2500|$|Quicksort is a space-optimized {{version of}} the binary tree sort. Instead of {{inserting}} items sequentially into an explicit tree, quicksort organizes them concurrently into a tree that is implied by the recursive calls. The algorithms make exactly the same comparisons, but in a different order. An often desirable property of a sorting algorithm is stability – that is the order of elements that compare equal is not changed, allowing controlling order of multikey tables (e.g. directory or folder listings) in a natural way. This property is hard to maintain for in situ (or in place) quicksort (that uses only constant additional space for pointers and buffers, and [...] additional space {{for the management of}} explicit or implicit recursion). For variant quicksorts involving extra memory due to representations using <b>pointers</b> (e.g. <b>lists</b> or trees) or files (effectively lists), it is trivial to maintain stability. The more complex, or disk-bound, data structures tend to increase time cost, in general making increasing use of virtual memory or disk.|$|R
40|$|Introducing recent {{advances}} in computer technology to improve aircraft scheduling is investigated. Incorporating interactive graphics, modern database manipulation techniques, and decision support algorithms, the computer is proposed {{as a tool for}} the schedule development process, replacing present manual methods. A detailed set of graphics representations of schedule data are presented based on the sequence chart and station activity chart. The interactive manipulation of these displays by the scheduler results in an immediate appropriate update of the schedule database. Quick graphics response and automatic constraint violation alerts speed the search for feasible schedules. The execution of complex aircraft scheduling operations by the proposed system is presented. Schedule display and database structures are designed for implementation on computers with modern high resolution graphics and <b>pointer</b> directed <b>list</b> capabilities. June 1984 Also issued as an M. S. thesis, Massachusetts Institute of Technology, Dept. of Aeronautics and Astronautics, 1984 Bibliography: leaf 138 Includes bibliographical references (leaf 138...|$|R
50|$|Quicksort is a space-optimized {{version of}} the binary tree sort. Instead of {{inserting}} items sequentially into an explicit tree, quicksort organizes them concurrently into a tree that is implied by the recursive calls. The algorithms make exactly the same comparisons, but in a different order. An often desirable property of a sorting algorithm is stability - that is the order of elements that compare equal is not changed, allowing controlling order of multikey tables (e.g. directory or folder listings) in a natural way. This property is hard to maintain for in situ (or in place) quicksort (that uses only constant additional space for pointers and buffers, and O(log n) additional space {{for the management of}} explicit or implicit recursion). For variant quicksorts involving extra memory due to representations using <b>pointers</b> (e.g. <b>lists</b> or trees) or files (effectively lists), it is trivial to maintain stability. The more complex, or disk-bound, data structures tend to increase time cost, in general making increasing use of virtual memory or disk.|$|R
2500|$|A buffer {{overflow}} {{occurring in the}} heap data area {{is referred to as}} a heap overflow and is exploitable in a manner different from that of stack-based overflows. [...] Memory on the heap is dynamically allocated by the application at run-time and typically contains program data. [...] Exploitation is performed by corrupting this data in specific ways to cause the application to overwrite internal structures such as linked <b>list</b> <b>pointers.</b> [...] The canonical heap overflow technique overwrites dynamic memory allocation linkage (such as malloc meta data) and uses the resulting pointer exchange to overwrite a program function pointer.|$|R
5000|$|In the {{earliest}} versions of C, functions with no specific result defaulted to a return type of [...] and functions with no arguments simply had empty argument <b>lists.</b> <b>Pointers</b> to untyped data were declared as integers or pointers to [...] Some early C compilers had the feature, now {{seen as an}} annoyance, of generating a warning on any function call that {{did not use the}} function's returned value. Old code sometimes casts such function calls to void to suppress this warning. By the time Bjarne Stroustrup began his work on C++ in 1979-1980, void and void pointers were part of the C language dialect supported by AT&T-derived compilers.|$|R
40|$|International audienceIn {{this paper}} we discuss how to present the result of searching {{elements}} of any type from XML documents relevant to some information need (relevance-oriented search). As the resulting elements can contain each other we show an intuitive way of organizing the resulting list of elements in several ranked lists at different levels such that each element is presented only one time. Depending {{on the size of}} such ranked lists its presentation is given by a structure tree for small lists or by a sequence of <b>pointers</b> for large <b>lists.</b> In both cases the textual content of the implied elements is given. We also analyse the size of ranked lists in a real collection of XML documents...|$|R
40|$|In many garbage {{collected}} systems, the mutator {{performs a}} write barrier for every pointer update. Using generational garbage collectors, we study in depth three code placement options for rememberedset write barriers: inlined, out-of-line, and partially inlined (fast path inlined, slow path out-of-line). The fast path determines if the collector needs {{to remember the}} pointer update. The slow path records the <b>pointer</b> in a <b>list</b> when necessary. Efficient implementations minimize the instructions on the fast path, and record few pointers (from 0. 16 to 3 % of pointer stores in our benchmarks). We find the mutator performs best with a partially inlined barrier, by a modest 1. 5 % on average over full inlining. We als...|$|R
40|$|In 2004, Berdine, Calcagno and O'Hearn {{introduced}} {{a fragment of}} separation logic that allows for reasoning about programs with <b>pointers</b> and linked <b>lists.</b> They showed that entailment in this fragment is in coNP, but the precise complexity of this problem has been open since. In this paper, we show that the problem can actually be solved in polynomial time. To this end, we represent separation logic formulae as graphs and show that every satisfiable formula is equivalent to one whose graph is in a particular normal form. Entailment between two such formulae then reduces to a graph homomorphism problem. We also discuss natural syntactic extensions that render entailment intractable. © 2011 Springer-Verlag...|$|R
5000|$|The four bitangents of two {{disjoint}} convex polygons may {{be found}} efficiently by an algorithm based on binary search in which one maintains a binary search <b>pointer</b> into the <b>lists</b> of edges of each polygon and moves one of the pointers left or right at each steps depending on where the tangent lines to the edges at the two pointers cross each other. This bitangent calculation is a key subroutine in data structures for maintaining convex hulls dynamically [...] [...] describe an algorithm for efficiently listing all bitangent line segments that do not cross {{any of the other}} curves in a system of multiple disjoint convex curves, using a technique based on pseudotriangulation.|$|R
40|$|This paper {{presents}} {{the design and}} prototype of an intelligent, 3 -Dimensional-Queue (3 DQ) for highperformance, scalable, input bu ered ATM switches. 3 DQ uses <b>pointers</b> and linked <b>lists</b> to organize ATM cells into multiple virtual queues according to priority, destination, and virtual connection. It enforces per virtual connection Quality-of-Service (QoS) and eliminates Head-Of-Line (HOL) blocking. Using Field-Programmable-Gate-Array (FPGA) devices, our prototype hardware can process ATM cells at 622 Mb/s (OC- 12). Using more aggressive technology (Multi-Chip-Module (MCM) and fast GaAs logic), the same 3 DQ design can process cells at 2. 5 Gb/s (OC- 48). Using 3 DQ and Matrix-Unit-Cell-Scheduler (MUCS) as essential components, an input-bu ered ATM switch system has been designed, which can achieve near- 100 % link bandwidth utilization. ...|$|R
40|$|Modern routers {{and switch}} fabrics can have {{hundreds}} of input and output ports running at up to 10 Gb/s; 40 Gb/s systems are starting to appear. At these rates, {{the performance of the}} buffering and queuing subsystem becomes a significant bottleneck. In high performance routers with more than a few queues, packet buffering is typically implemented using DRAM for data storage and a combination of off-chip and on-chip SRAM for storing the linked-list nodes and packet length, and the queue headers, respectively. This paper focuses on the performance bottlenecks {{associated with the use of}} offchip SRAM. We show how the combination of implicit buffer <b>pointers</b> and multi-buffer <b>list</b> nodes can dramatically reduce the impact of buffering and queuing subsystem on queuing performance. We also show ho...|$|R
40|$|In this paper, {{we discuss}} how {{to present the}} result of searching {{elements}} of any type from XML documents relevant to some information need (relevance-oriented search). As the resulting elements can contain each other, we show an intuitive way of organizing the resulting list of elements in several ranked lists at different levels, such that each element is presented only one time. Depending {{on the size of}} such ranked lists, its presentation is given by a structure tree, for small lists, or by a sequence of <b>pointers,</b> for large <b>lists.</b> In both cases, the textual content of the implied elements is given. We also analyse the size of ranked lists in a real collection of XML documents. Categories and Subject Descriptor...|$|R
