123|7004|Public
5000|$|The tilde {{is used in}} the AWK {{programming}} language as part of the <b>pattern</b> <b>match</b> operators for regular expressions: ...|$|E
5000|$|In Haskell, the tilde {{is used in}} type {{constraints}} {{to indicate}} type equality. [...] Also, in pattern-matching, the tilde is used to indicate a lazy <b>pattern</b> <b>match.</b>|$|E
50|$|A visual {{search engine}} {{searches}} images, patterns {{based on an}} algorithm which it could recognize and gives relative information based on the selective or apply <b>pattern</b> <b>match</b> technique.|$|E
40|$|A {{very fast}} {{parallel}} approach to <b>pattern</b> <b>matching</b> is presented. The approach {{is based on}} the bit-parallel approach and we use two-dimensional bitwise memory matrix which helps to achieve very fast parallel <b>pattern</b> <b>matching</b> algorithms. The parallel <b>pattern</b> <b>matching</b> takes O(1) time for the exact <b>pattern</b> <b>matching</b> and O(k) for the approximate <b>pattern</b> <b>matching,</b> where k is the number of errors...|$|R
5000|$|... #Caption: Block {{diagrams}} of (left) <b>pattern</b> <b>matching</b> and {{substitution method}} and (right) soft <b>pattern</b> <b>matching</b> method ...|$|R
40|$|Abstract. In {{this paper}} we {{classify}} <b>pattern</b> <b>matching</b> problems using algebraic means. We construct an algebra of <b>pattern</b> <b>matching</b> automata in which nite automata are the elements and operations applied to them {{correspond to the}} creation of new <b>pattern</b> <b>matching</b> problems. We present several such operations and describe some identied properties of the algebra dened in this way. Key words: <b>pattern</b> <b>matching,</b> nite automata, algebra...|$|R
5000|$|<b>Pattern</b> <b>match</b> - in {{this case}} the tools is given a set of lexical {{patterns}} that it can match. For example, the tools may search for [...] "*gender*" [...] or [...] "*sex*" ...|$|E
50|$|The {{underscore}} is {{a special}} SQL <b>pattern</b> <b>match</b> to a single character and should be escaped {{if you are in}} fact looking for an underscore character in the LIKE clause of a query.|$|E
5000|$|Ad blocking: OmniWeb uses a {{powerful}} <b>pattern</b> <b>match</b> ad blocking feature to stop images from loading from servers matching the pattern. It {{is also possible}} to block images that don't originate from the current server you are browsing and to block images that match common advertisement sizes.|$|E
5000|$|Each judging block {{consists}} of a sequence of <b>pattern</b> <b>matching</b> commands, each of which introduces a (possibly empty) block of commands to be executed if that <b>pattern</b> <b>matches.</b> The two most common <b>pattern</b> <b>matching</b> commands were [...] and [...] These had identical <b>pattern</b> <b>matching</b> semantics except that [...] judged a student response to be correct if it matched, while [...] judged a student response to be incorrect.|$|R
40|$|Abstract. Intrusion {{detection}} {{for network}} security is an application area demanding high throughput. The <b>pattern</b> <b>matching</b> in intrusion detection requires extremely high performance to process string <b>matching.</b> Most of <b>pattern</b> <b>matching</b> using software has many time complexities and cannot reach {{the requirements of}} high throughput. The <b>pattern</b> <b>matching</b> using hardware considerably improves the speed of matching and has several other advantages. This paper describes a FPGA-based <b>pattern</b> <b>matching</b> architecture, using hashing method called XOR Hashing. The proposed method updates new patterns without reconfiguration and processes the collision and has high matching performance. The proposed system implements the <b>pattern</b> <b>matching</b> by using Snort rule-set, an open source Network Intrusion Detection and has simulation processing on PC. Compared with existing hardware method, the results explained that our method has relatively high performance for the <b>pattern</b> <b>matching</b> and can else process the <b>pattern</b> <b>matching</b> with high performance on low–cost FPGA device...|$|R
40|$|The {{importance}} of hypertext {{has been steadily}} growing over the last decade. Internet and other information systems use hypertext format, with data organized associatively rather than sequentially or relationally. A myriad of textual problems have been considered in the <b>pattern</b> <b>matching</b> field with many non-trivial results. Nevertheless, surprisingly little {{work has been done}} on the natural combination of <b>pattern</b> <b>matching</b> and hypertext. In contrast to regular text, hypertext has a non-linear structure and the techniques of <b>pattern</b> <b>matching</b> for text cannot be directly applied to hypertext. Manber and Wu [14] pioneered the study of <b>pattern</b> <b>matching</b> in hypertext and defined a hypertext model for <b>pattern</b> <b>matching.</b> Akutsu [2] developed an algorithm {{that can be used for}} exact <b>pattern</b> <b>matching</b> in a tree-structured hypertext. Park and Kim [16] considered regular <b>pattern</b> <b>matching</b> in hypertext. They developed a complex algorithm that works for hypertext with an underlying structure of a [...] ...|$|R
50|$|Identifying and {{predicting}} sequences {{which have}} the capacity to form quadruplexes is an important tool in further understanding their role. Generally, a simple <b>pattern</b> <b>match</b> is used for searching for possible intrastrand quadruplex forming sequences: d(G3+N1-7G3+N1-7G3+N1-7G3+), where N is any nucleotide base (including guanine).This rule has been widely used in on-line algorithms.|$|E
5000|$|Like LMGs, RCG clauses {{have the}} general schema , where in an RCG, [...] is either the empty string or {{a string of}} predicates. The {{arguments}} [...] consist of strings of terminal symbols and/or variable symbols, which <b>pattern</b> <b>match</b> against actual argument values like in LMG. Adjacent variables constitute a family of matches against partitions, so that the argument , with two variables, matches the literal string [...] in three different ways: [...]|$|E
5000|$|The {{effects of}} de-duplication and {{correlation}} are slightly different. De-duplication results {{in only one}} event being presented, effectively summarising a given number of events occurring close together over a stated timespan. Correlation occurs when an older event is consigned to the Acknowledged message list because its key matches an [...] "acknowledge these" [...] pattern (here's the HPOM <b>pattern</b> <b>match</b> again) in a later message, which normally remains on the Active message list.|$|E
40|$|Abelian <b>pattern</b> <b>matching</b> is a {{new class}} of <b>pattern</b> <b>matching</b> problems. In abelian patterns, the order of the {{characters}} in the substrings does not matter, e. g. the strings abbc and babc represent the same abelian pattern a+ 2 b+c. Therefore, unlike classical <b>pattern</b> <b>matching,</b> we do not look for an exact (ordered) occurrence of a substring, rather the aim here is to find any permutation of a given combination of characters that represents the given abelian pattern. In this thesis, we study the problem of abelian <b>pattern</b> <b>matching</b> in strings in a systematic manner, and present several algorithms for exact as well as approximate abelian <b>pattern</b> <b>matching.</b> We also present different strategies for indexing the input text to make the abelian <b>pattern</b> <b>matching</b> more efficient...|$|R
40|$|In this paper, {{counting}} objects {{techniques are}} proposed for fast <b>pattern</b> <b>matching</b> algorithm based on normalized cross correlation and convolution technique which {{are widely used}} in image processing application. <b>Pattern</b> <b>matching</b> {{can be used to}} recognize and/or locate specific objects in an image. It is one of the emerging areas in computational object counting. In this paper, introduces a new <b>pattern</b> <b>matching</b> technique called convolution based on <b>pattern</b> <b>matching</b> algorithm. Many different <b>pattern</b> <b>matching</b> techniques have been developed but more efficient and robust methods are needed. The <b>pattern</b> <b>matching</b> algorithm is used to identify the patterns similar present in image. With the patterns, identify the similarity measures of the given pattern to count the object present in the given image. An experimental evaluation is carried out to estimate the performance of the proposed efficient <b>pattern</b> <b>matching</b> algorithm for remote sensing as well as common images in terms of estimation of execution times, efficiency and compared the results with an existing conventional methods...|$|R
40|$|We {{prove the}} theorems and lemmas stated in [2]. The most {{significant}} results among all are: (1) termination and determinacy of <b>pattern</b> <b>matching,</b> which guarantees that the <b>pattern</b> <b>matching</b> algorithm always yields just one result (thus, a program does never falls into an infinite loop during <b>pattern</b> <b>matching),</b> and (2) soundness and completeness of the typing rules for <b>pattern</b> <b>matching,</b> which guarantee that our type system infers all and only possible strings {{bound to the}} variables in a pattern. ...|$|R
5000|$|Complex SNOBOL {{patterns}} can {{do things}} that would be impractical or impossible using the more primitive regular expressions used in most other pattern matching languages. Some of this power derives from the so-called [...] "SPITBOL extensions" [...] (which have since been incorporated in basically all modern implementations of the original SNOBOL 4 language too), although {{it is possible to}} achieve the same power without them. Part of this power comes from the side effects {{that it is possible to}} produce during the pattern matching operation, including saving numerous intermediate/tentative matching results and the ability to invoke user-written functions during the <b>pattern</b> <b>match</b> which can perform nearly any desired processing, and then influence the ongoing direction the interrupted <b>pattern</b> <b>match</b> takes, or even to indeed change the pattern itself during the matching operation. Patterns can be saved like any other first-class data item, and can be concatenated, used within other patterns, and used to create very complex and sophisticated pattern expressions. It is possible to write, for example, a SNOBOL4 pattern which matches [...] "a complete name and international postal mailing address", which is well beyond anything that is practical to even attempt using regular expressions.|$|E
50|$|Each of {{the five}} {{elements}} is optional. In general, the subject is matched against the pattern. If the object is present, any matched portion is replaced by the object via rules for replacement. The transfer can be an absolute branch or a conditional branch dependent upon {{the success or failure}} of the subject evaluation, the pattern evaluation, the <b>pattern</b> <b>match,</b> the object evaluation or the final assignment. It can also be a transfer to code created and compiled by the program itself during a run.|$|E
50|$|There are two {{workflows}} {{that are}} of interest to scientists that use Minimotif Miner 1) Entering any query protein into Minimotif Miner returns {{a table with a}} list of minimotif sequence and functions that have a sequence <b>pattern</b> <b>match</b> with the protein query sequence. These provide potential new functions in the protein query. 2) By using the view single nucleotide polymorphism (SNP) function, SNPs from dbSNP are mapped in the sequence window. A user can select any set of the SNPs and then identify any minimotif that is introduced or eliminated by the SNP or mutation. This helps to identify minimotifs involved in generating organism diversity or those that may be associated with a disease.|$|E
40|$|At {{the heart}} of almost every modern Network Intrusion Detection System (NIDS), there is a <b>pattern</b> <b>matching</b> engine (PME). As <b>pattern</b> <b>matching</b> is the most time {{consuming}} operation in NIDS, it is highly desired to reduce the <b>pattern</b> <b>matching</b> time of each packet or flow. This paper proposed a parallel <b>pattern</b> <b>matching</b> algorithm based on Aho-Corasick (AC) algorithm and an efficient load balance policy for it. The method is implemented on Intel’s IXP 2850 Network Processor (NP). Experimental results show that when using eight processors, the <b>pattern</b> <b>matching</b> time of each packet or flow can decrease to 60. 44 %~ 14. 42 % of using only one processor. Based on the parallel algorithm, a PME utilizing parallel processing on three levels is proposed. Experimental results on IXP 2850 show that the throughput speedup of <b>pattern</b> <b>matching</b> is 13. 34 ~ 55. 48 times...|$|R
40|$|Abstract: <b>Pattern</b> <b>matching</b> {{problem is}} still very {{interesting}} and important problem. Algorithms for the exact <b>pattern</b> <b>matching</b> search for exact patterns in some texts or figures. Algorithms for an approximate <b>pattern</b> <b>matching</b> search for exact and similar patterns with some errors. They use some measures to evaluate a similarity of found similar patterns. In {{the area of the}} <b>pattern</b> <b>matching</b> allowing errors is possible to use fuzzy logic theory. In the paper we present the algorithm for a fuzzification of a deterministic finite state automaton using a similarity function of characters. The fuzzified automaton will accept exact and similar words. The second presented algorithm is a fuzzy modification of Aho-Corasick <b>pattern</b> <b>matching</b> algorithm which still work in linear time with respect to the length of the searching text. Key words: <b>Pattern</b> <b>matching,</b> fuzzy logic, fuzzy automaton. ...|$|R
5000|$|Developed “MagicNet,” a <b>pattern</b> <b>matching</b> method using {{time-delay}} {{neural networks}} that is two {{times faster than}} deterministic finite automata for exact <b>pattern</b> <b>matching</b> [...] (2011).|$|R
5000|$|During 2007-2009, Grant Tranter of the University of Sydney, Australia in {{collaboration}} with Jason Morris of Morris Technical Solutions, USA, completed a working prototype of SINFERS. This implementation of the SINFERS concept uses Jess to <b>pattern</b> <b>match</b> object representations of subsets of soil properties in working memory to the argument list of known pedotransfer functions. The SINFERS' knowledge base knows which PTF rules to apply and how to choose the most certain computed values. SINFERS computes new properties not only from an original input set, but also from all newly inferred properties. Some of the design aspects of this application were presented at the October Rules Fest 2009. See October Rules Fest 2009 [...]|$|E
5000|$|Given that Gremlin is a language, an {{instruction}} set, and a virtual machine, {{it is possible}} to design another traversal language that compiles to the Gremlin traversal machine (analogous to how Scala compiles to the JVM). For instance, the popular SPARQL graph <b>pattern</b> <b>match</b> language can be compiled to execute on the Gremlin machine. The following SPARQL querySELECT ?a ?b ?c WHERE { ?a a Person [...] ?a ex:knows ?b [...] ?a ex:created ?c [...] ?b ex:created ?c [...] ?b ex:age ? d [...] FILTER(?d < 30)}would compile toMatchStep(AND,VertexStep(OUT,knows,vertex),,),.In Gremlin-Java8, the SPARQL query above would be represented as below and compile to the identical Gremlin step sequence (i.e. traversal).g.V (...) [...]match( [...] as("a").label (...) [...]is("person"), as("a").out("knows").as("b"), as("a").out("created").as("c"), as("b").out("created").as("c"), as("b").values("age").as("d"), as("d").is(gt(30))). select("a","b","c") ...|$|E
50|$|Sam's command syntax is {{formally}} {{similar to}} ed's or ex's, containing (structural-) regular expression based conditional and loop functions and scope addressing, even sharing some of ed's syntax for such functions. But while ed's commands are line-oriented, sam's are selection-oriented. Selections are contiguous strings of text (which may span multiple lines), and are specified either with the mouse (by sweeping {{it over a}} region of text) or by a <b>pattern</b> <b>match.</b> Sam's commands take such selections as basic—more or less as other Unix tools treat lines; thus, multi-line and sub-line patterns are as naturally handled by Sam as whole-line patterns are by ed, vi, AWK, Perl, etc. This is implemented through a model called structural regular expressions, which can recursively apply regular-expression matching to obtain other (sub)selections within a given selection. In this way, sam's command set {{can be applied to}} substrings that are identified by arbitrarily complex context.|$|E
40|$|Abstract. We propose <b>pattern</b> <b>matching</b> calculi as a {{refinement}} of λ-calculus that integrates mechanisms appropriate for fine-grained mod-elling of non-strict <b>pattern</b> <b>matching.</b> Compared with the functional rewriting strategy usually employed {{to define the}} operational semantics of <b>pattern</b> <b>matching</b> in non-strict functional programming languages like Haskell or Clean, our <b>pattern</b> <b>matching</b> calculi achieve the same effects using simpler and more local rules. The main device is to embed into expressions the separate syntactic cate-gory of matchings; the resulting language naturally encompasses pattern guards and Boolean guards as special cases. By allowing a confluent reduction system and a normalising strategy, these <b>pattern</b> <b>matching</b> calculi provide a new basis for operational semantics of non-strict programming languages and also for implemen-tations. ...|$|R
40|$|Finding matches, both exact and approximate, {{between a}} {{sequence}} of symbols A and a pattern P {{has long been an}} active area of research in algorithm design. Some of the more well-known byproducts from that research are the diff program and grep family of programs. These problems form a sub-domain of a larger areas of problems called discrete <b>pattern</b> <b>matching</b> which has been developed recently to characterise the wide range of <b>pattern</b> <b>matching</b> problems. This dissertation presents new algorithms for discrete <b>pattern</b> <b>matching</b> over sequences and develops a new sub-domain of problems called discrete <b>pattern</b> <b>matching</b> over interval sets. The problems and algorithms presented here are characterised by <b>pattern</b> <b>matching</b> over interval sets. The problems and a...|$|R
40|$|This paper {{presents}} a <b>pattern</b> <b>matching</b> machine which detects all occurrences {{of the longest}} possible keywords in a text and replaces them with the corresponding keywords. The <b>pattern</b> <b>matching</b> machine of this type is a generalized sequential machine and is constructed in nearly {{the same way as}} Aho-Corasick 2 ̆ 7 s <b>pattern</b> <b>matching</b> machine to locate all occurrences of keywords. We show algorithms to construct our <b>pattern</b> <b>matching</b> machine and to make the machine run on a given text string, and show the validities of them. We also consider the time complexity of the algorithms and evaluate the running time of the algorithms. Finally we discuss some applications of our <b>pattern</b> <b>matching</b> machines...|$|R
5000|$|Several MTS {{commands}} {{that use}} file names or lists of file names allow {{the use of}} file-name patterns: COPY, DESTROY, DUPLICATE, EMPTY, EDIT, FILESTATUS, FILEMENU, LIST, LOCKSTATUS, PERMIT, RENAME, RENUMBER, and TRUNCATE. A question-mark (?) is the <b>pattern</b> <b>match</b> character. A single question-mark used in a file-name will match zero or more characters. [...] "?" [...] matches all files for the current signon ID, [...] "?.S" [...] matches all files that end with [...] ".S", [...] "A?B" [...] matches all files that begin with [...] "A" [...] and end with [...] "B", [...] "A?B?C" [...] matches all files that start with [...] "A", end with [...] "C", and contain a [...] "B". Two or more consecutive question-marks match [...] "n-1" [...] characters. [...] "???.S" [...] matches all four character file-names that end with [...] ".S", and [...] "????" [...] matches all three character file-names. [...] "W163:?" [...] matches all files under the signon ID [...] "W163" [...] to which the current user has some access.|$|E
5000|$|Over my {{many years}} of learning, iterating, and teaching, I’ve arrived at the {{conclusions}} {{that the process of}} learning, as humans, can be abused, tuned, and scaled easily.There comes a specific point in your life where you can reach or obtain near mastery of one specific subject. After that, there’s a base of knowledge that you can (and will) build analogies on. By doing so, you take one industry and mirror it into another industry.I would emphasize, you can not be a jack-of-all-trades without being a master of at least one.Perhaps it is social skill, doll making, mathematics, language, emotional awareness—you must be a master of at least one in order to be a jack of many others...Mastery of one trade can be converted into a catalyst for learning other fields. You have something to pull from, complex ideas you can <b>pattern</b> <b>match,</b> and metaphoric analogies that can complete a picture.The more you learn, the faster you learn.|$|E
5000|$|The phrase regular {{expressions}} (and consequently, regexes) {{is often}} used to mean the specific, standard textual syntax (distinct from the mathematical notation described below) for representing patterns that matching text need to conform to. Each character in a regular expression (that is, each character in the string describing its pattern) is understood to be a metacharacter (with its special meaning), or a regular character (with its literal meaning). For example, in the regex [...] a is a literal character which matches just 'a' and [...] is a meta character which matches every character except a newline. Therefore, this regex would match for example 'a ' or 'ax' or 'a0'. Together, metacharacters and literal characters can be used to identify textual material of a given pattern, or process a number of instances of it. Pattern-matches can vary from a precise equality to a very general similarity (controlled by the metacharacters). For example, [...] is a very general pattern, [...] (match all letters from 'a' to 'z') is less general and [...] is a precise <b>pattern</b> (<b>match</b> just 'a'). The metacharacter syntax is designed specifically to represent prescribed targets in a concise and flexible way to direct the automation of text processing of a variety of input data, in a form easy to type using a standard ASCII keyboard.|$|E
30|$|String {{matching}} algorithms can {{be categorized}} into single and multiple <b>pattern</b> <b>matching</b> algorithms. In the single <b>pattern</b> <b>matching,</b> one <b>pattern</b> is <b>matched</b> against the entire text at a time [14]. In contrast, the multiple <b>pattern</b> <b>matching</b> approach compares the text sequence against all signatures all at once [15]. Obviously, the multiple matching approach is a better choice for intrusion detection to avoid sweeping the packet many times. However, it consumes more memory and requires a pre-processing phase to program the <b>patterns</b> before <b>matching</b> can commence.|$|R
40|$|<b>Pattern</b> <b>matching</b> is {{a widely}} used {{procedure}} in signal processing, computer vision, image and video processing. Recently, methods using Walsh Hadamard Transform (WHT) and Gray-Code kernels (GCK) are successfully applied for fast transform domain <b>pattern</b> <b>matching.</b> This paper introduces strip sum on the image. The sum of pixels in a rectangle can be computed by one addition using the strip sum. Then we propose to use the orthogonal Haar transform (OHT) for <b>pattern</b> <b>matching.</b> Applied for <b>pattern</b> <b>matching,</b> the algorithm using strip sum require...|$|R
40|$|Abstract. In this paper, I outline a new {{algorithm}} {{for regular}} tree <b>pattern</b> <b>matching.</b> The Boyer-Moore family of string <b>pattern</b> <b>matching</b> algorithms {{are considered to}} be among the most ecient. The Boyer-Moore idea of a shift dis-tance was generalized by Commentz-Walter for multiple keywords, and general-izations for regular expressions have also been found. The existence of a further generalization to tree <b>pattern</b> <b>matching</b> was rst mentioned in the statements accompanying my dissertation, [Wats 95]. Key words: tree <b>pattern</b> <b>matching,</b> tree parsing, code selection, Boyer-Moor...|$|R
