92|229|Public
5000|$|In the x86, the {{protection}} keys [...] architecture allows tagging virtual addresses for user pages {{with any of}} 16 protection keys. All the pages tagged with the same protection key constitute a <b>protection</b> <b>domain,</b> A new register contains the permissions associated {{with each of the}} <b>protection</b> <b>domain.</b> Load and store operations are checked against both the page table permissions and {{the protection}} key permissions associated with the <b>protection</b> <b>domain</b> of the virtual address, and only allowed if both permissions allow the access. The protection key permissions can be set from user space, allowing applications to directly restrict access to the application data without OS intervention. Since the protection keys are associated with a virtual address, the protection domains are per address space, so processes running in different address spaces can each use all 16 domains.|$|E
50|$|With a powerbox system, {{the file}} dialog is {{implemented}} as a trusted {{part of the}} system. It runs in a <b>protection</b> <b>domain</b> separate from the application. The powerbox component has {{access to all the}} user's files, whereas the application does not.|$|E
50|$|MIDP 2.0 (JSR 118) {{includes}} a comprehensive security model based on protection domains. MIDlet suites are installed into a <b>protection</b> <b>domain</b> that determines access to protected functions. The MIDP 2.0 specification also {{includes a}} recommended practice for using public key cryptography to verify and authenticate MIDlet suites.|$|E
40|$|Today’s {{distributed}} applications are built using processes and therefore are {{only able to}} rely on process-level <b>protection</b> <b>domains.</b> In this paper we argue that process-level <b>protection</b> <b>domains</b> are insufficient for {{distributed applications}} and propose job-level <b>protection</b> <b>domains</b> as a new high-level building block for distributed applications. We present a network interface architecture called the Network Management Unit (NMU) and show that it efficiently implements job-level <b>protection</b> <b>domains</b> and argue that this allows programmers to productively develop reliable high-performance distributed applications. ...|$|R
25|$|Support for {{hierarchical}} <b>protection</b> <b>domains</b> {{is typically}} implemented using CPU modes.|$|R
50|$|PA has 15-18 bits of key; Itanium {{mandates}} {{at least}} 18. Keys are {{usually associated with}} <b>protection</b> <b>domains,</b> such as libraries, modules, etc.|$|R
5000|$|DomainTools, LLC {{provides}} DNS research {{tools that}} use {{a database of}} domain name, IP address, and WHOIS data. These tools are used for brand <b>protection,</b> <b>domain</b> monitoring, domain valuation, and cybercrime investigation. Other services include a name suggestion, patented reverse IP address, and a combined screenshot history view that incorporates millions of screenshots that shows how a website looked recently or in the past.|$|E
5000|$|Clarivate Analytics is an {{independent}} company that owns and operates a collection of subscription-based businesses [...] "focused on scientific and academic research, patent analytics and regulatory standards, pharmaceutical and biotech intelligence, trademark <b>protection,</b> <b>domain</b> brand protection and intellectual property management." [...] It has over 4,000 employees, operates in more than 100 countries, and owns Web of Science, Cortellis, Derwent Innovation, Derwent World Patents Index, CompuMark, MarkMonitor, Techstreet, and Publons, among others.|$|E
50|$|Protected Working Capacity Envelope Optimization - This model {{different}} from the other 2 models because in this model the p-cycles are found first. There are some considerations when creating the p-cycles based on the idea of optimizing the general volume of the working channels which must be protected. After the p-cycles are found, the working demand is routed on the network within the p-cycle <b>protection</b> <b>domain.</b> This concept is known as protected working capacity envelope (PWCE).|$|E
40|$|Extensible systems allow {{services}} to be configured and deployed {{for the specific}} needs of individual applications. This paper describes a safe and efficient method for user-level extensibility that requires only minimal changes to the kernel. A sandboxing technique is described that supports multiple logical <b>protection</b> <b>domains</b> within the same address space at user-level. This approach allows applications to register sandboxed code with the system, that may be executed in the context of any process. Our approach differs from other implementations that require special hardware support, such as segmentation or tagged translation look-aside buffers (TLBs), to either implement multiple <b>protection</b> <b>domains</b> in a single address space, or to support fast switching between address spaces. Likewise, we do not require the entire system to be written in a type-safe language, to provide fine-grained <b>protection</b> <b>domains.</b> Instead, our user-level sandboxing technique requires only paged-based virtual memory support, and the requirement that extension code is written either in a type-safe language, or by a trusted source. Using a fast method of upcalls, we show how our sandboxing technique for implementing logical <b>protection</b> <b>domains</b> provides significant performance improvements over traditional methods of invoking user-level services. Experimental results show our approach to be an efficient method for extensibility, with inter-protection domain communication costs close to those of hardware-based solutions leveraging segmentation...|$|R
40|$|In {{a single}} address space {{operating}} system (SASOS) all objects in memory are visible {{to all other}} objects by default. As a consequence some means is needed to protect the privacy of object contents and prevent the occurrence of accidental or deliberate corruption {{of the contents of}} objects not participating in the current thread of execution. Every access to memory must be tested to determine if the current thread of execution has legal access to the instructions or data at the memory location. The Range Protection Lookaside Buffer (RPLB) is a hardware device which implements the required protection and enforces the communication constraints between <b>protection</b> <b>domains</b> in the Sombrero operating system. We have named Sombrero <b>protection</b> <b>domains</b> `ubiquitous' <b>protection</b> <b>domains,</b> or UPDs, because of {{the manner in which they}} enforce protection. The benefits realized by this model include the virtually costless domain switching enabling traditional InterProcess Communication (IPC) [...] ...|$|R
40|$|Rights to {{individual}} papers {{remain with the}} author or the author's employer. Permission is granted for noncommercial reproduction of the work for educational or research purposes. This copyright notice must {{be included in the}} reproduced paper. USENIX acknowledges all trademarks herein. The Java ™ Virtual Machine is viewed by many as inherently insecure despite all the efforts to improve its security. In this paper we take a different approach to Java security and describe the design and implementation of a system that provides operating system style protection for Java code. We use hardware <b>protection</b> <b>domains</b> to separate Java classes, provide access control on cross domain method invocations, efficient data sharing between <b>protection</b> <b>domains,</b> and memory and CPU resource control. These security measures, when they do not violate the policy, are all transparent to the Java programs, even when a subclass is in one domain and its superclass is in another. To reduce the performance impact we group classes and share them between <b>protection</b> <b>domains</b> and map data on demand as it is being shared. 1...|$|R
50|$|The {{database}} {{managers are}} implemented as a protected subsystem and are called as a procedure from user programs and other subsystems. The implementation as a subsystem {{means that there}} is no upper limit to the potential concurrency of activities (threads) executing in the database manager. The thread of each user executes the database manager code but within its <b>protection</b> <b>domain</b> so that misbehaved and malicious programs cannot affect the integrity of the database. This approach also reduces the path lengths and overhead involved as messages {{do not have to be}} sent between the caller and the database manager. All communication is through parameters.|$|E
5000|$|Dynamic program {{analysis}} is performed by running {{the program with}} sufficient test inputs to produce interesting behaviors. Safe Drive is a low overhead system for detecting and recovering from type safety violations in device drivers. With only 4% changes to the source code of Linux network drivers {{they were able to}} implement SafeDrive and give better protection and recovery to Linux kernel. A similar project using hardware to isolate the device drivers from the main kernel is Nook. They place device drivers in separate hardware <b>protection</b> <b>domain</b> called [...] "nooks" [...] and they have separate permission setting for each pages making sure that a driver does not modify pages which are not in its domain but can read all kernel data since they share the same address space.|$|E
5000|$|Objects {{included}} Activities (now {{more commonly}} known as tasks or processes), Segments (of memory), Files, Semaphores and Clocks. Another object type, the Sphere, was a run-time <b>protection</b> <b>domain</b> within which all other object types (including other Spheres) existed. Objects could be created in arbitrary quantities, and were each referenced through a Run Time Name, or RTN. Since an object could be referenced by several RTNs belonging to different spheres, they could easily be shared between programs, and were deleted only when the object's reference count of RTNs fell to zero. Linked lists were used very extensively within E4 to manage data structures, in fact the RTN list was about the only linear list there was. (The system generation process included a phase prosaically called [...] "knitting" [...] comprising a combination of macro expansion and procedural elements, by which the initial data structures were dynamically [...] "knitted" [...] together to create an input file for the assembler.) ...|$|E
40|$|This {{document}} describes release 1. 0 of {{the application}} programming interface to the kernel of the Mungi single-address-space operating system. This interface will, in general, only be used by low-level software, most applications are expected to use a higher-level interface implemented as system libraries. Such libraries will be described in separate documents. Department of Computer Systems School of Computer Science and Engineering The University of New South Wales Sydney 2052, Australia Contents 1 Introduction 1 2 Objects and Capabilities 1 2. 1 Password capabilities.................................... 1 2. 2 Object descriptors...................................... 2 2. 3 System calls......................................... 3 3 <b>Protection</b> <b>Domains</b> 5 3. 1 Active <b>protection</b> <b>domains.................................</b> 5 3. 2 Protected procedu [...] ...|$|R
25|$|In {{computer}} science, hierarchical <b>protection</b> <b>domains,</b> {{often called}} <b>protection</b> rings, are mechanisms to protect data and functionality from faults (by improving fault tolerance) and malicious behaviour (by providing computer security). This approach is diametrically opposite {{to that of}} capability-based security.|$|R
40|$|Pebble {{is a new}} {{operating}} system designed {{with the goals of}} flexibility, safety, and performance. Its architecture combines a set of features heretofore not found in a single system, including (a) a minimal privileged mode nucleus, responsible for switching between <b>protection</b> <b>domains,</b> (b) implementation of all system services by replaceable user-level components with minimal privileges (including the scheduler and all device drivers) that run in separate <b>protection</b> <b>domains</b> enforced by hardware memory protection, and (c) generation of code specialized for each possible cross-domain transfer. The combination of these techniques results in a system with extremely inexpensive cross-domain calls that makes it well-suited for both efficiently specializing the {{operating system}} on a per-application basis and supporting modern component-based applications. ...|$|R
40|$|The Mungi single {{address space}} {{operating}} system provides a protected procedure call mechanism named <b>protection</b> <b>domain</b> extension (PDX). The PDX call executes in a <b>protection</b> <b>domain</b> {{which is the}} union of (a subset of) the caller`s, and a fixed domain associated with the procedure. On return, the caller`s original <b>protection</b> <b>domain</b> is reestablished. Extensive caching of validation data allows amortisation of setup costs over a possibly large number of invocations. The PDX mechanism forms the basis for object support in Mungi, particularly encapsulation. It is also used for accessing devices, and to implement user-level page fault handlers...|$|E
30|$|An {{architecture}} {{can contain}} several IOMMUs, each one {{dedicated to a}} subset of buses (Fig.  1). DMAR units translate and filter requests according to the <b>protection</b> <b>domain</b> assigned to the emitter device. A <b>protection</b> <b>domain</b> is defined {{by a set of}} translation policies. The process is divided into two phases. The first one identifies the <b>protection</b> <b>domain</b> assigned to the emitter device. This phase, called device to domain mapping, is conceptually similar to an address translation but instead, it associates PCI identifiers to address translation domains. In the second phase, called address translation, the addresses used by peripheral memory accesses are translated by DMAR, before crossing the host bridge (Fig.  1). This translation is similar to the one carried out by the cores Memory Management Unit (MMU). Access controls are applicable in the two translation phases.|$|E
40|$|In {{this paper}} we {{describe}} the design of an extensible kernel, called Paramecium. This kernel uses an object-based software architecture which together with instance naming, late binding and explicit overrides enables easy reconfiguration. Determining which components reside in the kernel <b>protection</b> <b>domain</b> {{is up to the}} user. An certification authority or one of its delegates certifies which components are trustworthy and therefore permitted to run in the kernel <b>protection</b> <b>domain.</b> These delegates may include validation programs, correctness provers, and system administrators. The main advantage of certifications is that it can handle trust and sharing in a non-cooperative environment. 1...|$|E
40|$|As safe languages, such as Java, find {{themselves}} leveraged to run larger, multi-task applications, {{many of the}} security concerns historically solved by hardware enforced <b>protection</b> <b>domains</b> are again sneaking their way into code. Previous schemes to enforce <b>protection</b> <b>domains</b> within the Java language have accepted run-time overhead and severe limitations on sharing semantics as a reasonable cost to achieve security. This thesis proposes soft boundaries to attain the benefits of separation without additional run-time overhead and without compromising the Java semantics. Soft boundaries use static analysis to assist the programmer in isolating components, protecting both a program's data and its control flow. Soft boundaries can be deployed either independently or in conjunction with previous separation schemes to further bolster separation...|$|R
40|$|Currently in most Unixes (and Linux), process permissions {{are based}} on userid and groupid mechanisms. This is too coarse grained to provide a {{suitable}} trust environment for running servers or programs where {{there may not be}} sufficient trust such as potential viruses. A widely used technique for securing computer systems is to execute programs inside <b>protection</b> <b>domains</b> that enforce established security policies. In this project, I give a general extensible capability based system named srun to control the specific resources used by processes. In this system, <b>protection</b> <b>domains,</b> often referred to as sandboxes, are created and managed by monitor processes. Sandboxes can be nested to form a tree structure. The srun system is flexible and can be applied to solve many types of security problems...|$|R
40|$|International audienceMulti-compartment is a flexible, {{lightweight}} architecture for {{embedded systems}} that allows multiple <b>protection</b> <b>domains</b> (compartments) to securely share processing, memory and other system resources. Compartments run in physical address space and enjoy {{direct access to}} security-critical initiator devices, such as DMA devices, while remaining protected from one another...|$|R
40|$|Executable content poses {{a threat}} of {{unauthorized}} access because it contains program code running on the user's machine. Protecting against executable content is difficult because of the inevitable flaws {{in the implementation of}} protection mechanisms. This paper introduces a hierarchical protection model to tolerate flaws in protection mechanisms. This model improves both the granularity and the robustness of protection mechanisms by nesting two protection domains: a level- 1 <b>protection</b> <b>domain</b> to provide fine-grained access control on executable content, and a level- 2 <b>protection</b> <b>domain</b> to act as a fail-safe mechanism. We achieved an efficient implementation of the hierarchical protection model that incorporated the fine-grained protection domains proposed in our previous paper...|$|E
40|$|The {{existing}} {{model of}} execution in Mungi is unnecessarily {{bound to the}} notion of a task. Each task has a <b>protection</b> <b>domain</b> which all threads in that task must use. However, it would be more useful if threads could run in whichever <b>protection</b> <b>domain</b> best served their access requirements. This paper proposes the removal of the Mungi task and the introduction of a more flexible binding of protection domains and threads, so as to make execution and protection orthogonal. Protection domains are at present transient structures associated with tasks. This paper also proposes a mechanism whereby protection domains can be made persistent and distributed across the system. Content...|$|E
40|$|General-purpose {{operating}} systems provide inadequate support for resource management in large-scale servers. Applications lack sufficient control over scheduling {{and management of}} machine resources, which {{makes it difficult to}} enforce priority policies, and to provide robust and controlled service. There is a fundamental mismatch between the original design assumptions underlying the resource management mechanisms of current general-purpose {{operating systems}}, and the behavior of modern server applications. In particular, the operating system's notions of <b>protection</b> <b>domain</b> and resource principal coincide in the process abstraction. This coincidence prevents a process that manages large numbers of network connections, for example, from properly allocating system resources among those connections. We propose and evaluate a new operating system abstraction called a resource container, which separates the notion of a <b>protection</b> <b>domain</b> from that of a resource principal. Resource containers [...] ...|$|E
40|$|Extensibility {{is a vital}} {{property}} of modern applications. An extension component is downloaded from Internet and loaded into an application. However, an extension component may be malicious. Thus {{there is a risk}} of the application being illegally accessed. To protect the application from mali-cious components, this paper proposes a multi-protection page table: a mechanism for providing pro-tection among an application and components residing in the same address space. A multi-protection page table provides kernel-level fine-grained <b>protection</b> <b>domains,</b> thereby enabling efficient cross-domain calls between fine-grained <b>protection</b> <b>domains.</b> To prove that a multi-protection page table can be implemented on stock hardware, the paper shows the implementation on IA- 32 (32 -bit Intel Architectures). Experimental results show that a cross-domain call requires only 267 - 700 cycles and the performance in a real application is also good enough. ...|$|R
40|$|This article {{investigates the}} {{security}} {{issues raised by}} the use of meta-programming systems with Java. For each possible type of MOP (compile-time, load-time, etc.), we study the permissions required for both the base and the meta-level <b>protection</b> <b>domains,</b> taking into account the flow of control between the different parts of the application...|$|R
25|$|On {{the other}} end, the {{hierarchical}} <b>protection</b> <b>domains</b> architecture {{that leads to}} the design of a monolithic kernel has a significant performance drawback each time there's an interaction between different levels of protection (i.e. when a process has to manipulate a data structure both in 'user mode' and 'supervisor mode'), since this requires message copying by value.|$|R
40|$|This paper {{describes}} {{a mechanism for}} protecting against malicious mobile code. As mobile code is linked with a hosting application and executed in the same process, a fine-grained <b>protection</b> <b>domain</b> providing an intra-process protection is required to prevent a malicious mobile code from unauthorized access. This paper introduces a multi-protection page table: a mechanism of virtual memory that enables fine-grained protection domains to be supported at the kernel level. A fine-grained <b>protection</b> <b>domain</b> (1) confines the memory accesses by mobile code in authorized areas, (2) restricts the system calls issued by mobile code, and (3) enables efficient cross-domain calls among mobile codes and a hosting application. Efficiency of cross-domain calls encourages the use of fine-grained protection domains. This paper demonstrates that a multi-protection page table can be implemented efficiently on {{the most widely used}} architectur...|$|E
40|$|This thesis {{describes}} the system {{design and implementation}} of the secure Ephemerizer System that was first introduced by Radia Perlman in 2005. The system is designed to enable users to keep data for a finite period of time before making the data unrecoverable by destroying the keys with which the data was encrypted. The task of the Ephemerizer System service is to create, advertise, and destroy keys required for the Ephemerizer System's functionalities. We designed the Ephemerizer System Service's security by placing the sensitive key management modules into a Trusted Computing Base (TCB). Our compartmentalized approach distributes security requirements at different sensitivity levels into different protection domains. In our approach, we implement the trusted <b>protection</b> <b>domain</b> (our TCB) on a tamper-resistant Javacard. We placed the key storage database into the partly trusted <b>protection</b> <b>domain</b> to improve scalability and availability of the Ephemerizer System. The partly trusted <b>protection</b> <b>domain</b> requires memory isolation and other security mechanisms provided by the underlying operating system. We implemented several mechanisms on the TCB, such as the signature engine, cryptographic modules, the on-card expiration validator, and on-card time verification. We make the Ephemerizer System available to users as a web service and expose it though a uniform API. This approach enables the seamless integration of the Ephemerizer System into business processes on heterogeneous platforms...|$|E
40|$|High-level {{languages}} like Java or ML support abstraction {{and data}} encapsulation through language {{features such as}} mod-ules, objects, classes, and/or abstract data types. But traditional compilation does not preserve such abstraction boundaries. At machine code level, there is just a single address-space where all code is readable and all data is read/writable. In other words, the entire high-level program is compiled down into one single <b>protection</b> <b>domain.</b> To a large extent, {{this is the case}} because the <b>protection</b> <b>domain</b> granularity of modern execution platforms is very coarse grained: the smallest unit of protection is an operating system process, and most programs are compiled to a single process. For fully safe languages, and if attackers can only provide input to and read output from programs, {{there is no need to}} preserve abstraction or protection boundaries after compilation...|$|E
40|$|JAVASEAL {{extends the}} JAVA {{programming}} environment {{with a model}} of mobile “agents” and strong hierarchical <b>protection</b> <b>domains.</b> These extensions {{are based on a}} formal model of distributed computation which we briefly overview. We then present the design and implementation of JAVASEAL and discuss the engineering compromises involved in inte-grating our model of mobility and protection within JAVA. ...|$|R
50|$|On {{the other}} end, the {{hierarchical}} <b>protection</b> <b>domains</b> architecture {{that leads to}} the design of a monolithic kernel has a significant performance drawback each time there's an interaction between different levels of protection (i.e. when a process has to manipulate a data structure both in 'user mode' and 'supervisor mode'), since this requires message copying by value.|$|R
40|$|We {{describe}} a two-dimensional architecture for defending against {{denial of service}} attacks. In one dimension, the architecture accounts for all resources consumed by each I/O path in the system; this accounting mechanism is implemented as an extension to the path object in the Scout operating system. In the second dimension, the various modules that define each path can be configured in separate protection domains; we implement hardware enforced <b>protection</b> <b>domains,</b> although other implementations are possible. The resulting system [...] -which we call Escort [...] -is the first example {{of a system that}} simultaneously does end-to-end resource accounting (thereby protecting against denial of service attacks) and supports multiple <b>protection</b> <b>domains</b> (thereby allowing untrusted modules to be isolated from each other). The paper describes the Escort architecture and its implementation in Scout, and reports a collection of experiments that measure {{the costs and benefits of}} using Escort to protect a web [...] ...|$|R
