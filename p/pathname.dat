88|38|Public
25|$|In 1985, RFC 959 officially {{defined a}} <b>pathname</b> {{to be the}} {{character}} string that must be entered into a file system by a user {{in order to identify}} a file.|$|E
50|$|The {{function}} AVAILABLE-SHELLS calls above function LIST-MATCHING-LINES with a <b>pathname</b> and {{an anonymous}} {{function as the}} predicate. The predicate returns the <b>pathname</b> of a shell or NIL (if the string is not the filename of a shell).|$|E
5000|$|... a local <b>pathname</b> {{relative}} to the M3U file location; e.g. Heavysets.mp3 ...|$|E
5000|$|Force {{existing}} destination <b>pathnames</b> to {{be removed}} to allow the link.|$|R
5000|$|Input {{editing and}} context {{specific}} completion over symbols, <b>pathnames,</b> class names and other objects.|$|R
5000|$|... <b>pathnames</b> {{may contain}} {{wildcard}} characters '?' and '*' (CD FOO*\B?R {{will enter the}} first directories that match the names) ...|$|R
5000|$|...> Retry OPEN using a {{different}} pathnameUse what <b>pathname</b> instead lispm:>zippy>lispm-int.lisp.newest: lispm:>zippy>lispm-init.lisp.newest ...|$|E
5000|$|...x, only {{traverse}} {{files and}} directories on the device {{on which the}} <b>pathname</b> argument is specified.|$|E
50|$|Makes {{encoding}} {{depend on}} the full <b>pathname.</b> So renaming or moving means reencoding. Hardlinks are not supported.|$|E
5000|$|Tilde {{notation}} {{offers a}} shorthand way of specifying <b>pathnames</b> {{relative to the}} home directory using the [...] "" [...] character.|$|R
5000|$|Microsoft Windows {{application}} shortcuts contain additional metadata {{that can}} be associated with the destination, whereas POSIX symbolic links are just strings that will be interpreted as absolute or relative <b>pathnames.</b>|$|R
50|$|CLOS {{has been}} {{integrated}} into ANSI Common Lisp. Generic Functions {{can be used}} like normal functions and are a first-class data type. Every CLOS class is integrated into the Common Lisp type system. Many Common Lisp types have a corresponding class. There is more potential use of CLOS for Common Lisp. The specification does not say whether conditions are implemented with CLOS. <b>Pathnames</b> and streams could be implemented with CLOS. These further usage possibilities of CLOS for ANSI Common Lisp {{are not part of}} the standard. Actual Common Lisp implementations are using CLOS for <b>pathnames,</b> streams, input/output, conditions, the implementation of CLOS itself and more.|$|R
50|$|Note:If a <b>pathname</b> is not specified, FIND {{searches}} the text typed at the promptor piped from another command.|$|E
5000|$|DPATH pathnamepathnamepathnamepathname... DPATH DPATH <b>pathname</b> : {{drive letter}} and/or folder : the command 'DPATH' will clear the path ...|$|E
5000|$|... {{slightly}} {{different set of}} characters is allowed in a <b>pathname</b> and filespec (e.g. the '$' sign is disallowed) ...|$|E
50|$|The Logic File System is a {{research}} file system which replaces <b>pathnames</b> with expressions in propositional logic. It allows file metadata to be queried with a superset of the Boolean syntax commonly used in modern search engines.|$|R
5000|$|Components form a {{directed}} graph where each Component can have several parents. Components are a logical grouping mechanism allowing Files to be grouped together {{without regard to}} their physical <b>pathnames</b> (unlike directories or folders which lie on the path).|$|R
40|$|Abstract The current {{solution}} to secure Web communication is SSLwhich relies on certificate authorities for key management, limiting {{the ability for}} individuals to independently set upsecure Web sites and forcing them to trust {{a small number of}} third parties. We propose a new model for Web security [...] SFS-HTTP [...] based on SFS. While SFS uses self-certifying <b>pathnames</b> to separate key management from file system se-curity, SFS-HTTP uses self-certifying URLs to separate key management from Web security. Users and Web site main-tainers can define their own security models without having to rely on centralized certification authorities. We implementSFS-HTTP using the SFS libraries; users configure host authentication through the SFS agent. 1 Introduction The {{current solution}} to security and authentication on theWeb is SSL [7] which, while providing these desired properties, lacks one critical feature: extensible host authentication. Currently, Web security models all depend on (centralized) certificate authorities to validate the authenticity of remoteWeb servers. SFS [10] solves this problem in the file system arena with self-certifying <b>pathnames,</b> but can we leveragethis idea for HTTP? We propose self-certifying URLs as the correct modelfor security on the Web. Self-certifying URLs, like selfcertifying <b>pathnames,</b> completely specify a remote server, in-cluding its public key. The central idea in SFS is to remove the burden of authentication from the file system; in SFS-HTTP, we separate the means of authentication from Web servers and browsers themselves. A user can verify hosts in SFS-HTTP is work in-progress. This paper is available online at [URL]...|$|R
5000|$|... dirname will {{retrieve}} the directory-path name from a <b>pathname</b> ignoring any trailing slashes$ dirname /home/martin/docs/base.wiki/home/martin/docs$ dirname /home/martin/docs//home/martin$ dirname base.wiki.$ dirname // ...|$|E
5000|$|... (defun available-shells (&optional (file #p"/etc/shells")) (list-matching-lines file (lambda (line) (and (plusp (length line)) (char= (char line 0) #\/) (<b>pathname</b> (string-right-trim '(#\space #\tab) line)))))) ...|$|E
5000|$|In Unix-like {{and some}} other {{operating}} systems, the [...] command (print working directory)writes the full <b>pathname</b> of the current working directory to the standard output.|$|E
40|$|HECPRM {{output is}} stored in the Hydrologic Engineering Center’s Data Storage System (HEC-DSS). HEC-DSS data is {{classified}} into two generic data types- time series data, in which one value is given for each time step, and paired data, in which two variables are {{related to each other}} by a piece-wise linear function. HEC-DSS data files are identified with <b>pathnames</b> consisting o...|$|R
40|$|No {{secure network}} file system has ever grown to span the Internet. Existing systems all lack {{adequate}} key management for security at a global scale. Given {{the diversity of}} the Internet, any particular mechanism a file system employs to manage keys will fail to support many types of use. We propose separating key management from file system security, letting the world share a single global file system no matter how individuals manage keys. We present SFS, a secure file system that avoids internal key management. While other file systems need key management to map file names to encryption keys, SFS file names effectively contain public keys, making them self-certifying <b>pathnames.</b> Key management in SFS occurs outside of the file system, in whatever procedure users choose to generate file names. Self-certifying <b>pathnames</b> free SFS clients from any notion of administrative realm, making inter-realm file sharing trivial. They let users authenticate servers through a number of different tech [...] ...|$|R
5000|$|Many {{computer}} programs used by system administrators in Unix-like operating systems designate files with inode numbers. Examples include popular disk integrity checking utilities {{such as the}} [...] or [...] Thus, the need naturally arises to translate inode numbers to file <b>pathnames</b> and vice versa. This can be accomplished using the file finding utility [...] with the [...] option, or the [...] command with the proper option ( [...] on POSIX-compliant platforms).|$|R
50|$|In the {{following}} example (using Symbolics Genera) the user tries to open a file in a Lisp function test called from the Read-Eval-Print-LOOP (REPL), when the file does not exist. The Lisp system presents four restarts. The user selects the Retry OPEN using a different <b>pathname</b> restart and enters a different <b>pathname</b> (lispm-init.lisp instead of lispm-int.lisp). The user code does not contain any error handling code. The whole error handling and restart code {{is provided by the}} Lisp system, which can handle and repair the error without terminating the user code.|$|E
5000|$|... takes {{a single}} argument, specifying a <b>pathname</b> for du to work; {{if it is}} not specified, the current {{directory}} is used. The SUS mandates for du the following options: ...|$|E
50|$|In 1985, RFC 959 officially {{defined a}} <b>pathname</b> {{to be the}} {{character}} string that must be entered into a file system by a user {{in order to identify}} a file.|$|E
50|$|When a map {{is saved}} a new file {{extension}} is created (.mxd). This file does not save the layers or spatial data with it, only the relative <b>pathnames.</b> What {{this means is}} if the data used in the map {{is not in the}} same location as the previous time it was opened there will be an error. This assists with keeping the file small and reduces the amount of redundancy in data management.|$|R
5000|$|Genera {{supports}} {{several different}} types of garbage collection: full Garbage Collection, in-place Garbage Collection, Incremental Garbage Collection and Ephemeral Garbage Collection. The Ephemeral Garbage Collector only uses physical memory and uses the memory management unit to get information about changed pages in physical memory. The garbage collector uses generations and the virtual memory is divided into areas. Areas can contain objects of certain types (strings, bitmaps, <b>pathnames,</b> ...) and each area can use different memory management mechanisms.|$|R
5000|$|Since [...] accepts {{only one}} operand, its usage within the inner loop of shell scripts can be {{detrimental}} to performance. Consider while read file; do dirname [...] "$file" [...] done < some-inputThe above excerpt would cause a separate process invocation for each line of input. For this reason, shell substitution is typically used instead [...] echo [...] "${file%/*}";or if relative <b>pathnames</b> need to be handled as well if -n [...] "${file##*/*}" [...] then echo [...] "." [...] else echo [...] "${file%/*}"; fiNote that these handle trailing slashes differently than dirname.|$|R
50|$|Editing {{can be done}} {{not only}} on the text of a {{previous}} command, but also on variable substitutions. Operators range from simple string search/replace to parsing a <b>pathname</b> to extract a specific segment.|$|E
5000|$|...r (--relative-only): Only output {{information}} about source files with a relative <b>pathname</b> (after source prefix elision). Absolute paths are usually system header files and coverage of any inline functions therein is normally uninteresting.|$|E
50|$|Pathnames {{represent}} {{files and}} directories in the filesystem. The Common Lisp <b>pathname</b> facility is more general than most operating systems' file naming conventions, making Lisp programs' access to files broadly portable across diverse systems.|$|E
40|$|Abstract: 2 ̆ 2 One of {{the most}} {{frequent}} complaints in the Lisp community {{is the lack of}} availability of programming tools. This document describes portable implementations of six tools for the development and maintenance of Common Lisp programs: XREF, a Lisp code cross referencer; METERING, a timing and consing code profiler; DEFSYSTEM, a 2 ̆ 7 make 2 ̆ 7 for Lisp; LOGICAL-PATHNAMES, portable <b>pathnames</b> for Lisp; SOURCE-COMPARE, a 2 ̆ 7 diff 2 ̆ 7 for Lisp; and USER-MANUAL, a program which extracts documentation for Lisp programs. All six tools are publicly available via anonymous ftp. 2 ̆...|$|R
5000|$|The {{convention}} {{for such}} an installation is for the Linux root directory to be a subdirectory of the actual root directory of the DOS boot volume, e.g. C:\LINUX [...] The various Linux top-level directories are thus, to DOS, directories such as C:\LINUX\ETC (for /etc), C:\LINUX\BIN (for /bin), C:\LINUX\LIB (for /lib), and so forth. The umsdos filesystem driver automatically prepends the C:\LINUX\ to all <b>pathnames.</b> The location of the Linux root directory is supplied to the umsdos filesystem driver {{in the first place}} via an option to the loadlin command. So, for example, for the aforegiven root directory loadlin would be invoked with a command line such as [...]|$|R
40|$|Fct ApplyFunctor Overload PrintType Unify Typecheck PrintAbsyn Stream MLLexFun Vector Ascii LrParser JoinWithArg Join MLLrValsFun CoreLang NewParse Index Misc TyvarSet Absyn Types Normalize Modules ConRep Instantiate LrTable Backpatch PrimTypes PolyCont Initial Assembly Math Unsafe Loader CInterface CleanUp CoreFunc InLine Fastlib Core Dummy Overloads MakeMos Stamps Intmap PersStamps <b>Pathnames</b> Symbol Bigint Dynamic IntStrMap ArrayExt Unionfind Siblings StrgHash Env BasicTypes Tuples ModuleUtil EqTypes Fixity TypesUtil Equal Variables BareAbsyn PrintBasics PrintVal PrintDec SigMatch IntSparcD IntShare Batch RealDebug BogusDebug UnixPaths Interact ModuleComp Importer IntSparc IntNullD Linkage Prof IntNull Interp ProcessFile FreeLvar LambdaOpt Translate Opt Reorder CompSparc MCopt MCprint Nonrec MC InlineOps Unboxed dot User's Manual, October 18, 1993 Drawing graphs with dot 2 1 Basic Graph Drawing dot draws di [...] ...|$|R
