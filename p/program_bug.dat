10|284|Public
5000|$|Synchronously {{waiting for}} the {{specific}} child processes in a (specific) order may leave zombies present longer than the above-mentioned [...] "short period of time". It {{is not necessarily a}} <b>program</b> <b>bug.</b>|$|E
50|$|Minicomputers, {{starting}} with the Digital Equipment Corporation (DEC) PDP-5 and PDP-8 (1965) simplified design by using the CPU to assist input and output operations. This saved cost but made booting more complicated than pressing a single button. Minicomputers typically had some way to toggle in short programs by manipulating an array of switches on the front panel. Since the early minicomputers used magnetic core memory, which did not lose its information when power was off, these bootstrap loaders would remain in place unless they were erased. Erasure sometimes happened accidentally when a <b>program</b> <b>bug</b> caused a loop that overwrote all of memory.|$|E
5000|$|Make {{originated}} {{with a visit}} from Steve Johnson (author of yacc, etc.), storming into my office, cursing the Fates that had caused him to waste a morning debugging a correct <b>program</b> (<b>bug</b> had been fixed, file hadn't been compiled, cc *.owas therefore unaffected). As I had spent {{a part of the}} previous evening coping with the same disaster on a project I was working on, the idea of a tool to solve it came up. It began with an elaborate idea of a dependency analyzer, boiled down to something much simpler, and turned into Make that weekend. Use of tools that were still wet was part of the culture. Makefiles were text files, not magically encoded binaries, because that was the Unix ethos: printable, debuggable, understandable stuff. Stuart Feldman ...|$|E
5000|$|The DVD {{version has}} a <b>programming</b> <b>bug</b> {{that allows the}} player to skip {{directly}} to higher levels.|$|R
50|$|Zzap!64 {{were less}} {{impressed}} by the Commodore 64 version which was criticised for dull gameplay and <b>programming</b> <b>bugs.</b> It was rated 39% overall.|$|R
5000|$|Design {{flaws and}} <b>programming</b> <b>bugs</b> in {{databases}} {{and the associated}} programs and systems, creating various security vulnerabilities (e.g. unauthorized privilege escalation), data loss/corruption, performance degradation etc.; ...|$|R
5000|$|On Windows 3.11 for Workgroups, {{the default}} {{opponent}} names are Anna, Lynda, and Terri. In later versions, the three default opponent names, Pauline, Michele, and Ben, were {{specified by the}} program's developer. One is the spouse of a Microsoft employee who found a <b>program</b> <b>bug,</b> one was a Microsoft employee who resigned in 1995, and one is an employee's child who frequented the Microsoft worksite. The names are not used in the Windows Vista version of the game, instead favoring the three cardinal directions that the computer players pertain to depending on {{their side of the}} window ("West", [...] "North", and [...] "East"). Additionally, this version of the game no longer prompts for a player name to be entered at startup, and instead uses the name of the currently logged-in user account as the player name.|$|E
50|$|In many cases, {{a single}} {{hard-coded}} value, {{such as an}} array size, may appear several times within the source code of a program. This would be a magic number. This may commonly cause a <b>program</b> <b>bug</b> {{if some of the}} appearances of the value are modified, but not all of them. Such a bug is hard to find and may remain in the program for a long time. A similar problem may occur if the same hard-coded value is used for more than one parameter value, e.g. an array of 6 elements and a minimum input string length of 6. A programmer may mistakenly change all instances of the value (often using an editor's search-and-replace facility) without checking the code to see how each instance is used. Both situations are avoided by defining constants, which associate names with the values, and using the names of the constants for each appearance within the code.|$|E
40|$|Concurrency bugs are {{becoming}} increasingly important due to the prevalence of concurrent programs. A fundamental problem of concurrent <b>program</b> <b>bug</b> detection and testing is that the interleaving space is too large to be thoroughly explored. Practical yet effective interleaving coverage criteria are desired to systematically explore the interleaving space and effectively expose concurrency bugs. This paper proposes a concurrent program interleaving coverage criteria hierarchy, including seven (including five new) coverage criteria. These criteria are all designed based on different concurrency fault models. Their cost ranges from exponential to linear...|$|E
40|$|The recent wave of Code Red worms has {{revealed}} how vulnerable web servers {{can be to}} attacks over port 80, the default TCP/IP port used for HTTP traffic. Expensive firewalls proved ineffective at preventing the worm from infecting vast numbers of web servers through a simple <b>programming</b> <b>bug.</b> While investigating the latest variant, I found that some web servers did not get infected {{even though they were}} vulnerable to the <b>programming</b> <b>bug.</b> This led me to the realization that there were ways to protect web servers from futu [...] . Copyright SANS Institut...|$|R
40|$|Program {{correctness}} {{is one of}} {{the most}} difficult challenges in parallel programming. Message Passing Interface MPI is widely used in writing parallel applications. Since MPI is not a compiled language, the programmer will be enfaced with several <b>programming</b> <b>bugs.</b> This paper presents the most common <b>programming</b> <b>bugs</b> arise in MPI programs to help the programmer to compromise between the advantage of parallelism and the extra effort needed to detect and fix such bugs. An algebraic specification of an MPI-like programming language, called Simple MPI (SMPI), to be used in writing MPI programs specification has also been proposed. In addition, both nondeterminacy and deadlocks arise in SMPI programs have been verified using Maud system...|$|R
40|$|<b>Program</b> <b>bugs</b> {{remain a}} major {{challenge}} for software developers and various tools have been proposed to help with their localization and elimination. Most present-day tools are based either on over-approximating techniques that can prove safety but may report false positives, or on underapproximating techniques that can find real bugs but with possible false negatives. In this paper, we propose a dual static analysis {{that is based on}} only over-approximation. Its main novelty is to concurrently derive conditions that lead to either success or failure outcomes and thus we provide a comprehensive solution for both proving safety and finding real <b>program</b> <b>bugs.</b> We have proven the soundness of our approach and have implemented a prototype system that is validated by a set of experiments. Categories and Subject Descriptor...|$|R
40|$|Abstract—As {{users are}} {{increasingly}} concerned about energy efficiency, {{they are also}} increasingly intolerant of performance anomalies of programs that may cause significant energy waste. Bug localization is a bottleneck {{in the development of}} multi-threaded programs. Although both static and dynamic perfor-mance bug localization techniques have been proposed, they cannot handle performance anomalies with unforeseen patterns, and cannot work well if the concept of performance anomaly is fuzzy or evolves over time for the same program. We propose a novel model-based approach to performance bug localization. The approach is based on curve fitting and trend estimation over program executions with performance data. We describe our trend estimation model and illustrate it with the result of a case study on locating three real-world performance bugs in MySQL. Keywords—performance bug, model-based approach, multi-threaded <b>program,</b> <b>bug</b> localization I...|$|E
40|$|To {{facilitate}} {{the process of}} tracking <b>program</b> <b>bug</b> symptoms to their causes while debugging, we have developed a robust architecture for program tracing and replay. rdb is a framework for program instrumentation which modifies user programs to perform complete and highly efficient tracing of an execution including interactions with the operating system and asynchronous interrupts. We have developed a library which can be plugged into existing debugging tools to add trace-and-replay functionality, and we have developed a new prototype debugger using our library which provides replay control and flowback capabilities. We discuss the design and implementation of {{all aspects of the}} system and suggest future debugging tools and techniques based on this technology. This paper is the discussion of the author's project for the degree of Master of Science, and is the culmination of two years of work in this area with Professor Robert H. B. Netzer. 1 1 Introduction Debugging is the process of bo [...] ...|$|E
40|$|Debugging is hard. Each <b>program</b> <b>bug</b> brings its own {{particular}} problems, {{but there are}} usually three basic steps that a programmer must perform. These common steps are: (1) understanding something about the failure and the program being debugged, (2) finding the error in the program, and (3) correcting the error. Tools to assist in this process vary from providing virtually no assistance to intelligent debugging systems — tools that use knowledge about programs and program bugs. The purpose of all intelligent debugging systems is to narrow a software engineer’s focus to the program statements involved in a program failure, but existing systems vary in their efficiency, data requirements, and effectiveness. Using an approach that combines ideas from existing debugging systems, we present our work on a probabilistic intelligent debugging system for high-level languages. This system, called RAID (Run-time Analysis and Intelligent Debugging system), is an automated debugger for C programs. It uses probabilistic reasoning, heuristic debugging knowledge, and structural analyses to identify the most likely causes of a program failure...|$|E
50|$|At the end {{of every}} {{function}} there is an instruction which continues execution from the memory address indicated by RETA. Before this instruction is executed, a check of CNRY ensures it has not been altered. If the value of CNRY fails the test, program execution is ended immediately. In essence, both serious attacks and harmless <b>programming</b> <b>bugs</b> result in a program abort.|$|R
5000|$|Cheat Engine exposes an {{interface}} to its {{device driver}} with , a wrapper that handles both loading and initializing the Cheat Engine driver and calling alternative Windows kernel functions. Due to a <b>programming</b> <b>bug</b> in Lazarus {{pertaining to the}} use of try and except blocks, Cheat Engine Lazarus had to remove the use of [...] and incorporate the driver functions in the main executable.|$|R
30|$|B. How to {{generate}} testcases? The quality of testcases {{is an important}} factor affecting the efficiency and effectiveness of fuzzing testing. Firstly, good testcases explore more program execution states and cover more code in a shorter time. Besides, good testcases could target potential vulnerable locations and bring a faster discovery of <b>program</b> <b>bugs.</b> Thus how {{to generate}} good testcases based on seed inputs is an important concern.|$|R
40|$|JCrasher is an {{automatic}} robustness testing tool for Java code. JCrasher examines the type information {{of a set}} of Java classes and constructs code fragments that will create instances of different types to test the behavior of public methods under random data. JCrasher attempts to detect bugs by causing the program under test to “crash”, that is, to throw an undeclared runtime exception. Although in general the random testing approach has many limitations, it also has the advantage of being completely automatic: no supervision is required except for off-line inspection of the test cases that have caused a crash. Compared to other similar commercial and research tools, JCrasher offers several novelties: it transitively analyzes methods, determines the size of each tested method’s parameter-space and selects parameter combinations and therefore test cases at random, taking into account the time allocated for testing; it defines heuristics for determining whether a Java exception should be considered a <b>program</b> <b>bug</b> or the JCrasher supplied inputs have violated the code’s preconditions; it includes support for efficiently undoing all the state changes introduced by previous tests; it produces test files for JUnit—a popular Java testing tool; and can be integrated in the Eclipse IDE. key words: software testing, test case generation, random testing, Java, state re-initialization 1...|$|E
50|$|Outlier data is {{data that}} appears to not belong in the data set. It {{can be caused by}} human error such as {{transposing}} numerals, mislabeling, <b>programming</b> <b>bugs,</b> etc. If actual outliers are not removed from the data set, they corrupt the results to a small or large degree depending on circumstances. If valid data is identified as an outlier and is mistakenly removed, that also corrupts results.|$|R
50|$|The year {{number of}} the ISO week very often differs from the Gregorian year number for dates close to 1 January. For example, 29 December 2014 is ISO 2015-W01-1, i.e., it is in year 2015 instead of 2014. A <b>programming</b> <b>bug</b> {{confusing}} these two year numbers is probably the cause of some Android users of Twitter unable to log in around midnight of 29 December 2014 UTC.|$|R
5000|$|Some program {{debugging}} {{can only}} be performed (or is more efficient or accurate when performed) at runtime. Logic errors and array bounds checking are examples. For this reason, some <b>programming</b> <b>bugs</b> are not discovered until the program is tested in a production environment with real data, despite sophisticated compile-time checking and pre-release testing. In this case, the end user may encounter a runtime error message.|$|R
25|$|As of Solaris 10 (2005), {{use of the}} NX bit is {{automatically}} enabled by default on x86 processors that support this feature. Exceptions are made for the 32-bit legacy ABI's treatment of a program's stack segment. The vast majority of programs will work without changes. However, if a program fails, the protection may be disabled via the enforce-prot-exec EEPROM option. Sun recommend that failures should be reported as <b>program</b> <b>bugs.</b>|$|R
40|$|An {{application}} {{is vulnerable to}} attacks if it exhibits incorrect behavior while it reads and processes {{the contents of a}} specially crafted malicious file. These vulnerabilities are often caused due to <b>programming</b> <b>bugs</b> in the routines that parse and utilize the fields of a file. In this paper, we propose a solution for the discovery of this kind of vulnerabilities, using an approach that is based on attack injection. 1...|$|R
5000|$|Haskell's static typing {{can make}} it easier for <b>program</b> <b>bugs</b> to be {{detected}} at compile time. Haskell code is also often thought to be concise. The Parsec library http://www.cs.uu.nl/~daan/parsec.html, a monadic combinatorial parser written entirely in Haskell, simplifies parsing. Because Haskell is a purely functional language, making the functional code interact with the real world (inputs/outputs and time-driven environment) requires thought. To achieve this, Pugs makes extensive use of monads.|$|R
40|$|One main {{motive is}} {{to solve the}} problem that {{presently}} exist in process discovery, which includes unable to search out correct and understandable process models out of event logs stemming from exceptionally flexible environments. Programming analyst spend extra time in dealing with <b>programming</b> <b>bugs.</b> An unavoidable stride of fixing bugs is bug processing in a system, because of this to efficaciously relegate a designer to every other bug. To decrease the time cost in manual work, content classifications are linked to lead <b>programmed</b> <b>bug</b> processing. This system addresses the difficulty of statistics diminishment for bug processing in a process improvement, i. e., the way to lessen the scale and identify the character of bug facts. To conquer those problems proposed system provides an automatic way for software engineers to generate mined process from systematic event logs specification and bug reviews consist of problem fixing, operating to gain others and technical task. This system focuses on characteristics from chronicled bug information units and fabricates a prescient model for each alternative bug statistics set...|$|R
50|$|In August 2016, a Casino {{machine at}} Resorts World Casino printed a prize ticket of $42,949,672.76 {{as a result}} of an {{overflow}} bug. The Casino refused to pay this amount calling it a malfunction, using in their defense that the machine clearly stated that the maximum payout was $10,000, so any prize higher than that had to be the result of a <b>programming</b> <b>bug.</b> The Iowa Supreme Court ruled in favor of the Casino.|$|R
40|$|Openflow {{provides}} a standard interface for partitioning a network into a data plane and a programmatic control plane. While providing easy network reconfiguration, Openflow introduces {{the potential for}} <b>programming</b> <b>bugs,</b> causing network deficiency. To study the behavior of OpenFlow switchs, we used Alloy to create a software abstraction, describing the internal state of a network and its OpenFlow switches. Hence, this work {{is an attempt to}} model the static and dynamic behaviour of networks configured using OpenFlow switches...|$|R
40|$|Operating system facilities, {{such as the}} kernel {{and utility}} programs, are {{typically}} assumed to be reliable. In our recent experiments, {{we have been able}} to crash 25 - 33 % of the utility programs on any version of UNIX that was tested. This report describes these tests and an analysis of the <b>program</b> <b>bugs</b> that caused the crashes. Content Indicators D. 2. 5 (Testing and Debugging), D. 4. 9 (Programs and Utilities), General term: reliability, UNIX...|$|R
40|$|Accurate {{identification}} and explication of <b>program</b> <b>bugs</b> {{requires an understanding}} of the pro-grammer's intentions. This paper describes a system called PROUST which performs intention-based diagnosis of errors in novice PASCAL programs. The technique used involves generating possible goal decompositions for the program, matching them against the program, and then proposing bugs and misconceptions to explain the mismatches. Empirical studies of PROUST's performance show that it achieves high performance in finding bugs in nontrivial student programs. 1...|$|R
40|$|Abstract—Openflow {{provides}} a standard interface for separating a network into a data plane and a programmatic control plane. This enables easy network reconfiguration, but introduces {{the potential for}} <b>programming</b> <b>bugs</b> to cause network effects. To study OpenFlow switch behavior, we used Alloy to create a software abstraction describing the internal state of a network and its OpenFlow switches. This work {{is an attempt to}} model the static and dynamic behaviour a network built using OpenFlow switches. I...|$|R
40|$|In {{this paper}} we {{translate}} concurrent C/C++ code into PDDL. The system then runs heuristic search planners against the PDDL outcome to generate traces for locating <b>programming</b> <b>bugs.</b> These counter-examples {{result in an}} interactive debugging aid and exploit efficient planner in-built heuristics. Different aspects like parsing, generation of the dependency graph, slicing, abstraction, and property conversion are described. For data abstraction we provide a library, and for increased usability the tool has been integrated in Eclipse...|$|R
5000|$|There {{were two}} {{expansion}} packs that slowly added more features to the game. The first, Conflicts in Civilization, included 20 new scenarios: 12 {{created by the}} makers of the game, and eight [...] "Best of the Net" [...] by fans. It also added an enhanced macro language for scenario scripting with advanced programming features such as variable typing and network features, which was considered widely unnecessary. Due to a <b>programming</b> <b>bug,</b> the Encarta-style Civilopedia was disabled from the game.|$|R
5000|$|For example, some {{language}} {{features that}} can be performed only (or are more efficient or accurate) at runtime are implemented in the runtime environment and may be invoked via the runtime library API, e.g. some logic errors, array bounds checking, dynamic type checking, exception handling, and possibly debugging functionality. For this reason, some <b>programming</b> <b>bugs</b> are not discovered until the program is tested in a [...] "live" [...] environment with real data, despite sophisticated compile-time checking and testing performed during development.|$|R
40|$|The {{constant}} {{increase of}} attacks against networks andtheir resources causes {{the necessity to}} protect these valuable assets. Although well-configured firewalls provide goodprotection against many attacks, some services (like HTTP or DNS) have to be publicly available. In such cases, a fire-wall has to allow incoming traffic from the Internet to these services without restrictions. As a matter of fact, the programs implementing these services are often complex andold pieces of software. This inevitably leads {{to the existence of}} <b>programming</b> <b>bugs</b> which can be exploited by skilled in-truders...|$|R
50|$|CodeSonar is {{a source}} code and binary code {{analysis}} tool that performs a whole-program, interprocedural analysis on C, C++, Java, and binary executables. It identifies <b>programming</b> <b>bugs</b> and security vulnerabilities in software. CodeSonar {{is used in the}} Defense/Aerospace, Medical, Industrial Control, Electronic, Telecom/Datacom and Transportation industries. The U.S. Food and Drug Administration (FDA) Center for Devices and Radiological Health uses it to detect defects in fielded medical devices.The U.S. National Highway Traffic Safety Administration (NHTSA) and NASA used it in its Study on Sudden Unintended Accelerationin the electronic throttle control systems of Toyota vehicles.|$|R
