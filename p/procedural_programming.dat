319|276|Public
25|$|Ruby {{has been}} {{described}} as a multi-paradigm programming language: it allows <b>procedural</b> <b>programming</b> (defining functions/variables outside classes makes them part of the root, 'self' Object), with object orientation (everything is an object) or functional programming (it has anonymous functions, closures, and continuations; statements all have values, and functions return the last evaluation). It has support for introspection, reflection and metaprogramming, as well as support for interpreter-based threads. Ruby features dynamic typing, and supports parametric polymorphism.|$|E
25|$|<b>Procedural</b> <b>programming</b> {{could be}} {{considered}} a step towards declarative programming. A programmer can often tell, simply by looking at the names, arguments, and return types of procedures (and related comments), what a particular procedure is supposed to do, without necessarily looking at the details of how it achieves its result. At the same time, a complete program is still imperative since it fixes the statements to be executed and their order of execution to a large extent.|$|E
25|$|Visual FoxPro: Visual FoxPro is a {{data-centric}} object-oriented and <b>procedural</b> <b>programming</b> language {{produced by}} Microsoft. It derives from FoxPro (originally known as FoxBASE) which {{was developed by}} Fox Software beginning in 1984. Visual FoxPro is tightly integrated with its own relational database engine, which extends FoxPro's xBase capabilities to support SQL queries and data manipulation. Visual FoxPro is a full-featured, dynamic programming language that {{does not require the}} use of an additional general-purpose programming environment. In 2007, Visual FoxPro was discontinued after version 9 Service Pack 2. It was supported until 2015.|$|E
40|$|Abstract. We {{present a}} method for model-checking of safety and {{liveness}} properties over <b>procedural</b> <b>programs,</b> {{by a combination of}} state and ranking abstractions as well as procedure summarization. Our abstraction is an augmented finitary abstraction [KP 00,BPZ 05], meaning that a concrete <b>procedural</b> <b>program</b> is first augmented with a well founded ranking function, and then abstracted by a finitary state abstraction. This results in a <b>procedural</b> abstract <b>program</b> with strong fairness requirements which is then reduced to a finite-state fair discrete system (FDS) using procedure summarization. ...|$|R
40|$|In our research, taking {{advantage}} of methods for proving inductive theorems, we apply them to verification of <b>procedural</b> <b>programs</b> written in {{a subset of the}} C language with integer type. More precisely, we transform <b>procedural</b> <b>programs</b> to equivalent rewrite systems, and verify that the rewrite systems satisfy the specifications, using the inductionless induction method. In this paper, we briefly summarize the outline of our approach. 1...|$|R
40|$|In {{order to}} {{translate}} a non-object-oriented (<b>procedural)</b> <b>program</b> into an object-oriented one, objects must be identified from the <b>procedural</b> <b>program.</b> Object-oriented <b>programs</b> (compared with <b>procedural</b> ones) {{are considered to}} be easier to reuse and maintain. Thus, object identification followed by translation from a non-object-oriented language into an object-oriented language is one way to re-engineer legacy programs. This paper gives an overview of re-engineering in general and of object identification especially. Associated with objectorientation, identification of (design) patterns is discussed, too...|$|R
25|$|<b>Procedural</b> <b>programming</b> {{is a type}} of {{imperative}} {{programming in}} which the program is built from one or more procedures (also termed subroutines or functions). The terms are often used as synonyms, but the use of procedures has a dramatic effect on how imperative programs appear and how they are constructed. Heavily-procedural programming, in which state changes are localized to procedures or restricted to explicit arguments and returns from procedures, is a form of structured programming. From the 1960s onwards, structured programming and modular programming in general have been promoted as techniques to improve the maintainability and overall quality of imperative programs. The concepts behind object-oriented programming attempt to extend this approach.|$|E
2500|$|As {{pointed out}} by Peter Landin's 1965 paper [...] "A Correspondence between ALGOL 60 and Church's Lambda-notation", {{sequential}} <b>procedural</b> <b>programming</b> languages can {{be understood in terms}} of the lambda calculus, which provides the basic mechanisms for procedural abstraction and procedure (subprogram) application.|$|E
50|$|<b>Procedural</b> <b>programming</b> {{languages}} such as C, Pascal.|$|E
40|$|AbstractSince PROLOG {{programs}} are regarded {{not only as}} declarative predicates but also as <b>procedural</b> <b>programs,</b> it is reasonable that we first write a clear declarative PROLOG program and then transform it into a possibly unclear but efficient <b>procedural</b> <b>program.</b> In this paper we present a PROLOG program transformation method especially for a binary-tree manipulation program. By using a list as intermediate representation, we can derive a <b>procedural</b> tree manipulation <b>program</b> from a declarative one. In addition we find some heuristic knowledge for writing a tree manipulation algorithm from processes of PROLOG program transformation. These processes may be useful for automatic programming...|$|R
40|$|Object-oriented {{concepts}} are useful concerning the reuse of existing software. Therefore {{a transformation of}} <b>procedural</b> <b>programs</b> to objectoriented architectures becomes an important process to enhance the reuse of <b>procedural</b> <b>programs.</b> Moreover, {{it would be useful}} to assist by automatic methods the software developers in transforming procedural code into an equivalentobject-oriented one. In this paper we aim at introducing a hierarchical clustering algorithm that can be used for assisting software developers in the process of transforming procedural code into an object-oriented architecture...|$|R
40|$|Abstract:- Object-oriented {{paradigm}} {{is built on}} the notion of real world entities. This paradigm has received higher acceptability among the programming community. This is because the programs written using an object-oriented language are easier to comprehend as compared to the <b>procedural</b> <b>programs.</b> Hence this paper makes an attempt to apply Cognitive Information Complexity Measure (CICM) on object-oriented program and proves that cognitive complexity for any <b>procedural</b> <b>program</b> is greater than the cognitive complexity of the same program written in object-oriented software...|$|R
5000|$|... #Subtitle level 3: Knowledge-based vs. <b>procedural</b> <b>programming</b> ...|$|E
5000|$|Functions: rule-based, table look-up, and <b>procedural</b> <b>programming</b> {{components}} ...|$|E
5000|$|Clear {{separation}} between logic and data (<b>procedural</b> <b>programming).</b>|$|E
40|$|Object-oriented {{concepts}} {{facilitate the}} reusability {{as well as}} the maintainability of existing software. Due to the great amount of existing procedural software, object identification in <b>procedural</b> <b>programs</b> is an important approach. The object recovery process for this identification of objects within <b>procedural</b> <b>programs</b> presents several uncertainties and ambiguities, which have to be resolved by acquisition of additional knowledge from the application domain and a human expert. In this paper we show the basic concepts of the object recovery process and describe those uncertainties and ambiguities, as well as our way of managing them in order to identify objects in <b>procedural</b> <b>programs.</b> 1 Introduction Based on the increasing importance of reusability and maintainability in software development research in this field has uncovered many problems. Especially the reuse and maintenance of procedural software is a difficult problem (e. g. the components to be reused are difficult to define, m [...] ...|$|R
40|$|A {{commonly}} held {{belief is that}} applications written in a object-oriented languages are more modular than those written in procedural languages. This paper presents results from an experiment that examines this hypothesis. Open source and industrial program modules written in the procedural languages of Fortran and C were compared with open source program modules written in the object-oriented languages of C++ and Java. The metrics {{examined in this study}} were lines of code per module and number of parameters per module. The results of the investigation support the hypothesis. The modules of the object-oriented programs were found to be half the size of those of the <b>procedural</b> <b>programs</b> and the average number of parameters per module for the objectoriented programs was approximately half that of the <b>procedural</b> <b>programs.</b> Thus the object-oriented programs were twice as modular as the <b>procedural</b> <b>programs.</b> An unexpected result was that the C++ programs were found to be no more modular than the C programs. 1...|$|R
40|$|Monolithic nite-state {{probabilistic}} {{programs have}} been abstractly modeled by nite Markov chains, and the algorithmic veri - cation problems for them have been investigated very extensively. In this paper we survey recent work conducted by the authors together with colleagues on the algorithmic veri cation of probabilistic <b>procedural</b> <b>programs</b> ([BKS,EKM 04,EY 04]). Probabilistic <b>procedural</b> <b>programs</b> can more naturally be modeled by recursive Markov chains ([EY 04]), or equivalently, probabilistic pushdown automata ([EKM 04]). A very rich theory emerges for these models. While our recent work solves a number of veri cation problems for these models, many intriguing questions remain open...|$|R
5000|$|<b>Procedural</b> <b>programming</b> using functions, {{supporting}} recursion, call-by-value etc.|$|E
5000|$|... #Subtitle level 2: Compared against {{imperative}} and <b>procedural</b> <b>programming</b> ...|$|E
50|$|Data {{manipulation}} {{languages are}} divided into two types, <b>procedural</b> <b>programming</b> and declarative programming.|$|E
30|$|Delamaro et al. [57] {{addressed}} the mutation testing of <b>procedural</b> <b>programs</b> at the integration level. The authors characterised {{a set of}} integration faults related to communication variables (i.e. variables {{that are related to}} the communication between units such as formal parameters, local and global variables and constants).|$|R
5000|$|It {{contains}} many (though not all) of the syntactical {{capabilities of the}} C programming language, {{and can be used}} to implement simple <b>procedural</b> <b>programs</b> that can be executed by a runtime parser (that is to say, MINC {{does not need to be}} compiled in any way).|$|R
30|$|Based on {{this brief}} analysis, we {{conclude}} that designing those operators was a “natural” evolution of operators previously devised for <b>procedural</b> <b>programs,</b> despite addressing different testing levels (i.e. unit and integration testing) and fault types. A few exceptions regard some class-level operators [59] which still require assessment through empirical studies.|$|R
5000|$|GarGar - A Spanish <b>procedural</b> <b>programming</b> {{language}} {{based on}} Pascal for learning purposes.|$|E
5000|$|Rapira - A Russian-based {{interpreted}} <b>procedural</b> <b>programming</b> {{language with}} strong dynamic type system.|$|E
5000|$|... pic is a <b>procedural</b> <b>programming</b> {{language}} providing various drawing functions like {{circle and}} box.|$|E
5000|$|Phoenix - A C-like {{high-level}} imperative <b>procedural</b> Arabic <b>programming</b> language.|$|R
40|$|Object-oriented {{concepts}} seem to {{be useful}} concerning the reuse of existing software. Therefore a transformation of <b>procedural</b> <b>programs</b> to object-oriented programs becomes an important process to enhance the reuse potential of <b>procedural</b> <b>programs.</b> In this paper we describe a program transformation process, which transforms originally procedural systems to objectoriented systems. The objects of the resulting system may then be used for further object-oriented systems engineering, avoiding many problems arising in connection with procedural software reuse (i. e. module interconnection, etc.). Keywords: program transformation, software reuse, reverse engineering, reusable components. Introduction Software reuse has {{become more and more}} important in industrial software production to reduce the costs of software development as well as {{to improve the quality of}} the resulting product. 1 Research on this topic has uncovered many problems, especially concerning the reuse of procedural softwa [...] ...|$|R
40|$|Abstract. We {{present a}} tool for {{reachability}} analysis of <b>procedural</b> <b>programs</b> whose statements consist of affine equations and inequations. The algorithms uses finite automata to finitely represent possibly infinite sets of both stack contents and memory valuations. We illustrate our program on some examples and compare it to Moped, a model checker for pushdown systems. ...|$|R
50|$|TNSDL is a {{general-purpose}} <b>procedural</b> <b>programming</b> language. It {{is especially}} well-suited for developing highly concurrent, distributed systems.|$|E
5000|$|<b>Procedural</b> <b>programming,</b> {{structured}} programming - specifies the steps a program must take {{to reach a}} desired state.|$|E
50|$|TNSDL is a {{strongly}} typed <b>procedural</b> <b>programming</b> language. Its basic capabilities {{are comparable to}} the C and Pascal languages.|$|E
30|$|Control flow- {{and data}} flow-based {{criteria}} for <b>procedural</b> <b>programs</b> (e.g. all-nodes, all-edges and all-uses) are well-established. They date from 30 years ago [39] {{and have been}} evolved to address the integration level [47]. The underlying models explicitly show the internal logic of units and the data interactions when either unit or integration testing is on focus.|$|R
40|$|In {{this paper}} we present {{advantages}} of object-oriented programming concept {{with respect to}} conventional, procedural approach for the case of finite element modeling in nonlinear structural mechanics. We analyze and discus the program structure, main classes and implementation details. The accuracy and efficiency of object-oriented program design is evaluated by comparing with <b>procedural</b> <b>program</b> for the same task...|$|R
40|$|Dynamic program {{visualization}}, i. e. the {{visualization of}} the runtime {{behavior of a}} program {{as opposed to the}} static structure of its source code has been investigated for various kinds of programs, usually on a fairly low level. The focus has been on control flow in <b>procedural</b> <b>programs</b> or on the communication between objects in object-oriented programs...|$|R
