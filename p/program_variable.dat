68|1668|Public
5000|$|A control {{variable}} in computer programming is a <b>program</b> <b>variable</b> {{that is used}} to regulate the flow of control of the program [...]|$|E
50|$|Fluctuat is {{a static}} analyser, based on {{abstract}} interpretation. Compared to similar tools like Polyspace or Astrée, {{it relies on}} zonotopes as an abstract domain. It means {{that the value of}} each <b>program</b> <b>variable</b> is abstracted by a linear expression over noise symbols (internal variables that range in -1,1).|$|E
50|$|The first {{electronic}} payazzo {{was introduced}} in 1982; older payazzos were completely mechanical. In electronic payazzos, the actual game is played with a real, physical coin, but the electronics are used {{to determine if the}} player feeds money into the machine, to register whether a coin falls into a winning slot and to pay winnings to the player. By using the electronics, it was possible <b>program</b> <b>variable</b> winning sums for each slot.|$|E
40|$|Abstract This paper studies how to {{describe}} the real-time behaviour of programs using Duration Calculus. Since <b>program</b> <b>variables</b> are interpreted as functions over time in real-time programming, and it is inevitable to introduce quantifications over <b>program</b> <b>variables</b> in order {{to describe}} local variable declaration and declare local channel and so on, therefore, to establish a higher-order du-ration calculus (HDC) is necessary. We firstly establish HDC, then show some real-time properties of programs in terms of HDC, and lastly, prove that HDC is complete on abstract domains {{under the assumption that}} all <b>program</b> <b>variables</b> vary finitely in the paper...|$|R
50|$|Local <b>program</b> <b>variables</b> {{cannot be}} removed once added without {{deleting}} the program.|$|R
50|$|Autotype {{can also}} refer to {{automatically}} determining a peripheral's configuration or a <b>program's</b> <b>variables.</b>|$|R
50|$|A {{declaration}} has global scope {{if it has}} effect throughout {{an entire}} <b>program.</b> <b>Variable</b> names with global scope — called global variables — are frequently considered bad practice, {{at least in some}} languages, due to the possibility of name collisions and unintentional masking, together with poor modularity, and function scope or block scope are considered preferable. However, global scope is typically used (depending on the language) for various other sorts of identifiers, such as names of functions, and names of classes and other data types. In these cases mechanisms such as namespaces are used to avoid collisions.|$|E
40|$|AbstractThe {{value range}} {{information}} of program variables {{is useful in}} many applications such as compiler optimization and program analysis. In the framework of abstract interpretation, the interval abstract domain infers numerical bounds for each <b>program</b> <b>variable.</b> However, in certain applications such as automatic parallelization, symbolic ranges are often desired. In this paper, we present a new numerical abstract domain, namely the abstract domain of parametric ranges, to infer symbolic ranges over nonnegative parameters for each <b>program</b> <b>variable.</b> The new domain is designed based on the insight that in certain contexts, program procedures often have nonnegative parameters, such as the length of an input list {{and the size of}} an input array. The domain of parametric ranges seeks to infer the lower and upper bounds for each <b>program</b> <b>variable</b> where each bound is a linear expression over nonnegative parameters. The time and memory complexity of the domain operations of parametric ranges is O(nm) where n is the number of program variables and m is the number of nonnegative parameters. On this basis, we show the application of parametric ranges to infer symbolic ranges of the sizes of list segments in programs manipulating singly-linked lists. Finally, we show preliminary experimental results...|$|E
40|$|We {{propose the}} notion of logical {{reliability}} for real-time program tasks that interact through periodically updated program variables. We describe a reliability analysis that checks if the given short-term (e. g., single-period) reliability of a <b>program</b> <b>variable</b> update in an implementation is sufficient to meet the logical reliability requirement (of the <b>program</b> <b>variable)</b> in the long run. We then present a notion of design by refinement where a task can be refined by another task that writes to program variables with less logical reliability. The resulting analysis can be combined with an incremental schedulability analysis for interacting real-time tasks proposed earlier for the Hierarchical Timing Language (HTL), a coordination language for distributed real-time systems. We implemented a logical-reliabilityenhanced prototype of the compiler and runtime infrastructure for HTL. ...|$|E
5000|$|Predicative {{programming}} is a methodology for program specification and refinement. The central idea of predicative {{programming is}} that each specification is a predicate (generally written as a boolean expression) that is true of acceptable behaviours and false of unacceptable behaviours. It follows that refinement is reversed implication universally quantified over behaviours:Commands in a programming language {{are considered to be}} a special case of specifications—special only because they are compilable. For example, in an environment where the <b>program</b> <b>variables</b> are , , and , the command [...] is considered equivalent to the predicate (represented here by a boolean expression)in which , , and [...] represent the initial values of the <b>program</b> <b>variables</b> and [...] , , and [...] represent the final values of the <b>program</b> <b>variables.</b> Thus ...|$|R
5000|$|Formatted dump or {{symbolic}} debugging, tools allowing {{inspection of}} <b>program</b> <b>variables</b> on error or at chosen points ...|$|R
40|$|A simple linear loop is {{a simple}} while loop with linear {{assignments}} and linear loop guards. If a simple linear loop has only two <b>program</b> <b>variables,</b> we give a complete algorithm for computing the set of all the inputs on which the loop does not terminate. For the case of more <b>program</b> <b>variables,</b> we show that the non-termination set cannot be described by Tarski formulae in generalComment: 15 pages, 3 figure...|$|R
40|$|Conditional branches connect the values of program variables with the execution paths and thus with the execution times,  including the worstcase execution time (WCET).  Flow analysis aims to {{discover}} this connection and represent it as loop bounds and other path constraints. Usually,  {{a specific}} analysis of the dependencies between branch conditions and assignments to variables creates some representation of the feasible paths,  for example as IPET executioncount constraints, from which a WCET bound is calculated. This paper explores another approach that uses a more direct connection between variable values and execution time. The execution time is modeled as a <b>program</b> <b>variable.</b> An analysis of the dependencies between variables,  including the executiontime variable,   gives   a   WCET   bound   that   excludes   many   infeasible   paths. Examples   show   that   the approach often works,  in principle. It remains to be seen if it is scalable to real programs. 1...|$|E
3000|$|The {{decisions}} in this code example are the assignments of a logical expression to a <b>program</b> <b>variable.</b> This {{is just a}} compact form instead of using an if/then construct. Now lets look at the inlined implementation variant of this model, which is generated by default by the code generator Real-Time Workshop of Matlab 6.5. 1 and Simulink 5.1. In the inlined implementation variant we get a single decision: [...]...|$|E
40|$|AbstractThe action systems {{framework}} for modelling parallel programs {{is used to}} formally specify a microprocessor. First the microprocessor is specified as a sequential program. The sequential specification is then decomposed and refined into a concurrent program using correctnesspreserving program transformations. Previously this microprocessor has been specified at Caltech, where an asynchronous circuit for the microprocessor {{was derived from the}} specification. We propose a specification strategy that is based on the idea of spatial decomposition of the <b>program</b> <b>variable</b> space...|$|E
40|$|<b>Program</b> <b>variables</b> in a call-by-value mode {{are added}} to the {{elementary}} syntax of program algebra. Only very simple data are considered: finite sequences of bits. The meaning of <b>program</b> <b>variables,</b> data type constants and assignments in a call-by-value regime is given by means of a translation into behaviors or processes. Assignment actions as well as input actions are modeled by means of sequential substitutions for processes from behavior extraction...|$|R
40|$|Abstract. Dividing {{the heap}} memory of {{programs}} into regions {{is the starting}} point of region-based memory management. In our existing work of enabling region-based memory management for Mercury, a program analysis was used to distribute data over the regions. An important goal of the analysis is to decide which <b>program</b> <b>variables</b> should end up in the same region. For a popular class of programs, it covetously puts <b>program</b> <b>variables</b> in the same region, while more memory could have been reused if they had been kept in separate ones. In this paper we define a new refined region analysis that is keen to keep <b>program</b> <b>variables</b> in separate regions by taking into account the different execution paths of a procedure. With the more precise, path-sensitive analysis we can reduce the memory footprint for several programs. ...|$|R
50|$|A function-level {{program is}} variable-free (cf. point-free <b>programming),</b> since <b>program</b> <b>variables,</b> which are {{essential}} in value-level definitions, are not needed in function-level programs.|$|R
40|$|International audienceWe {{propose a}} type system for an {{imperative}} programming language, which certifies program time bounds. This type system {{is based on}} secure flow information analysis. Each <b>program</b> <b>variable</b> has a level and we prevent information from flowing from low level to higher level variables. We also introduce a downgrading mechanism in order to delineate a broader class of programs. Thus, we propose a relation between security-typed language and implicit computational complexity. We establish a characterization {{of the class of}} polynomial time functions...|$|E
40|$|Municipal {{recycling}} {{is driven by}} a variety of factors. Yet how these factors change over time is not well understood. I analyze a suite of contextual and <b>program</b> <b>variable</b> in multiple time periods, spanning 16 years, in the Commonwealth of Massachusetts. Based on the models run, I reach the surprising conclusion that most program variables have an insignificant effect on recycling rates. These findings can inform municipal officials and waste managers as they seek new ways to increase municipal recycling participation...|$|E
40|$|In base SAS ® {{programming}} {{there is}} a very useful function called LAG which allows a SAS program to reference previous values of a SAS <b>program</b> <b>variable.</b> Wouldn’t it be wonderful if a similar function were available to look ahead at the value of a dataset field in the next observation. There is no such function available but with some simple programming logic a “look ahead ” functionality can be achieved. This paper will describe a technique {{that can be used to}} achieve this...|$|E
40|$|The {{focus of}} this {{correlational}} {{study was to determine}} which selected demographic and <b>program</b> <b>variables</b> could be utilized in developing an instructional technology profile of North Carolina and Virginia secondary agricultural education teachers. Overall no demographic or <b>program</b> <b>variables</b> were found to be significant indicators to develop a profile. Recommendations included future research upon other instructional technology variables and possibly implementing a “train the trainer ” philosophy to encourage more technology adoption by the majority of North Carolina and Virginia secondary agricultural education teachers...|$|R
40|$|Security {{testing has}} gained {{significant}} attention recently {{due to the}} huge number of attacks against software systems. This paper presents a novel security testing method using trace-based symbolic execu-tion and satisfiability analysis. It reuses test cases generated from traditional functional testing to produce execution traces. An execution trace is a sequence of program statements exercised by a test case. Each execution trace is symbolically executed to produce program constraints and security constraints. A pro-gram constraint is a constraint imposed by program logic on <b>program</b> <b>variables.</b> A security constraint is a condition on <b>program</b> <b>variables</b> that must be satisfied to ensure system security. A security vulnerability exists {{if there is an}} assignment of values to <b>program</b> <b>variables</b> that satisfies the program constraint but violates the security constraint. This assignment of values is used to generate test cases to uncover the security vulnerability. One novelty of this method is a test model that unifies program constraints and security constraints such that formal reasoning can be applied to detect vulnerabilities. Another nov-elty is attribute-based analysis that abstracts <b>program</b> <b>variables</b> and functions for effective and efficient symbolic execution. A tool named SecTAC has been implemented and applied to 14 benchmark pro-grams and 3 moderate size open-source programs. The experiment shows that SecTAC quickly detects all reported vulnerabilities and 15 new ones that have not been detected previously. The merits of the proposed method are threefold. First, trace-based symbolic execution reduces the search space greatly as compared to conventional symbolic execution. Second, attribute-based analysis tracks more useful information about <b>program</b> <b>variables</b> and functions than previous methods, resulting in more effective detection of vulnerabilities. Third, it is efficient and effective as the experiment result indicates. ...|$|R
40|$|We {{present a}} shallow {{embedding}} in PVS of a predicate transformer semantics of an imperative language suitable for reasoning about recursive procedures with parameters and local variables. We use the PVS dependent type mechanism for implementing <b>program</b> <b>variables</b> of different types. We use an uninterpreted state space and define the <b>program</b> <b>variables</b> behavior {{by means of}} certain tree functions {{that are supposed to}} satisfy some axioms. Unlike in the implementations mentioned in the literature, we do not need to change the state space when adding local variables or procedure parameters. ...|$|R
40|$|In my diploma thesis I {{deal with}} {{the image on the}} border of digital and analog media and horizon as border of visual perception. Output is {{computer}} <b>program,</b> <b>variable</b> image, digital version of artefact. The image is the grid of pictures superimposed in horizontal strip, particular pictures we can vary for their alternatives. The image we can see from various point of view: 1. As a picture on the wall of gallery, 2. from the space behind the canvas, from where is able to contol it with cursor, 3. on the internet, as video stream...|$|E
40|$|The NECAP is a {{sophisticated}} building design and energy analysis tool which has embodied within it {{all of the}} latest ASHRAE state-of-the-art techniques for performing thermal load calculation and energy usage predictions. It {{is a set of}} six individual computer programs which include: response factor program, data verification program, thermal load analysis <b>program,</b> <b>variable</b> temperature program, system and equipment simulation program, and owning and operating cost program. Each segment of NECAP is described, and instructions are set forth for preparing the required input data and for interpreting the resulting reports...|$|E
40|$|A new {{approach}} to construction of reliable discrete PLC-programs with timers — programming based on specification and verification — is proposed. Timers are modelled in a discrete way. For the specification of a program behavior we use the linear-time temporal logic LTL. Programming is {{carried out in the}} ST-language according to a LTLspecification. A {{new approach}} to programming of PLC is shown by an example. The proposed programming approach provides an ability of a correctness analysis of PLC-programs using the model checking method. The programming requires fulfillment of the following two conditions: 1) a value of each variable should be changed not more than once per one full PLC-program implementation (per one full working cycle of PLC); 2) a value of each variable should only be changed in one place of a PLC-program. Under the proposed approach the change of the value of each <b>program</b> <b>variable</b> is described by a pair of LTL-formulas. The first LTL-formula describes situations that increase the value of the corresponding variable, the second LTL-formula specifies conditions leading to a decrease of the variable value. The LTL-formulas (used for specification of the corresponding variable behavior) are constructive {{in the sense that they}} construct the PLC-program, which satisfies temporal properties expressed by these formulas. Thus, the programming of PLC is reduced to the construction of LTL-specification of the behavior of each <b>program</b> <b>variable.</b> </p...|$|E
50|$|A micro-cycle is also {{defined as}} a number of {{training}} sessions, built around a given combination of acute <b>program</b> <b>variables,</b> which include progression as well as alternating effort (heavy vs. light days). The length of the micro-cycle should correspond to the number of workouts - empirically often 4-16 workouts - it takes for the athlete or fitness client to adapt to the training program. When the athlete or fitness client has adapted to the program and no longer makes progress, a change to one or more <b>program</b> <b>variables</b> should be made.|$|R
50|$|The {{first one}} {{corresponds}} to duplicating {{some or all}} of the <b>program</b> <b>variables</b> to introduce data redundancy, and modifying all the operators to manage the introduced replica of the variables.|$|R
40|$|Program {{analysis}} {{requires the}} generation of program properties expressing conditions to hold at intermediate program locations. When it comes to programs with loops, these properties are typically expressed as loop invariants. In this paper we study a class of multi-path program loops with numeric variables, in particular nested loops with conditionals, where assignments to <b>program</b> <b>variables</b> are polynomial expressions over <b>program</b> <b>variables.</b> We call this class of loops extended P-solvable and introduce an algorithm for generating all polynomial invariants of such loops. By an iterative procedure employing Gröbner basis computation, our approach computes the polynomial ideal of the polynomial invariants of each program path and combines these ideals sequentially until a fixed point is reached. This fixed point represents the polynomial ideal of all polynomial invariants of the given extended P-solvable loop. We prove termination of our method and show that the maximal number of iterations for reaching the fixed point depends linearly {{on the number of}} <b>program</b> <b>variables</b> and the number of inner loops. In particular, for a loop with m <b>program</b> <b>variables</b> and r conditional branches we prove an upper bound of m*r iterations. We implemented our approach in the Aligator software package. Furthermore, we evaluated it on 18 programs with polynomial arithmetic and compared it to existing methods in invariant generation. The results show the efficiency of our approach...|$|R
40|$|This {{research}} represent descriptive research [at] {{employees of}} PT. ISS Unlucky Servisistem with title Influence Of Program Planning Of Career To Spirit Of activity Employees at PT. ISS Servisystem. Intention {{of this research}} is to know program planning of career and spirit of employees activity of PT. ISS Servisystem and influence of program planning of career to spirit of employees activity at PT. ISS Servisystem. Analyzer used to know program perncnaan of career to spirit of employees activity is to use analysis span and scale of regresi linear modestly. Pursuant to at result of research got that program planning of career can give influence which is signifikan to spirit of employees activity. This matter because if a employees can put the srews on and program planning of good career, hence employees can work hotly which later can assist to improve career which have been programmed with goals which have in determining and passing planning of career. To know influence of free variable (Planning of development of career (X) to Spirit of activity conducted with examination of t-test. From result of analysis of regresi obtained by doubled linear of value of t count/calculate <b>Program</b> <b>variable</b> planning of career (X) equal to 8, 267. the mentioned of meaning that <b>program</b> <b>variable</b> planning of career have influence to spirit of activity by signifikan. ...|$|E
40|$|We {{present an}} {{automatic}} iterative abstraction-refinement methodology {{in which the}} initial abstract model is generated by an automatic analysis of the control structures in the program to be verified. Abstract models may admit erroneous (or "spurious") counterexamples. We model correspondingly. The refinement algorithm keeps {{the size of the}} abstract state space small due to the use of abstraction functions which distinguish many degrees of abstraction for each <b>program</b> <b>variable.</b> We describe an implementation of our methodology in NuSMV. Practical experiments including a large Fujitsu IP core design with about 500 latches and 10000 lines of SMV code confirm the effectiveness of our approach...|$|E
40|$|An {{approach}} to construction and verification of PLC LD-programs for discrete problems is proposed. For the specification {{of the program}} behavior, we use the linear-time temporal logic LTL. Programming is {{carried out in the}} LD-language (Ladder Diagram) according to an LTL-specification. The correctness analysis of an LTL-specification is carried out by the symbolic model checking tool Cadence SMV. A new {{approach to}} programming and verification of PLC LD-programs is shown by an example. For a discrete problem, we give a LD-program, its LTL-specification and an SMV-model. The purpose of the article is to describe an approach to programming PLC, which would provide a possibility of LD-program correctness analysis by the model checking method. Under the proposed approach, the change of the value of each <b>program</b> <b>variable</b> is described by a pair of LTL-formulas. The first LTL-formula describes situations which increase the value of the corresponding variable, the second LTL-formula specifies conditions leading to a decrease of the variable value. The LTL-formulas (used for speci- fication of the corresponding variable behavior) are constructive {{in the sense that they}} construct the PLC-program (LD-program), which satisfies temporal properties expressed by these formulas. Thus, the programming of PLC is reduced to the construction of LTLspecification of the behavior of each <b>program</b> <b>variable.</b> In addition, an SMV-model of a PLC LD-program is constructed according to LTL-specification. Then, the SMV-model is analysed by the symbolic model checking tool Cadence SMV. </p...|$|E
40|$|We use an {{existing}} ACP-style process algebra as a formal framework for imperative sequential programming. The framework is realized by instantiating this process algebra with a suitable set of atomic actions and providing concrete definitions for the auxiliary functions assumed by this process algebra. In this framework, we can reason algebraically about programs with assignments and <b>programming</b> <b>variables.</b> We show the <b>programming</b> <b>variables</b> obey scoping rules known from existing programming languages. Next, {{we use the}} framework to define well known constructs of sequential programming languages, like conditional statements and loops, and show laws characterizing these constructs can be proved using the ACP axioms...|$|R
40|$|An {{econometric model}} of planted wheat acreage was {{estimated}} for five distinct production {{regions in the}} United States. This structural investigation represents an update of previous published work with specific attention given to policy <b>program</b> <b>variables,</b> weather, production cost, risk, market price influences, and program participation. Estimated results indicated regional divergence in responsiveness to government <b>program</b> <b>variables.</b> The most significant divergence occurred in the Cornbelt and Southeast - soft red winter wheat areas. Results indicate that management of the wheat program from the USDA level will contain countervailing production incentives unless these regional characteristics are taken into consideration in policy directives. Crop Production/Industries,...|$|R
40|$|We {{consider}} an abstraction of programs which preserves affine assignments exactly while conservatively dealing with other assignments and ignoring conditions at branches. We present an interprocedural analysis of such abstracted programs which for every program point determines {{the set of}} all affine relations between <b>program</b> <b>variables</b> which are valid when reaching. The runtime of this algorithm is linear in the program size and polynomial {{in the number of}} occurring variables. We extend this result to a polynomial-time algorithm which determines for every program point the set of all valid polynomial relations between <b>program</b> <b>variables</b> of bounded degree...|$|R
