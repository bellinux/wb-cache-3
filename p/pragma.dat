163|96|Public
25|$|The LANGUAGE <b>pragma</b> was specified. By 2010 {{dozens of}} {{extensions}} {{to the language}} were in wide use, and GHC (among other compilers) provided the LANGUAGE <b>pragma</b> to specify individual extensions {{with a list of}} identifiers. Haskell 2010 compilers are required to support the Haskell2010 extension, and encouraged to support several others that correspond to extensions added in Haskell 2010.|$|E
500|$|Perl 5 added {{features}} that support complex data structures, first-class functions (that is, closures as values), and an object-oriented programming model. These include references, packages, class-based method dispatch, and lexically scoped variables, along with compiler directives (for example, the strict <b>pragma).</b> A major additional feature introduced with Perl 5 was {{the ability to}} package code as reusable modules. Wall later stated that [...] "The whole intent of Perl 5's module system was to encourage the growth of Perl culture rather than the Perl core." ...|$|E
2500|$|T. Pratsch, Theodoros Studites (759-826): zwischen Dogma und <b>Pragma</b> (Frankfurt am Main, 1998).|$|E
40|$|Abstract: The villains of {{synthesis}} {{for many}} a design are the “parallel_case ” and “full_case” synthesis <b>pragmas.</b> The dastardly deeds of these infamous <b>pragmas</b> {{have been well}} documented in a past SNUG paper, “‘full_case parallel_case’, the Evil Twins of Verilog Synthesis”, by Clifford Cummings[6]. Despite this excellent paper, these <b>pragmas</b> are still misunderstood and are abused by many design engineers. SystemVerilog introduces two new synthesis heroes, “unique ” and “priority”. These new keywords are intended to replace the villainous twin <b>pragmas.</b> This paper discusses in depth {{the purpose of the}} unique and priority decision modifiers, and how they affect simulation, synthesis, and formal verification. Comparisons between the SystemVerilo...|$|R
40|$|In earlier work, we {{proposed}} extending Ada with {{a high-level}} parallel programming layer consisting of three <b>pragmas</b> that indicate where standard sequential constructs can be executed in parallel without changing the sequential semantics of a program. The three <b>pragmas</b> specify:i) parallelizable sequences of statements, (ii) parallelizable for-loop statements, and (iii) single-assignment types for synchronization. A precise definition of these <b>pragmas</b> {{was given by}} means of transformations to standard Ada tasking constructs. In this paper, we improve our definition of the parallel programming layer and demonstrate that the <b>pragmas</b> can be implemented efficiently {{on top of an}} existing Ada compiler by straightforward preprocessing using the defining transformations. We present three simple parallel programs that exhibit good speedups over sequential programs, when executed on a multiprocessor computer. Development of these programs was considerably easier than the direct use of Ada tasking, because the parallel programs are identical to equivalent sequential programs except for the added <b>pragmas...</b>|$|R
50|$|The ODB-specific <b>pragmas</b> {{can also}} be placed outside of the class declaration.|$|R
2500|$|Pratsch, T., Theodoros Studites (759–826): zwischen Dogma und <b>Pragma</b> (Frankfurt am Main, 1997) ...|$|E
2500|$|However {{his work}} as an improviser by now made him far {{more aware of the}} {{limitations}} of his current way of writing. An encounter with Iancu Dumitrescu and the Romanian Spectralist school provided a turning point, after which he began to find new ways of developing musical structures out of the behaviours of sounds and unstable acoustic systems. This became evident with the release of the CD <b>Pragma</b> in 1998, on which the pieces are realised on a computer using a mix of live instruments and samples.|$|E
2500|$|The TeX {{system has}} precise {{knowledge}} of the sizes of all characters and symbols, and using this information, it computes the optimal arrangement of letters per line and lines per page. It then produces a DVI file ("DeVice Independent") containing the final locations of all characters. This dvi file can be printed directly given an appropriate printer driver, {{or it can be}} converted to other formats. Nowadays, pdfTeX is often used, which bypasses DVI generation altogether. The base TeX system understands about 300 commands, called primitives. [...] These low-level commands are rarely used directly by users, and most functionality is provided by format files (predumped memory images of TeX after large macro collections have been loaded). Knuth's original default format, which adds about 600 commands, is Plain TeX. [...] The most widely used format is LaTeX, originally developed by Leslie Lamport, which incorporates document styles for books, letters, slides, etc., and adds support for referencing and automatic numbering of sections and equations. Another widely used format, AMS-TeX, is produced by the American Mathematical Society and provides many more user-friendly commands, which can be altered by journals to fit with their house style. Most of the features of AMS-TeX can be used in LaTeX by using the AMS [...] "packages". This is then referred to as AMS-LaTeX. Other formats include ConTeXt, used primarily for desktop publishing and written mostly by Hans Hagen at <b>Pragma.</b>|$|E
50|$|In C/C++, OpenMP uses #pragmas. The OpenMP {{specific}} <b>pragmas</b> {{are listed}} below.|$|R
5000|$|In Ada, {{compiler}} directives {{are called}} <b>pragmas</b> (short for [...] "pragmatic information").|$|R
5000|$|Compiler <b>pragmas</b> for {{directing}} optimizations such as inline {{expansion and}} specializing functions for particular types.|$|R
5000|$|Usage:/*if <b>pragma</b> once support {{then use}} it in {{addition}} to include guard*/#if _pragma_once_support# <b>pragma</b> once#endif ...|$|E
50|$|Originally {{entitled}} pragmatex, ConTeXt {{was given}} its name around 1996. by Hans Hagen from <b>PRAGMA</b> Advanced Document Engineering (<b>Pragma</b> ADE), a Netherlands-based company.|$|E
50|$|Lee defines <b>pragma</b> as {{the most}} {{practical}} type of love, not necessarily derived out of true romantic love. Rather, <b>pragma</b> is a convenient type of love.|$|E
5000|$|The Glasgow Haskell Compiler, {{the most}} {{commonly}} used Haskell compiler, supports <b>pragmas</b> such as [...]|$|R
500|$|Good Perl {{practices}} {{require more}} complex programs {{to add the}} [...] and [...] <b>pragmas,</b> leading into something like: ...|$|R
5000|$|ECMAScript also adopts the [...] syntax for directives, {{with the}} {{difference}} that <b>pragmas</b> are declared as string literals (e.g. , or [...] ), {{rather than a}} function call.|$|R
5000|$|The {{function}} is recursive and not accompanied by [...] With the <b>pragma,</b> recursive functions are inlined to a default depth of 16 calls. To reduce the inlining depth, use [...] <b>pragma.</b>|$|E
5000|$|Pacific Rim Applications and Grid Middleware Assembly (<b>PRAGMA)</b> ...|$|E
50|$|Burke's typefaces include Celeste, Celeste Sans, Parable and <b>Pragma.</b>|$|E
5000|$|The 1999 {{standard}} of the C programming language supports the FMA operation through the [...] standard math library function, and standard <b>pragmas</b> controlling optimizations based on FMA.|$|R
50|$|It {{translates}} C and Fortran {{programs with}} OpenMP <b>pragmas</b> into C code suitable for compiling with a native compiler linked withthe Omni OpenMP runtime library. It does for loop parallelization.|$|R
5000|$|OpenACC defines an {{extensive}} list of <b>pragmas</b> (directives), for example: #pragma acc parallel #pragma acc kernelsBoth {{are used to}} define parallel computation kernels to be executed on the accelerator, using distinct semantics ...|$|R
5000|$|T. Pratsch, Theodoros Studites (759-826): zwischen Dogma und <b>Pragma</b> ...|$|E
5000|$|... {{accessibility}} appropriately {{from outside}} the module. The strict <b>pragma</b> ...|$|E
5000|$|... {{helpful for}} debugging. The {{warnings}} <b>pragma</b> turns on optional warnings.|$|E
50|$|WPP's {{understanding}} of C/C++ syntax is very limited. In particular, {{it does not}} expand macros (except in special circumstances where it is necessary), nor does it handle <b>pragmas</b> or perform any semantic analysis.|$|R
5000|$|In Ruby, {{interpreter}} directives {{are referred}} to as <b>pragmas</b> and are specified by top-of-file comments that follow a [...] notation. For example, [...] indicates that the file is encoded via the UTF-8 character encoding.|$|R
40|$|International audienceOften tools {{need to be}} {{extended}} at runtime depending {{on the availability of}} certain features. Simple registration mechanisms can handle such a situation: It often boils down to represent an action and describe such action with some meta-data. However, ad-hoc registration mechanisms have some drawbacks: they are often not uniform and do not fit well with code navigability. In addition, metadata is not automatically synchronized with the data or behavior it describes. In this article we present the notion of <b>pragmas,</b> method annotations, as it was introduced in VisualWorks and now it is an important extensibility mechanism of Pharo. We present some examples of <b>pragmas</b> within Pharo...|$|R
50|$|The three {{secondary}} {{types of}} love are mania, agape and <b>pragma.</b>|$|E
5000|$|Pohled z druhé strany (spolu s M.Pekárkem - <b>Pragma,</b> Praha 1998) ...|$|E
50|$|In the Ada {{programming}} language, {{there exists}} a <b>pragma</b> for inline functions.|$|E
50|$|Many languages, {{including}} Java {{and functional}} languages, {{do not provide}} language constructs for inline functions, but their compilers or interpreters often do perform aggressive inline expansion. Other languages provide constructs for explicit hints, generally as compiler directives (<b>pragmas).</b>|$|R
50|$|Examples {{of common}} usage of {{compiler}} <b>pragmas</b> {{would be to}} disable certain features, such as run-time type checking or array subscript boundary checking, or to instruct the compiler to insert object code {{in lieu of a}} function call (as C/C++ does with inline functions).|$|R
50|$|The {{first line}} is a shebang, which {{identifies}} the file as a Perl script that can be executed directly on the command line (on Unix/Linux systems.) The other two are <b>pragmas</b> turning on warnings and strict mode, which are mandated by fashionable Perl programming style.|$|R
