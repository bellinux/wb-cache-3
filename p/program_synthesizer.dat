25|926|Public
50|$|Automatic program {{synthesis}} {{began in the}} artificial intelligence field, with software intended for automatic problem solving. The first <b>program</b> <b>synthesizer</b> was developed by Cordell Green in 1969. At about the same time, mathematicians including R. Constable, Z. Manna, and R. Waldinger explained the possible use of formal logic for automatic {{program synthesis}}. Practically applicable program synthesizers appeared considerably later.|$|E
5000|$|In 1978, Professor Teitelbaum {{created the}} Cornell <b>Program</b> <b>Synthesizer,</b> {{one of the}} seminal systems that {{demonstrated}} the power of tightly integrating a collection of program development tools, all deeply knowledgeable about a programming language and its semantics, into one unified framework. His more than 45 lectures and demonstrations of this early IDE during 1979-82, {{as well as the}} credo of his 1981 paper co-authored with Thomas Reps, asserted: ...|$|E
50|$|GrammaTech is a 1988 {{spin-off}} from Cornell University, {{where its}} founders had developed an early Integrated Development Environment in 1978 (the Cornell <b>Program</b> <b>Synthesizer)</b> {{and a system}} for generating language-based environments from attribute-grammar specifications in 1982 (the Synthesizer Generator). Commercial systems that have been implemented using the Synthesizer Generator include ORA's Ada verification system (Penelope),Terma's Rigorous Approach to Industrial Software Engineering(Raise),and Loral's checker of the SPC Quality and Style Guidelines for AdaGrammaTech co-founders Reps and Teitelbaum received the 2010ACM SIGSOFT Retrospective Impact Award http://www.sigsoft.org/awards/ImpactAward.htmfor their work on the Synthesizer Generator.|$|E
5000|$|Michael Boddicker: <b>Programming,</b> <b>Synthesizer,</b> <b>Synthesizer</b> <b>Programming</b> ...|$|R
5000|$|Rick Bowen - <b>programming,</b> <b>synthesizer,</b> <b>synthesizer</b> <b>programming</b> ...|$|R
5000|$|Robbie Kondor - orchestration, <b>programming,</b> <b>synthesizer</b> <b>programming</b> ...|$|R
50|$|A syntax-directed editor may treat grammar {{rules as}} {{generative}} (e.g., offering the user templates {{that correspond to}} one or more steps in a formal derivation of program text) or proscriptive (e.g., preventing a phrase of a given part of speech from being moved to a context where another part of speech is required) or analytic (e.g., parsing textual edits to create a structured representation). Structure editing features in source code editors make it harder to write programs with invalid syntax. Language-sensitive editors may impose syntactic correctness as an absolute requirement (e.g., as did Mentor), or may tolerate syntax errors after issuing a warning (e.g., as did the Cornell <b>Program</b> <b>Synthesizer).</b> Strict structured editors often make it difficult to perform edits that are easy to perform with plain text editors, {{which is one of the}} factors contributing to the lack of adoption of structured editing in some domains, such as source code editing.|$|E
40|$|This {{tutorial}} {{introduces a}} novice student {{to the basic}} facilities of the Cornell <b>Program</b> <b>Synthesizer</b> for developing programs written in the PL/CS dialect of PL/I. No knowledge of programming is assumed or required. It is assumed that you possess a Synthesizer diskette and {{have access to a}} TERAK microcomputer...|$|E
40|$|AbstractIn this paper, we {{deal with}} editing tabular forms for program {{specifications}} based on a particular graph grammar HNGG [2]. First, we formalize syntax-directed editing methods by extending {{of the notion of}} the Cornell <b>Program</b> <b>Synthesizer</b> [8] to attribute NCE graph grammars (cf. [1]). Next, we discuss the algorithms of the editing methods...|$|E
5000|$|Ren Klyce: synclavier <b>programming,</b> <b>synthesizer</b> <b>programming</b> (Akai) ...|$|R
500|$|Felipe Elgueta – engineer, producer, <b>programming,</b> <b>synthesizer</b> <b>programming</b> ...|$|R
500|$|Gary Cirimelli – digital <b>programming,</b> <b>programming,</b> <b>synthesizer</b> <b>programming</b> ...|$|R
40|$|The {{paper we}} present compares the three systems for program syn-thesis, namely Adate, an {{approach}} through evolutionary computation, the inductive/abductive logic <b>program</b> <b>synthesizer</b> Dialogs-II and the classification learner Atre, capable of simultaneously learning mutually dependent, recursive target predicates. It gives an overview over the func-tionality {{of all three}} systems, and evaluates their capabilities under equal premises. As a consequence, we propose to combine Adate’s expressional power with Dialog-II’s search heuristic...|$|E
40|$|Programs are not text; {{they are}} {{hierarchical}} compositions of computational structures {{and should be}} edited, executed, and debugged {{in an environment that}} consistently acknowledges and reinforces this viewpoint. The Cornell <b>Program</b> <b>Synthesizer</b> demands a structural perspective at all stages of program development. Its separate features are unified by a common foundation: a grammar for the programming language. Its full-screen derivation-tree editor and syntax-directed diagnostic interpreter combine to make the Synthesizer a powerful and responsive interactive programming tool. Key Words and Phrases: programming environment, program development system, syntax-directed editor...|$|E
40|$|A {{discussion}} of the teaching of large, introductory courses in programming in the early days-using the Terak and Macintosh computers {{and the development of}} integrated programming environments that implement language-aware editing capabilities. Tim Teitelbaum carried a major load in the teaching end of the department, especially the intro programming courses. In the late 1970 ’s, Tim, along with PhD student Tom Reps, took advantage of the new desktop computer, the Terak, to build the Cornell <b>Program</b> <b>Synthesizer,</b> a seminal, ground-breaking environment for developing and testing programs. Cornell immediately adopted it for their intro Pascal courses, and its use spread to many other universities. Tim and Tom went further to develop the <b>Program</b> <b>Synthesizer</b> Generator, {{to make it easier to}} create such environments for any language, and turned it into a general tool for static analysis of programs. In 1988, they founded GrammaTech to promote its use. Now, Grammatech, with over 20 PhD employees, is a leading developer of software-assurance tools and advanced cyber-security solutions. Tim became Prof Emeritus in 2010 to devote full time to GrammaTech. Tim and David talk about the teaching of large, introductory courses in programming in the early days using the Terak and Macintosh computers and the development of integrated programming environments that implement language-aware editing capabilities. Running Time: 36 min. [URL]...|$|E
5000|$|Felipe Elgueta - engineer, producer, <b>programming,</b> <b>synthesizer</b> <b>programming</b> ...|$|R
5000|$|Gary Cirimelli - digital <b>programming,</b> <b>programming,</b> <b>synthesizer</b> <b>programming</b> ...|$|R
5000|$|Steve Skinner - arranger, orchestration, <b>programming,</b> <b>synthesizer</b> <b>programming</b> ...|$|R
40|$|We discuss {{logic and}} {{specification}} language of a <b>program</b> <b>synthesizer</b> for Java intended for dynamic synthesis of services. We introduce metainterfaces as logical specifications of classes. They {{can be used}} in two ways: as specifications of computational usage of classes or as specifications of new classes composed from metaclasses – the classes already supplied with metainterfaces. The specification language used has a straightforward translation into a restricted first-order constructive logic. New programs are composed by a deductive synthesis method close to the structural synthesis of programs. An example of composition of a transaction service is presented...|$|E
40|$|Software design {{decisions}} must {{balance a}} collection of functional and non-functional software quality attributes (e. g., correctness, efficiency, testability, and analyzability) each prioritized by business needs. It is unreasonable to expect the non-functional software quality attribute of testability to dominate software design decisions in every application domain. Yet {{this is exactly the}} tacit assumption made by purveyors of general-purpose, one-size-fits-all software test development tools. Software development organizations invest considerable resources to create domain-specific, ad hoc, software test development tools tailored specifically to meet their needs. Siddhartha is a defined, disciplined, alternative technique for developing domain-specific test development tools that fit within a software development organization’s technical and business constraints. Automated Test Driver-Oracle Synthesis Siddhartha 1 provides essential automated test development support {{in the form of a}} <b>program</b> <b>synthesizer.</b> The <b>program</b> <b>synthesizer</b> transforms a domain-specific, formal test specification (TestSpec) into a test driver-oracle procedure (TDOP), which automates test execution and test result verification. A TDOP invokes not only the unitunder-test (UUT) but also an embedded oracle procedure (and embedded oracle data as well, depending on the application domain) that verifies whether the tested behavior of the UUT agrees with the TestSpec. By applying the Siddhartha technique, an expert Test Engineer develops a domain-specific TestSpec→TDOP synthesizer to accept and generate formal test artifacts in formats, languages, and styles already in use in her application domain. Thus, Siddhartha provides test development automation support in application domains that cannot be well-supported by generalpurpose test development tools...|$|E
40|$|Abstract. dialogs (Dialogue-based Inductive and Abductive LOGic <b>program</b> <b>Synthesizer)</b> is a schema-guided {{synthesizer}} of recursive logic programs; {{it takes}} the initiative and queries a (possibly computationally naive) specier for evidence in her/his conceptual language. The specier must know the answers to such simple queries, because otherwise s/he wouldn't even feel {{the need for the}} synthesized program. dialogs can be used by any learner (including itself) that detects, or merely conjectures, the necessity of invention of a new predicate. Due to its foundation on a powerful codication of a -theory " (by means of the template and constraints of a divide-and-conquer schema), dialogs needs very little evidence and is very fast. ...|$|E
5000|$|Michael Boddicker - percussion, <b>programming,</b> <b>synthesizer,</b> <b>synthesizer</b> <b>programming</b> ...|$|R
5000|$|Randy Kerber - arranger, keyboards, <b>programming,</b> <b>synthesizer</b> <b>programming</b> ...|$|R
500|$|Dan Shea – <b>synthesizer,</b> bass, keyboards, <b>programming,</b> moog <b>synthesizer,</b> drum <b>programming,</b> <b>synthesizer</b> bass ...|$|R
40|$|We {{describe}} {{a method for}} learning formulas in firstorder logic using a brute-force, smallest-first search. The method is exceedingly simple. It generates all irreducible well-formed formulas up to a fixed size and tests them against a set of examples. Although the method has some obvious limitations due to its computational complexity, it performs surprisingly well on some tasks. This paper describes experiments with two applications of the method in the Multi-tac system, a <b>program</b> <b>synthesizer</b> for constraint satisfaction problems. In the first application, axioms are learned, {{and in the second}} application, search control rules are learned. We describe these experiments, and consider why searching the space of small formulas makes sense in our applications. Introduction Most machine learning systems prefer smaller, simpler hypotheses to larger, more complex ones. This bias is a form of Occam's Razor. While Occam's razor has obvious aesthetic appeal, some researchers have attempted to [...] ...|$|E
40|$|We {{propose a}} new conflict-driven program {{synthesis}} technique that {{is capable of}} learning from past mistakes. Given a spurious program that violates the desired specification, our synthesis algorithm identifies the root cause of the conflict and learns new lemmas that can prevent similar mistakes in the future. Specifically, we introduce the notion of equivalence modulo conflict and show how this idea can be used to learn useful lemmas that allow the synthesizer to prune large parts of the search space. We have implemented a general-purpose CDCL-style <b>program</b> <b>synthesizer</b> called Neo and evaluate it in two different application domains, namely data wrangling in R and functional programming over lists. Our experiments demonstrate the substantial benefits of conflict-driven learning and show that Neo outperforms two state-of-the-art synthesis tools, Morpheus and Deepcoder, that target these respective domains. Comment: This was a miscommunication and one author did not want to make it publicly available right no...|$|E
40|$|K- 12 {{mathematics}} {{includes many}} procedures to be learned, such as addition and subtraction, {{and there are}} many “buggy ” or incor-rect procedures that students demonstrate during this learning pro-cess. Learning such procedures (both correct and incorrect) from demonstration traces has various applications in computer-aided education. We formalize mathematical procedures as spreadsheet programs, involving loops and conditionals over a given set of base operators, and present a novel algorithm for synthesizing such pro-cedures from demonstrations. Our algorithm is based on dynamic programming and leverages ideas from version-space algebras and template-based program synthesis. Our implementation efficiently synthesized programs to solve 20 common math procedures and re-produce 28 different kinds of bugs that were demonstrated by real students across 9 procedures. Our implementation significantly out-performs SKETCH, a state of the art <b>program</b> <b>synthesizer,</b> on these tasks. We also demonstrate the applicability of our generic program synthesis technology to spreadsheet table transformations, an im-portant domain in end-user programming. 1...|$|E
5000|$|Peter Zizzo - Guitar (Acoustic), Bass, Piano, Drums, Guitar (Electric), Keyboards, Producer, Engineer, Executive Producer, Tiple, Digital Editing, Vocal Arrangement, Drum <b>Programming,</b> <b>Synthesizer</b> Bass, Keyboard <b>Programming,</b> <b>Synthesizer</b> Piano, Pianette ...|$|R
500|$|Peter Mokran – drum <b>programming,</b> engineer, <b>programming,</b> <b>synthesizer</b> <b>programming</b> ...|$|R
5000|$|Bobby Baldwin: drum <b>programming,</b> <b>synthesizer</b> <b>programming</b> and {{arrangement}} (11) ...|$|R
40|$|The deep {{semantics}} of {{a scheme}} {{is defined as}} a set of programs derivable from the scheme. A uniform way of representing deep semantics of schemes is introduced based on the usage of a <b>program</b> <b>synthesizer.</b> An implementation of structural synthesis of programs in the NUT system and visual tools built on top of it are described. A visual compositional programming technique based on these tools is demonstrated on a number of examples. 1. Department of Teleinformatics, Royal Institute of Technology, Kista, Sweden 2 1. Introduction A visual programming tool is described in this paper which is intended for compositional programming. It can be, first of all, used for developing problem-oriented visual languages in engineering domains. Visual compositional programming can be considered as an extension of visual object-oriented programming thoroughly discussed in [1]. The extension lies in different encapsulation of objects and different usage of classes which is inherent to the NUT system [ [...] ...|$|E
40|$|We {{consider}} part of {{the problem}} of schema-biased inductive synthesis of recursive logic pro-grams from incomplete specications, such as clausal evidence (for instance, but not necessar-ily, ground positive and negative examples). After synthesizing the base clause and introducing recursive call(s) to the recursive clause, it remains to combine the overall result from the partial results obtained through recursion, so as to complete the recursive clause. Evidence for this combination relation can be abduced from the initially given evidence for the top-level relation. A program for this combination relation can be anything, from a single clause performing a uni cation (such as for lastElem) to multiple guarded clauses performing unications (such as for ltering programs) to recursive programs (such as for naive reverse). Existing meth-ods cannot induce guarded clause programs for this combination relation from the abduced evidence. Some existing methods cannot even detect that the combination program itself may have to be recursive and thus they then do not recursively invoke themselves the overall recursive <b>program</b> <b>synthesizer.</b> We introduce our Program Completion Method as a suitable extension and generalization of the existing methods. ...|$|E
40|$|Marvin is {{a program}} which is capable of {{learning}} concepts from many different environments. It achieves this by using a flexible description language based on first order predicate logic with quantifiers. Once a concept has been learnt, Marvin treats the concept description as a program which can be executed to produce an output. Thus the learning system can also {{be viewed as an}} automatic <b>program</b> <b>synthesizer.</b> The ability to treat a concept as a program permits the learning system to construct objects to show a human trainer. Given an initial example by the trainer, Marvin creates a concept intended to describe the class of objects containing the example. The validity of the description is tested when Marvin constructs an instance of the concept to show the trainer. If he indicates that the example constructed by the program belongs to the concept which is to be learnt, called the 'target', then Marvin attempts to generalize the description of its hypothesized concept. If the example does not belong to the target then the description must be made more specific so that a correct example can be constructed. This process is repeated until the description o...|$|E
5000|$|Stephen Fox: drum <b>programming,</b> <b>synthesizer</b> <b>programming</b> and {{arrangement}} (11) ...|$|R
5000|$|Michael Urbaniak: drum <b>programming,</b> <b>synthesizer</b> <b>programming</b> and {{arrangement}} (11) ...|$|R
5000|$|Peter Mokran - drum <b>programming,</b> engineer, <b>programming,</b> <b>synthesizer</b> <b>programming</b> ...|$|R
