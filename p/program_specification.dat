229|1427|Public
50|$|His {{research}} activities includes Programming languages and methods; functional programming; generic programming; object technology; <b>program</b> <b>specification,</b> derivation and transformation.|$|E
5000|$|The most {{detailed}} and consistent account {{was that the}} error was in hand-transcription of a mathematical symbol in the <b>program</b> <b>specification</b> for the guidance system, in particular a missing overbar.|$|E
50|$|An oracle is an {{instrument}} for verifying whether the outcomes match the <b>program</b> <b>specification</b> or not. An operation profile is knowledge about usage patterns {{of the program and}} thus which parts are more important.|$|E
50|$|It can be {{described}} as a language of quantum <b>programs</b> <b>specification.</b>|$|R
5000|$|... (1) {{to study}} the methods for {{developing}} <b>programs</b> (<b>specification</b> methods, object-oriented design, structured programming algorithms, testing); ...|$|R
25|$|In 2008, AMD {{released}} the low-level <b>programming</b> <b>specifications</b> for its GPUs, {{and works with}} the X.Org Foundation to develop drivers for AMD graphics cards.|$|R
50|$|Although {{there are}} {{currently}} no true MAVs (i.e., truly micro scaled flyers) in existence, DARPA has attempted a program to develop even smaller Nano Air Vehicles (NAVs) with a wingspan of 7.5 centimeters. However, no NAVs meeting DARPA's original <b>program</b> <b>specification</b> were forthcoming until 2009 when AeroVironment demonstrated a controlled hovering of DARPA's flapping-wing NAV.|$|E
5000|$|Comments {{positioned}} above each column (or even embedded textual documentation) can {{render a}} decision table 'human readable' even after 'condensing down' (encoding) to its essentials (and still broadly in-line {{with the original}} <b>program</b> <b>specification</b> - especially if a printed decision table, enumerating each unique action, is created before coding begins).The table entries can also optionally contain counters to collect run-time statistics for 'in-flight' or later optimization ...|$|E
5000|$|... 1940s: American {{women were}} {{recruited}} to do ballistics calculations and program computers during WWII. Around 1943-1945, these women [...] "computers" [...] used a differential analyzer {{in the basement}} of the Moore School of Electrical Engineering to speed up their calculations, though the machine required a mechanic to be totally accurate and the women often rechecked the calculations by hand. Phyllis Fox ran a differential analyzer single-handedly, with differential equations are her <b>program</b> <b>specification.</b>|$|E
50|$|The C++11 Concepts generic <b>programming</b> <b>specification</b> {{would have}} made {{obsolete}} the Barton-Nackman trick. Concepts have since {{been removed from the}} final C++11 language standard,, but are proposed for inclusion in C++20.|$|R
40|$|Modularity in {{programming}} language semantics derives from abstracting over {{the structure of}} underlying denotations, yielding semantic descriptions that are more abstract and reusable. One such semantic framework is Liang’s modular monadic semantics in which the underlying semantic structure is encapsulated with a monad. Such abstraction can {{be at odds with}} program verification, however, because <b>program</b> <b>specifications</b> require access to the (deliberately) hidden semantic representation. The techniques for reasoning about modular monadic definitions of imperative programs introduced here overcome this barrier. And, just like program definitions in modular monadic semantics, our <b>program</b> <b>specifications</b> and proofs are representation-independent and hold for whole classes of monads, thereby yielding proofs of great generality...|$|R
40|$|The UTM Petroleum Engineering <b>Program</b> <b>Specifications</b> (for {{the period}} of 2005 - 2008) {{comprises}} the Program Objectives (is also known as Program Educational Objectives âˆ’ PEO) and Program Learning Outcomes (is also known as Program Outcomes âˆ’ PO). The <b>program</b> <b>specifications</b> were formulated after taking into consideration the view of stakeholders, and also the graduates attributes (issued by Universiti Teknologi Malaysia, BoEM, and Ministry of Higher Education). Petroleum graduates {{who have been working}} for four years or more in the industry must have all the competencies outlined in the PEO (achieved satisfactorily). Petroleum students must have all the competencies outlined in the PO upon graduation (achieved satisfactorily) ...|$|R
50|$|Through {{interpretation}} of data as code, weird machine functionality that is by definition outside the original <b>program</b> <b>specification</b> can be reached also by Proof-Carrying Code, which has been formally proven to function in a certain specific way. This disparity is essentially caused by a disconnect between formal abstract modelling of a computer program and its real-world instance, which can be influenced by events that are not captured in the original abstraction, such as memory errors or power outages.|$|E
50|$|A <b>program</b> <b>specification</b> is the {{definition}} of what a computer program is expected to do. It can be informal, in which case it can be considered as a user manual from a developer point of view, or formal, in which case it has a definite meaning defined in mathematical or programmatic terms. In practice, many successful specifications are written to understand and fine-tune applications that were already well-developed, although safety-critical software systems are often carefully specified prior to application development. Specifications are most important for external interfaces that must remain stable.|$|E
50|$|The {{next step}} is {{defining}} the calibration process. The selection of a standard or standards is the most visible part of the calibration process. Ideally, the standard has less than 1/4 of the measurement uncertainty of the device being calibrated. When this goal is met, the accumulated measurement uncertainty {{of all of the}} standards involved is considered to be insignificant when the final measurement is also made with the 4:1 ratio. This ratio was probably first formalized in Handbook 52 that accompanied MIL-STD-45662A, an early US Department of Defense metrology <b>program</b> <b>specification.</b> It was 10:1 from its inception in the 1950s until the 1970s, when advancing technology made 10:1 impossible for most electronic measurements.|$|E
50|$|Although HUD has {{released}} data standards and <b>programming</b> <b>specifications</b> for some reports, HUD does not endorse or explicitly approve any HMIS application. HUD provides certification for related CMS products for Housing Counseling Agencies, {{information can be}} found below.|$|R
40|$|There are {{described}} Qt, OpenGL and their mutual interconnection {{in the first}} chapter of the thesis. Especially, OpenGL techniques implemented in the program are closely specified. Qt toolkit is compared to three other multiplatform toolkits (AWT/Swing, QTK+ and wxWidgets). The second, more practical chapter of the thesis, includes <b>program</b> <b>specifications,</b> <b>program</b> design and program implementation. There are presented results and possible future development {{at the end of the}} thesis...|$|R
40|$|A program {{analysis}} for documentation (PAD) written in FORTRAN has three steps: listing the variables, describing {{the structure and}} writing the <b>program</b> <b>specifications.</b> Technical notes on editing criteria for reviewing program documentation, technical notes for PAD, and FORTRAN program analyzer for documentation are appended...|$|R
5000|$|Predicative {{programming}} is a methodology for <b>program</b> <b>specification</b> and refinement. The central idea of predicative {{programming is}} that each specification is a predicate (generally written as a boolean expression) that is true of acceptable behaviours and false of unacceptable behaviours. It follows that refinement is reversed implication universally quantified over behaviours:Commands in a programming language {{are considered to be}} a special case of specifications—special only because they are compilable. For example, in an environment where the program variables are , , and , the command [...] is considered equivalent to the predicate (represented here by a boolean expression)in which , , and [...] represent the initial values of the program variables and [...] , , and [...] represent the final values of the program variables. Thus ...|$|E
5000|$|The {{earliest}} known {{programmable machine}} preceded {{the invention of}} the digital computer and is the automatic flute player described in the 9th century by the brothers Musa in Baghdad, [...] "during the Islamic Golden Age". [...] From the early 1800s, [...] "programs" [...] were used to direct the behavior of machines such as Jacquard looms and player pianos. Thousands of different programming languages have been created, mainly in the computer field, and many more still are being created every year. Many programming languages require computation to be specified in an imperative form (i.e., as a sequence of operations to perform) while other languages use other forms of <b>program</b> <b>specification</b> such as the declarative form (i.e. the desired result is specified, not how to achieve it).|$|E
5000|$|... ==As {{a problem}} solving tool== The known {{deductive}} systems for various fragments of CoL share the property that a solution (algorithm) can be automatically extracted from a {{proof of a}} problem in the system. This property is further inherited by all applied theories based on those systems. So, in order to find a solution for a given problem, it is sufficient to express it in the language of CoL and then find a proof of that expression. Another way to look at this phenomenon is to think of a formula G of CoL as <b>program</b> <b>specification</b> (goal). Then a proof of G is - more precisely, translates into - a program meeting that specification. There is no need to verify that the specification is met, because the proof itself is, in fact, such a verification.|$|E
40|$|In this paper, {{we present}} a {{technique}} to automatically translate <b>program</b> <b>specifications</b> into pseudo code. This technique is developed {{in the context of}} the well-known programming method Jackson Structured Programming (JSP). The objective of our research is to investigate to what extent a programming method can be automated. Current CASE tools are only able to automate programming methods to a very limited extent, whereas our technique automates the entire programming cycle by creating pseudo code from <b>program</b> <b>specifications.</b> We show that the JSP programming method can be transformed into a set of formal rules when the scope of the technique is limited to a well-defined area of problems. The rules are implemented in a CASE tool, called JSPTool, which is currently operative, although still in a prototyping phase. We believe that the strength of the CASE tool lies in the fact that it is able to automate the programming process completely, although its scope possibly is still rather limited. In this paper, the technique is explained by solving an example programming problem. The source language that has been developed to enter <b>program</b> <b>specifications</b> is briefly explained. Also, the differences between other JSP CASE tools and JSPTool are dealt with. Some additional features of the method are discussed and suggestions for future research are given...|$|R
5000|$|Transmission Control Protocol DARPA Internet <b>Program</b> Protocol <b>Specification</b> ...|$|R
40|$|New {{paradigms}} are {{appearing in}} relation to object oriented programming like mixins [1 – 4] for instance. The framework Focal belongs to this tendency. In particular, it brings object oriented solutions to develop certified softwares. Moreover, Focal has the originality to allow to write in a same <b>program</b> <b>specifications...</b>|$|R
5000|$|For convenience, an SDP may be {{specified}} {{in a slightly}} different, but equivalent form. For example, linear expressions involving nonnegative scalar variables may {{be added to the}} <b>program</b> <b>specification.</b> This remains an SDP because each variable can be incorporated into the matrix [...] as a diagonal entry ( [...] for some [...] ). To ensure that , constraints [...] can be added for all [...] As another example, note that for any positive semidefinite matrix , there exists a set of vectors [...] such that the , [...] entry of [...] is [...] the scalar product of [...] and [...] Therefore, SDPs are often formulated in terms of linear expressions on scalar products of vectors. Given the solution to the SDP in the standard form, the vectors [...] can be recovered in [...] time (e.g., by using an incomplete Cholesky decomposition of X).|$|E
50|$|Top-down {{design was}} {{promoted}} in the 1970s by IBM researchers Harlan Mills and Niklaus Wirth. Mills developed structured programming concepts for practical use and tested {{them in a}} 1969 project to automate the New York Times morgue index. The engineering and management success of this project led {{to the spread of}} the top-down approach through IBM {{and the rest of the}} computer industry. Among other achievements, Niklaus Wirth, the developer of Pascal programming language, wrote the influential paper Program Development by Stepwise Refinement. Since Niklaus Wirth went on to develop languages such as Modula and Oberon (where one could define a module before knowing about the entire <b>program</b> <b>specification),</b> one can infer that top-down programming was not strictly what he promoted. Top-down methods were favored in software engineering until the late 1980s, and object-oriented programming assisted in demonstrating the idea that both aspects of top-down and bottom-up programming could be utilized.|$|E
30|$|The <b>Program</b> <b>Specification</b> {{highlights}} the distinctive {{features of the}} program. The most important are: new paradigm thinking and practice, unique holistic educational model, collaborative approach, and flexible learning (document 1).|$|E
40|$|Abstract. Discovering <b>program</b> <b>specifications</b> {{automatically}} for heapmanipulating {{programs is}} a challenging task {{due to the}} complexity of aliasing and mutability of data structures used. This paper describes a compositional analysis framework for discovering <b>program</b> <b>specifications</b> in a combined abstract domain with shape, numerical and bag (multiset) information. The framework analyses each method and derives its summary independently from its callers. We propose a novel abstraction method with a bi-abduction technique in the combined domain to discover pre/post-conditions which cannot be automatically inferred before. The analysis does not only prove the memory safety properties, but also finds relationships between pure and shape domains towards full functional correctness of programs. A prototype of the framework has been implemented and initial experiments have shown that our approach can discover interesting properties for non-trivial programs. ...|$|R
5000|$|ASF+SDF_Meta_Environment, <b>programming</b> {{language}} <b>specification</b> and prototyping system, IDE generator ...|$|R
5000|$|C. C. Morgan, <b>Programming</b> from <b>Specifications,</b> 2nd edition, 1994[...]|$|R
40|$|Abstract. The automata-theoretic {{approach}} to linear temporal logic uses {{the theory of}} automata as a unifying paradigm for <b>program</b> <b>specification,</b> verification, and synthesis. Both programs and specifications are in essence descriptions of computations. These computations {{can be viewed as}} words over some alphabet. Thus,programs and specificationscan be viewed as descriptions of languagesover some alphabet. The automata-theoretic perspective considers the relationships between programs and their specifications as relationships between languages. By translating programs and specifications to automata, questions about programs and their specifications can be reduced to questions about automata. More specifically, questions such as satisfiability of specifications and correctness of programs with respect to their specifications can be reduced to questions such as nonemptiness and containment of automata. Unlike classical automata theory, which focused on automata on finite words, the applications to <b>program</b> <b>specification,</b> verification, and synthesis, use automata on infinite words, since the computations in which we are interested are typically infinite. This paper provides an introduction to the theory of automata on infinite words and demonstrates its applications to <b>program</b> <b>specification,</b> verification, and synthesis. ...|$|E
40|$|AbstractThe problem-oriented {{verification}} system SPECTRUM {{using the}} set of linear algebra programs as the problem area is described. Its main component is a special prover which uses knowledge base and approximate decision procedures. To simplify the <b>program</b> <b>specification,</b> a method of loop-invariant elimination is used...|$|E
40|$|Constraint {{diagrams}} [1, 2] {{constitute a}} graphical notation for <b>program</b> <b>specification.</b> This paper presents an experiment that compares {{the efficacy of}} constraint diagrams (CD) with natural language (NL) for understanding <b>program</b> <b>specification</b> statements. In a web-based competition 33 participants were given training either on CD notation or equivalent NL expression, and answered questions about specification statements. It was predicted that the CD participants would find learning and answering questions harder {{than those in the}} NL group, because they had no prior experience of CD notation. Although the CD group spent more time on the training examples and were less confident about their answers, they spent less time answering the questions and achieved approximately the same proportion of correct answers as the NL group...|$|E
40|$|This paper {{describes}} {{the generation of}} file processing programmes within the TUBA environment. Program structures are derived from data structures according to the JSP method. Expressions describing output data are specified in user-system dialogues. The <b>program</b> <b>specifications</b> are stored in the dictionary. Complete executable programs can be generated from these specifications...|$|R
40|$|AbstractIn this paper, we {{deal with}} editing tabular forms for <b>program</b> <b>specifications</b> based on a {{particular}} graph grammar HNGG [2]. First, we formalize syntax-directed editing methods by extending {{of the notion of}} the Cornell Program Synthesizer [8] to attribute NCE graph grammars (cf. [1]). Next, we discuss the algorithms of the editing methods...|$|R
40|$|We {{solve the}} problem of obtaining answers to queries posed to a {{mediated}} integration system under the local-as-view paradigm that are consistent wrt to certain global integrity constraints. For this, the query program is combined with logic <b>programming</b> <b>specifications</b> under the stable model semantics of the class of minimal global instances, and o...|$|R
