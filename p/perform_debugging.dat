10|44|Public
50|$|A {{high-speed}} clocked {{serial interface}} for debugging called background debug mode (BDM). The 683xx-series {{was the first}} to have a clocked serial interface to the CPU to <b>perform</b> <b>debugging.</b> Now, many CPUs use a standard serial test interface, usually JTAG, for this purpose.|$|E
40|$|Abstract. It is {{not enough}} to offer {{accessible}} learning material, accessible learning platform and bilingual tutoring. Deaf or hearing impaired (DHI) java graduates still show poorer perfomance in debugging tasks when compared to their hearing counterparts. Direct manipulation and visual debuggers might improve the odds of securing the DHI a position in the IT industry. We present a study where DHI java graduates <b>perform</b> <b>debugging</b> tasks using a visual de-bugger and Eclipse. Situated analysis, usability assessment and a formal task performance evaluation show visual debuggers might benefit the DHI program-mer. 1...|$|E
40|$|Abstract — In today’s designs, when {{functional}} verification fails, engineers <b>perform</b> <b>debugging</b> using the provided error traces. Reducing {{the length of}} error traces can help the debugging task by decreasing the number of variables and clock cycles that must be considered. We propose a novel trace length compaction approach based on SAT-based reachability analysis. We develop procedures and algorithms using pre-image computation to efficiently traverse the state space and reduce the trace lengths. We further introduce a data structure used to store the visited states which {{is critical to the}} performance of the proposed approach. Experiments demonstrate the effectiveness of the reachability approach as approximately 75 % of the traces are reduced by one or two orders of magnitudes. I...|$|E
5000|$|With the platform-independent {{open-source}} Winpdb debugger, one can <b>perform</b> remote <b>debugging</b> over TCP/IP, through encrypted connection.|$|R
40|$|We {{present an}} {{annotation}} language well-suited for rendering aspects of Prolog execution. Our annotations are special Prolog goals {{that act as}} executable comments, <b>performing</b> <b>debugging</b> at run-time. No restrictions are placed upon the object language, the concern being verification of (full) Standard Prolog programs. Here we discuss {{the merits of the}} annotations for Prolog debugging. All the examples are actual runs of our system, Nope...|$|R
40|$|Emerging {{research}} {{has sought to}} bring effective debugging devices to end-user programmers. This {{research has}} largely focused on how well such devices bring genuine “functional ” rewards to end users. However, emerging models of programming behavior indicate that another, often ignored, type of reward—perceivable rewards—can play an equally vital role in how well debugging devices serve end users. Using an empirically evaluated fault localization device, this paper investigates the impact such perceivable rewards can have on end-user debugging. Our results indicate that perceivable rewards alone can significantly improve the effectiveness and understanding of end users <b>performing</b> <b>debugging</b> tasks. 1...|$|R
40|$|XFEL/SPring- 8 employs 72 {{units of}} the pulse {{modulator}} power supplies in order to drive the pulse power klystrons and the electron gun[1, 2]. We use single tank design in these pulse power supplies, i. e., all the PFN circuitry and high voltage pulse transformer are installed in a single metallic tank, and filled with insulation oil. This design provides good EM noise-shield performance, and superior operational stability against environmental temperature variation and humidity. The mass production and installation of the modulators are in progress. All accelerating structures and waveguide systems have been installed in the main accelerator. We start high power operation from October 2010 and <b>perform</b> <b>debugging</b> system and processing the accelerating structure at high accelerating gradient up to 40 MV/m maximum. The beam operation is scheduled in March 2011...|$|E
40|$|The {{behaviour}} of a {{distributed application}} cannot be easily reproduced {{because of its}} nondeterministic characteristics. Fortunately, with a replay mechanism, the program behaviour can be captured and reproduced later for post-mortem analysis. Replaying a distributed application requires two phases. During the monitoring phase, significant program events are recorded; then during the replay phase, the occurrence of events is coerced {{to be consistent with}} the original partial-order relation. Since the event executions are controlled by the replay facility, it is possible to use a sequential debugger to <b>perform</b> <b>debugging</b> tasks such as examining the program states and setting breakpoints. In a distributed environment, there is also the inherent difficulty of halting the program execution at a consistent breakpoint-stop state when the breakpoint assertions are met. Because of system and/or network delays, the breakpoint commands cannot be communicated instantaneously. As a result, the evide [...] ...|$|E
40|$|Traffic Incident Management is a multi-jurisdictional process. Complications with communication, com-patibility, coordination, {{institutional}} {{responsibilities and}} legal issues are inherent in a traffic incident man-agement system. Increasing delay in incident clearance due to various conflicts has vital economical, safety, environmental and social impacts. Therefore, a thorough and rigorous modeling {{of the system is}} necessary to better understand its properties and systematically solve issues that might arise. This paper proposes the use of formal language theory for modeling, analyzing, and implementing the traffic incident management process. This theory has been used very effectively for hardware and software systems. Using formal lan-guages, allows us to <b>perform</b> <b>debugging</b> on a traffic incident management system covering all possibilities for inefficiencies and problems for which we can find solutions. This paper demonstrates how to use formal language methodology to model the traffic incident management system through a case study in the Las Vegas area...|$|E
50|$|Some professions, such as {{software}} developers, regularly {{utilize the}} similarity heuristic. For software developers, the similarity heuristic is utilized when <b>performing</b> <b>debugging</b> tasks. A software bug exhibits {{a set of}} symptoms indicating {{the existence of a}} problem. In general, similar symptoms are caused by similar types of programming errors. By comparing these symptoms with those of previously corrected software flaws, a developer is able to determine the most probable cause and take an effective course of action. Over time, a developer’s past experiences will allow their use of the similarity heuristic to be highly effective, quickly choosing the debugging approach that will likely reveal the problem’s source.|$|R
40|$|In {{this paper}} we discuss several issues {{concerning}} the design and implementation of a debugger for parallel and distributed applications. This debugger {{is based on a}} client-server approach to isolate the debugging user-interface from the debugging services, and has a two-level structure. A distinctive feature of our work is that we are following a twolevel structured approach to achieve this goal: 1. Component-level. At this level, the <b>performed</b> <b>debugging</b> actions act upon individual application components, such as processes and threads. 2. Coordination-level. At this level, coordination groups of processes and/or threads is provided, and the inspection and control commands can observe and control distributed processes interactions. In this paper we are focusing in the component-level (processes...|$|R
40|$|Abstract—Automatically {{generated}} {{test cases}} are usually evaluated {{in terms of}} their fault revealing or coverage capabil-ity. Beside these two aspects, test cases are also the major source of information for fault localization and fixing. The impact of automatically generated test cases on the debugging activity, compared to the use of manually written test cases, has never been studied before. In this paper we report the results obtained from two con-trolled experiments with human subjects <b>performing</b> <b>debugging</b> tasks using automatically generated or manually written test cases. We investigate whether the features of the former type of test cases, which make them less readable and understandable (e. g., unclear test scenarios, meaningless identifiers), have an impact on accuracy and efficiency of debugging. The empirical study is aimed at investigating whether, despite the lack of readability in automatically generated test cases, subjects can still take advantage of them during debugging...|$|R
40|$|Debugging {{applications}} that are running in embedded systems is becoming {{harder and harder}} due to the growing complexity of the systems. This {{is especially true for}} embedded systems that are developed for the automotive market. To aid the debugging there are tools called debuggers. Historically, debuggers have been implemented by using a debug port to connect a software debugger running at the developer machine to dedicated on-chip debugging hardware. The problem with this approach is that it is expensive and that {{it is not possible to}} use it if the debug port on the system is not available. Therefore there is a demand for user-friendly debuggers that are not as expensive and require no extra hardware. This report presents alternatives to debugging embedded systems. From these alternatives a completely software based debugger solution called monitor-based debugging is selected and acts as a foundation for an implementation that is described in the report. The implementation uses GNU Debugger (GDB) and its remote debugging capabilities to <b>perform</b> <b>debugging.</b> The implemented debugger is evaluated by using it to debug {{applications that}} are running in a powertrain control unit in a modern truck. It is also compared to two commercial hardware based debuggers. In the evaluation it is found that the debugger functionalities and user-friendliness are on par with the commercial alternatives, but that it lacks some in its non-intrusive capabilities when comparing it with the high-end alternatives on the market...|$|E
40|$|The {{behaviour}} of a {{distributed application}} cannot be easily reproduced {{because of its}} nondeterministic characteristics. Fortunately, with a replaymechanism, the program behaviour can be captured and reproduced later for post-mortem analysis. Replaying a distributed application requires two phases. During the monitoring phase, significant program events are recorded# then during the replay phase, the occurrence of events is coerced {{to be consistent with}} the original partial-order relation. Since the event executions are controlled by the replay facility,itispossible to use a sequential debugger to <b>perform</b> <b>debugging</b> tasks such as examining the program states and setting breakpoints. In a distributed environment, there is also the inherent difficulty of halting the program execution at a consistent breakpoint-stop state when the breakpoint assertions are met. Because of system and/or network delays, the breakpoint commands cannot be communicated instantaneously. As a result, the evidence for the causes of the erroneous program behaviour may have been removed. This thesis presents a technique for replaying distributed applications based on the partial-order relation of events. Wehave implemented a prototype for replaying applications in the OSF DCE environment. Using the replay facility,we can control the program execution for cyclic debugging. The replay facility {{can also be used to}} effectively modify the program characteristics and monitor the effect of replay-speed variations on the program execution and the effect of varying the program environment. Thus, the replay facility has created a controlled environment for analysing program behaviour and for studying the effects of dynamic program-execution characteristics. In addition to replay, this thesis also presents a g [...] ...|$|E
40|$|Recently, {{the usage}} of the {{automotive}} Electronic Control Unit (ECU) and its software in cars is increasing. Therefore, as the functional complexity of such software increases, so does the likelihood of software-related faults. Therefore, {{it is important to}} ensure the reliability of ECU software in order to ensure automobile safety. For this reason, systematic testing methods are required that can guarantee software quality. However, it is difficult to locate a fault during testing with the current ECU development system because a tester performs the black-box testing using a Hardware-in-the-Loop (HiL) simulator. Consequently, developers consume a large amount of money and time for debugging because they <b>perform</b> <b>debugging</b> without any information about the location of the fault. In this paper, we propose a method for localizing the fault utilizing memory information during black-box testing. This is likely to be of use to developers who debug automotive software. In order to observe whether symbols stored in the memory have been updated, the memory is partitioned by a memory map and the stack, thus the fault candidate region is reduced. A memory map method has the advantage of being able to finely partition the memory, and the stack method can partition the memory without a memory map. We validated these methods by applying these to HiL testing of the ECU for a body control system. The preliminary results indicate that a memory map and the stack reduce the possible fault locations to 22 % and 19 % of the updated memory, respectively...|$|E
40|$|We propose an {{annotation}} language {{well suited}} for rendering aspects of Prolog execution. Our annotations are special Prolog goals that act as executable comments, <b>performing</b> <b>debugging</b> at run-time. We do not place any restrictions upon the object language, the concern being verification of (full) Standard Prolog programs. Ample illustrations of {{the merits of the}} approach are given. All examples presented here are actual runs of our system Nope, which is a Prolog module. 1 Introduction We start by briefly surveying previous research in debugging of Prolog programs. Then we summarize our approach, introduced in [8]. The central part of the paper is Sec. 4, allowing a close look into the merits of the approach, by means of extensive examples. Sec. 5 rounds off the survey of related work. 2 Debugging Prolog In the area of Prolog debugging and validation different approaches have been put forward. The very influential approach of declarative debugging (algorithmic debugging, declara [...] ...|$|R
30|$|MrSim aims at {{providing}} a simple framework {{to create and}} test MapReduce jobs with a minimal setup, using straightforward implementations of all necessary concepts. This entails some purposeful limitations to the system: for example, it is not optimized in any way. In counterpart, MrSim offers interesting features from a pedagogical point of view: it {{runs out of the}} box, and the centralized processing makes it easy to <b>perform</b> step-by-step <b>debugging</b> of a MapReduce job.|$|R
40|$|Runtime {{monitoring}} support {{serves as}} a foundation for the important tasks of providing security, <b>performing</b> <b>debugging,</b> and improving performance of applications. Often runtime monitoring requires the maintenance of information associated with each of the application’s original memory location, which is held in corresponding shadow memory locations. Unfortunately, existing robust shadow memory implementations are inefficient. In this paper, we present a shadow memory implementation that is both efficient and robust. A combination of architectural support (in the form of ISA support and augmentations to the cache coherency protocol) and operating system support (in the form of coupled allocation of memory pages used by the application and associated shadow memory pages) is proposed. By coupling the coherency of shadow memory with the coherency of the main memory, we ensure that the shadow memory instructions execute atomically with their corresponding original memory instructions. Our page allocation policy enables fast translation of original addresses into corresponding shadow memory addresses; thus allowing implicit addressing of shadow memory. This approach obviates the need for page table entries for shadow pages. Our experiments show that the overheads of runtime monitoring tasks are significantly reduced in comparison to previous software implementations...|$|R
40|$|Most current {{programming}} debuggers do {{not have}} any built-in intelligence to help programmers <b>perform</b> <b>debugging.</b> When using these non-intelligent debuggers, programmers have to debug their programs statement by statement in order to track down the bugs. There are several disadvantages with the current non-intelligent debuggers. The first disadvantage is that the debugger does not know the variable dependencies of the program being debugged. It does not understand the cause-effect semantics of the program, and how a single error in one line of code can lead to a propagation of errors in later lines of code. The second disadvantage is that the debugger cannot simplify the program being debugged. If programmers are only concerned with some particular variables when debugging the code, the debugger should have the ability to filter out the statements that have no relevancy (i. e., no dependency) with those variables. The third disadvantage is that the debugger cannot help identify the statements which would have a higher probability of causing certain program errors. If the debugger allowed programmers to provide some information regarding what is wrong (and what is right) with the program, it should be able to utilize that information and help programmers narrow down the bugs. This paper proposes an intelligent debugger which can help programmers to narrow down the bugs in a program. Using test result information provided to it, the intelligent debugger applies an enhanced static slicing algorithm to display a subset of the program containing only the statements that have a variable dependency related to the error condition(s). After slicing, the resulting program becomes more readable and understandable to the user, aiding the debugging process. Also, a variable analyzer is able to compute correctness ratio numbers to assist the user in identifying relatively weak areas of code which have the highest probability of causing certain program errors. Users can then focus on and double check those areas of code to determine if any of them are indeed causing the bugs in the program...|$|E
40|$|The {{detection}} {{of the reason}} for an incorrect behaviour of an integrated circuit in its real-time environment is a very time consuming task. Using logic analysers in combination with an extensive logic simulation is the today's only way to isolate possible errors. In this paper, we introduce a hardware debugger to <b>perform</b> the <b>debugging</b> process in a more efficient way. Goal of the hardware debugger is detecting a failure of an integrated circuit in real-time processing and the supply of data for the determination of the cause of the failure...|$|R
40|$|Multi-Processor Systems-on-Chip (MPSoCs) are {{increasingly}} popular in embedded systems. Due to their complexity and huge design space to explore for such systems, CAD tools and frameworks to customize MPSoCs are mandatory. The main {{goal of this}} paper is to present a conceptual platform for MPSoC development, named HeMPS Station. HeMPS Station is derived from the MPSoC HeMPS. HeMPS, in its present state, includes the platform (NoC, processors, DMA, NI), embedded software (microkernel and applications) and a dedicated CAD tool to generate the required binaries and <b>perform</b> basic <b>debugging.</b> Experiments show the execution of a real application running in HeMPS. 1...|$|R
5000|$|DBX is also {{available}} on IBM z/OS systems, in the UNIX System Services component. DBX for z/OS can debug programs written in C and C++, and can also <b>perform</b> machine level <b>debugging.</b> As of z/OS V1R5, DBX is able to debug programs using the DWARF debug format. z/OS V1R6 added support for debugging 64-bit programs.|$|R
40|$|The GNU {{debugger}} {{is valuable}} for testing, fixing, and retesting software {{because it allows}} you to see exactly what's going on inside of a program as it's executing. This new pocket reference shows you how to specify a target for <b>debugging,</b> <b>perform</b> a careful examination to find the cause of program failure, and make quick changes for further testing. The guide covers several popular programming languages...|$|R
40|$|Very {{little is}} known about the process by which {{end-user}} developers detect and correct spreadsheet errors. Any research pertaining to the development of spreadsheet testing methodologies or auditing tools would benefit from information on how end-users <b>perform</b> the <b>debugging</b> process in practice. Thirteen industry-based professionals and thirty-four accounting & finance students took part in a current ongoing experiment designed to record and analyse end-user behaviour in spreadsheet error detection and correction. Professionals significantly outperformed students in correcting certain error types. Time-based cell activity analysis showed that a strong correlation exists between the percentage of cells inspected and the number of errors corrected. The cell activity data was gathered through a purpose written VBA Excel plug-in that records the time and detail of all cell selection and cell change actions of individuals. Comment: 12 Pages, 3 Figure...|$|R
40|$|We {{describe}} {{how we have}} parallelized Python, an interpreted object oriented scripting language, {{and used it to}} build an extensible message-passing molecular dynamics application for the CM- 5, Cray T 3 D, and Sun multiprocessor servers running MPI. This allows us to interact with large-scale message-passing applications, rapidly prototype new features, and <b>perform</b> application specific <b>debugging.</b> It is even possible to write message passing programs in Python itself. We describe some of the tools we have developed to extend Python and results of this approach. ...|$|R
40|$|System {{interoperability}} is a {{well known}} issue, especially for heterogeneous information systems, where ontologybased representations may support automatic and usertransparent integration. In this paper we present X-SOM: an ontology mapping and integration tool. The contribution of our tool is a modular and extensible architecture that automatically combines several matching techniques {{by means of a}} neural network, <b>performing</b> also ontology <b>debugging</b> to avoid inconsistencies. Besides describing the tool components, we discuss the prototype implementation, which has been tested against the OAEI 2006 benchmark with promising results. ...|$|R
40|$|Nobody {{would claim}} that {{debugging}} computer software is easy: {{all too often}} it proceeds by trial-and-error experiments in which programmers examine the behaviour {{of the system and}} form hypotheses that could explain what they see. These problems are exacerbated when developing distributed, peer-to-peer or multi-processor applications, or when unreliable network links form part of the system under test. Environments for pervasive computing take this to an extreme, allowing user-supplied code to run or migrate within and around the network. In this paper we show how to <b>perform</b> pervasive <b>debugging,</b> enabling complex multi-process applications to be debugged and controlled as single entities and their robustness to changes in network performance to be evaluated. We do this by virtualizing the resources used by the system, allowing the threads that it involves and the network links that it uses to be modelled within a single controllable process. ...|$|R
40|$|Regular {{works on}} energy {{efficiency}} strategies for wireless communications {{are based on}} classical energy models that account for the wireless card only. Nevertheless, there is a non-negligible energy toll called "cross-factor" that encompasses the energy drained while a frame crosses the network stack of an OS. This paper addresses the challenge of deepen into {{the roots of the}} cross-factor, deseed its components and analyse its causes. Energy issues are critical for IoT devices. Thus, this paper conceives and validates a new comprehensive framework that enables us to measure a wide range of wireless devices, as well as multiple devices synchronously. We also present a rigorous methodology to perform whole-device energy measurements in laptops, a more generic and suitable device to <b>perform</b> energy <b>debugging.</b> Finally, and using this framework, we provide a collection of measurements and insights that deepens our understanding of the cross-factor. Comment: 10 pages, 12 figure...|$|R
40|$|The authors {{describe}} {{how they have}} parallelized Python, an interpreted object oriented scripting language, {{and used it to}} build an extensible message-passing C/C++ applications for the CM- 5, Cray T 3 D, and Sun multiprocessor servers running MPI. Using a parallelized Python interpreter, it is possible to interact with large-scale parallel applications, rapidly prototype new features, and <b>perform</b> application specific <b>debugging.</b> It is even possible to write message passing programs in Python itself. The authors describe some of the tools they have developed to extend Python and applications of this approach...|$|R
40|$|In {{software}} development, {{perhaps the}} most critical, yet least predicitible stage in the process is debugging. Of the many factors that come into play when debugging software applications, time is of utmost importance. The time required {{to set up and}} debug a software application can have major impacts on time-to-market, meeting customer expectations, and ultimately the financial impact of a well-developed product. This paper will explain the fundamentals of how the emulation logic and emulation tools work together with the TI digital signal processors. By understanding the fundamentals of emulation, {{you will be able to}} accelerate the process of setting up and <b>performing</b> software <b>debug,</b> as well as aid in troubleshooting potential problems in the debugging setup. A detailed explanation of the setup of the emulator hardware systems for single and multi-processor applications, along with a discussion of how the system components interact during debug will be discussed in the sections to follow. Also included is...|$|R
5000|$|In {{addition}} to being useful for manufacturing [...] "go/no go" [...] testing, scan chains {{can also be used}} to [...] "debug" [...] chip designs. In this context, the chip is exercised in normal [...] "functional mode" [...] (for example, a computer or mobile-phone chip might execute assembly language instructions). At any time, the chip clock can be stopped, and the chip re-configured into [...] "test mode". At this point the full internal state can be dumped out, or set to any desired values, by use of the scan chains. Another use of scan to aid debug consists of scanning in an initial state to all memory elements and then go back to functional mode to <b>perform</b> system <b>debug.</b> The advantage is to bring the system to a known state without going through many clock cycles. This use of scan chains, along with the clock control circuits are a related sub-discipline of logic design called [...] "Design for Debug" [...] or [...] "Design for Debuggability".|$|R
40|$|International audienceTo debug running {{software}} we need unanticipated adaptation capabilities, {{especially when}} systems cannot be stopped, updated and restarted. Adapting such programs at runtime {{is an extreme}} solution given the delicate live contexts the debugging activity takes place. We introduce the Dynamic Layer, a construct in which behavioral variations are gathered and activated as {{a whole set of}} adaptations. Dimensions of Dynamic Layers activation are reified to allow very fine definitions of layer scopes and a fine grained selection of adapted entities. This paper describes and discusses the Dynamic Layer solution to <b>perform</b> unanticipated runtime <b>debugging.</b> An experimental implementation with the Pharo language is evaluated through a runtime adaptation example...|$|R
40|$|The {{developed}} {{methods for}} analytical modelling and {{calculation of the}} protocol efficiency characteristics {{can be used for}} network protocol with different complexity level. On base of the applying the developed methods the mathematical models have been obtained and the analytical evaluation of the INMARSAT - AERO network protocol characteristics has been <b>performed.</b> The modules <b>debugged</b> on the simulating model can be transfered into the specialized controller for control of the radio stations. The analytical and simulating model programs permitting to calculate the characteristics of INMARSAT - AERO metwork protocols have been introducedAvailable from VNTIC / VNTIC - Scientific & Technical Information Centre of RussiaSIGLERURussian Federatio...|$|R
40|$|A {{significant}} part of the software development effort is spent on detecting deviations between software implementations and specifications, and subsequently locating the sources of such errors. This thesis illustrates that is possible to identify a significant number of errors during static analysis of declarative object-oriented equation-based modeling languages that are typically used for system modeling and simulation. Detecting anomalies in the source code without actually solving the underlying system of equations provides a significant advantage: a modeling error can be corrected before trying to get the model compiled or embarking on a computationally expensive symbolic or numerical solution process. The overall objective of this work is to demonstrate that debugging based on static analysis techniques can considerably improve the error location and error correcting process when modeling with equation-based languages. A new method is proposed for debugging of over- and under-constrained systems of equations. The improved approach described in this thesis is to <b>perform</b> the <b>debugging</b> process on the flattened intermediate form of the source code and to use filtering criteria generated from program annotations and from the translation rules. Each time when an error is detected in the intermediat...|$|R
40|$|In {{collaboration}} with Cryenco Inc. and NIST-Boulder, {{we intend to}} develop a natural gas-powered natural-gas liquefier which has absolutely no moving parts and requires no electrical power. It will have high efficiency, remarkable reliability, and low cost. Progress on the liquefier to be constructed at Cryenco continues satisfactorily. The thermoacoustic driver is still ahead of the pulse tube refrigerator, because of NIST`s schedule. We completed the thermoacoustics design {{in the fall of}} 1994, with Los Alamos providing physics input and checks of all aspects, and Cryenco providing engineering to ASME code, drafting, etc. Completion of this design represents a significant amount of work, especially in view of the many unexpected problems encountered. Meanwhile, Cryenco and NIST have almost completed the design of the pulse tube refrigerator. At Los Alamos, we have assembled a half-size scale model of the thermoacoustic portion of the 500 gal/day TANGL. This scale model will enable easy experimentation in harmonic suppression techniques, new stack geometries, new heat-exchanger geometries, resonator coiling, and other areas. As of March 1995, the scale model is complete and we are <b>performing</b> routine <b>debugging</b> tests and modifications...|$|R
40|$|This {{application}} note {{is intended to}} be a getting started guide for new users of ENEA OSE BSP on the Zynq®- 7000 AP SoC. The document contains the following sections: • Building OSE for the Zynq- 7000 AP SoC goes over the steps to download, configure and build the OSE BSP, as well as how to boot the device and set up the remote debugging capabilities using ENEA Optima tools. • Building and Debugging an OSE Application for the Zynq- 7000 AP SoC explains how to create a simple application running within OSE, and then sets up the debugging feature of the ENEA tools, and explains how to <b>perform</b> basic <b>debugging</b> of OSE running on a Zynq- 7000 AP SoC. • Accessing a Peripheral in the Programmable Logic goes over the configuration needed to access a peripheral in the programmable logic of the Zynq- 7000 SoC, showing the ability for ENEA Optima tools to develop applications and drivers targeting custom IP instantiated within the Zynq- 7000 AP SoC programmable logic. You can download the reference design f iles for this {{application note}} from the Xilinx ® website. For detailed information about the design files, see Reference Design...|$|R
