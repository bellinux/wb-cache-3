65|723|Public
2500|$|To {{execute a}} command, a {{pipeline}} (represented by a Pipeline object) must be created and {{associated with the}} runspace. The pipeline object is then populated with the cmdlets {{that make up the}} pipeline. For sequential operations (as in a PowerShell script), a Pipeline object is created for each statement and nested inside another Pipeline object. When a pipeline is created, Windows PowerShell invokes the <b>pipeline</b> <b>processor,</b> which resolves the cmdlets into their respective assemblies (the command processor) and adds a reference to them to the pipeline, and associates them with InputPipe, Outputpipe and ErrorOutputPipe objects, to represent the connection with the pipeline. The types are verified and parameters bound using reflection. Once the pipeline is set up, the host calls the Invoke (...) method to run the commands, or its asynchronous equivalent – InvokeAsync (...) [...] If the pipeline has the Write-Host cmdlet {{at the end of the}} pipeline, it writes the result onto the console screen. If not, the results are handed over to the host, which might either apply further processing or display the output itself.|$|E
50|$|A linear <b>pipeline</b> <b>processor</b> is {{a series}} of {{processing}} stages and memory access.|$|E
5000|$|Molnar, C., Sproull, R., Sutherland, I. (1994), Counterflow <b>Pipeline</b> <b>Processor</b> Architecture, Sun Microsystems, Technical Report TR-94-25.|$|E
40|$|This paper {{presents}} {{a method of}} test program generation for software-based self-test of <b>pipelined</b> <b>processors.</b> We propose a model of <b>pipelined</b> <b>processors</b> and testability measures for registers. We generate a test program efficiently by means of specific behaviors of <b>pipelined</b> <b>processors</b> and combinational ATPG. Experimental {{results show that the}} proposed method obtains high fault efficiency. [URL]...|$|R
5000|$|<b>Pipelined</b> <b>processor</b> with 7-way superscalar {{execution}} pipeline ...|$|R
5000|$|... 8-stage <b>pipelined</b> <b>processor</b> with 2-way superscalar, in-order {{execution}} pipeline ...|$|R
5000|$|Counterflow <b>Pipeline</b> <b>Processor</b> Architecture, by Ivan E. Sutherland, Charles E. Molnar (Charles Molnar), and Robert F. Sproull (Bob Sproull), Sun Microsystems Laboratories Report Number TR-94-25, April 1994 ...|$|E
5000|$|Data from ASKAP will be {{transmitted}} from the MRO to a supercomputer at the Pawsey Supercomputing Centre in Perth. The {{data will be}} converted to images of the sky in near-real-time by a <b>pipeline</b> <b>processor</b> running the purpose-built ASKAPsoft package. All data will {{be placed in the}} public domain after being checked for quality by the ten ASKAP Survey Science Teams. Post processing will be supported by supercomputers operated by iVEC at the Pawsey Centre in Perth, and may also be complemented by 'theSkyNet', a [...] "community computing initiative" [...] similar to Seti@home.|$|E
5000|$|EMU will {{survey the}} entire sky {{visible from the}} ASKAP {{telescope}} in 30 square degree fields. Each field will be surveyed over the 300 MHz band from about 1110 to 1410 MHz, in 1 MHz channels, delivering both spectral shapes and, through the POSSUM [...] project, all four Stokes parameters and rotation measures. The data will be processed in near-real-time by the ASKAP <b>pipeline</b> <b>processor.</b> After the processed data have been approved for quality control by the EMU team, they will {{be placed in the}} public domain. The radio components will then be grouped into radio sources, and where possible cross-matched with other multiwavelength data. They will then be placed into the EMU value-added catalogue (EVACAT) which will be available only to members of the EMU team for some proprietary period before being released into the public domain.|$|E
40|$|Abstract: The {{multicore}} {{design has}} become a design philosophy in engineering applications. Speedup has been achieved by increasing clock speeds and, more recently, adding multiple processing cores to the same chip. Although chip speed has increased exponentially over the years, that time is ending and manufacturers have shifted toward multicore processing. However, by {{increasing the number of}} cores on a single chip challenges arise with memory and cache coherence as well as communication between the cores. A multi-core processor is a processing system composed of two or more independent cores. One can describe it as an integrated circuit to which two or more individual processors (called cores in this sense) have been attached. This paper discuss the advantage in the transition from non <b>pipelined</b> <b>processor</b> to single core <b>pipelined</b> <b>processor,</b> and the transition from single core <b>pipelined</b> <b>processor</b> to multicore <b>pipelined</b> <b>processor</b> and finally ends in with designing a quadcore processor. It begins with the discussion of implementation of a non <b>pipelined</b> <b>processor.</b> Secondly we discuss the process of converting it into a <b>pipelined</b> <b>processor</b> and the shared memory issues are discussed. Finally provides the design details of all the phases of a multicore processor with quad port memory design, including performance achievement achieved by this transition. The design is done on xilinx Spartan xc 6 slx 45 -csg 324 - 4 FPGA and it performance characteristics are anlaysed. The designed Quad core performance issues like area, speed and power dissipation are also presented...|$|R
5000|$|<b>Pipelined</b> <b>processor</b> with deeply out of order, {{speculative}} issue 3-way superscalar execution pipeline ...|$|R
40|$|As {{embedded}} systems continue to face increasingly higher performance requirements, deeply <b>pipelined</b> <b>processor</b> architectures are being employed to meet desired system performance. System architects critically need modeling techniques that allow exploration, evaluation, customization and validation of different <b>processor</b> <b>pipeline</b> configurations, tuned {{for a specific}} application domain. We propose a novel Finite State Machine (FSM) based modeling of <b>pipelined</b> <b>processors</b> and define a set of properties {{that can be used}} to verify the correctness of in-order execution in the presence of fragmented pipelines and multicycle functional units. Our approach leverages the system architect's knowledge about the behavior of the <b>pipelined</b> <b>processor,</b> through Architecture Description Language (ADL) constructs, and thus allows a powerful top-down approach to pipeline verification. We applied this methodology to the DLX processor to demonstrate the usefulness of our approach...|$|R
5000|$|To {{execute a}} command, a {{pipeline}} (represented by a [...] object) must be created and {{associated with the}} runspace. The pipeline object is then populated with the cmdlets {{that make up the}} pipeline. For sequential operations (as in a PowerShell script), a Pipeline object is created for each statement and nested inside another Pipeline object. When a pipeline is created, Windows PowerShell invokes the <b>pipeline</b> <b>processor,</b> which resolves the cmdlets into their respective assemblies (the command processor) and adds a reference to them to the pipeline, and associates them with , [...] and [...] objects, to represent the connection with the pipeline. The types are verified and parameters bound using reflection. Once the pipeline is set up, the host calls the [...] method to run the commands, or its asynchronous equivalent - [...] If the pipeline has the [...] cmdlet {{at the end of the}} pipeline, it writes the result onto the console screen. If not, the results are handed over to the host, which might either apply further processing or display the output itself.|$|E
40|$|We have {{developed}} PGPG (Pipeline Generator for Programmable GRAPE), a software which generates the low-level {{design of the}} <b>pipeline</b> <b>processor</b> and communication software for FPGA-based computing engines (FBCEs). An FBCE typically consists of one or multiple FPGA (Field-Programmable Gate Array) chips and local memory. Here, the term "Field-Programmable" means that one can rewrite the logic implemented to the chip after the hardware is completed, and therefore a single FBCE {{can be used for}} calculation of various functions, for example pipeline processors for gravity, SPH interaction, or image processing. The main problem with FBCEs is that the user need to develop the detailed hardware design for the processor to be implemented to FPGA chips. In addition, she or he has to write the control logic for the processor, communication and data conversion library on the host processor, and application program which uses the developed processor. These require detailed knowledge of hardware design, a hardware description language such as VHDL, the operating system and the application, and amount of human work is huge. A relatively simple design would require 1 person-year or more. The PGPG software generates all necessary design descriptions, except for the application software itself, from a high-level design description of the <b>pipeline</b> <b>processor</b> in the PGPG language. The PGPG language is a simple language, specialized to the description of pipeline processors. Thus, the design of <b>pipeline</b> <b>processor</b> in PGPG language is much easier than the traditional design. For real applications such as the pipeline for gravitational interaction, the <b>pipeline</b> <b>processor</b> generated by PGPG achieved the performance similar to that of hand-written code. In this paper we present a detailed description of PGPG version 1. 0. Comment: 24 pages, 6 figures, accepted PASJ 2005 July 2...|$|E
40|$|A {{system that}} detects object {{outlines}} in television images {{in real time}} is described. A high-speed <b>pipeline</b> <b>processor</b> transforms the raw image into an edge map and a microprocessor, which is integrated into the system, clusters the edges, and represents them as chain codes. Image statistics, useful for higher level tasks such as pattern recognition, are computed by the microprocessor. Peak intensity and peak gradient values are extracted within a programmable window and are used for iris and focus control. The algorithms implemented in hardware and the <b>pipeline</b> <b>processor</b> architecture are described. The strategy for partitioning functions in the pipeline was chosen to make the implementation modular. The microprocessor interface allows flexible and adaptive control of the feature extraction process. The software algorithms for clustering edge segments, creating chain codes, and computing image statistics are also discussed. A strategy for real time image analysis that uses this system is given...|$|E
50|$|It {{fails to}} project the {{concurrency}} in <b>pipeline</b> <b>processors,</b> as degree of parallelism doesn't account for concurrency handle by pipe-lined design.|$|R
40|$|Abstract—This paper {{proposes a}} {{technique}} for dynamic power reduction of <b>pipelined</b> <b>processors.</b> It {{is based on}} eliminating unnecessary transitions that are generated during the execution of NOP instructions. The approach includes the elimination of unnecessary changes in pipe register contents and the limita-tion of boundary movement of transitions caused by inevitable changes in pipe register contents due to insertion of a NOP into a <b>pipelined</b> <b>processor.</b> To assess its efficiency, the proposed technique is applied to MIPS, DLX, and PAYEH processors considering a number of benchmarks. The experimental {{results show that the}} techniques can lead to up to 10 % reduction in the dynamic power consumption at a cost of negligible (almost zero) speed and (about 0. 2 %) area overheads. Index Terms—Dataflow architectures, low-power design, <b>pipelined</b> <b>processors,</b> stall. I...|$|R
40|$|This paper {{proposes a}} graph theoretic model based {{systematic}} approach {{for the delay}} fault testing of　<b>pipelined</b> <b>processor</b> cores using their instruction sets. The proposed methodology generates the test vectorsunder the extracted architectural constraints. These test vectors can be applied in functional mode ofoperation, hence self-test become possible. Self-test in functional mode {{can also be used}} for the on-lineperiodic testing. Our approach uses a graph model to model the behaviour of the <b>pipelined</b> <b>processor</b> whichis then used to extract the architectural constraints and to classify the paths in different categories. Testvectors are generated using constrained ATPG under the extracted constraints. Finally, an instructionsequence is generated for the application of generated test vectors by using graph model. The experimentalresults on a 16 bit five stage <b>pipelined</b> <b>processor</b> (VPRO) demonstrate the effectiveness of our methodology. [URL]...|$|R
40|$|Abstract. Pipeline {{processing}} {{provides us}} {{an effective way}} to enhance processing speed with low hardware costs. However, pipeline hazards are obstacles to the smooth pipelined execution of instructions. This paper analyzes the pipeline hazards occur in a <b>pipeline</b> <b>processor</b> designed for data processing in mechanical measurements. Instruction scheduling and register renaming are performed to eliminate hazards. The simulation experiments are performed, and the effectiveness is confirmed...|$|E
40|$|Abstract — The paper {{presents}} an application specific Java processor including reconfigurabilities, {{which is a}} DLX like <b>pipeline</b> <b>processor</b> with 5 stages and executes Java byte codes directly. Reconfigurabilities are the key technologies for application specific operations. We have introduced two reconfigurabilities: (1) a mechanism to override the control signals for a specific instruction, (2) external components can be attached with the same input and output ports as the internal ALU. I...|$|E
40|$|The rotary <b>pipeline</b> <b>processor</b> {{is a new}} {{architecture}} for superscalar computing. It {{is based}} on a simple and regular pipeline structure which can support several ALUs for efficient dispatching of multiple instructions. Register values flow around a rotary pipeline, constrained by local data dependencies. During normal operation the control circuits are not on the critical path and performance is only limited by data rates. The architecture is particularly well suited to implementation using self-timed logic. ...|$|E
5000|$|<b>Pipelined</b> <b>processors</b> {{commonly}} use {{three techniques}} {{to work as}} expected when the programmer assumes that each instruction completes before the next one begins: ...|$|R
5000|$|A <b>pipelined</b> <b>processor's</b> need to {{organize}} all its work into modular steps may require the duplication of registers {{that increases the}} latency of some instructions.|$|R
40|$|Teaching {{methodology}} Learning {{objectives of}} the subject To provide students with the general concepts and techniques used in current high-performance general purpose microprocessors and systems. Basic contents of the course are the following: <b>Processor</b> design, <b>pipelined</b> <b>processors,</b> superscalar processors, multiprocessor and vector architectures. 1 /...|$|R
40|$|Abstract. We {{consider}} {{the problem of}} bounded model checking of systems expressed in a decidable fragment of first-order logic. While model checking is not guaranteed to terminate for an arbitrary system, it converges for many practical examples, including pipelined processors. We give a new formal definition of convergence that generalizes previously stated criteria. We also give a sound semi-decision procedure to check this criterion based on a translation to quantified separation logic. Preliminary results on simple <b>pipeline</b> <b>processor</b> models are presented...|$|E
40|$|An {{architecture}} for a <b>pipeline</b> <b>processor</b> circuit, preferably of the VLIW type, comprises {{a plurality}} of stages (IF, ID; EX, MEM, WB) and a network of forwarding paths (EX-EX, MEM-EX, MEM-ID) which connect pairs of said stages, {{as well as a}} register file (RF) for operand write-back. An optimization of power consumption function is provided via inhibition of writing (Write Inhibit) and subsequent readings in said Register File (RF) of operands retrievable from said forwarding network on account of their reduced liveness lengt...|$|E
40|$|We {{consider}} {{the problem of}} bounded model checking of systems expressed in a decidable fragment of first-order logic. While model checking is not guaranteed to terminate for an arbitrary system, it converges for many practical examples, including pipelined processors. We give a new formal definition of convergence that generalizes previously stated criteria. We also give a sound semidecision procedure to check this criterion based on a translation to quantified separation logic. Preliminary results on simple <b>pipeline</b> <b>processor</b> models are presented...|$|E
5000|$|C V Ramamoorthy and Benjamin W Wah. An Optimal Algorithm for Scheduling Requests on Interleaved Memories for a <b>Pipelined</b> <b>Processor.</b> IEEE Trans. Computers (...) , 30(10):787- 800, 1981.|$|R
40|$|<b>Pipeline</b> FFT <b>processors</b> {{are used}} in mobile {{communication}} systems and in particular in OFDM-based systems. This paper presents a method for power analysis and clock optimization of <b>pipeline</b> FFT <b>processors</b> for particular OFDM baseband system. This method is applied to various architectures with different radices. The analysis {{can be used in}} the design of high speed <b>pipeline</b> FFT <b>processors...</b>|$|R
40|$|We {{present a}} {{technique}} for automatic verification of pipelined microprocessors using model checking. Antecedent conditioned slicing is an efficient abstraction technique for hardware designs at the Register Transfer Level (RTL). Antecedent conditioned slicing prunes the verification state space, using {{information from the}} antecedent of a given LTL property. In this work, we model instructions of a <b>pipelined</b> <b>processor</b> as LTL properties, such that the instruction opcode forms the antecedent. We use antecedent conditioned slicing to decompose the problem space of <b>pipelined</b> <b>processor</b> verification on an instruction-wise basis. We pass the resulting smaller, tractable problems through a lower level verification engine. We thereby verify that every instruction behaves {{according to the specification}} and ensure that non-target registers are not modified by the instruction. We use the SMV model checker to verify all the instruction classes of a Verilog RTL implementation of the OR 1200, an off-the-shelf <b>pipelined</b> <b>processor.</b> 1...|$|R
40|$|A {{methodology}} and a package is proposed {{that has been}} developed for performance analysis of a class type of timed Petri net model which is particularly suitable for, but not restricted to, communication protocols. The method's theoretical foundation, {{which is based on}} analysing the embedded Markov chain of a derived decision reachability graph for the TPN model that is considered, is presented. The methodology is demonstrated by analysing two simple models: an alternating bit data link protocol; and a two-stage <b>pipeline</b> <b>processor</b> architecture. © 1990...|$|E
40|$|Abstract: 2 ̆ 2 We {{consider}} {{the problem of}} bounded model checking of systems expressed in a decidable fragment of first-order logic. While model checking is not guaranteed to terminate for an arbitrary system, it converges for many practical examples, including pipelined processors. We give a new formal definition of convergence that generalizes previously stated criteria. We also give a sound semi-decision procedure to check this criterion based on a translation to quantified separation logic. Preliminary results on simple <b>pipeline</b> <b>processor</b> models are presented. 2 ̆...|$|E
40|$|A {{distributed}} Java platform {{has been}} designed and built for the simplified implementation of distributed Java applications. Its programmable nature means that code as well as data is distributed over a network. The platform is largely based on the Java Distributed Computation Library of Fritsche, Power, and Waldron. The generality of our system is demonstrated through the emulation of a MIMD (multiple instruction, multiple data) architecture. This is achieved by augmenting the server with a virtual <b>pipeline</b> <b>processor.</b> We explain {{the design of the}} system, its deployment over a university network, and its evaluation through a sample application...|$|E
50|$|A <b>pipelined</b> <b>processor</b> may {{deal with}} hazards by {{stalling}} {{and creating a}} bubble in the pipeline, resulting {{in one or more}} cycles in which nothing useful happens.|$|R
50|$|WebMIPS is a {{browser-based}} MIPS simulator {{with visual}} {{representation of a}} generic, <b>pipelined</b> <b>processor.</b> This simulator is quite useful for register tracking during step by step execution.|$|R
3000|$|... 2 -optimal {{requiring}} no shuffling between iterations of a <b>pipelined</b> <b>processor.</b> In applying these factorizations {{the successive}} iterations are effected on successive sub-images such that after log [...]...|$|R
