13|330|Public
5000|$|Snapshot {{support for}} <b>precompiling</b> JavaScript source code to byte code ...|$|E
40|$|Abstract. In {{this paper}} a simple {{straight}} string search algorithm is presented. For a string s {{that consists of}} n characters and a pattern p that consists of m characters the order of comparisons is O(n:m), 0 < m n, in the worst case, but the average time complexity is good. The algorithm presented nds all occurrences of p in s. It do not use a <b>precompiling</b> of the pattern p. 1991 Mathematical Subject Classications: 68 P 10 [Searching and Sorting] Key words: direct, string, pattern, searc...|$|E
40|$|This paper {{describes}} {{some aspects}} of Steedman's grammar for jazz chord sequences. We have implemented this formalism in a computer system for improvisation. Some specific problems concerning the rewrite rule mechanism arise from the real-time improvisation context. This leads to the formal study {{of the language of}} chord sequences generated by Steedman's grammar, which rely on particular cadential sequences. An improvement of the system in order to fit the real-time constraints could consist in <b>precompiling</b> these cadential sequences for improvisation and elaboration Keywords Formal grammar, rewrite rule, chord sequence, harmonic substitution, jazz, improvisation, real-time...|$|E
40|$|This paper {{describes}} the crucial {{design and implementation}} issues that arise in building a fully automatic <b>precompiled</b> header mechanism for compiling industrial-strength C and C++ applications. The key challenges include designing the Makefiletransparent automation, determining the precompileable region, capturing the compile environment and verifying it and addressing the correctness issues involved in using <b>precompiled</b> headers. The ensuing discussion treats the internals of the actual dumping and loading of <b>precompiled</b> headers as a black-box beyond a brief high-level description. An automatic <b>precompiled</b> header mechanism has been implemented in aCC, the HP ANSI C++ compiler, {{and the results of}} compiling real applications show that it achieves significant speedup in compile-times of real applications...|$|R
5000|$|In {{the default}} project configuration, the C++Builder {{compiler}} implicitly generates <b>precompiled</b> headers for all headers included by a source module until the line [...] is found. <b>Precompiled</b> headers are shared for all modules {{of the project}} if possible. For example, when working with the Visual Component Library, {{it is common to}} include the [...] header first which contains most of the commonly used VCL header files. Thus, the <b>precompiled</b> header can be shared across all project modules, which dramatically reduces the build times.|$|R
5000|$|When {{compiling}} source.cpp for {{the first}} time with the <b>precompiled</b> header feature turned on, the compiler will generate a <b>precompiled</b> header, [...] The next time, if the timestamp of this header did not change, the compiler can skip the compilation phase relating to [...] and instead use header.pch directly.|$|R
40|$|Developing and {{maintaining}} ontologies {{is an expensive}} and error-prone task. After an error is detected, users {{may have to wait}} {{for a long time before}} a corrected version of the ontology is available. In the meantime, one might still want to derive meaningful knowledge from the ontology, while avoiding the known errors. We introduce brave and cautious reasoning and show that it is hard for EL. We then propose methods for improving the reasoning times by <b>precompiling</b> informa-tion about the known errors and using proof-theoretic techniques for computing justifications. A prototypical implementation shows that our approach is feasible for large ontologies used in practice...|$|E
40|$|Due {{to growing}} demand for {{computer}} generated graphi-cal content, procedural modeling has become an important topic in the gaming and movie industry. Creating vast amounts of content by hand requires excessive amounts of manual labor. Using a procedural rule set, entire worlds can be generated by a computer. However, the traditional CPU-based derivation of a large city can take multiple hours, making rapid design iterations impossible. In this paper, we investigate different strategies to execute procedural modeling on graphics processors using CUDA. We com-pare a persistent threads megakernel approach to simple kernel calls and different rule queuing strategies. Along these lines, we explore the trade-off between <b>precompiling</b> an entire rule set and interpreting a rule set online...|$|E
40|$|MIPS, model {{checking}} has eventually approached classical AI planning. It was {{the first}} planning system based on for-mal verification techniques {{that turned out to}} be competitive with the various Graphplan- or SAT-based approaches on a broad spectrum of domains. MIPS uses binary decision diagrams (BDDs, introduced by Bryant (1986)) to compactly store and operate on sets of states. More precisely, it applies reduced ordered binary decision diagrams, which we will refer to simply as BDDs for the rest of this article. Its main strength compared to other, similar approaches lies in its <b>precompiling</b> phase, which infers a concise state representation by exhibiting knowledge that is implicit in the description of the planning domain (Edelkamp & Helmert 1999). This representation is then used to carry out an accu...|$|E
5000|$|Manuel Llorens' fast <b>precompiled</b> dcraw {{binaries}} include Rawzor support.|$|R
50|$|The {{source code}} and <b>precompiled</b> {{packages}} of the deblobbed Linux kernel are available {{directly from the}} distributions which use the Linux-libre scripts. Freed-ora is a subproject which prepares and maintains RPM packages based on the Fedora kernel. There are also <b>precompiled</b> packages for Debian and derived distributions such as Ubuntu.|$|R
50|$|GCC {{can only}} use the <b>precompiled</b> version {{if the same}} {{compiler}} switches are set as when the header was compiled and it may use at most one. Further, only preprocessor instructions may be placed before the <b>precompiled</b> header (because it must be directly or indirectly included through another normal header, before any compilable code).|$|R
40|$|Matlab {{is one of}} {{the most}} popular {{computer}} languages for technical and scientific programming. However, until recently, it has been limited to running on uniprocessors. One strategy for overcoming this limitation is to introduce global distributed arrays, with those arrays distributed across the processors of a parallel machine. In this paper, we describe the compilation technology we have designed for Matlab D, a distributed-array extension of Matlab. Our approach is distinguished by a two-phase compilation technology with support for a rich collection of data distributions. By <b>precompiling</b> array operations and communication steps into Fortran plus MPI, the time to compile an application using those operations is significantly reduced. This paper includes preliminary results that demonstrate that this approach can dramatically improve performance, scaling well to at least 32 processors...|$|E
40|$|We {{describe}} an interlingua-based methodology for translating encoded knowledge and present a formalism for declaratively specifying vocabulary translations within a predicate logic interlingua. In this paper we (1) use the formalism {{to provide a}} semantics for translation, (2) show that the formalism enables translation to be done as deduction by a standard theorem prover, (3) describe a proof technique for determining whether a given set of rules for translating from one vocabulary to another is sufficient for performing that translation for any theory, (4) provide examples of how the formalism {{can be used to}} specify various forms of translation, including abstractions and approximations, and (5) describe techniques for <b>precompiling</b> translation rules that translate directly between two given vocabularies. 1 Motivation Acquiring and representing knowledge is the key to building powerful intelligent systems. Unfortunately, knowledge base construction is difficult and time consuming. T [...] ...|$|E
40|$|Abstract — Xilinx VirtexII Pro FPGAs support dynamic reconfiguration. To {{benefit from}} this functionality, Xilinx proposes a modular and {{differential}} development flow, which consists in <b>precompiling</b> all possible configurations and switching {{from one to another}} in real time. The pre-compilation process is too slow and static. Xilinx also supplies JBits, but this tool does not support the VirtexII Pro FPGA and later devices. We aim to dynamically produce digital circuits. Unfortunately, since Xilinx does not entirely document the format of the FPGA bitstreams, it is in principle impossible to produce bitstreams without using their tools. This paper presents the methodology we have used to determine the Xilinx bitstream format in order to quickly produce valid configurations on the fly using only our tools. Our synthesis approach translates a simple expression language into a dataflow graph of predefined tiles which are placed and interconnected using the bitstream format information we gathered...|$|E
5000|$|<b>Precompiled</b> headers are {{supported}} in GCC (3.4 and newer). GCC's approach {{is similar to}} these of VC and compatible compilers. GCC saves <b>precompiled</b> versions of header files using a [...] ".gch" [...] suffix. When compiling a source file, the compiler checks whether this file {{is present in the}} same directory and uses it if possible.|$|R
5000|$|... : a file {{containing}} <b>precompiled</b> resources, such as binary XML for example.|$|R
50|$|The Extra edition {{adds the}} ability to create <b>precompiled</b> scripts. It costs $99.|$|R
40|$|We {{present a}} multi-pass {{approach}} to real-time, largevocabulary speech recognition {{in which we}} dynamically manipulate the vocabulary between passes. For recognition tasks where subsets of the vocabulary can be triggered by the occurences of other words or phrases, a combination of unknown word modelling and vocabulary refinement can be utilized to attack large-vocabulary tasks with relatively small active vocabularies. We evaluate this approach within the JUPITER weather information domain by enabling recognition of all 30, 000 citystate pairs within the USA. By maximally <b>precompiling</b> the static and dynamic portions of our search space using finitestate transducers (FSTs), we splice dynamic-vocabulary components on-demand during decoding with negligible speed impact while enforcing cross-word context-dependent constraints. We find that a dynamic-vocabulary system can compete quite favorably with a single-pass, large-vocabulary system. For even larger vocabularies (e. g., street addresses), static compilation may be infeasible, making a dynamic-vocabulary approach necessary. 1...|$|E
40|$|With the {{explosive}} growth of the Web, {{one of the biggest}} challenges in exploiting the wealth of available information is to locate the relevant documents. Search engines play a crucial role in addressing this problem by <b>precompiling</b> a large index of available information to quickly produce a set of possibly relevant documents in response to a query. While most Web users make extensive use of the Internet search engines, few people have more than a vague idea of how these systems work. This installment of “Trends & Controversies ” features two essays that describe the inner workings of Internet search engines. In the first, Michael Mauldin, who developed Lycos, presents a brief history of Web search services and describes how search engines such as Lycos perform their tasks. In the second, Erik Selberg and Oren Etzioni, who developed the MetaCrawler Softbot, describe how their system exploits the results from other search engines to provide a comprehensive set of documents in response to a query...|$|E
40|$|Supervised {{learning}} in attribute-based spaces {{is one of}} the most popular machine learning problems studied and, consequently, has attracted considerable attention from the evolutionary computation community. The problem studied here is typical—determining optimal symbolic descriptions for a concept, for which positive and negative examples are provided along with an appropriate language. Key difficulties stem from such concept descriptions being sets of elementary descriptions. The approach presented here uses a variable-length representation—each chromosome represents a complete set of these elementary elements. Another difficulty lies in the gap between the abstract variablelength phenotype and the often used binary genotype. This problem is avoided by defining the evolutionary search at the phenotype level. Finally, most other evolutionary approaches suffer from high time complexity. The approach presented in this case study alleviates this problem by utilizing problem specific search operators and heuristics and by <b>precompiling</b> data to facilitate faster evaluations. G 2. 3. 1 G 2. 3. 1. 1 Project overview Problem description Supervised concept learning is a fundamental cognitive process that involves learning descriptions of some categories of objects. Precategorized example objects constitute a priori knowledge. Acquired descriptions, often in the form of rules, can subsequently be used to both infer properties of the corresponding concepts (characteristic descriptions) or to decide which category new objects belong to (discriminant descriptions). Table G 2. 3. 1. Attributes and domains...|$|E
50|$|On 1 August 2006, DeLano Scientific {{adopted a}} controlled-access {{download}} system for <b>precompiled</b> PyMOL builds (including betas) {{distributed by the}} company. Access to these executables is now limited to registered users who are paying customers; educational builds are available free to students and teachers. However, most of the current source code continues to be available for free, as are older <b>precompiled</b> builds. While the build systems for other platforms are open, the Windows API (WinAPI, Win32) build system is not, although unofficial Windows binaries are available online. Anyone can either compile an executable from the source code or pay for a subscription to support services to obtain access to <b>precompiled</b> executables.|$|R
50|$|In {{computer}} programming, a <b>precompiled</b> header is a (C or C++) header {{file that}} is compiled into an intermediate form that is faster to {{process for the}} compiler. Usage of <b>precompiled</b> headers may significantly reduce compilation time, especially when applied to large header files, header files that include many other header files, or header files that are included in many translation units.|$|R
2500|$|ANGLE for Windows Store [...] {{provides}} Windows developers <b>precompiled</b> ANGLE binaries via a NuGet package ...|$|R
40|$|The Problem: To achieve robustness, {{autonomous}} systems, such as {{deep space}} explorers, and embedded systems, such as intelligent automobiles, {{must be able}} to repair or reconfigure their underlying hardware as failures occur. This requires planning algorithms that are able to reason from engineering models, in order to generate novel command sequences. These planners are similar to STRIPs-style planners, with the added complexity that they must reason through the indirect effects of hardware component interactions. To handle novel situations these planners must operate at reactive time scales, generating novel actions within the sense-act loop. The challenge is that even STRIPS-style planning is known to be NP Hard. Methods for <b>precompiling</b> reactive plans are efficient, such as universal plans. However, universal plans have size quadratic in the number of system states, and are impractical for real-world systems. This research addresses the problemofgenerating reactive plans that are compact, fast and offer hard, real-time guarantees. Motivation: Future space exploration will require autonomous systems that are able to act alone, responding to novel situations and failures, sometimes within the fraction of a second. In our past work we demonstrated NASA’s first fully autonomous spacecraft called Deep Space 1 mission, which acts by reasoning from basic engineering hardware and operations models. We continue this line of workintheupcoming Air Force T 21 multi-spacecraft mission and NASA’s Space Technology 7 space probe(ST 7) ...|$|E
5000|$|Simorgh (SPL) سیمرغ - An object-oriented, general-purpose, {{interpreted}} and <b>precompiled,</b> portable and open-source programming language.|$|R
5000|$|... {{explicitly}} execute stored <b>precompiled</b> code {{made by a}} compiler {{which is}} part of the interpreter system.|$|R
50|$|<b>Precompiled</b> JWasm {{binaries}} {{are available}} for DOS, Windows and Linux. For OS/2 and FreeBSD, makefiles are supplied.|$|R
40|$|The wide use of {{separate}} compilation and <b>precompiled</b> libraries among programmers poses {{a challenge to}} source-code based security and analysis tools such as CCured. These tools must understand enough {{of the behavior of}} <b>precompiled</b> libraries that they can prevent any unsafe use of the library. The situation is even more complicated for instrumentation tools that change the layout of data to accommodate array bounds or other metadata that is necessary for safety checking...|$|R
50|$|Unlike other solutions, the {{database}} server does not compile queries itself, but executes queries <b>precompiled</b> in a custom access specification language.|$|R
5000|$|BCI2000 is {{available}} as <b>precompiled</b> Windows executables or as source code, which is officially supported for compilation {{on the following}} platforms: ...|$|R
40|$|Knowledge {{compilation}} is {{a common}} technique for propositional logic knowledge bases. The idea is to transform a given knowledge base into a special normal form ([11],[6]), for which queries can be answered efficiently. This precompilation step is very expensive but it only has to be performed once. We propose to apply this technique to knowledge bases defined in Description Logics. For this, we introduce a structure called linkless graph, for ALC concepts. Further we present an algorithm, based on path dissolution, {{which can be used}} for this precompilation step. We discuss an efficient satisfiability test as well as a subsumption test for <b>precompiled</b> concept descriptions. Finally we show how to extend this approach in order to <b>precompile</b> Tboxes and to use the <b>precompiled</b> Tboxes for efficient Tbox reasoning...|$|R
50|$|FSL is {{available}} as both <b>precompiled</b> binaries and source code for Apple and PC (Linux) computers. It is freely available for non-commercial use.|$|R
50|$|In addition, C++Builder can be {{instrumented}} to use {{a specific}} header file as <b>precompiled</b> header, similar to the mechanism provided by Visual C++.|$|R
50|$|Release {{versions}} {{and development}} versions are available as C++ source code, and as <b>precompiled</b> versions for Microsoft Windows, macOS, Linux 32-bit/64-bit and Android.|$|R
2500|$|Both {{the source}} and <b>precompiled</b> {{binaries}} of BLAT are freely available for academic and personal use. Commercial license of stand-alone BLAT is distributed by ...|$|R
