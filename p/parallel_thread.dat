71|489|Public
5|$|A valve failed on a diver’s {{emergency}} cylinder on {{a diving}} support vessel during {{preparation for a}} dive injuring five divers. The cylinder valve was ejected at 180 bar due to incompatible thread. Pillar valve was M25x2 <b>parallel</b> <b>thread</b> and cylinder was a 3/4″x14 BSP <b>parallel</b> <b>thread.</b>|$|E
5|$|All <b>parallel</b> <b>thread</b> valves {{are sealed}} using an O-ring at {{top of the}} neck thread which seals in a chamfer or step in the {{cylinder}} neck and against the flange of the valve.|$|E
5|$|Cylinder threads {{may be in}} {{two basic}} configurations: Taper thread and <b>parallel</b> <b>thread.</b> These thread {{specifications}} are detailed in a previous section. The valve thread specification must exactly match the neck thread specification of the cylinder. Improperly matched neck threads can fail under pressure and can have fatal consequences.|$|E
5000|$|Some of {{the common}} {{features}} of Dextra's <b>parallel</b> <b>threaded</b> splicing systems are as follows: ...|$|R
50|$|The {{story was}} told in three <b>parallel</b> <b>threads</b> which {{eventually}} intertwined {{in the later}} part of the book.|$|R
50|$|Separation logic {{was used}} {{originally}} to prove sequential programs, but then {{was extended to}} concurrency using a proof rulethat divides the storage accessed by <b>parallel</b> <b>threads.</b>|$|R
500|$|M18x1.5 <b>parallel</b> <b>thread,</b> {{which is}} sealed by an O-ring, and torqued to [...] on steel cylinders, and [...] on {{aluminium}} cylinders; ...|$|E
500|$|M25x2 ISO <b>parallel</b> <b>thread,</b> {{which is}} sealed by an O-ring and torqued to [...] on steel, and [...] on {{aluminium}} cylinders; ...|$|E
500|$|... 3/4"x14BSP <b>parallel</b> <b>thread,</b> {{which has}} a 55° Whitworth thread form, a pitch {{diameter}} of [...] and a pitch of 14 threads per inch (1.814mm); ...|$|E
5000|$|VITESS 2.10 (Oct 2011) <b>parallel</b> <b>threads</b> reduce {{simulation}} time on multi-processor computers, {{visualization of}} trajectories in neutron guide, output compression, new components: elliptic mirror, lens, beamstop ...|$|R
3000|$|... • Client – a GUI {{application}} {{responsible for}} sending {{jobs to the}} corresponding queue. From the GUI {{it is possible to}} specify the number of <b>parallel</b> <b>threads</b> sending tasks to the queue.|$|R
50|$|Gauging of threads may be {{mandatory}} {{to ensure}} the integrity of <b>parallel</b> <b>threads.</b> If the gauge exceeds the maximum gauge limit for taper threads, re-tapping may be considered {{at the discretion of}} the competent person.|$|R
500|$|... 3/4"x14NGS (NPSM) <b>parallel</b> <b>thread,</b> sealed by an O-ring, torqued to [...] on {{aluminium}} cylinders, {{which has}} a 60° thread form, a pitch diameter of , and a pitch of 14 threads per inch (5.5 threads per cm); ...|$|E
50|$|A valve failed on a diver’s {{emergency}} cylinder on {{a diving}} support vessel during {{preparation for a}} dive injuring five divers. The cylinder valve was ejected at 180 bar due to incompatible thread. Pillar valve was M25x2 <b>parallel</b> <b>thread</b> and cylinder was a 3/4″x14 BSP <b>parallel</b> <b>thread.</b>|$|E
5000|$|M18x1.5 <b>parallel</b> <b>thread,</b> {{which is}} sealed by an O-ring, and torqued to 100 to 130 Nm on steel cylinders, and 85 to 100 Nm on {{aluminium}} cylinders; ...|$|E
50|$|Thread tape is {{appropriate}} for use on tapered threads, where the sealing force is a wedge action. <b>Parallel</b> <b>threads</b> may not seal effectively with or without tape, as {{they are intended to}} be sealed by a gasket.|$|R
50|$|If {{the pool}} is used by {{multiple}} threads, it may need the means to prevent <b>parallel</b> <b>threads</b> from grabbing and trying to reuse the same object in parallel. This is not necessary if the pooled objects are immutable or otherwise thread-safe.|$|R
40|$|Dynamic {{software}} update {{is a technique}} by which a running program can be updated with new code and data without interrupting its execution. Often we will want to preserve properties of programs across update boundaries. Preserving simple typing across update boundaries for single-threaded programs is well studied. There are other higher-level properties we may wish to preserve, particularly for multi-threaded programs. Session typing is used to guarantee that a set of <b>parallel</b> <b>threads</b> communicate according to a given protocol. Hence we investigate preserving correct communications behaviour {{of a set of}} <b>parallel</b> <b>threads</b> correctly across update boundaries which change the running protocol. We present a procedure for updating multiple threads to cleanly migrate a system from one protocol to another...|$|R
5000|$|M25x2 ISO <b>parallel</b> <b>thread,</b> {{which is}} sealed by an O-ring and torqued to 100 to 130 Nm on steel, and 95 to 130 Nm on {{aluminium}} cylinders; ...|$|E
5000|$|... 3/4"x14 BSP <b>parallel</b> <b>thread,</b> {{which has}} a 55° Whitworth thread form, a pitch {{diameter}} of 25.279 mm and a pitch of 14 threads per inch (1.814 mm); ...|$|E
50|$|All <b>parallel</b> <b>thread</b> valves {{are sealed}} using an O-ring at {{top of the}} neck thread which seals in a chamfer or step in the {{cylinder}} neck and against the flange of the valve.|$|E
40|$|Abstract. Thread-level {{speculation}} (TLS) allows potentially dependent threads to speculatively execute in parallel, {{thus making}} it easier for the compiler to extract <b>parallel</b> <b>threads.</b> However, the high cost associated with unbalanced load, failed speculation, and inter-thread value communication makes it difficult to obtain the desired performance unless the speculative threads are carefully chosen. In this paper, we focus on extracting <b>parallel</b> <b>threads</b> from loops in generalpurpose applications because loops, with their regular structures and significant coverage on execution time, are ideal candidates for extracting <b>parallel</b> <b>threads.</b> General-purpose applications, however, usually contain a large number of nested loops with unpredictable parallel performance and dynamic behavior, thus making it difficult to decide which set of loops should be parallelized to improve overall program performance. Our proposed loop selection algorithm addresses all these difficulties. We have found that (i) with the aid of profiling information, compiler analyses can achieve a reasonably accurate estimation of the performance of parallel execution, and that (ii) different invocations of a loop may behave differently, and exploiting this dynamic behavior can further improve performance. With a judicious choice of loops, we can improve the overall program performance of SPEC 2000 integer benchmarks by as much as 20 %. ...|$|R
30|$|In this paper, a novel FIB named MaFIB is {{proposed}} {{to meet the}} NDN’s requirement and makes full use of the current faster memory chips. Our current and future work is to extend this design to build an engine running on multiple <b>parallel</b> <b>threads</b> with real packets.|$|R
40|$|The statechart formalism, {{proposed}} by Harel [6] {{as an extension}} of conventional fi-nite state machines, is a visual language for specifying reactive systems. It addresses the state explosion problem of state transition diagrams when modeling systems with <b>parallel</b> <b>threads</b> of control by introducing the concepts of hierarchy, concurrency, an...|$|R
5000|$|Parallel (straight) threads, British Standard Pipe <b>Parallel</b> <b>thread</b> (BSPP; {{originally}} {{also known}} as British Standard Pipe Fitting thread/BSPF and British Standard Pipe Mechanical thread/BSPM), which have a constant diameter; denoted by the letter G.|$|E
5000|$|... 3/4"x14 NGS (NPSM) <b>parallel</b> <b>thread,</b> sealed by an O-ring, torqued to 40 to 50 Nm on {{aluminium}} cylinders, {{which has}} a 60° thread form, a pitch diameter of 0.9820 to 0.9873 in, and a pitch of 14 threads per inch (5.5 threads per cm); ...|$|E
50|$|Cylinder threads {{may be in}} {{two basic}} configurations: Taper thread and <b>parallel</b> <b>thread.</b> These thread {{specifications}} are detailed in a previous section. The valve thread specification must exactly match the neck thread specification of the cylinder. Improperly matched neck threads can fail under pressure and can have fatal consequences.|$|E
50|$|In general, {{performance}} {{of any particular}} device can vary significantly in different operating conditions. For example, the number of <b>parallel</b> <b>threads</b> accessing the storage device, the I/O block size, {{and the amount of}} free space remaining can all dramatically change the performance (i.e. transfer rates) of the device.|$|R
40|$|XMT is a multi-threaded {{programming}} model {{designed to}} exploit explicit specification of <b>parallel</b> <b>threads.</b> Its main features are a simple thread execution model and an efficient prefix-sum instruction for synchronizing shared data accesses. This paper presents and evaluates {{the performance of}} multithreading in the XMT programming environment. A prototype XMT compiler converts parallel regions into procedure calls, which are then executed efficiently in XMT hardware. An architecture simulator similar to SimpleScalar is {{used to evaluate the}} performance of the XMT system for twelve benchmark codes. Results show the XMT architecture generally succeeds in providing low-overhead <b>parallel</b> <b>threads</b> and uniform access times on-chip. However, compiler optimizations to cluster (coarsen) threads are still needed for very fine-grained <b>threads.</b> Keywords <b>Parallel</b> programming, compilers, processor architectures. 1. Introduction Conditional branches, variable memory access latencies, and other barrie [...] ...|$|R
40|$|Increasing {{the number}} of {{instructions}} executing in parallel has helped improve processor performance, but the technique is limited. Executing code on <b>parallel</b> <b>threads</b> and processors has fewer limitations, but most computer programs tend to be serial in nature. This paper presents a compiler optimisation that at run-time parallelises code inside a JVM and thereby increases {{the number of}} threads. We show Spec JVM benchmark results for this optimisation. The performance on a current desktop processor is slower than without <b>parallel</b> <b>threads,</b> caused by thread creation costs, but with these costs removed the perfor-mance {{is better than the}} serial code. We measure the threading costs and discuss how a future computer architecture will en-able this optimisation to be feasible in exploiting thread instead of instruction and/or vector parallelism. 1...|$|R
50|$|<b>Parallel</b> <b>Thread</b> Execution (PTX) is a pseudo-assembly {{language}} used in Nvidia's CUDA programming environment. The nvcc compiler translates code written in CUDA, a C-like language, into PTX, and the graphics driver contains a compiler which translates the PTX into a binary code {{which can be}} run on the processing cores.|$|E
50|$|A {{key feature}} of OpenCL is portability, via its {{abstracted}} memory and execution model, and the programmer {{is not able}} to directly use hardware-specific technologies such as inline <b>Parallel</b> <b>Thread</b> Execution (PTX) for Nvidia GPUs unless they are willing to give up direct portability on other platforms. It is possible to run any OpenCL kernel on any conformant implementation.|$|E
50|$|At version 3.4, LLVM {{supports}} many instruction sets, including ARM, Qualcomm Hexagon, MIPS, Nvidia <b>Parallel</b> <b>Thread</b> Execution (PTX; called NVPTX in LLVM documentation), PowerPC, AMD TeraScale, AMD Graphics Core Next (GCN), SPARC, z/Architecture (called SystemZ in LLVM documentation), x86/x86-64, and XCore. Some {{features are}} not available on some platforms. Most features are present for x86/x86-64, z/Architecture, ARM, and PowerPC.|$|E
40|$|This paper {{presents}} a new combined pointer and escape analysis algorithm for Java programs with unstructured multithreading. The algorithm {{is based on}} the abstraction of parallel interaction graphs, which characterize the points-to and escape relationships between objects and the ordering relationships between actions performed by multiple <b>parallel</b> <b>threads.</b> To our knowledge, this algorithm is the first interprocedural, flow-sensitive pointer analysis algorithm capable of extracting the points-to relationships generated by the interactions between unstructured <b>parallel</b> <b>threads.</b> It is also the first algorithm capable of analyzing interactions between threads to extract precise escape information even for objects accessible to multiple threads. We have implemented our analysis in the IBM Jalape~no dynamic compiler for Java and used the analysis results to eliminate redundant synchronization. For our benchmark programs, the thread interaction analysis significantly improves the effectiven [...] ...|$|R
40|$|We {{describe}} SAFL+: a call-by-value, parallel {{language in}} the style of ML which combines imperative, concurrent and functional programming. Synchronous channels allow communication between <b>parallel</b> <b>threads</b> and -calculus style channel passing is provided. SAFL+ is designed for hardware description and synthesis; a silicon compiler, translating SAFL+ into RTL-Verilog, has been implemented...|$|R
5000|$|The {{history of}} group theory, a {{mathematical}} domain studying groups in their various forms, has evolved in various <b>parallel</b> <b>threads.</b> There are three historical roots of group theory: {{the theory of}} algebraic equations, number theory and geometry. [...] Lagrange, Abel and Galois were early researchers {{in the field of}} group theory.|$|R
