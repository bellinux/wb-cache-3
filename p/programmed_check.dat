0|1105|Public
40|$|Abstract: We {{evaluate}} {{the use of}} <b>program</b> <b>checking</b> to ensure the correctness of compiler implementations. Our contributions in this paper are threefold: Firstly, we extend the classical notion of black-box <b>program</b> <b>checking</b> to <b>program</b> <b>checking</b> with certificates. Our checking approach with certificates relies on the observation that the correctness of solutions of NP-complete problems can be checked in polynomial time whereas their computation itself {{is believed to be}} much harder. Our second contribution is the application of <b>program</b> <b>checking</b> with certificates to optimizing compiler backends, in particular code generators, thus answering the open question of how <b>program</b> <b>checking</b> for such compiler backends can be achieved. In particular, we state a checking algorithm for code generation based on bottom-up rewrite systems from static single assignment representations. We have implemented this algorithm in a checker for a code generator used in an industrial project. Our last contribution in this paper is an integrated view on all compiler passes, in particular a comparison between frontend and backend phases, with respect to the applicable methods of <b>program</b> <b>checking...</b>|$|R
40|$|Abstract. We {{introduce}} <b>program</b> <b>checking</b> with certificates {{by extending}} the traditional notion of black-box <b>program</b> <b>checking.</b> Moreover, we establish <b>program</b> <b>checking</b> with certificates as a safety-scalable and practical method {{to ensure the}} correctness of real-scale applications. We motivate our extension of <b>program</b> <b>checking</b> with concepts of computational complexity theory and show its practical implication on the implementation and verification of checkers. Furthermore, we present an iterative method to construct checkers which is {{able to deal with}} the practically relevant problem of incomplete or missing specifications of software. In our case study, we have considered compilers and their generators, in particular code generators based on rewrite systems...|$|R
40|$|A program checker verifies that a {{particular}} program execution is correct. We give simple and efficient program checkers for some basic geometric tasks. We report about our experiences with <b>program</b> <b>checking</b> {{in the context of}} the LEDA system. We discuss <b>program</b> <b>checking</b> for data structures that have to rely on user-provided functions...|$|R
5000|$|When required, the <b>program</b> <b>checks</b> {{the volume}} for errors before defragmenting.|$|R
5000|$|SizeMeInstallation wizard based and the <b>program</b> <b>checks</b> for {{updates on}} startup (optional), Freewarehttps://web.archive.org/web/20051228104936/http://lars.werner.no:80/sizeme/ ...|$|R
40|$|Abstract. Students of our {{department}} solve algebraic exercises in math-ematical logic in a computerized environment. They construct transfor-mations {{step by step}} and the <b>program</b> <b>checks</b> the syntax, equivalence of expressions and completion of the task. With our current project, we add a <b>program</b> component for <b>checking</b> relevance of the steps. ...|$|R
5000|$|LM R14,R12,12(R13) where r13 {{incorrectly}} {{points to}} string of X"00"s BR R14 causes PSW to contain X"0000002" [...] with <b>program</b> <b>check</b> [...] "Operation Exception" [...] * all registers on error contain nulls.|$|R
40|$|A basic {{question}} about NP {{is whether or}} not search reduces in polynomial time to decision. We indicate that the answer is negative: under a complexity assumption (that deterministic and non-deterministic double-exponential time are unequal) we construct a language in NP for which search does not reduce to decision. These ideas extend in a natural way to interactive proofs and <b>program</b> <b>checking.</b> Under similar assumptions we present languages in NP for which it is harder to prove membership interactively than it is to decide this membership, and languages in NP which are not checkable. Keywords: NP-completeness, self-reducibility, interactive proofs, <b>program</b> <b>checking,</b> sparse sets...|$|R
50|$|This {{construct}} {{may cause}} a <b>program</b> <b>check</b> or protection violation if address 0 is protected against {{reading on the}} machine the program is running upon or the operating system it is running under.|$|R
50|$|Since {{this new}} {{approach}} {{does not use}} a return instruction, it has negative implications for defense. When a defense <b>program</b> <b>checks</b> not only for several returns but also for several jump instructions, this attack may be detected.|$|R
50|$|On {{some models}} the {{alignment}} requirements for some problem-state instructions were relaxed. There is no mechanism {{to turn off}} this feature, and programs depending on receiving a <b>program</b> <b>check</b> type 6 (alignment) on those instructions must be modified.|$|R
25|$|In QuickTime 7.3, a {{processor}} that supports SSE is required. QuickTime 7.4 {{does not require}} SSE. Unlike versions 7.2 and 7.3, QuickTime 7.4 cannot be installed on Windows XP SP1 system (its setup <b>program</b> <b>checks</b> if Service Pack 2 is installed).|$|R
50|$|The five {{events from}} EAs website {{instructed}} users {{to participate in}} the Battlefield Veterans <b>program,</b> <b>check</b> the players stats online after playing the game, register for the BF newsletter, pre-order the game through participating stores, and get to rank 4 in the demo.|$|R
40|$|AbstractIn theory, <b>program</b> result <b>checking</b> {{has been}} {{established}} as a well-suited method to construct formally correct compiler frontends but it has never proved its practicality for real-life compilers. Such a proof is necessary to establish result checking as the method of choice to implement compilers correctly. We show that the lexical analysis of the GNU C compiler can be formally specified and checked within the theorem prover Isabelle/HOL utilizing <b>program</b> <b>checking.</b> Thereby we demonstrate that formal specification and verification techniques are able to handle real-life compilers...|$|R
40|$|Photograph {{used for}} {{a story in the}} Oklahoma Times newspaper. Caption: "Robert L. Daniels, {{electronic}} technician in Florida-based hurricane research <b>program,</b> <b>checks</b> radar instruments in a DC- 6 that will seek new weather knowledge in Oklahoma's turbulent spring skies. Weather, Severe Weather Research, U. S. Rough Riders...|$|R
50|$|The <b>program</b> <b>check</b> STXIT {{provided}} {{a mechanism for}} program animation via the deliberate introduction of invalid opcodes (on the fly) to locations in the target programs. Once the exit recovery was entered, the original opcode would be restored ready for later resumption and a new location set.|$|R
5000|$|Functional testing {{differs from}} system testing in that {{functional}} testing [...] "verifies a <b>program</b> by <b>checking</b> it against ... design document(s) or specification(s)", while system testing [...] "validates a <b>program</b> by <b>checking</b> {{it against the}} published user or system requirements" [...] (Kaner, Falk, Nguyen 1999, p. 52).|$|R
40|$|In the <b>program</b> <b>checking</b> paradigm, the {{original}} program is {{run on the}} desired input, and its output is <b>checked</b> by another <b>program</b> called achecker. Recently, the notion of <b>program</b> <b>checking</b> has been extended from its original formulation of checking functions to checking a sequence of operations which query and alter the state of an object external to the <b>program,</b> e. g., <b>checking</b> the interactions between a client and the manager (server) of a data structure. In this expanded paradigm, the checker acts as an intermediary between the client, which generates the requests, and the server, which processes them. The checker is allowed {{a small amount of}} reliable memory and may provide a probabilistic guarantee of correctness for the client. We present off-line and on-line checkers for data structures such as linked lists, trees, and graphs. Previously, the only data structures for which such checkers existed were random access memories, stacks, and queues...|$|R
40|$|In {{this paper}} we study <b>program</b> <b>checking</b> (in {{the sense of}} Blum and Kannan [7]) using AC 0 {{circuits}} as checkers. Our {{focus is on the}} number of queries made by the checker to the <b>program</b> being <b>checked</b> and we term this as the query complexity of the checker for the given problem. We study the query complexity of both deterministic and randomized AC 0 checkers. We show that, for each ffl ? 0, ΩΓ n 1) is a lower bound to the query complexity of deterministic AC 0 checkers for Parity and certain P-complete and NC 1 -complete problems, where n is the input size. On the other hand, we show that Parity and suitably encoded complete problems for P, NL, and NC 1 have randomized AC 0 checkers of constant query complexity. The latter results are proved using techniques from the PCP(n 3; 1) protocol for 3 -SAT in [4]. 1 Introduction In this paper we study <b>program</b> <b>checking</b> (in the sense of Blum and Kannan [7]) using AC 0 circuits as checkers. Our main focu [...] ...|$|R
40|$|The Weizmann Workshop on Probabilistic Proofs and Applications to <b>Program</b> <b>Checking,</b> Cryptography, and Hardness of Approximation {{was held}} at the Weizmann Institute of Science, on January 10 - 13, 1994. The {{following}} report provides the abstracts of the talks given at the workshop, the list of participants, and relevant references...|$|R
50|$|Superdawg was {{featured}} on the Food Network's television programs Unwrapped and Emeril Live, and on the PBS television <b>program</b> <b>Check,</b> Please! It has been visited by many critics and food aficionados. It is listed in the books 1,000 Places to See Before You Die and Hot Dog Chicago: A Native's Dining Guide.|$|R
5000|$|Malicious {{users are}} likely to invent new kinds of {{representations}} of incorrect data. For example, if a <b>program</b> <b>checks</b> if the requested file is not [...] "/etc/passwd", a cracker might pass another variant of this file name, like [...] "/etc/./passwd". Canonicalization libraries can be employed to avoid bugs due to non-canonical input.|$|R
40|$|International audienceLint-like program {{checkers}} {{are popular}} tools that ensure code quality by verifying compliance with best practices {{for a particular}} programming language. The proliferation of internal domain-specific languages and models, however, poses new challenges for such tools. Traditional program checkers produce many false positives and fail to accurately check constraints, best practices, common errors, possible optimizations and portability issues particular to domain-specific languages. We advocate the use of dedicated rules to check domain-specific practices. We demonstrate the implementation of domain-specific rules, the automatic fixing of violations, and their application to two case-studies: (1) Seaside defines several internal DSLs through a creative use of the syntax of the host language; and (2) Magritte adds meta-descriptions to existing code by means of special methods. Our empirical validation demonstrates that domain-specific <b>program</b> <b>checking</b> significantly improves code quality when compared with general purpose <b>program</b> <b>checking...</b>|$|R
40|$|Abstract. This paper explores z-ranking, a {{technique}} to rank error reports emitted by static <b>program</b> <b>checking</b> analysis tools. Such tools often use approximate analysis schemes, leading to false error reports. These reports can easily render the error checker useless by hiding real errors amidst the false, and by potentially causing the tool to be discarded as irrelevant. Empirically, all tools that effectively find errors have false positive rates that can easily reach 30 – 100 %. Z-ranking employs a simple statistical model to rank those error messages {{most likely to be}} true errors over those that are least likely. This paper demonstrates that z-ranking applies to a range of <b>program</b> <b>checking</b> problems and that it performs up to an order of magnitude better than randomized ranking. Further, it has transformed previously unusable analysis tools into effective program error finders. ...|$|R
40|$|Lint-like program {{checkers}} {{are popular}} tools that ensure code quality by verifying compliance with best practices {{for a particular}} programming language. The proliferation of internal domain-specific languages and models, however, poses new challenges for such tools. Traditional program checkers produce many false positives and fail to accurately check constraints, best practices, common errors, possible optimizations and portability issues particular to domain-specific languages. We advocate the use of dedicated rules to check domain-specific practices. We demonstrate the implementation of domain-specific rules, the automatic fixing of violations, and their application to two case-studies: (1) Seaside defines several internal DSLs through a creative use of the syntax of the host language; and (2) Magritte adds meta-descriptions to existing code by means of special methods. Our empirical validation demonstrates that domain-specific <b>program</b> <b>checking</b> significantly improves code quality when compared with general purpose <b>program</b> <b>checking...</b>|$|R
40|$|This paper explores z-ranking, a {{technique}} to rank error reports emitted by static <b>program</b> <b>checking</b> analysis tools. Such tools often use approximate analysis schemes, leading to false error reports. These reports can easily render the error checker useless by hiding real errors amidst the false, and by potentially causing the tool to be discarded as irrelevant. Empirically, all tools that effectively find errors have false positive rates that can easily reach 30 [...] 100 %. Z-ranking employs a simple statistical model to rank those error messages {{most likely to be}} true errors over those that are least likely. This paper demonstrates that z-ranking applies to a range of <b>program</b> <b>checking</b> problems and that it performs up to an order of magnitude better than randomized ranking. Further, it has transformed previously unusable analysis tools into e#ective program error finders...|$|R
5000|$|... e2fsck : an fsck <b>program</b> that <b>checks</b> for and corrects {{inconsistencies}} ...|$|R
40|$|We {{demonstrate}} {{the use of}} a hyper-programming system to build persistent Java applications in PJama, an orthogonally persistent version of Java. This allows program representations to contain type-safe links to persistent objects embedded directly within the source code. The potential benefits include greater potential for static <b>program</b> <b>checking,</b> improved efficiency, and reduced programming effort. Postprin...|$|R
50|$|Some banks bundle a {{level of}} this service with a {{business}} checking account or with a bank credit card acceptance <b>program.</b> <b>Check</b> verification companies will often offer one, two, {{or all of the}} different services in their own system. Some check verification services also offer collection agency service for the civil prosecution of check fraud.|$|R
5000|$|It {{is called}} a [...] "race" [...] because in its typical manifestation, the <b>program</b> <b>checks</b> {{to see if a}} file by that name already exists; if it does not exist, the program then creates the file. An {{attacker}} must create the link in the interval between the check and when the file is created.|$|R
5000|$|This example {{contains}} no code {{to decide when}} to stop. A more complete <b>program</b> would <b>check</b> for cards that begin with , which denotes {{the start of the}} next job. To stop the card reader as soon as possible, a <b>program</b> could <b>check</b> for the Hollerith code of [...] before even converting the card to EBCDIC.|$|R
40|$|In {{this paper}} we {{address the problem of}} {{integrating}} functions in Datalog. We extend Datalog to a language containing negation, functions, and a strong type system. This type system is used by an algorithm that, given a <b>program,</b> <b>checks</b> for its -consistency (a stronger form of consistency) by using the notions of local dependencies and global dependencies...|$|R
40|$|A {{letter report}} {{issued by the}} Government Accountability Office with an {{abstract}} that begins "Since 9 / 11, {{the federal government has}} taken steps to ensure that transportation workers are screened to ensure that they do not pose a security risk. However, the number of DHS background <b>check</b> <b>programs</b> has raised concerns that such workers may be subject to redundant background <b>check</b> <b>programs.</b> The Security and Accountability for Every Port Act of 2006 required GAO to conduct a study of those DHS background <b>check</b> <b>programs</b> similar to the one required of truck drivers to obtain a hazardous material endorsement (HME). For this study, GAO examined DHS background <b>check</b> <b>programs</b> to identify (1) potential redundancies and inconsistencies, if any, connected with these programs, and (2) actions, if any, DHS is taking or planning to coordinate its background <b>check</b> <b>programs.</b> To address these objectives, GAO examined selected background <b>check</b> <b>programs,</b> interviewed DHS officials and private stakeholders, and reviewed relevant documents. ...|$|R
40|$|A basic {{question}} about NP {{is whether or}} not search reduces in polynomial time to decision. We indicate that the answer is negative: under a complexity assumption (that deterministic and non-deterministic double-exponential time are unequal) we construct a language in NP for which search does not reduce to decision. These ideas extend in a natural way to interactive proofs and <b>program</b> <b>checking.</b> Under similar assumptions we present languages in NP for which it is harder to prove membership interactively than it is to decide this membership, and languages in NP which are not checkable. Keywords: NP-completeness, self-reducibility, interactive proofs, <b>program</b> <b>checking,</b> sparse sets, quadratic residuosity. Department of Computer Science & Engineering, Mail Code 0114, University of California at San Diego, 9500 Gilman Drive, La Jolla, CA 92093. E-mail: mihir@cs. ucsd. edu. Part of this work was done while the author was at MIT, partially supported by NSF grant No. CCR- 8719689 and DARPA grant [...] ...|$|R
40|$|<b>Program</b> <b>{{checking}}</b> {{has been}} thought of merely as checking the computation of a function {{which does not}} have any side effects. We extend the notion of <b>program</b> <b>checking</b> to include <b>programs</b> which alter their environment. In particular, we consider programs which store and retrieve data from memory. <b>Checking</b> such <b>programs</b> is a problem of great practical importance. The model we consider allows the checker a small amount of reliable (possibly secret) memory. The checker is presented with a sequence of requests (on-line) to a data structure which must reside in a large but unreliable memory. We view the data structure as being controlled by an adversary. We want the checker to perform each operation in the input sequence using its reliable memory and the unreliable data structure so that any error in the operation of the structure will be detected by the checker with high probability. We present checkers for various problems of storage and retrieval: random access memories, stacks, and queues [...] . ...|$|R
40|$|<b>Program</b> <b>checking,</b> <b>program</b> self-correcting {{and program}} {{self-testing}} were pioneered by [Blum and Kannan] and [Blum, Luby and Rubinfeld] {{in the mid}} eighties as {{a new way to}} gain confidence in software, by considering program correctness on an input by input basis rather than full program verification. Work in the field of <b>program</b> <b>checking</b> focused on designing, for specific functions, checkers, testers and correctors that are more efficient than the best program known for the function. These were designed utilizing specific algebraic, combinatorial or completeness properties of the function at hand. In this work we introduce a novel composition methodology for improving the efficiency of program checkers. We use this approach to design a variety of program checkers that are provably more efficient, in terms of circuit depth, than the optimal program for computing the function being checked. Extensions of this methodology for the cases of program testers and correctors are also presented. In particular, we show: • For all i ≥ 1, every language in RNC i (that is NC 1 -hard under NC 0 -reductions) has a program checker in RNC i− 1...|$|R
