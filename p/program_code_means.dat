0|6487|Public
40|$|The Warren Instruction Set for the {{relative}} abstract machine {{designed for the}} execution of Prolog <b>programs</b> is <b>coded</b> by <b>means</b> of a two part opcode. The first part has a fixed, 8 -bit format {{and the second part}} may have a variable format of 8 or of 32 bits containing the value of a respective register or registers. The fourth and the eighth bit of {{the first part of the}} opcode are exploited for interrupting the decoding step, in order to reduce the execution times and for signalling the presence of a second part of opcode with a 32 bit format containing the value of a certain registe...|$|R
50|$|<b>Code</b> {{generation}} <b>means</b> {{that the}} user abstractly models solutions, which are connoted by some model data, {{and then an}} automated tool derives from the models parts {{or all of the}} source code for the software system. In some tools, the user can provide a skeleton of the <b>program</b> source <b>code,</b> {{in the form of a}} source code template where predefined tokens are then replaced with <b>program</b> source <b>code</b> parts during the code generation process.|$|R
30|$|The runtime {{world of}} the {{notional}} machine and the domain world of target processed by <b>program</b> <b>code</b> are hidden and are not clearly visible in <b>program</b> <b>code.</b>|$|R
40|$|Abstract: In {{this paper}} we show a new {{approach}} to evolution of software systems. We embed high-level specification information into <b>program</b> <b>code</b> patterns, so that such <b>program</b> <b>code</b> is interpretable at different abstraction levels. Since these model information is also acessed at run time for execution, we can avoid the situation that <b>program</b> <b>code</b> and high-level specifications are out of synch. Since the <b>program</b> <b>code</b> is thus a valid notation for the model syntax, we can apply transformations based on model semantics to it. An example will be provided that transforms software based on state machines to process models. This leads to a new perspective of software evolution in which the <b>program</b> <b>code</b> can be considered at higher levels of abstraction. ...|$|R
40|$|There are {{numerous}} of <b>program</b> <b>code</b> {{resources on the}} web which are solutions to programming problems on online judges. These <b>program</b> <b>code</b> resources are not organized for students to learn data structures and algorithms although they contain much knowledge of data structures and algorithms. For this reason, we propose an approach to organize the <b>program</b> <b>code</b> resources together with the programming problems systematically in terms of algorithms and data structures. This approach {{is based on the}} discovery of associate relationships between data structures and algorithms by applying ontology techniques. 1073 <b>program</b> <b>codes</b> on the web which are solutions to 480 problems distributed on online judges were mined in our experiment to discover the relationships between the data structures and algorithms used in the <b>program</b> <b>codes.</b> With the discovered relationships, the <b>program</b> <b>codes</b> and the corresponding problems were organized into learning materials in terms of algorithms and data structures. We believe that it would be useful for students to learn the programming knowledge. </p...|$|R
50|$|Languages {{that lack}} {{flexibility}} in specifying string literals make it particularly cumbersome to write <b>programming</b> <b>code</b> that generates other <b>programming</b> <b>code.</b> This {{is particularly true}} when the generation language is the same or similar to the output language.|$|R
30|$|The {{resulting}} packed {{structure of}} the operation sequence ideally comes closer to the <b>program</b> <b>code’s</b> structure. The learner will arrive at {{an understanding of the}} entire control sequence for the <b>program</b> <b>code</b> by completing a series of these activities.|$|R
40|$|This essay {{examines}} common coding practices and, on {{the basis}} that <b>program</b> <b>code</b> should be designed to avoid errors, argues for example that punctuation symbols should not be used in <b>program</b> <b>code</b> as though they were in literary text. Carrying the argument further, it is asserted that the computing profession should not talk about programming languages or about writing <b>programs,</b> but about <b>coding</b> schemes and <b>coding</b> <b>programs...</b>|$|R
50|$|An FT-based, domain-specific {{language}} (FT-DSL) is a domain-specific language whose semantics (expressed in <b>program</b> <b>code)</b> {{have been}} engineered into frames. A typical FT-DSL editor translates between DSL expressions and a frame that will adapt the framed semantics to express program-code equivalents of the DSL expressions. An SPC sitting atop this subassembly can then specify in <b>program</b> <b>code</b> any customizations inexpressible in the domain-specific language. Thus when users regenerate <b>program</b> <b>code</b> from altered DSL expressions, prior customizations are not lost.|$|R
40|$|Programming is {{the most}} {{difficult}} task to most computer sciences students. They always faces problem to write and to understand the <b>program</b> <b>codes.</b> There are lots of exercises is been given to students for practice on writing a <b>program</b> <b>code.</b> But those students still faces problem on understanding the <b>programming</b> <b>codes</b> while written it. The {{purpose of this paper is}} to present the model and the developed system that can help students to understand the <b>programming</b> <b>codes.</b> It is a program understanding system for an object-oriented programming language using the plan base approach named CONCEIVER++. In this paper will describe the design and implementation of two main modules of this system, the understanding and editor modules. Key words...|$|R
5000|$|... #Subtitle level 2: <b>Programming</b> <b>code</b> {{formatting}} and beautification ...|$|R
40|$|WO 9957623 A UPAB: 20040629 NOVELTY - The <b>program</b> <b>code</b> {{interpreter}} {{reads the}} digital watermark and executes the <b>program</b> <b>code</b> {{included in the}} watermark obtained from digital watermark information. DETAILED DESCRIPTION - INDEPENDENT CLAIMS are also included for: (1) a method for reading digital watermark; and (2) a method of creating the digital watermark. USE - For digital watermark apparatus. ADVANTAGE - Preserves authentication, even if digital representation is output in analog form, thereby management of digital representation is very flexible. The <b>program</b> <b>code</b> can be written in any programming language...|$|R
40|$|Abstract—This paper {{describes}} {{the development of}} a numerical finite element algorithm used for the analysis of reinforced concrete structure equipped with shakes energy absorbing device subjected to earthquake excitation. For this purpose a finite element <b>program</b> <b>code</b> for analysis of reinforced concrete frame buildings is developed. The performance of developed <b>program</b> <b>code</b> is evaluated by analyzing of a reinforced concrete frame buildings model. The results are show that using damper device as seismic energy dissipation system effectively can reduce the structural response of framed structure during earthquake occurrence. Keywords—Viscous Damper, finite element, <b>program</b> <b>coding</b> I...|$|R
40|$|Abstract. Model-driven {{software}} development makes models and model transformations first-class citizens in {{software development}}. <b>Program</b> <b>code</b> and corresponding models evolve parallelly, thus round-trip engineering is highly required. <b>Program</b> <b>code</b> to model transformation {{plays a key}} role in program comprehension and examination as examining models is simpler than processing <b>program</b> <b>code.</b> In this paper, we introduce our solution to the reverse engineering case at GraBaTs’ 09 tool contest, in which filtering and transformation tasks have been proposed. The given solution utilizes model transformation described by graph transformation rules and a control flow language. ...|$|R
5000|$|On-screen editing of content, Web graphics, <b>program</b> <b>codes,</b> and simulations.|$|R
5000|$|Portability of {{components}} by moving <b>program</b> <b>code</b> {{with the data}} ...|$|R
40|$|A {{major issue}} facing the {{programming}} world {{today is the}} quick and efficient understanding of existing <b>program</b> <b>code</b> by programmers and software engineers. Visualization of concepts inherent in the <b>program</b> <b>code</b> is proposed as a new mechanism to facilitate program comprehension. The premise {{of this research is}} that program comprehension is primarily based on the reader's conceptual formation of <b>program</b> <b>code</b> fragments. This paper identifies two novel visualization models called the Program-Scientific and the Conceptual Crown Visualization models; and presents preliminary visualization studies based on understanding programs from data processing, parallel computing and high performance computing. applications...|$|R
50|$|<b>Program</b> <b>code</b> can {{be written}} in S-expressions, usually using prefix notation.|$|R
50|$|The <b>programming</b> <b>code</b> seen in {{the film}} is from Viralator 0.9.|$|R
5000|$|... #Caption: An {{example of}} MLX type-in <b>program</b> <b>code</b> from COMPUTE!s Gazette.|$|R
5000|$|Hypervisor, {{permitting}} {{complete control}} of the execution of <b>program</b> <b>code</b> including:- ...|$|R
5000|$|Program monitors, {{permitting}} full {{or partial}} monitoring of <b>program</b> <b>code</b> including: ...|$|R
50|$|A more {{innovative}} modern dongle is designed with a code porting process which transfers encrypted {{parts of the}} software vendor's <b>program</b> <b>code</b> or license enforcement into a secure hardware environment (such as in a smart card OS, mentioned above). An ISV can port thousands of lines of important computer <b>program</b> <b>code</b> into the dongle.|$|R
40|$|Readers are {{accustomed}} to annotating on paper documents while reading. To cater {{to the needs of}} readers, researchers have managed to reproduce this annotation ability for readers working with digital documents. However, most research has focused on textual documents rather than <b>program</b> <b>code</b> documents, and existing programming environments also do not support digital ink annotation. Therefore, this research focuses on the needs of annotating <b>program</b> <b>code</b> directly inside an Integrated Development Environment (IDE). An IDE is a good platform for reviewing, editing, and running <b>program</b> <b>code.</b> To provide IDE with the annotation functionality, this research designed and developed a tool, CodeAnnotator, which integrates digital ink annotation support inside an IDE. This tool supports direct annotation of <b>program</b> <b>code</b> with digital ink in the IDE. CodeAnnotator enables users to make free-form annotations on <b>program</b> <b>code</b> documents without restriction of location and content, and easily modify existing annotations. This tool also supports grouping ink strokes and anchoring each annotation to a specific piece of code, thus maintaining consistency between grouped annotations and their associated code when the underlying code changes. Furthermore, this tool enables users to recognize handwritten comments, and provides a navigation system t...|$|R
40|$|In smart {{wireless}} {{software defined}} networks (WSDNs), sensor nodes are {{deployed in the}} monitored area to sense data. In order to increase the flexibility of WSDNs configuration, sensor nodes use programmable technology. Thus, programming and software engineering that integrate Internet of Things (IoT) lead to a smart world. Due to the large capacity of <b>program</b> <b>codes</b> and the limited energy of wireless network, only a subset of nodes is selected to spread <b>program</b> <b>codes,</b> and the remaining nodes are in sleep status to save energy. In this paper, a fast <b>program</b> <b>codes</b> dissemination (FPCD) scheme for smart wireless software defined networking is proposed; many nodes in the area far from the sink will be selected to spread program codes; those areas have much energy left, while the area near the sink chooses less number of active nodes to spread <b>program</b> <b>codes</b> to save energy. Thus, FPCD scheme can reduce delay for spreading <b>program</b> <b>codes</b> while retaining network lifetime. The theoretical analysis and experimental results show that our approach can reduce transmission delay by 10. 76 %– 105. 791 % while retaining network lifetime compares with previous broadcast schemes...|$|R
2500|$|... a large open-access {{database}} of <b>program</b> <b>codes</b> of published computational neuroscience models.|$|R
30|$|The {{derivatives}} {{are calculated}} with Maple and the <b>program</b> <b>codes</b> are available.|$|R
40|$|In this paper, {{it will be}} {{explained}} about an application which able to analyze the quality of java <b>program</b> <b>code</b> in implementing Java Database Connectivity (JDBC). The analysis {{will be based on}} existing best practice in implement JDBC. To analyze JDBC, bugs patterns are needed to be compared with existing best practice. Various methods are available to be used in constructing this kind of application, but in this paper, static analysis non-linear method is used in designing this application. Static analysis <b>means</b> the java <b>program</b> <b>code</b> will be read and analyzed without executing. Non-linear <b>means</b> the java <b>program</b> <b>code</b> will not read sequentially, but it will follow the flow of the <b>program</b> <b>code</b> itself. And this application will be called Bedhigasan, which able to detect bugs pattern in implementing JDBC and it will report those bugs to the web page including with location of the bugs...|$|R
50|$|The <b>programming</b> <b>code</b> {{required}} to interface EEPROM to the DataFlash chip is simpler.|$|R
5000|$|... #Caption: An {{example of}} MLX type-in <b>program</b> <b>code</b> as printed in Compute!'s Gazette.|$|R
5000|$|How many {{lines of}} <b>program</b> <b>code</b> {{will it take}} to perform this function? ...|$|R
5000|$|Through five <b>programs,</b> <b>Code</b> for America helps {{government}} work {{more like the}} Internet.|$|R
40|$|Secure <b>program</b> <b>coding</b> {{refers to}} how manage the risks {{determined}} by the security breaches because of the <b>program</b> source <b>code.</b> The papers reviews the best practices must be doing during the software development life cycle for secure software assurance, the methods and techniques used for a secure coding assurance, the most known and common vulnerabilities determined by a bad coding process and how the security risks are managed and mitigated. As a tool of the better secure <b>program</b> <b>coding,</b> the code review process is presented, together with objective measures for code review assurance and estimation of the effort for the code improvement...|$|R
40|$|Contents 1 Introduction 5 2 Theoretical Background 11 2. 1 Basic Results....................... 11 2. 2 A Linear Space MOC Algorithm............ 14 2. 3 Computing All Longest Chains............. 17 3 Rick's Algorithm 25 4 The New Decomposition Method 35 4. 1 Dualization of Rick's Method.............. 35..................... 45 4. 3 <b>Program</b> <b>Code......................</b> 47 5 Linear Space LCS Construction 53 5. 1 Locating Two Centered Matches............ 53 5. 2 <b>Program</b> <b>Code......................</b> 57 6 The AMOC Problem 69 6. 1 Generating the AMOC [...] Graph............. 70 6. 2 Border LCS........................ 73 6. 3 <b>Program</b> <b>Code......................</b> 85 6. 4 Complexity Analysis................... 94 4 CONTENTS 7 Experimental Results 97 Bibliography 105 Introduction This work is c...|$|R
30|$|Programmer, agent {{designing}} the algorithm or <b>program</b> <b>code</b> {{that is the}} target of visualization.|$|R
5000|$|Tools for {{configuring}} or {{extending the}} application (e.g. an SDK), access to <b>program</b> <b>code.</b>|$|R
