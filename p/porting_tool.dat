4|84|Public
50|$|Cet {{acquired}} the Phase one company. Also, Phase One Systems licenses a <b>porting</b> <b>tool</b> called CET Basic. CET Basic {{is compatible with}} THEOS BASIC, MultiUser BASIC, OASIS BASIC, and UX-BASIC. This means you can keep most of your existing source code, and using W/32 BASIC, recompile your THEOS, OASIS, or UX-BASIC programs to work under additional operating systems such as Microsoft Windows, Linux or SCO UNIX.|$|E
50|$|Deterministic Parallel Java (DPJ) is an {{extension}} of the Java programming language which adds parallel constructs that provide a deterministic programming model for object-oriented languages. The language extensions define a type system that a programmer (or interactive <b>porting</b> <b>tool)</b> can use to annotate Java code with type information, and a compiler can use to type-check that a DPJ program has deterministic semantics, i.e., produces the same visible output for a given input, in all executions. Parallel algorithms that cannot be expressed entirely in the statically checked type system require run-time mechanisms to enforce determinism: two key research goals are to make the type system more expressive and to minimize the need to fall back to run-time techniques. With minor modifications, language extensions should be applicable to other base OO languages, such as C++ and C#.|$|E
40|$|This paper {{describes}} {{the design and}} implementation of a conversion tool. This tool, called Distributed Computing Environment (DCE) <b>Porting</b> <b>Tool,</b> converts an Open Network Computing (ONC) Remote Procedure Call (RPC) application to a DCE RPC application. The manual intervention needed during the conversion process in minimal. The paper briefly describes RPC programming and highlights the difference between ONC RPC and DCE RPC. The design decisions of the <b>Porting</b> <b>Tool</b> is explained. The implementation uses LEX and YACC (language processing tools supported by Unix) for conversion logic and OSF/MOTIF for Graphical User Interface (GUI). The paper concludes with current limitations of the Tool and the possible future work. Keywords: Remote Procedure Call (RPC), Distributed Computing Environment (DCE), Open Network Computing (ONC), Interface Definition Language (IDL), <b>Porting</b> <b>Tool.</b> 1 Introduction In simple terms, Distributed Processing means that, the (individual) components of an application [...] ...|$|E
50|$|As well as <b>porting</b> <b>tools,</b> Phase One Systems {{distributed}} the Freedom query package and Control database package for THEOS systems, {{used to bring}} SQL-like data extraction tools to third-party software packages.|$|R
5000|$|Currently Unity Linux is in it's {{very early}} stages. We have <b>ported</b> <b>tools</b> {{that we used}} in the past (on Unity Linux itself and past projects) to Mageia. At this point we do offer {{development}} ISOs that can be ran [...] "live", but that are still very experimental.|$|R
5000|$|Starting in 1992, Apple {{had also}} been {{involved}} {{in an effort to}} replace MacApp development framework with a cross-platform solution known as Bedrock, from Symantec. Symantec's Think C was rapidly becoming the tool of choice for development on the Mac. Apple had been working with them to <b>port</b> their <b>tools</b> to the PowerPC when they learned of Symantec's internal <b>porting</b> <b>tools.</b> Apple proposed merging existing MacApp concepts and code with Symantec's to produce an advanced cross-platform system. Bedrock began to compete with OpenDoc as [...] "the" [...] solution for future development.|$|R
40|$|Raspberry Pi is a {{powerful}} and affordable small computer. It was produced with an aim in education to help young adult learn about computer and programming language. Hence, it consists of high functional features and is sold at low cost for easy access to everybody. Moreover, there are many supports available for Raspberry Pi in both technical and commercial field making it appealing for running various kinds of application. In this thesis, Raspberry Pi computer is studied and evaluated for its features and capability using Matlab software as a code <b>porting</b> <b>tool</b> due to a free availability of the support package. The implementation is done with examples of signal and image processing based on problem from relevant courses in university level as well as real world applications from Simulink Computer Vision toolbox. The model is constructed using Simulink blocks and Matlab scripts. The input is provided in two ways; one as a parameter added through the software {{and the other is}} fed directly from a peripheral device. With an aim to provide the use of Raspberry Pi computer in practical courses, a limitation of model compilation time is taken into account for the evaluation. The results from examples show that time taken to generate the code is slower if the model comprises many Simulink blocks or contains Matlab scripts. The larger size and software input parameter also causes the delay compilation. However, these factors fall into an acceptable range. Hence, Raspberry Pi can be used with Matlab as a learning tool for hands-on experience for students. The possibility of the future work would include the use of graphic processor in Matlab and Simulink application. The research would involve determining Matlab code generation method used as a compiler for a graphic processor modified code...|$|E
50|$|Javaground was the {{provider}} of {{a suite of}} development and <b>porting</b> <b>tools</b> for the mobile games industry called the Xpress Suite. The company was also a developer of mobile games. Javaground's Xpress Suite was noted for its set of automated converters, which were used to create games {{for a range of}} platforms including the iPhone, Windows Mobile, Android, BREW, and Flash, from a single set of Java ME source code.|$|R
40|$|There {{are three}} steps in porting SIMR to new {{language}} pairs. The {{first step is}} to choose an appropriate matching predicate, and collect any linguistic resources required by that matching predicate. The second step is to implement bitext space axis generation routines that are consistent with the matching predicate. The last step is to re-optimize SIMR 2 ̆ 7 s numerical parameters. This document explains each step in detail. It assumes that you have read and understood the paper [1]. It also assumes that you have SIMR and the <b>porting</b> <b>tools</b> properly installed...|$|R
5000|$|Single file installation. There {{is also an}} {{actively}} maintained FreeBSD <b>port</b> of this <b>tool.</b>|$|R
5000|$|These {{issue are}} mitigated, {{to a large}} extent, if TCPMUX is used on a secure local network; and the [...] "HELP" [...] command might also (could also) return an empty list, {{making it harder for}} attackers {{to use it as a}} <b>port</b> {{scanning}} <b>tool</b> even if the network is not secured.|$|R
40|$|Developing and {{maintaining}} CLP programs requires visualization and explanation tools. However, existing tools are built {{in an ad}} hoc way. Therefore <b>porting</b> <b>tools</b> from one platform to another is very difficult. We have shown in previous work that, from a fine-grained execution trace, a number of interesting views about logic program executions could be generated by trace analysis. In this article, we propose a trace model for constraint solving by narrowing. This trace model {{is the first one}} proposed for clp(fd) and does not pretend to be the ultimate one. We also propose an instrumented meta-interpreter in order to experiment with the model. Furthermore, we show that the proposed trace model contains the necessary information to build known and useful execution views. This work sets the basis for generic execution analysis of clp(fd) programs. [23] is a comprehensive version of this paper. ...|$|R
40|$|This paper {{details the}} {{optimization}} of bulk material port handling systems {{through the use}} of an evolutionary based approach. The effective management of port systems requires effective solutions for the design, operation and maintenance of these facilities. This has to be achieved through a reduction in financial costs, and an increase in the utilization of equipment and other resources. The operation of a port system is complex and difficult to model mathematically. Consequently, through the explicit characterization of port components, a <b>port</b> modeling <b>tool</b> was developed that permits the generic construction of port simulation models. A genetic algorithm based approach was developed to provide an optimization capability to the <b>port</b> simulation <b>tool.</b> Two case studies based on real world port systems are presented and the results are discussed. A significant improvement is demonstrated in both the operational and economic performance {{as a result of the}} GA/model interaction...|$|R
40|$|The on-line {{monitoring}} {{interface specification}} OMIS provides means for developing more powerful interoperable and portable tool environments for parallel and distributed systems. It specifies {{the interaction between}} any tool and a monitoring system {{that is responsible for}} observing and manipulating the programs' execution. By having this well defined interface it is now possible to concurrently use several tools of possibly different developers with the same program run and to <b>port</b> <b>tools</b> onto various target architectures and software environments. As a starting point the research group at LRR-TUM is designing an OMIS compliant monitoring system (OCM) for PVM running on workstation clusters. Tool developers can use this implementation to attach their own on-line tools to the system. Key words. Monitoring, on-line tools, distributed systems AMS subject classifications. 68 N 25, 68 M 10 1. Motivation. The available support for parallel programming in environments with distributed memory [...] ...|$|R
40|$|The {{increasing}} {{complexity of}} software systems and {{growing demand for}} regulations compliance require effective methods and tools to support requirements analysts activities. Internationalization of information systems due to both economics and Web based architectures call {{for the application of}} regulations written in different languages. Thus far existing approaches for extracting rights and obligations have concentrated on English documents. In this paper, we describe the results of the application of Cerno, a lightweight framework for semantic annotation, to legal documents written in Italian. In addition, we investigate critical issues for semantic annotation tools in a different cultural and environmental context. Results obtained, while preliminary, allow us to quantify the effort needed to <b>port</b> <b>tools</b> based on Cerno and give some insight on directions of future development of a multilingual system to support semantic annotation of regulations not only in different domains, but also written in different languages...|$|R
40|$|A system’s {{architecture}} {{influence on}} the functions and other properties of embedded systems makes its high level analysis and verification very desirable. EAST-ADL is an architecture description language dedicated to automotive embedded system design with focus on structural and functional modeling. The behavioral description is not integrated within the execution semantics, which {{makes it harder to}} transform, analyze, and verify EAST-ADL models. Model-based techniques help address this issue by enabling automated transformation between different design models, and providing means for simulation and verification. We present a verification tool, called ViTAL, which provides the possibility to express the functional EAST-ADL behavior as timed automata models, which have precise semantics and can be formally verified. The ViTAL tool enables the transformation of EAST-ADL functional models to the UPPAAL <b>PORT</b> <b>tool</b> for model checking. This method improves the verification of functional and timing requirements in EAST-ADL, and makes it possible to identify dependencies and potential conflicts between different vehicle functions before the actual AUTOSAR implementation. ATAC, MBA...|$|R
40|$|There {{are three}} steps in porting SIMR to new {{language}} pairs. The {{first step is}} to choose an appropriate matching predicate, and collect any linguistic resources required by that matching predicate. The second step is to implement bitext space axis generation routines that are consistent with the matching predicate. The last step is to re-optimize SIMR's numerical parameters. This document explains each step in detail. It assumes that you have read and understood the paper [1]. It also assumes that you have SIMR and the <b>porting</b> <b>tools</b> properly installed. 1 Matching Predicate SIMR's matching predicates can be based on any combination of predicate filters and oracle filters [3]. Your choice of matching predicate will depend on the languages that you are dealing with and the linguistic resources that you have at your disposal. If you are dealing with languages that share many cognates, or even phonetic cognates, then your matching predicate should test for cognateness. Cognate predicates u [...] ...|$|R
3000|$|... 1) “Before the event” – {{cyberattack}} preparation phase. To {{explore the}} location of cyberattack target, the cyberattack platform uses the IP and <b>port</b> scanning <b>tool</b> to gather the network information related to the power plant simulation platform. The messages intercepted by the early warning model are shown in Appendix A Table A 1. Since a substantial cyberattack did not form at this stage, the early warning model did not generate any alarm.|$|R
40|$|A web {{definition}} of management states {{it is the}} effective utilization and coordination of resources such as capital, plant, materials, and labour to achieve defined objectives with maximum efficiency. Like every facet of business enterprises, the port is not left behind in finding out {{the most efficient way}} to carry out its task through the use and coordination of resources. We can define port management as a process in which all port resources superstructure and infrastructure are well managed in order to arrive at set objective. He also adds that it is aimed at improving quality of services lowering costs and eliminating waste. Whether or not the model operated in any <b>port</b> is <b>tool</b> <b>port</b> or landlord port, the overall objective of any port is to be efficient and to render quality service to port users. Large ports need to deal with a number of diverse activities: the movement of ships, containers and other cargo, the loading and unloading of ships an...|$|R
30|$|In {{the local}} CPPS model, the {{cyberattack}} platform {{is used to}} simulate cyberattacks, and the early warning model is used to detect CFCA. Many cyberattack software programs are integrated into the cyberattack platform, such as the IP and <b>port</b> scan <b>tool,</b> remote malicious attack control tools, etc. The cyberattack platform launches cyberattacks for both the station layer nodes and network to induce CFCA. To facilitate real-time capture of all network messages, the network message capture tool is integrated into the early warning model.|$|R
5000|$|The {{area was}} first settled about 1829 by an {{unidentified}} disbanded military unit. At first settlers {{had to walk}} 20 mi to Kilworth to reach a grist mill, 30 mi to London to a market and miles to <b>Port</b> Stanley for <b>tools</b> and implements.|$|R
40|$|Abstract—In {{the recent}} years, virtual machine introspection (VMI) {{has become a}} {{valuable}} technique for developing security applications for virtualized environments. With the increasing popularity of the ARM architecture, and the recent addition of hardware virtualization extensions, {{there is a growing}} need for <b>porting</b> existing VMI <b>tools.</b> <b>Porting</b> these applications requires proper hypervisor support, which we have been implementing for the upcoming release of the Xen hypervisor. I. VMI Virtual Machine Introspection (VMI) has been proven in the x 86 world to be a viable method to create out-of-band security software. VMI relies on reconstructing high-level state infor-mation from low-level data. This data is provided by inspecting the virtual hardware components of virtual machines, such as the memory and the vCPU registers; commonly referred t...|$|R
40|$|Neglecting {{network port}} scans {{could result in}} {{unavoidable}} consequences. Network attackers continuously monitor and check communication ports looking for any open port. To protect computers and networks, computers need to be safeguarded against applications that aren't required by any function currently in use. To accomplish this, the available ports and the applications utilizing them should be determined. This paper attempts to evaluate eight <b>port</b> scanning <b>tools</b> based on fifteen criterions. The criteria were reached after fully testing each tool. The outcomes of the evaluation process are discussed...|$|R
40|$|Real software, {{the kind}} working programmers produce by the kLOC to solve {{real-world}} problems, {{tends to be}} "natural", like speech or natural language; {{it tends to be}} highly repetitive and predictable. Researchers have captured this naturalness of software through statistical models and used them to good effect in suggestion engines, <b>porting</b> <b>tools,</b> coding standards checkers, and idiom miners. This suggests that code that appears improbable, or surprising, to a good statistical language model is "unnatural" in some sense, and thus possibly suspicious. In this paper, we investigate this hypothesis. We consider a large corpus of bug fix commits (ca. ~ 8, 296), from 10 different Java projects, and we focus on its language statistics, evaluating the naturalness of buggy code and the corresponding fixes. We find that code with bugs tends to be more entropic (i. e., unnatural), becoming less so as bugs are fixed. Focusing on highly entropic lines is similar in cost-effectiveness to some well-known static bug finders (PMD, FindBugs) and ordering warnings from these bug finders using an entropy measure improves the cost-effectiveness of inspecting code implicated in warnings. This suggests that entropy may be a valid language-independent and simple way to complement the effectiveness of PMD or FindBugs, and that search-based bug-fixing methods may benefit from using entropy both for fault-localization and searching for fixes. Comment: 12 page...|$|R
40|$|We {{present a}} tool that helps C/C++ {{developers}} to estimate the effort and automate software <b>porting.</b> Our <b>tool</b> supports project leaders in planning a porting project by showing where a project must be changed, how many changes are needed, what kinds of changes are needed, and how these interact with the code. For developers, we {{provide an overview of}} where a given file must be changed, the structure of that file, and close interaction with typical code editors. To this end, we integrate code querying, program transformation, and software visualization techniques. We illustrate our solution with use-cases on real-world code bases. ...|$|R
40|$|This thesis {{deals with}} portation of the OptaPlanner tool to the Android {{operating}} system. The OptaPlanner {{is used for}} solving planning problems and it is completely written in the Java programming language which is also used for application development of the Android operating system. However, Android does not contain all of the Java Standard Edition Application Programming Interface libraries and porting of OptaPlanner to Android thus causes dependency problems. The result of the thesis is solution design {{and implementation of the}} problems mentioned above and model Android Vehicle Routing Problem application which uses <b>ported</b> OptaPlanner <b>tool...</b>|$|R
50|$|However, the COFF {{design was}} both too limited and incompletely specified: {{there was a}} limit on {{the maximum number of}} sections, a limit on the length of section names, {{included}} source files, and the symbolic debugging information was incapable of supporting real world languages such as C, much less newer languages like C++, or new processors. All real world implementations of COFF were necessarily violations of the standard as a result. This led to numerous COFF extensions. IBM used the XCOFF format in AIX; DEC, SGI and others used ECOFF; and numerous SysV <b>ports</b> and <b>tool</b> chains targeting embedded development each created their own, incompatible, variations.|$|R
40|$|Inexpensive self-expanding plug makes {{convenient}} low-pressure seal. Simple elastomeric plug seals round {{ports and}} holes better than regular cork. Plug is inserted with plastic tool that squeezes it to diameter smaller than <b>port</b> opening. Once <b>tool</b> is removed, plug self-expands {{to its original}} shape, exerting stronger pressure to sealed surface than cork. Plug is less expensive to make than screw-on or cam-expanded seals...|$|R
40|$|Wux is a <b>port</b> of Unix <b>tools</b> to the Microsoft Windows environment. It {{is based}} on a library {{providing}} a Unix-compatible set of system calls on top of Windows. Unix-derived tools run in parallel, communicating using the Unix pipe abstraction. All processes are run within an application template that gives them basic Windows compatibility such as input and output windows and an icon. The performance of the system is comparable to that of Unix ports to the PC architecture. 1 Motivation The Unix operating system offers a wide variety of tools that can be used as building blocks or autonomous units for application development. Although these and similar <b>tools</b> can be <b>ported</b> to other environments [KP 76, Gor 93], their usability is often impaired by the lack of the glue elements available under Unix: multitasking and interprocess communication using pipes. Specifically, <b>tool</b> <b>ports</b> to the widely used MS-DOS system have to rely on serialised process execution and pipes implemented using ineffici [...] ...|$|R
40|$|Distributed Array Query and Visualization (DAQV) is a Parallel Tools Consortium {{sponsored}} {{project to}} create a tool for visualizing distributed data in High Performance Fortran (HPF). The DAQV tool is currently maintained at the University of Oregon, and our goals here at the Cornell Theory Center (CTC) are to verify the work done by the people there, and <b>port</b> the DAQV <b>tool</b> and its associated visualization clients to our IBM SP 2 and IBM's HPF compiler, XL HPF. We describe in this paper {{the installation of the}} DAQV tool first on an SGI Onyx, using Portland Group Inc. 's HPF compiler, pghpf, which was already supported by DAQV. We make various modifications to the distribution to generalize the installation, and then <b>port</b> the DAQV <b>tool</b> to the IBM SP 2, also using the pghpf compiler. Finally, we accomplish the port of DAQV to IBM's XL HPF compiler. We describe our approaches to overcoming various obstacles encountered in the porting process. These include re-analyzing the DAQV desi [...] ...|$|R
40|$|This paper {{presents}} high-level {{details of}} two contributions to iperf, a modern tool for testing network performance. The first contribution is a <b>port</b> of the <b>tool</b> to the Windows Mobile operating system, {{while the second}} one is {{the extension of the}} tool to support BlueTooth communication. The paper also includes results of experiments carried out by the modified tool in various configurations of real networks created by laptops and mobile phones. ...|$|R
30|$|In {{the same}} way, former Soviet bloc {{countries}} choose {{to open their}} economy to capitalism through the implementation of free zones along the Adriatic, the Black and the Baltic Seas (see Fig.  1). Iran is also currently following a similar strategy {{as a way to}} mitigate economic sanctions imposed in particular by the European Union and the United States. In this context, free <b>ports</b> are <b>tools</b> not only to influence freight flows, but to reform an economy in a controlled fashion (Bost, 2010). In some cases, the free port can become the main driver of national economic development, as the case of Dubai illustrates by combining port, airport and real estate development and creating a free port in a relatively closed regional context.|$|R
40|$|University ofPennsylvania There {{are three}} steps in porting SIMR to new {{language}} pairs. The rst {{step is to}} choose an appropriate matching predicate, and collect any linguistic resources required by thatmatching predicate. The second step is to implement bitext space axis generation routines {{that are consistent with}} the matching predicate. The last step is to re-optimize SIMR's numerical parameters. This document explains each step in detail. It assumes that you have read and understood the paper [1]. It also assumes that you have SIMR and the <b>porting</b> <b>tools</b> properly installed. 1 Matching Predicate SIMR's matching predicates can be based on any combination of predicate lters and oracle lters [3]. Your choice of matching predicate will depend on the languages that you are dealing with and the linguistic resources that you have atyour disposal. If you are dealing with languages that share many cognates, or even phonetic cognates, then your matching predicate should test for cognateness. Cognate predicates using seem to work best with the LCSR metric [3]. If you have access to part-of-speech (POS) taggers for both languages, then your predicate should test for matching POS. If you have access to a pre-existing translation lexicon between your two languages, even a small and noisy one, then by all means use it. The nlplib. pl library that comes with your SIMR distribution includes matching predicates that represent all possible combinations of POS, cognate and translation lexicon lters. However, other matching predicates are certainly possible, and you are encouraged to experiment. Your matching predicate should be a Perl 5 subroutine, which takes two axis co-ordinates as arguments. The routine must look up the tokens in these co-ordinates in the appropriate global array (refer to one of the existing matching predicates for a template). It must return 1 if the two tokens are deemed likely mutual translations, and 0 otherwise. ...|$|R
40|$|Port scans are {{typically}} {{at the begin}} of {{a chain of events}} that will lead to the attack and exploitation of a host over a network. Since building an effective defense relies on information what kind of threat an organization is facing, threat intelligence outlining an actor’s modus operandi is a critical ingredient for network security. In this paper, we describe characteristic patterns in port scan packets {{that can be used to}} identify the tool chain used by an adversary. In an empirical analysis of scan traffic received by two / 16 networks, we find that common open source <b>port</b> scan <b>tools</b> are adopted differently by communities across the globe, and that groups specializing to use a particular tool have also specialized to exploit particular services. Accepted Author ManuscriptCyber Securit...|$|R
40|$|The Caribbean {{region is}} a cross road of {{international}} and regional container traffic. Most {{of the islands}} {{in the region have}} also adopted ambitious strategies to become prime locations for container transshipment. This paper introduces a tool {{that can be used to}} visualise and analyse the Caribbean container flows. The tool is constructed on the basis of a multi-layered graph structure and is highly parameterized to allow for flexible selection of flows and <b>ports.</b> The <b>tool</b> supports the assessment of the potential for the development of logistics and transport hub through the calculation of relevant indicators using available information on container flows in the region. Much of the empirical work centers on the estimation of the origin-destination matrix of container flows in the region. The paper presents a case study for the island of Curacao...|$|R
40|$|Wux is a <b>port</b> of Unix <b>tools</b> to the Microsoft Windows environment. It {{is based}} on a library {{providing}} a Unixcompatible set of system calls on top of Windows. Unix-derived tools run in parallel, communicating using the Unix pipe abstraction. All processes are run within an application template that gives them basic Windows compatibility such as input and output windows and an icon. The performance of the system is comparable to that of Unix ports to the PC architecture...|$|R
