6|8|Public
25|$|The AGC {{also had}} a {{sophisticated}} software interpreter, developed by the MIT Instrumentation Laboratory, that implemented a virtual machine with more complex and capable pseudo-instructions than the native AGC. These instructions simplified the navigational programs. Interpreted code, which featured double precision trigonometric, scalar and vector arithmetic (16 and 24-bit), even an MXV (matrix × vector) instruction, could be mixed with native AGC code. While the execution time of the pseudo-instructions was increased (due {{to the need to}} interpret these instructions at runtime) the interpreter provided many more instructions than AGC natively supported and the memory requirements were much lower than in the case of adding these instructions to the AGC native language which would require additional memory built into the computer (at that time the memory capacity was very expensive). The average <b>pseudo-instruction</b> required about 24 ms to execute. The assembler and version control system, named YUL for an early prototype Christmas Computer, enforced proper transitions between native and interpreted code.|$|E
5000|$|Perhaps {{the most}} common type of literal pool are the literal pools used by the [...] <b>pseudo-instruction</b> in ARM {{assembly}} languageand similar instructions in IBM System/360 assembly language.which are compiled to a LOAD with a PC-relative addressing mode and the constant stored in the literal pool.|$|E
50|$|One of {{the most}} {{interesting}} features in MAD is the ability to extend the language by redefining existing operators, defining new operators, or defining new data types (modes). The definitions are made using MAD declaration statements and assembly language mnemonics included following the declaration up to the END <b>pseudo-instruction</b> that implement the operation.|$|E
5000|$|But {{he admits}} {{the model is}} easier if he adds some <b>pseudo-instructions</b> O- [...] (combined 0 [...] and - [...] ) and [...] "go(n)". He builds [...] "go(n)" [...] out of the {{register}} w pre-set to 0, so that O- (w, (n)) is an unconditional jump.|$|R
25|$|A program {{written in}} {{assembly}} language {{consists of a}} series of mnemonic processor instructions and meta-statements (known variously as directives, <b>pseudo-instructions</b> and pseudo-ops), comments and data. Assembly language instructions usually consist of an opcode mnemonic followed by a list of data, arguments or parameters. These are translated by an assembler into machine language instructions that can be loaded into memory and executed.|$|R
40|$|Non-interference is a {{desirable}} property of systems in a multilevel security architecture, stating that confidential {{information is not}} disclosed in public output. The challenge of studying information flow for assembly languages is that the control flow constructs that guide the analysis in high-level languages are not present. To address this problem, we define a typed assembly language that uses <b>pseudo-instructions</b> to impose a stack discipline on the control flow of programs. We develop a type system for checking that assembly programs enjoy non-interference and its proof of soundness. ...|$|R
5000|$|The AGC {{also had}} a {{sophisticated}} software interpreter, developed by the MIT Instrumentation Laboratory, that implemented a virtual machine with more complex and capable pseudo-instructions than the native AGC. These instructions simplified the navigational programs. Interpreted code, which featured double precision trigonometric, scalar and vector arithmetic (16 and 24-bit), even an [...] (matrix × vector) instruction, could be mixed with native AGC code. While the execution time of the pseudo-instructions was increased (due {{to the need to}} interpret these instructions at runtime) the interpreter provided many more instructions than AGC natively supported and the memory requirements were much lower than in the case of adding these instructions to the AGC native language which would require additional memory built into the computer (at that time the memory capacity was very expensive). The average <b>pseudo-instruction</b> required about 24 ms to execute. The assembler and version control system, named YUL for an early prototype Christmas Computer, enforced proper transitions between native and interpreted code.|$|E
40|$|An {{approximate}} {{internal blocking}} probability calculation program is described, {{which has been}} ~evised to reduce the procedure for practical applications and can generally be applied to an arbitrary complicated case without programming for the computation of individually derived formula. The calculation is performed by giving only a series of pseudo-instructions. The principle of the method and the functions of each <b>pseudo-instruction</b> are described in detail. Examples are shown to characterize this program, utilized for the traffic design of electronic switc hing systems development. 1. I NTRODUCTIO...|$|E
40|$|In {{this talk}} I present N-gram GP, {{a system for}} {{evolving}} linear GP programs using an EDA style system to update the probabilities of different 3 -grams (triplets) of instructions. I then pick apart some of the evolved programs {{in an effort to}} better understand the properties of this approach and identify ways that it might be extended. Doing so reveals that there are frequently cases where the system needs two triples of the form ABC and ABD to solve the problem, but can only choose between them probabilistically in the EDA phase. I present the entirely untested idea of creating a new <b>pseudo-instruction</b> that is a duplicate of a key instruction. This could potentially allow the system to learn, for example, that AB is always followed by C, while AB 2 ̆ 7 is always followed by D...|$|E
5000|$|IEFBR14 {{consisted}} initially of {{a single}} instruction a [...] "Branch to Register" [...] 14. The mnemonic used in the IBM Assembler was BR and hence the name: IEF BR 14. BR 14 is identically equivalent to BCR 15,14 (Branch Always mask = 15 = always [...] to the address contained in general purpose register 14). BR is a pseudo instruction for BCR 15. The system assembler accepts many cases of such <b>pseudo-instructions,</b> as logical equivalents to the canonical System/360 instructions. The canonical instance of BR 14 is BCR 15,14.|$|R
40|$|Abstract — This paper {{describes}} the mapping of a recently introduced template matching algorithm {{based on the}} Normalized Cross Correlation (NCC) on a general purpose processor endowed with SIMD (Single Instruction Multiple Data) multimedia instructions. The algorithm relies on the Bounded Partial Correlation (BPC) technique, which consists in deploying a sufficient condition to detect unsatisfactory matching candidates at a reduced computational cost. First, we briefly describe the BPC technique and highlight the related expensive computations. Then, based on {{the analysis of the}} major SIMD multimedia instruction set extensions available nowadays, we define a processor-independent multimedia instruction set and show how to carry out the most expensive BPC calculations using these <b>pseudo-instructions.</b> Finally, we provide experimental results obtained mapping the proposed algorithm on a mainstrea...|$|R

