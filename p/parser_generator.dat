305|185|Public
25|$|The {{original}} dissertation gave no algorithm {{for constructing}} such a parser given some formal grammar. The first algorithms for LALR parser generation {{were published in}} 1973. In 1982, DeRemer and Tom Pennello published an algorithm that generated highly memory-efficient LALR parsers. LALR parsers can be automatically generated from some grammar by an LALR <b>parser</b> <b>generator</b> such as Yacc or GNU Bison. The automatically generated code may be augmented by hand-written code to augment {{the power of the}} resulting parser.|$|E
2500|$|JavaScript based {{implementation}} of a LALR(1) <b>parser</b> <b>generator,</b> which can be run in a web-browser or from the command-line.|$|E
2500|$|... is a Prolog {{interpreter}} {{written in}} (managed) C#. Can easily be integrated in C# programs. Characteristics: reliable and fairly fast interpreter, command line interface, Windows-interface, builtin DCG, XML-predicates, SQL-predicates, extendible. The complete source code is available, including a <b>parser</b> <b>generator</b> {{that can be}} used for adding special purpose extensions.|$|E
5000|$|Comparison of <b>parser</b> <b>generators</b> {{for a more}} {{complete}} list, which also includes LL, SLR, GLR and LR <b>parser</b> <b>generators.</b>|$|R
50|$|Specifications for <b>parser</b> <b>generators</b> in the Yacc {{family can}} be broadly {{considered}} S-attributed grammars. However, these <b>parser</b> <b>generators</b> usually include {{the capacity to}} reference global variables and/or fields from within any given grammar rule, meaning {{that this is not}} a pure S-attributed approach.|$|R
5000|$|DMS Software Reengineering Toolkit, {{a program}} {{transformation}} system with <b>parser</b> <b>generators.</b>|$|R
2500|$|An LR(1) parser {{will create}} two {{different}} states (with non-conflicting lookaheads), {{neither of which}} is ambiguous. In an LALR parser this one state has conflicting actions (given lookahead c or d, reduce to E or F), a [...] "reduce/reduce conflict"; the above grammar will be declared ambiguous by a LALR <b>parser</b> <b>generator</b> and conflicts will be reported.|$|E
5000|$|SableCC - <b>parser</b> <b>generator</b> {{that generates}} strictly-typed {{abstract}} syntax trees.|$|E
5000|$|PQCC, a {{compiler-compiler}} that is {{more than}} a <b>parser</b> <b>generator.</b>|$|E
5000|$|Comparison of <b>parser</b> <b>generators</b> {{for a list}} of LL(k) and LL(*) parsers ...|$|R
50|$|This {{is a list}} of notable lexer <b>generators</b> and <b>parser</b> <b>generators</b> {{for various}} {{language}} classes.|$|R
50|$|This {{section of}} the article can be skipped by most users of LR <b>parser</b> <b>generators.</b>|$|R
5000|$|JavaCC, GWT {{compatible}} <b>parser</b> <b>generator,</b> implement client-side (JavaScript-based) parsers in Java.|$|E
5000|$|GNU Bison, a <b>parser</b> <b>generator</b> {{that can}} create LALR and GLR parsers ...|$|E
5000|$|GNU Bison: a <b>parser</b> <b>generator,</b> {{often used}} with the Flex lexical {{analyser}} ...|$|E
5000|$|However, a {{new type}} of LR(1) parser, some people call a [...] "minimal LR(1) parser" [...] was {{introduced}} in 1977 by David Pager [...] who showed that LR(1) parsers can be created whose memory requirements rival those of LALR(1) parsers. Recently, some <b>parser</b> <b>generators</b> are offering minimal LR(1) parsers, which not only solvethe memory requirement problem, but also the mysterious-conflict-problem inherent in LALR(1) <b>parser</b> <b>generators.</b>|$|R
50|$|LALR parsers {{have the}} same states as SLR parsers, but use a more complicated, more precise way of working out the minimum {{necessary}} reduction lookaheads for each individual state. Depending {{on the details of}} the grammar, this {{may turn out to be}} the same as the Follow set computed by SLR <b>parser</b> <b>generators,</b> or it may turn out to be a subset of the SLR lookaheads. Some grammars are okay for LALR <b>parser</b> <b>generators</b> but not for SLR <b>parser</b> <b>generators.</b> This happens when the grammar has spurious shift/reduce or reduce/reduce conflicts using Follow sets, but no conflicts when using the exact sets computed by the LALR generator. The grammar is then called LALR(1) but not SLR.|$|R
50|$|Some of {{the well}} known parser {{development}} tools include the following. Also see comparison of <b>parser</b> <b>generators.</b>|$|R
5000|$|JavaCC, Java Compiler Compiler tm (JavaCC tm) - The Java <b>Parser</b> <b>Generator.</b>|$|E
5000|$|PackCC is a <b>parser</b> <b>generator</b> for C. Its main {{features}} are as follows: ...|$|E
5000|$|ANTLR - <b>parser</b> <b>generator</b> {{that offers}} a {{different}} approach to tree processing: tree grammars.|$|E
50|$|Other {{examples}} of <b>parser</b> <b>generators</b> in the yacc vein are ANTLR, Coco/R, CUP, GNU bison, Eli, FSL, SableCC, SID (Syntax Improving Device) and JavaCC. While useful, pure <b>parser</b> <b>generators</b> only address the parsing {{part of the}} problem of building a compiler. Tools with broader scope, such as PQCC, Coco/R and DMS Software Reengineering Toolkit provide considerable support for more difficult post-parsing activities such as semantic analysis, code optimization and generation.|$|R
5000|$|... {{parboiled}} {{is commonly}} used as an alternative for regular expressions or <b>parser</b> <b>generators</b> (like ANTLR or JavaCC), especially for smaller and medium-size applications.|$|R
40|$|AbstractA {{wide range}} of <b>parser</b> <b>generators</b> are used to {{generate}} parsers for programming languages. The grammar formalisms that come with <b>parser</b> <b>generators</b> provide different approaches for defining operator precedence. Some generators (e. g. YACC) support precedence declarations, others require the grammar to be unambiguous, thus encoding the precedence rules. Even if the grammar formalism provides precedence rules, a particular grammar might not use it. The result is grammar variants implementing the same language. For the C language, the GNU Compiler uses YACC with precedence rules, the C-Transformers uses SDF without priorities, while the SDF library does use priorities. For PHP, Zend uses YACC with precedence rules, whereas PHP-front uses SDF with priority and associativity declarations. The variance between grammars raises the question if the precedence rules of one grammar are compatible with those of another. This is usually not obvious, since some languages have complex precedence rules. Also, for some <b>parser</b> <b>generators</b> the semantics of precedence rules is defined operationally, which {{makes it hard to}} reason about their effect on the defined language. We present a method and tool for comparing the precedence rules of different grammars and <b>parser</b> <b>generators.</b> Although it is undecidable whether two grammars define the same language, this tool provides support for comparing and recovering precedence rules, which is especially useful for reliable migration of a grammar from one grammar formalism to another. We evaluate our method by the application to non-trivial mainstream programming languages, such as PHP and C...|$|R
5000|$|Spirit Parser Framework - a C++ {{recursive}} descent <b>parser</b> <b>generator</b> framework requiring no pre-compile step ...|$|E
5000|$|TMG (language), {{an early}} {{compiler}} definition language and <b>parser</b> <b>generator</b> {{used to create}} the B-language ...|$|E
5000|$|An early LALR <b>parser</b> <b>generator</b> {{was called}} [...] "TWS", created by Frank DeRemer and Tom Pennello.|$|E
50|$|The {{generated}} code is beautified and as ease-of-understanding as possible. Actually, it uses lots of goto statements, but {{the control}} flows {{are much more}} traceable than goto spaghetti storms generated by some other <b>parser</b> <b>generators.</b>|$|R
50|$|With the {{resurgence}} of domain-specific languages {{and the need for}} <b>parser</b> <b>generators</b> which are easy to use, easy to understand, and easy to maintain, metacompilers are becoming a valuable tool for advanced software engineering projects.|$|R
40|$|A {{wide range}} of <b>parser</b> <b>generators</b> are used to {{generate}} parsers for programming languages. The grammar formalisms that come with <b>parser</b> <b>generators</b> provide different approaches for defining operator precedence. Some generators (e. g. YACC) support precedence declarations, others require the grammar to be unambiguous, thus encoding the precedence rules. Even if the grammar formalism provides precedence rules, a particular grammar might not use it. The result is grammar variants implementing the same language. For the C language, the GNU Compiler uses YACC with precedence rules, the C-Transformers uses SDF without priorities, while the SDF library does use priorities. For PHP, Zend uses YACC with precedence rules, whereas PHP-front uses SDF with priority and associativity declarations. The variance between grammars raises the question if the precedence rules of one grammar are compatible with those of another. This is usually not obvious, since some languages have complex precedence rules. Also, for some <b>parser</b> <b>generators</b> the semantics of precedence rules is defined operationally, which {{makes it hard to}} reason about their effect on the defined language. We present a method and tool for comparing the precedence rules of different grammars and <b>parser</b> <b>generators.</b> Although it is undecidable whether two grammars define the same language, this tool provides support for comparing and recovering precedence rules, which is especially useful for reliable migration of a grammar from one grammar formalism to another. We evaluate our method by the application to non-trivial mainstream programming languages, such as PHP and C. Presented at LDTA 2007 Seventh Workshop on Language Descriptions, Tools and Applications, 25 - 3 - 2007, Braga, Portuga...|$|R
50|$|Version 7.5 {{contains}} http server and LALR(1) <b>parser</b> <b>generator</b> (see also New Features in Visual Prolog 7.5).|$|E
5000|$|A <b>Parser</b> <b>Generator</b> for {{use with}} Miranda, ACM Symposium on Applied Computing, pages 401-407, Philadelphia, USA, Feb 1996.|$|E
50|$|TreeDL can be {{used with}} any <b>parser</b> <b>generator</b> that allows custom actions during parsing (for example, ANTLR, JavaCC).|$|E
50|$|Some LR <b>parser</b> <b>generators</b> create {{separate}} tailored {{program code}} for each state, {{rather than a}} parse table. These parsers can run several {{times faster than the}} generic parser loop in table-driven parsers. The fastest parsers use generated assembler code.|$|R
5000|$|Lex and <b>parser</b> <b>generators,</b> such as Yacc or Bison, are {{commonly}} used together. Parser generators use a formal grammar to parse an input stream, something which Lex cannot do using simple regular expressions (Lex is limited to simple finite state automata).|$|R
40|$|The Deep Linguistic Processing with HPSG Initiative (DELH-IN) {{provides}} the infrastructure {{needed to produce}} open-source semantic transfer-based machine translation systems. We have made available a prototype Japanese-English machine translation system built from existing resources include <b>parsers,</b> <b>generators,</b> bidirectional grammars and a transfer engine...|$|R
