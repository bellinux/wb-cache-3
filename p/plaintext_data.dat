49|29|Public
500|$|To {{carry out}} the cryptoviral {{extortion}} attack, the malware generates a random symmetric key and encrypts the victim's data with it. It uses the public key in the malware to encrypt the symmetric key. This is known as hybrid encryption and it results in a small asymmetric ciphertext {{as well as the}} symmetric ciphertext of the victim's data. It zeroizes the symmetric key and the original <b>plaintext</b> <b>data</b> to prevent recovery. It puts up a message to the user that includes the asymmetric ciphertext and how to pay the ransom. The victim sends the asymmetric ciphertext and e-money to the attacker.|$|E
50|$|In {{cryptography}} and steganography, plausibly deniable encryption describes encryption techniques {{where the}} existence of an encrypted file or message is deniable in the sense that an adversary cannot prove that the <b>plaintext</b> <b>data</b> exists.|$|E
50|$|One {{aspect of}} Tempest testing that distinguishes it from limits on {{spurious}} emissions (e.g., FCC Part 15) {{is a requirement}} of absolute minimal correlation between radiated energy or detectable emissions and any <b>plaintext</b> <b>data</b> that are being processed.|$|E
3000|$|Fine-Grained Access Control The {{data owner}} is {{permitted}} to impose an access policy on each file to be uploaded that precisely entitles the set of data users allowed to access. The public cloud is also prohibited from learning the <b>plaintexts</b> of <b>data</b> files.|$|R
50|$|In the attack, an {{algebraic}} {{function is}} used to represent an S-box. This may be a simple quadratic, or a polynomial or rational function over a Galois field. Its coefficients can be determined by standard Lagrange interpolation techniques, using known <b>plaintexts</b> as <b>data</b> points. Alternatively, chosen plaintexts {{can be used to}} simplify the equations and optimize the attack.|$|R
40|$|Abstract:- In this paper, {{we propose}} an {{encryption}} algorithm to encrypt plaintext to cipher text. We apply the basic computing operations, e. g., inserting dummy symbols, rotating, transposition, shifting and complement, {{in the proposed}} algorithm to encrypt plaintext to cipher text. The cipher text contains the <b>plaintext,</b> relative <b>data</b> and tables of encryption and transmits through the network. Since the tables of cipher text are produced randomly, {{it is difficult to}} do cryptanalysis...|$|R
50|$|Modern {{cryptographic}} systems resist known plaintext or even chosen plaintext attacks, and so may not {{be entirely}} compromised when plaintext is lost or stolen. Older systems resisted the effects of <b>plaintext</b> <b>data</b> loss on security with less effective techniques—such as padding and Russian copulation to obscure information in plaintext that could be easily guessed.|$|E
50|$|Zero padding {{may not be}} {{reversible}} if {{the original}} file ends {{with one or more}} zero bytes, making it impossible to distinguish between <b>plaintext</b> <b>data</b> bytes and padding bytes. It may be used when the length of the message can be derived out-of-band. It is often applied to binary encoded strings as the null character can usually be stripped off as whitespace.|$|E
50|$|A {{striking}} {{example of}} the degree to which ECB can leave <b>plaintext</b> <b>data</b> patterns in the ciphertext can be seen when ECB mode is used to encrypt a bitmap image which uses large areas of uniform color. While the color of each individual pixel is encrypted, the overall image may still be discerned as the pattern of identically colored pixels in the original remains in the encrypted version.|$|E
5000|$|In all countries, this preceded a table {{followed}} by a detailed expansion of her record chart for singles and albums, including her some achievements; It also details a bit <b>plaintext</b> some important <b>data</b> about Madonna in these countries.|$|R
30|$|Space {{consumption}} is also affected. Ciphertexts are computed {{as a combination}} of the <b>plaintext</b> with random <b>data.</b> This way, a non-trivial expansion rate is expected. Differently from speed overheads which are affected by a single attribute type, all attributes suffer with the expansion rate of encryption.|$|R
30|$|According to the {{probabilistic}} {{property of}} Paillier cryptosystem, the parameter r∈Z_N^* is selected randomly for each plaintext to achieve semantic security. Since magnitude relationships among plaintexts {{can not be}} kept to the corresponding ciphertexts, {{it is still a}} dilemma to embed additional data directly into an encrypted image with such a cryptosystem. In this work, with the probabilistic property, we design a strategy to encrypt two pixels in a group by using a random parameter so as to reserve the difference of two <b>plaintexts</b> for <b>data</b> hiding in encrypted domain.|$|R
5000|$|... victim→attacker To {{carry out}} the cryptoviral {{extortion}} attack, the malware generates a random symmetric key and encrypts the victim's data with it. It uses the public key in the malware to encrypt the symmetric key. This is known as hybrid encryption and it results in a small asymmetric ciphertext {{as well as the}} symmetric ciphertext of the victim's data. It zeroizes the symmetric key and the original <b>plaintext</b> <b>data</b> to prevent recovery. It puts up a message to the user that includes the asymmetric ciphertext and how to pay the ransom. The victim sends the asymmetric ciphertext and e-money to the attacker.|$|E
50|$|In the cryptoviral {{extortion}} attack, {{the virus}} hybrid encrypts <b>plaintext</b> <b>data</b> on the victim's machine using the randomly generated IV and SK. The IV+SK are then encrypted using the virus writer's public key. In theory the victim must {{negotiate with the}} virus writer to get the IV+SK back in order to decrypt the ciphertext (assuming there are no backups). Analysis of the virus reveals the public key, not the IV and SK needed for decryption, or the private key needed to recover the IV and SK. This result {{was the first to}} show that computational complexity theory can be used to devise malware that is robust against reverse-engineering.|$|E
50|$|For an {{internal}} array controller configuration, the array controller is generally a PCI bus card situated inside the host computer. As {{shown in the}} diagram, the PCI array controller would contain an encryption unit where <b>plaintext</b> <b>data</b> is encrypted into ciphertext. This separate encryption unit is utilized to prevent and minimize performance reduction and maintain data throughput. Furthermore, the Key Management Client will generally be an additional service within the host computer applications where it will authenticate all keys retrieved from the Key Server. A major disadvantage {{to this type of}} implementation would be that encryption components are required to be integrated within each host computer and therefore is redundant on large networks with many host devices.|$|E
40|$|Part 8 : Sidechannel AnalysisInternational audienceMemory {{disclosure}} attacks, such as cold-boot {{attacks and}} DMA attacks, allow attackers to access all memory contents, therefore introduce great threats to <b>plaintext</b> sensitive <b>data</b> in memory. Register-based and cache-based schemes {{have been used}} to implement RSA securely, at the expense of decreased performance. In this paper, we propose another concept named register buffer, which makes use of all available registers as secure data buffer, no matter scalar registers or vector registers. The <b>plaintext</b> sensitive <b>data</b> only appear in register buffer. Based on this concept, we finish a security implementation of 2048 -bit RSA called RegRSA, to defeat against memory disclosure attacks. The 1024 -bit Montgomery multiplication in RegRSA runs entirely in register buffer, by performing computations using scalar instructions and registers, maintaining intermediate variables in vector registers. Due to the size limitation of register buffer, several variables out of Montgomery multiplications are spilled into memory. RegRSA encrypts these variables with AES before saving in memory. Furthermore, RegRSA employs a windowing method and the CRT speed-up to accelerate RSA, and minimizes the data exchange between registers and memory to reduce the workload of AES encryption/decryption. The evaluation on Intel Haswell i 7 - 4770 R shows that, the performance of RegRSA achieves a factor of 0. 74 compared to the regular RSA implementation in OpenSSL and is much greater than PRIME, the existing register-based scheme for 2048 -bit RSA. Moreover, RegRSA allows multiple instances to run on a multi-core CPU simultaneously, which makes it more practical for the real-world applications...|$|R
50|$|A modern {{example of}} {{information}} leakage is the leakage of secret information via data compression, by using variations in data compression ratio to reveal correlations between known (or deliberately injected) <b>plaintext</b> and secret <b>data</b> combined {{in a single}} compressed stream. Another example is the key leakage that can occur when using some public-key systems when cryptographic nonce values used in signing operations are insufficiently random.|$|R
40|$|In {{the modern}} world, the {{information}} that could benefit the individual / a group {{also can be used}} against such individual or group. Encryption is the technique of converting a <b>plaintext</b> (original <b>data</b> packet) into cipher text (encrypted message) which can be decoded back into the original message. There are several types of data encryptions schemes available which form the basis of network security. Our proposed work deals with the security based wireless communication system, with the NIOS-II soft core processor. Security in wireless communication is most essential, especially where hacking and tampering are threats of the data packet. Hence introduction of suitable security bits (Key) with the actual data packet is most important aspect in wireless communication to avoid such threats. It is really a significant and interesting area for the researcher. In this work, the data encryption standard technique is used for the safety transmission and reception, and implemented it successfully with the NIOS-II soft core processor...|$|R
50|$|To {{overcome}} this limitation, several so-called block cipher {{modes of operation}} have been designed and specified in national recommendations such as NIST 800-38A and BSI TR-02102 and international standards such as ISO/IEC 10116. The general concept is to use randomization of the <b>plaintext</b> <b>data</b> based on an additional input value, frequently called an initialization vector, to create what is termed probabilistic encryption. In the popular cipher block chaining (CBC) mode, for encryption to be secure the initialization vector passed along with the plaintext message must be a random or pseudo-random value, which is added in an exclusive-or manner to the first plaintext block before it is being encrypted. The resultant ciphertext block is then used as the new initialization vector for the next plaintext block. In the cipher feedback (CFB) mode, which emulates a self-synchronizing stream cipher, the initialization vector is first encrypted and then added to the plaintext block. The output feedback (OFB) mode repeatedly encrypts the initialization vector to create a key stream for the emulation of a synchronous stream cipher. The newer counter (CTR) mode similarly creates a key stream, but {{has the advantage of}} only needing unique and not (pseudo-)random values as initialization vectors; the needed randomness is derived internally by using the initialization vector as a block counter and encrypting this counter for each block.|$|E
30|$|In this experiment, data {{test was}} {{conducted}} from two main different perspectives: {{in the first}} scenario, <b>plaintext</b> <b>data</b> with different sizes were chosen to compare their encryption speed and speed-up ratio in different serial and parallel environment; in the second situation, <b>plaintext</b> <b>data</b> with fixed size were chosen to compare their encryption speed and speed-up ratio under different block sizes. In the first situation, the chosen <b>plaintext</b> <b>data</b> had the sizes of 256 [*]MB, 512 [*]MB, 768 [*]MB, 1024 [*]MB, 1280 [*]MB, 1536 [*]MB, 1792 [*]MB, and 2048 [*]MB, the default data block size was 64 [*]MB in the parallel environment, and the encryption test was conducted in both serial and parallel environment. For the second situation, the <b>plaintext</b> <b>data</b> with the sizes of 2 G and 4 G were chosen in the experiment, the data fragment numbers were 1, 4, 8, 12, 16, 20, 24, 28, and 32, respectively, and their encryption speeds were tested. In the experiment, the size of float-point numbers is 32  bit, and the dimension of the security parameter n is 128 bit.|$|E
3000|$|... {{which is}} the desired output. Bob gains no {{knowledge}} in this protocol as he never handles any <b>plaintext</b> <b>data.</b> The only step that Alice involves in is in the secure multiplication. The adversarial intention of Alice is to make [...]...|$|E
40|$|In {{this paper}} we improve Davies' attack [2] on DES to become capable of {{breaking}} the full 16 -round DES faster than the exhaustive search. Our attack requires 2 50 complexity of the data collection and 2 50 the complexity of analysis. An alternative approach nds 24 key bits of DES with 2 52 known <b>plaintexts</b> and the <b>data</b> analysis requires only several minutes on a SPARC. Therefore, {{this is the third}} successful attack on DES, faster than brute force, after dierential cryptanalysis [1] and linear cryptanalysis [5]. We also suggest criteria which make the S-boxes immune to this attack. ...|$|R
40|$|Abstract. A DPA contest {{has been}} {{launched}} at CHES 2008. The {{goal of this}} initiative {{is to make it}} possible for researchers to compare different side-channel attacks in an objective manner. For this purpose, a set of 80 000 traces corresponding to the encryption of 80 000 different <b>plaintexts</b> with the <b>Data</b> Encryption Standard and a fixed key has been made available. In this short note, we discuss the rules that the contest uses to rate the effectiveness of different distinguishers. We first describe practical examples of attacks in which these rules can be misleading. Then, we suggest an improved set of rules that can be implemented easily in order to obtain a better interpretation of the comparisons performed. ...|$|R
5000|$|In cryptography, a {{ciphertext}}-only attack (COA) or known ciphertext {{attack is}} an attack model for cryptanalysis where the attacker is assumed to have access only {{to a set of}} ciphertexts. While the attacker has no channel providing access to the plaintext prior to encryption, in all practical ciphertext-only attacks, the attacker still has some knowledge of the plaintext. For instance, the attacker might know the language in which the plaintext is written in or the expected statistical distribution of characters in the <b>plaintext.</b> Standard protocol <b>data</b> and messages are commonly part of the plaintext in many deployed systems and can usually be guessed or known efficiently as part of a ciphertext-only attack on these systems.|$|R
40|$|Data {{geolocation}} in {{the cloud}} is becoming an increasingly pressing problem, aggravated by incompatible legislation in different jurisdictions and compliance requirements of data owners. In this work we present a mechanism allowing cloud users to control the geographical location of their data, stored or processed in plaintext on the premises of Infrastructure-as-a-Service cloud providers. We use trusted computing principles and remote attestation to establish platform state. We enable cloud users to confine <b>plaintext</b> <b>data</b> exclusively to the jurisdictions they specify, by sealing decryption keys used to obtain <b>plaintext</b> <b>data</b> to the combination of cloud host geolocation and platform state. We provide {{a detailed description of}} the implementation as well as performance measurements on an open source cloud infrastructure platform using commodity hardware. ...|$|E
30|$|For <b>plaintext</b> <b>data</b> {{with the}} same size, the {{generated}} ciphertexts also have the same size. Assume it requires reduce time of Tric for each floating-point number to generate ciphertext, then the plaintext that contains N floating-point numbers requires the time of Treduce[*]=[*]N[*]×[*]Tric, {{and it can be}} seen that Treduce is proportional to the size of generated ciphertext.|$|E
30|$|We {{assume the}} {{scenario}} in which the data owner has exclusive possession of cryptographic keys. This way, insertions to the database must be locally encrypted before {{being sent to the}} server. The database or the application never deal with <b>plaintext</b> <b>data.</b> Our framework thus has the advantage over CryptDB of preserving privacy even in the outcome of a compromised database or application server.|$|E
30|$|In this scenario, the {{following}} process happens: (1) The document: The data owner encrypts the <b>plaintext</b> medical <b>data</b> file using a symmetric encryption method {{to secure the}} privacy of the medical data before outsourcing the file, and sends the key to the authorized patient user via the secure channel. Without a key, it is difficult for the medical cloud server or attacker to decrypt the ciphertext document. (2) Index: In each index, the keyed hash function guarantees {{the privacy of the}} keyword; the medical data file identifier is the indicator of the associated ciphertext document and does not reveal related information. Therefore, the privacy of the index can be guaranteed. (3) Query: In trapdoors, each query keyword is encrypted by a keyed hash function, so its privacy security is guaranteed. (4) Related verification information: This scheme inserts encrypted keywords in the Bloom filter. The medical cloud server or attacker cannot know the relevant information of the hash function without a key and cannot analyze the Bloom filter. Therefore, the Bloom filter is privacy-safe. The message authentication code is obtained through the function MAC, and only the user with the key can use it to verify the result.|$|R
40|$|This package {{contains}} {{a set of}} data regarding daily refugee arrivals at the Greek islands of first-reception in teh Aegean Sea, for the most intense period of influx waves, {{from the beginning of}} October 2015 until the mid-January of 2016. The sources of the data are: 1) For daily arrivals: UNHCR Refugees/Migrants Emergency Response (Data mashups) [URL] 2) For weather: Searchable Weather Database - National Observatory (Greece) [URL] The datasets from (1) have already been used in various publications describing such predictive analytics models. Detailed description and related conclusions can be found at: * Harris V. Georgiou, "Identification of refugee influx patterns in Greece via model-theoretic analysis of daily arrivals" (9 -May- 2016), [URL] _______________________________________________ AVAILABLE FILE FORMATS The datasets are available in the following formats (included) : *. xlsx : MS-Excel/LibreOffice native spreadsheets *. csv : comma-separated plaintext spreadsheets *arff : WEKA native <b>data</b> source (<b>plaintext)</b> These <b>data</b> formats are equivalent, i. e., they contain the exact same sets of data. Normally, {{at least one of them}} should be compatible with any major programming platform (e. g. Matlab, Octave, R) or any native programming language for arbitrary handling (e. g. C, Java) ...|$|R
50|$|In 2004, Muller {{published}} two {{attacks on}} Helix. The first has a complexity of 288 and requires 212 adaptive chosen-plaintext words, but requires nonces to be reused. Souradyuti Paul and Bart Preneel later {{showed that the}} number of adaptive chosen-plaintext words of Muller's attack can be reduced by a factor of 3 in the worst case (a factor of 46.5 in the best case) using their optimal algorithms to solve differential equations of addition. In a later development, Souradyuti Paul and Bart Preneel showed that the above attack can also be implemented with chosen plaintexts (CP) rather than adaptive chosen <b>plaintexts</b> (ACP) with <b>data</b> complexity 235.64 CP's. Muller's second attack on Helix is a distinguishing attack that requires 2114 words of chosen plaintext.|$|R
30|$|In the experiment, 4 {{computation}} nodes were used, {{and each}} node had 4 -core CPU, so the CPU had total 16 cores. In the parallel experiment, {{we found that}} {{with the increase of}} <b>plaintext</b> <b>data</b> volume, the time occupied by Reduce would keep growing, and in order to increase the efficiency, the number of Reduce was all set as 15 in parallel experiment.|$|E
30|$|Several schemes {{have been}} {{proposed}} {{over the last decade}} for securely processing range predicates over outsourced encrypted databases. The most prominent among them have been OPE [1, 5, 6, 13, 18] and PPE [15, 22], which inevitably leak order-based and structure-based characteristics, respectively, of the <b>plaintext</b> <b>data.</b> More pertinently, these solutions can be easily breached in the HCC model, as shown in Sect.  1.1.|$|E
40|$|This thesis {{presents}} an approach for designing secure web applications that use client-side encryption to keep user data private {{in the face}} of arbitrary web server compromises, as well as a set of tools, called CryptFrame, that makes it easier to build such applications. Crypt- Frame allows developers to encrypt and decrypt confidential data in the user's browser. To ensure an adversary cannot gain access to the decryption keys or <b>plaintext</b> <b>data,</b> CryptFrame provides a browser extension that stores the keys and allows only sensitive regions in the web page to access them. CryptFrame performs templatized verification of sensitive regions to grant small amounts of trusted client-side code access to <b>plaintext</b> <b>data</b> in the browser. Finally, CryptFrame provides a principal graph to help users safely change permissions on shared data in the presence of active adversaries. We use CryptFrame to modify several existing Django-based applications, requiring few source code modifications and incurring moderate performance overhead. by Emily Stark. Thesis (S. M.) [...] Massachusetts Institute of Technology, Dept. of Electrical Engineering and Computer Science, 2013. Cataloged from PDF version of thesis. Includes bibliographical references (p. 53 - 55) ...|$|E
40|$|At CCS 2015 Naveed et al. {{presented}} first {{attacks on}} efficiently searchable encryption, such as deterministic and order-preserving encryption. These plaintext guessing attacks have been further improved in subsequent work, e. g. by Grubbs et al. in 2016. Such cryptanalysis is crucially important to sharpen {{our understanding of}} the implications of security models. In this paper we present an efficiently searchable, encrypted data structure that is provably secure against these and even more powerful chosen <b>plaintext</b> attacks. Our <b>data</b> structure supports logarithmic-time search with linear space complexity. The indices of our data structure can be used to search by standard comparisons and hence allow easy retrofitting to existing database management systems. We implemented our scheme and show that its search time overhead is only 10 milliseconds compared to non-secure search...|$|R
40|$|Despite {{considerable}} {{research on}} passwords, empirical studies of password strength {{have been limited}} by {{lack of access to}} <b>plaintext</b> passwords, small <b>data</b> sets, and password sets specifically collected for a research study or from low-value accounts. Properties of pass-words used for high-value accounts thus remain poorly understood. We fill this gap by studying the single-sign-on passwords used by over 25, 000 faculty, staff, and students at a research university with a complex password policy. Key aspects of our contributions rest on our (indirect) access to plaintext passwords. We describe our data collection methodology, particularly the many precautions we took to minimize risks to users. We then analyze how guessable the collected passwords would be during an offline attack by sub-jecting them to a state-of-the-art password cracking algorithm. We discover significant correlations between a number of demographi...|$|R
40|$|Secure {{communication}} channels are typically constructed from an authenticated key exchange (AKE) protocol, which authenticates the communicating parties and establishes shared secret keys, and a {{secure data transmission}} layer, which uses the secret keys to encrypt data. We address the partial leakage of communicating parties' long-term secret keys due to various side-channel attacks, and the partial leakage of <b>plaintext</b> due to <b>data</b> compression. Both issues can negatively affect the security of channel establishment and data transmission. In this work, we advance the modelling of security for AKE protocols by considering more granular partial leakage of parties' long-term secrets. We present generic and concrete constructions of two-pass leakage-resilient key exchange protocols that are secure in the proposed security models. We also examine two techniques [...] heuristic separation of secrets and fixed-dictionary compression [...] for enabling compression while protecting high-value secrets...|$|R
