0|10000|Public
50|$|During PCB Assembly, {{the bottom}} package of <b>a</b> <b>PoP</b> <b>stack</b> is placed {{directly}} on the PCB, and the other package(s) of the stack are stacked on top.The packages of <b>a</b> <b>PoP</b> <b>stack</b> become attached <b>to</b> each other (and to the PCB) during reflow soldering.|$|R
40|$|We study sorting {{machines}} {{consisting of}} <b>a</b> <b>stack</b> and <b>a</b> <b>pop</b> <b>stack</b> in series, {{with or without}} a queue between them. While there are, a priori, four such machines, only two are essentially different: <b>a</b> <b>pop</b> <b>stack</b> followed directly by <b>a</b> <b>stack,</b> and <b>a</b> <b>pop</b> <b>stack</b> followed by <b>a</b> queue and then by <b>a</b> <b>stack.</b> In the former case, we obtain complete answers for the basis and enumeration of the sortable permutations. In the latter case, we present a characterization in terms of divided permutations and several conjectures...|$|R
50|$|Calculators that utilize reverse Polish {{notation}} (RPN), {{also known}} as postfix notation, use <b>a</b> <b>stack</b> <b>to</b> enter formulas {{without the need for}} parentheses.|$|R
5000|$|Stacks {{are created}} using [...] The <b>stack</b> offers methods <b>to</b> {{put a new}} object on the stack (method push (...) [...] ) and to get objects from the <b>stack</b> (method <b>pop</b> (...) [...] ). <b>A</b> <b>stack</b> returns the object {{according}} to last-in-first-out (LIFO), e.g. the object which was placed latest on the stack is returned first. java.util.Stack is a standard implementation of <b>a</b> <b>stack</b> provided by Java. The <b>Stack</b> class represents <b>a</b> last-in-first-out (LIFO) <b>stack</b> of objects. It extends class [...] with five operations that allow a vector {{to be treated as}} <b>a</b> <b>stack.</b> The usual push and pop operations are provided, as well as a method to peek at the top item on the <b>stack,</b> <b>a</b> method <b>to</b> test for whether the stack is empty, and a method <b>to</b> search the <b>stack</b> for <b>an</b> item and discover how far it is from the top. When <b>a</b> <b>stack</b> is first created, it contains no items.|$|R
5000|$|<b>A</b> <b>stack</b> S <b>to</b> {{store the}} {{positions}} of pivots partitioning heap.|$|R
50|$|All nearest smaller values, {{the problem}} of finding, for each number in an array, the closest {{preceding}} number that is smaller than it. One algorithm for this problem uses <b>a</b> <b>stack</b> <b>to</b> maintain <b>a</b> collection of candidates for the nearest smaller value. For each position in the array, the <b>stack</b> is <b>popped</b> until <b>a</b> smaller value is found on its top, and then the value in the new position is pushed onto the stack.|$|R
50|$|In {{contrast}} to the COM-based specifications, the UA specifications are not pure application specifications. They describe typically UA internal mechanisms, which get handled through the communication stack and are normally only of interest for those that port <b>a</b> <b>stack</b> <b>to</b> <b>a</b> specific target or those that want to implement their own UA stack.|$|R
50|$|There {{are many}} {{possibilities}} for the intermediate representation. Three-address code, {{also known as a}} quadruple or quad is a common form, where there is an operator, two operands, and a result. Two-address code or triples have <b>a</b> <b>stack</b> <b>to</b> which results are written, in contrast to the explicit variables of three-address code.|$|R
50|$|In mathematics, Artin's {{criterion}} gives {{a necessary}} and sufficient condition for <b>an</b> algebraic <b>stack</b> <b>to</b> be <b>an</b> algebraic space.|$|R
5000|$|... #Caption: Jon Lord put his Hammond C-3 through <b>a</b> Marshall <b>stack</b> <b>to</b> {{fit in with}} Deep Purple's {{hard rock}} sound ...|$|R
2500|$|There {{is a way}} <b>to</b> {{associate}} <b>a</b> <b>stack</b> <b>to</b> <b>a</b> given prestack. It {{is similar}} to the sheafification of a presheaf and is called stackification. The idea of the construction is quite simple: given a prestack , we let HF be the category where an object is a descent datum and a morphism is that of descent data. (The details are omitted for now) ...|$|R
50|$|A {{storm in}} November 1866 caused <b>a</b> chimney <b>stack</b> <b>to</b> {{fall through the}} station roof causing {{considerable}} damage. In 1873, a footbridge was added.|$|R
50|$|Graham's scan is {{a method}} of finding the convex hull of a finite set of points in the plane with time {{complexity}} O(n log n). It is named after Ronald Graham, who published the original algorithm in 1972. The algorithm finds all vertices of the convex hull ordered along its boundary. It uses <b>a</b> <b>stack</b> <b>to</b> detect and remove concavities in the boundary efficiently.|$|R
5000|$|In {{addition}} to the larger islands thare are various smaller islets, stacks and skerries. Biruaslum is <b>a</b> <b>stack</b> <b>to</b> the west of Vatersay. It reaches 72 m in height {{and there is a}} ruined prehistoric fort on the southern side. Francis G. Thompson characterizes it as [...] "high and virtually inaccessible"; [...] James Fisher mentions a [...] "fulmar flying up and down its tiny cliff." ...|$|R
5000|$|Many 32-bit {{computers}} (such as 68000, ARM, or PowerPC) {{have more}} than one register which could be used as <b>a</b> <b>stack</b> pointer—and so use the [...] "register autoincrement indirect" [...] addressing mode to specify which of those registers should be used when pushing or <b>popping</b> data from <b>a</b> <b>stack.</b>|$|R
50|$|Perl has <b>a</b> {{number of}} <b>stacks</b> <b>to</b> store things {{it is working}} on.|$|R
5000|$|The goal is <b>to</b> create <b>a</b> <b>stack</b> {{of coins}} which {{includes}} one penny, one nickel, one dime and one quarter. Any player who places the fourth coin on <b>a</b> <b>stack</b> gets <b>to</b> claim that <b>stack</b> and {{remove it from}} the board.|$|R
40|$|Work-stealing is a {{promising}} approach for effectively exploiting software parallelism on parallel hardware. A programmer who uses work-stealing explicitly identifies potential parallelism and the runtime then schedules work, keeping otherwise idle hardware busy while relieving overloaded hardware of its burden. However, work-stealing comes with substantial overheads. Our prior work demonstrates that using the exception handling mechanism of modern VMs and gathering the runtime information {{directly from the}} victim’s execution stack can significantly reduce these overheads. In this paper we identify the overhead associated with managing the work-stealing related information on <b>a</b> victim’s execution <b>stack.</b> <b>A</b> return barrier is a mechanism for intercepting the <b>popping</b> of <b>a</b> <b>stack</b> frame, and thus is {{a powerful tool for}} optimizing mechanisms that involve scanning of stack state. We present the design and preliminary findings of using return barriers on <b>a</b> victim’s execution <b>stack</b> <b>to</b> reduce these overheads. We evaluate our design using classical work-stealing benchmarks. On these benchmarks, compared to our prior design, we are able to reduce the overheads by as much as 58 %. These preliminary findings give further hope to an already promising technique of harnessing rich features of a modern VM inside a work-stealing scheduler...|$|R
5000|$|The {{contents}} of <b>a</b> <b>stack</b> will appear <b>to</b> spring {{out from behind}} the icon when clicked.|$|R
50|$|A {{series of}} translation, scaling, and {{rotation}} matrices can logically describe most transformations. Rasterization systems generally use <b>a</b> transformation <b>stack</b> <b>to</b> move {{the stream of}} input vertices into place. The transformation <b>stack</b> is <b>a</b> standard <b>stack</b> which stores matrices. Incoming vertices are multiplied by the matrix stack.|$|R
50|$|Joan Elliott Pickart is a Virgo. Her {{mother was}} widowed young, raised {{her and her}} two sisters. She always has <b>a</b> <b>stack</b> waiting <b>to</b> be read, her {{favourite}} books are those written by LaVyrle Spencer.|$|R
50|$|As noted above, {{the primary}} purpose of <b>a</b> call <b>stack</b> is <b>to</b> store the return addresses. When a {{subroutine}} is called, the location (address) of the instruction at which it can later resume needs to be saved somewhere. Using <b>a</b> <b>stack</b> <b>to</b> save the return address has important advantages over alternative calling conventions. One is that each task can have its own stack, and thus the subroutine can be reentrant, that is, can be active simultaneously for different tasks doing different things. Another benefit is that recursion is automatically supported. When a function calls itself recursively, a return address needs to be stored for each activation of the function so that it can later be used to return from the function activation. Stack structures provide this capability automatically.|$|R
40|$|We give {{criteria}} for certain morphisms from <b>an</b> algebraic <b>stack</b> <b>to</b> <b>a</b> (not necessarily algebraic) <b>stack</b> <b>to</b> admit <b>an</b> (appropriately defined) scheme-theoretic image. We apply our criteria {{to show that}} certain natural moduli stacks of local Galois representations are algebraic (or Ind-algebraic) stacks. Comment: 116 pages; minor changes, submitte...|$|R
50|$|Specifically, the invariants on stacked run sizes {{ensure a}} tight {{upper bound on}} the maximum size of the {{required}} stack. The implementation preallocated <b>a</b> <b>stack</b> sufficient <b>to</b> sort 264 bytes of input, and avoided further overflow checks.|$|R
50|$|All un-dealt {{cards are}} left {{face down in}} <b>a</b> <b>stack</b> placed central <b>to</b> all players called the draw pile.|$|R
5000|$|Ensure that players, in general, do {{not have}} <b>a</b> large <b>stack</b> {{relative}} <b>to</b> the blind level.|$|R
40|$|The laser and optics {{system for}} the photon {{collider}} seeks to minimize the required laser power by using <b>an</b> optical <b>stacking</b> cavity <b>to</b> recirculate the laser light. An enhancement of between 300 to 400 is desired. In order to achieve this the laser pulses which drive the cavity must precisely match the phase of the pulse circulating within the cavity. We report on simulations {{of the performance of}} <b>a</b> <b>stacking</b> cavity <b>to</b> various variations of the drive laser in order to specify the required tolerances of the laser system...|$|R
40|$|On {{the example}} of the Fibonacci chain we show how to efˇciently {{generate}} inˇnite words deˇned by substitutions. We introduce substitution trees and we present an algorithm that uses them to generate suchinˇnite words. We use <b>a</b> <b>stack</b> <b>to</b> generate the words in a completely different manner than in traditional breadth-ˇrst tree traversals. We show that the algorithm has O(log n) space complexity and O(n) time complexity, where n is the length of the generated word. The aperiodic Fibonacci chain is used for construction of aperiodic pseudorandom number generators...|$|R
50|$|Like this algorithm, Tarjan's {{strongly}} connected components algorithm {{also uses}} {{depth first search}} together with <b>a</b> <b>stack</b> <b>to</b> keep track of vertices {{that have not yet}} been assigned to a component, and moves these vertices into a new component when it finishes expanding the final vertex of its component. However, in place of the stack P, Tarjan's algorithm uses a vertex-indexed array of preorder numbers, assigned in the order that vertices are first visited in the depth-first search. The preorder array is used to keep track of when to form a new component.|$|R
5000|$|Memory (typically some {{region of}} virtual memory); which {{includes}} the executable code, process-specific data (input and output), <b>a</b> call <b>stack</b> (<b>to</b> keep track of active subroutines and/or other events), and a heap to hold intermediate computation data generated during run time.|$|R
50|$|Stack {{pointers}} may {{point to}} the origin of <b>a</b> <b>stack</b> or <b>to</b> <b>a</b> limited range of addresses either above or below the origin (depending on {{the direction in which}} the stack grows); however, the stack pointer cannot cross the origin of the stack. In other words, if the origin of the stack is at address 1000 and the stack grows downwards (towards addresses 999, 998, and so on), the stack pointer must never be incremented beyond 1000 (to 1001, 1002, etc.). If <b>a</b> <b>pop</b> operation on the stack causes the <b>stack</b> pointer <b>to</b> move past the origin of the <b>stack,</b> <b>a</b> <b>stack</b> underflow occurs. If a push operation causes the <b>stack</b> pointer <b>to</b> increment or decrement beyond the maximum extent of the <b>stack,</b> <b>a</b> <b>stack</b> overflow occurs.|$|R
40|$|The stack {{model of}} {{execution}} uses <b>a</b> <b>stack</b> <b>to</b> hold temporary results during {{evaluation of a}} program. Systems such as Java virtual machines that use this model can be implemented so that they have more efficient access <b>to</b> the <b>stack</b> than <b>to</b> local variables. Thus, converting local variable accesses into stack accesses can improve the performance of stack-based programs, {{as suggested by the}} experiments of Koopman [1994], Maierhofer and Ertl [1998], Vallée-Rai et al. [2000], and Shpeisman and Tikir [1999]. In this paper we provide a foundation for these experiments by formalizing and generalizing various known transformations for reducing the number of loads and stores, and by proving their correctness. ...|$|R
50|$|The {{open source}} FreeBSD {{operating}} system includes <b>an</b> IPX/SPX <b>stack,</b> <b>to</b> support both <b>a</b> NetWare file system client, nwfs, {{as well as}} NetWare server using Mars NWE (providing some functionality). OpenBSD dropped support with version 4.2, and 4.1 needed some work to compile with IPX.|$|R
50|$|The Horse of Copinsay, {{also known}} as the Horse, is <b>a</b> {{rectangular}} sea <b>stack</b> <b>to</b> the north east of Copinsay in the Orkney Islands.|$|R
40|$|Strictness {{analysis}} {{is crucial for}} the efficient implementation f the lazy flmctionM lan-guages. A related technique for the concurrent logic languages (CLLs) called schedule {{analysis is}} presented which divides at compile-time a CLL program into threads of to-tally ordered atoms, whose relative ordering is determined at run-time. The technique enables the enqueuing and dequeuing of processes to be reduced, synchronisation tests to be partially removed, introduces {{the possibility of using}} unboxed arguments, and permits variables to be migrated from <b>a</b> heap <b>to</b> <b>a</b> <b>stack</b> <b>to</b> affect <b>a</b> form of compile-time garbage collection. The implementation is outlined and some preliminary results are given. ...|$|R
50|$|Starting with a {{topographic}} map, one can cut out successive layers {{from some}} sheet material, with edges following the contour {{lines on the}} map. These may be assembled in <b>a</b> <b>stack</b> <b>to</b> obtain <b>a</b> rough approximation of the terrain. This method is commonly used as the base for architectural models, and is usually done without vertical exaggeration. For models of landforms, the stack can then be smoothed by filling with some material. This model may be used directly, or for greater durability a mold may be made from it. This mold may then be used to produce a plaster model.|$|R
