105|384|Public
50|$|In recent years, {{researchers}} in Runtime Verification {{have recognized the}} potential of using Aspect-oriented Programming as a technique for defining <b>program</b> <b>instrumentation</b> in a modular way. Aspect-oriented programming (AOP) generally promotes the modularization of crosscutting concerns. Runtime Verification naturally is one such concern and can hence benefit from certain properties of AOP. Aspect-oriented monitor definitions are largely declarative, and hence tend to be simpler to reason about than instrumentation expressed through a program transformation written in an imperative programming language. Further, static analyses can reason about monitoring aspects more easily than about other forms of <b>program</b> <b>instrumentation,</b> as all instrumentation is contained within a single aspect. Many current runtime verification tools are hence built {{in the form of}} specification compilers, that take an expressive high-level specification as input and produce as output code written in some Aspect-oriented programming language (most often AspectJ).|$|E
40|$|Hands-on <b>program</b> <b>instrumentation</b> and {{simulation}} {{projects are}} good tools to teach computer architecture {{to students who}} may have limited backgrounds in hardware design. Through working with toolkits such as Atom [SE 94] and Shade [CK 94], {{students are able to}} become comfortable with the concrete behavior of complex hardware and software structures, and be prepared for more advanced research projects. This paper summarizes my experiences developing hands-on <b>program</b> <b>instrumentation</b> and measurement projects for students in a sequence of computer architecture courses...|$|E
40|$|Conference Name:World Congress on Software Engineering. Conference Address: Xiamen, PEOPLES R CHINA. Time:MAY 19 - 21, 2009. In this paper, an {{improved}} method of Super Block Method (SBM) is presented for software testing. The primary {{idea of the}} method, called virtual node method (VNM), is to add virtual nodes to the control flow before the SBM is used. The same with the SBM, the VNM can help testers use minimal test cases to cover 100 % blocks or achieve a desired coverage. Moreover, {{it can be used}} to reduce the overhead of <b>program</b> <b>instrumentation</b> for coverage testing by reducing the redundancies in the SBM. Essentially, the total overhead of <b>program</b> <b>instrumentation</b> is reduced not only by inserting fewer probes, which is realized by the SBM, but also by inserting the probes among the codes that are less likely to be executed. The experimental results show that the overhead of <b>program</b> <b>instrumentation</b> is further reduced by the VNM compared with the SBM...|$|E
5000|$|Allan Grigg - songwriting, production, <b>programming,</b> <b>instrumentation</b> ...|$|R
5000|$|Manuel Reuter - songwriting, production, <b>programming,</b> <b>instrumentation</b> ...|$|R
5000|$|Shellback - songwriting, production, recording, <b>programming,</b> <b>instrumentation</b> ...|$|R
40|$|AbstractThe Java-MaC {{framework}} is a run-time verification system for Java programs {{that can be}} used to dynamically test and enforce safety policies. This paper presents a formal model of the Java-MaC safety properties in terms of an operational semantics for Middleweight Java, a realistic subset of full Java. This model is intended to be used as a framework for studying the correctness of Java-MaC <b>program</b> <b>instrumentation,</b> optimizations, and future experimentation with run-time monitor expressiveness. As a preliminary demonstration of this model's applicability for these tasks, the paper sketches a correctness result for a simple <b>program</b> <b>instrumentation</b> scheme...|$|E
40|$|It {{is often}} {{important}} for software developers and researchers {{to be able}} to measure and understand both the static structure and dynamic behavior of a program. Such information is very valuable for debugging purpose, for evaluation and comparison the performance of different implementations, and other purposes. The concept of <b>program</b> <b>instrumentation</b> has been developed and implemented in the past decade. The idea is to insert additional statements (instruments) into a program for information gathering purposes. The inserted statements will be executed at the same time when the program is running. But the editing of the program should not have any impact on output of the program. We searched thoroughly on this topic and found out many tools available. We put these tools in 3 categories: binary rewriting tool and Java bytecode instrumentation, dynamic instrumentation, Aspect-oriented <b>program</b> <b>instrumentation</b> and programming language support on <b>program</b> <b>instrumentation.</b> We have studies on each category. The binary rewriting tools modify binary or Java bytecode. They hold the concept of object oriented. So they are much easier to be customized than other early-developed tools, and suppor...|$|E
40|$|Program {{comprehension}} is {{an essential}} part of software maintenance and there exists a variety of techniques the can be applied to support the comprehension process. Two of these techniques are source code analysis and <b>program</b> <b>instrumentation.</b> Source code analysis is typically applied to analyze the source code of existing systems and their behavior. There exists a wide range of techniques and approaches to support source code analysis. Feature analysis is one of these techniques that can be applied to extract functional features from existing source code. Another approach is <b>program</b> <b>instrumentation</b> that is used to collect program executions and program behavior. In this thesis, both of these techniques, feature analysis and <b>program</b> <b>instrumentation,</b> are combined to improve on the understanding of functional features and their behavior. In the presented approach, feature related statements in Java programs are mapped in a semi-automatic process into AspectJ tracing program. The approach takes advantage of both, the tracing and encapsulation support embedded within the Aspect Oriented Programming (AOP) paradigm. An initial case study is presented to illustrate the presented approach...|$|E
5000|$|Eric Prydz - songwriter, producer, <b>programming,</b> <b>instrumentation</b> ...|$|R
5000|$|Yann Peifer - songwriting, production, <b>programming,</b> <b>instrumentation</b> ...|$|R
5000|$|Arca - vocals, production, composition, mixing, <b>programming,</b> <b>instrumentation</b> ...|$|R
40|$|An {{integrated}} set of FORTRAN {{tools that}} are commercially available is described. The basic purpose of various tools is summarized and their economic impact highlighted. The areas addressed by these tools include: code auditing, error detection, program portability, <b>program</b> <b>instrumentation,</b> documentation, clerical aids, and quality assurance...|$|E
30|$|Various {{methods are}} {{proposed}} as countermeasures to these challenges, and both traditional techniques, like <b>program</b> <b>instrumentation</b> and taint analysis, and new techniques, like RNN and LSTM (Godefroid et al. 2017) (Rajpal et al. 2017) are involved. How these techniques can compromise the challenges {{will be discussed}} in “Techniques integrated in fuzzing” section.|$|E
40|$|Monitoring is a widely-used {{technique}} to check {{assumptions about the}} real-time behavior of a system, debug the code, or enforce the system to react if certain deadlines are passed. <b>Program</b> <b>instrumentation</b> is needed to insert monitoring code fragments into the monitored system if the monitor is implemented without hardware support. This pape...|$|E
5000|$|Flavahood - programming, multi instruments, drum <b>programming,</b> <b>instrumentation</b> ...|$|R
5000|$|WLPWR - assistant, drum <b>programming,</b> <b>instrumentation,</b> producer, <b>programming</b> ...|$|R
5000|$|<b>Programmed,</b> <b>Instrumentation</b> by, Keyboards, Piano - Frankmusik, Vince Clarke ...|$|R
40|$|Dynamic {{analysis}} of software systems requires the instrumentation of application programs with functionality to measure events {{of interest that}} occur during program execution, e. g., method calls, runtime exceptions, and variable accesses. For modern programming languages that are executed by virtual machines (Java,. NET, etc.), instrumentation techniques based on bytecode manipulation are available. Bytecode manipulation enables <b>program</b> <b>instrumentation</b> without the need to modify the source code. Modern aspect-oriented programming approaches for these languages are based on bytecode manipulation. This seminar paper should introduce <b>program</b> <b>instrumentation</b> in general, but then focus on approaches based on bytecode instrumentation for the Java virtual machine. The provided references are {{to be considered a}} starting point and it is expected to extend the literature search and present a coherent view on {{the current state of the}} art in this area. References [1] Asm java bytecode manipulation and analysis...|$|E
40|$|Service {{creation}} environments play {{a relevant}} role in new telecom applications because they enable openness and programmability by offering frameworks {{for the development}} of value added services. The JAIN SLEE specification defines a Java framework for executing event-based distributed services made up of components, called Service Building Blocks. In such a complex architecture, monitoring is an indispensable technique to test the dynamic behavior of a system, debug the code, gather usage statistics or measure the quality of service. <b>Program</b> <b>instrumentation</b> is needed to insert monitoring code into the system to be monitored, which is typically a manual and time-consuming task. This paper describes a language-based approach to automate <b>program</b> <b>instrumentation</b> and monitoring management using a dynamic Aspect Oriented Programming (AOP) framework. The basic notions of AOP {{and the use of the}} JBoss AOP framework features are described, in order to allow a highly modular and easily configurable implementation of reusable monitoring code. Using an Eclipse-based system administration console, it is possible to manage remotely the dynamic deployment and update of monitoring code in a service deployed on a JAIN-SLEE container...|$|E
40|$|Program Analysis is {{increasingly}} {{used to enhance}} program understanding and find flaws in programs. In contrast to testing, it can guarantee properties of a program. Up to now, {{in the context of}} program analysis, aspect oriented programming (AOP) has mostly been used for <b>program</b> <b>instrumentation</b> (tracing), but has not been itself subject to analytical methods. This paper identifies sources of flaws in AOP and suggests that program analysis could be used to avoid these pitfalls. The subjec...|$|E
2500|$|Shondrae [...] "Mr. Bangladesh" [...] Crawford – <b>programming,</b> <b>instrumentation,</b> {{producer}} ...|$|R
5000|$|John Feldmann - {{additional}} orchestration, <b>programming,</b> <b>instrumentation,</b> additional backing vocals ...|$|R
5000|$|Shondrae [...] "Mr. Bangladesh" [...] Crawford - <b>programming,</b> <b>instrumentation,</b> {{producer}} ...|$|R
40|$|Monitoring and {{performance}} analysis tools based on dynamic <b>program</b> <b>instrumentation</b> frameworks {{are widely used}} to help improve program's reliability {{and performance}}. However, almost all these tools suffer from substantial runtime overhead. This paper employs three methods, including multithread monitoring code instrumentation, buffer-based offline data analysis and a novel approach to construct dominant tree according to data flow forward analysis theory, to reduce the overhead. A prototype tool named DBIMAT is developed and comparative experiments show that the new tool can efficiently improve the instrumentation speed and notably reduce the overhead. © 2013 IEEE. Monitoring and performance analysis tools based on dynamic <b>program</b> <b>instrumentation</b> frameworks are widely used to help improve program's reliability and performance. However, almost all these tools suffer from substantial runtime overhead. This paper employs three methods, including multithread monitoring code instrumentation, buffer-based offline data analysis and a novel approach to construct dominant tree according to data flow forward analysis theory, to reduce the overhead. A prototype tool named DBIMAT is developed and comparative experiments show that the new tool can efficiently improve the instrumentation speed and notably reduce the overhead. © 2013 IEEE...|$|E
40|$|An {{experimental}} {{comparison of}} cache aware and cache oblivious static search tree algo-rithms is presented. Both cache aware and cache oblivious algorithms outperform classic binary search on large data sets {{because of their}} better utilization of cache memory. Cache aware algorithms with implicit pointers perform best overall, but cache oblivious algorithms do almost as well {{and do not have}} to be tuned to the memory block size as cache aware algorithms require. <b>Program</b> <b>instrumentation</b> techniques are used to compare the cache misses and instruction counts for implementations of these algorithms. ...|$|E
40|$|Abstract The Java-MaC {{framework}} is a run-time verification system for Java programs {{that can be}} used to dynamically test and enforce safety policies. This paper presents a formal model of the Java-MaC safety properties in terms of an operational semantics for Middleweight Java, a realistic subset of full Java. This model is intended to be used as a framework for studying the correctness of Java-MaC <b>program</b> <b>instrumentation,</b> optimizations, and future experimentation with run-time monitor expressiveness. As a preliminary demonstration of this model's applicability for these tasks, the paper sketches a correctness result for a simple <b>program</b> <b>instrumentation</b> scheme. 1 Introduction A run-time monitor is a process that observes the execution of a target system, verifies that the system meets a given safety property, and takes action when the system violates the property. One might use run-time monitors to halt a program that tries to gain unauthorized access to a file or to notify an administrator when a target variable exceeds some threshold. Because of their generality and potential for efficient implementation, run-time monitors are an attractive way to enforce security and other safety-critical properties. Java-MaC [12] is an instance of a Monitoring and Checking (MaC) framework developed at the University of Pennsylvania [13, 11]. The goal of the project is to apply run-time verification technology to Java programs...|$|E
5000|$|Edward [...] "DJ Eddie F" [...] Ferrell - drum <b>programming,</b> <b>instrumentation</b> ...|$|R
5000|$|In <b>programming,</b> <b>instrumentation</b> {{means the}} ability of an {{application}} to incorporate: ...|$|R
500|$|Fernando Garibay– songwriter, producer, {{background}} vocals, <b>programming,</b> <b>instrumentation</b> and arrangement, guitar, keyboards ...|$|R
40|$|Includes bibliographies. v. 1. Plenary session, {{integral}} system experiments, separate effects, foreign {{programs in}} thermal hydraulics, EPRI safety research [...] v. 2. Pressurized thermal shock, code assessment and improvement, 2 D/ 3 D research program, nuclear plant analyzer program [...] v. 3. Containment systems research, status of source term reassessment, fuel systems research program, risk analysis [...] v. 4. Materials engineering research [...] v. 5. Mechanical engineering, structural engineering, seismic research <b>program,</b> <b>instrumentation</b> and control program, research on equipment survival in accidents [...] v. 6. Human factors research, safeguards research, emergency preparedness, process control, occupational radiation protection. Mode of access: Internet...|$|E
40|$|The {{study of}} {{distributed}} systems is increasingly fundamental to a Computer Science curriculum. Yet, {{the design of}} applications to run over distributed systems is complex and mastery of fundamental concepts is challenging for students. In order to assist in distributed systems instruction, we have developed ConcurrentMentor, a visualization system for distributed programming. This system reveals {{the behavior of a}} distributed program and its underlying communication protocols while the program executes. Input to the visualization system is generated by an accompanying communication library that closely follows abstractions of communication found in distributed systems literature. No <b>program</b> <b>instrumentation</b> is required...|$|E
30|$|The {{challenge}} of low code coverage. Higher code coverage represents {{for a higher}} coverage of program execution states, and a more thorough testing. Previous work has proved that better coverage results in a higher probability of finding bugs. However, most testcases only cover the same few paths, {{while most of the}} code could not be reached. As a result, it’s not a wise choice to achieve high coverage only through large amounts of testcase generation and throwing into testing resources. Coverage-based fuzzers try to solve the problem with the help of program analysis techniques, like <b>program</b> <b>instrumentation.</b> We will introduce the detail in next section.|$|E
5000|$|Peter Wallevik - drum <b>programming,</b> <b>instrumentation,</b> keyboards, piano, producer, programming, {{background}} vocals ...|$|R
5000|$|Fernando Garibay - songwriter, producer, {{background}} vocals, <b>programming,</b> <b>instrumentation</b> and arrangement, guitar, keyboards ...|$|R
5000|$|Production, <b>programming,</b> <b>instrumentation,</b> and backing vocals for {{the album}} Efflorence (1997, Flaming Fish Music) ...|$|R
