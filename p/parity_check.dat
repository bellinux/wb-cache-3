1515|194|Public
25|$|Enhanced {{self test}} {{features}} like the L1 cache <b>parity</b> <b>check</b> (see Cache Structure in the Developers Manual, Vol 1).|$|E
500|$|It {{concerns}} the quadratic residue code of order n, extended {{by adding a}} single <b>parity</b> <b>check</b> bit. This [...] "remarkable theorem" [...] shows that this code is highly symmetric, having the projective linear group PSL2(n) as a subgroup of its symmetries.|$|E
500|$|The IEEE Richard W. Hamming Medal, {{named after}} him, is an award given {{annually}} by the Institute of Electrical and Electronics Engineers (IEEE), for [...] "exceptional contributions to information sciences, systems and technology", {{and he was}} the first recipient of this medal. The reverse side of the medal depicts a Hamming <b>parity</b> <b>check</b> matrix for a Hamming error-correcting code.|$|E
5000|$|... 4532624 <b>Parity</b> <b>checking</b> {{arrangement}} for a {{remote switching unit}} network ...|$|R
5000|$|... #Subtitle level 3: <b>Parity</b> <b>checking</b> {{limited to}} only 6 of 10 bits ...|$|R
40|$|This paper {{develops}} resource-ecient {{alternatives to}} modular redundancy for faulttolerant discrete-time (DT) linear time-invariant (LTI) dynamic systems. The proposed method extends previous approaches {{that are based}} on embedding the state of a given DT LTI dynamic system into the redundant state-space of a DT LTI dynamic system of higher state dimension. These embeddings, as well as the embeddings studied in this paper, preserve the state evolution of the original system in some linearly encoded form and allow error detection and correction to be performed through concurrent <b>parity</b> <b>checks</b> (i. e., <b>parity</b> <b>checks</b> that are evaluated {{at the end of each}} time step). The novelty of the approach developed in this paper relies on carefully choosing the redundant dynamics of the fault-tolerant implementation in a way that allows <b>parity</b> <b>checks</b> to capture the evolution of errors in the system and, based on non-concurrent <b>parity</b> <b>checks</b> (e. g., <b>parity</b> <b>checks</b> that are evaluated periodically), uniquely determine the initial value of each error, the time step at which it took place and the state variable it originally aected. The resulting error detection, identi cation and correction procedures can be performed periodically and can signi cantly reduce the overhead, complexity and reliability requirements on the checking mechanism...|$|R
5000|$|The rows of a <b>parity</b> <b>check</b> matrix are the {{coefficients}} of the <b>parity</b> <b>check</b> equations. That is, they show how linear combinations of certain digits (components) of each codeword equal zero. For example, the <b>parity</b> <b>check</b> matrix ...|$|E
5000|$|A {{generator}} matrix {{can be used}} {{to construct}} the <b>parity</b> <b>check</b> matrix for a code (and vice versa). If the generator matrix G is in standard form, [...] , then the <b>parity</b> <b>check</b> matrix for C is ...|$|E
5000|$|B1: Bit Error Monitoring. The B1 Byte {{contains}} {{the result of}} the <b>parity</b> <b>check</b> of the previous STM frame, after scrambling of the actual STM frame. This check is carried out with a Bit Interleaved <b>Parity</b> <b>check</b> (BIP-8).|$|E
40|$|Abstract—We {{present a}} new soft-decision {{majority}} decoding algorithm for Reed–Muller codes RM @ A. First, the reliabilities of P transmitted symbols are recalculated into the reliabilities of P <b>parity</b> <b>checks</b> that represent each information bit. In turn, information bits are {{obtained by the}} weighted majority that gives more weight to more reliable <b>parity</b> <b>checks.</b> It is proven that for long low-rate codes RM @ A, our soft-decision algorithm outperforms its conventional hard-decision counterpart by IH �� � @ PA 2 dB at any given output error probability. For fixed code rate and, our algorithm increases almost P times the correcting capability of soft-decision bounded distance decoding. Index Terms—Gaussian channel, majority decoding, <b>parity</b> <b>checks,</b> reliabilities. I...|$|R
40|$|Abstract—This paper {{develops}} resource-efficient {{alternatives to}} modular redundancy for fault-tolerant discrete-time (DT) linear time-invariant (LTI) dynamic systems. The proposed method ex-tends previous approaches {{that are based}} on embedding the state of a given DT LTI dynamic system into the redundant state-space of a DT LTI dynamic system of higher state dimension. These embeddings, as well as the embeddings studied in this paper, preserve the state evolution of the original system in some linearly encoded form and allow error detection and correction to be performed through concurrent <b>parity</b> <b>checks</b> (i. e., <b>parity</b> <b>checks</b> that are evaluated {{at the end of each}} time step). The novelty of the approach developed in this paper relies on carefully choosing the redundant dynamics of the fault-tolerant implementation in a way that allows <b>parity</b> <b>checks</b> to capture the evolution of errors in the system and, based on non-concurrent <b>parity</b> <b>checks</b> (e. g., <b>parity</b> <b>checks</b> that are evaluated periodically), uniquely determine the initial value of each error, the time step at which it took place and the state variable it originally affected. The resulting error detection, identification and correction procedures can be performed periodically and can significantly reduce the overhead, complexity and reliability requirements on the checking mechanism. Index Terms—Fault tolerance, transient faults, non-concurrent error detection and correction, ABFT, linear time-invariant dy-namic systems, state variable descriptions, fault-tolerant digital filters. I...|$|R
5000|$|Static RAM {{sizes of}} 8 KB general purpose with {{hardware}} <b>parity</b> <b>checking,</b> 20 bytes battery-backed with tamper-detection erase.|$|R
5000|$|Static RAM {{consists}} of 16 / 24 / 32 / 40 KB general purpose with hardware <b>parity</b> <b>check,</b> 0 / 8 KB core coupled memory (CCM) with hardware <b>parity</b> <b>check,</b> 64 / 128 bytes battery-backed with tamper-detection erase.|$|E
50|$|A {{fixed rate}} erasure code, usually {{with a fairly}} high rate, is applied as a 'pre-code' or 'outer code'. This pre-code may itself be a {{concatenation}} of multiple codes, for example in the code standardized by 3GPP a high density <b>parity</b> <b>check</b> code derived from the binary Gray sequence is concatenated with a simple regular low density <b>parity</b> <b>check</b> code. Another possibility would be a concatenation of a Hamming code with a low density <b>parity</b> <b>check</b> code.|$|E
5000|$|B2 : Bit Error Monitoring. The B2 Bytes {{contains}} {{the result of}} the <b>parity</b> <b>check</b> of the previous STM frame, except the RSOH, before scrambling of the actual STM frame. This check is carried out with a Bit Interleaved <b>Parity</b> <b>check</b> (BIP24) ...|$|E
5000|$|Static RAM {{consists}} of 4 / 6 / 8 / 16 / 32 KB general purpose with hardware <b>parity</b> <b>checking.</b>|$|R
40|$|Lee {{weight is}} more {{appropriate}} for some practical situations than Hamming weight. Bounds over the number of <b>parity</b> <b>checks</b> in terms of Hamming weight have been obtained, but such a detailed study is not available in terms of Lee weight. In this paper, considering Lee weight, we obtain a necessary bound over the number of <b>parity</b> <b>checks</b> to correct a message which has both clustered errors and errors in separate positions. Also there is a bound for codes correcting bursts with limited intensity...|$|R
5000|$|Memory errors: <b>parity</b> <b>checking</b> detects when {{a memory}} error has occurred. Error {{correction}} code (ECC) can correct limited memory errors so that processing can continue.|$|R
50|$|Each packet {{consisted}} of a 32-bit header and a 16-bit header <b>parity</b> <b>check</b> word, followed by up to 80 bytes of data and a 16-bit <b>parity</b> <b>check</b> word for the data. The header contained address information identifying a particular user {{so that when the}} Menehune broadcast a packet, only the intended user's node would accept it.|$|E
5000|$|Any [...] {{columns of}} a <b>parity</b> <b>check</b> matrix for [...] are linearly independent.|$|E
5000|$|Inner encoding: a Low Density <b>Parity</b> <b>Check</b> (LDPC) code is {{cascaded}} to the BCH ...|$|E
40|$|In {{this paper}} we develop {{fault-tolerant}} constructions for discrete-time (DT) linear time-invariant (LTI) dynamic {{systems that are}} build out of appropriately interconnected delay, adder and gain elements. More specically, we extend previously developed techniques, in which error detection and correction was based on concurrent <b>parity</b> <b>checks</b> {{at the end of}} each time step, by developing schemes that depend on non-concurrent (e. g., periodic) <b>parity</b> <b>checks.</b> Our approach relies on carefully choosing the redundant dynamics of the faulttolerant implementation in a way that allows <b>parity</b> <b>checks</b> to capture the evolution of errors in the system and determine the initial value of each error, the time at which it took place and the state variable it originally aected. The resulting (non-concurrent) error detection and identication approach signicantly reduces the overhead in terms of error detection, identi- cation and correction operations, thereby relaxing the stringent requirements on the checking mechanism...|$|R
40|$|Abstract: We {{present the}} {{construction}} of interleaving arrays for correcting clusters as well as diffuse bursts of insertion or deletion errors in constrained data. In this construction, a constrained information sequence is systematically encoded by computing {{a small number of}} <b>parity</b> <b>checks</b> and inserting markers such that the resulting code word is also constrained. Insertions and deletions lead to a shift between successive markers which can thus be detected and recovered using the <b>parity</b> <b>checks.</b> In this paper, as an example, the scheme is developed for Manchester-encoded information sequences...|$|R
50|$|Archive files {{often include}} <b>parity</b> <b>checks</b> and other {{checksums}} for error detection, for instance zip files use a {{cyclic redundancy check}} (CRC). RAR archives may include redundant error correction data (called recovery records).|$|R
5000|$|One bi bit: 5, three {{ring counter}} coded quinary bits and one <b>parity</b> <b>check</b> bit ...|$|E
50|$|Alice {{generates a}} (n − k) × n <b>parity</b> <b>check</b> matrix, H, for the code, G.|$|E
5000|$|One bi bit: 5, three binary coded quinary bits: 4 2 1 and one <b>parity</b> <b>check</b> bit ...|$|E
40|$|In this paper, we {{consider}} protection schemes for linear timeinvariant (LTI) controllers in switched systems. These controllers are often digital in nature and, as such, {{are subject to}} internal hardware malfunctions (faults). A discrete-time (DT) LTI system is usually protected against faults by embedding the state-space of the original system into the state-space of a higher dimensional redundant system. These embeddings preserve the state evolution of the original system in some encoded form, but enable error detection and correction through concurrent <b>parity</b> <b>checks</b> (i. e., <b>parity</b> <b>checks</b> that are performed {{at the end of}} each time step). In this paper, we present a systematic method of constructing linear embeddings for protecting switched DT LTI controllers. Thes...|$|R
40|$|Introduction to {{positional}} number system, signed magnitude numbers, {{floating point}} numbers, binary arithmetic: addition, subtraction, multiplication and division, Base conversion, conversion formulas with examples, one’s and two’s compliment arithmetic, Computer codes – BCD codes, gray codes, excess- 3 codes, <b>parity</b> <b>checks,</b> Hamming an...|$|R
50|$|Similarly, Hamming codes cannot detect or {{recover from}} an {{arbitrary}} three-bit error; Consider the diagram: if the {{bit in the}} green circle (colored red) were 1, the <b>parity</b> <b>checking</b> would return the null vector, indicating {{that there is no}} error in the codeword.|$|R
5000|$|RM(1, m) {{codes are}} <b>parity</b> <b>check</b> codes of length N = 2m, rate [...] and minimum {{distance}} [...]|$|E
5000|$|Enhanced {{self test}} {{features}} like the L1 cache <b>parity</b> <b>check</b> (see Cache Structure in the Developers Manual, Vol 1).|$|E
50|$|Associated {{with each}} memory {{location}} were two other bits, called C for odd <b>parity</b> <b>check</b> and M for word mark.|$|E
50|$|Simple go/no go <b>parity</b> <b>checking</b> {{requires}} that the memory have extra, redundant bits beyond those needed to store the data; but if extra bits are available, {{they can be used}} to correct, as well as detect, errors. Earlier memory as used in, for example, the IBM PC/AT (FPM and EDO memory) were available in versions that supported either no <b>checking</b> or <b>parity</b> <b>checking</b> (in earlier computers that used individual RAM chips rather than DIMM or SIMM modules, extra chips were used to store parity bits); if the computer detected a parity error it would display a message to that effect and stop. The SDRAM and DDR modules that replaced the earlier types are usually available either without error-checking or with ECC (full correction, not just parity).|$|R
30|$|In this article, we {{investigate}} alternatives for early-termination decoding of QC-LDPC codes on a stream processor using {{a form of}} the TDMP algorithm which achieves good performance with low-resolution, fixed-point arithmetic. (Early termination increases the throughput of the decoder by allowing it to exit the decoding algorithm prior to {{the maximum number of}} allowed iterations if the decoded word passes all <b>parity</b> <b>checks.)</b> We consider two algorithms in which the posterior updates and <b>parity</b> <b>checks</b> are integrated for each subset of the check nodes processed in parallel, in contrast with the standard TDMP schedule in which all <b>parity</b> <b>checks</b> for an iteration are performed after all the updates. The decoding algorithms reduce by half the data communications required between the stream processor's functional-unit clusters for each iteration of the decoder using the standard schedule. Termination rules which guarantee a valid decoded word are also specified for each integrated update-and-parity-check decoding algorithm. The probability of error and the throughput achieved with each decoding algorithm is evaluated. It is shown that properly designed integration of the update and parity-check steps results in significantly higher decoder throughput than the standard schedule of the TDMP algorithm without an increase in the decoder's probability of error.|$|R
50|$|Many {{access control}} system {{manufacturers}} adopted Wiegand technology, but were unhappy with the limitations of only 8 bits for site codes (0-255) and 16 bits for card numbers (0-65535), so they designed their own formats with varying complexity of field numbers and lengths and <b>parity</b> <b>checking.</b>|$|R
