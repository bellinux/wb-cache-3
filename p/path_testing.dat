78|1046|Public
5000|$|In {{software}} engineering, basis <b>path</b> <b>testing,</b> or structured testing, is a {{white box}} method for designing test cases. The method analyzes the control flow graph of a program to find a set of linearly independent paths of execution. The method normally uses McCabe' cyclomatic complexity {{to determine the number}} of linearly independent paths and then generates test cases for each path thus obtained. Basis <b>path</b> <b>testing</b> guarantees complete branch coverage (all edges of the control flow graph), but achieves that without covering all possible paths of the control flow graph—the latter is usually too costly. Basis <b>path</b> <b>testing</b> has been widely used and studied.|$|E
50|$|Happy <b>path</b> <b>testing</b> is a {{well-defined}} test case using known input, which executes without exception and produces an expected output.|$|E
5000|$|S. Kannan, J. Rajendran, O. Sinanoglu, and R. Karri, [...] "Sneak <b>Path</b> <b>Testing</b> of Crossbar-based Resistive Random Access Memories," [...] IEEE Transactions on Nanotechnology, vol.12, no.3, pp. 413-426, May 2013.|$|E
40|$|Content {{addressable}} memories (CAMs) {{are gaining}} popularity with computer networks. Testing costs of CAMs are extremely high owing to their unique configuration. In this paper, we {{carried out a}} transistor-level fault analysis and devise a search <b>path</b> <b>test</b> algorithm. The proposed algorithm is of the order (nl / log 2 n) compared to the brute-force algorithm of complexity (nl). For the analyzed CAM, the search <b>path</b> <b>test</b> complexity is reduced by 30 x. 1...|$|R
5000|$|A direct {{consequence}} of the closed <b>path</b> <b>test</b> is that the work done by a conservative force on a particle moving between any two points {{does not depend on}} the path taken by the particle.|$|R
50|$|Informally, a {{conservative}} force {{can be thought}} of as a force that conserves mechanical energy. Suppose a particle starts at point A, and there is a force F acting on it. Then the particle is moved around by other forces, and eventually ends up at A again. Though the particle may still be moving, at that instant when it passes point A again, it has traveled a closed path. If the net work done by F at this point is 0, then F passes the closed <b>path</b> <b>test.</b> Any force that passes the closed <b>path</b> <b>test</b> for all possible closed paths is classified as {{a conservative}} force.|$|R
50|$|One testing strategy, called basis <b>path</b> <b>testing</b> by McCabe {{who first}} {{proposed}} it, is to test each linearly independent {{path through the}} program; in this case, the number of test cases will equal the cyclomatic complexity of the program.|$|E
50|$|Negative testing {{ensures that}} {{the plot of the}} {{application}} is according to the requirements and can handle the unwanted input and user behavior. In this testing we put invalid data and see the output against the given input.We determine that application is not doing anything that it isn't supposed to do. Negative testing is also known as failure testing or error <b>path</b> <b>testing.</b> When performing negative testing exceptions are expected. This shows that your application is able to handle improper user behavior.|$|E
5000|$|Full path coverage, of {{the type}} {{described}} above, is usually impractical or impossible. Any module with a succession of [...] decisions in it can have up to [...] paths within it; loop constructs can result in {{an infinite number of}} paths. Many paths may also be infeasible, in that there is no input to the program under test that can cause that particular path to be executed. However, a general-purpose algorithm for identifying infeasible paths has been proven to be impossible (such an algorithm could be used to solve the halting problem). Basis <b>path</b> <b>testing</b> is for instance a method of achieving complete branch coverage without achieving complete path coverage.|$|E
40|$|Abstract – Since a {{logic circuit}} often {{has too many}} <b>paths</b> to <b>test</b> delay of all paths in the circuit, it is {{necessary}} for <b>path</b> delay <b>testing</b> {{to limit the number of}} <b>paths</b> to be <b>tested.</b> <b>Paths</b> to be <b>tested</b> should be ones with large delay that more likely cause a fault. In addition, a test set for the paths are required to detect other models of faults as many as possible. In this paper, we investigate criteria of path selection for <b>path</b> delay <b>testing.</b> We first define typical two criteria to be investigated here, and then experimentally show the feature of paths selected with each criterion, with respect to fault coverage of other delay fault models. From our experiments, we observe that test patterns for the longest paths cannot cover many other faults such as gate delay faults or segment delay faults. I...|$|R
40|$|The paper proposes System Dependence Graph (SDG) based {{algorithm}} {{to select}} different <b>test</b> <b>paths</b> for <b>testing</b> polymorphic call-sites. SDG, includes control and data dependencies, helps both the testers and developers of object-oriented programs {{to better understand}} the polymorphic interactions within the software. In addition, the algorithm considers only the method bindings of a polymorphic call-site having different definition sets. As a result, the number of <b>test</b> <b>paths</b> for <b>testing</b> polymorphism gets reduced. Also, the algorithm has been implemented in a prototype Graphical User Interface (GUI) based tool. The results are obtained by using the tool, which demonstrate the proposed technique...|$|R
40|$|T Multiaxial {{creep-fatigue}} tests under non-proportional {{loading conditions}} with various strain rates {{were carried out}} using a hollow cylinder specimen of a high chromium ferritic steel at 823 K in air to discuss the influence of non-proportional loading on failure life. Strain paths employed were a push-pull loading and a circle loading. The push-pull loading test is proportional strain <b>path</b> <b>test.</b> The circle loading test is non-proportional strain <b>path</b> <b>test</b> in which sinusoidal waveforms of axial and shear strains have 90 degree phase difference. The failure life is affected largely by the strain rate and the non-proportional loading. This paper presents a modified strain range for life evaluation considering the strain rate based on a non-proportional strain parameter proposed by authors. The strain range is a suitable parameter for life evaluation of tested material under non-proportional loading at high temperatur...|$|R
50|$|White-box {{testing is}} a method of testing the {{application}} {{at the level of}} the source code. These test cases are derived through the use of the design techniques mentioned above: control flow testing, data flow testing, branch testing, <b>path</b> <b>testing,</b> statement coverage and decision coverage as well as modified condition/decision coverage. White-box testing is the use of these techniques as guidelines to create an error free environment by examining any fragile code. These White-box testing techniques are the building blocks of white-box testing, whose essence is the careful testing of the application at the source code level to prevent any hidden errors later on. These different techniques exercise every visible path of the source code to minimize errors and create an error-free environment. The whole point of white-box testing is the ability to know which line of the code is being executed and being able to identify what the correct output should be.|$|E
40|$|Abstract. This paper {{identifies}} baseline {{procedures for}} verifying software for individual, small team, and large team development efforts for mission-critical and non-mission-critical software. It {{is based on}} defect-based inspections and basis <b>path</b> <b>testing.</b> Basis <b>path</b> <b>testing</b> provides a unified approach for performing unit, integration, and functional tests, whereas defect-based inspections are primarily used for verifying requirement and design documents. However, in situations where practitioners cannot afford to be as thorough as basis <b>path</b> <b>testing</b> permits, several heuristics are defined for prioritizing the remaining verification efforts and deciding which technique to apply. In addition, several studies are discussed that identify the relative merit of various verification tech-niques...|$|E
40|$|Web {{engineers}} and stake holders {{are more concerned}} about competition in web application testing. Therefore various technical activities are carried out in the process of testing a web application. Basis <b>Path</b> <b>testing</b> and graph matrices are the two test case generation techniques of white box testing. So the idea is to generate and compare the test cases using the flow graphs of the basis <b>path</b> <b>testing</b> and the graph matrices. It is not easy to find out all the test cases in the program. This fundamental problem in testing thus throws an open question, as to what would be the strategy we should adopt to find the test cases for testing. In this paper, we have compared the test cases, generated by basis <b>path</b> <b>testing</b> and graph matrices...|$|E
5000|$|The DD path graph {{is used to}} find {{independent}} <b>path</b> for <b>testing.</b>|$|R
40|$|AbstractFalmagne {{recently}} introduced {{the concept of}} a medium, a combinatorial object encompassing hyperplane arrangements, topological orderings, acyclic orientations, and many other familiar structures. We find efficient solutions for several algorithmic problems on media: finding short reset sequences, shortest <b>paths,</b> <b>testing</b> whether a medium has a closed orientation, and listing the states of a medium given a black-box description...|$|R
40|$|An elasto-plastic {{stress strain}} {{equation}} was proposed for predicting the stress strain relationships {{of sand and}} gravel in particle-crushing regions. Predicted stress strain curves were compared to those obtained from several kinds of triaxial shear tests, including multi-step stress <b>path</b> <b>tests,</b> and it was proved that the proposed equation much better predicts the measured stress strain curves than the conventional equations do...|$|R
40|$|In {{order to}} allow the {{introduction}} of safety-related digital control in nuclear power reactors, the software used by the systems must be demonstrated to be highly reliable. One method of improving software reliability is testing. A study of the complete testing of software was performed based upon past research. The literature search found two complete testing methods, only one of which, complete <b>path</b> <b>testing,</b> was feasible for use. The literature contained a practical and nearly complete testing method known as Structured <b>Path</b> <b>Testing,</b> developed by Howden (Howd 77). Structured <b>Path</b> <b>Testing</b> was adapted here {{as the basis for}} a new testing method known as Feasible Structured <b>Path</b> <b>Testing</b> (FSPT). The FSPT involves a five step formal method which examines the code's data flow structure and develops test cases based upon the analysis. The FSPT eliminates unfeasible paths from the test case which greatly speeds the testing process. The FSPT was applied to several simple programs. Many of the test programs are written in the 001 case tool language developed by Hamilton Technology (Hami 92.). The ultimate example test bed program, known as the Reactor Protection System (RPS) was written by M. Ouyang (Ouya 95) ...|$|E
40|$|Includes bibliographical {{references}} (l. 45 - 46). In this work, we formulate the <b>path</b> <b>testing</b> {{problem as}} an optimization problem by combining two previous ideas, and we propose a simulated annealing (SA) algorithm to solve it. We also improve a genetic algorithm (GA) {{that has been}} previously used. Our experimental {{results show that the}} SA and improved GA are useful for <b>path</b> <b>testing</b> and that they have comparable behavior and performance. 1 bound copy: v, 46 leaves; ill.; 30 cm. available at RNL...|$|E
40|$|ISBN: 0818633603 Scan <b>path</b> <b>testing</b> has the {{drawback}} that {{it increases}} considerably the test length. The authors first present an original technique which allows RAM scan <b>path</b> <b>testing</b> without increasing the test length. Then they compare several address generation, test data generation and output response verification techniques for RAM BIST, scanpath and BIST schemes. Automatic generation tools {{have been implemented}} for these schemes and allow to select the more efficient ones. This way one can reduce the design effort and satisfy several constraints like low area overhead, high fault coverage and low test length for embedded RAMs...|$|E
40|$|Falmagne {{recently}} introduced {{the concept of}} a medium, a combinatorial object encompassing hyperplane arrangements, topological orderings, acyclic orientations, and many other familiar structures. We find efficient solutions for several algorithmic problems on media: finding short reset sequences, shortest <b>paths,</b> <b>testing</b> whether a medium has a closed orientation, and listing the states of a medium given a black-box description. Comment: 12 page...|$|R
40|$|It is {{well known}} that the output signals {{measured}} by a test/measurement system are not only due to the device-under-test (DUT), but also due to the <b>test</b> <b>path</b> or <b>test</b> interfaces. For example, if the intersymbol interference (ISI) due to the <b>test</b> <b>path</b> is not negligible, then the performance of the DUT can be grossly underestimated or overestimated, depending on whether it is an output test or input test. In this paper, we propose a generic model with extension to high orders for both the <b>test</b> <b>path</b> and the DUT. By using a cascading model, we will illustrate the measured signals due to the <b>test</b> <b>path</b> and DUT combined, in contrast to the measured signals due to the DUT alone. We will investigate both the effect of the limited bandwidth and the effect of ringing. We will illustrate the eye-diagrams of the DUT, and conceptually identify, separate, and de-embed the impact of the <b>test</b> <b>path</b> on the eye-diagrams, resulting in accurate measurement results and yield for the DUT...|$|R
40|$|Due to the {{increased}} use of field programmable gate arrays (FP-GAs) in production circuits with high reliability requirements, the design-specific testing of FPGAs has become an important topic for research. <b>Path</b> delay <b>testing</b> of FPGAs is especially important since path delay faults can render an otherwise fault-free FPGA unusable for a given design layout. This paper presents a new approach for FPGA <b>path</b> delay <b>testing</b> which partitions target paths into subsets that are tested in the same <b>test</b> configuration. Each <b>path</b> is <b>tested</b> for all combinations of signal inversions along the path length. Each configuration consists of a sequence generator, response analyzer and circuitry for controlling inversions along <b>tested</b> <b>paths,</b> all of which are formed from FPGA resources not currently under test. Two algorithms are presented for target path partitioning to determine the number of required test configurations. Test circuitry associated with these methods is also described. The results of applying the methods indicate that our <b>path</b> delay <b>testing</b> approach requires seconds per design to cover all paths with delay within 10 % of the critical path delay. The approach has been validated using Xilinx Virtex devices. I...|$|R
40|$|Visualization of an {{algorithm}} offers only a rough {{picture of}} operations. Explanations are crucial for deeper understanding, because they help {{the viewer to}} associate the visualization with the factual meaning of each detail. We present a framework based on <b>path</b> <b>testing</b> for associating instructive explanations and assignments with a constructive self-study visualization of an algorithm. The algorithm is divided into blocks, and a description is given for each block. The system contains a separate window for code, flowchart, animation, explanations, and control. Assignments {{are based on the}} flowchart and on the coverage conditions of <b>path</b> <b>testing.</b> <b>Path</b> <b>testing</b> is expected to lead into more accurate evaluation of learning outcomes because it supports systematic instruction in addition to more free trial-and-error heuristics. A qualitative analysis of preliminary experiences with the prototype indicates that the approach helps a student to reflect on her own reasoning about the algorithm. However, a prerequisite for an successful learning process with the environment is a motivating introduction, describing both the system and the main idea of the algorithm to be learned. ...|$|E
40|$|Abstract: Testing {{plays an}} {{important}} role in the software development to identify the difficulties in process very well. In case of code based testing, <b>path</b> <b>testing</b> plays a very crucial role. The importance of <b>path</b> <b>testing</b> is to check the code coverage as well as to identify the code significance. Better the test sequence is estimated, better the testing is performed. It also affects the testing code and test case reusability. There are number of factors on which code sequence is decided. This paper presents a framework that helps in implementing dynamic programming approach that will work on the basis of fault as well as future aspects of test cases to estimate path sequence...|$|E
40|$|Testing {{is a vital}} {{component}} of software engineering. As complex programs become integrated into all aspects of society, {{it is important that}} there exist no errors that could compromise safety, security or even financial investment. In this paper, we specifically examine <b>path</b> <b>testing,</b> and how {{it can be used to}} detect errors within a piece of code. The core reason that <b>path</b> <b>testing</b> is implemented is to provide code with a level of test coverage; that is, to find out how much of a piece of software has been examined for faults. We will be examining two methods, DD-Path and Basis <b>Path</b> <b>testing,</b> each of which provide us with different test coverage metrics, as well as their own unique benefits. Much of the work carried out on these test coverage metrics actually led to important discoveries in the field of testing, such as how using only structured constructs in a piece of code can minimise the number of required test cases. This paper will provide us with an analysis of this discovery, before concluding with a brief discussion of the merits of using a structural testing method over the functiona...|$|E
5000|$|Path {{selection}} and monitoring {{to select a}} primary data transmission <b>path</b> and <b>test</b> the connectivity of the transmission path.|$|R
40|$|In this research, {{we focus}} on the {{development}} of an algorithm that is used to generate a minimal number of patterns for <b>path</b> delay <b>test</b> of integrated circuits using the multi-cycle at-speed test. We test the circuits in functional mode, where multiple functional cycles follow after the test pattern scan-in operation. This approach increases the delay correlation between the scan and functional test, due to more functionally realistic power supply noise. We use multiple at-speed cycles to compact K-longest <b>paths</b> per gate <b>tests,</b> which reduces the number of scan patterns. After a path is generated, we try to place each path in the first pattern in the pattern pool. If the path does not fit due to conflicts, we attempt to place it in later functional cycles. This compaction approach retains the greedy nature of the original dynamic compaction algorithm where it will stop if the path fits into a pattern. If the path is not able to compact in any of the functional cycles of patterns in the pool, we generate a new pattern. In this method, each <b>path</b> delay <b>test</b> is compared to at-speed patterns in the pool. The challenge is that the at-speed delay test in a given at-speed cycle must have its necessary value assignments set up in previous (preamble) cycles, and have the captured results propagated to a scan cell in the later (coda) cycles. For instance, if we consider three at-speed (capture) cycles after the scan-in operation, and if we need to place a fault in the first capture cycle, then we must generate it with two propagation cycles. In this case, we consider these propagation cycles as coda cycles, so the algorithm attempts to select the most observable path through them. Likewise, if we are placing the <b>path</b> <b>test</b> in the second capture cycle, then we need one preamble cycle and one coda cycle, and if we are placing the <b>path</b> <b>test</b> in the third capture cycle, we require two preamble cycles with no coda cycles...|$|R
40|$|Abstract – It is {{well known}} that the output signals {{measured}} by an automatic test equipment (ATE) system are not only due to the device-under-test (DUT), but also due to the <b>test</b> <b>path.</b> For example, if the intersymbol interference (ISI) due to the <b>test</b> <b>path</b> is not negligible, then the performance of the DUT can be grossly underestimated. In this paper, we propose a generic model for both the <b>test</b> <b>path</b> and the DUT. By using a cascading model, we will illustrate the measured signals due to the <b>test</b> <b>path</b> and DUT combined, in contrast to the measured signals due to the DUT alone. We will investigate both the effect of the limited bandwidth and the effect of ringing. We will illustrate the eye-diagrams of the DUT, and conceptually identify and separate the impact of the <b>test</b> <b>path</b> on the eye-diagrams. Keywords –ATE, Jitter, ISI, Eye-diagram. I...|$|R
40|$|Random {{testing of}} {{programs}} is usually (but not always) {{viewed as a}} worst case of program testing. Test case generation that takes into ac-count the program structure is usually preferred. <b>Path</b> <b>testing</b> is an often proposed ideal for structural testing. <b>Path</b> <b>testing</b> is treated here as an instance of partition testing. (Partition testing is any testing scheme which forces execu-tion {{of at least one}} test case from each subset of a partition of the input domain.) Simulation results are presented which treat path and parti-tion testing in a reasonably favorable way, and yet still suggest that random testing may often be more cost effective. ResultS of actual random testing experiments are presented which tend to confirm the viability of random testing as a use-ful validation tool...|$|E
40|$|Abstract—One {{of the key}} {{problems}} in <b>path</b> <b>testing</b> is building a path through specified set of stalemates particularly which contain loops. Traditional genetic algorithm has been successfully used in software testing activities such as finding test data, selecting test cases and test cases prioritization. In this paper, we introduce a new variable length genetic algorithm. Based on the new algorithm, we present a new strategy for automatically generating a set of basis test paths {{which can be used}} as testing paths in any basis <b>path</b> <b>testing</b> technique. We define all elements of genetic algorithm such as chromosome representation, crossover, mutation, and fitness function to be compatible with path generation. In addition, we present a case study to show the efficiency of our strategy...|$|E
40|$|AbstractIn Systems of Systems (SoS), a major {{challenge}} is {{to determine how to}} design a test suite that will check that the complete SoS mission and objectives are achieved. Combinatorial strategies that test for every interface in the SoS are not always optimal due to their exponential nature, and given the mission of the SoS, not all the constituent systems might have to actually interact with each other. To overcome these problems, this paper proposes the use of Basis <b>Path</b> <b>Testing,</b> which is a white-box software testing technique that makes use of Graph Theory to analyse the complexity of a structured system by creating a control flow graph from each of the program's functions to design an optimal test suite. This test suite is a set of paths that traverse through the functions, which are assumed linearly independent and {{that can be used to}} create a test strategy that will exercise all of the program's functions at least once to verify and validate their functionality. By applying Basis <b>Path</b> <b>Testing</b> analysis to the constituent systems in a SoS, the tester can develop an optimal test suite that will guarantee that all possible independent paths, all possible logical decisions, and all their interfaces are executed at least once. This paper presents a SoS sample architecture and show how to generate a test suite using Basis <b>Path</b> <b>Testing</b> analysis...|$|E
40|$|This paper proposes an {{approach}} to non-robust and functionally sensitizable <b>path</b> delay <b>test</b> generation through stuck-at test generation. In this approach, to generate two-pattern <b>tests</b> for <b>path</b> delay faults in a combinational circuit, checker circuitry is constructed which is composed of logic gates corresponding to the mandatory assignments for detecting the faults. This checker circuitry allows us to use any existing combinational stuck-at test generation tool. Since today's stuck-at test generation tools reach a mature level, the proposed approach can efficiently solve the <b>path</b> delay <b>test</b> generation problem for combinational circuits. Experimental {{results show that the}} approach can speed up <b>path</b> delay <b>test</b> generation and can improve fault efficiency. This paper also discusses how a scan circuit and the issues of over-testing and test power are handled in the proposed test generation framework...|$|R
40|$|The {{extended}} finite {{state machine}} is a powerful model that can capture almost all the aspects of a system. However, testing from an EFSM is yet a challenging task due to two main problems: path feasibility and <b>path</b> <b>test</b> data generation. Although optimization algorithms are efficient, their applications to EFSM testing have received very little attention. The aim {{of this paper is}} to develop a novel approach that utilizes optimization algorithms to test from EFSM models...|$|R
40|$|Content {{addressable}} memories (CAMs) {{are gaining}} popularity with computer networks. Testing costs of CAMs are extremely high owing to their unique configuration. In this thesis, a fault analysis {{is carried out}} on an industrial ternary CAM (TCAM) design, and search <b>path</b> <b>test</b> algorithms are designed. The proposed algorithms are able to test the TCAM array, multiple-match resolver (MMR), and match address encoder (MAE). The tests represent a 6 x decrease in test complexity compared to existing algorithms, while dramatically improving fault coverage...|$|R
