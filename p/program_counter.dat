479|217|Public
5|$|Each 32-bit word of RAM could contain {{either a}} program {{instruction}} or data. In a program instruction, bits 0–12 represented the memory {{address of the}} operand to be used, and bits 13–15 specified the operation to be executed, such as storing a number in memory; the remaining 16bits were unused. The SSEM's single operand architecture meant that the second operand of any operation was implicit: the accumulator or the <b>program</b> <b>counter</b> (instruction address); program instructions specified only {{the address of the}} data in memory.|$|E
5|$|The machine's most {{significant}} innovation {{is generally considered}} to be its incorporation of index registers, commonplace on modern computers. The SSEM had included two registers, implemented as Williams tubes: the accumulator (A) and the <b>program</b> <b>counter</b> (C). As A and C had already been assigned, the tube holding the two index registers, originally known as B-lines, was given the name B. The contents of the registers could be used to modify program instructions, allowing convenient iteration through an array of numbers stored in memory. The Mark 1 also had a fourth tube, (M), to hold the multiplicand and multiplier for a multiplication operation.|$|E
25|$|Branch {{instructions}} have a 6-bit opcode field, a 5-bit Ra {{field and}} a 21-bit displacement field. The Ra field specifies a register {{to be tested}} by a conditional branch instruction, and if the condition is met, the <b>program</b> <b>counter</b> is updated by adding {{the contents of the}} displacement field with the <b>program</b> <b>counter.</b> The displacement field contains a signed integer and if the value of the integer is positive, if the branch is taken then the <b>program</b> <b>counter</b> is incremented. If the value of the integer is negative, then <b>program</b> <b>counter</b> is decremented if the branch is taken. The range of a branch thus is ±1 Mi instructions, or ±4 MiB. The Alpha Architecture was designed with a large range as part of the architecture's forward-looking goal.|$|E
5000|$|In February 2017, sources {{claimed that}} the Trump {{administration}} intends to rename and revamp the U.S. government <b>program</b> <b>Countering</b> Violent Extremism (CVE) to solely focus on Islamist extremism.|$|R
5000|$|A worthy {{companion}} to INTERCAL; a computer language family which escapes the quotidian limitation of linear control flow and embraces <b>program</b> <b>counters</b> flying through multiple dimensions with exotic topologies. Jargon File ...|$|R
50|$|Mill uses a {{very long}} {{instruction}} word (VLIW)-style encoding to store up to 33 simple operations in wide instruction words, termed opcodes. Mill uses two <b>program</b> <b>counters,</b> and every wide instruction is split into two parts. One of the <b>program</b> <b>counters</b> counts backward. So, the code of every linear instruction block is executed from its middle to outside by two almost independent decoders. Unused operations are deleted by a small fixed-format data item {{in the center of}} each instruction. This helps maintain code density by reducing the incidence of no-operation codes in Mill code. It also allows each functional unit to start speculatively executing its instruction field, and then discard its result if it has no instruction.|$|R
25|$|R15 is also {{referred}} to as PC, the <b>Program</b> <b>Counter.</b>|$|E
25|$|The <b>program</b> <b>counter</b> (PC) is {{no longer}} {{directly}} accessible as a register.|$|E
25|$|Uniform 16× 32-bit {{register}} file (including the <b>program</b> <b>counter,</b> {{stack pointer}} and the link register).|$|E
40|$|We {{present a}} {{symbolic}} model checking approach that allows verifying {{a unit of}} code, e. g., a single procedure or a collection of procedures that interact with each other. We allow temporal specification that make assertions about both the <b>program</b> <b>counters</b> and the <b>program</b> variables. We decompose the verification into two parts: (1) a search {{that is based on}} the temporal behavior of the <b>program</b> <b>counters,</b> and (2) the formulation and refutation of a path condition, which. inherits conditions on the program variables from the temporal specification. This verification approach is modular, as there is no requirement that all the involved procedures are provided. Furthermore, we do not require that the code is based on a finite domain. The presented approach can also be used for automating the generation of test cases for unit testing...|$|R
40|$|Reducing energy {{consumption}} {{has become one}} of the major challenges in designing future computing systems. This paper proposes a novel idea of using <b>program</b> <b>counters</b> to predict I/O activities in the operating system. The paper presents a complete design of Program-Counter Access Predictor (PCAP) that dynamically learns the access patterns of applications and predicts when an I/O device can be shut down to save energy. PCAP uses path-based correlation to observe a particular sequence of <b>program</b> <b>counters</b> leading to each idle period, and predicts future occurrences of that idle period. PCAP differs from previously proposed shutdown predictors in its ability to: (1) correlate I/O operations to particular behavior of the applications and users, (2) carry prediction information across multiple executions of the applications, and (3) attain better energy savings while incurring low mispredictions. 1...|$|R
50|$|The system {{employed}} The Multiple-Sequence Program Technique. This technique allowed multiple <b>program</b> <b>counters</b> to each {{associate with}} one of 32 possible sequences of program code. These explicitly prioritized sequences could be interleaved and executed concurrently, affecting not only the computation in process, but also the control flow of sequences and switching of devices as well. Much discussion related to device sequencing.|$|R
25|$|The <b>program</b> <b>counter</b> has 32 bits. The two low-order bits always contain zero since MIPS I {{instructions}} are 32 bits long and are aligned to their natural word boundaries.|$|E
25|$|The <b>program</b> <b>counter</b> is a 64-bit {{register}} {{which contains}} a longword-aligned virtual byte address, that is, the low two {{bits of the}} <b>program</b> <b>counter</b> are always zero. The PC is incremented by four to {{the address of the}} next instruction when an instruction is decoded. A lock flag and locked physical address register are used by the load-locked and store-conditional instructions for multiprocessor support. The floating-point control register (FPCR) is a 64-bit register defined by the architecture intended for use by Alpha implementations with IEEE 754-compliant floating-point hardware.|$|E
25|$|An exploit will {{commonly}} inject a shellcode {{into the}} target process before {{or at the}} same time as it exploits a vulnerability to gain control over the <b>program</b> <b>counter.</b> The <b>program</b> <b>counter</b> is adjusted to point to the shellcode, after which it gets executed and performs its task. Injecting the shellcode is often done by storing the shellcode in data sent over the network to the vulnerable process, by supplying it in a file that is read by the vulnerable process or through the command line or environment in the case of local exploits.|$|E
50|$|Extracode mode {{had its own}} <b>program</b> address <b>counter,</b> {{and easy}} access to the {{instruction}} operands.|$|R
5000|$|Member, Standing Committee on Support to the DoD's <b>Programs</b> to <b>Counter</b> Biological Threats, National Research Council ...|$|R
40|$|This article {{examines}} recent trends and developments {{in an increasingly}} popular HR practice [...] incentive pay programs. In addition to highlighting major developments in recent empirical studies, this article also synthesizes recent research pertaining to general guidelines or strategies for design, implementation, and the utilization of incentive pay <b>programs.</b> <b>Counter</b> arguments pointing out potential pitfalls and precautions will also be discussed. The article concludes by offering some recommendations for future research...|$|R
25|$|At {{the level}} of machine {{language}} or assembly language, control flow instructions usually work by altering the <b>program</b> <b>counter.</b> For some central processing units (CPUs), the only control flow instructions available are conditional or unconditional branch instructions, also termed jumps.|$|E
25|$|Unconditional {{branches}} {{update the}} <b>program</b> <b>counter</b> {{with a new}} address computed {{in the same way}} as conditional branches. They also save the address of the instruction following the unconditional branch to a register. There are two such instructions, and they differ only in the hints provided for the branch prediction hardware.|$|E
25|$|The {{architecture}} {{defined a}} set of 32 integer registers and {{a set of}} 32 floating-point registers in addition to a <b>program</b> <b>counter,</b> two lock registers and a floating-point control register (FPCR). It also defined registers that were optional, implemented only if the implementation required them. Lastly, registers for PALcode were defined.|$|E
5000|$|Opium Season, {{the true}} story of a young American in Afghanistan running an aid <b>program</b> to <b>counter</b> the opium trade ...|$|R
50|$|Opium Season is {{the true}} story of a young American in Afghanistan running an aid <b>program</b> to <b>counter</b> the opium trade.|$|R
40|$|Abstract. This paper {{describes}} a logic of progress for concurrent programs. The logic {{is based on}} that of UNITY, molded to fit a sequential programming model. Integration of the two is achieved by using auxiliary variables in a systematic way that incorporates <b>program</b> <b>counters</b> into the <b>program</b> text. The rules for progress in UNITY are then modified to suit this new system. This modification is however subtle enough to allow the theory of Owicki and Gries to be used without change. 1...|$|R
25|$|There {{are four}} jump {{instruction}}s. These all perform the same operation, saving {{the address of}} the instruction following the jump, and providing the <b>program</b> <b>counter</b> with a new address from a register. They differ in the hints provided to the branch prediction hardware. The unused displacement field is used for this purpose.|$|E
25|$|A stored-program {{computer}} {{requires an}} initial computer program stored in its read-only memory to boot. The boot {{process is to}} identify and initialize {{all aspects of the}} system, from processor registers to device controllers to memory contents. Following the initialization process, this initial computer program loads the operating system and sets the <b>program</b> <b>counter</b> to begin normal operations.|$|E
25|$|The ARM2 {{featured}} a 32-bit data bus, 26-bit address space and 2732-bit registers. Eightbits from the <b>program</b> <b>counter</b> register {{were available for}} other purposes; the top sixbits (available because of the 26-bit address space) served as status flags, and the bottom twobits (available because the <b>program</b> <b>counter</b> was always word-aligned) were used for setting modes. The address bus was extended to 32bits in the ARM6, but program code still had to lie within the first 64MB of memory in 26-bit compatibility mode, due to the reserved bits for the status flags. The ARM2 had a transistor count of just 30,000, compared to Motorola's six-year-older 68000 model with around 40,000. Much of this simplicity came {{from the lack of}} microcode (which represents about one-quarter to one-third of the 68000) and from (like most CPUs of the day) not including any cache. This simplicity enabled low power consumption, yet better performance than the Intel 80286. A successor, ARM3, was produced with a 4KB cache, which further improved performance.|$|E
50|$|The NESA Center has {{implemented}} <b>programs</b> on <b>countering</b> ideological {{support for}} terrorism, increasing and improving strategic communication and outreach {{to the region}} and supporting other strategic goals.|$|R
30|$|OProfile <b>programs</b> {{hardware}} <b>counters</b> {{to calculate}} the number of user-specified performance events and to generate a non-maskable interrupt (NMI) when the counter has counted to the user-specified count.|$|R
40|$|Abstract—This paper {{presents}} a new hardware prefetcher {{based on the}} idea of the Global History Buffer proposed in [4]. We extend this idea to Local History Buffers, which keep the memory access information for selective <b>program</b> <b>counters.</b> These buffers can then be queried on cache accesses to predict future memory accesses and enable data prefetching. Our trace-driven simulations show that by using approximately a 4 KByte (32 Kbits) storage budget, an average performance improvement of 20 % (geomean) can be obtained for SPEC benchmark suite on an ideal out-of-order processor. I...|$|R
25|$|Among the {{significant}} enhancements {{introduced in the}} 6809 were the use of two 8-bit accumulators (A and B, which could be combined into a single 16-bit register, D), two 16-bit index registers (X, Y) and two 16-bit stack pointers. The index and stack registers allowed advanced addressing modes. <b>Program</b> <b>counter</b> relative addressing allowed for the easy creation of position-independent code, while a user stack pointer (U) facilitated the creation of reentrant code.|$|E
25|$|One more {{issue is}} that some complex {{instructions}} are difficult to restart, e.g. following a page fault. In some cases, restarting from the beginning will work (although wasteful), {{but in many cases}} this would give incorrect results. Therefore, the machine needs to have some hidden state to remember which parts went through and what remains to be done. With a load/store machine, the <b>program</b> <b>counter</b> is sufficient to describe the state of the machine.|$|E
25|$|Each multi-threaded MIPS core {{can support}} {{up to two}} VPEs (Virtual Processing Elements) which share a single {{pipeline}} {{as well as other}} hardware resources. However, since each VPE includes a complete copy of the processor state as seen by the software system, each VPE appears as a complete standalone processor to an SMP Linux operating system. For more fine-grained thread processing applications, each VPE is capable of supporting up to nine TCs allocated across two VPEs. The TCs share a common execution unit but each has its own <b>program</b> <b>counter</b> and core register files so that each can handle a thread from the software.|$|E
40|$|Abstract. This paper {{presents}} a new architecture model, named Weld, for VLIW processors. Weld integrates multithreading support into a VLIW processor to hide run-time latency effects that cannot {{be determined by}} the compiler. It does this through a novel hardware technique called operation welding that merges operations from different threads to utilize the hardware resources more efficiently. Hardware contexts such as <b>program</b> <b>counters</b> and fetch units are duplicated to support multithreading. The experimental results show that the Weld architecture attains a maximum of 27 % speedup as compared to a single-threaded VLIW architecture. 1...|$|R
5000|$|... <b>program</b> Factorial1;var <b>Counter,</b> Factorial: integer;begin Counter := 5; Factorial := 1; while Counter > 0 do;;;; begin Factorial := Factorial * Counter; Counter := Counter - 1 end; WriteLn(Factorial)end.|$|R
40|$|This paper {{proposes a}} new {{hardware}} prefetcher that extends {{the idea of}} the Global History Buffer (GHB) originally proposed in [1]. We augment the GHB with several Local History Buffers (LHBs), which keep the memory access information for selective <b>program</b> <b>counters.</b> These buffers can then be queried on cache accesses to predict future memory accesses and enable data prefetching using novel detection schemes. Our trace-driven simulations show that by using approximately a 4 KByte (32 Kbits) storage budget, we can obtain an average performance improvement of 22 % for SPEC 2006 benchmark suite on an ideal out-of-order processor. 1...|$|R
