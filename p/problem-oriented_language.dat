11|11|Public
50|$|While {{developing}} the MADIDDA, the design team {{came to realize}} that a digital differential analyzer could be run on a general-purpose digital computer through the use of an appropriate <b>problem-oriented</b> <b>language</b> (POL), such as Dynamo. A year after the first MADIDDA was demonstrated, Steele and the MADDIDA design team left Northrop, along with Irving S. Reed, in order to develop general-purpose computers. On July 16, 1950 they formed the Computer Research Corporation (CRC), which in 1953 was sold to NCR.|$|E
50|$|The {{founding}} {{owners of}} CRC were Floyd Steele, Donald Eckdahl, Hrant (Harold) Sarkinssian, Richard Sprague, and Irving S. Reed. With {{the exception of}} Reed, {{all members of the}} CRC had been on the design team for the MADDIDA, a special-purpose digital computer developed from 1946-49 for Northrop. Realizing that a <b>Problem-Oriented</b> <b>Language</b> (POL) could be used to make a general-purpose computer function as a differential analyzer, the MADDIDA design team left Northrup in 1950 to focus on designing general-purpose computers, leading to them to found the CRC. After developing the Cadac, an early minicomputer, the CRC was sold to National Cash Register (NCR) in February 1953, launching NCR into the digital computing business.|$|E
40|$|A domain-specific {{language}} is a specialized and <b>problem-oriented</b> <b>language.</b> Successful application of a DSL largely depends on provided tools, so called language workbenches that support end-programmers creating, editing, and maintaining programs written in a DSL. In this paper, we describe four different tools support-ing the creating of language workbenches, identify commonalities and differences and compare these tools {{by means of a}} set of cri-teria. 1. Introdcution Domain-specific languages (DSL) are languages tailored to a specific application domain [1]. They have the potential to reduce complexity of software development by raising the abstraction level towards an application domain. According to the application domain, different notations (textual, graphical, tabular) are used...|$|E
40|$|The phenomenal {{impact and}} {{influence}} of electronic computers on present-day technology has already been felt in most areas of structural engineering. Numerous structural analysis and design programs have been developed, including some large systems based on <b>problem-oriented</b> <b>languages.</b> However, {{due to the nature}} of most available computers, the vast majority of existing programs are geared to a batch processing environment. The Office of Naval Research Department Of The Navy. Contract Nonr 1834 (03), Project NR- 064 - 18...|$|R
40|$|For {{systems that}} share enough {{structural}} and functional commonalities, reuse in schema development and data manipulation {{can be achieved}} by defining <b>problem-oriented</b> <b>languages.</b> Such languages are often called domainspecific, because they introduce powerful abstractions meaningful only within the domain of observed systems. In order to use domain-specific languages for database applications, a mapping to SQL is required. In this paper, we deal with metaprogramming concepts required for easy definition of such mappings. Using an example domain-specific language, we provide an evaluation of mapping performance...|$|R
40|$|This paper gives {{a formal}} {{definition}} of SOL, a general-purpose algorithmic language useful for describing and simulating complex systems. SOL is described using meta-linguistic formulas {{as used in}} the definition of ALGOL 60. The principal differences between SOL and <b>problem-oriented</b> <b>languages</b> such as ALGOL or FORTRAN is that SOL includes capabilities for expressing parallel computation, convenient notations for embedding random quantities within arithmetic expressions and automatic means for gathering statistics about the elements involved. SOL differs from other simulation languages such as SIMSCRIPT primarily in simplicity of use and in readability since it is capable of describing models without including computer-oriented characteristics...|$|R
40|$|The {{procedure}} of constructing situation models for {{solution of the}} non-production problems in the organizing-managerial systems (OMS) has been proposed; the method for dynamic grouping of the non-production problem executors has been developed; the <b>problem-oriented</b> <b>language</b> for logic-linquistic description of the functional OMS structure has been substantiated; the algorithm for choice of the cost-effective problem automation boundaries and evaluations of the advantage caused by a use of the workbench has been developed. The work results have been approved and are used at the Pilot Plant "Antikor" of the State Enterprise of Fuel-Power Complex (St. -Petersburg) and St. -Petersburg State Academy of Aero-Cosmic Instrument MakingAvailable from VNTIC / VNTIC - Scientific & Technical Information Centre of RussiaSIGLERURussian Federatio...|$|E
40|$|Abstract: The most {{rational}} mode {{of communication}} between intelligent robot and human-operator is bilateral speech dialogue using a <b>problem-oriented</b> <b>language.</b> The dialogue mode of control raises the problem of compliance between the human and robot perception of external world, logic, behavior planning and decision making. We suppose that linguistic variables and fuzzy logic is the most suitable approach for the mentioned problems. The model of the world formed {{on the base of}} natural space-time relations allows formulating the basic robot operations in terms of linguistic variables and {{to solve the problem of}} planning of robot behavior in previously undetermined environment. Using the fuzzy neural networks it is possible to train robot to fulfill complicated operations by human-operator. Relationship between fuzzy logic approach and the procedures of speech recognition are also under consideratio...|$|E
40|$|Code Generation is an {{increasing}} popular technique for implementing families of similar software products, where the code is automatically synthesized from abstract specifications written in Domain Specific Languages (DSLs) [2]. DSL compilers usually work as any general purpose language compiler: analyzing the source code and (a) synthesizing the final code from scratch or (b) transforming the source code into the final code. Hence, when a DSL compiler is developed the next paradox usually comes up. A DSL is a specialized, <b>problem-oriented</b> <b>language.</b> From {{the point of view}} of the DSL user, it is interesting that the DSL is as abstract as possible (supporting the domain terminology and removing the low-level implementation details). On the other hand, from {{the point of view of}} the compiler developer, the DSL abstraction makes harder to build the compiler. Tha...|$|E
40|$|In {{an effort}} to gain an overviev, of the {{application}} of computer technology in education and training, to identify areas requiring additional research, and to identify/potential application areas for use in technical training, field viz its were made to representative military and civilian institutions which are using the literature and computer equipment manufacturers, technical data was computer in instructional programs. A revi/. 0 of the recent research also conducted. The primary focus of the/study was on the terminal devices available {{for use in a}} training/system and on the software required for effective use of a computer in a training environment. Several c(mputer terminals used in computer assisted instruction (CAI) are discussed and computer-controlled audio presentation is described. Programing languages which have been used in CAI are categorized into four groups: general-purpose problem languages, extended problem languages, interactive terminal problem <b>languages,</b> and author-student <b>problem-oriented</b> <b>languages.</b> A typical language from each category is examined. On the basis of their survey, the authors make some suggestions regarding terminal devices, programing languages, and areas for further research. (JY) AIR FORCE N...|$|R
40|$|This paper {{deals with}} <b>problem-oriented</b> visual <b>languages</b> used for solving design tasks during the {{conceptual}} design phase. Visualization of early design solutions {{by means of}} visual languages requires an appropriate design knowledge representation in computer systems. The continuation of our method to develop a knowledge-based decision support design system is presented. It consists in connecting a graph-based knowledge representation with a design reasoning method which uses first-order logic formulas. The design diagrams being elements of a visual language are automatically transformed into hierarchical hypergraphs and then information stored in these hypergraph data structures is translated to formulas of the first-order logic forming design knowledge. Modifications of design diagrams cause changes in logic formulas, which can be traced by the designer. The approach is illustrated by examples of designing floor layouts and navigating robots in them...|$|R
40|$|In {{this paper}} a {{specification}} language for sequential file processing is defined. For a rich subset of this language the decidability {{of the program}} verification problem is proved. The crucial point is the introduction of "constructive " equality between values on the input and output of the program that is weaker than the common mathematical equality predicate. Informally the "constructive" equality {{could be interpreted as}} an assertion of the type "a value has been copied from the input to the output of the program". The program verification faces two problems:. there does not exist a convenient language to describe assertions about programs. the Program Verification Problem is algorithmically undecidable in general case There may be two approaches to manage these problems:. to develop <b>problem-oriented</b> specification <b>languages</b> to express program properties. to look for such classes of programs and specifications for which the problem of checking whether the program meets the s [...] ...|$|R
40|$|The <b>problem-oriented</b> <b>language</b> PROJECT, {{of which}} this {{research}} forms a part, {{was developed in}} order to facilitate the use of CPM and PERT on any project which can be described in terms of work items. The area with which this thesis deals is that of monitoring a project's prog-ress. As is true {{of the rest of the}} PROJECT subsystem, nc special com-puter knowledge is necessary to use this feature since all instructions to the computer are couched in the language of project management. The preparation of PROJECT'S progress control capability was marked by two phases. The first phase centered around the development of the measures to be used as monitors. The concept underlying this de-velopmental work was that of comgarison,. Actual work progress and costs are compared with estimated work progress and costs in order to determine a project's status. In addition to being able to determine the status of the project as a single entity, the status of any subset of activities called sub-networks — can be determined also. The second phase of this research was concerned with interfacing the monitoring feature with PROJECT. It was during the implementation phase that the algorithms developed earlier were translated into workable computer programs, compatible with PROJECT...|$|E
40|$|User {{interfaces}} {{for large}} distributed applications have to handle specific problems: {{the complexity of}} the application itself and the integration of online-data into the user interface. A main task of the user interface architecture is to provide powerful tools to design and augment the end-user system easily, hence giving the designer more time to focus on user requirements. Our experiences developing a user interface system for a process control room showed that a lot of time during the development process is wasted for the integration of online-data residing anywhere but not in the user interface itself. Furtheron external data may be kept by different kinds of programs, e. g. C-programs running a numerical process model or PROLOG-programs running a diagnosis system, both in parallel to the process and in parallel to the user interface. Facing these specific requirements, we developed a user interface architecture following two main goals: 1. integration of external information into high-level graphical objects and 2. the system should be open for any program running as a separate process using its own <b>problem-oriented</b> <b>language.</b> The architecture is based on two approaches: an asynchronous, distributed and language independent communication model and an object model describing the problem domain and the interface using object-oriented techniques. Other areas like rule-based programming are involved, too. With this paper, we will present the XAVIA user interface architecture, the (as far as we know) first user inteface architecture, which is consequently based on a distributed object model...|$|E
40|$|This note {{describes}} general installation {{procedures for}} the ELLPACK 77 system. This set of programs is the software product of the ELLPACK project [2] to develop a research and educational tool to evaluate software for solving elliptic partial differential equations. SYSTEM OVERVIEW ELLPACK 77 allows its users to pose a linear elliptic partial differential equation with general boundary conditions on a rectangular domain {{in two or three}} dimensions and to specify the names of procedures to be used to solve the problem. This ELLPACK input is coded in a simple, high-level <b>problem-oriented</b> <b>language</b> which is recognized by the ELLPACK Preprocessor. This preprocessor, a FORTRAN program, accepts this input and generates another FORTRAN program, the ELLPACK control program, which performs the requested tasks by specifying calls to FORTRAN subprograms in a library of programs called the ELLPACK modules. When the generated control program executes, then, it solves the problem specified in the original input using the methods described and produces the output requested. Information on preparing input for FLLPACK 77 is found in [3] and details on adding modules is contained in [4], It is assumed that the reader is familiar with both these documents in what follows. The system described here was developed on the CDC 6500 computing system at Purdue University with modules contributed from a number of sources. Various versions of ELLPACK have since run on a number of different computing system...|$|E
40|$|The deep {{semantics}} of {{a scheme}} {{is defined as}} a set of programs derivable from the scheme. A uniform way of representing deep semantics of schemes is introduced based on the usage of a program synthesizer. An implementation of structural synthesis of programs in the NUT system and visual tools built on top of it are described. A visual compositional programming technique based on these tools is demonstrated on a number of examples. 1. Department of Teleinformatics, Royal Institute of Technology, Kista, Sweden 2 1. Introduction A visual programming tool is described in this paper which is intended for compositional programming. It can be, first of all, used for developing <b>problem-oriented</b> visual <b>languages</b> in engineering domains. Visual compositional programming can be considered as an extension of visual object-oriented programming thoroughly discussed in [1]. The extension lies in different encapsulation of objects and different usage of classes which is inherent to the NUT system [ [...] ...|$|R
40|$|Exploiting {{locality}} is {{a central}} goal of translating <b>problem-oriented</b> parallel programming <b>languages</b> for distributed memory parallel machines. Modula- 2 * places the burden of automatically deriving good data and process distribution on the compiler. In this paper we present a technique implemented in our optimizing compiler that enhances locality in a source-to-source transformation. Analysis of data access patterns and parallel operations leads to an arrangement graph. Processing of this graph reveals conflicting arrangements. Some assumptions and a heuristic based on dynamic programming enables the compiler {{to find the best}} alignment in logarithmic time. The technique has improved runtime performance on benchmarks by over 60 %. ...|$|R
40|$|The aim of {{this project}} is to design and develop PEAK, a multi-layer, multi-target, {{intelligent}} programming environment for the efficient solution of numerical problems {{on a variety of}} parallel machines. At the highest level, a numerical problem may be formulated in a <b>problem-oriented</b> specification <b>language,</b> using familiar mathematical concepts such as PDEs or ODEs. The system provides a rich set of automatic tools which transform specifications step by step into machine specific Fortran dialects that exploit the inherent parallelism of the given machine. Fortran 90, the new Fortran standard, plays {{a central role in the}} environment by serving as a target as well as a source language. We strive to make the program development process as automatic as possible, implementing an expert system approach that is supported by extensive analysis and guided by knowledge about algorithms, machines, program performance and heuristics. On the other hand, since automatic translation will not produce optimal or near-optimal results under all circumstances, the system will be designed to be interactive, allowing the user to furnish relevant strategic information and the system to explain the reasoning behind its transformation decisions...|$|R
40|$|This thesis {{document}} was issued {{under the authority}} of another institution, not NPS. At the time it was written, a copy was added to the NPS Library collection for reasons not now known. It has been included in the digital archive for its historical value to NPS. Not believed to be a CIVINS (Civilian Institutions) title. The <b>problem-oriented</b> <b>language</b> PROJECT, of which this research forms a part, was developed in order to facilitate the use of CPM and PERT on any project which can be described in terms of work items. The area with which this thesis deals is that of monitoring a project's progress. As is true {{of the rest of the}} PROJECT subsystem, no special computer knowledge is necessary to use this feature since all instructions to the computer are couched in the language of project management. The preparation of PROJECT's progress control capability was marked by two phases. The first phase centered around the development of the measures to be used as monitors. The concept underlying this developmental work was that of comparison. Actual work progress and costs are compared with estimated work progress and costs in order to determine a project's status. In addition to being able to determine the status of the project as a single entity, the status of any subset of activities-­ called sub-networks [...] can be determined also. The second phase of this research was concerned with interfacing the monitoring feature with PROJECT. It was during the implementation phase that the algorithms developed earlier were translated into workable computer programs, compatible with PROJECT. [URL] junior Grade, United States Nav...|$|E
40|$|Research {{into the}} {{cognitive}} aspects of programming {{originated in the}} study of professional programmers (whether experts or students). Even “end-user” programmers in previous studies have often worked in organizations where programming is recognized to be demanding professional work – the term “power-user” recognizes this technical kudos. But as personal computers become widespread, and most new domestic appliances incorporate microprocessors, many people are engaging in programming-like activities in domestic or nonprofessional contexts. Such users often have less motivation and more obstacles to programming, meaning that they may be unlikely even to take the first steps. This paper analyses the generic nature of those first steps, and identifies the cognitive demands that characterize them. On the basis of this analysis we propose the Attention Investment model, a cognitive model of programming that offers a consistent account of all programming behaviour, from professionals to end-users. 1. What is Programming? Goodell’s excellent website devoted to end user programming [10] offers definitions of “end user ” and “end user programming”, but not of “programming”. This may not seem a serious omission, as most researchers in computer science use implicit definitions that seem quite adequate for their professional work. Nevertheless, this paper considers the possibility that challenging the implicit professional definitions of programming may generate important insights for the study of end user programming. Programming is in fact seldom defined in modern research publications. An earlier programming textbook from 1959 gives a typical formulation for that time: “This sequence [of basic operations] is called the program and the process of preparing it is called programming ” [32, p. 4]. Programming is the “spadework ” of finding a precise mathematical formulation and method of solution, possibly notated in a “convenient <b>problem-oriented</b> <b>language</b> ” whose symbols are “more closely related to the mathematical problem to be solved”...|$|E
40|$|Abstract. Often {{an ad hoc}} {{programming}} language integrating features from different {{programming language}}s and paradigms represents the best choice to express a concise and clean solution to a problem. But, developing a programming language {{is not an easy}} task and this often discourages from developing your <b>problem-oriented</b> or domain-specific <b>language.</b> To foster DSL development and to favor clean and concise problem-oriented solutions we developed Neverlang. The Neverlang framework provides a mechanism to build custom programming languages up from features coming from different languages. The composability and flexibility provided by Neverlang permit to develop a new programming language by simply composing features from previously developed languages and reusing the corresponding support code (parsers, code generators, In this work, we explore the Neverlang framework and try out its benefits in a case study that merges functional programming àlaPython with coordination for distributed programming as in Linda...|$|R
40|$|The {{increasing}} {{availability of}} substantial computer power at relatively low {{costs and the}} increasing ease of using computer graphics, of communicating with other computers and data bases, and of programming using high-level <b>problem-oriented</b> computer <b>languages,</b> is providing new opportunities and challenges for those developing and using hydrologic and water resources models. This paper reviews some of the progress made towards the development and application of computer support systems designed to aid those involved in analyzing hydrologic data and in operating, managing, or planning water resource facilities. Such systems of hardware and software are being designed to allow direct and easy access to a broad and heterogeneous group of users. These systems often combine data-base management; simulation and optimization techniques; symbolic colored displays; heuristic, qualitative approaches; and possibly artificial intelligence methods in an interactive, user-controlled, easily accessible interface. Individuals involved {{in the use of}} such systems are not only those with technical training, but also those representing different interest groups and having non-technical backgrounds. The essential difference between what is happening now and the more traditional off-line, non-interactive approaches is that instead of generating solutions to specific problems, model developers are now beginning to deliver, in a much more useful and user-friendly form, computer-based turnkey systems for exploring, analyzing and synthesizing plans or policies. Such tools permit the user to evaluate alternative solutions based on his or her own objectives and subjective judgments in an interactive learning and decision-making process...|$|R

