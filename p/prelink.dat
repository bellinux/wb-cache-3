7|16|Public
50|$|Because <b>prelink</b> {{is often}} run periodically, {{typically}} every two weeks, {{the address of}} any given library has a chance of changing over time. <b>prelink</b> is often used in an incremental mode in which already prelinked libraries are not altered unless absolutely necessary, so a library may not change its base address when <b>prelink</b> is re-run. This gives any address derived a half-life of {{the period in which}} <b>prelink</b> is run. Also note that if {{a new version of the}} library is installed, the addresses changes.|$|E
5000|$|... <b>prelink</b> will (when {{run with}} the [...] "-R" [...] option) {{randomly}} select the address base that libraries are loaded at. This {{makes it more difficult}} to perform a return-to-libc attack on the system, because the addresses used are unique to that system. The reason <b>prelink</b> does this is because kernel facilities supplying address space layout randomization (ASLR) for libraries cannot be used in conjunction with <b>prelink</b> without defeating the purpose of <b>prelink</b> and forcing the dynamic linker to perform relocations at program load time.|$|E
50|$|As stated, <b>prelink</b> and per-process library address {{randomization}} {{cannot be}} used in conjunction. In order to avoid completely removing this security enhancement, <b>prelink</b> supplies its own randomization; however, this does not help a general information leak caused by <b>prelink.</b> Attackers {{with the ability to}} read certain arbitrary files on the target system can discover where libraries are loaded in privileged daemons; often libc is enough as it is the most common library used in return-to-libc attacks.|$|E
50|$|<b>Prelinking</b> reduces this penalty by resolving {{libraries}} this linking in advance. Afterward, resolution only occurs if the libraries {{have changed}} since being <b>prelinked,</b> such as following perhaps an upgrade.|$|R
50|$|In computing, prebinding, {{also called}} <b>prelinking,</b> {{is a method}} for {{optimizing}} application load times by resolving library symbols prior to launch.|$|R
50|$|Jakub Jelínek {{points out}} that {{position}} independent executables (PIE) ignore <b>prelinking</b> on Red Hat Enterprise Linux and Fedora, and recommends that network and SUID programs be built PIE to facilitate a more secure environment.|$|R
50|$|Position-independent {{executable}} (PIE) implements {{a random}} base address {{for the main}} executable binary {{and has been in}} place since 2003. It provides the same address randomness to the main executable as being used for the shared libraries. The PIE feature is in use only for the network facing daemons - the PIE feature cannot be used together with the <b>prelink</b> feature for the same executable. The <b>prelink</b> tool implements randomization at <b>prelink</b> time rather than runtime, because by design <b>prelink</b> aims to handle relocating libraries before the dynamic linker has to, which allows the relocation to occur once for many runs of the program. As a result, real address space randomization would defeat the purpose of prelinking.|$|E
50|$|On Linux, prelinking is {{accomplished}} via the <b>prelink</b> program, a free program written by Jakub Jelínek of Red Hat for ELF binaries.|$|E
5000|$|... preload {{is a free}} Linux {{program which}} runs as a daemon to record {{statistics}} about usage of files by more frequently-used programs. This information is then used to keep these files preloaded into memory. This results in faster application startup times as less data needs to be fetched from disk. preload is often paired with <b>prelink.</b> preload was written by Behdad Esfahbod and uses Markov chains in its implementation; ...|$|E
50|$|Occasionally <b>prelinking</b> {{can cause}} issues with {{application}} checkpoint and restart libraries like blcr, {{as well as}} other libraries (like OpenMPI) that use blcr internally. Specifically when checkpointing a program on one host, and trying to restart on a different host, the restarted program may fail with a segfault due to differences in host-specific library memory address randomization.|$|R
50|$|Versions of Windows {{prior to}} Vista require system DLLs to be <b>prelinked</b> at non-conflicting fixed {{addresses}} at the link {{time in order}} to avoid runtime relocation of images. Runtime relocation in these older versions of Windows is performed by the DLL loader within the context of each process, and the resulting relocated portions of each image can no longer be shared between processes.|$|R
40|$|Application {{launching}} {{times in}} embedded systems are more crucial than in general-purpose systems since the response times of embedded applications are significantly {{affected by the}} launching times. As general-purpose operating systems are increasingly used in embedded systems, reducing application launching times {{are one of the}} most influential factors for performance improvement. In order to reduce the application launching times, three factors should be considered at the same time: relocation time, symbol resolution time, and binary loading time. In this paper, we propose a new application execution model using a combination of <b>prelinking</b> and preloading to reduce the relocation, symbol resolution, and binary load overheads at the same time. Such application execution model is realized using fork and dlopen execution model instead of traditional fork and exec execution model. We evaluate the performance effect of the proposed fork and dlopen application execution model on a Linuxbased embedded system using XScale processor. By applying the proposed application execution model using both <b>prelinking</b> and preloading, the application launching time...|$|R
40|$|<b>Prelink</b> {{is a tool}} {{designed}} to speed up dynamic linking of ELF programs on various Linux architectures. It speeds up start up of OpenOffice. org 1. 1 by 1. 8 s from 5. 5 s on 651 MHz Pentium III. 1 Preface In 1995, Linux changed its binary format from a. out to ELF. The a. out binary format was very inflexible and shared 1 libraries were pretty hard to build. Linux’s shared libraries in a. out are position dependent and each had {{to be given a}} 2 unique virtual address space slot at link time. Maintaining these assignments was pretty hard even when there were just 3 a few shared libraries, {{there used to be a}} central address registry maintained by humans in form of a text file, but it is 4 certainly impossible to do these days when there are thousands of different shared libraries and their size, version and 5 exported symbols are constantly changing. On the other side, there was just minimum amount of work the dynamic 6 linker had to do in order to load these shared libraries, as relocation handling and symbol lookup was only done at link 7 time. The dynamic linker used the uselib system call which just mapped the named library into the address space 8 (with no segment or section protection differences, the whole mapping was writable and executable). 9 The ELF 1 binary format is one of the most flexible binary formats, its shared libraries are easy to build and there is no 10 need for a central assignment of virtual address space slots. Shared libraries are position independent and relocation 1...|$|E
5|$|DragonFly BSD {{supports}} Amiga-style resident applications feature: {{it takes}} a snapshot of a large, dynamically linked program's virtual memory space after loading, allowing future instances of the program to start {{much more quickly than}} it otherwise would have. This replaces the <b>prelinking</b> capability that was being worked on earlier in the project's history, as the resident support is much more efficient. Large programs like those found in KDE Software Compilation with many shared libraries will benefit the most from this support.|$|R
40|$|This report {{summarizes}} useful {{techniques for}} implementing scientific programs in C++, {{with an emphasis}} on using templates to improve performance. Contents 1 Introduction 3 1. 1 C++ Compilers....................................... 3 1. 1. 1 Placating sub-standard compilers......................... 3 1. 1. 2 The compiler landscape.............................. 4 1. 1. 3 C++-specific optimization............................. 4 1. 2 Compile times........................................ 4 1. 2. 1 Headers....................................... 5 1. 2. 2 <b>Prelinking......................................</b> 5 1. 2. 3 The program database approach [...] Visual Age C++.............. 5 1. 2. 4 Quadratic/Cubic template algorithms................... [...] ...|$|R
40|$|Writable XOR eXecutable (W XOR X) and Address Space Layout Randomisation (ASLR), have {{elevated}} the understanding necessary to perpetrate buffer overflow exploits [1]. However, {{they have not}} {{proved to be a}} panacea [1] [2] [3] and so other mechanisms such as stack guards and <b>prelinking</b> have been introduced. In this paper we show that host based protection still does not offer a complete solution. To demonstrate, we perform an over the network brute force return-to-libc attack against a pre-forking concurrent server to gain remote access to W XOR X and ASLR. We then demonstrate that deploying a NIDS with appropriate signatures can detect this attack efficiently...|$|R
40|$|Both {{uppermost}} {{open source}} compilers, GCC and LLVM, are {{mature enough to}} link-time optimize large applications. In case of large applications, we must take into account, except standard speed efficiency and memory consumption, different aspects. We focus on size of the code, cold start-up time, etc. Developers of applications often come up with ad-hoc solutions such as Elfhack utility, start-up of an application via a pre-loading utility and dlopen; <b>prelinking</b> and variety of different tools that reorder functions to fit the order of execution. The goal of the thesis is to analyse all existing techniques of optimization, evaluate their efficiency and design new solutions based on the link-time optimization platform. Comment: 78 pages, diploma thesi...|$|R
25|$|Since shared {{libraries}} on most {{systems do}} not change often, systems can compute a likely load address for each shared library on the system before it is needed, and store that information in the libraries and executables. If every shared library that is loaded has undergone this process, then each will load at its predetermined address, which speeds up the process of dynamic linking. This optimization is known as prebinding in macOS and <b>prelinking</b> in Linux. Disadvantages of this technique include {{the time required to}} precompute these addresses every time the shared libraries change, the inability to use address space layout randomization, and the requirement of sufficient virtual address space for use (a problem that will be alleviated by the adoption of 64-bit architectures, {{at least for the time}} being).|$|R
40|$|Numerous {{interesting}} {{problems in}} the phonology of different dialects of Chi nese tend {{to be buried in}} Chinese-language sources, or have not yet gained the attention of phonologists in genera!. 1 One such case is the final glottal stop in modern Fuzhou, with respect to its behaviour synchronically and its historical origins. The final glottal stop came from two earlier sources, *-k and *-r. While *-k has completely merged with *-r in stressed syllables, evidences of the earlier contrast can still be found in the modern dialect in how it behaves in more weakly stressed syllables in tone sandhi spans, and in its effect on adjacent consonants. It is proposed here that the con tinued relevance of the former phonological contrast can be accounted for by treating the final glottal stop from *-k as a <b>prelinked</b> glottal stop, and the one from *-r as a floating segment within the autosegmental approach. In this paper I will trace the history of these two codas, as well as address the implications that the differences in representation have with respect to subsequent changes in the language. I will conclude with a discussion o...|$|R
40|$|A radioligand {{immunoassay}} for 1, 25 -dihydroxycholecalciferol [1, 25 (OH) 2 D 3] receptors {{was developed}} utilizing a specific, high-affinity (Kd = 1. 8 X 10 (- 11 M) monoclonal antibody (9 A 7 gamma) obtained from suspension cultures of rat spleen X mouse myeloma hybrid SP 2 / 0 - 9 A 7. A standard curve was established, {{based on the}} competition between 1, 25 (OH) 2 [3 H]D 3 -receptor (18 fmol/tube) and increasing concentrations of radioinert 1, 25 (OH) 2 D 3 -receptor (0 - 240 fmol/tube) for the binding site on 9 A 7 gamma. Samples, prepared in identical buffer, contained 0 - 100 fmol of receptor/tube. After an equilibrium incubation of 1, 25 (OH) 2 [3 H]D 3 -receptor with either standard or sample (16 h at 4 degrees C), antibody-bound receptor was immunoprecipitated with rabbit anti-(rat immunoglobulin) <b>prelinked</b> to Staphylococcus aureus and quantified. The assay is statistically sensitive to 2 fmol of receptor/tube, with intra- and inter-assay variations of 7 and 12 % respectively. Occupied, unoccupied and denatured receptor were observed to compete equally in the assay. This quantitative technique has been successfully applied to the characterization of receptors after fractionation by sedimentation analysis and DNA-cellulose chromatography. Finally, the measurement of total receptor by this assay, in conjunction with 1, 25 (OH) 2 D 3 binding assays, has revealed that rachitic, normal and 1, 25 (OH) 2 D 3 -injected chicks have respectively 13, 20, and 56 % of receptor in the occupied form. From these results we consider that this radioligand immunoassay will be a useful tool in further research focusing on quantifying 1, 25 (OH) 2 D 3 receptors in tissue and cell extracts...|$|R
40|$|Previous {{studies on}} tone-vowel {{interaction}} have centered on two issues. The {{first is the}} correlation between tone and vowel quality (Pilszczikowa-Chodak 1972, 1975, Newman 1975 for Hausa; Cheung 1973 for Omei dialect of Mandarin; Wang 1968, Maddieson 1976, Yip 1980, Chan 1985 for Fuzhou), {{and the second is}} the directionality of the influence between tone and vowel, namely, whether tone affects vowel quality change, or whether vowel quality gives rise to tonal change (Wang 1968, Maddieson 1976, Yip 1980 for Fuzhou; Gandour 1977 for Thai dialects; Yue 1976 for Cantonese, Lianzhou, and Taishan). There {{have been a number of}} experimental studies on the first issue. The principal finding among these studies is the correlation between fundamental frequency (F₀) and vowel height. In particular, a high vowel has higher F₀ and a low vowel has lower F₀ (Lehiste and Peterson 1961 for English; Petersen 1976 for Danish; Di Cristo and Chafcouloff 1976 for French; Kim 1968 for Korean; Chuang and Wang 1976, Tsay and Sawusch 1994 for Mandarin; and Sawusch and Tsay 1994 for Fuzhou; etc.). Since tone, defined as linguistic use of pitch, is also primarily identified in terms of F₀ (Gandour 1978), it is natural to ask whether this phonetic correlation between F 0 and vowel height manifests itself phonologically in natural languages. In other words, the question is whether there is any empirical evidence suggesting a phonological correlation between tone and vowel height. The evidence for Hausa (an African language principally spoken in Nigeria), for example, is inconclusive. Data is offered both for (Pilszczikowa-Chodak 1972, 1975) and against (Newman 1975) this position. A highly controversial case is Fuzhou, (a Northern Min dialect spoken on the southern coast of China). In Fuzhou, a whole series of finals participate in vowel alternations in accordance with their tonal environment. It has been claimed, on the one hand, that in a tone sandhi environment, a vowel undergoes raising when the tone it occurs with increases its F₀ (Wang 1968). This is characterized as a tone -induced vowel raising process (Yip 1980). I refer to this claim as the "height-correlation" hypothesis. On the other hand, it has been argued that the vowel alternations in Fuzhou involve not only differences in height, but also differences along other dimensions, such as a front/back axis, monophthongs versus diphthongs, etc. (Maddieson 1976, Chan 1985). The "height- correlation" hypothesis, therefore, is not sufficient to explain all instances of tone -related vowel alternation. The implicit assumption behind this debate is that tonal features and vocalic features may interact directly. This yields a more fundamental question as to the nature of this interaction. In other words, whether the interaction between tone and vowels is direct (i. e. feature -to- feature) or indirect (i. e. mediated by something else). Although studies of the second issue are relatively rare, it has been shown that the influence of tones and vowels on each other is bi- directional cross -linguistically. For example, whereas Mandarin and Fuzhou have been cited as cases in which vowel alternations are conditioned by tonal environment (Wang 1969, Wang 1968, Yip 1980), the Yue dialects of Chinese, such as Cantonese, Taishan, and Lianzhou, illustrate the opposite direction of influence (Yue 1976). In Cantonese, for instance, the Yin "entering" tone historically splits into two tones according to their vocalic environment. It is realized with a higher register when the vowel is lax and short, and with a lower register when the vowel is tense and long (Yue 1976 : 49). A general question that relates to the first issue, then, is whether tone and vowel quality directly influence each other or whether this influence between them is mediated by something else. This article provides a unified account for all vowel distribution and alternation patterns corresponding to tonal environments in Fuzhou, focusing on the prosodic anchor mediating between tones and vowels. Tones and vowels will be claimed not to interact directly (i. e., feature -tofeature), and it will be seen that there is no height correlation between them. Instead, tone -vowel interaction in Fuzhou must be mediated by a prosodic anchor; in this case, the mora; and distinct moraic structures (monomoraic/bimoraic) required by the <b>prelinking</b> of the lexically specified number of tonal roots are what trigger the vowel alternations. The analysis is formulated within the constraint -based grammar of Optimality Theory (OT) (McCarthy and Prince 1993 a, b; Prince and Smolensky 1993; Pulleyblank 1994, among others). Contrary to the rule -based approach, OT assumes that Universal Grammar (UG) contains two types of phonological representation: the input and the output. The function Gen freely generates a set of output candidates for each input. UG also contains a set of violable constraints that are ranked on a language- particular basis. The function Eval determines the optimal output, which either satisfies the higher ranked constraints, or has the least violations of the relevant constraints...|$|R

