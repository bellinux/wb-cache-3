592|54|Public
2500|$|The ITRANS {{transliteration}} {{scheme was}} developed for the ITRANS software package, a <b>pre-processor</b> for Indic scripts. [...] The user inputs in Roman letters and the ITRANS preprocessor converts the Roman letters into Devanāgarī (or other Indic scripts). [...] The latest version of ITRANS is version 5.30 released in July, 2001.|$|E
5000|$|... hbpp - <b>Pre-processor,</b> a {{powerful}} tool which avoids typical problems found on C language <b>pre-processor</b> ...|$|E
5000|$|The <b>pre-processor</b> {{component}} of Calculix can generate grid {{data for the}} computational fluid dynamics programs duns, ISAAC and OpenFOAM. It can also generate input data for the commercial FEM programs Nastran, Ansys and Abaqus. [...] The <b>pre-processor</b> can also generate mesh data from STL files.|$|E
30|$|The method can be {{implemented}} by the user in simulation <b>pre-processors</b> such as Petrel and RMS.|$|R
50|$|SIMPLE is a {{specialized}} translator {{system designed to}} aid the writing of <b>pre-processors</b> for PL/I, SIMPLE, written in PL/I, is composed of three components: An executive, a syntax analyzer and a semantic constructor.|$|R
2500|$|By default, 7-Zip creates 7z-format {{archives}} with a [...]7z file extension. Each archive {{can contain}} multiple directories and files. As a container format, security or size reduction are achieved using a stacked combination of filters. These can consist of <b>pre-processors,</b> compression algorithms, and encryption filters.|$|R
5000|$|It is {{possible}} to introduce generators into C++ using <b>pre-processor</b> macros. The resulting code might have aspects very different from native C++. but the generator syntax can be very uncluttered. A very good example can be found at. The set of <b>pre-processor</b> macros defined in this source allow generators defined with the syntax as in the following example: ...|$|E
50|$|Further, {{the same}} <b>pre-processor</b> syntax {{could be used}} for {{multiple}} different languages, even natural languages as in the generation of a story from a story template using a person's name, nickname, name of pet dog, etc. and the temptation would be to devise a <b>pre-processor</b> programme which would accept the source file, perform the <b>pre-processor</b> actions and output the result ready for the next stage, the compilation. But this clearly constitutes at least one extra pass through the source and so such a solution would be unavailable to a single-pass compiler. Thus, progress through the actual input source file may well advance in fits and starts, but it is still unidirectional.|$|E
50|$|Some systems {{allow the}} {{definition}} of <b>pre-processor</b> procedures whose output is source text to be compiled, and may even allow such source to define still further <b>pre-processor</b> items. Adroit usage of such options allows for constants to be given explanatory names, recondite details {{to be replaced by}} easy mnemonics, the appearance of new statement forms, and the generation of in-line code for specific usages of a general procedure (such as sorting), rather than devise actual procedures. With a proliferation of parameters and parameter types, the number of combinations required grows exponentially.|$|E
40|$|The {{behaviour}} {{of atmospheric}} dispersion models is {{strongly influenced by}} meteorological input, especially as far as new generation models are concerned. More sophisticated meteorological <b>pre-processors</b> require more extended and more reliable data. This is true in particular when short-term simulations are performed, while in long-term modelling detaile...|$|R
40|$|A unified {{and general}} vision of {{different}} spacetime processors is presented. Many popular receivers can be accommodated, like V-RAKE receivers, weighted V-RAKE, or spatial narrowband beamforming. By making appropriate assumptions on the space/time {{characteristic of the}} interference {{it is possible to}} enhance the performance of the receiver through spatial/temporal <b>pre-processors.</b> These receivers will be tested in the FDD mode of UTRA [ETSI-UTRA]...|$|R
40|$|We further {{increase}} {{the efficiency of}} Java RMI programs. Where other optimizing re-implementations of RMI use <b>pre-processors</b> to create stubs and skeletons and to create class specific serializers and deserializers, this paper demonstrates that with transformations based on compile time analysis an additional 18 % performance gain can be achieved over class specific serializers alone for a simple scientific application...|$|R
5000|$|The Web 68 Literate Programming {{system uses}} Algol 68 as the {{underlying}} programming language, {{although there is}} nothing in the <b>pre-processor</b> 'tang' to force the use of that language.|$|E
5000|$|MADYMO/XMADgic - A <b>Pre-processor</b> for MADYMO. It is a XML-editor with {{dedicated}} functionality {{to support}} you in editing an XMLinput deck for the MADYMO solver. The editor fully complies with the XML standard.|$|E
50|$|IRAF {{allows users}} to write their own tasks in two main ways. One is by writing non-compiled {{procedure}} scripts. The second is through compiled subset <b>pre-processor</b> (SPP) programs. Tutorial documents exist for both methods.|$|E
40|$|Object {{serialization}} {{and object}} inspector user interfaces are concerns {{that can be}} orthogonally implemented using intro-spection via meta-object protocols (MOP). The C++ lan-guage lacks a formal meta-object protocol, although some are available as source <b>pre-processors.</b> A full MOP is not necessary for many classes of problems where basic intro-spection is useful. This paper describes a technique: exten-sible visitation of objects as a basic introspection primitive. 1...|$|R
5000|$|The code became {{littered}} with a crude form of <b>pre-processors</b> - It marked out the code using the Fortran comment command [...] "C" [...] So {{if you wanted}} the code to be available for a PC ( [...] IBM [...] ) then you would surround the code with CIBM. For Apollo - CAPOLLO. Later versions included Sun and there were specified processors for that as well.|$|R
40|$|Parallel {{microprocessors}} have computational {{power and}} speed for realistic simulations. Interactive information bus links front-end processor and computational processors. Real-time information bus links real-time extension processor and <b>pre-processors.</b> Computational processor and preprocessor communicate through shared memory. System used to simulate small turboshaft engine to demonstrate potential of multiprocessing in such applications. Real-time simulations aid {{development of new}} digital engine controls enabling testing of hardware and software under realistic conditions...|$|R
50|$|The C# {{language}} has supported attributes from its very first release. However these attributes {{are used to}} give run-time information and are not used by a <b>pre-processor</b> (there isn't one in C#'s reference implementation).|$|E
50|$|BCJ2 - <b>Pre-processor</b> for 32-bit x86 executables. BCJ2 is an {{improvement}} on BCJ, adding additional x86 jump/call instruction processing. Near jump, near call, conditional near jump targets are split out and compressed separately in another stream.|$|E
5000|$|A COBOL compiler. This {{was very}} rarely used, early {{experiences}} not having been entirely favourable. One notable exception was a wiring design program called [...] "WRS1", {{used to help}} design the hardware for the later English Electric KDF9 and System 4 range of Mainframe computers. Another oddity was a decision table <b>pre-processor</b> for COBOL programs, itself written in COBOL. This was of some interest, since bureau programming staff were at the time experimenting with using decision tables {{as an alternative to}} flowcharts. However, while these programmers continued to hand-code in assembler from the hand-written decision tables with some success, the compilation overheads prevented the use of the <b>pre-processor.</b>|$|E
40|$|Abstract:- This paper {{presents}} a sequential decomposition {{of the data}} auto-correlation matrix using SVD, QR-method and QLP as <b>pre-processors</b> from the design of Wiener Filters. It is shown that this approach is effective for noise reduction by improving the SNR while reducing CPU time {{for a range of}} input signal lengths, filter length and noise variance. The theoretical and practical aspects of the proposed approach are introduced and compared to those obtained from simulation results...|$|R
40|$|ABC++ is a {{portable}} object-oriented type-safe class library for parallel programming in C++. It supports active objects, synchronous and asynchronous object interactions, and object-based shared regions on both shared- and distributed-memory parallel computers. ABC++ is written in, and compatible with, standard C++: no language extensions or <b>pre-processors</b> are used. This paper focuses on {{its use of}} an object-oriented technique called smart messages to support object interactions. Smart messages demonstrate the effectiveness of object-oriented programming in encapsulating low-level details of concurrency and in improving software portability...|$|R
3000|$|The {{advantage}} {{of this study is}} to include the observed variations in terms of water saturation data. The justification in this study is to produce a realization which honors laboratory data as well as the well log data and considers the depth so that it can handle the transition zone in a proper manner. Moreover, this method is consistent with equilibration method for initializing reservoir simulations. The method can be implemented by the user in simulation <b>pre-processors</b> such as Petrel and RMS as follows: [...]...|$|R
50|$|Note that MELPe (and/or its derivatives) {{is subject}} to IPR {{licensing}} from the following companies, Texas Instruments (2400 bit/s MELP algorithm / source code), Microsoft (1200 bit/s transcoder), Thales Group (600 bit/s rate), AT&T (Noise <b>Pre-Processor</b> NPP).|$|E
5000|$|The {{alternative}} method of enforcing the [...] structure {{to be aligned}} to a one byte boundary will cause the <b>pre-processor</b> to discard the pre-determined alignment of the structure members and thus no padding bytes would be inserted.|$|E
50|$|Autoconf {{comes with}} several {{auxiliary}} {{programs such as}} Autoheader, {{which is used to}} help manage C header files; Autoscan, which can create an initial input file for Autoconf; and , which can list C <b>pre-processor</b> identifiers used in the program.|$|E
40|$|Abstract Background High-throughput {{automated}} sequencing {{has enabled}} {{an exponential growth}} rate of sequencing data. This requires increasing sequence quality and reliability {{in order to avoid}} database contamination with artefactual sequences. The arrival of pyrosequencing enhances this problem and necessitates customisable pre-processing algorithms. Results SeqTrim has been implemented both as a Web and as a standalone command line application. Already-published and newly-designed algorithms have been included to identify sequence inserts, to remove low quality, vector, adaptor, low complexity and contaminant sequences, and to detect chimeric reads. The availability of several input and output formats allows its inclusion in sequence processing workflows. Due to its specific algorithms, SeqTrim outperforms other <b>pre-processors</b> implemented as Web services or standalone applications. It performs equally well with sequences from EST libraries, SSH libraries, genomic DNA libraries and pyrosequencing reads and does not lead to over-trimming. Conclusions SeqTrim is an efficient pipeline designed for pre-processing of any type of sequence read, including next-generation sequencing. It is easily configurable and provides a friendly interface that allows users to know what happened with sequences at every pre-processing stage, and to verify pre-processing of an individual sequence if desired. The recommended pipeline reveals more information about each sequence than previously described <b>pre-processors</b> and can discard more sequencing or experimental artefacts. </p...|$|R
40|$|Narrowband {{interference}} can seriously {{degrade the}} performance of GPS systems. Several techniques exist for reducing this interference, including adaptive transversal filters, overlapped FFTs, and filter banks. All these techniques attempt to filter out the interference before the GPS receiver performs correlation. This paper compares these three interference suppression techniques for application to GPS. Likely VLSI-based designs with various levels of complexity (i. e., operation counts) for each technique are proposed and described. The effects of these designs as <b>pre-processors</b> on GPS ranging performance is then compared using computer simulation. iii Acknowledgments The {{authors would like to}} acknowledge useful conversations with Paul T. Capozza...|$|R
40|$|In 2015 the LHC {{is already}} {{operating}} {{with a higher}} center-of-mass energy and proton beams luminosity. To keep a high trigger efficiency against an increased event rate, part of ATLAS Level- 1 Calorimeter Trigger electronics have been re-designed or newly introduced (<b>Pre-Processors,</b> Merging Modules and Topological Processors). Additionally, to achieve the best possible resolution for the reconstructed physics objects, complex calibration and monitoring systems are employed. Hit rates and energy spectra down to channel level, based on reconstructed events, are supervised with the calorimeter trigger hardware. In this paper {{the performance of the}} upgraded Level- 1 Calorimeter Trigger at the beginning of LHC Run- 2 is illustrated...|$|R
5000|$|Serial: {{results of}} VU0/FPU sent to VU1 (via 3 methods) and {{can act as}} an {{optional}} geometry <b>pre-processor</b> that does all base work to update the scene every frame (E.G. camera, perspective, boning and laws of movement such as animations or physics) ...|$|E
5000|$|MultiMech is one {{of several}} commercially {{available}} multiscale simulation technologies for solid structural analysis. MultiMech is a stand-alone Finite Element desktop-based solution that consists of a <b>pre-processor,</b> a proprietary solver, and a post-processor. MultiMech is also integrated with CAE platforms Abaqus and Ansys Workbench.|$|E
5000|$|SAFE AIR (Simulation of Air {{pollution}} From Emissions Above Inhomogeneous Regions) is {{an advanced}} atmospheric pollution dispersion model for calculating concentrations of atmospheric pollutants emitted both continuously or intermittently from point, line, volume and area sources. It adopts an integrated Gaussian puff modeling system.SAFE AIR {{consists of three}} main parts: the meteorological <b>pre-processor</b> WINDS (Wind-field Interpolation by Non Divergent Schemes) to calculate wind fields, the meteorological <b>pre-processor</b> ABLE (Acquisition of Boundary Layer parameters) to calculate atmospheric parameters and a lagrangian multisource model named P6 (Program Plotting Paths of Pollutant Puffs and Plumes) to calculate pollutant dispersion.SAFE AIR {{is included in the}} online Model Documentation System (MDS) of the European Environment Agency (EEA) and of the [...]Italian Agency for the Protection of the Environment (APAT).|$|E
40|$|Qualitative” is a python toolkit for ranking and {{selection}} of sentence-level output by different MT systems using Quality Estimation. The toolkit implements a basic pipeline for annotating the given sentences with black-box features. Consequently, it applies a machine learning mechanism {{in order to}} rank data based on models pre-trained on human preferences. The preprocessing pipeline includes support for language models, PCFG parsing, language checking tools and various other <b>pre-processors</b> and feature generators. The code follows the principles of object-oriented programming to allow modularity and extensibility. The tool can operate by processing both batch-files and single sentences. An XML-RPC interface is provided for hooking up with web-services and a graphical animated web-based interface demonstrates its potential on-line use...|$|R
40|$|Abstract. An {{analogue}} median filter, realised in a 0. 35 µm CMOS technology, {{is presented}} in this paper. The key advantages of the filter are: high speed of image processing (50 frames per second), low-power operation (below 1. 25 mW under 3. 3 V supply) and relatively high accuracy of signal processing. The presented filter {{is a part of}} an integrated circuit for image processing (a vision chip), containing: a photo-sensor matrix, a set of analogue <b>pre-processors,</b> and interface circuits. The analysis of the main parameters of the considered median filter is presented. The discussion of important limitations in the operation of the filter due to the restrictions imposed by CMOS technology is also presented. Key words: analogue CMOS circuits, early vision processing, median filter, low-power. 1...|$|R
40|$|This paper {{describes}} {{the system that}} has been used by TeamX in SemEval- 2014 Task 9 Subtask B. The system is a senti-ment analyzer based on a supervised text categorization approach designed with fol-lowing two concepts. Firstly, since lex-icon features were shown to be effective in SemEval- 2013 Task 2, various lexicons and <b>pre-processors</b> for them are introduced to enhance lexical information. Secondly, since a distribution of sentiment on tweets is known to be unbalanced, an weighting scheme is introduced to bias an output of a machine learner. For the test run, the sys-tem was tuned towards Twitter texts and successfully achieved high scoring results on Twitter data, average F 1 70. 96 on Twit-ter 2014 and average F 1 56. 50 on Twit-ter 2014 Sarcasm...|$|R
