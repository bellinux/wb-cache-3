9|245|Public
40|$|In this paper, we {{describe}} a non-adhoc approach to building an SNMP <b>protocol</b> <b>object</b> for the Protocol Independent Management Information Base (PIMIB). In [5], {{the design of}} a protocol independent MIB agent is proposed which can support both SNMPandCMIP. Then, in [9], we present the implementation of PIMIB, which provides not only management protocol independence (i. e., SNMP and CMIP) but also network device protocol independence. In practice, for SNMP management applications talking to the PIMIB, an SNMP <b>protocol</b> <b>object</b> with the knowledge of a MIB specification is needed to transform the SNMP requests into the PIMIB generic interface. In [7, 6], MOSY (Managed Object Syntax-compiler Yacc-based) is introduced as a tool to build an SNMP <b>protocol</b> <b>object.</b> However, in the normal building process of an SNMP subagent, a certain amount of knowledge about the implementation of network resources is still necessary for connecting the MIB with the real network environment. Thus, for a specific MIB de [...] ...|$|E
40|$|International audienceNowadays, {{the rapid}} growth of Cloud {{computing}} services is starting to overload the network communication infrastructures. This evolution reveals missing blocks of the current Internet Protocol architecture, in particular in terms of addressing and locator-identifier mapping control-plane. In this paper, we give a short overview of a solution that handles virtual-machines migration over the Internet based on the Locator/Identifier Separation <b>Protocol,</b> <b>object</b> of a technical demonstration...|$|E
40|$|Computing {{systems are}} more and more intensively used in our society. Hence, more and more real-life {{situations}} depend on these computing systems. Therefore, the dependability, (i. e., reliability and availability) of computing systems becomes more and more important. This thesis defines a replication mechanism to achieve fault- tolerant computing. The Reference Model for Open Distributed Processing (RM-ODP) defines concepts and rules for the description of open distributed systems. The replication mechanism that we propose is RM-ODP conform. The replication mechanism is described from the computational, engineering and technology viewpoint of RM- DP. One conclusion of this is that the replication mechanism is implemented in the <b>protocol</b> <b>object.</b> This thesis can be a basis to realise the replication mechanism on any platform. In this thesis the mechanism has been realised in ANSAware. ...|$|E
50|$|<b>Protocol</b> <b>objects</b> are {{components}} of a protocol stack that enclose network communication within an object-oriented interface.|$|R
40|$|Whenbuilding {{distributed}} applications, {{one has to}} {{deal with}} many complex issues, some of which can be modeled as interacting distributed protocols. Modern operating systems already offer communication facilities such as sockets or RPC-like abstractions, but they have proven to be too low-level or limited in scope. Furthermore, they lack the ability to seamlessly cope with failures. In this paper, we claim that modeling <b>protocols</b> as reusable <b>objects</b> is a good way of structuring distributed systems, since robust protocol implementations and well-tested code reuse are key features in this context. We show how <b>protocol</b> <b>objects</b> can help to build new distributed protocols by composing existing ones, and that they add flexibility to distributed systems. We also give an overview of the design and implementation of BAST, our extensible library of <b>protocol</b> <b>objects.</b> 1 INTRODUCTION This paper introduces the concept of <b>protocol</b> <b>objects</b> and how it canbe used to model distributed systems. In particu [...] ...|$|R
40|$|This paper {{describes}} Bast, an open object-oriented {{framework for}} building reliable distributed application and middleware. Specialised environments, such as group communication toolkits (e. g., Isis, Totem) or transactional monitors (e. g., Encina, Tuxedo), are hardly extensible or customisable for speci c needs, because their underlying protocols are hidden and implemented {{in an ad}} hoc manner. In contrast, Bast provides customisable distributed protocols as basic components for reliable distributed computing. In the Bast framework, a hierarchy of <b>protocol</b> <b>objects</b> is made available for subclassing to both application and middleware programmers. We illustrate this point by presenting how transactional and group-oriented software is build from abstract <b>protocol</b> <b>objects,</b> by rede ning callback operations. The resulting objects provide adequate support {{for a wide range}} of reliable distributed applications. We also detail protocol composition and tuning facilities of Bast. Here, we isolate distributed algorithms into separate objects, and we bind them to <b>protocol</b> <b>objects</b> via the Strategy pattern. We also present our implementations of Bast in Smalltalk and Java, discuss our design in the light of di erent alternatives, and point out some optimisation issues. ...|$|R
40|$|The Totem {{protocol}} {{supports the}} maintenance of consistency of replicated information in fault-tolerant distributed systems by providing reliable totally ordered delivery of messages. The membership algorithm of Totem maintains a consistent view of processors in a local-area network and handles all aspects of reconfiguration, including restarting of failed processors and remerging of partitioned networks. In this paper we describe a network monitor with graphical output that we have constructed for the Totem protocol development environment. The development environment executes the <b>protocol</b> <b>object</b> modules unmodified while simulating network communication, timing, and fault injection. The network monitor collects information from the processors within the development environment and displays global membership information and other data in an intuitive fashion. 1 Introduction Distributed systems achieve high performance and reliability {{through the use of}} multiple processors communicating [...] ...|$|E
40|$|A {{software}} framework is an architecture or infrastructure intended {{to enable the}} integration and interoperation of software components. Specialized types of {{software framework}}s are those specifically intended to support the composition of models or other components within a simulation system. Such frameworks are intended to simplify the process of assembling a complex model or simulation system from simpler component models {{as well as to}} promote the reuse of the component models. Several different types of software frameworks for model composition have been designed and implemented; those types include common library, product line architecture, interoperability <b>protocol,</b> <b>object</b> model, formal, and integrative environment. The various framework types have different components, processes for composing models, and intended applications. In this survey the fundamental terms and concepts of software frameworks for model composition are presented, the different types of such frameworks are explained and compared, and important examples of each type are described...|$|E
40|$|This thesis {{deals with}} the {{creation}} of a library {{that can be used in}} the construction of network protocols. The library provides functions that are useful for organizing protocols as stacks of layers and for processing packets. The thesis implements the main concepts of the special purpose language, Morpheus [2]. Morpheus was designed by Mark Bert Abbott at the University of Arizona in 1994 but has not yet been implemented. We have implemented the main concepts of Morpheus by using a concurrent programming language called MPD (Multithreaded, Parallel and Distributed) [5] and a programming discipline known as reactive objects. Morpheus is based on the concept of protocol shapes. A protocol shape is a template for implementing protocols with certain functions. Three main protocol shapes are router, sequencer and multiplexor. The protocol implementer constructs protocols by extending these shapes. Our library implements these shapes as objects. Each of these shapes in turn extends from a base <b>protocol</b> <b>object</b> called Protocol. We have used reactive objects for allowing communication between protocols...|$|E
40|$|When {{building}} distributed applications, {{one has to}} {{deal with}} many complex issues, some of which can be modeled as interacting distributed protocols. Modern operating systems already offer communication facilities such as sockets or RPC-like abstractions, but they have proven to be too low-level or limited in scope. Furthermore, they lack the ability to seamlessly cope with failures. In this paper, we claim that modeling <b>protocols</b> as reusable <b>objects</b> is a good way of structuring distributed systems, since robust protocol implementations and well-tested code reuse are key features in this context. We show how <b>protocol</b> <b>objects</b> can help to build new distributed protocols by composing existing ones, and that they add flexibility to distributed systems. We also give an overview of the design and implementation of BAST, our extensible library of <b>protocol</b> <b>objects...</b>|$|R
50|$|The RPC {{facilities}} of {{the cross}} platform serialization protocol, Cap'n Proto amount to a distributed <b>object</b> <b>protocol.</b> Distributed <b>object</b> method calls can be executed(chained, in a single network request, if needs be) through interface references/capabilities.|$|R
50|$|In 2002, Congressional {{researchers}} who examined {{the legal status}} of the Protocol advised that signature of the UNFCCC imposes an obligation to refrain from undermining the <b>Protocol's</b> <b>object</b> and purpose, and that while the President probably cannot implement the Protocol alone, Congress can create compatible laws on its own initiative.|$|R
40|$|Ever had an {{experience}} of forgetting to do something very important on a place you just past?. Remembering, on arrival at your destination afterward, requires an action {{to return to the}} task location. This can be unproductive and perhaps result to frustration. The purpose of this thesis is to develop a “Location Task-To-Do manager” an android mobile application that will efficiently organizes task-to-do list and remind an individual to perform a task at a pre-defined location through notification and alert messages. The methods used includes,  investigation of pre-existing systems, requirement elicitation survey technique, three-tier architecture design pattern, iterative development life-cycle model, acceptance test plan and a sets of other technology such as  Java SDK, Android APIs, TCP/IP <b>protocol,</b> <b>object</b> oriented programing techniques and MySql relational database. The result showed that, installed “Location Task-To-Do manager” application on individual mobile devices/smartphones were capable of creating task, adding task, editing task, deleting task, sharing task and setting task location through its user friendly graphical interfaces. Users are able to receive notification to perform a task within a minimum distance of 1 km to the exact task location...|$|E
40|$|This {{thesis is}} at the {{crossing}} of object-orientation and reliable distributed systems, and contributes to integrate those two research fields. Existing distributed programming environments can be characterised according to whether they rely on object concepts and to whether they deal with reliability issues. Most of such environments combine objects and distribution, although they follow different approaches in doing so. However, only a minority is concerned with reliability. This is not surprising, since the design of reliable distributed software requires to deal with many non-trivial issues, such as reliable communication, failure detection, consensus, etc. In this context, the research presented here focuses on fundamental programming abstractions for structuring reliability issues at the system level. Three questions {{are at the heart}} of that concern: (1) what abstractions are most adequate to model reliability, (2) how to represent them to promote flexible design, and (3) how to implement them to promote code reuse. These questions enable to further categorise existing distributed environments as reliability-based or protocol-based. The former answer question 1, by proposing either group communication or transactions, whereas the latter answer questions 2 and 3 by providing protocols as basic structuring abstractions. Because transactions and group communication are primarily aimed at application programmers, reliability-based environments are of limited help for system programmers. As for protocol-based environments, none integrates recent advances in object-orientation, such as design patterns, and in the theory of asynchronous distributed systems augmented with unreliable failure detectors. The contribution of this research is in its attempt to address questions 2 and 3, while it acknowledges existing theoretical results as possible answers to question 1. The thesis introduces the protocol-oriented approach, together with Bast, an object-oriented framework written in Smalltalk and later ported on Java. The Bast framework relies on protocols as basic programming abstractions, each protocol representing an elemental problem/solution pair. It supports the composition of such elemental pairs through protocol objects and protocol patterns; they are the proposed answers to question 2. Protocol objects are distributed objects capable of participating in virtually any kind of remote interactions, whereas protocol patterns are domain-specific design patterns that describe how to compose protocol objects. Bast provides an extensible library of <b>protocol</b> <b>object</b> classes, implementing reliable point-to-point and multicast communication, failure detection, consensus, etc. Two protocol patterns are presented: Active Replication, which helps in the assembling of protocol objects for active replication, and Distributed Agreement, which captures the recurring structure of various classical agreement protocols. In Bast, three <b>protocol</b> <b>object</b> classes are derived from the Distributed Agreement pattern, each one solving a specific agreement problem, that is atomic commitment, total order multicast and view synchrony. The Bast framework is also based on an open implementation, which is the proposed answer to question 3. Protocol dependencies are managed within protocol objects using a general-purpose design pattern, known as Strategy. The Strategy pattern is applied to implement distributed algorithms as separate objects from the protocol objects that use them. It helps to overcome the limitations of single inheritance as far as protocol composition is concerned. As a consequence, one can flexibly change or customise any distributed algorithms within existing protocol objects. This pattern also enables to manage concurrent protocol executions in a transparent and recursive way. The thesis concludes by sketching how transparency could be added on top of Bast, with no loss of flexibility...|$|E
40|$|This thesis {{represents}} {{an attempt to}} improve {{the state of the}} art in our ability to understand and check <b>object</b> <b>protocols,</b> with a particular emphasis on concurrent programs. <b>Object</b> <b>protocols</b> are the patterns of use imposed on clients of APIs in objectoriented programs. We show through an empirical study of open-source objectoriented programs that <b>object</b> <b>protocols</b> are quite common. We then present “Syncor-Swim,” a methodology and suite of accompanying tools for checking at compiletime that <b>object</b> <b>protocols</b> are used and implemented correctly. This methodology i...|$|R
50|$|The Agent Extensibility Protocol or AgentX is a {{computer}} networking protocol that allows management of Simple Network Management <b>Protocol</b> <b>objects</b> defined by different processes via a single master agent. Agents that export objects via AgentX to a master agent are called subagents. The AgentX standard not only defines the AgentX protocol but also the procedure by which those subagents process SNMP protocol messages.|$|R
5000|$|... making {{cultural}} property protected under the Convention and this <b>Protocol</b> the <b>object</b> of attack; and ...|$|R
40|$|This {{document}} {{explains the}} concept of object to object communications and describes naming issues for object identification. In order to develop <b>protocols</b> for <b>object</b> to object communications, this document provides the naming architecture according to mapping relationships between host and object(s). In addition, considerations of <b>protocols</b> for naming <b>object</b> are specified...|$|R
40|$|If {{an object}} {{oriented}} {{program is a}} collection of communicating objects, then the objects' protocols define the languages the program speaks. Unfortunately, protocols are difficult to design in isolation, so many programs' protocols are not as well designed as they could be. This paper presents six patterns which describe how <b>objects</b> <b>protocols</b> can be designed or redesigned. By using these patterns, programs and designs can be made more simple, more general, and more easy to change. Introduction <b>Object's</b> <b>protocols,</b> also know as interfaces, are very important in object oriented design. An <b>object's</b> <b>protocol</b> is the face the object presents to other objects surrounding it. Using an <b>object's</b> <b>protocol,</b> other <b>objects</b> in the program can use the object as a server, thus accessing the behaviour the object provides. Similarly, an object can act as a client to other objects, in turn using their protocols to access their services. This paper presents six patterns for designing object oriented protoc [...] ...|$|R
40|$|This paper {{discusses}} {{the necessity of}} a meta <b>object</b> <b>protocol</b> in the design of an open hypermedia system. It shows that a meta <b>object</b> <b>protocol</b> enables to tailor the behaviour and configuration of the hypermedia system, independent of its constituting elements. The approach is demonstrated by means of the Zypher Open Hypermedia Framework, where the meta <b>object</b> <b>protocol</b> eases the incorporation of system services (i. e. caching, logging, authority control and integrity control) and flexible reconfiguration (i. e. run-time extensibility and cross-platform portability) ...|$|R
40|$|With the {{increase}} of processing power and network bandwidth {{it is possible to}} build sophisticated distributed hard-real time systems. The construction of such communication systems using the composition of several micro-protocol objects is an approach that has been applied with success in the non real-time arena. This encourages the re-use of protocol components and allows the applications to configure stacks tailored to their needs. To benefit from this approach in hard real-time systems, one must be able to derive the timing behavior of a protocol composition given a description of its <b>protocol</b> <b>objects.</b> This thesis presents a general framework to analyse the timing behavior of protocol stacks derived from the composition of micro-protocols. Individual micro-protocols are described as <b>protocol</b> <b>objects</b> that subscribe and produce events; interactions among adjacent protocols are modeled by the exchange of these events. The protocol implementation is modeled by a set of tasks, each programmed to handle a specific protocol event. To illustrate the use of the framework, a study is presented on the timing analysis of a set of modular fault-tolerant group communication protocols designed for the CAN field-bus: RELCAN and EDCAN. In order to perform this study, an existing software tool was extended to comply with the model requirement...|$|R
40|$|Services <b>Protocols</b> <b>Objects</b> Design Modularity Implementation Modularity Figure 1 : Services, <b>Protocols,</b> and <b>Objects</b> This paper {{makes two}} contributions. First, it {{presents}} {{a case study of}} how we realized modularity in the design and implementation of Consul. Although necessarily specific to Consul, this discussion is of general interest because the fault-tolerant services provided by Consul are widely accepted to be fundamental. Second, it enumerates the general lessons we learned while working on Consul. These lessons should be useful to anyone trying to apply modularity to the design and implementation of a fault-tolerant distributed system. CASE STUDY This section documents how we applied modularity to the design and implementation of Consul. This involves three levels of abstraction, as illustrated in Figure 1. We first introduce the abstract set of services supported by Consul. These services are general, and have been discussed widely in the literature. We next describes how these a [...] ...|$|R
40|$|The paper {{presents}} a generic framework to analyse the timing behavior of protocol graphs {{derived from the}} composition of microprotocols. The model assumes that a protocol stack is composed {{of a set of}} <b>protocol</b> <b>objects</b> that interact through the exchange of events. A specific task is associated with each relevant protocol event and for each task, the periods and offsets are derived from a description of the interactions between adjacent protocols. To illustrate the use of the model, a stack of modular reliable group communication protocols for the CAN field-bus is analysed. ...|$|R
5000|$|Some {{of these}} extensions, such as {{distributed}} <b>objects</b> and <b>protocol</b> <b>objects,</b> are domain-specific terms for special types of [...] "ordinary" [...] objects {{used in a}} certain context (such as remote method invocation or protocol composition). Others, such as replicated objects and live distributed objects, are more non-standard, in that they abandon the usual case that an object resides in a single location at a time, and apply the concept to groups of entities (replicas) that might span across multiple locations, might have only weakly consistent state, and whose membership might dynamically change.|$|R
5000|$|Moose {{and other}} modules such as [...] provide a {{low-level}} emulation of Perl 6's object model and meta-object <b>protocol.</b> This <b>object</b> {{model can be}} used directly or through v6.|$|R
40|$|Abstract. An {{active area}} of {{research}} in computer science is the prevention of violations of <b>object</b> <b>protocols,</b> i. e., restrictions on temporal orderings of method calls on an object. However, little is understood about <b>object</b> <b>protocols</b> in practice. This paper describes an empirical study of <b>object</b> <b>protocols</b> in some popular open-source Java programs. In our study, we have attempted to determine how often <b>object</b> <b>protocols</b> are defined, and how often they are used, while also developing a taxonomy of similar protocols. In the open-source projects in our study, comprising almost two million lines of code, approximately 7. 2 % of all types defined protocols, while 13 % of classes were clients of types defining protocols. (For comparison, 2. 5 % of the types in the Java library define type parameters usingJava Generics.) This suggests thatprotocol checkingtools are widely applicable. ...|$|R
40|$|This {{document}} {{describes the}} Grid extensions for the GMPLS routing and signaling protocols, with specific <b>protocol</b> <b>objects</b> for G. OSPF-TE and G. RSVP-TE. These extensions are {{integral part of}} the G 2 MPLS Control Plane prototype delivered by Phosphorus WP 2. Most of the extensions are also part of the G. OUNI routing and signalling protocols, used to enable the integration with Grid middleware towards Grid Network Services. Architectural backgrounds for this deliverable are “The Grid-GMPLS Control Plane architecture ” described in D 2. 1 and the “Grid-GMPLS network interfaces specification ” delivered by D 2. 7. Project...|$|R
50|$|A wire {{protocol}} {{provides the}} means for interoperation {{of one or more}} applications in a network. They often refer to distributed <b>object</b> <b>protocols,</b> or they use applications that were designed to work together. As the name suggests, these distributed <b>object</b> <b>protocols</b> run in different processes in one or several computers that are connected over a network.|$|R
5000|$|Host Controller Interface (HCI), Logical Link Control and Adaptation Protocol (L2CAP), Service Discovery Protocol (SDP), RFCOMM, Audio/Video Distribution Transport Protocol (AVDTP), Audio/Video Control Transport Protocol (AVCTP), Bluetooth Network Encapsulation <b>Protocol</b> (BNEP), <b>Object</b> Exchange <b>Protocol</b> (OBEX) ...|$|R
40|$|We discuss usage <b>protocols</b> for {{iterator}} <b>objects</b> {{that prevent}} concurrent modifications {{of the underlying}} collection while iterators are in progress. We formalize these <b>protocols</b> in Java-like <b>object</b> interfaces, enriched with separation logic contracts. We present examples of iterator clients and proofs that they adhere to the iterator protocol, as well as examples of iterator implementations and proofs that they implement the iterator interface. ...|$|R
40|$|This {{document}} specifies an Internet standards track {{protocol for}} the Internet community, and requests discussion {{and suggestions for}} improvements. Please refer to the current edition of the "Internet Official Protocol Standards " (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited. Copyright Notice Copyright (C) The IETF Trust (2007). This document describes an application layer client-server protocol for the provisioning and management of objects stored in a shared central repository. Specified in XML, the <b>protocol</b> defines generic <b>object</b> management operations and an extensible framework that maps <b>protocol</b> operations to <b>objects.</b> This document includes a <b>protocol</b> specification, an <b>object</b> mapping template, and an XML media typ...|$|R
40|$|The {{data are}} divided into four ZIP files based on whether they contain core or flake models, and whether the models were created using an {{expedient}} or refined photogrammetric setup and protocol. Each of these. ZIP files contains the relevant 3 D models in OBJ format. There are three files associated with each model (OBJ, MTL, and JPG texture). The files are named based on object ID, and the setup used to create them (i. e. expedient or refined). All models were processed and scaled in Agisoft PhotoScan Professional Edition. Geomagic Design X was used to center and align models around the origin. The data set consists of three-dimensional (3 D) models of experimentally produced lithic artifacts created using both expedient and refined photogrammetric setups and processing protocols. Source images for all models were captured using a 12. 1 megapixel Canon PowerShot SX 260 HS compact digital camera. In our expedient <b>protocol,</b> <b>objects</b> were placed on a wire stand. The photographer moved around the object, and captured photos using Auto mode. In our refined <b>protocol,</b> <b>objects</b> were placed on a rotating turntable under controlled lighting conditions. The camera was placed on a tripod. Shutter speed, f-stop, and ISO were set manually. This refined protocol is described in Porter, S. T., Roussel, M., & Soressi, M. (2016). A Simple Photogrammetry Rig for the Reliable Creation of 3 D Artifact Models in the Field Lithic Examples from the Early Upper Paleolithic Sequence of Les Cottés (France). Advances in Archaeological Practice, 4 (1), 71 - 86. The associated paper discusses the relative fidelity of the models produced using these different workflows. Models may also be viewed online (in browser) at: [URL]...|$|R
40|$|This thesis {{represents}} {{an attempt to}} improve {{the state of the}} art in our ability to understand and check <b>object</b> <b>protocols,</b> with a particular emphasis on concurrent programs. <b>Object</b> <b>protocols</b> are the patterns of use imposed on clients of APIs in object-oriented programs. We show through an empirical study of open-source object-oriented programs that <b>object</b> <b>protocols</b> are quite common. We then present “Syncor-Swim,” a methodology and suite of accompanying tools for checking at compile-time that <b>object</b> <b>protocols</b> are used and implemented correctly. This methodology is based upon the existing access permissions method of alias control, which is here extended to be sound in the face of shared-memory concurrency. The analysis is formalized as a type system for an object-oriented calculus, and then proven to be free from false-negatives using a proof of type safety. The type system is extended with parametric polymorphism, or “generics,” in order to increase its ability to check commonly occurring patterns. An implementation of the approach, a static analysis for programs written in the Java programming language, is presented. This implementatio...|$|R
40|$|There {{has been}} {{a steady stream of}} {{research}} over the years into componentized network protocols: protocol implementations assembled from a variety of building blocks. A promise of such frameworks has generally been flexibility: a protocol stack tailored for a particular application can be easily assembled, usually without writing any new code, by binding <b>protocol</b> <b>objects</b> together. Despite its conceptual elegance, protocol implementations based on this approach have never caught on, particularly at the transport level. Most applications today make use of a kernel-provided IP stack, and usually TCP for transport, to perform network communication. The consensus is that for both bulk-transfer of data and RPC-like call semantics, TCP appears to be perfectly adequate, and it is not worth inventing something new...|$|R
40|$|Extensible Provisioning Protocol (EPP) This {{document}} {{describes an}} application-layer client-server protocol for the provisioning {{and management of}} objects stored in a shared central repository. Specified in XML, the <b>protocol</b> defines generic <b>object</b> management operations and an extensible framework that maps <b>protocol</b> operations to <b>objects.</b> This document includes a <b>protocol</b> specification, an <b>object</b> mapping template, and an XML media type registration. This document obsoletes RFC 4930. Status of This Memo This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the "Internet Official Protocol Standards " (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited. Copyright Notice Copyright (c) 2009 IETF Trust and the persons identified as th...|$|R
40|$|<b>Object</b> <b>protocols</b> are a {{commonly}} studied research problem, {{but there is}} little known about their usability in practice. In particular, there is little research to show that <b>object</b> <b>protocols</b> cause difficulty for developers. In this work, we use community forums to find empirical evidence that <b>object</b> <b>protocols</b> are burdensome for developers. We analyzed 427 threads from the Spring and ASP. NET forums and discovered that 69 were on a protocol violation. We found that violations of protocols result in unusual runtime behavior rather than exceptions in 45 % of our threads, that questions took an average of 62 hours to resolve, and that even though 54 % of questions were repeated violations of similar protocols, the manifestation of the violation at runtime was different enough that developers could not search for similar questions. D. 2. m [Software En...|$|R
