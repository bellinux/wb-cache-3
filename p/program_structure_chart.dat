0|5623|Public
40|$|This paper {{proposes a}} system design {{methodology}} which centres on the user interface. Compared to traditional structured methodologies the role of Data Flow Diagrams is reduced and <b>Program</b> <b>Structure</b> <b>Charts</b> are to some extent replaced by Panel Flow Diagrams (a type of state-transition diagram). This methodology is particularly suited to interactive and transaction processing systems. It {{can be used with}} both linear life cycle and evolutionary approaches...|$|R
40|$|We {{apply the}} {{techniques}} of logic <b>programming</b> to evaluate <b>structure</b> <b>charts.</b> We find that <b>structure</b> <b>charts</b> can be represented naturally in Prolog, and useful information can be derived in a straightforward manner. Standard techniques {{in the evaluation of}} <b>structure</b> <b>charts</b> can be formalized, and a few previous problems can be solved easily...|$|R
40|$|We {{summarize}} {{our experience}} {{in the use of}} Prolog to model and evaluate <b>structure</b> <b>charts</b> according to standard guidelines in structured design. We discuss how to construct first-cut <b>structure</b> <b>charts</b> automatically from data flow diagrams using transform and transaction analyses, evaluate them using recommended criteria such as coupling, cohesion, morphology and tramp, and improve on the resulting <b>structure</b> <b>charts</b> by means of automatic backtracking. Logic <b>programming,</b> Prolog, <b>structure</b> <b>charts,</b> <b>structured</b> design ∗ Copyright 1994 Information and Software Technology. This material is presented to ensure timely dissemination of scholarly and technical work. Personal use of this material is permitted. Copyright and all rights therein are retained by authors or by other copyright holders. All persons copying this information are expected to adhere to the terms and constraints invoked by each author¡¯s copyright. In most cases, these works may not be reposted without the explicit permission of the copyright holder. Permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted componen...|$|R
40|$|When people write {{a report}} that {{involves}} a complex argument towards a conclusion, they can use a design tool called the inference tree, which enables them to outline the argument, and quickly detect reasoning errors in the outline. Yet when the argument is very complex, the inference tree may spread over several pages, so that writers may often have to flip {{back and forth between}} those pages. To prevent unnecessary flipping, they can draw the tree as a hierarchy of modules, similar to a modular hierarchy of <b>program</b> flowcharts or <b>structure</b> <b>charts,</b> where a major module controls several minor modules. In drawing the tree, writers can adopt four principles of Computing: modularity, the criterion of minimal coupling between modules, and the methods of forward and backward chaining to draw all the modules...|$|R
40|$|We {{investigate}} {{into the}} feasibility of applying logic <b>programming</b> to <b>structured</b> design. We propose to use Prolog as a common machinery for the representation of various structured tools. We illustrate through examples how to produce <b>structure</b> <b>charts</b> from data flow diagrams, and evaluate them according to commonly recommended design guidelines. If the <b>structure</b> <b>charts</b> produced are not satisfactory, the inherent backtracking mechanism in Prolog will help to produce other versions for further evaluation...|$|R
25|$|The {{overall design}} {{of the system is}} {{documented}} using HIPO <b>charts</b> or <b>structure</b> <b>charts.</b> The <b>structure</b> <b>chart</b> is similar in appearance to an organizational chart, but has been modified to show additional detail. <b>Structure</b> <b>charts</b> can be usedto display several types of information, but are used most commonly to diagram either data structures or code structures.|$|R
50|$|A <b>structure</b> <b>chart</b> (SC) is a {{chart that}} shows the {{breakdown}} of the configuration system to the lowest manageable levels. This chart is used in <b>structured</b> <b>programming</b> to arrange the program modules in a tree structure. Each module is represented by a box which contains the name of the modules. The tree structure visualizes the relationships between the modules.|$|R
50|$|A <b>Structure</b> <b>Chart</b> (SC) in {{software}} engineering and organizational theory is a chart {{which shows the}} breakdown of a system to its lowest manageable levels. They are used in <b>structured</b> <b>programming</b> to arrange program modules into a tree. Each module is represented by a box, which contains the module's name. The tree structure visualizes the relationships between modules.|$|R
40|$|We {{summarize}} {{our experience}} {{in the use of}} Prolog to model and evaluate <b>structure</b> <b>charts</b> according to standard guidelines in structured design. We discuss how to construct first-cut <b>structure</b> <b>charts</b> automatically from data flow diagrams using transform and transaction analyses, evaluate them using recommended criteria such as coupling, cohesion, morphology and tramp, and improve on the resulting <b>structure</b> <b>charts</b> by means of automatic backtracking...|$|R
40|$|In this paper, we {{summarize}} {{our experience}} {{in the use of}} Prolog to model and evaluate <b>structure</b> <b>charts</b> according to standard guidelines in structured design. We discuss how to construct first-cut <b>structure</b> <b>charts</b> automatically from dataflow diagrams using transform and transaction analyses, evaluate them using recommended criteria such as coupling, cohesion, morphology and tramp, and improve on the resulting <b>structure</b> <b>charts</b> by means of automatic backtracking. © 1994. postprin...|$|R
40|$|In {{recent years}} <b>structured</b> <b>programming</b> {{has emerged as}} an {{advanced}} programming technology. During this time, many tools {{have been developed for}} facilitating the programmer % use of ‘structured programming. One of these tools, the Structured Flowcharts developed by I. Nassi and B. Shneiderman in 1972, is proving its value in both the design phase and the coding phase of program development. Several programming groups in System Products Division, Endicott, New York, have used the Nassi-Shneiderman charts as replacements for conventional flowcharts in <b>structuring</b> <b>programs.</b> The <b>charts</b> have been used extensively on some projects for structured walk-throughs, design reviews, and education. This paper describes the Nassi-Shneiderman charts and provides explanations of their use in programming, in development process control, in walkthroughs, and in testing. It includes an analysis of the value of Nassi-Shneiderman charts compared to other design and documentation methods such as pseudo-code, HIP 0 charts, prose, and flowcharts, as well as the authors’ experiences in using the Nassi-Shneiderman charts. The paper is intended for a general data processing audience and although no special’knowledge is required, familiarity with <b>structured</b> <b>programming</b> concepts would be helpful. The reader should gain insight into the use of Nassi-Shneiderman charts as part of the total development process...|$|R
40|$|The {{software}} life cycle. Requirements analysis. Specification of requirements. Software design and selection. Initial design, modularity, <b>structure</b> <b>charts</b> and partitioning. Detailed design and notations. Data structure design. Design documentation and software maintenance. Prerequisite by Topic: Algorithm design and representation. Developing and running computer programs. It is preferable {{that the student}} has taken the EEE 212 (or EE 413) Data Structures and/or the EE 415 <b>Structured</b> <b>Programming</b> an...|$|R
5000|$|... #Caption: Peter The Great 28955 <b>structure</b> <b>chart</b> {{notation}} pedigree ...|$|R
5000|$|National Center for State Courts, {{including}} State Court <b>Structure</b> <b>Charts</b> ...|$|R
5000|$|... #Subtitle level 3: Submanifolds: organs, {{subcortical}} <b>structures,</b> <b>charts,</b> and immersions ...|$|R
50|$|A <b>structure</b> <b>chart</b> is {{also used}} to diagram {{associated}} elements that comprise a run stream or thread. It is often developed as a hierarchical diagram, but other representations are allowable. The representation must describe the breakdown of the configuration system into subsystems and the lowest manageable level. An accurate and complete <b>structure</b> <b>chart</b> {{is the key to the}} determination of the configuration items (CI), and a visual representation of the configuration system and the internal interfaces among its CIs(define CI clearly). During the configuration control process, the <b>structure</b> <b>chart</b> is used to identify CIs and their associated artifacts that a proposed change may impact.|$|R
5000|$|... #Caption: A {{process flow}} diagram {{describing}} {{the construction of a}} <b>structure</b> <b>chart</b> by a so-called Subject Matter Experts (SME).|$|R
5000|$|According to Hay(1999) [...] "information {{engineering}} was {{a logical}} {{extension of the}} structured techniques that were developed during the 1970's. <b>Structured</b> <b>programming</b> led to <b>structured</b> design, which in turn led to structured systems analysis. These techniques were characterized by their use of diagrams: <b>structure</b> <b>charts</b> for <b>structured</b> design, and data flow diagrams for structured analysis, both to aid in communication between users and developers, and to improve the analyst's and the designer's discipline. During the 1980's, tools began to appear which both automated the drawing of the diagrams, and kept track of the things drawn in a data dictionary". After the example of computer-aided design and computer-aided manufacturing (CAD/CAM), {{the use of these}} tools was named computer-aided software engineering (CASE).|$|R
5000|$|The <b>structure</b> <b>chart</b> aims to show [...] "the module {{hierarchy}} or {{calling sequence}} relationship of modules. There is a module specification for each module {{shown on the}} <b>structure</b> <b>chart.</b> The module specifications can be composed of pseudo-code or a program design language. The data dictionary is like that of structured analysis. At this stage in the software development lifecycle, after analysis and design have been performed, {{it is possible to}} automatically generate data type declarations", and procedure or subroutine templates.|$|R
40|$|The {{functional}} {{design of a}} preprocessor, and subsystems is described. A <b>structure</b> <b>chart</b> and a data flow diagram are included for each subsystem. Also a group of intermodule interface definitions (one definition per module) is included immediately following the <b>structure</b> <b>chart</b> and data flow for a particular subsystem. Each of these intermodule interface definitions consists of {{the identification of the}} module, the function the module is to perform, the identification and definition of parameter interfaces to the module, and any design notes associated with the module. Also described are compilers and computer libraries...|$|R
50|$|The output {{section of}} the NFDRS <b>structure</b> <b>chart</b> is the {{components}} or simply the outputs that are based in fire behavior description.but expressed in the broader context of fire danger rating.|$|R
5000|$|According to Wolber (2009), [...] "a <b>structure</b> <b>chart</b> can be {{developed}} starting with the creating of a structure, which places the root of an upside-down tree which forms the <b>structure</b> <b>chart.</b> The {{next step is to}} conceptualize the main sub-tasks that must be performed by the program to solve the problem. Next, the programmer focuses on each sub-task individually, and conceptualizes how each can be broken down into even smaller tasks. Eventually, the program is broken down to a point where the leaves of the tree represent simple methods that can be coded with just a few program statements".|$|R
5000|$|Jackson <b>Structured</b> <b>Programming</b> (JSP) is {{a method}} for <b>structured</b> <b>programming</b> based on correspondences between data stream <b>structure</b> and <b>program</b> <b>structure.</b>|$|R
50|$|Constantine was {{the primary}} force behind the {{discipline}} of Structured Design, in his book of the same name. The key features of Structured Design, such as <b>Structure</b> <b>Chart,</b> the Data flow diagram are all commonly used and taught worldwide.|$|R
50|$|In practice, see figure, {{first it}} is checked if a <b>Structure</b> <b>Chart</b> has been {{developed}} already. If so an expert needs to review it to ensure it represents the current structure and if not, updates the chart where needed..|$|R
50|$|SA and SD are {{displayed}} with <b>structure</b> <b>charts,</b> data flow diagrams and data model diagrams, {{of which there}} were many variations, including those developed by Tom DeMarco, Ken Orr, Larry Constantine, Vaughn Frick, Ed Yourdon, Steven Ward, Peter Chen, and others.|$|R
5000|$|Control Flow Analyser. This {{examines}} the <b>program</b> <b>structure,</b> identifying key features: Entry/Exit points, Loops, Branches and unreachable code. It provides a summary report {{drawing attention to}} undesirable constructs and {{an indication of the}} complexity of the <b>program</b> <b>structure.</b>|$|R
50|$|A <b>structure</b> <b>chart</b> is a {{top-down}} {{modular design}} tool, constructed of squares representing the different modules in the system, and lines that connect them. The lines represent the connection and or ownership between activities and subactivities {{as they are}} used in organization charts.|$|R
50|$|The non-architectural {{approach}} respectively picks a {{model for}} each view. For example, Structured Systems Analysis and Design Method (SSADM), picking the <b>Structure</b> <b>Chart</b> (SC) for <b>structure</b> description and the Data Flow Diagram (DFD) for behavior description, is categorized into the non-architectural approach.|$|R
5000|$|Procedural <b>programming,</b> <b>structured</b> <b>programming</b> - {{specifies}} {{the steps}} a program must take {{to reach a}} desired state.|$|R
50|$|Structural Partitioning - The <b>program</b> <b>structure</b> can {{be divided}} both {{horizontally}} and vertically. Horizontal partitions define separate branches of modular hierarchy for each major program function. Vertical partitioning suggests that control and work should be distributed top down in the <b>program</b> <b>structure.</b>|$|R
50|$|<b>Structure</b> <b>charts</b> {{are used}} in {{structured}} analysis to specify the high-level design, or architecture, of a computer program. As a design tool, they aid the programmer in dividing and conquering a large software problem, that is, recursively breaking a problem down into parts that are small enough to be understood by a human brain. The process is called top-down design, or functional decomposition. Programmers use a <b>structure</b> <b>chart</b> to build a program {{in a manner similar}} to how an architect uses a blueprint to build a house. In the design stage, the chart is drawn and used as a way for the client and the various software designers to communicate. During the actual building of the program (implementation), the chart is continually referred to as the master-plan.|$|R
50|$|Literate programming, {{as a form}} of {{imperative}} <b>programming,</b> <b>structures</b> <b>programs</b> as a human-centered web, as in a hypertext essay: documentation {{is integral}} to the program, and the <b>program</b> is <b>structured</b> following the logic of prose exposition, rather than compiler convenience.|$|R
40|$|Proposes {{a design}} method for the {{development}} of software in Visual BASIC whose programming environment is multi-paradigm. Extensions to <b>structure</b> <b>charts</b> and pseudocode to incorporate the three paradigms have been developed {{based on the premise that}} procedural models, event-driven forms and objects are mutually exclusive in operation...|$|R
5000|$|Prioritizing {{academic}} programs within the approved <b>program</b> <b>structure</b> ...|$|R
40|$|In this paper, {{we define}} a Mathematical model of <b>program</b> <b>structure.</b> Mathematical model of <b>program</b> <b>structure</b> defined here {{provides}} unified mathematical treatment of <b>program</b> <b>structure,</b> which reveals that a {{program is a}} large and finite set of embedded binary relations between current statement and previous ones. Then, a program is considered as a composed listing and a logical combination of multiple statements according to the certain composing rules. We also define the Scope Information Complexity Number (SICN) and present the cognitive complexity based on functional decomposition of software, including theoretical validation through nine Weyuker's properties...|$|R
