5|119|Public
5000|$|In Visual Basic a <b>procedure</b> <b>argument</b> can be {{declared}} to be optional by prefixing {{it with the}} [...] keyword. When the argument is omitted Visual Basic passes a special value to the procedure, called Missing in the table above, indicating that the argument is missing. Since the value could either be a supplied value or a special value, a variant must be used.Function GetText(Optional ByVal Index) As String If IsMissing(Index) Then GetText = Item(CurrentItem) Else GetText = Item(Index) End IfEnd FunctionSimilarly the keyword [...] {{can be used to}} pass all following arguments in a variant array.|$|E
40|$|The moral {{principle}} of fairness or fair play {{is widely believed}} to be a solid ground for political obligation, i. e., a general prima facie moral duty to obey the law qua law. In this article, I advance a new and, more importantly, principled objection to fairness theories of political obligation by revealing and defending a justificatory gap between the {{principle of}} fairness and political obligation: the duty of fairness on its own is incapable of preempting the citizen‟s liberty to reciprocate fairly in ways other than obeying the law. This justificatory gap is unaffected by the ongoing debate between the voluntarist and the nonvoluntarist accounts of fairness, and it cannot be bridged by the two arguments that are perhaps implicit in Klosko‟s account, namely the presumptive benefits argument and the democratic <b>procedure</b> <b>argument...</b>|$|E
40|$|Traditional {{schemes for}} {{abstract}} interpretation-based global analysis of logic programs generally focus on obtaining <b>procedure</b> <b>argument</b> mode and type information. Variable sharing information is often given only the attention needed {{to preserve the}} correctness of the analysis. However, such sharing information can be very useful. In particular, {{it can be used}} for predicting runtime goal independence, which can eliminate costly run-time checks in and-parallel execution. In this paper, a new algorithm for doing abstract interpretation in logic programs is described which concentrates on inferring the dependencies of the terms bound to program variables with increased precision and at all points in the execution of the program, rather than just at a procedure level. Algorithms are presented for computing abstract entry and success substitutions which extensively domain independent fixpoint algorithm is presented and described in detail. The algorithms are illustrated with examples. Finally, results from an implementation of the abstract interpreter are presented. ...|$|E
5000|$|... #Subtitle level 4: Order of {{evaluation}} of <b>procedure</b> <b>arguments</b> ...|$|R
5000|$|Most Lisps specify {{an order}} of {{evaluation}} for <b>procedure</b> <b>arguments.</b> Scheme does not. Order of evaluation—including {{the order in which}} the expression in the operator position is evaluated—may be chosen by an implementation on a call-by-call basis, and the only constraint is that [...] "the effect of any concurrent evaluation of the operator and operand expressions is constrained to be consistent with some sequential order of evaluation." [...] (R5RS sec. 4.1.3) ...|$|R
50|$|In civil <b>procedure,</b> certain <b>arguments</b> must {{be raised}} in the first {{objection}} that a party submits to the court, or else they will be deemed waived.|$|R
40|$|Reverse {{communication}} {{is a means}} of avoiding procedure arguments in the parameter list of a procedure. Most numerical routines use the alternative, forward (or direct) communication approach, i. e. they are called only once to compute results; they completely specify the problem by including user-provided procedures in the argument list. In the majority of applications this is the easiest and most convenient way to solve numerical problems. In a forward communication routine to minimize a function the user supplies the objective function and/or nonlinear constraints as a procedure, or a set of procedures, which is evaluated for any values of its arguments. This procedure will have a strict format of how the information might be supplied and this can lead to some restrictions. For example the specification of the userprovided procedure might not allow the user to pass some useful information. Alternatively the routine might be called in a mixed language environment and this too can lead to difficulties passing a <b>procedure</b> <b>argument.</b> A way to get around these problems is to use a reverse communicatio...|$|E
40|$|Unification, in {{distributed}} implementations {{of logic}} programming, involves sending and receiving messages to access data structures spread among different nodes. In traditional implementations, processes access remote data structures by exchanging messages which carry either the overall data structures or only remote references to them. Intermediate but fixed solutions are also possible. These fixed policies can {{be far from}} optimal on various classes of programs and may induce substantial overhead. This paper presents an implementation scheme for distributed logic programming which consists of tailoring the copying level for each <b>procedure</b> <b>argument.</b> The scheme {{is based on a}} consumption specification which describes the way each procedure "consumes" its arguments locally. Consumption specification avoids unnecessary copying and allows to request data structures globally. The consumption specification (or its approximation) can be obtained through a static analysis inspired by traditional type analyses. The paper presents two implementations which exploit the consumption specification. The low-level implementation extends the Warren abstract Machine with instructions and data structures for exploiting the consumption specification during code compilation. The high-level implementation is based on attributed variables in order to capture and implement, at a higher-level, distributed unification. Experimental results of the high-level implementation on a network of workstations show the potential of the approach...|$|E
40|$|The lambda and procedure-application {{forms in}} PLT Scheme support {{arguments}} that are tagged with keywords, instead of identified by position, {{as well as}} optional arguments with default values. Unlike previous keyword-argument systems for Scheme, a keyword is not self-quoting as an expression, and keyword arguments use a different calling convention than non-keyword arguments. Consequently, a keyword serves more reliably (e. g., in terms of error reporting) as a lightweight syntactic delimiter on <b>procedure</b> <b>arguments.</b> Our design requires no changes to the PLT Scheme cor...|$|R
30|$|In gynecology, supracervical {{hysterectomy}} {{has been}} attractive {{for patients with}} fibroids or abnormal bleeding {{and the absence of}} a specific indication for removal of the cervix, citing lower complication rates (less bleeding, fewer infections/abscesses and vaginal cuff hematomas, trauma to urinary tract), shorter operative times, less postoperative pain, faster recovery, and a less complicated <b>procedure.</b> <b>Arguments</b> against the supracervical procedure are the potential for bleeding from residual endometrium in the cervical stump, absence of using the vagina as a port for specimen removal, the need for a continued cervical screening program, and the potential risk of future cervical pathology [10 – 14].|$|R
40|$|Keep it simple! Let {{the tasks}} do the work. What’s new? What’s new since the User’s Guide? scan() from a pipe printf() – more C-like than SPP The CL printf is called as a task, {{not as a}} {{function}} in expressions, but CL printf requires no call, unlike SPP CL printf supports same formats as SPPProcedure Scripts All scripts should be procedure scripts The task name must match the file name <b>procedure</b> <b>arguments</b> are query parameters Two CL modes, “command ” & “compute” Command mode is used interactively Compute mode requires parentheses, commas and quoted string literal...|$|R
40|$|Trigeminal {{neuralgia}} {{is a type}} {{of facial}} pain that is difficult to treat. The pain can be excruciating and debilitating. The wide range of treatments currently used for trigeminal neuralgia is ample evidence that there is no simple answer to how it should be managed. This review will evaluate the current surgical procedures used for the treatment of trigeminal neuralgia. A critical analysis of the evidence-based studies to date was done to evaluate and compare the efficacy of the different surgical <b>procedures.</b> <b>Arguments</b> for and against the use of surgery for trigeminal neuralgia are presented. In addition, the surgical procedures were compared with other treatments for trigeminal neuralgia...|$|R
5000|$|In Fortran, <b>procedure</b> <b>arguments</b> {{and other}} {{variables}} may not alias each other (unless they are pointers {{or have the}} target attribute), and the compiler assumes they do not. This enables excellent optimization, and is one major reason for Fortran's reputation as a fast language. (Note that aliasing may still occur within a Fortran function. For instance, if [...] is an array and [...] and [...] are indices which happen {{to have the same}} value, then [...] and [...] are two different names for the same memory location. Fortunately, since the base array must have the same name, index analysis can be done to determine cases where [...] and [...] cannot alias.) ...|$|R
40|$|Understanding {{procedure}} calls {{is crucial}} in computer science and everyday programming. Among the most common strategies for passing <b>procedure</b> <b>arguments</b> ('evaluation strategies') are 'call-by-name', 'call-by-need', and 'call-by-value', where the latter is the most commonly used. While reasoning about procedure calls is simple for call-by-name, problems arise for call-by-need and call-by-value, because it matters how often and in which order the <b>arguments</b> of a <b>procedure</b> are evaluated. We shall classify these problems and see {{that all of them}} occur for call-by-value, some occur for call-by-need, and none occur for call-by-name. In that sense, call-by-value is the 'greatest common denominator' of the three evaluation strategies. Reasoning about call-by-value programs has been tackled by Eugenio Moggi's 'computational lambda-calculus', which is based on a distinction between 'values' and arbitrary expressions. However, the computational lambda-calculus deals only implicitly with the evaluation order and the number of evaluations of <b>procedure</b> <b>arguments.</b> Therefore, certain program equivalences that {{we should be able to}} spot immediately require long proofs. We shall remedy this by introducing a new calculus - the 'let-calculus' - that deals explicitly with evaluation order and the number of evaluations. For dealing with the number of evaluations, the let-calculus has mechanisms known from; linear, affine, and relevant logic. For dealing with evaluation order, it has mechanisms which seems to be completely new. We shall also introduce a new kind of denotational semantics for call-by-value programming languages. The key idea is to consider how categories with finite products are commonly used to model call-by-name languages, and remove the axioms which break for call-by-value. The resulting models we shall call 'precartesian categories'. These relatively simple structures have remarkable mathematical properties, which will inspire the design of the let-calculus. Precartesian categories will provide a semantics of both the let-calculus and the computational lambda-calculus. This semantics not only validates the same program equivalences as Moggi's monad-based semantics of the computational lambda-calculus; It is also 'direct' by contrast to Moggi's semantics, which implicitly performs a language transform. Our direct semantics has practical benefits: It clarifies issues that are related with the evaluation order and the number of evaluations of <b>procedure</b> <b>arguments,</b> and it is also very easy to remember. The thesis is rounded up by three applications of the let-calculus and precartesian categories: First, construing well-established models of partiality (i. e. categories of generalised partial functions) as precartesian categories, and specialising the let-calculus accordingly. Second, adding global state to a given computational system and construing the resulting system as a precartesian category. Third, analysing an implementation technique called 'continuation-style transform' by construing the source language of such a transform as a precartesian category...|$|R
40|$|In this chapter, we {{reflect on}} the key role of {{semiotic}} representations in constructing and communicating mathematical knowledge, since they are essential components of mathematical practices. However, other mathematical entities, such as concepts, propositions, <b>procedures</b> and <b>arguments</b> intervene in these practices, in addition t...|$|R
40|$|For {{nonlinear}} Schroedinger equations {{with a power}} nonlinearity, a {{new approach}} to derive the conservation law of the momentum and the pseudo conformal conservation law is obtained. Since this approach does not contain approximating <b>procedure,</b> the <b>argument</b> is simplified to derive these conservation laws. Comment: 8 page...|$|R
5000|$|Parameters {{appear in}} <b>procedure</b> definitions; <b>arguments</b> appear in <b>procedure</b> calls. In the {{function}} definition [...] the variable x is a parameter; in the function call [...] the value 2 {{is the argument}} of the function. Loosely, a parameter is a type, and an argument is an instance.|$|R
40|$|Abstract. Almost all current Prolog {{systems are}} based on the Warren Abstract Machine (WAM), in which {{registers}} are used to pass <b>procedure</b> <b>arguments</b> and store temporary variables. In this paper, we present a stack machine for Prolog, named TOAM Jr., which departs from the TOAM adopted in early versions of B-Prolog in that it employs no registers for arguments or temporary variables, and offers variable-size instructions for encoding procedure calls. TOAM Jr. is suitable for fast bytecode interpretation: the use of coarse-grained instructions results in more compact code and execution of fewer instructions than the use of fine-grained instructions; and the omission of registers facilitates interpretation of tagged operands and instruction merging. TOAM Jr. has been employed in B-Prolog since Version 7. 0. Benchmarking shows that TOAM Jr. significantly enhances the speed of B-Prolog. ...|$|R
50|$|<b>Procedures</b> {{often take}} <b>arguments.</b> They are {{handled by the}} {{procedure}} in a very specific way, {{different from that of}} other programming languages.|$|R
5000|$|CREATE TRIGGER name { BEFORE | AFTER } { event OR ... } ON TABLE FOR EACH [...] EXECUTE <b>PROCEDURE</b> funcname ( [...] <b>arguments</b> [...] ) ...|$|R
30|$|Curriculum genres can be {{contrasted with}} {{knowledge}} genres, {{which include the}} written genres of the school, such as stories, chronicles, explanations, reports, <b>procedures,</b> <b>arguments</b> and text responses (Martin & Rose, 2008). Knowledge genres configure the fields of curriculum subjects, such as history, science, mathematics, literature. Students learn {{to read and write}} these knowledge genres, {{at the same time as}} learning the curriculum content, by participating in the curriculum genres of the classroom. While curriculum content is taught explicitly, its knowledge genres are usually left implicit, but can be made explicit (Rose & Martin, 2012). For example, in the lessons reported here students learnt to read and write scientific reports at the same time as learning about bird species. Understanding that language realises both genre and register enables explicit language teaching to be embedded in subject teaching.|$|R
50|$|PROMAL (PROgrammer's Microapplication Language) is a {{structured}} programming language from Systems Management Associates for MS-DOS, Commodore 64, and Apple II. PROMAL features simple syntax, no line numbers, long variable names, functions and <b>procedures</b> with <b>argument</b> passing, real number type, arrays, strings, pointer, and a built-in I/O library. Like ABC and Python, indentation {{is part of}} the language syntax.|$|R
40|$|Plotkin [Theor. Comp. Sci. 1975] {{showed that}} the lambda {{calculus}} is a good model of the evaluation process for call-by-name functional programs. Reducing programs to constants or lambda abstractions according to the leftmost-outermost strategy exactly mirrors execution on an abstract machine like Landin's SECD machine. The machine-based evaluator returns a constant or the token closure {{if and only if}} the standard reduction sequence starting at the same program will end in the same constant or in some lambda abstraction. However, the calculus does not capture the sharing of the evaluation of arguments that lazy implementations use to speed up the execution. More precisely, a lazy implementation evaluates <b>procedure</b> <b>arguments</b> only when needed and then only once. All other references to the formal procedure parameter re-use the value of the first argument evaluation. The mismatch between the operational semantics of the lambda calculus and the actual behavior of the prototypical implement [...] ...|$|R
40|$|Programs {{for data}} flow {{machines}} {{are written in}} functional languages, some of which require efficient support for dynamic procedure invocation to achieve high performance and programming flexibility. Among the proposed data flow machines, few support procedures in any generality. Our machine, which is a hardware realization of the U-interpreter for data flow languages, provides support {{for a variety of}} procedure calling conventions. Because the U-interpreter assigns a unique activity name to each instance of a computation (activity), an activity name may become arbitrarily large in the case of nested or recursive procedure calls. Hardware considerations, however, require that an activity name be represented by a fixed-size tag. We describe a mechanism that uses fixed-size, reusable tags in hardware. Like processor and memory resources, a group of tags is allocated and deallocated for each procedure activation. The proposed mechanism passes <b>procedure</b> <b>arguments</b> and results efficiently, given the distributed environment of our machine...|$|R
40|$|It {{is argued}} that a {{programming}} style based on higher order techniques [...] -the use of procedures that have other <b>procedures</b> as <b>arguments</b> and/or results [...] -can be most effectively employed if ffl it is driven by abstraction from real algorithms, rather than attempting {{to work with a}} fixed set of functional forms; and ffl the use of imperative forms and mutative procedures is permitted (even encouraged!), rather than restricting to a purely applicative style. A sequence of examples is presented illustrating a number of higher order techniques [...] - operators, iterators, accumulation, reduction, parallel reduction [...] -and their effective use in conjunction with mutative procedures. The examples culminate with an interesting family of sorting algorithms, illustrating how higher order techniques can lead naturally to new algorithms. 1 Introduction The central idea of higher order programming is the use of higher order procedures; i. e., procedures that take other <b>procedures</b> as <b>arguments</b> and/or r [...] ...|$|R
40|$|International audienceWe {{study the}} {{magnetic}} Laplacian {{in the case}} when the Neumann boundary contains an edge. We provide complete asymptotic expansions in powers of h^ 1 / 4 of the low lying eigenpairs in the semiclassical limit h→ 0. In order to get our main result we establish a general method based on a normal form <b>procedure,</b> microlocal <b>arguments,</b> the Feshbach-Grushin reduction and the Born-Oppenheimer approximation...|$|R
5000|$|Distributed or {{asynchronous}} {{message passing}} has some overhead {{associated with it}} compared to the simpler way of simply calling a procedure. In a traditional <b>procedure</b> call, <b>arguments</b> are passed to the receiver typically {{by one or more}} general purpose registers or in a parameter list containing the addresses of each of the arguments. This form of communication differs from message passing in at least three crucial areas: ...|$|R
40|$|The {{prevalence}} of multicore processors {{is bound to}} drive most kinds of software development towards parallel programming. To limit the difficulty and overhead of parallel software design and maintenance, {{it is crucial that}} parallel programming models allow an easy-to-understand, concise and dense representation of parallelism. Parallel programming models such as Cilk++ and Intel TBBs attempt to offer a better, higher-level abstraction for parallel programming than threads and locking synchronization. It is not straightforward, however, to express all patterns of parallelism in these models. Pipelines are an important parallel construct, although difficult to express in Cilk and TBBs in a straightfor- ward way, not without a verbose restructuring of the code. In this paper we demonstrate that pipeline parallelism can be easily and concisely expressed in a Cilk-like language, which we extend with input, output and input/output dependency types on <b>procedure</b> <b>arguments,</b> enforced at runtime by the scheduler. We evaluate our implementation on real applications and show that our Cilk-like scheduler, extended to track and enforce these dependencies has performance comparable to Cilk++...|$|R
40|$|Progress on {{automated}} termination detection for logic {{programs is}} reported. The prospects for handling a large class of programs completely automatically appear promising, {{in contrast to}} the bleak picture for procedural languages. The methods reported are based on term size analysis of <b>procedure</b> <b>arguments.</b> Argument sizes of derivable facts involving an n-ary predicate are viewed as points in the positive orthant of R n. We describe a method of nding a nonnegative linear combination of bound argument sizes that (if it is found) is guaranteed to decrease during top-down execution of recursive rules. Duality theory of linear programming is used. This methodology can handle nonlinear recursion, mutual recursion, and cases in which no specific argument is certain to decrease; while it requires rules to have a certain form, this form is attainable by known syntactic transformations. Several programs that could not be shown to terminate by earlier published methods are handled successfully. However, it only analyzes a su cient condition; a procedure may terminate without our methodology detecting that fact...|$|R
40|$|Keywords: Abstract. This article {{presents}} a convenient and efficient procedural interface {{that allows the}} definition and use of <b>procedures</b> with optional <b>arguments</b> and indefinite numbers of arguments without resorting {{to the use of}} a language-dependent data structure in which to store the arguments. This interface solves many of the problems inherent in the use of lists in Lisp and Scheme to store indefinite numbers of arguments. Simple recursion can be used to consume such arguments without the complexity problems that are caused by the use of the Lisp <b>procedure</b> apply on <b>argument</b> lists. A natural extension to the interface to support multiple return values is presented. ...|$|R
50|$|The new act {{decreases}} initial {{input from}} biologists and accelerates {{movement of the}} project to the legal hearing stage. Upon receipt of the project description, the agency has 10 days to request additional information and post the project description on the internet. Following 20 days in which the public may post comments, the agency has 25 days to decide if the project requires a formal environmental assessment. Different bodies may conduct the assessment, but all assessments now follow judicial <b>procedures</b> of <b>argument</b> and counter-argument.|$|R
25|$|In R5RS, a {{suggested}} {{implementation of}} delay and force is given, implementing the promise as a <b>procedure</b> with no <b>arguments</b> (a thunk) and using memoization {{to ensure that}} it is only ever evaluated once, irrespective of the number of times force is called (R5RS sec. 6.4).|$|R
50|$|Interfaces are {{commonly}} used in the Java language for callbacks, as Java does not allow multiple inheritance of classes, nor does it allow the passing of methods (<b>procedures)</b> as <b>arguments.</b> Therefore, in order to pass a method as a parameter to a target method, current practice is to define and pass a reference to an interface {{as a means of}} supplying the signature and address of the parameter method to the target method rather than defining multiple variants of the target method to accommodate each possible calling class.|$|R
2500|$|As {{in other}} Lisps, the term [...] "thunk" [...] {{is used in}} Scheme {{to refer to a}} <b>procedure</b> with no <b>arguments.</b> The term [...] "proper tail recursion" [...] refers to the {{property}} of all Scheme implementations, that they perform tail-call optimization so as to support an indefinite number of active tail calls.|$|R
40|$|The RoHS Directive bans lead, cadmium, {{hexavalent}} chromium, mercury, PBB and PBDE from use {{in electrical}} and electronic equipment. The ELV Directive bans the same metals from uses in vehicles. Both Directives, however, allow exemptions from these material bans under specific conditions, which are reviewed periodically. The RoHS Directive additionally allows applying for new exemptions under specific conditions. This paper {{reports about the}} conditions for exemptions, about the <b>procedure</b> and <b>arguments</b> to obtain new exemptions {{and the status of}} the review of all existing exemptions in the ELV and the RoHS Directive in 2007 and in 2008...|$|R
50|$|By contrast, the {{arguments}} are the values supplied to the procedure {{when it is}} called. Unlike the parameters, which form an unchanging part of the <b>procedure's</b> definition, the <b>arguments</b> may vary from call to call. Each time a procedure is called, {{the part of the}} procedure call that specifies {{the arguments}} is called the argument list.|$|R
