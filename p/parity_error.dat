34|92|Public
2500|$|The PERR# line is {{only used}} during data phases, once a target has been selected. [...] If a <b>parity</b> <b>error</b> is {{detected}} during an address phase (or the data {{phase of a}} Special Cycle), the devices which observe it assert the SERR# (System error) line.|$|E
2500|$|The PCI bus detects parity errors, {{but does}} not attempt to correct them by {{retrying}} operations; it is purely a failure indication. [...] Due to this, {{there is no need}} to detect the <b>parity</b> <b>error</b> before it has happened, and the PCI bus actually detects it a few cycles later. [...] During a data phase, whichever device is driving the AD lines computes even parity over them and the C/BE# lines, and sends that out the PAR line one cycle later. [...] All access rules and turnaround cycles for the AD bus apply to the PAR line, just one cycle later. [...] The device listening on the AD bus checks the received parity and asserts the PERR# (<b>parity</b> <b>error)</b> line one cycle after that. [...] This generally generates a processor interrupt, and the processor can search the PCI bus for the device which detected the error.|$|E
5000|$|Channel data checkPoOps {{indicates}} a <b>parity</b> <b>error</b> during a data transfer.|$|E
50|$|Some {{methods are}} {{designed}} to avoid the <b>parity</b> <b>errors</b> described above. For instance, solving the corners and edges first and the centers last would avoid such <b>parity</b> <b>errors.</b> Once {{the rest of the}} cube is solved, any permutation of the center pieces can be solved. Note {{that it is possible to}} apparently exchange a pair of face centers by cycling 3 face centers, two of which are visually identical.|$|R
50|$|Another similar {{approach}} to solving this cube is to first pair the edges, {{and then the}} centers. This, too, is vulnerable to the <b>parity</b> <b>errors</b> described above.|$|R
50|$|Intel's Pentium 4, Intel Xeon, P6 family {{processors}} {{as well as}} the Itanium architecture {{implement a}} machine check architecture that provides a mechanism for detecting and reporting hardware (machine) errors, such as: system bus <b>errors,</b> ECC <b>errors,</b> <b>parity</b> <b>errors,</b> cache errors, and translation lookaside buffer errors. It consists of a set of model-specific registers (MSRs) that are used to set up machine checking and additional banks of MSRs used for recording errors that are detected.|$|R
5000|$|Memory {{consist of}} 64 Kbit 150 ns memory modules. <b>Parity</b> <b>error</b> {{protected}} setup.|$|E
5000|$|... 32 KiB {{instruction}} + 32 KiB data L1 cache per core, L1 cache includes <b>parity</b> <b>error</b> detection ...|$|E
50|$|The status {{register}} indicates {{the status of}} the IRQ, DSR and DCD lines, transmitter and receiver data Registers, and overrun, framing and <b>parity</b> <b>error</b> conditions.|$|E
5000|$|System Reset sends a reset signal {{on every}} I/O channel and clears the {{processor}} state; all pending interruptions are cancelled. System Reset is not guaranteed to correct <b>parity</b> <b>errors</b> in general registers, floating point registers or storage. System Reset does not reset {{the state of}} shared I/O devices.|$|R
5000|$|The DS-3 M-frame uses P bits {{to check}} the line parity. The M-subframe uses C bits in a format called C-bit parity, which copies {{the result of the}} P bits at the source and checks the result at the destination. An ATM {{interface}} reports detected C-bit <b>parity</b> <b>errors</b> back to the source via a far-end block error (FEBE). ( [...] Cisco.com all rights reserved) ...|$|R
50|$|One {{strategy}} involves grouping similar edge pieces into solid strips, and centers into one-colored blocks. This {{allows the}} cube to be quickly solved {{with the same}} methods one would use for a 3×3×3 cube. Because the permutations of the corners, central edges and fixed centers have the same parity restrictions as the 3×3×3 cube, the <b>parity</b> <b>errors</b> seen on the 4×4×4 and 6×6×6 cannot occur on the 7×7×7 unless the cube has been tampered with.|$|R
50|$|Similarly, {{the data}} bus is often {{designed}} to suit specific needs such as serial or parallel data access, {{and the memory}} may be designed to provide for <b>parity</b> <b>error</b> detection or even error correction in expensive business systems.|$|E
50|$|A <b>Parity</b> <b>Error</b> {{occurs when}} the parity {{of the number of}} 1 bits disagrees with that {{specified}} by the parity bit. Use of a parity bit is optional, so this error will only occur if parity-checking has been enabled.|$|E
50|$|The PERR# line is {{only used}} during data phases, once a target has been selected. If a <b>parity</b> <b>error</b> is {{detected}} during an address phase (or the data {{phase of a}} Special Cycle), the devices which observe it assert the SERR# (System error) line.|$|E
50|$|People able {{to rapidly}} solve puzzles like this usually favour the {{reduction}} method of grouping similar edge pieces into solid strips, and centers into one-colored blocks. This allows the cube to be quickly solved {{with the same}} methods one would use for a 3×3×3 cube. As illustrated to the right, the fixed centers, middle edges and corners can be treated as equivalent to a 3×3×3 cube. As a result, the <b>parity</b> <b>errors</b> sometimes seen on the 4×4×4 cannot occur on the 5×5×5 unless the cube has been tampered with.|$|R
25|$|One {{major feature}} that distinguishes ZFS from other file systems {{is that it}} is {{designed}} with a focus on data integrity by protecting the user's data on disk against silent data corruption caused by data degradation, current spikes, bugs in disk firmware, phantom writes (the previous write did not make it to disk), misdirected reads/writes (the disk accesses the wrong block), DMA <b>parity</b> <b>errors</b> between the array and server memory or from the driver (since the checksum validates data inside the array), driver errors (data winds up in the wrong buffer inside the kernel), accidental overwrites (such as swapping to a live file system), etc.|$|R
40|$|An early {{experience}} of camp laparoscopic sterilization in Gujarat State, India, resulted in 22 deaths among 106, 500 women undergoing the operation during 1979 and 1980. Increased {{risk of death}} was seen when larger numbers of procedures were performed by year or month of year. The least experienced surgeons had the highest case-fatality rate. Improvised settings (i. e., school buildings) exacerbated the risk of death, as did advanced age, and, to a lesser extent, high <b>parity.</b> <b>Errors</b> in clinical judgment were identified in some fatal procedures. A system of health audit of large sterilization programs is needed. Key words: sterilization deaths, laparoscopic sterilization, camp sterilizatio...|$|R
50|$|The PCI bus detects parity errors, {{but does}} not attempt to correct them by {{retrying}} operations; it is purely a failure indication. Due to this, {{there is no need}} to detect the <b>parity</b> <b>error</b> before it has happened, and the PCI bus actually detects it a few cycles later. During a data phase, whichever device is driving the AD31:0 lines computes even parity over them and the C/BE3:0# lines, and sends that out the PAR line one cycle later. All access rules and turnaround cycles for the AD bus apply to the PAR line, just one cycle later. The device listening on the AD bus checks the received parity and asserts the PERR# (<b>parity</b> <b>error)</b> line one cycle after that. This generally generates a processor interrupt, and the processor can search the PCI bus for the device which detected the error.|$|E
50|$|Electromechanical {{teleprinters}} {{were arranged}} to print a special character when received data contained a <b>parity</b> <b>error,</b> to allow detection of messages damaged by line noise. A single parity bit {{does not allow}} implementation of error correction on each character, and communication protocols working over serial data links will have higher-level mechanisms to ensure data validity and request retransmission of data that has been incorrectly received.|$|E
50|$|A Machine Check interruptionPoOps {{occurs to}} report unusual {{conditions}} {{associated with the}} channel or CPU that cannot be reported by another class of interruption. The most important class of conditions causing a Machine Check is a hardware error such as a <b>parity</b> <b>error</b> found in registers or storage, but some models may use it to report less serious conditions. Both the interruption code and the data stored in the scanout area at '80'x (128 decimal) are model dependent.|$|E
50|$|One {{major feature}} that distinguishes ZFS from other file systems {{is that it}} is {{designed}} with a focus on data integrity by protecting the user's data on disk against silent data corruption caused by data degradation, current spikes, bugs in disk firmware, phantom writes (the previous write did not make it to disk), misdirected reads/writes (the disk accesses the wrong block), DMA <b>parity</b> <b>errors</b> between the array and server memory or from the driver (since the checksum validates data inside the array), driver errors (data winds up in the wrong buffer inside the kernel), accidental overwrites (such as swapping to a live file system), etc.|$|R
50|$|There are {{a number}} of methods {{that can be used to}} solve a V-Cube 6. One method is to first group the center pieces of common colors together, then to match up edges that show the same two colors. Once this is done, turning only the outer layers of the cube allows it to be solved like a 3×3×3 cube. However, certain {{positions}} that cannot be solved on a standard 3×3×3 cube may be reached. For instance, a single quartet of edges may be inverted, or the cube may appear to have an odd permutation (that is, two pieces must be swapped, which is not possible on the 3×3×3 cube). These situations are known as <b>parity</b> <b>errors,</b> and require special algorithms to be solved.|$|R
40|$|We {{employ the}} methods {{presented}} in the previous chapter for decoding corrupted codewords, encoded using sparse <b>parity</b> check <b>error</b> correcting codes. We show the similarity between the equations derived from the TAP approach and those obtained from belief propagation, and examine their performance as practical decoding methods...|$|R
50|$|The AMD K8 has a {{combined}} bimodal and global predictor, where the combining choice is another bimodal predictor. This processor caches {{the base and}} choice bimodal predictor counters in bits of the L2 cache otherwise used for ECC. As a result, it has effectively very large base and choice predictor tables, and parity rather than ECC on instructions in the L2 cache. Parity is just fine, since any instruction suffering a <b>parity</b> <b>error</b> can be invalidated and refetched from memory.|$|E
50|$|The SPARCstation 2 can be {{configured}} {{with up to}} 128 MB {{of memory}} in total: 64 MB on the motherboard, and an additional 64 MB using a special 32 MB SBus memory card with another 32 MB piggy-backed daughterboard. The 16 RAM slots on the motherboard can be populated with either 1 MB SIMMs {{for a total of}} 16 MB, or with 4 MB SIMMs for a total of 64 MB. Standard 30 pin SIMMs can be used as long as they use <b>parity</b> <b>error</b> detection and are rated 80 ns or faster.|$|E
50|$|SCSI is an intelligent, peripheral, buffered, {{peer-to-peer}} interface, {{hiding the}} complexity of the physical format. Every device attaches to the SCSI bus in a similar manner. Up to 8 or 16 devices can be attached to a single bus. There can be any number of hosts and peripheral devices but there should be at least one host. SCSI uses handshake signals between devices, SCSI-1, SCSI-2 have the option of <b>parity</b> <b>error</b> checking. Starting with SCSI-U160 (part of SCSI-3) all commands and data are error checked by a CRC32 checksum.|$|E
40|$|We {{propose a}} method {{based on the}} {{magnetization}} enumerator to determine the critical noise level for Gallager type low density <b>parity</b> check <b>error</b> correcting codes (LDPC). Our method provides an appealingly simple interpretation to the relation between different decoding schemes, and provides more optimistic critical noise levels than those reported in the information theory literature...|$|R
40|$|We {{report the}} {{computational}} advances that have enabled the first micron-scale simulation of a Kelvin-Helmholtz (KH) instability us-ing molecular dynamics (MD). The advances are in three key areas for massively parallel computation such as on BlueGene/L (BG/L) : fault tolerance, application kernel optimization, and distribution across the parallel architecture. In particular, {{we have developed}} novel capabilities for handling hardware <b>parity</b> <b>errors</b> and improved particle-based domain decomposition algorithms to minimize com-munication overhead, achieve excellent scalability, and improve overall application performance. We have also extended the ddcMD code to handle commonly used Embedded Atom Method (EAM) interatomic potentials efficiently. As a result we have conducted a 2 billion atom KH simulation amounting to 2. 8 CPU-millennia of run time, including a single, continuous simulation run in ex-cess of 1. 5 CPU-millennia. The current optimized ddcMD code is benchmarked at 54. 3 TFlop/s with the EAM potential, with addi-tional improvements ongoing. These improvements enabled us to run the first MD simulation of a micron-scale system developing a KH instability. 1...|$|R
40|$|Abstract—Early in the {{deployment}} of the Advanced Simulation and Computing (ASC) Q supercomputer, a higher-than-expected number of single-node failures was observed. The elevated rate of single-node failures was hypothesized to be caused primarily by fatal soft errors, i. e., board-level cache (B-cache) tag (BTAG) <b>parity</b> <b>errors</b> caused by cosmic-ray-induced neutrons that led to node crashes. A series of experiments was undertaken at the Los Alamos Neutron Science Center (LANSCE) to ascertain whether fatal soft errors were indeed {{the primary cause of}} the elevated rate of single-node failures. Observed failure data from Q are consistent with the results from some of these experiments. Mitigation strategies have been developed, and scientists successfully use Q for large computations in the presence of fatal soft errors and other single-node failures. Index Terms—Cosmic-ray-induced neutron, life estimation, linear accelerators, memory testing, neutron beam, neutron-induced soft error, neutron radiation effects, semiconductor-device radiation effects, semiconductor-device testing, single-event upset, soft-error rate, static random access memory (SRAM) chips...|$|R
50|$|In the {{original}} IBM PC, an NMI was triggered if a <b>parity</b> <b>error</b> was detected in system memory, or reported by an external device. In either case, the PC would display an error message and halt. Some later PC clones used an NMI {{to conceal the}} hardware differences {{from that of a}} standard PC. On such computers, an NMI would be generated when a program attempted to access incompatible hardware. A BIOS interrupt handler would then translate the program's request to match the hardware that was actually present. The SMM in the 386SL is a better way to do this.|$|E
50|$|The {{diagnostic}} microcomputer (based {{around the}} Zilog Z80) was embedded within the CPU. Its functions included running a system confidence check when power is first applied, bootstrapping the CPU, and taking control should an unrecoverable control store <b>parity</b> <b>error</b> be detected. It {{could also be}} used to load new microcode dynamically whilst the machine was running. An RS-232C interface was provided to which a terminal could be attached. Extensive diagnostics could then be run in conjunction with special microcode to perform fault analysis {{in the event of a}} system failure. Problems could usually be isolated to one or two integrated circuits.|$|E
50|$|If an {{odd number}} of bits (including the parity bit) are {{transmitted}} incorrectly, the parity bit will be incorrect, thus indicating that a <b>parity</b> <b>error</b> occurred in the transmission. The parity bit is only suitable for detecting errors; it cannot correct any errors, {{as there is no}} way to determine which particular bit is corrupted. The data must be discarded entirely, and re-transmitted from scratch. On a noisy transmission medium, successful transmission can therefore take a long time, or even never occur. However, parity has the advantage that it uses only a single bit and requires only a number of XOR gates to generate. See Hamming code for an example of an error-correcting code.|$|E
5000|$|There {{are several}} methods {{that can be}} used to solve a Rubik's Revenge. The most common method is reduction, so called because it {{effectively}} reduces the 4×4×4 to a 3×3×3. Cubers first group the centre pieces of common colours together, then pair edges that show the same two colours. Once this is done, turning only the outer layers of the cube allows it to be solved like a 3×3×3 cube. However, certain positions that cannot be solved on a standard 3×3×3 cube may be reached. There are two possible problems not found on the 3×3×3. The first is two edge pieces reversed on one edge, resulting in the colours for that edge not matching the rest of the cubies on either face: [...] Notice that these two edge pieces are swapped. The second is two edge pairs being swapped with each other: [...] These situations are known as <b>parity</b> <b>errors.</b> These positions are still solvable; however, special algorithms must be applied to fix the errors.|$|R
30|$|Provides {{more than}} 16.5 dB worth of SNR gain at a BER of 10 − 5 within the given {{simulation}} {{as compared to}} low density <b>parity</b> check (LDPC) <b>error</b> correcting codes.|$|R
40|$|A tape {{certification}} program tests the useability of magnetic tape at different densities by writing test patterns and re-reading them. The ability to certify tapes {{is important in}} environments that do large amounts of tape processing. TAPECERT is a VAX utility for tape certification in use at the Jet Propulsion Laboratory Multi-Mission Image Processing Laboratory which handles data from projects such as Voyager and Galileo. TAPECERT allows the user to select the tape density, the test pattern to use, the number of allowed retries, and whether to allow extended inter-record gaps to skip past bad spots on the tape. The program displays system <b>error</b> messages (<b>parity</b> <b>errors,</b> for instance) and record count information, with totals every 1000 blocks. TAPECERT is designed such that command procedures {{can be set up}} with defaults for different types of certification runs. TAPECERT is written in FORTRAN 77 for interactive execution and has been implemented on a DEC VAX series computer operating under VMS level 3. 7 and level 4. 2. TAPECERT utilizes standard VMS system services and run-time library routines. This program was developed in 1985...|$|R
