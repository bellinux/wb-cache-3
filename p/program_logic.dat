593|10000|Public
500|$|Furthermore, C# {{has added}} several major {{features}} to accommodate functional-style programming, {{culminating in the}} LINQ extensions released with C# 3.0 and its supporting framework of lambda expressions, extension methods, and anonymous types. [...] These features enable C# programmers to use functional programming techniques, such as closures, when it is advantageous to their application. The LINQ extensions and the functional imports help developers {{reduce the amount of}} boilerplate code that is included in common tasks like querying a database, parsing an xml file, or searching through a data structure, shifting the emphasis onto the actual <b>program</b> <b>logic</b> to help improve readability and maintainability.|$|E
500|$|In mid-2006, Bloc Party {{travelled}} to Lee's Grouse Lodge Studios in Westmeath, Ireland, {{to record}} A Weekend in the City. The band members initially worked by experimenting with their respective instruments and sound check arrangements. Moakes additionally focused on using {{different types of}} synthesiser. All parties soon moved to the main recording room, a large area with [...] "a lot of natural ambience" [...] according to sound engineer Tom McFall. A makeshift booth was built {{around the back of}} the drum kit to reduce any sonic interference, while a roof was sometimes used over drummer Matt Tong to isolate a pure sound. Different types of microphones were used for each component of the drum kit. The miking scheme was crucial to prepare the drum tracks for the looping and processing Lee planned using production <b>program</b> <b>Logic.</b>|$|E
2500|$|Prolog has {{its roots}} in first-order logic, a formal logic, and unlike many other {{programming}} languages, Prolog is intended as primarily a declarative programming language: the <b>program</b> <b>logic</b> is expressed in terms of relations, represented as facts and rules. [...] A computation is initiated by running a query over these relations.|$|E
50|$|<b>Logic</b> <b>programming</b> {{based on}} Resolution {{developed}} alongside functional <b>programming.</b> <b>Logic</b> <b>programming</b> {{is a form}} of relational programming that makes deductions about values. Constraint <b>logic</b> <b>programming</b> extends <b>logic</b> <b>programming,</b> by supporting constraints. Constraint <b>logic</b> <b>programming</b> languages such as ECLiPSe provide the ability to solve complex logic problems. However ECLiPSe is not lazy.|$|R
40|$|In {{this paper}} we define the rather general {{framework}} of Monotonic <b>Logic</b> <b>Programs,</b> where the main results of (definite) <b>logic</b> <b>programming</b> are validly extrapolated. Whenever defining new <b>logic</b> <b>programming</b> extensions, we can thus {{turn our attention}} to the stipulation and study of its intuitive algebraic properties within the very general setting. Then, the existence of a minimum model and of a monotonic immediate consequences operator is guaranteed, and they are related as in classical <b>logic</b> <b>programming.</b> Afterwards we study the more restricted class of residuated <b>logic</b> <b>programs</b> which is able to capture several quite distinct <b>logic</b> <b>programming</b> semantics. Namely: Generalized Annotated <b>Logic</b> <b>Programs,</b> Fuzzy <b>Logic</b> <b>Programming,</b> Hybrid Probabilistic <b>Logic</b> <b>Programs,</b> and Possibilistic <b>Logic</b> <b>Programming.</b> We provide the embedding of possibilistic <b>logic</b> <b>programming...</b>|$|R
40|$|This paper surveys various {{complexity}} and expressiveness results on {{different forms of}} <b>logic</b> <b>programming.</b> The main focus is on decidable forms of <b>logic</b> <b>programming,</b> in particular, propositional <b>logic</b> <b>programming</b> and datalog, but we also mention general <b>logic</b> <b>programming</b> with function symbols. Next to classical results on plain <b>logic</b> <b>programming</b> (pure Horn clause programs), more recent results on various important extensions of <b>logic</b> <b>programming</b> are surveyed. These include <b>logic</b> <b>programming</b> with different forms of negation, disjunctive <b>logic</b> <b>programming,</b> <b>logic</b> <b>programming</b> with equality, and constraint <b>logic</b> <b>programming...</b>|$|R
2500|$|In Prolog, <b>program</b> <b>logic</b> is {{expressed}} in terms of relations, and a computation is initiated by running a query over these relations. [...] Relations and queries are constructed using Prolog's single data type, the term. Relations are defined by clauses. [...] Given a query, the Prolog engine attempts to find a resolution refutation of the negated query. If the negated query can be refuted, i.e., an instantiation for all free variables is found that makes the union of clauses and the singleton set consisting of the negated query false, it follows that the original query, with the found instantiation applied, is a logical consequence of the program. This makes Prolog (and other logic programming languages) particularly useful for database, symbolic mathematics, and language parsing applications. [...] Because Prolog allows impure predicates, checking the truth value of certain special predicates may have some deliberate side effect, such as printing a value to the screen. [...] Because of this, the programmer is permitted to use some amount of conventional imperative programming when the logical paradigm is inconvenient. [...] It has a purely logical subset, called [...] "pure Prolog", {{as well as a number}} of extralogical features.|$|E
5000|$|Declarative {{programming}} - defines <b>program</b> <b>logic,</b> but not detailed control flow.|$|E
50|$|<b>Program</b> <b>logic</b> can tie all of {{the above}} {{elements}} together using constructs such as if-then-else statements and logical operators.|$|E
40|$|In {{this paper}} we show the {{embedding}} of Hybrid Probabilistic <b>Logic</b> <b>Programs</b> into the rather general framework of Residuated <b>Logic</b> <b>Programs,</b> where the main results of (de nite) <b>logic</b> <b>programming</b> are validly extrapolated, namely {{the extension of}} the immediate consequences operator of van Emden and Kowalski. The importance of this result is that for the rst time a framework encompassing several quite distinct <b>logic</b> <b>programming</b> semantics is described, namely Generalized Annotated <b>Logic</b> <b>Programs,</b> Fuzzy <b>Logic</b> <b>Programming,</b> Hybrid Probabilistic <b>Logic</b> <b>Programs,</b> and Possibilistic <b>Logic</b> <b>Programming.</b> Moreover, the embedding provides a more general semantical structure paving the way for de ning paraconsistent probabilistic reasoning with a <b>logic</b> <b>programming</b> semantics...|$|R
40|$|<b>Program</b> <b>logics</b> are modal logics used in software/hardware {{specification}} /verification {{for sound}} reasoning about <b>programs.</b> <b>Program</b> <b>logics</b> comprised dynamic logics, temporal logics, logics of process(es), and their extensions {{by means of}} fixpoints. A more recent addition {{to the family of}} <b>program</b> <b>logics</b> are logics of knowledge and belief. The talk introduces (on an informal level) several popular <b>program</b> <b>logics</b> (including Computation Tree Logic and Mu-Calculus), surveys fundamental results and research problems for this logics. Some links to software tools and experimental systems based on <b>program</b> <b>logics</b> are included. Several well-known computer scientists and mathematicians have contributed to this research domain, ex., E. M. Clarke, D. Harel, J. Halpern, D. Kozen, L. Lamport, Z. Manna, R. Parikh, A. Pnueli, V. R. Pratt, J. Sifacis, M. Vardi, etc. Their research are well known around the world. In contrast, research of scientists from former Soviet Union are less known abroad in spite [...] ...|$|R
40|$|Inductive <b>Logic</b> <b>Programming</b> (ILP) {{combines}} both Machine Learning and <b>Logic</b> <b>Programming</b> techniques. ILP uses first-order {{predicate logic}} restricted to Horn clauses as an underlying language. Thus, programs induced by an ILP system inherit the classical limitations of PROLOG <b>programs.</b> Constraint <b>Logic</b> <b>Programming</b> avoids some {{of the limitations of}} <b>Logic</b> <b>Programming</b> and so ILP aims to induce programs that employ this paradigm. Current ILP systems which induce constrained <b>logic</b> <b>programs</b> extend systems based on the normal semantics of ILP. In this paper we introduce ICLog, a new system which induces constrained <b>logic</b> <b>programs</b> and relies on an extension of a non-monotonic semantics-based system. We then present an application of IC-Log in the field of Computer-Aided Publishing. Keywords Machine Learning, Inductive <b>Logic</b> <b>Programming,</b> Inductive Constraint <b>Logic</b> <b>Programming.</b> 1 Introduction Inductive <b>Logic</b> <b>Programming</b> (ILP) combines both Machine Learning and <b>Logic</b> <b>Programming</b> techniq [...] ...|$|R
50|$|Unrau, Y.A. (2001). Using client exit {{interviews}} to illuminate outcomes in <b>program</b> <b>logic</b> models: A case example. Evaluation and Program Planning, 24(4), 353-361.|$|E
5000|$|Attempts {{to change}} {{the value of the}} object (by later programmers who do not fully {{understand}} the <b>program</b> <b>logic)</b> will be rejected by the compiler ...|$|E
5000|$|C. Calcagno, P. O'Hearn, R. Bornat; 2002; <b>Program</b> <b>Logic</b> and Equivalence in the Presence of Garbage Collection. To {{appear in}} Theoretical Computer Science special issue on Foundations.|$|E
5000|$|... writing {{graphical}} {{flow and}} java services (the <b>programming</b> <b>logic)</b> ...|$|R
40|$|Abstract. Nested <b>logic</b> <b>programs</b> and epistemic <b>logic</b> <b>programs</b> are two {{important}} extensions of answer set programming. However, {{the relationship between}} these two formalisms is rarely explored. In this paper we first introduce the epistemic HT-logic, and then propose a more general extension of <b>logic</b> <b>programs</b> called nested epistemic <b>logic</b> <b>programs.</b> The semantics of this extension- named equilibrium views- is defined {{on the basis of the}} epistemic HT-logic. We prove that equilibrium view semantics extends both the answer sets of nested <b>logic</b> <b>programs</b> and the world views of epistemic <b>logic</b> <b>programs.</b> Therefore, our work establishes a unifying framework for both nested <b>logic</b> <b>programs</b> and epistemic <b>logic</b> <b>programs.</b> Furthermore, we also provide a characterization of the strong equivalence of two nested epistemic <b>logic</b> <b>programs.</b> ...|$|R
40|$|In {{this paper}} we {{describe}} {{some of our}} progress towards an operational implementation of a modern <b>programming</b> <b>logic.</b> The logic is inspired by the variable type systems of Feferman, and is designed for reasoning about imperative functional <b>programs.</b> The <b>logic</b> goes well beyond traditional <b>programming</b> <b>logics,</b> such as Hoare’s logic and Dynamic logic in its expressibility, yet is less problematic to encode into higher order logics. The main focus of the paper is to...|$|R
5000|$|Multiple {{conditions}} can be coded for in similar manner to encapsulate the entire <b>program</b> <b>logic</b> {{in the form}} of an [...] "executable" [...] decision table or control table.|$|E
50|$|All Thread-shared non-concurrent Maps {{and other}} {{collections}} {{need to use}} some form of explicit locking such as native synchronization {{in order to prevent}} concurrent modification, or else there must be a way to prove from the <b>program</b> <b>logic</b> that concurrent modification cannot occur. Concurrent modification of a Map by multiple Threads will sometimes destroy {{the internal consistency of the}} data structures inside the Map, leading to bugs which manifest rarely or unpredictably, and which are difficult to detect and fix. Also, concurrent modification by one Thread with read access by another Thread or Threads will sometimes give unpredictable results to the reader, although the Map's internal consistency will not be destroyed. Using external <b>program</b> <b>logic</b> to prevent concurrent modification increases code complexity and creates an unpredictable risk of errors in existing and future code, although it enables non-concurrent Collections to be used. However, either locks or <b>program</b> <b>logic</b> cannot coordinate external threads which may come in contact with the Collection.|$|E
50|$|The University of Wisconsin Extension {{offers a}} series of {{guidance}} documents {{on the use of}} logic models. There is also an extensive bibliography of work on this <b>program</b> <b>logic</b> model.|$|E
40|$|We {{describe}} a derived <b>programming</b> <b>logic</b> for a generic structured assembly language. It has been {{combined with a}} compiler correctness theorem. This allows us to deduce correctness properties of object code from corresponding properties of the source code proved with the <b>programming</b> <b>logic.</b> All proofs {{have been carried out}} using the HOL system...|$|R
40|$|AbstractThis paper {{presents}} {{a method for}} mechanically proving the soundness of a <b>programming</b> <b>logic</b> for a distributed programming language, {{in support of the}} development of verified program verification tools. We focus on: 1. (1) how to formalize the operational semantics of a distributed programming language; 2. (2) how to formalize the concept of program correctness for distributed programs; 3. (3) how to mechanically prove the soundness of a <b>programming</b> <b>logic</b> with respect to the formal semantics of the language; 4. (4) how to use the mechanized and sound logic to develop verification tools with soundness guaranteed; and 5. (5) how to accomplish all above in the same formalism. Our <b>programming</b> <b>logic</b> permits the verification of single processes executing in isolation and, also, the verification of the composition of concurrently executing processes. Our method demonstrates that structuring the specification of operational semantics can ease the creation of a sound and mechanized <b>programming</b> <b>logic</b> for distributed <b>programming</b> languages. We believe that our method can be scaled up to larger distributed programming languages and their <b>programming</b> <b>logics.</b> The Cambridge HOL theorem proving system is used in our research...|$|R
40|$|<b>Logic</b> <b>programs</b> are an {{important}} knowledge representation tool. In many cases, definite <b>logic</b> <b>programs</b> are too restricted to formalize problems intuitively. Therefore definite <b>logic</b> <b>programs</b> have been extended in several ways by additional syntactic constructs such as negation and disjunction. A very expressive program class are generalized <b>logic</b> <b>programs.</b> Their rules may contain any quantifier free formula in both their body and head. Definite, normal and disjunctive <b>logic</b> <b>programs</b> are special cases of generalized <b>logic</b> <b>programs.</b> Constraint <b>logic</b> <b>programming,</b> defined in [4], extends definite <b>logic</b> <b>programs</b> by constraints: logical expressions that describe special properties of the problem domain. The combination of these two extensions defines the syntax of generalized <b>logic</b> <b>programs</b> with constraints (�ÄÈ �). Declarative semantics provides a mathematically precis...|$|R
5000|$|ChinaPnR - {{financial}} payment provider: V-Key integrates {{a virtual}} secure element into [...] "ChinaPnR POS Acquirer" [...] (Point-of-Sale payment acquisition query platform) to protect mobile applications' runtime environment, <b>program</b> <b>logic</b> and important data.|$|E
5000|$|One form of {{boilerplate}} {{consists of}} declarations which, while {{not part of}} the <b>program</b> <b>logic</b> or the language's essential syntax, are added to the start of a source file as a matter of custom. The following Perl example demonstrates boilerplate: ...|$|E
50|$|Prolog has {{its roots}} in first-order logic, a formal logic, and unlike many other {{programming}} languages, Prolog is declarative: the <b>program</b> <b>logic</b> is expressed in terms of relations, represented as facts and rules. A computation is initiated by running a query over these relations.|$|E
40|$|In a {{previous}} work we have de ned Monotonic <b>Logic</b> <b>Programs</b> which extend de nite <b>logic</b> <b>programming</b> to arbitrary complete lattices of truth-values with an appropriate notion of implication. We {{have shown that}} this framework is general enough to capture Possibilistic <b>Logic</b> <b>Programming,</b> Hybrid Probabilistic <b>Logic</b> <b>Programs,</b> Fuzzy <b>Logic</b> <b>Programming,</b> Probabilistic Deductive Databases, and Generalized Annotated <b>Logic</b> <b>Programs.</b> However, none of these semantics de ne a form of non-monotonic negation, which is fundamental for several knowledge representation applications. In the spirit of our previous work, we generalise our framework of Monotonic <b>Logic</b> <b>Programs</b> to allow for rules with arbitrary antitonic bodies over general complete lattices, of which normal programs are a special case. We then show that all the standard <b>logic</b> <b>programming</b> theoretical results carry over to Antitonic <b>Logic</b> <b>Programs,</b> de ning Stable Model and Well-founded Model alike semantics...|$|R
25|$|Concurrent {{constraint}} <b>logic</b> <b>programming</b> combines concurrent <b>logic</b> <b>programming</b> and constraint <b>logic</b> <b>programming,</b> using constraints {{to control}} concurrency. A clause can contain a guard, {{which is a}} set of constraints that may block the applicability of the clause. When the guards of several clauses are satisfied, concurrent constraint <b>logic</b> <b>programming</b> makes a committed choice to the use of only one.|$|R
40|$|Abductive <b>logic</b> <b>programs</b> offer a {{formalism}} to declaratively represent {{and reason}} about {{problems in a}} variety of areas: diagnosis, decision making, hypothetical reasoning, etc. On the other hand, <b>logic</b> <b>program</b> updates allow us to express knowledge changes, be they internal (or self) and external (or world) changes. Abductive <b>logic</b> <b>programs</b> and <b>logic</b> <b>program</b> updates thus naturally coexist in problems that are susceptible to hypothetical reasoning about change. Taking this as a motivation, in this paper we integrate abductive <b>logic</b> <b>programs</b> and <b>logic</b> <b>program</b> updates by jointly exploiting tabling features of <b>logic</b> <b>programming.</b> The integration is based on and benefits from the two implementation techniques we separately devised previously, viz., tabled abduction and incremental tabling for query-driven propagation of <b>logic</b> <b>program</b> updates. A prototype of the integrated system is implemented in XSB Prolog. Comment: To appear in Theory and Practice of <b>Logic</b> <b>Programming</b> (TPLP), 10 pages plus bibliograph...|$|R
5000|$|An HTML Application (HTA) is styled after HTML. The HTML in {{the file}} is used to {{generate}} the user interface, and a scripting language such as VBScript {{is used for the}} <b>program</b> <b>logic.</b> The files have extension [...] and can be executed using mshta.exe.|$|E
50|$|Arrows {{have several}} benefits, mostly {{stemming}} from {{their ability to}} make <b>program</b> <b>logic</b> explicit yet concise. Besides avoiding side effects, purely functional programming creates more opportunities for static code analysis. This in turn can theoretically lead to better compiler optimizations, easier debugging, and features like syntax sugar.|$|E
50|$|Off-line, {{the parties}} must define and {{communicate}} between them the knowledge {{needed to make}} the change, and then recode the data structures and <b>program</b> <b>logic</b> to accommodate it, and then apply these changes to the database and the application. Then, and only then, can they implement the changes.|$|E
2500|$|Various {{implementations}} {{have been}} developed from Prolog to extend <b>logic</b> <b>programming</b> capabilities in numerous directions. [...] These include types, modes, constraint <b>logic</b> <b>programming</b> (CLP), object-oriented <b>logic</b> <b>programming</b> (OOLP), concurrency, linear logic (LLP), functional and higher-order <b>logic</b> <b>programming</b> capabilities, plus interoperability with knowledge bases: ...|$|R
40|$|AbstractIn {{this paper}} we {{describe}} {{some of our}} progress towards an operational implementation of a modern <b>programming</b> <b>logic.</b> The logic is inspired by the variable type systems of Feferman, and is designed for reasoning about imperative functional <b>programs.</b> The <b>logic</b> goes well beyond traditional <b>programming</b> <b>logics,</b> such as Hoare's logic and Dynamic logic in its expressibility, yet is less problematic to encode into higher order logics. The main focus of the paper is to present an axiomatization of the base first order theory...|$|R
5000|$|The <b>Programming</b> <b>Logics</b> Department {{was headed}} by Harald Ganzinger (died June 3, 2004) ...|$|R
