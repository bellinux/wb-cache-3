66|1628|Public
25|$|The lower 15 bits of each {{memory word}} held AGC {{instructions}} or data, with each word being {{protected by a}} 16th odd parity bit. This bit was set to 1 or 0 by a parity generator circuit so a count of the 1s in each memory word would always produce an odd number. A <b>parity</b> <b>checking</b> circuit tested the parity bit during each memory cycle; if the bit didn't match the expected value, the memory word {{was assumed to be}} corrupted and a parity alarm panel light was illuminated.|$|E
5000|$|... 4532624 <b>Parity</b> <b>checking</b> {{arrangement}} for a {{remote switching unit}} network ...|$|E
5000|$|... #Subtitle level 3: <b>Parity</b> <b>checking</b> {{limited to}} only 6 of 10 bits ...|$|E
5000|$|The rows of a <b>parity</b> <b>check</b> matrix are the {{coefficients}} of the <b>parity</b> <b>check</b> equations. That is, they show how linear combinations of certain digits (components) of each codeword equal zero. For example, the <b>parity</b> <b>check</b> matrix ...|$|R
3000|$|The {{processing}} time per iteration {{can be reduced}} substantially if some means is employed to eliminate the inter-lane communications associated with performing <b>parity</b> <b>checks.</b> Consider an alternative approach to testing the correctness of code-symbol polarities in which the <b>parity</b> <b>checks</b> for a given block of rows are incorporated within the corresponding message-passing subiterations. At {{the end of each}} subiteration of the message-passing phase, the posteriors updated during the subiteration are used to determine if the corresponding subset of <b>parity</b> <b>checks</b> are satisfied. The current posterior values required for each <b>parity</b> <b>check</b> are already located in the stream-processor lane in which the <b>parity</b> <b>check</b> is performed since the updates of the same values have just been completed in the same lane. Thus the need for separate inter-lane communications for <b>parity</b> <b>checks</b> is eliminated. We refer to this non-standard schedule of <b>parity</b> <b>checks</b> as the integrated <b>parity</b> <b>check</b> (IPC). The decoding time for the IPC is shown in the second-row entry in Table 1. The {{processing time}} for the integrated message-passing-and-parity-check phase of an iteration is only [...]. 08 μ s greater than the message-passing phase alone in the standard schedule.|$|R
40|$|International audienceWe {{investigate}} {{the use of}} Low Rank <b>Parity</b> <b>Check</b> Codes, originally designed for cryptography applications {{in the context of}} Power Line Communication. Particularly, we propose a new code design and an efficient probabilistic decoding algorithm. The main idea of decoding Low Rank <b>Parity</b> <b>Check</b> Codes is based on calculations of vector spaces over a finite field math formula. Low Rank <b>Parity</b> <b>Check</b> Codes {{can be seen as the}} identical of Low Density <b>Parity</b> <b>check</b> codes. We compare the performance of this code against the Reed-Solomon Code through a Power Line Communication channel...|$|R
5000|$|Static RAM {{sizes of}} 8 KB general purpose with {{hardware}} <b>parity</b> <b>checking,</b> 20 bytes battery-backed with tamper-detection erase.|$|E
5000|$|Static RAM {{consists}} of 4 / 6 / 8 / 16 / 32 KB general purpose with hardware <b>parity</b> <b>checking.</b>|$|E
5000|$|Memory errors: <b>parity</b> <b>checking</b> detects when {{a memory}} error has occurred. Error {{correction}} code (ECC) can correct limited memory errors so that processing can continue.|$|E
40|$|We propose several {{improvements}} for Linear Programming (LP) decoding algorithms for High Density <b>Parity</b> <b>Check</b> (HDPC) codes. First, {{we use the}} automorphism {{groups of}} a code to create <b>parity</b> <b>check</b> matrix diversity and to generate valid cuts from redundant <b>parity</b> <b>checks.</b> Second, we propose an efficient mixed integer decoder utilizing the branch and bound method. We further enhance the proposed decoders by removing inactive constraints and by adapting the <b>parity</b> <b>check</b> matrix prior to decoding according to the channel observations. Based on simulation results the proposed decoders achieve near-ML performance with reasonable complexity. Comment: Submitted to the IEEE Transactions on Communications, November 200...|$|R
5000|$|A {{generator}} matrix {{can be used}} {{to construct}} the <b>parity</b> <b>check</b> matrix for a code (and vice versa). If the generator matrix G is in standard form, [...] , then the <b>parity</b> <b>check</b> matrix for C is ...|$|R
5000|$|B1: Bit Error Monitoring. The B1 Byte {{contains}} {{the result of}} the <b>parity</b> <b>check</b> of the previous STM frame, after scrambling of the actual STM frame. This check is carried out with a Bit Interleaved <b>Parity</b> <b>check</b> (BIP-8).|$|R
50|$|Similarly, Hamming codes cannot detect or {{recover from}} an {{arbitrary}} three-bit error; Consider the diagram: if the {{bit in the}} green circle (colored red) were 1, the <b>parity</b> <b>checking</b> would return the null vector, indicating {{that there is no}} error in the codeword.|$|E
50|$|Simple go/no go <b>parity</b> <b>checking</b> {{requires}} that the memory have extra, redundant bits beyond those needed to store the data; but if extra bits are available, {{they can be used}} to correct, as well as detect, errors. Earlier memory as used in, for example, the IBM PC/AT (FPM and EDO memory) were available in versions that supported either no checking or <b>parity</b> <b>checking</b> (in earlier computers that used individual RAM chips rather than DIMM or SIMM modules, extra chips were used to store parity bits); if the computer detected a parity error it would display a message to that effect and stop. The SDRAM and DDR modules that replaced the earlier types are usually available either without error-checking or with ECC (full correction, not just parity).|$|E
50|$|Many {{access control}} system {{manufacturers}} adopted Wiegand technology, but were unhappy with the limitations of only 8 bits for site codes (0-255) and 16 bits for card numbers (0-65535), so they designed their own formats with varying complexity of field numbers and lengths and <b>parity</b> <b>checking.</b>|$|E
5000|$|Static RAM {{consists}} of 16 / 24 / 32 / 40 KB general purpose with hardware <b>parity</b> <b>check,</b> 0 / 8 KB core coupled memory (CCM) with hardware <b>parity</b> <b>check,</b> 64 / 128 bytes battery-backed with tamper-detection erase.|$|R
3000|$|... of the <b>parity</b> <b>check</b> matrix is non-null. Decoding {{algorithms}} {{based on}} Tanner graphs are iterative, based on exchanging information between <b>parity</b> <b>check</b> nodes and variable nodes. Belief propagation {{is applied to}} Tanner graphs to efficiently decode LDPC codes [20, 21].|$|R
50|$|A {{fixed rate}} erasure code, usually {{with a fairly}} high rate, is applied as a 'pre-code' or 'outer code'. This pre-code may itself be a {{concatenation}} of multiple codes, for example in the code standardized by 3GPP a high density <b>parity</b> <b>check</b> code derived from the binary Gray sequence is concatenated with a simple regular low density <b>parity</b> <b>check</b> code. Another possibility would be a concatenation of a Hamming code with a low density <b>parity</b> <b>check</b> code.|$|R
50|$|Error {{detection}} and recovery is emphasized, with error-correcting code (ECC) on L2 and L3 caches and buffers, and extensive <b>parity</b> <b>checking</b> elsewhere; in all over 20,000 error checkers on the chip. Processor state is buffered {{in a way}} that allows precise core retry for almost all hardware errors.|$|E
50|$|RAM <b>parity</b> <b>checking</b> is the storing of a {{redundant}} {{parity bit}} representing the parity (odd or even) {{of a small}} amount of computer data (typically one byte) stored in random access memory, and the subsequent comparison of the stored and the computed parity to detect whether a data error has occurred.|$|E
5000|$|A {{string of}} records, words, or characters, that for {{technical}} or logical purposes {{are treated as}} a unit. Blocks (a) are separated by interblock gaps, (b) are delimited by an end-of-block signal, and (c) may contain one or more records. A block is usually subjected to some type of block processing, such as multidimensional <b>parity</b> <b>checking,</b> associated with it.|$|E
5000|$|B2 : Bit Error Monitoring. The B2 Bytes {{contains}} {{the result of}} the <b>parity</b> <b>check</b> of the previous STM frame, except the RSOH, before scrambling of the actual STM frame. This check is carried out with a Bit Interleaved <b>Parity</b> <b>check</b> (BIP24) ...|$|R
40|$|In this paper, we {{investigate}} an efficient encoding approach for generalized low-density (GLD) <b>parity</b> <b>check</b> codes, a generalization of Gallager's low-density <b>parity</b> <b>check</b> (LDPC) codes. We propose a systematic approach to construct approximate upper triangular GLD <b>parity</b> <b>check</b> matrix which defines {{a class of}} efficientencoding GLD codes. It's shown that such GLD codes have equally good performance. By effectively exploiting the structure sharing in the encoding process, we also present a hardware/software codesign for the practical encoder implementation of these efficientencoding GLD codes...|$|R
40|$|A {{class of}} codes {{defined by the}} <b>parity</b> <b>check</b> matrix of a linear code of minimum {{distance}} at least t + 1 is examined {{and the number of}} <b>parity</b> <b>check</b> symbols is discussed. Determinants of this type are known as alternants (Muir and Metzler, 1930); codes corresponding to such a matrix are termed alternant codes. The <b>parity</b> <b>check</b> matrix is obtained by restricting some of its elements to subfields of GF(q to the m-th power). Minimum distance and redundancy bounds are established for these codes, and some interesting equivalence and invariance properties are derived...|$|R
5000|$|Whenever any single-bit error {{occurs in}} a {{transmission}} block of data, such two-dimensional <b>parity</b> <b>checking,</b> or [...] "two-coordinate parity checking",enables the receiver to use the TRC to detect which byte the error occurred in, and the LRC to detect exactly which track the error occurred in, to discover exactly which bit is in error, and then correct that bit by flipping it.|$|E
50|$|Moreover, parity {{does not}} {{indicate}} which bit contained the error, even when it can detect it. The data must be discarded entirely and re-transmitted from scratch. On a noisy transmission medium, a successful transmission could {{take a long time}} or may never occur. However, while the quality of <b>parity</b> <b>checking</b> is poor, since it uses only a single bit, this method results in the least overhead.|$|E
5000|$|IBM {{sold the}} first IBM PCs in {{configurations}} with 16 or 64 kB of RAM preinstalled using either nine or thirty-six 16-kilobit DRAM chips. (The ninth bit {{was used for}} <b>parity</b> <b>checking</b> of memory.) After the IBM XT shipped, the IBM PC motherboard was redesigned with the same RAM configuration as the IBM XT. (64 kB in one bank, expandable to 256kB by populating the other 3 banks.) ...|$|E
3000|$|... {{and each}} {{independent}} <b>parity</b> <b>check</b> is tested. If all the <b>parity</b> <b>checks</b> are satisfied, decoding is terminated with a valid decoded code word, {{and the information}} bits are recovered by inverse mapping. If not, but {{the maximum number of}} iterations has been executed, a known decoding failure occurs. Otherwise, another iteration of the algorithm is performed. We use this schedule of updates and <b>parity</b> <b>checks</b> for the TDMP algorithm (with alternating message-passing and parity-check phases) as a benchmark in the article and refer to it as the TDMP algorithm with the standard schedule.|$|R
40|$|Simple {{arguments}} {{suggest that}} shortened codes must have distance properties {{equal to or}} better than those of their parent codes, {{and that they should}} be equally practical to decode. This relationship holds true in the case of low density generator codes and low density <b>parity</b> <b>check</b> codes. We investigate the properties of shortened turbo codes. I. Motivation for Shortening In our previous work on codes based on very sparse matrices we have observed that while codes with a low density generator matrix [1] are asymptotically bad, codes with a low density <b>parity</b> <b>check</b> matrix [2] are asymptotically good [3, 4, 5]. One way of viewing the relationship between low density generator matrix codes and low density <b>parity</b> <b>check</b> matrix codes is that one obtains a low density <b>parity</b> <b>check</b> matrix by taking the M Θ N <b>parity</b> <b>check</b> matrix [P IM] of a (N; K) low density generator matrix code and chopping off its right-most M columns (where M = N Γ K), to yield an M Θ K matrix [P], which [...] ...|$|R
40|$|Recently {{there has}} been {{interest}} {{in the construction of}} small <b>parity</b> <b>check</b> sets for iterative decoding of the Hamming code with the property that each uncorrectable (or stopping) set of size three is the support of a codeword and hence uncorrectable anyway. Here we reformulate and generalise the problem, and improve on this construction. First we show that a <b>parity</b> <b>check</b> collection that corrects all correctable erasure patterns of size m for the r-th order Hamming code (i. e, the Hamming code with codimension r) provides for all codes of codimension $r$ a corresponding ``generic'' <b>parity</b> <b>check</b> collection with this property. This leads naturally to a necessary and sufficient condition on such generic <b>parity</b> <b>check</b> collections. We use this condition to construct a generic <b>parity</b> <b>check</b> collection for codes of codimension r correcting all correctable erasure patterns of size at most m, for all r and m = 3 and r large enough. Finally we discuss some directions for further research. Comment: 13 pages, no figures. Submitted to IEEE Transactions on Information Theory, July 28, 200...|$|R
5000|$|Seymour Cray famously said [...] "parity is for farmers" [...] {{when asked}} why he left {{this out of the}} CDC 6600. Later, he {{included}} parity in the CDC 7600, which caused pundits to remark that [...] "apparently a lot of farmers buy computers". The original IBM PC and all PCs until the early 1990s used <b>parity</b> <b>checking.</b> Later ones mostly did not. Many current microprocessor memory controllers, including almost all AMD 64-bit offerings, support ECC, but many motherboards and in particular those using low-end chipsets do not.|$|E
50|$|The lower 15 bits of each {{memory word}} held AGC {{instructions}} or data, with each word being {{protected by a}} 16th odd parity bit. This bit was set to 1 or 0 by a parity generator circuit so a count of the 1s in each memory word would always produce an odd number. A <b>parity</b> <b>checking</b> circuit tested the parity bit during each memory cycle; if the bit didn't match the expected value, the memory word {{was assumed to be}} corrupted and a parity alarm panel light was illuminated.|$|E
50|$|The {{machine was}} also {{designed}} {{from the outset}} {{to allow it to}} scale across a wide variety of needs. The system included 64 hardware channels that could be connected to peripherals of any sort, and could run {{with a wide variety of}} core memory sizes. In other ways the machine was fairly similar to the ReserVecs Gemini machine, using a 24-bit word with a 25-bit for <b>parity</b> <b>checking</b> and a simple machine language. One change was the lack of a memory drum, as the advances in core allowed them to replace the drum entirely.|$|E
40|$|Error {{correcting}} codes prevent loss {{of integrity}} in data transmission. Low Density <b>Parity</b> <b>Check</b> codes are {{a family of}} codes that are specified by sparse matrices. Using the Nelder-Mead Downhill Simplex Evolution to design an irregular Low Density <b>Parity</b> <b>Check</b> code, we hope to improve upon the accuracy of decoding...|$|R
40|$|It is {{proposed}} {{a method for}} dynamically changing the low-density <b>parity</b> <b>check</b> code parameters in accordance with communication channel qualit y monitoring and device for storing, dynamic selection of <b>parity</b> <b>check</b> matrices and error-correcting encoding. Finally, results of the simulation codes characteristics and performance, which prove the effectiveness of proposed method, are presented...|$|R
40|$|A {{simple but}} {{effective}} decoding procedure, applicable to any (n,k) linear block code with symbols from GF(q), is described. The technique involves {{a transformation of}} the <b>parity</b> <b>check</b> equations which focuses the code's correction power on the soft symbol set while still retaining the capability to correct one symbol error from outside this set. The soft symbol set is defined to be the n-k least reliably detected code symbol positions whose <b>parity</b> <b>check</b> row-spaces are linearly independent. The process generates a number of error vector screening candidates, each {{a solution to the}} <b>parity</b> <b>check</b> equations, and the maximum-likelihood candidate is accepted...|$|R
