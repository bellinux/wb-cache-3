8|12|Public
40|$|Today’s complex {{software}} {{systems are}} neither secure nor reliable. The rudimentary software <b>protection</b> <b>primitives</b> pro-vided by current hardware forces systems to run many distrust-ing software components (e. g., procedures, libraries, plugins, modules) {{in the same}} protection domain, or otherwise suffer degraded performance from address space switches. We present CODOMs (COde-centric memory DOMains), a novel architecture that can provide finer-grained isolation between software components with effectively zero run-time overhead, all {{at a fraction of}} the complexity of other ap-proaches. An implementation of CODOMs in a cycle-accurate full-system x 86 simulator demonstrates that with the right hardware support, finer-grained protection and run-time per-formance can peacefully coexist. 1...|$|E
40|$|We {{describe}} how reachability-based orthogonal persistence can be supported even in uncooperative implementations of languages such as C++ and Modula- 3, and without modification to the compiler. Our scheme extends Bartlett's mostly-copying garbage collector to manage both transient objects and resident persistent objects, and {{to compute the}} reachability closure necessary for stabilization of the persistent heap. It has been implemented in our prototype of reachability-based persistence for Modula- 3, yielding performance competitive with that of comparable, but non-orthogonal, persistent variants of C++. Experimental results, using the OO 7 object database benchmarks, reveal that the mostly-copying approach offers a straightforward path to efficient orthogonal persistence in these uncooperative environments. The results also characterize the performance of persistence implementations based on virtual memory <b>protection</b> <b>primitives.</b> 1 Introduction Incorporating orthogonal persistence [11] [...] ...|$|E
40|$|With {{reference}} to an embedded system featuring no support for memory management, {{we present a}} model of a protection system based on passwords. At the hardware level, our model takes advantage of a memory protection unit (MPU) interposed between the processor and the complex of the main memory and the input-output devices. The MPU supports both concepts of a protection context and a protection domain. A protection context is a set of access rights for the memory pages; a protection domain is a set of one or more protection contexts. Passwords are associated with protection domains. A process that holds a given password can take advantage of this password to activate the corresponding domain. A small set of <b>protection</b> <b>primitives</b> makes it possible to modify the composition of the domains in a strictly controlled fashion. The proposed protection model is evaluated from a number of important viewpoints, which include password distribution, review and revocation, the memory requirements for storage of the information concerning protection, and the time necessary for password validation...|$|E
50|$|An ancient volcano, {{known as}} Mount Tehama is {{believed}} to have been much larger than Lassen Peak. Its explosion is responsible for the topography of the national forest and the national park: a volcanic rim, with elevations beginning at 6000 ft above sea level. The third historical resource is the 20000 acre Caribou Wilderness immediately east of the National Park. Caribou Wilderness received <b>protection</b> as a <b>Primitive</b> Area beginning in 1932.|$|R
40|$|Modern-day {{imperative}} programming languages such as C++, C# and Java offer protection facilities such as abstract data types, field access modifiers, and module systems. Such abstractions {{were mainly}} designed to enforce software engineering principles such as information hiding and encapsulation, {{but they can}} also be used to enforce security properties of programs. Unfortunately, these source-level security properties are typically lost during compilation to low-level machine code. For instance, access to private instance fields is restricted by the programming language's type system at the source-code level, but such restrictions are not in place at the assembly level. This can leave a software module vulnerable to attacks at the assembly level, such as code-injection attacks and kernel-level malware. In the first part of this dissertation, we present a compilation scheme that is fully abstract, which means that the high-level security properties of a software module are maintained after compilation. We formalize this property as preservation of contextual equivalence, which means that two assembly-level compiled modules should only be distinguishable from each other by another module interacting with them, when their original source-level modules can also be distinguished from each other by a source-level module. In other words, a fully abstract compiler ensures that any possible assembly-level interaction is explainable at the source-code level. This effectively reduces the power of an assembly-level attacker to the power of a source-level attacker. To achieve this strong security property, the compiler relies on the presence of a fine-grained, program counter-based memory access <b>protection</b> <b>primitive,</b> as part of the assembly-level target language. We formalize our compilation scheme, prove that it is fully abstract and we show by means of a prototype implementation that the assumed memory access <b>protection</b> <b>primitive</b> can be realized efficiently on modern commodity hardware. In the second part of this dissertation, we discuss the sound modular verification of imperative programs executing in an unverified context. We focus on Hoare logic-based software verification techniques, which enable developers to statically prove correctness and safety properties of imperative programs. Unfortunately, the runtime guarantees offered by such verification techniques are relatively limited when the verified codebase is part of a program that also contains unverified code. In particular, unverified code might not behave as assumed by the verifier, leading to failure of all verified assertions that were based on those assumptions. This is particularly troublesome in memory-unsafe languages, where a memory safety error in unverified code can corrupt the runtime state of verified code. We have developed a series of runtime checks to be inserted at the boundary between the verified and unverified parts of a program, which check that the unverified code behaves as expected. A key problem that we had to solve, is how to ensure that memory errors or malicious code in the unverified part cannot corrupt the state of the verified part. We solve this problem in two steps. Firstly, the inserted boundary checks perform an integrity check on the heap memory owned by the verified code, to ensure that bad writes to heap memory by the unverified part are detected upon (re-) entry to verified code. Secondly, we use the mechanism of fully abstract compilation developed in the first part of this dissertation, for the integrity protection of the verified code's local variables and control flow metadata on the runtime call stack. The combination of these protection measures results in a very strong modular soundness guarantee: no verified assertion in the verified codebase will ever fail at runtime, even if the verified codebase interacts with unverified code. We formalize the developed program transformations, prove that they are sound and precise, and we show by means of micronbsp;macro benchmarks that the performance overhead of the boundary checks is sufficiently low for practical applicability. nrpages: 198 status: publishe...|$|R
40|$|To provide privacy <b>protection,</b> {{cryptographic}} <b>primitives</b> {{are frequently}} applied to communication protocols {{in an open}} environment (e. g. the Internet). We call these protocols privacy enhancing protocols (PEPs) which constitute a class of cryptographic protocols. Proof of the security properties, {{in terms of the}} privacy compliance, of PEPs is desirable before they can be deployed. However, the traditional provable security approach, though well-established for proving the security of cryptographic primitives, is not applicable to PEPs. We apply the formal language of Coloured Petri Nets (CPNs) to construct an executable specification of a representative PEP, namely the Private Information Escrow Bound to Multiple Conditions Protocol (PIEMCP). Formal semantics of the CPN specification allow us to reason about various privacy properties of PIEMCP using state space analysis techniques. This investigation provides insights into the modelling and analysis of PEPs in general, and demonstrates the benefit of applying a CPN-based formal approach to the privacy compliance verification of PEPs...|$|R
40|$|With {{reference}} to a protection system featuring active subjects that attempt to access passive, typed objects,we propose a set of mechanisms supporting the distribution,verification,review and revocation of access privileges. In our approach, a protection domain {{is a collection of}} access rights for the protected objects. An access control list is associated with each object to specify the access rights in each domain. Objects are grouped into clusters. To access the objects in a given cluster, a subject presents a gate referencing this cluster. The gate is a form of password capability that identifies one or more domains. The gate grants the access rights specified for these domains by the access control lists of the objects in the cluster. A subject that holds a gate and is aimed at distributing the access privileges in this gate in restricted form can reduce the gate to eliminate domains; the gate reduction procedure requires no intervention of the protection system. A small set of <b>protection</b> <b>primitives</b> allows subjects to manage objects and access control lists. Forms of revocation of access permissions are supported, at both levels of gates and access control lists...|$|E
40|$|Withreferencetoadistributedsystemconsistingofnodesconnectedbyalocalareanetwork,we {{consider}} a salient {{aspect of the}} protection problem, the representation of access permissions and protection domains. We present {{a model of a}} protection system supporting typed objects. Possession of an access permission for a given object is certified by possession of an object pointer including the specification of a set of access rights. We associate an encryption key with each object and a password with each domain. Object pointers are stored in memory in a ciphertext form obtained by using the object key and including the value of the domain password. Each process is executed in a domain and can take advantage of a given object pointer only if this object pointer was encrypted by including the password of this domain. A set of <b>protection</b> <b>primitives</b> makes it possible to use object pointers for object reference and to control the movements of the objects across the network. The resulting protection environment is evaluated from a number of salient viewpoints, including ease of access right distribution and revocation, interprocess interaction and cooperation, protection against fraudulent actions of access right manipulation and stealing, storage overhead, and network traffic...|$|E
40|$|Motivated by {{contemporary}} security challenges, we reevaluate and refine capability-based addressing for the RISC era. We present CHERI, a hybrid capability model that extends the 64 -bit MIPS ISA with byte-granularity memory protection. We demonstrate that CHERI enables language memory model enforcement and fault isolation in hardware rather than software, {{and that the}} CHERI mechanisms are easily adopted by existing programs for efficient in-program memory safety. In contrast to past capability models, CHERI complements, rather than replaces, the ubiquitous page-based protection mechanism, providing a migration path towards deconflating data-structure protection and OS memory management. Furthermore, CHERI adheres to a strict RISC philosophy: it maintains a load-store architecture and requires only singlecycle instructions, and supplies <b>protection</b> <b>primitives</b> to the compiler, language runtime, and operating system. We demonstrate a mature FPGA implementation that runs the FreeBSD operating system with {{a full range of}} software and an open-source application suite compiled with an extended LLVM to use CHERI memory protection. A limit study compares published memory safety mechanisms in terms of instruction count and memory overheads. The study illustrates that CHERI is performance-competitive even while providing assurance and greater flexibility with simpler hardware. 1...|$|E
5000|$|When Barnabus is {{informed}} of The Bom's visit, he tells Mike {{that he has}} opened a [...] by sending out his rescue message, as it signaled to the universe that Earth has advanced to a certain technological level. Because of this, Barnabus says Earth is no longer eligible for intergalactic <b>protection</b> for <b>primitive</b> life, even though Mike blames the message on the thunder strike and does not understand how he actually contacted alien life. Mike accepts Barnabus' offer {{to take him to}} a place where he can be alone, but first tries to make amends with Katelyn. However, The Loafer Alien arrives and prevents Mike from meeting with Katelyn, who believes he has rudely ignored her after insisting that they talk. The alien proposes becoming Mike's agent, representing him throughout the galaxy and eventually having him star in a weekly television series about his life as an immigrant. Mike declines the offer.|$|R
40|$|We propose an {{efficient}} technique {{for the detection}} of errors in cryptographic circuits introduced by strong adversaries. Previously a number of linear and nonlinear error detection schemes were proposed. Linear codes provide <b>protection</b> only against <b>primitive</b> adversaries which no longer represents practice. On the other hand non-linear codes provide protection against strong adversaries, but at the price of high overhead. Here we propose a novel error detection technique, based on the random selection of linear codes. Under mild assumptions the proposed construction achieves near non-linear code error detection performance at much lower cost {{due to the fact that}} no non-linear operations are needed for the encoder and decoder. 1...|$|R
5000|$|Pure {{capability}} architectures {{are supported}} by well-tested and mature mathematical security models. These {{have been used to}} formally demonstrate that capability-based systems can be made secure if implemented correctly. The so-called [...] "safety property" [...] {{has been shown to be}} decidable for pure capability systems (see Lipton). Confinement, which is the fundamental building block of isolation, has been formally verified to be enforceable by pure capability systems, and is reduced to practical implementation by the EROS [...] "constructor" [...] and the KeyKOS [...] "factory". No comparable verification exists for any other <b>primitive</b> <b>protection</b> mechanism. There is a fundamental result in the literature showing that [...] "safety" [...] is mathematically undecidable in the general case (see HRU, but note that it is of course provable for an unbounded set of restricted cases). Of greater practical importance, safety has been shown to be false for all of the <b>primitive</b> <b>protection</b> mechanisms shipping in current commodity operating systems (see HRU). Safety is a necessary precondition to successful enforcement of any security policy. In practical terms, this result means that it is not possible in principle to secure current commodity systems, but it is potentially possible to secure capability-based systems provided they are implemented with sufficient care. Neither system has ever been successfully penetrated, and their isolation mechanisms have never been successfully defeated by any inside attacker, but it is not known whether the EROS or KeyKOS implementations was careful enough. One goal of the Coyotos project is to demonstrate that component isolation and security has been definitively achieved by applying software verification techniques.|$|R
40|$|JLS 76] writes, “The Folklore {{is replete}} with stories of ‘secure ’ {{protection}} systems being compromised {{in a matter of}} hours. This is quite astounding since one is not likely to claim that a system is secure without some sort of proof to support the claim. In practice, proof is not provided, and one reason for this is clear: although the <b>protection</b> <b>primitives</b> are apparently quite simple, they may potentially interact in extremely complex ways. Vague and informal arguments, therefore, often overlook subtleties that an adversary can exploit. Precision is not merely desirable for protection systems, it is mandatory. ” In this thesis, we construct a formalism which provides the required precision. We initially study the decidability of safety in specific protection systems using the common access-matrix model. We build upon this {{to the point where we}} can treat the systems themselves as computational elements and thus create a formalism which produces safety results for entire classes of protection systems. Our study of the manipulation of rights encompasses a study of responsibility; we achieve a unification of the λsec-calculi for stack inspection with that for data inspection, and demonstrate an extremely close coupling between the calculi of responsibility and our formalism fo...|$|E
40|$|Today's complex {{software}} {{systems are}} neither secure nor reliable. The rudimentary software <b>protection</b> <b>primitives</b> provided by current hardware forces systems to run many distrusting software components (e. g., procedures, libraries, plugins, modules) {{in the same}} protection domain, or otherwise suffer degraded performance from address space switches. We present CODOMs (COde-centric memory DOMains), a novel architecture that can provide finer-grained isolation between software components with effectively zero run-time overhead, all {{at a fraction of}} the complexity of other approaches. An implementation of CODOMs in a cycle-accurate full-system x 86 simulator demonstrates that with the right hardware support, finer-grained protection and run-time performance can peacefully coexist. We would like to thank Lluc Alvarez, Javier Cabezas, Ana Jokanovic, Marc Jorda, Carlos Villavieja, our shepherd Mohit Tiwari and the anonymous reviewers for their help and comments on this paper. This work has received funding from: the European Commission through TERAFLUX (FP 7 - 249013) and RoMoL (GA- 321253); the Spanish Government through Programa Severo Ochoa (SEV- 2011 - 0067); the Spanish Min­istry of Science and Technology through TIN 2007 - 60625 and TIN 2012 - 34557; the Israel Science Foundation (grant 769 / 12 and equipment grant 1719112); and the Ministry of Science and Technology, Israel. Yoav Etsion was supported by the Center for Computer Engineering at the Technion. Peer ReviewedPostprint (published version...|$|E
40|$|Abstract—Public-key {{cryptographic}} {{devices are}} vulnerable to fault-injection attacks. As countermeasures, a number of secure architectures based on linear and nonlinear error detecting codes were proposed. Linear codes provide <b>protection</b> only against <b>primitive</b> adversaries which no longer represents practice. On the other hand nonlinear codes provide protection against strong adversaries, but {{at the price of}} high area overhead (200 – 400 %). In this paper we propose a novel error detection technique, based on the random selection of linear arithmetic codes for each encryption and the corresponding decryption operation. Under mild assumptions the proposed construction achieves near nonlinear code error detection performance at a lower cost (at most 50 % area overhead) {{due to the fact that}} no nonlinear operations are needed for the encoder and decoder...|$|R
40|$|Abstract. Block Memory Content Scrambling (BMS), {{presented}} at CHES 2011, enables {{an effective way}} of first-order side-channel <b>protection</b> for cryptographic <b>primitives</b> {{at the cost of}} a significant reconfiguration time for the mask update. In this work we analyze alternative ways to im-plement dynamic first-order masking of AES with randomized look-up tables that can reduce this mask update time. The memory prim-itives we consider in this work include three distributed RAM compo-nents (RAM 32 M, RAM 64 M, and RAM 256 X 1 S) and one BRAM primi-tive (RAMB 8 BWER). We provide a detailed study of the area and time overheads of each implementation technique with respect to the oper-ation (encryption) as well as reconfiguration (mask update) phase. We further compare the achieved security of each technique to prevent first-order side-channel leakages. Our evaluation is based {{on one of the most}} general forms of leakage assessment methodology known as non-specific t-test. Practical SCA evaluations (using a Spartan- 6 FPGA platform) demonstrate that solely the BRAM primitive but none of the distributed RAM elements can be used to realize an SCA-protected implementation. ...|$|R
40|$|Most {{primitive}} {{hematopoietic cells}} {{appear to be}} normally quiescent in vivo, whereas their leukemic counterparts in patients with chronic myeloid leukemia (CML) are maintained {{in a state of}} rapid turnover. This difference is also seen in the long-term culture system, where control of primitive hematopoietic progenitor proliferation is mediated by interactions of these cells with marrow-derived mesenchymal cells of the fibroblast lineage. We now show that exogenous addition of macrophage inflammatory protein 1 alpha (MIP- 1 alpha) to normal long-term cultures can reversibly and specifically block the activation of "primitive" (high proliferative potential), but not "mature" (lower proliferative potential), progenitors in the adherent layer of these cultures. Moreover, addition of MIP- 1 beta after primitive-progenitor activation can prevent the subsequent return of these cells to a quiescent state a few days later as shown previously in similar experiments using antibodies to transforming growth factor beta. This suggests that the level of MIP- 1 alpha (or a related MIP- 1 alpha agonist) produced in LTCs, like the level of transforming growth factor beta, may be necessary, but is not on its own sufficient, to mediate the inhibitory activity of the regulatory cells in the adherent layer. Addition of MIP- 1 alpha to similar long-term cultures containing normal marrow adherent layers but supporting exclusively neoplastic (CML) hematopoiesis did not block the cycling of primitive neoplastic progenitors. A defect in the responsiveness of CML cells to MIP- 1 alpha (or a similarly acting chemokine) would explain their deregulated proliferative behavior in this model and, by extrapolation to the in vivo setting, suggests a molecular mechanism whereby the leukemic clone may become amplified at the stem-cell level. In addition, these findings suggest approaches to the therapy of CML, using inhibitors such as MIP- 1 alpha for the <b>protection</b> of <b>primitive</b> normal cells...|$|R
40|$|International audienceFPGAs are {{primarily}} digital devices and application designers {{have to follow}} the usual design methodologies of digital systems when they target FPGAs. Nevertheless, when the applications include cryptographic primitives these methodologies are not sufficient to achieve the security requirements of certification. The variability of parameters of the devices, due to electronic noises, aging, environmental fluctuations and CMOS/FLASH process variations, conduce to change the design methodologies and the designers have to consider analog phenomena during {{the design of the}} digital system. At the same time, the continuous {{increase in the number of}} research projects on hardware implementation of ciphers, true random number generators (TRNG) and physical unclonable functions (PUF) highlights their scientific and practical interest. But design, evaluation and test of such cryptographic primitives are arduous especially in FPGA when the designer doesn’t control all the design parameters and the estimation of entropy sources is tricky. This half-day tutorial will provide firstly an introduction to the physical phenomena for the security of digital integrated circuit including an introduction to the randomness generation (TRNG), to the device fingerprint (PUF) generation and to the <b>protection</b> of cryptographic <b>primitives</b> against physical attacks. Random numbers are crucial in cryptography: they are used as confidential keys, initialization vectors, nonces in challenge-response protocols, padding values, hardware identifiers, and as masks in side channel attack countermeasures. Random number generators (RNGs) and physical unclonable functions (PUF) must generate random numbers that have good statistical properties and the generated sequences must be impossible to predict and manipulate. To help FPGA designers with the TRNG/PUF design and evaluation, we will discuss the design, statistical evaluation and tests of TRNGs and PUFs when implemented in FPGA...|$|R
40|$|Abstract: The {{need for}} water quality {{research}} on the Tibetan plateau has arisen after the rangeland was allocated and leased as pasture grounds to individual nomadic families in the 1990 s. These policies changed the access to water sources. The imposed fencing of the pasture tenures makes the situation even more delicate. Nomadic families are now obliged to use only water sources existing on their own site. The restrictions have caused the urge to use all available water, which resulted in increasing water quality and quantity problems. In the past, natural water sources were in common use. During the Collective era, machine-dug wells near the collective settlements facilitated the procurement of drinking water. Based on recent investigations in Dzoge county (Sichuan province), the nomadic families of some regions considered the availability of adequate drinking water for humans and animals as their biggest problem. For this study, eight water samples were collected from the Dzoge county area. A l l samples were from different kinds of sources, but all in continuous use by humans and animals. The samples were analyzed for typical potable water quality factors (hygienic and technique-aesthetic). The {{results show that the}} Chinese national guideline values were exceeded for NO 4 -N and PO 4 -P in most open sampling locations. Those parameters do not spoil the water by themselves, but together with suspended solids and organic materials produce a great environment for bacteria like E. coli and fecal streptococci to grow. The result analysis and pictures seen from the location reveal that bacterial growth may be the biggest problem in water quality. Even <b>primitive</b> <b>protection</b> around the water source (i. e. concrete rings, woode...|$|R
40|$|The {{need for}} water quality {{research}} on the Tibetan plateau has arisen after the rangeland was allocated and leased as pasture grounds to individual nomadic families in the 1990 s. These policies changed the access to water sources. The imposed fencing of the pasture tenures makes the situation even more delicate. Nomadic families are now obliged to use only water sources existing on their own site. The restrictions have caused the urge to use all available water, which resulted in increasing water quality and quantity problems. In the past, natural water sources were in common use. During the Collective era, machine-dug wells near the collective settlements facilitated the procurement of drinking water. Based on recent investigations in Dzoge county (Sichuan province), the nomadic families of some regions considered the availability of adequate drinking water for humans and animals as their biggest problem. For this study, eight water samples were collected from the Dzoge county area. All samples were from different kinds of sources, but all in continuous use by humans and animals. The samples were analyzed for typical potable water quality factors (hygienic and technique-aesthetic). The {{results show that the}} Chinese national guideline values were exceeded for NO 4 -N and PO 4 -P in most open sampling locations. Those parameters do not spoil the water by themselves, but together with suspended solids and organic materials produce a great environment for bacteria like E. coli and fecal streptococci to grow. The result analysis and pictures seen from the location reveal that bacterial growth may be the biggest problem in water quality. Even <b>primitive</b> <b>protection</b> around the water source (i. e. concrete rings, wooden barriers around edges, covers) seem to have a great impact on water quality...|$|R

