588|449|Public
5|$|Both HDMI and DVI use TMDS to send 10-bit {{characters}} that are encoded using 8b/10b encoding that {{differs from the}} original IBM form for the Video Data Period and 2b/10b encoding for the Control Period. HDMI adds the ability to send audio and auxiliary data using 4b/10b encoding for the Data Island Period. Each Data Island Period is 32 pixels in size and contains a 32-bit <b>Packet</b> <b>Header,</b> which includes 8 bits of BCH ECC parity data for error correction and describes {{the contents of the}} packet. Each packet contains four subpackets, and each subpacket is 64 bits in size, including 8 bits of BCH ECC parity data, allowing for each packet to carry up to 224 bits of audio data. Each Data Island Period can contain up to 18 packets. Seven of the 15 packet types described in the HDMI 1.3a specifications deal with audio data, while the other 8 types deal with auxiliary data. Among these are the General Control Packet and the Gamut Metadata Packet. The General Control Packet carries information on AVMUTE (which mutes the audio during changes that may cause audio noise) and Color Depth (which sends the bit depth of the current video stream and is required for deep color). The Gamut Metadata Packet carries information on the color space being used for the current video stream and is required for xvYCC.|$|E
25|$|Like SMPTE 259M, SMPTE 292M {{supports}} the SMPTE 291M standard for ancillary data. Ancillary data is provided as a standardized transport for non-video payload within a serial digital signal; {{it is used}} for things such as embedded audio, closed captions, timecode, and other sorts of metadata. Ancillary data is indicated by a 3-word packet consisting of 0, 3FF, 3FF (the opposite of the synchronization <b>packet</b> <b>header),</b> followed by a two-word identification code, a data count word (indicating 0 - 255 words of payload), the actual payload, and a one-word checksum. Other than in their use in the header, the codes prohibited to video payload are also prohibited to ancillary data payload.|$|E
25|$|The {{link layer}} {{is used to}} move packets between the Internet layer {{interfaces}} of two different hosts on the same link. The processes of transmitting and receiving packets on a given link can be controlled both in the software device driver for the network card, {{as well as on}} firmware or specialized chipsets. These perform data link functions such as adding a <b>packet</b> <b>header</b> to prepare it for transmission, then actually transmit the frame over a physical medium. The TCP/IP model includes specifications of translating the network addressing methods used in the Internet Protocol to link layer addresses, such as Media Access Control (MAC) addresses. All other aspects below that level, however, are implicitly assumed to exist in the link layer, but are not explicitly defined.|$|E
5000|$|Hardware-based filters for {{monitoring}} <b>packet</b> <b>headers</b> in inbound and outbound network traffic for known threats (based on programmable timers), and {{for monitoring}} known / unknown threats based on time-based heuristics. Laptops and desktop PCs have filters to monitor <b>packet</b> <b>headers.</b> Desktop PCs have packet-header filters and time-based filters.|$|R
30|$|A packet-layer model (e.g., P.NAMS) {{utilizes}} various <b>packet</b> <b>headers</b> (e.g., RTP header, TS header), network parameters (e.g., {{packet loss}} rate (PLR), delay), and codec configuration information as input to the model. Obviously, {{this type of}} model can roughly locate the impaired parts by analyzing the <b>packet</b> <b>headers.</b> However, how to take the content-dependent features into account is a big challenge to this model.|$|R
5000|$|Note: These LSA <b>Packet</b> <b>Headers</b> are all {{preceded by}} {{standard}} [...] "16-byte" [...] OSPF Headers.|$|R
2500|$|... 6to4 embeds an IPv6 packet in the payload {{portion of}} an IPv4 packet with {{protocol}} type 41. To send an IPv6 packet over an IPv4 network to a 6to4 destination address, an IPv4 header with protocol type 41 is prepended to the IPv6 packet. [...] The IPv4 destination address for the prepended <b>packet</b> <b>header</b> {{is derived from}} the IPv6 destination address of the inner packet (which is in the format of a 6to4 address), by extracting the 32 bits immediately following the IPv6 destination address's 2002::/16 prefix. The IPv4 source address in the prepended <b>packet</b> <b>header</b> is the IPv4 address of the host or router which is sending the packet over IPv4. The resulting IPv4 packet is then routed to its IPv4 destination address just like any other IPv4 packet.|$|E
2500|$|In 1985, NTP version 0 (NTPv0) was {{implemented}} in both Fuzzball and Unix, and the NTP <b>packet</b> <b>header</b> and round-trip delay and offset calculations, which have persisted into NTPv4, were documented in [...] Despite the relatively slow computers and networks {{available at the}} time, accuracy of better than 100 milliseconds was usually obtained on Atlantic spanning links, with accuracy of tens of milliseconds on Ethernet networks.|$|E
5000|$|Processing {{delay time}} routers take {{to process the}} <b>packet</b> <b>header</b> ...|$|E
50|$|The {{deterministic}} {{nature of}} the routing makes offline prediction/computation/experimentation of the network loading much simpler since actual routes are not dependent on {{the contents of the}} <b>packet</b> <b>headers</b> {{with the exception of the}} VLAN identifier.|$|R
5000|$|Encapsulation: The {{bundling}} of {{the control}} data in the <b>packet's</b> <b>header</b> and then removing the header (and/or footer) of the packet at the far end, restoring the data {{to be the same}} as the original.|$|R
5000|$|After the header, {{the file}} is split into packets called [...] "FLV tags", which have 15-byte <b>packet</b> <b>headers.</b> The first four bytes denote {{the size of}} the {{previous}} packet/tag (including the header), and aid in seeking backward.|$|R
5000|$|IP packets are {{composed}} of a header and payload. The IPv4 <b>packet</b> <b>header</b> consists of: ...|$|E
50|$|A {{standard}} GRE <b>packet</b> <b>header</b> structure, {{as defined}} by RFC 2784 and RFC 2890, is represented in the diagram below.|$|E
5000|$|The evil bit is {{a fictional}} IPv4 <b>packet</b> <b>header</b> field {{proposed}} in RFC 3514, a humorous April Fools' Day RFC from 2003 authored by Steve Bellovin. The RFC {{recommended that the}} last remaining unused bit, the [...] "Reserved Bit," [...] in the IPv4 <b>packet</b> <b>header</b> be used to indicate whether a packet had been sent with malicious intent, thus making computer security engineering an easy problem simply ignore any messages with the evil bit set.|$|E
30|$|Compression friendliness: small codeblocks {{adversely}} impact compression performance; the MQ coder performs {{better on}} large codeblocks. In addition for small <b>packets,</b> the <b>packet</b> <b>headers</b> and marker sequences (e.g., SOP and EPH) will represent an important {{fraction of the}} bitstream.|$|R
50|$|EWI {{is also an}} organizing-style architecture, {{where the}} system layer organizes the {{wireless}} link modules (at the wireless link layer); and peer wireless link modules can exchange module management information by padding <b>packet</b> <b>headers</b> to the system-layer information units.|$|R
5000|$|Knowledge based {{processors}} mainly process <b>packet</b> <b>headers</b> (20% of {{the packet}} approximately) which enables network awareness. Content processors, by contrast, allow for packet payload inspection (80% of the packet is data) and therefore must search [...] "deeper" [...] into the packet.|$|R
50|$|The <b>packet</b> <b>header</b> in IPv6 is {{simpler than}} the IPv4 header. Many rarely used fields {{have been moved}} to {{optional}} header extensions.|$|E
50|$|A packet is a {{block of}} data with length that can vary between {{successive}} packets, ranging from 7to 65,542 bytes, including the <b>packet</b> <b>header.</b>|$|E
50|$|In {{a network}} based on packet switching, {{processing}} delay {{is the time}} it takes routers to process the <b>packet</b> <b>header.</b> Processing delay is a key component in network delay.|$|E
40|$|Conference on Lasers and Electro-Optics and 2006 Quantum Electronics and Laser Science Conference, CLEO/QELS 2006, Long Beach, CA, 21 - 26 May 2006 We {{report the}} first {{demonstration}} of all-optical packet switching of 160 Gb/s <b>packets</b> with all-optical <b>header</b> processing of the 10 Gb/s <b>packet</b> <b>headers.</b> The timing diagrams {{before and after}} packet switching are shown. Department of Electrical EngineeringDepartment of Electronic and Information EngineeringRefereed conference pape...|$|R
5000|$|Routing is {{designed}} such that each packet requires very little handling {{by an individual}} router, or node. Each node will respond to 'search queries' asking it for other nodes nearby to it. This allows the sending node to determine and add routes to its own routing table. [...] Once the sending node has determined a route, it sends its packet to the first node on said route. For each hop, the receiving node reads the <b>packet's</b> <b>header</b> to determine where to next send the packet. Before the packet is forwarded to the next hop, the node performs a bit shift on the <b>packet's</b> <b>headers,</b> making it ready {{for use by the}} next node.|$|R
30|$|In this work, flow {{splitting}} {{is implemented}} by building little flow of packets from an original one. To face reordering challenge, {{we use the}} numbering packets each time the flows are split, because this method does not modify significantly the <b>packets</b> <b>headers.</b>|$|R
5000|$|Aggregation at layer 3 (network layer) in the OSI {{model can}} use {{round-robin}} scheduling, hash values computed from {{fields in the}} <b>packet</b> <b>header,</b> {{or a combination of}} these two methods.|$|E
50|$|The Point-to-Point Tunneling Protocol (PPTP), {{defined in}} RFC 2637, uses a variant GRE <b>packet</b> <b>header</b> structure, {{represented}} below. PPTP creates a GRE tunnel {{through which the}} PPTP GRE packets are sent.|$|E
50|$|Next, we flip {{every bit}} in that value, {{to obtain the}} checksum:0100 0111 1001 1110 becomes:1011 1000 0110 0001This is equal to B861 in hexadecimal, as shown {{underlined}} in the original IP <b>packet</b> <b>header.</b>|$|E
5000|$|Raw sockets (or Raw IP sockets), {{typically}} {{available in}} routers and other network equipment. Here the transport layer is bypassed, and the <b>packet</b> <b>headers</b> are made {{accessible to the}} application, {{and there is no}} port number in the address, just the IP address.|$|R
50|$|Packetized Elementary Stream (PES) is a {{specification}} {{defined by}} the MPEG communication protocol (see the MPEG-2 standard) that allows an elementary stream to be divided into packets. The elementary stream is packetized by encapsulating sequential data bytes from the elementary stream inside PES <b>packet</b> <b>headers.</b>|$|R
50|$|A packet {{consists}} of control information and user data, {{which is also}} known as the payload. Control information provides data for delivering the payload, for example: source and destination network addresses, error detection codes, and sequencing information. Typically, control information is found in <b>packet</b> <b>headers</b> and trailers.|$|R
50|$|The GSE <b>Packet</b> <b>header</b> {{is highly}} dynamic and {{provides}} for many options. The minimum header is two bytes, comprising three flags fields, and a 12-bit payload length field. The diagram below shows all possible fields.|$|E
5000|$|Forwarding plane: The router {{forwards}} data packets between incoming {{and outgoing}} interface connections. It routes {{them to the}} correct network type using information that the <b>packet</b> <b>header</b> contains. It uses data recorded in the routing table control plane.|$|E
50|$|The RTMP defines several virtual {{channels}} {{on which}} packets may be sent and received, and which operate independently of each other. For example, {{there is a}} channel for handling RPC requests and responses, a channel for video stream data, a channel for audio stream data, a channel for out-of-band control messages (fragment size negotiation, etc.), and so on. During a typical RTMP session, several channels may be active simultaneously at any given time. When RTMP data is encoded, a <b>packet</b> <b>header</b> is generated. The <b>packet</b> <b>header</b> specifies, amongst other matters, the ID of the channel on which {{it is to be}} sent, a timestamp of when it was generated (if necessary), {{and the size of the}} packet's payload. This header is then followed by the actual payload content of the packet, which is fragmented according to the currently agreed-upon fragment size before it is sent over the connection. The <b>packet</b> <b>header</b> itself is never fragmented, and its size does not count towards the data in the packet's first fragment. In other words, only the actual packet payload (the media data) is subject to fragmentation.|$|E
40|$|Multipath routing {{strategies}} such as Equal-Cost MultiPath (ECMP) {{are widely}} used in IP and data-center networks. Most current methods to balance packets over the multiple next hops toward the destination base their decision on a hash computed over selected fields of the <b>packet</b> <b>headers.</b> Because of the non-invertible nature of hash functions, {{it is hard to}} determine the values of those fields so as to make the packet follow a specific path in the network. However, several applications might benefit from being able to choose such a path. Therefore, we propose a novel next-hop selection method based on an invertible function. By encoding the selection of successive routers into common fields of <b>packet</b> <b>headers,</b> the proposed method enables end hosts to force their packets to follow a specific path. E...|$|R
50|$|A nested Type-Length-Value (TLV) {{format is}} used to encode all {{messages}} on the wire. Each message is composed {{of a set of}} <b>packet</b> <b>headers</b> and a protocol message that includes the name, the content (or payload), and information used to cryptographically validate the message - all contained in nested TLVs.|$|R
50|$|Another {{example is}} making the packets shorter to {{decrease}} latency (as is required if a bus must operate as a memory interface). Smaller <b>packets</b> mean <b>packet</b> <b>headers</b> consume {{a higher percentage of}} the packet, thus decreasing the effective bandwidth. Examples of bus protocols designed for this purpose are RapidIO and HyperTransport.|$|R
