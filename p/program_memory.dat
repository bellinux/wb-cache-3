346|1701|Public
25|$|While Babbage's {{machines}} were mechanical and unwieldy, their basic architecture {{was similar to}} a modern computer. The data and <b>program</b> <b>memory</b> were separated, operation was instruction-based, the control unit could make conditional jumps, and the machine had a separate I/O unit.|$|E
25|$|All models {{feature a}} Broadcom {{system on a chip}} (SoC), which {{includes}} an ARM compatible {{central processing unit}} (CPU) and an on-chip graphics processing unit (GPU, a VideoCore IV). CPU speed ranges from 700MHz to 1.2GHz for the Pi3 and on board memory range from 256MB to 1GB RAM. SecureDigital (SD) cards are used to store the operating system and <b>program</b> <b>memory</b> in either the SDHC or MicroSDHC sizes. Most boards have between one and four USB slots, HDMI and composite video output, and a 3.5mm phono jack for audio. Lower level output is provided by a number of GPIO pins which support common protocols like I²C. The B-models have an 8P8C Ethernet port and the Pi3 and Pi ZeroW have on board Wi-Fi 802.11n and Bluetooth.|$|E
2500|$|In {{practice}} a program may not intentionally contain instructions {{to jump to}} a particular register. The traditional solution is to find an unintentional instance of a suitable opcode at a fixed location somewhere within the <b>program</b> <b>memory.</b> In figure [...] on the left you can see an example of such an unintentional instance of the i386 jmp esp instruction. The opcode for this instruction is FF E4. This two-byte sequence {{can be found at}} a one-byte offset {{from the start of the}} instruction call DbgPrint at address 0x7C941EED. If an attacker overwrites the program return address with this address the program will first jump to 0x7C941EED, interpret the opcode FF E4 as the jmp esp instruction, and will then jump to the top of the stack and execute the attacker's code.|$|E
5000|$|Extended {{instruction}} set (multiply instructions and instructions for handling larger <b>program</b> <b>memories)</b> ...|$|R
50|$|The <b>program</b> in <b>memory</b> (<b>PROGRAM</b> XPLT) {{is started}} at {{location}} 21.|$|R
50|$|A guard byte {{is a part}} of a {{computer}} <b>program's</b> <b>memory</b> that helps software developers find buffer overflows while developing the program.|$|R
50|$|The 8051 is {{designed}} as a strict Harvard architecture; it can only execute code fetched from <b>program</b> <b>memory,</b> and has no instructions to write to <b>program</b> <b>memory.</b>|$|E
5000|$|Flash memory (<b>program</b> <b>memory,</b> {{programmed}} using MPLAB devices) ...|$|E
5000|$|MC9RS08KB12: 12 kB of Flash-programmable <b>program</b> <b>memory,</b> I2C, SCI.|$|E
50|$|In C {{and later}} {{languages}} that supported dynamic memory allocation, the runtime system {{also included a}} library that managed the <b>program's</b> <b>memory</b> pool.|$|R
40|$|The {{main purpose}} of my {{bachelor}} thesis is acquaint with issue programming of Atmel AVR microcontrollers {{and to create a}} simple chipprogrammer with component units like LEDs, switches, LCD display, DA converter for testing and development. The first part deal about questions of theory <b>programming</b> <b>memory</b> inside microcontrollers and descrption of <b>programming</b> algorithm. The <b>memories</b> is possible <b>program</b> in three way. The most used method is method call „In System Programming“ ISP. This method provide easy and fast manupulation. Order method of <b>programming</b> <b>memory</b> require 12 V supply. These method are parallel and serial high voltage programming. The concept of programmer is design to all method of <b>programming</b> <b>memory.</b> From previous information about <b>programming</b> <b>memory</b> was written source code of program to control programmer that receive command from computer and ensure performing of right algorithm in target microcontroller. In the next chapter is clarified design of hardware items and there is the simple user manual of items and installation of programmer. The final part of thesis explains how to use programmer's tworowconnectors and setting jumpers for programing in daily work. In attachments are electrical scheme, list of devices, printed circuit board, files of circuit board and scheme in Eagle format, source code and binary program to control microcontroller of simple chipprogrammer. These attachments are needed for make a chipprogrammer...|$|R
50|$|Jana, the {{sensitive}} {{daughter of a}} creative genius, Dr. Loren, is distraught over her parents' reliance on her father's five seemingly perfect robot servants, complete with <b>programmed</b> <b>memories</b> and personalities.|$|R
5000|$|MC9RS08LA8: 8 kB of Flash-programmable <b>program</b> <b>memory,</b> SCI, SPI.|$|E
5000|$|... q = Extend <b>program</b> <b>memory</b> address with RAMPZ (0=0:Z, 1=RAMPZ:Z) ...|$|E
5000|$|... an {{external}} <b>program</b> <b>memory</b> interface {{to expand the}} code space ...|$|E
50|$|The CP21xx family {{offers a}} {{plug-and-play}} interface solution that support VCP, USBXpress, HID, and USB Audio driver suites on Windows, Linux, and OSX. These devices support Crystal-less operation and in-system <b>programming</b> <b>memory.</b>|$|R
50|$|The {{other main}} issue was that early Macs lacked a memory {{management}} unit (MMU)s. MMUs provide key functions in modern computers; they map memory addresses from main memory to each application so the applications believe they are running in a space of their own, they provide memory protection which ensures programs cannot accidentally overwrite other <b>program's</b> <b>memory,</b> and they provide systems to move data from program-to-program, in a safe way using shared memory. Lacking the last of these—shared memory—the API was instead written so the operating system and application shared all memory, which is what allowed QD to examine the <b>program's</b> <b>memory</b> for settings like the line drawing mode or color.|$|R
50|$|The {{database}} had {{a capacity}} of 1200 fields, which could each hold 124 characters. In order to keep down the <b>programs</b> <b>memory</b> requirements, {{it was necessary to}} export a database to the spreadsheet module in order to sort it.|$|R
5000|$|... #Caption: <b>Program</b> <b>memory</b> {{filled with}} code, NOPs, and error handler ...|$|E
50|$|The HP-65 had a <b>program</b> <b>memory</b> {{for up to}} 100 {{instructions}} of 6 bits {{which included}} subroutine calls and conditional branching based on comparison of x and y registers. Some but not all commands entered as multiple keystrokes were stored in a single <b>program</b> <b>memory</b> cell. When displaying a program, the key codes were shown without line numbers.|$|E
50|$|PaX flags data {{memory as}} non-executable, <b>program</b> <b>memory</b> as non-writable and {{randomly}} arranges the <b>program</b> <b>memory.</b> This effectively prevents many security exploits, such as {{some kinds of}} buffer overflows. The former prevents direct code execution absolutely, while the latter makes so-called return-to-libc (ret2libc) attacks difficult to exploit, relying on luck to succeed, but doesn't prevent overwriting variables and pointers.|$|E
5000|$|... #Subtitle level 2: Multithreaded <b>programming</b> and <b>memory</b> {{visibility}} ...|$|R
50|$|Digital circuits: Boolean algebra, {{minimization}} of Boolean functions; {{logic gates}} digital IC families (DTL, TTL, ECL, MOS, CMOS). Combinational circuits: arithmetic circuits, code converters, multiplexers and decoders. Sequential circuits: latches and flip-flops, counters and shift-registers. Sample and hold circuits, ADCs, DACs. Semiconductor <b>memories.</b> Microprocessor(8085): architecture, <b>programming,</b> <b>memory</b> and I/O interfacing.|$|R
50|$|Digital circuits: Boolean {{functions}} (NOT, AND, OR, XOR,...). Logic gates digital IC families (DTL, TTL, ECL, MOS, CMOS). Combinational circuits: arithmetic circuits, code converters, multiplexers and decoders. Sequential circuits: latches and flip-flops, {{counters and}} shift-registers. Sample and hold circuits, ADCs, DACs. Semiconductor memories. Microprocessor 8086: architecture, <b>programming,</b> <b>memory</b> and I/O interfacing.|$|R
5000|$|JMP: all 13 bits {{are used}} as an {{absolute}} address in <b>program</b> <b>memory.</b>|$|E
50|$|There {{are also}} {{processors}} which are Harvard machines {{by the most}} rigorous definition (that program and data memory occupy different address spaces), and are only modified in the weak sense that there are operations to read and/or write <b>program</b> <b>memory</b> as data. For example, LPM (Load <b>Program</b> <b>Memory)</b> and SPM (Store <b>Program</b> <b>Memory)</b> instructions in the Atmel AVR implement such a modification. Similar solutions are found in other microcontrollers such as the PIC and Z8Encore!, many families of digital signal processors such as the TI C55x cores, and more. Because instruction execution is still restricted to the program address space, these processors are very unlike von Neumann machines.|$|E
5000|$|... <b>program</b> <b>memory</b> - 60 steps (no ROM, {{the code}} is lost after shut down); ...|$|E
5000|$|A new ELF library that {{implements}} UN*X-type shared {{objects and}} dynamic linking. Shared objects are files that are loaded during runtime {{of a program}} and {{become part of the}} <b>program's</b> <b>memory</b> image. They have access to symbols and procedures of the main program as well as any other shared object loaded.|$|R
5000|$|DORMNT - Put {{the user}} into dormant status, with <b>program</b> in <b>memory</b> ...|$|R
5000|$|SCRATCH - {{to clear}} {{the content of the}} current <b>program</b> from <b>memory</b> ...|$|R
50|$|The 8032 {{had these}} same {{features}} as the 8052 except lacked internal ROM <b>program</b> <b>memory.</b>|$|E
5000|$|The JMP {{instruction}} performs an {{unconditional branch}} to anywhere within the 8192 word <b>program</b> <b>memory</b> ...|$|E
5000|$|All current PICAXE chips have {{at least}} 2048 bytes of on board <b>program</b> <b>memory</b> {{available}} for user programs: ...|$|E
50|$|The Bug Finder module {{identifies}} software bugs {{by performing}} static program analysis on source code. It finds defects such as numerical computation, <b>programming,</b> <b>memory,</b> and other errors. It also produces software metrics such as Comment density of a source file, Cyclomatic complexity, Number of lines, parameters, call levels, etc. in a function, Identified run-time {{errors in the}} software.|$|R
50|$|The design {{concept of}} TAL, an {{evolution}} of Hewlett Packard's SPL, was intimately associated and optimized with a microprogrammed CISC instruction set. Each TAL statement could easily compile into {{a sequence of}} instructions that manipulated data on a transient floating register stack. The register stack itself floated at {{the crest of the}} <b>program's</b> <b>memory</b> allocation and call stack.|$|R
50|$|When the DOS DEBUG <b>program</b> is in <b>memory,</b> Ontario.2048 will detect it and {{disinfect}} <b>programs</b> in <b>memory</b> {{to avoid}} being analysed. Ontario.2048 also features an extremely complex encryption system; a given sample of Ontario.2048 may only share two bytes in common with another.|$|R
