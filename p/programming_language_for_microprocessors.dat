2|10000|Public
2500|$|... and he {{continued}} to experiment with microcomputers and the emerging technology of floppy disks. Intel lent him systems using the 8008 and 8080 processors, and in 1973, he developed the first high-level <b>programming</b> <b>language</b> <b>for</b> <b>microprocessors,</b> called PL/M. He created CP/M the same year to enable the 8080 to control a floppy drive, combining {{for the first time}} all the essential components of a computer at the microcomputer scale. He demonstrated CP/M to Intel, but Intel had little interest and chose to market PL/M instead.|$|E
50|$|Kildall briefly {{returned}} to UW and finished his doctorate {{in computer science}} in 1972, then resumed teaching at NPS. He published a paper that introduced the theory of data-flow analysis used today in optimizing compilers,and he continued to experiment with microcomputers and the emerging technology of floppy disks. Intel lent him systems using the 8008 and 8080 processors, and in 1973, he developed the first high-level <b>programming</b> <b>language</b> <b>for</b> <b>microprocessors,</b> called PL/M. He created CP/M the same year to enable the 8080 to control a floppy drive, combining {{for the first time}} all the essential components of a computer at the microcomputer scale. He demonstrated CP/M to Intel, but Intel had little interest and chose to market PL/M instead.|$|E
40|$|Currently, many machine vision, {{signal and}} image {{processing}} problems are solved on personal computers {{due to the}} low cost involved in these computers and the many excellent software tools that exist, such as MATLAB. However, computationally expensive tasks {{require the use of}} multi-processor computers that are expensive and difficult to use efficiently due to communications between the processors. In these cases, FPGAs (Field Programmable Gate Arrays) are the best choice but they are not as widely used because of lack of experience in using these devices, difficulties with algorithmic translation and immaturity of the design and implementation tools <b>for</b> FPGAs. <b>Programming</b> <b>languages</b> are always evolving and the <b>programming</b> <b>languages</b> <b>for</b> <b>microprocessors</b> have evolved significantly, from functional and procedural languages to object-oriented languages. Nowadays, a new paradigm called aspect-oriented software development (AOSD) is becoming more widespread. However, hardware <b>programming</b> <b>languages</b> have not evolved to the same extent as the software <b>programming</b> <b>languages</b> <b>for</b> <b>microprocessors.</b> They are still dominated by the technologies developed in 1980 s, which have significant deficiencies described in this thesis. Recent advances in HDLs (Hardware Description Languages) have taken a conservative approach based on well-proven software techniques...|$|R
5000|$|... occam is an {{imperative}} {{procedural language}} (such as Pascal). It {{was developed by}} David May and others at INMOS, advised by Tony Hoare, as the native <b>programming</b> <b>language</b> <b>for</b> their transputer <b>microprocessors,</b> but implementations <b>for</b> other platforms are available. The most widely known version is occam 2; its programming manual was written by Steven Ericsson-Zenith and others at INMOS.|$|R
40|$|When {{implementing}} {{final year}} projects, students {{may need to}} program a microprocessor {{in order to achieve}} the project objectives. Therefore, a system is designed in order to assist students who have limited background knowledge in computer engineering to learn the basics of microprocessor programming primarily using the C <b>programming</b> <b>language.</b> In addition to the software, various hardware components are provided so that students can develop simple systems so the learning outcomes can be enhanced by practice. From feedback collected, users found that they are able to learn simple C <b>language</b> <b>programming</b> <b>for</b> a <b>microprocessor</b> {{with the help of the}} system. Department of Electrical EngineeringRefereed conference pape...|$|R
40|$|As {{more complex}} and {{functionally}} diverse requirements are placed on high consequence embedded applications, ensuring safe and secure operation requires an execution environment that is ultra reliable from a system viewpoint. In many cases the safety and security of the system depends upon the reliable cooperation between the hardware and the software to meet real-time system throughput requirements. The selection of a microprocessor and its associated development environment for an embedded application has the most far-reaching effects on the development and production of the system than any other element in the design. The effects of this choice ripple through {{the remainder of the}} hardware design and profoundly affect the entire software development process. While state-of-the-art software engineering principles indicate that an object oriented (OO) methodology provides a superior development environment, traditional <b>programming</b> <b>languages</b> available <b>for</b> <b>microprocessors</b> targeted <b>for</b> deeply embedded applications do not directly support OO techniques. Furthermore, the microprocessors themselves do not typically support nor do they enforce an OO environment. This paper describes a system level approach for the design of a <b>microprocessor</b> intended <b>for</b> use in deeply embedded high consequence applications that both supports and enforces an OO execution environment...|$|R
40|$|This masters thesis report {{presents}} the work {{leading to a}} C compiler for the NanoRisc processor. The NanoRisc is a general purpose embedded RISC-processor with simple architecture aimed at replacing custom logic in Systems on Chip (SOC) designs. Basic tools for writing and debugging small programs are already in existence, {{but these are not}} sufficient for larger and more complex programs. As the C <b>programming</b> <b>language</b> is the de facto standard for writing high level <b>language</b> <b>programs</b> <b>for</b> small <b>microprocessors</b> a C compiler was desirable. Prior to developing a compiler the NanoRisc processor's suitability <b>for</b> the C <b>programming</b> <b>language</b> was evaluated. The NanoRisc architecture was found to be C friendly with a sufficient number of general registers and stack functionality to facilitate a C compiler. For the compiler development several approaches was considered including an implementation from scratch and using a compiler generator. In the end the decision fell on retargeting the Gnu C Compiler (GCC) version 4. 1. 0. This choice was made because of GCC's quality, feature completeness {{and the fact that it}} is the most widespread open-source compiler framework today. GCC also made it possible to focus on the compiler back end generating code for the NanoRisc processor, not using time developing another C front end. The only concern in choosing GCC was the developing time as it is a large and complex system. The process of retargeting GCC consists of specifying GCC's rich set of parameters and describing the target architecture in a special machine description language. The important aspects of this process is analyzed and explained in the source code. In the end the developing time needed to retarget GCC was even greater than suspected resulting in that the compiler was not running at the end of this project. </p...|$|R
5000|$|The PL/M <b>programming</b> <b>language</b> (an acronym of <b>Programming</b> <b>Language</b> <b>for</b> Microcomputers)is a {{high-level}} language conceived and developed by Gary Kildall in 1973 [...] for Hank Smith at Intel <b>for</b> its <b>microprocessors.</b>|$|R
50|$|Z-Tel a {{text editing}} <b>language</b> <b>for</b> Z80 <b>microprocessors.</b>|$|R
40|$|While {{the state}} of the art is {{relatively}} sophisticated in <b>programming</b> <b>language</b> support <b>for</b> computer algebra, there has been less development in <b>programming</b> <b>language</b> support <b>for</b> symbolic computation over the past two decades. We summarize certain advances in <b>programming</b> <b>languages</b> <b>for</b> computer algebra and propose a set of directions and challenges <b>for</b> <b>programming</b> <b>languages</b> <b>for</b> symbolic computation. ...|$|R
5000|$|Curl (<b>programming</b> <b>language),</b> a {{declarative}} <b>programming</b> <b>language</b> <b>for</b> web applications ...|$|R
5000|$|Ur (<b>programming</b> <b>language)</b> - a {{functional}} <b>programming</b> <b>language</b> <b>for</b> web development ...|$|R
5000|$|Hindi <b>Programming</b> <b>Language</b> - A Hindi <b>programming</b> <b>language</b> <b>for</b> the [...]NET Framework.|$|R
5000|$|R (<b>programming</b> <b>language)</b> - {{open-source}} {{open source}} <b>programming</b> <b>language</b> <b>for</b> statistical computing.|$|R
30|$|And, if the {{software-defined}} {{networks are}} programmable, why not {{to develop a}} <b>programming</b> <b>language</b> <b>for</b> them? This is {{the objective of the}} Frenetic language [71]. Rexford recently presented a discussion on <b>programming</b> <b>languages</b> <b>for</b> SDN [72]. Other recent projects include SDN compilers [73] and debuggers [74].|$|R
50|$|Henry Lieberman, Dan Theriault, et al. {{developed}} Act1, an Actor <b>programming</b> <b>language.</b> Subsequently <b>for</b> his masters thesis, Dan Theriault developed Act2. These early {{proof of}} concept languages were rather inefficient and not suitable for applications. In his doctoral dissertation, Ken Kahn developed Ani, which he used to develop several animations. Bill Kornfeld developed the Ether <b>programming</b> <b>language</b> <b>for</b> the Scientific Community Metaphor in his doctoral disseration. William Athas and Nanette Boden 1988 developed Cantor which is an Actor <b>programming</b> <b>language</b> <b>for</b> scientific computing. Jean-Pierre Briot 1999 developed means to extend Smalltalk 80 for Actor computations. Christine Tomlinson, Mark Scheevel, Greg Lavender, Greg Meredith, et al. 1995 at MCC developed an Actor <b>programming</b> <b>language</b> <b>for</b> InfoSleuth agents in Rosette.|$|R
2500|$|... a {{declarative}} <b>programming</b> <b>language</b> <b>for</b> dynamic <b>programming</b> algorithms ...|$|R
5000|$|ChucK (a {{synchronous}} reactive <b>programming</b> <b>language</b> <b>for</b> audio) ...|$|R
5000|$|TouchDesigner, visual <b>programming</b> <b>language</b> <b>for</b> {{real-time}} {{multimedia content}} ...|$|R
2500|$|The Babbage <b>programming</b> <b>language</b> <b>for</b> GEC 4000 series {{minicomputers}} ...|$|R
50|$|Perl is the {{underlying}} <b>programming</b> <b>language</b> <b>for</b> the DroboApps.|$|R
50|$|Robic — <b>programming</b> <b>language</b> <b>for</b> 8-11 {{years old}} kids.|$|R
5000|$|ChucK - audio <b>programming</b> <b>language</b> <b>for</b> {{real-time}} audio synthesis ...|$|R
5000|$|Big Data (ECL, {{data-centric}} <b>programming</b> <b>language</b> <b>for</b> Big Data) ...|$|R
5000|$|SuperCollider - <b>programming</b> <b>language</b> <b>for</b> {{real time}} audio {{synthesis}} ...|$|R
5000|$|Supports ActionScript 2.0, an {{object-oriented}} <b>programming</b> <b>language</b> <b>for</b> developers ...|$|R
5000|$|Symbolics {{provided}} several <b>programming</b> <b>languages</b> <b>for</b> {{use with}} Genera: ...|$|R
5000|$|Scratch, a 21st-century {{multimedia}} <b>programming</b> <b>language</b> <b>for</b> young people.|$|R
5000|$|The Babbage <b>programming</b> <b>language</b> <b>for</b> GEC 4000 series {{minicomputers}} ...|$|R
25|$|Tree-traversal APIs {{accessible}} from a <b>programming</b> <b>language,</b> <b>for</b> example DOM.|$|R
50|$|Kermeta is a {{modeling}} and <b>programming</b> <b>language</b> <b>for</b> metamodel engineering.|$|R
50|$|PLEXIL is a <b>programming</b> <b>language</b> <b>for</b> {{representing}} {{plans for}} automation.|$|R
5000|$|Sun Microsystems' SwapDrop <b>programming</b> <b>language</b> <b>for</b> Sun Ray {{smartcard}} identification ...|$|R
5000|$|Minibloq, visual <b>programming</b> <b>language</b> <b>for</b> {{robotics}} and Arduino compatible boards ...|$|R
5000|$|Opa, a <b>programming</b> <b>language</b> <b>for</b> web development, free open source.|$|R
5000|$|... biXid is a <b>programming</b> <b>language</b> <b>for</b> {{processing}} XML data bidirectionally ...|$|R
