51|12|Public
25|$|On 2 August 2007, Beta 1 was released. Major {{features}} {{included a}} <b>pixmap</b> cache – speeding up icon loading, KDE PIM improvements, improved KWin effects and configuration, better interaction between Konqueror and Dolphin and Metalink support added to KGet for improved downloads.|$|E
50|$|Pseudo-transparency is a {{term used}} for X Window System clients that {{simulate}} the appearance of translucency or transparency by manipulating the same <b>pixmap</b> that has been drawn on the root window, or by instructing the X Server that the Background <b>Pixmap</b> should be inherited from the window's parent.|$|E
50|$|Present accepts any X <b>pixmap</b> as {{the source}} for a screen update. Since pixmaps are {{standard}} X objects, Present can be used not only by DRI3 clients performing direct rendering, but also by any X client rendering on a <b>pixmap</b> by any means. For example, most existing non-GL based GTK+ and Qt applications used to do double buffered <b>pixmap</b> rendering using XRender. The Present extension {{can also be used}} by these applications to achieve efficient and non-tearing screen updates. This is the reason why Present was developed as a separate standalone extension instead of being part of DRI3.|$|E
50|$|Windows and <b>pixmaps</b> are collectively named {{drawable}}s, {{and their}} content data resides on the server. A client can however request {{the content of}} a drawable to be transferred from the server to the client or vice versa.|$|R
50|$|The client {{can request}} {{a number of}} graphic operations, such as {{clearing}} an area, copying an area into another, drawing points, lines, rectangles, and text. Beside clearing, all operations are possible on all drawables, both windows and <b>pixmaps.</b>|$|R
50|$|It is {{intended}} primarily for creating icon <b>pixmaps,</b> and supports transparent pixels. Derived {{from the earlier}} XBM syntax, it is a plain text file in the XPM2 format or of a C programming language syntax, which can {{be included in a}} C program file.|$|R
50|$|The {{more general}} term <b>pixmap</b> {{refers to a}} map of pixels, where each one may store more than two colors, thus using more than one bit per pixel. Often bitmap is used for this as well. In some contexts, the term bitmap implies one bit per pixel, while <b>pixmap</b> is used for images with {{multiple}} bits per pixel.|$|E
50|$|Applications create {{windows as}} usual (specifying width and height), but can then change {{the shape of}} a window to be a subset of the {{original}} area. by sending the X display server either a list of rectangles or a <b>pixmap</b> of color depth one (a black-and-white <b>pixmap).</b> More precisely, a client can request the rectangles or the <b>pixmap</b> to be set as the new shape, but also to be combined in various ways (e.g., intersected or added) with the old shape. A third way for changing {{the shape of a}} window is by using the current shape of a window or a part of it.|$|E
5000|$|GDK {{lets you}} do low level stuff, like e.g. [...] "blit this <b>pixmap</b> to the screen".|$|E
5000|$|Egon Animator is the X-based {{animation}} {{development tool}} for Unix. The {{idea is that}} [...] "objects" [...] (rectangles, lines, <b>pixmaps</b> and so on) are added to a [...] "stage" [...] where they are then made to perform by telling them {{where they should be}} and when. It can also edit MagicPoint files.|$|R
50|$|Color QuickDraw {{introduced}} {{new data}} structures, including GDevices to represent each attached video card/monitor, {{and a new}} color GrafPort (CGrafPort) structure to handle color, as well as <b>PixMaps</b> instead of BitMaps for multiple bits-per-pixel images. One of the hacks for compatibility used here was that the new structure was exactly {{the same size as}} the old one, with most data members in the same place, but with additional handles and pointers to color structures in place of the BitMap fields. The upper two bits of the rowBytes field were pressed into use as flags to distinguish a GrafPort from a CGrafPort (they were always zero on old-style GrafPorts because a BitMap could never feasibly be so wide as to ever set these bits). The use of these two high bits would come back to haunt QuickDraw later, as it forced a maximum row width of just 4,096 on 32-bit <b>PixMaps,</b> which became problematic for high-resolution graphics work. Later development (Carbon) eliminated this limitation but was not fully backward compatible. A Palette Manager was also added in Color QuickDraw which managed the arbitration of colors on indexed video devices. Most graphics primitives operations remained either unchanged (but would operate in color), or else new color versions of the black and white APIs were added.|$|R
50|$|Identifiers are 32-bit {{integers}} {{with their}} three most significant bits equal to zero. Every client {{has its own}} set of identifiers it can use for creating new resources. This set is specified by the server as two integers included in the acceptance packet (the packet it sends to the client to inform it that the connection is accepted). Clients choose identifiers that are in this set in such a way they do not clash: two objects among windows, <b>pixmaps,</b> fonts, colormaps, and graphic contexts cannot have the same identifier.|$|R
50|$|A <b>pixmap</b> is {{a region}} of memory {{that can be used}} for drawing. Unlike windows, pixmaps are not {{automatically}} shown on the screen. However, the content of a <b>pixmap</b> (or a part of it) can be transferred to a window and vice versa. This allows for techniques such as double buffering. Most of the graphical operations that can be done on windows can also be done on pixmaps.|$|E
50|$|Netpbm {{format is}} a family {{including}} the portable <b>pixmap</b> file format (PPM), the portable graymap file format (PGM) and the portable bitmap file format (PBM). These are either pure ASCII files or raw binary files with an ASCII header that provide very basic functionality {{and serve as a}} lowest common denominator for converting <b>pixmap,</b> graymap, or bitmap files between different platforms. Several applications refer to them collectively as PNM (Portable aNy Map).|$|E
50|$|Users can {{transfer}} data {{of different types}} between clients: it is usually text, but {{can also be a}} <b>pixmap,</b> a number, a list of objects, etc.|$|E
5000|$|All {{data about}} windows, <b>pixmaps,</b> fonts, etc. {{are stored in}} the server. The client knows {{identifiers}} of these objects—integers it uses as names for them when interacting with the server. For example, if a client wishes a window to be created, it requests the server to create a window with a given identifier. The identifier can be later used by the client to request, for example, a string to be drawn in the window. The following objects reside in the server and are known by the client via a numerical identifier: ...|$|R
50|$|All PXG {{variants}} {{are capable}} of either 8-bit or 24-bit color, a resolution of 1280 × 1024 and a refresh rate of either 66 or 72 Hz. The PXG also has an 8-bit or 24-bit Z-buffer and is double buffered. The color depth {{and the depth of}} Z-buffer can be extended by installing additional VSIMMs or Z-buffer modules on the module. The PXG Turbo variants {{are capable of}} 24-bit color, a resolution of 1280 × 1024 and a refresh rate of either 66 or 72 Hz. They differ by featuring a 24-bit buffer for storing off-screen <b>pixmaps</b> in addition to the 24-bit Z-buffer and double buffer.|$|R
5000|$|Tile/Ttk: Tile/Ttk is a {{styles and}} theming widget {{collection}} that can replace {{most of the}} widgets in Tk with variants that are truly platform native through calls to an operating system's API. Themes covered in this way are Windows XP, Windows Classic, Qt (that hooks into the X11 KDE environment libraries) and Aqua (Mac OS X). A theme can also be constructed without these calls using widget definitions supplemented with image <b>pixmaps.</b> Themes created this way include Classic Tk, Step, Alt/Revitalized, Plastik and Keramik. Under Tcl 8.4, this package is known as Tile, while in Tcl 8.5 it has been folded into the core distribution of Tk (as Ttk).|$|R
50|$|There are {{two main}} file formats for {{computational}} photography: one {{is based on an}} extension of the PPM (Portable <b>Pixmap),</b> and the other is based on an extension of JPEG.|$|E
50|$|GOCR (or JOCR) {{is a free}} optical {{character}} recognition program, initially written by Jörg Schulenburg. It {{can be used to}} convert or scan image files (portable <b>pixmap</b> or PCX) into text files.|$|E
50|$|X <b>PixMap</b> (XPM) is {{an image}} file format used by the X Window System, created in 1989 by Daniel Dardailler and Colas Nahaboo working at Bull Research Center at Sophia Antipolis, France, and later {{enhanced}} by Arnaud Le Hors.|$|E
50|$|Precisely, atoms are {{identifiers}} of strings {{stored in}} the server. They {{are similar to the}} identifiers of resources (Windows, <b>Pixmaps,</b> etc.) but differ from them in two ways. First, the identifiers of atoms are chosen by the server, not by the client. In other words, when a client requests {{the creation of a new}} atom, it only sends the server the string to be stored, not its identifier; this identifier is chosen by the server and sent back as a reply to the client. The second important difference between resources and atoms is that atoms are not associated with clients. Once created, an atom survives until the server quits or resets (this is not the default behavior of resources).|$|R
40|$|On {{the other}} hand, {{traditional}} operating systems typically provide {{one or more}} flat interfaces containing Traditional operating systems typically provide a interface specific abstractions. For example, the UNIX number of flat, non-object oriented interfaces through interface presents abstractions such as pathnames, which system services are provided to applications. Two descriptors, files, directories, processes, etc.; the X such examples are the UNIX 1 system call interface and the X Window System interface presents abstractions such as Window System 2 protocol. Typically such services are resource IDs, windows, <b>pixmaps,</b> input events, etc. While provided by large, monolithic implementations, with no these interfaces typically contain {{a small number of}} provision for deriving related implementations through abstractions with largely independent semantics, these inheritance or other means. abstractions are not presented to applications as objects. Nonetheless, it is possible to provide flexible, object Thus, no clear means of inheritance for such interfaces is oriented views of otherwise flat, non-object oriente...|$|R
40|$|Context [...] This project {{looked at}} the {{development}} of a stereoscopic 3 D environment in which a user is able to draw freely in all three dimensions. The main focus was on the storage and manipulation of the ‘digital ink’ with which the user draws. For a drawing and sketching package to be effective it must not only have an easy to use user interface, it must be able to handle all input data quickly and efficiently so that the user is able to focus fully on their drawing. [...] Background [...] When it comes to sketching in three dimensions the majority of applications currently available rely on vector based drawing methods. This is primarily because the applications are designed to take a users two dimensional input and transform this into a three dimensional model. Having the sketch represented as vectors makes it simpler for the program to act upon its geometry and thus convert it to a model. There are a number of methods to achieve this aim including Gesture Based Modelling, Reconstruction and Blobby Inflation. Other vector based applications focus on the creation of curves allowing the user to draw within or on existing 3 D models. They also allow the user to create wire frame type models. These stroke based applications bring the user closer to traditional sketching rather than the more structured modelling methods detailed. While at present the field is inundated with vector based applications mainly focused upon sketch-based modelling there are significantly less voxel based applications. The majority of these applications focus on the deformation and sculpting of voxmaps, almost the opposite of drawing and sketching, and the creation of three dimensional voxmaps from standard two dimensional <b>pixmaps.</b> How to actually sketch freely within a scene represented by a voxmap has rarely been explored. This comes as a surprise when so many of the standard 2 D drawing programs in use today are pixel based. [...] Method [...] As part of this project a simple three dimensional drawing program was designed and implemented using C and C++. This tool is known as Sketch 3 D and was created using a Model View Controller (MVC) architecture. Due to the modular nature of Sketch 3 Ds system architecture it is possible to plug a range of different data structures into the program to represent the ink in a variety of ways. A series of data structures have been implemented and were tested for efficiency. These structures were a simple list, a 3 D array, and an octree. They have been tested for: {{the time it takes to}} insert or remove points from the structure; how easy it is to manipulate points once they are stored; and also how the number of points stored effects the draw and rendering times. One of the key issues brought up by this project was devising a means by which a user is able to draw in three dimensions while using only two dimensional input devices. The method settled upon and implemented involves using the mouse or a digital pen to sketch as one would in a standard 2 D drawing package but also linking the up and down keyboard keys to the current depth. This allows the user to move in and out of the scene as they draw. A couple of user interface tools were also developed to assist the user. A 3 D cursor was implemented and also a toggle, which when on, highlights all of the points intersecting the depth plane on which the cursor currently resides. These tools allow the user to see exactly where they are drawing in relation to previously drawn lines. [...] Results [...] The tests conducted on the data structures clearly revealed that the octree was the most effective data structure. While not the most efficient in every area, it manages to avoid the major pitfalls of the other structures. The list was extremely quick to render and draw to the screen but suffered severely when it comes to finding and manipulating points already stored. In contrast the three dimensional array was able to erase or manipulate points effectively while the draw time rendered the structure effectively useless, taking huge amounts of time to draw each frame. The focus of this research was on how a 3 D sketching package would go about storing and accessing the digital ink. This is just a basis for further research in this area and many issues touched upon in this paper will require a more in depth analysis. The primary area of this future research would be the creation of an effective user interface and the introduction of regular sketching package features such as the saving and loading of images...|$|R
50|$|On 2 August 2007, Beta 1 was released. Major {{features}} {{included a}} <b>pixmap</b> cache - speeding up icon loading, KDE PIM improvements, improved KWin effects and configuration, better interaction between Konqueror and Dolphin and Metalink support added to KGet for improved downloads.|$|E
5000|$|The [...] "parental-relative" [...] method uses [...] {{to inherit}} the parent window's {{background}} image. Unfortunately, using this method, the X server permits very few operations {{to be performed}} on the background <b>pixmap</b> (such as XOR), preventing clients from implementing any sort of advanced image filtering.|$|E
50|$|Based on {{a feature}} {{extraction}} method, it reads images in portable <b>pixmap</b> formats known as Portable anymap and produces text in byte (8-bit) or UTF-8 formats. Also included is a layout analyser, able {{to separate the}} columns or blocks of text normally found on printed pages.|$|E
50|$|An entire BitMap (or <b>PixMap,</b> when {{referring}} to color images) may be copied from one GrafPort to another, with scaling and clipping. Known as blitting, or CopyBits, after {{the name of the}} function, this operation is the basis for most animation and sprite-like effects on the Mac.|$|E
5000|$|XCopyArea {{can achieve}} a more {{realistic}} transparency effect in that it can include obscured windows, but with the significant disadvantage {{that it is only}} usable with modal windows. This method simply uses the [...] function to take a partial screenshot for use as the window's background <b>pixmap.</b>|$|E
50|$|This pseudo-transparency, {{so called}} as the {{background}} <b>pixmap</b> {{of the root}} window is visible (analogous to desktop wallpaper) rather than any obscured windows, allows users to make windows look less imposing (such as Terminal emulators, which usually comprise large chunks of text), and to integrate the appearance of windows with their desktop themes.|$|E
50|$|After this, {{apart from}} {{back-end}} changes to optimize for new processor architectures (PowerPC), QuickDraw remained largely unchanged {{throughout the rest}} of the life of the classic Mac OS. QuickDraw GX and QuickDraw 3D shared the QuickDraw name and were able to interoperate with QuickDraw <b>PixMap</b> and picture data structures, but were otherwise completely separate in functionality.|$|E
50|$|PhotoModeler has {{the ability}} to read the {{following}} image formats: JPEG (.jpg), Tiff (.tif), Windows BMP (.bmp), PC Paintbrush (.pcx), Targa (.tga), Portable Network Graphics (.png), Pict (.pct), Photoshop (.psd), Portable <b>Pixmap</b> (.ppm), Macintosh Paint (.mac), EA Interchange File Format (.iff), CALS Raster (.cal), PhotoCD (.pcd), Silicon Graphics Image (.sgi), Silicon Graphics RGB (.rgb), Jpeg2000 (.jp2/.jpx), MS HDphoto (.hpd/.wdp).|$|E
5000|$|The image {{shown above}} using only 0 or the maximal {{value for the}} {{red-green-blue}} channels can be also encoded as:White space including line ends and comment lines is syntactically equivalent to a single space within the PNM headers. For the plain formats P1…P3 this also affects the <b>pixmap</b> lines; in fact lines {{should be limited to}} 70 characters: ...|$|E
5000|$|Due to the {{increasing}} popularity of compositing window managers like Compiz, the Direct Rendering Infrastructure had to be redesigned so that X clients could also support redirection to [...] "offscreen pixmaps" [...] while doing direct rendering. Regular X clients already respected the redirection to a separate <b>pixmap</b> provided by the X Server as a render target [...] - the so-called offscreen <b>pixmap</b> - , but DRI clients continued to do the rendering directly into the shared backbuffer, effectively bypassing the compositing window manager. The ultimate solution was {{to change the way}} DRI handled the render buffers, which led to a completely different DRI extension with a new set of operations, and also major changes in the Direct Rendering Manager. The new extension was named [...] "DRI2", although {{it should be noted that}} it's not a later version but a different extension not even compatible with the original DRI [...] - in fact both have coexisted within the X Server for a long time.|$|E
5000|$|Present {{provides}} {{two main}} operations to X clients: update {{a region of}} a window using part of or all {{the contents of a}} <b>pixmap</b> (...) and set the type of presentation events related to a certain window that the client wants to be notified about (...) [...] There are three presentation events about which a window can notify an X client: when an ongoing presentation operation [...] - normally from a call to [...] - [...] has been completed (...) , when a <b>pixmap</b> used by a [...] operation is ready to be reused (...) and when the window configuration [...] - mostly window size - [...] changes (...) [...] Whether a [...] operation performs a direct copy (blit) onto the front buffer or a swap of the entire back buffer with the front buffer is an internal detail of the Present extension implementation, instead of an explicit choice of the X client as it was in DRI2.|$|E
50|$|A Netpbm {{format is}} any {{graphics}} format used and {{defined by the}} Netpbm project.The portable <b>pixmap</b> format (PPM), the portable graymap format (PGM) and the portable bitmap format (PBM) are image file formats designed to be easily exchanged between platforms. They are also sometimes referred to collectively as the portable anymap format (PNM), {{not to be confused}} with the related portable arbitrary map format.|$|E
