364|66|Public
5000|$|Specifically in Floyd-Hoare logic, the <b>partial</b> <b>correctness</b> of a {{while loop}} {{is governed by}} the {{following}} rule of inference: ...|$|E
50|$|It {{seems that}} naming this {{property}} non-aborting {{would be more}} appropriate: in total correctness, non-termination is abortion, whereas in <b>partial</b> <b>correctness,</b> it is not.|$|E
50|$|If {{the above}} {{ordinary}} while rule {{is replaced by}} the following one, the Hoare calculus {{can also be used}} to prove total correctness, i.e. termination as well as <b>partial</b> <b>correctness.</b> Commonly, square brackets are used here instead of curly braces to indicate the different notion of program correctness.|$|E
40|$|These therories {{describe}} Hoare logics for {{a number}} of imperative language constructs, from while-loops to mutually recursive procedures. Both <b>partial</b> and total <b>correctness</b> are treated. In particular a proof system for total correctness of recursive procedures in the presence of unbounded nondeterminism is presented...|$|R
40|$|A {{survey of}} various results {{concerning}} Hoare's approach to proving <b>partial</b> and total <b>correctness</b> of programs is presented. Emphasis {{is placed on}} the soundness and completeness issues. Various proof systems for while programs, recursive procedures, local variable declarations, and procedures with parameters, together with the corresponding soundness, completeness, and incompleteness results, are discussed...|$|R
40|$|General <b>correctness,</b> which subsumes <b>partial</b> {{and total}} <b>correctness,</b> is defined for both weakest {{preconditions}} and strongest postconditions. Healthiness properties for general-correctness predicate transformers are more uniform and complete {{than those for}} partial-and-total-correctness systems. In fact, the healthiness properties for <b>partial</b> and total <b>correctness</b> are simple restrictions of those for general correctness. General correctness allows simple formulations of the connections between weakest and strongest postconditions and between the notions of weakest precondition under the "demonic" and "angelic" interpretations of nondeterminism. A problem that plagues $sp - sp(P, C) $ is undefined if execution of $C$ begun in some state of $P$ may not terminate - disappears with the generalization. This paper is a study of some simple theory underlying predicate transformer semantics, and as yet has little bearing on current programming practices. The theory uses a relational model of programs...|$|R
50|$|Because of the {{similarity}} of loops and recursive programs, proving <b>partial</b> <b>correctness</b> of loops with invariants {{is very similar to}} proving correctness of recursive programs via induction. In fact, the loop invariant is often the same as the inductive hypothesis to be proved for a recursive program equivalent to a given loop.|$|E
50|$|A {{distinction}} is made between total correctness, which additionally {{requires that the}} algorithm terminates, and <b>partial</b> <b>correctness,</b> which simply requires that if an answer is returned it will be correct. Since there is no general solution to the halting problem, a total correctness assertion may lie much deeper. A termination proof {{is a type of}} mathematical proof that plays a critical role in formal verification because total correctness of an algorithm depends on termination.|$|E
50|$|In {{order to}} {{formally}} state {{the rule of}} inference for the termination of a while loop we have demonstrated above, recall that in Floyd-Hoare logic, the rule for expressing the <b>partial</b> <b>correctness</b> of a while loop is:where I is the invariant, C is the condition, and S is {{the body of the}} loop. To express total correctness, we write instead:where, in addition, V is the variant, and by convention the unbound symbol z is taken to be universally quantified.|$|E
40|$|Abstract. We {{discuss a}} proof-producing {{compiler}} for {{a subset of}} higher order logic. The translation validation is automatic, {{and is based on}} Hoare rules derived from a compositional semantics for sequences of instructions for an ARM-like machine. <b>Partial</b> and total <b>correctness</b> are dealt with. The main focus is on issues in the intermediate level and back-end of the compiler. ...|$|R
40|$|AbstractTwo {{definitions}} {{of a language}} of communicating programs are offered: one by denotational semantics, and one by predicative specifications. The equivalence of both definitions is established. Both <b>partial</b> and total <b>correctness</b> semantics are considered. Nondeterminism and its interaction with recursion is studied. The main contribution is a comparative study of the descriptive and the prescriptive viewpoint of program semantics...|$|R
40|$|This paper {{sketches}} {{a rigorous}} correctness {{proof of a}} compiler executable. We will emphasize {{the central role of}} <b>partial</b> program <b>correctness</b> and its preservation, which captures the intuitive correctness requirements for transformational programs and in particular for compilers on real machines. Although often left out of sight, implementation verification is definitely necessary, not only but also for compilers. We will show that a rigorous compiler correctness proof also for the final binary compiler machine program is possible and feasible. Verified compiler implementations guarantee correctness properties for generated executable program implementations; we need them, not only in safety critical systems, but also for security in e. g. network computing...|$|R
5000|$|Using {{standard}} Hoare logic, only <b>partial</b> <b>correctness</b> can be proven, while termination {{needs to}} be proved separately. Thus the intuitive reading of a Hoare triple is: Whenever P holds of the state before the execution of C, then Q will hold afterwards, or C does not terminate. In the latter case, there is no [...] "after", so Q can be any statement at all. Indeed, one can choose Q to be false to express that C does not terminate.|$|E
5000|$|Concurrent with Pnueli's work on LTL, {{academics}} {{were working}} to generalize Hoare logic for verification of multiprocess programs. Leslie Lamport {{became interested in}} the problem after peer review found an error in a paper he submitted on mutual exclusion. Ed Ashcroft introduced invariance in his 1975 paper [...] "Proving Assertions About Parallel Programs", which Lamport used to generalize Floyd's method in his 1977 paper [...] "Proving Correctness of Multiprocess Programs". Lamport's paper also introduced safety and liveness as generalizations of <b>partial</b> <b>correctness</b> and termination, respectively. This method was used to verify the first concurrent garbage collection algorithm in a 1978 paper with Edsger Dijkstra.|$|E
40|$|This paper {{presents}} an axiomatic technique for proving {{a number of}} properties of parallel programs. Hoare has given a set of axioms for <b>partial</b> <b>correctness</b> of parallel programs, {{but they are not}} strong enough in most cases. Here we define a deductive system which is in some sense complete for <b>partial</b> <b>correctness.</b> The information in a <b>partial</b> <b>correctness</b> proof is then used to prove such properties as mutual exclusion, blocking and termination...|$|E
40|$|This paper {{describes}} Hoare logics for {{a number}} of imperative language constructs, from while-loops via exceptions to mutually recursive procedures. Both <b>partial</b> and total <b>correctness</b> are treated. In particular a proof system for total correctness of recursive procedures in the presence of unbounded nondeterminism is presented. All systems are formalized and shown to be sound and complete in the theorem prover Isabelle/HOL...|$|R
40|$|We {{report on}} a new {{environment}} developed and implemented inside the Nuprl type theory that facilitates proving theorems about partial functions. It is the first such automated type-theoretic account of partiality. We demonstrate that such an environment can be used effectively for proving theorems about computability and for developing <b>partial</b> programs with <b>correctness</b> proofs. This extends the well-known proofs as programs paradigm to partial functions...|$|R
40|$|Relational {{theories}} of refinement using simulations exist based on total and on partial relations, modelling <b>partial</b> and total <b>correctness.</b> In order to model partialities such as non-termination and deadlock, domains of relations are often extended with, or assumed to include, a ``bottom'' value bot. This paper explores {{a number of}} such theories, all providing sound and jointly complete notions of simulations, concentrating {{on the role of}} bot...|$|R
40|$|A <b>partial</b> <b>correctness</b> {{specification}} is {{a triple}} {P} Γ {Q} {{consisting of two}} predicates, namely P and Q, and a command Γ. A Hoare logic is a formal system for establishing various relations between such triples. In this paper it is shown how a <b>partial</b> <b>correctness</b> specification containing a dummy command {{can be derived from}} a Z schema. The now well-understood ways of developing a command from such a <b>partial</b> <b>correctness</b> specification can then be used to implement the original Z schema. This approach is better than its rivals because it uses well-known tried-and-tested methods...|$|E
40|$|This paper {{provides}} the method and complete proof for programs written in Pascal programming language with decided specifications for programs which reverse the digits of an integer from [5]. The {{author of this}} paper describes a new concept of <b>partial</b> <b>correctness</b> of programs better suited to specification purposes than the classical one. <b>Partial</b> <b>correctness</b> specifications are pairs of assertions, preconditions and postconditions. As an application of <b>partial</b> <b>correctness</b> specifications, the paper presents the correctness method {{for some of the}} programs which have been written in procedural programming language. Moreover, this method is suitable for all procedural programs...|$|E
3000|$|Safety {{assurance}} that the composition is deadlock free and is checked against <b>partial</b> <b>correctness</b> of transitions [...]...|$|E
40|$|We present {{lessons learned}} from using {{mechanical}} theorem proving for proof support in software verification, with trusted execution of programs in mind. We will use two realistic running examples, compiler verification, which is central {{if we want to}} prove that we can trust a piece of executable software, and an industrial project in which we proved the correctness of a safety critical expert system using (verified) runtime result verification. We will emphasize the role of <b>partial</b> program <b>correctness</b> and its preservation. And we will comment on high level control aspects, in particular on what we can and what {{we will not be able}} to prove for a concrete piece of executable software. ...|$|R
40|$|Abstract. We {{show that}} using {{deductive}} systems to specify an offline partial evaluator {{allows one to}} specify, prototype, and mechanically verify correctness via meta-programming — all within a single framework. For a λ-mix-style partial evaluator, we specify binding-time constraints using a natural-deduction logic, and the associated program specializer using natural (aka “deductive”) semantics. These deductive systems can be directly encoded in the Elf programming language — a logic program-ming language based on the LF logical framework. The specifications are then executable as logic programs. This provides a prototype implemen-tation of the partial evaluator. Moreover, since deductive system proofs are accessible as objects in Elf, {{many aspects of the}} <b>partial</b> evaluator <b>correctness</b> proofs (e. g., the cor-rectness of binding-time analysis) can be coded in Elf and mechanically checked. ...|$|R
40|$|This paper {{presents}} {{sound and}} complete Hoare logics for <b>partial</b> and total <b>correctness</b> of recursive parameterless {{procedures in the}} context of unbounded nondeterminism. For total correctness, the literature so far has either restricted recursive procedures to be deterministic or has studied unbounded nondeterminism only in conjunction with loops rather than procedures. We consider both single procedures and systems of mutually recursive procedures. All proofs have been checked with the theorem prover Isabelle/HOL...|$|R
30|$|If a {{resource}} executing a task fails, then the task becomes again {{ready to be}} executed (<b>Partial</b> <b>correctness).</b>|$|E
40|$|We {{formulate}} a noncommutative sequent calculus for <b>partial</b> <b>correctness</b> that subsumes propositional Hoare Logic. <b>Partial</b> <b>correctness</b> assertions {{are represented by}} intuitionistic linear implication. We prove soundness and completeness over relational and trace models. As a corollary we obtain a complete sequent calculus for inclusion and equivalence of regular expressions. Categories and Subject Descriptors: D. 2. 2 [Software Engineering]: Tools and Techniques— structured programming; D. 2. 4 [Software Engineering]: Program Verification—correctnes...|$|E
40|$|We report work in {{progress}} concerning the theoretical basis and the implementation in the Theorema system of a methodology for the generation of verification conditions for recursive procedures, {{with the aim of}} practical verification of recursive programs. Proving total correctness is achieved by proving separately <b>partial</b> <b>correctness</b> and then termination. We develop a pattern for proving <b>partial</b> <b>correctness</b> properties of programs which have simple functional recursive definitions, and we discuss how this can be extended to recursive programs having multiple recursive calls. The method for proving <b>partial</b> <b>correctness</b> is based on Scott Induction, from which we extract the essential features. Furthermore we develop a pattern for proving termination of simple recursive functional programs, uder the assumption that total correctness of all the auxiliary functions used in the program definition is provided. Combining the verification conditions from the two parts (<b>partial</b> <b>correctness</b> and termination) we construct verification conditions for proving total correctness. While proving [partial] correctness of non-recursive procedural programs is quite well understood, for instance by using Hoare Logic [3], [5], there are relatively few approaches to recursive procedures (see e. g. [7...|$|E
40|$|Abstract. We {{present a}} general {{framework}} for defining denotational notion of state. We show how this framework {{can be used}} to establish natural relationships between traditional models of concurrency and more recent models based on separation principles. We formulate an intuitively reasonable characterization of when one model of state implements another, and we show that semantics based on related notions of state induce the same notions of <b>partial</b> and total <b>correctness</b> behavior. ...|$|R
40|$|We {{show that}} using {{deductive}} systems to specify an offline partial evaluator allows its correctness to be mechanically verified. For a -mix-style partial evaluator, we specify binding-time constraints using a natural-deduction logic, {{and the associated}} program specializer using natural (aka "deductive") semantics. These deductive systems can be directly encoded in the Elf programming language [...] - a logic programming language based on the LF logical framework. The specifications are then executable as logic programs. This provides a prototype implementation of the partial evaluator. Moreover, since deductive system proofs are accessible as objects in Elf, {{many aspects of the}} <b>partial</b> evaluation <b>correctness</b> proofs (e. g., the correctness of binding-time analysis) can be coded in Elf and mechanically verified. This work illustrates the utility of declarative programming and of using deductive systems for defining program specialization systems: by exploiting the logical character of definit [...] ...|$|R
40|$|Hoare {{logic is}} a {{foundation}} of axiomatic semantics of classical programs and it provides effective proof techniques for reasoning about correctness of classical programs. To offer similar techniques for quantum program verification and to build a logical foundation of programming methodology for quantum computers, we develop a full-fledged Hoare logic for both <b>partial</b> and total <b>correctness</b> of quantum programs. It is proved that this logic is (relatively) complete by exploiting the power of weakest preconditions and weakest liberal preconditions for quantum programs. Comment: 50 page...|$|R
40|$|Denoting {{a version}} of Hoare's system for proving <b>partial</b> <b>correctness</b> of {{recursive}} programs by H, Ns present an extension JD Nhich may {{be thought of as}} H u {^,v,],Y} u H- 1, including the rules H, four special purpose rules and inverse rules to those of Hoare. D is shown to be a complete system (in Cook's sense) for proving deductions of the form e 1, [...] r n ~ # over a language, the wff*n of which are assertions in some assertion language L and <b>partial</b> <b>correctness</b> specifications of the form p{=lq. All valid formulae of L are taken as axioms of D. It is shown that D is sufficient for proving <b>partial</b> <b>correctness,</b> total correctness and program equivalence as Nell as other Important properties of programs, the proofs of which ar...|$|E
40|$|This report {{introduces}} {{a new concept}} of <b>partial</b> <b>correctness</b> of programs better suited to specification purposes than the classical one. For motivations and for an account of existing variants of Hoare's logic the reader is referred to [3]. We allow a special assertion-valued place holder, denoted by Φ, to occur inside assertions. <b>Partial</b> <b>correctness</b> specifications, i. e. pairs of assertions, are understood to be universally quantified over that place holder. Thus, factorial may be specified b...|$|E
40|$|In earlier work, we {{presented}} an abstraction-refinement mechanism that {{was successful in}} verifying automatically the <b>partial</b> <b>correctness</b> of in-situ list reversal when applied to an acyclic linked list [10]. This paper reports on the automatic verification of the total correctness (<b>partial</b> <b>correctness</b> and termination) of the same list-reversal algorithm, when applied to a possibly-cyclic linked list. A key contribution that made this result possible {{is an extension of}} the finite-differencing technique [14] to enable the maintenance of reachability information for a restricted class of possibly-cyclic data structures, which includes possiblycyclic linked lists...|$|E
40|$|AbstractA {{survey of}} various results {{concerning}} {{the use of}} Hoare's logic in proving correctness of nondeterministic programs is presented. Various proof systems together with the example proofs are given and the corresponding soundness and completeness proofs of the systems are discussed. Programs allowing bounded and countable nondeterminism are studied. Proof systems deal with <b>partial</b> and total <b>correctness,</b> freedom of failure {{and the issue of}} fairness. The paper is a continuation of Part I by Apt (1981), where various results concerning Hoare's approach to proving correctness of sequential programs are presented...|$|R
40|$|Abstract. The {{classical}} {{concepts of}} <b>partial</b> and total <b>correctness</b> identify {{all types of}} runtime errors and divergence. We argue that the associated notions of translation correctness cannot cope adequately with practical questions like optimizations and finiteness of machines. As a step towards a solution we propose more fine-grained correctness notions, which are parameterized in sets of acceptable failure outcomes, and study a corresponding family of predicate transformers that generalize the well-known wp and wlp transformers. We also discuss {{the utility of the}} resulting setup for answering compiler correctness questions...|$|R
40|$|This paper {{introduces}} a new higher-order typed constructive predicate logic for fixpoint computations, which exploits the categorical semantics of computations introduced by Moggi [8] and contains a strong version of Martin-Löf’s ‘iteration type’ [ll]. The type system enforces {{a separation of}} computations from values. The logic contains a novel form of fixpoint induction and can express <b>partial</b> and total <b>correctness</b> statements about evaluation of computations to values. The constructive nature of the logic is witnessed by strong metalogical properties which are proved using a category-theoretic version of the ‘logical relations’ method...|$|R
