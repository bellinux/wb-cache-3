17|335|Public
5000|$|The [...] "E" [...] (Error) bit - If set, {{the message}} {{contains}} a <b>protocol</b> <b>error,</b> {{and the message}} will not conform to the CCF described for this command. Messages with the [...] "E" [...] bit set are {{commonly referred to as}} error messages. This bit MUST NOT be set in request messages.|$|E
50|$|BIND also {{sets the}} LDAP {{protocol}} version {{by sending a}} version number {{in the form of}} an integer. If the client requests a version that the server does not support,the server must set the result code in the BIND response to the code for a <b>protocol</b> <b>error.</b> Normally clients should use LDAPv3, which is thedefault in the protocol but not always in LDAP libraries.|$|E
5000|$|... /** * Adds Cluster object. * @param cluster {@link org.ovirt.engine.sdk.entities.Cluster} * cluster.data_center.id|name * cluster.name * cluster.version.major * cluster.version.minor * cluster.cpu.id * cluster.description * cluster.memory_policy.overcommit.percent * cluster.memory_policy.transparent_hugepages.enabled * cluster.scheduling_policy.policy * cluster.scheduling_policy.thresholds.low * cluster.scheduling_policy.thresholds.high * cluster.scheduling_policy.thresholds.duration * cluster.error_handling.on_error * cluster.virt_service * cluster.gluster_service * cluster.threads_as_cores * cluster.tunnel_migration * @return * {@link Cluster } * @throws ClientProtocolException * Signals that HTTP/S <b>protocol</b> <b>error</b> has occurred. * @throws ServerException * Signals that an oVirt api error has occurred. * @throws IOException * Signals that an I/O {{exception}} {{of some sort}} has occurred. */ public Cluster add(org.ovirt.engine.sdk.entities.Cluster cluster) throws ClientProtocolException, ServerException, IOException { .... } /** * Adds Cluster object. * @param cluster {@link org.ovirt.engine.sdk.entities.Cluster} * cluster.data_center.id|name * cluster.name * cluster.version.major * cluster.version.minor * cluster.cpu.id * cluster.description * cluster.memory_policy.overcommit.percent * cluster.memory_policy.transparent_hugepages.enabled * cluster.scheduling_policy.policy * cluster.scheduling_policy.thresholds.low * cluster.scheduling_policy.thresholds.high * cluster.scheduling_policy.thresholds.duration * cluster.error_handling.on_error * cluster.virt_service * cluster.gluster_service * cluster.threads_as_cores * cluster.tunnel_migration * @param expect * 201-created * @param correlationId * string * @return * {@link Cluster } * @throws ClientProtocolException * Signals that HTTP/S <b>protocol</b> <b>error</b> has occurred. * @throws ServerException * Signals that an oVirt api error has occurred. * @throws IOException * Signals that an I/O {{exception of}} some sort has occurred. */ public Cluster add(org.ovirt.engine.sdk.entities.Cluster cluster, String expect, String correlationId) throws ClientProtocolException, ServerException, IOException { .... } ...|$|E
50|$|On <b>protocol</b> <b>errors,</b> a {{receiving}} module discards {{the piece}} {{it has received}} and reports back the error condition to the original source of the piece on the same layer by handing the error message down or in case of the bottom module sending it across.|$|R
5000|$|... cURL {{can connect}} {{to a remote}} server via HTTPS <b>protocol</b> (return <b>error</b> message if a CA {{certificate}} file cannot be located) curl ...|$|R
40|$|Aiming at a sound formal {{basis for}} the design and {{implementation}} of robust programming languages for sensor networks, we present a process calculus that captures their main characteristics in terms of computational resources and communication abilities. The calculus, which has straightforward semantics and is rather expressive, features a static type system that allows premature detection of application <b>protocol</b> <b>errors.</b> Our main results include subject reduction and type safety proofs, {{as well as an}} initial implementation of a modular interpreter...|$|R
50|$|The frame check {{sequence}} (FCS) field is used for determining whether an individual frame has an error. It contains a checksum computed over the frame to provide basic protection against errors in transmission. This is a CRC code {{similar to the one}} used for other layer two <b>protocol</b> <b>error</b> protection schemes such as the one used in Ethernet. According to RFC 1662, it can be either 16 bits (2 bytes) or 32 bits (4 bytes) in size (default is 16 bits - Polynomial x16 + x12 + x5 + 1).|$|E
40|$|Abstract — We {{present a}} novel {{technique}} for accurately estimating {{the proportions of}} packet losses arising from collisions and from other sources of loss (channel noise, hidden nodes etc). Our approach is robust, makes use of local station-level measurements and requires no message passing. The required measurements are available in standard hardware as they are required for CSMA/CA operation. No channel quality probing is required which ensures energy efficiency. Index Terms — IEEE 802. 11, WLAN, MAC, <b>protocol,</b> <b>error</b> rate, hidden node...|$|E
40|$|Extensible Authentication Protocol(EAP) is {{a widely}} used {{security}} protocol for Wireless networks around the world. The project examines different security issues with the EAP based protocols, the family of security protocols for Wireless LAN. The project discovers {{an attack on the}} subscriber identity module(SIM) based extension of EAP. The attack is a Denial-of-Service attack that exploits the error handling mechanism in EAP protocols. The project further proposes countermeasures for detection and a defense against the discovered attack. The discovered attack can be prevented by changing the protocol to delay the processing of <b>protocol</b> <b>error</b> messages...|$|E
5000|$|These are {{available}} in Code Division Multiple Access(CDMA), Digital Enhanced Cordless Telecommunications - DECT (TDMA/DCA) ( [...] See ETSI 6 EN 300 765-1 V1.3.1 (2001-04) -"Digital Enhanced Cordless Telecommunications (DECT); Radio in the Local Loop (RLL) Access Profile (RAP); Part 1: Basic telephony services"), Global System for Mobile Communications(GSM), IS136 Time Division Multiple Access (TDMA) as well as analog access technologies such as Advanced Mobile Phone System(AMPS), for which there will be independent standards defining every aspect of modulation, <b>protocols,</b> <b>error</b> handling, etc.|$|R
40|$|Within the {{simultaneous}} message passing model of communication complexity, under a public-coin assumption, we derive the minimum achievable worst-case error {{probability of a}} classical fingerprinting <b>protocol</b> with one-sided <b>error.</b> We then present entanglement-assisted quantum fingerprinting <b>protocols</b> attaining worst-case <b>error</b> probabilities that breach this bound. Comment: 10 pages, 1 figur...|$|R
40|$|In {{this paper}} I {{report on the}} {{preliminary}} results of a longitudinal one-year study of students’ progression from {{a low level of}} language awareness manifested in their superficial/intuitive use of language/languages to a higher level of language self-awareness manifested in their more con- trolled use of language. The data gathered for this study include four sources: a language aware- ness questionnaire, think aloud <b>protocols,</b> <b>error</b> analysis and post error analysis in-class discussions. The results of this study are intended to be further explored in a larger research project...|$|R
30|$|Recently, Adda et al. [5] build a {{real-time}} {{fault detection}} and classification model using k-Means, Fuzzy C Means (FCM), and EM. They leverage SNMP {{to collect information}} from the routers, switches, hubs, printers and servers in an IP network of a college campus. The authors select 12 features that exhibit sensitivity to the behavior of network traffic [370], and use the traffic patterns to form clusters that represent normal traffic, link failure, server crash, broadcast storm and <b>protocol</b> <b>error.</b> Their evaluation results reveal that though k-Means and EM are relatively faster than FCM, FCM is more accurate.|$|E
40|$|Among private set operations, {{the privacy}} {{preserving}} element reduction of a multiset {{can be an}} important tool for privacy enhancing technology as itself or in the combination with other private set operations. Recently, a protocol, over-threshold-set-union-protocol, for a privacy preserving element reduction method of a multiset was proposed by Kissner and Song in Crypto 2005. In this paper, we point out that there is a mathematical flaw in their polynomial representation of element reduction of a multiset and the resulting <b>protocol</b> <b>error</b> from the flaw in the polynomial representation of a multiset. We correct their polynomial representation of a multiset and propose an over-threshold-set-operation-protocol based on the corrected representation...|$|E
40|$|Abstract: Error control {{techniques}} are very hot research topics in mobile adhoc networks. This paper deals with Performance of ARQ (Automatic Repeat reQuest) mechanism in mobile adhoc network using WEAC (Warning Energy Awareness Clusterhead) <b>Protocol.</b> <b>Error</b> control {{techniques are}} {{very popular in}} all types of networks. In Wireless network many types of Error control techniques are used. Automatic Repeat reQuest {{is one of the}} major error control techniques in wireless network. In this technique the erroneous packet will be retransmitted. Hence Loss of data is eliminated and it provides opportunity for reliable data delivery. This paper analyzes the famous three ARQ protocols and their performance in many circumstances and the advantages of various types in ARQ. The results of this paper shows that the amount of loss of data is eliminated using ARQ and it leads reliable data communication over noisy channels...|$|E
40|$|Dating manuscripts is a {{difficult}} task – particularly when these are not expressly datemarked, but even when they are. Factors such as the existence of successive copies that continue and repeat established models and production methods make dating a challenging task. The present work forms {{part of a much}} broader, comprehensive, investigation on the material composition of dated and bound manuscripts from the School of arabic Studies– CSIC of Granada. By means of a study <b>protocol,</b> <b>errors</b> in the dating of manuscripts ms 6, ms 10, ms 26 and ms 29 are successfully detected and corrected, and alternative dating proposed...|$|R
40|$|Performance {{prediction}} of DAB modulation and transmission using Matlab modeling Abstract — A Simulink-Matlab simulation model is described that enables an accurate performance {{prediction of}} complete DAB (digital audio broadcasting) transmission channels. Embedded compiled C-code subroutines include modulation <b>protocols,</b> <b>error</b> correction and MPEG layer- 2 perceptual audio coding. Rapid assessment of critical design related factors could be performed that include channel interference, multi-path reflection {{and a range}} of modulation-parameters. Software is PC compatible with both DAB system and transmission channel configurable using a bespoke graphical user interface, which facilitates changing on the fly modulation and transmission-path related parameters. Overall audio quality can also be assessed 1...|$|R
40|$|Abstract: Before trusting a {{communications}} security protocol with potentially critical or sensitive information, {{it is necessary}} to have some degree of assurance that the protocol fulfils its intended objectives. To provide this assurance {{it is necessary to}} use formal verification techniques, as intuitive reasoning does not satisfactorily guarantee complete freedom from <b>protocol</b> <b>errors.</b> In this paper, a number of recently published formal techniques for verifying cryptographic protocols, are described. The techniques are categorised as being based on algebraic modelling, or based on some form of testing. A comparative overview of the verification techniques available is presented, indicating their benefits, limitations and scope of application. 1...|$|R
40|$|Partial search methods like bitstate hashing, or supertrace, allow formal {{verification}} techniques {{to be applied}} to problems which normally could not be solved by exhaustive verification. A high coverage (defined as the percentage of the reachable states actually explored by the verifier) is important since the higher the coverage the lower the probability that a <b>protocol</b> <b>error</b> is not detected. In literature sequential hashing is proposed to improve the coverage of supertrace (i. e. start repeatedly supertrace by using different hash functions). Since supertrace is included in many commercial and noncommercial verification tools, {{it is important to know}} where its limitations are and where there is potential for possible improvements. We present both theoretical and experimental results to measure the quality of multiple hashing with supertrace. Tests made with the SPIN validator with different classes of hash functions show that the additional number of states reached in successive run [...] ...|$|E
40|$|Introduction There {{has been}} {{considerable}} research on formal analysis of security protocols, ranging from BAN logic and related approaches [BAN 89, GNY 90, Sv 94] to nite-state analysis [Ros 95, MMS 97] and proof methods based on higherorder logic [Pau 97]. However, {{there appears to}} have been little work on the problem of deriving useful protocols from abstract specications by composing standard building blocks. More specically, those familiar with protocol design and analysis will understand that there are several common mechanisms for guaranteeing freshness, avoiding replay attacks, committing to an action without completing the action, and so on. Often, when a <b>protocol</b> <b>error</b> is discovered, the repair involves a change that is familiar from other protocols. Based on these observations, we believe that it will be useful to develop methods for deriving useful protocols by suitably composing simpler parts. While we began our eort by attaching logical formulas to steps in protoco...|$|E
40|$|In {{the absence}} of {{location}} errors, geographic routing - {{using a combination of}} greedy forwarding and face routing - has been shown to work correctly and efficiently. The effects of location errors on geographic routing have not been studied before. In this work we provide a detailed analysis of the effects of location errors on the correctness and performance of geographic routing in static sensor networks. First, we perform a micro-level behavioral analysis to identify the possible <b>protocol</b> <b>error</b> scenarios and their conditions and bounds. Then, we present results from an extensive simulation study of GPSR and GHT to quantify the performance degradation due to location errors. Our results show that even small location errors (of 10 % of the radio range or less) can in fact lead to incorrect (non-recoverable) geographic routing with noticeable performance degradation. We then introduce a simple modification for face routing that eliminates probable errors and leads to near perfect performance...|$|E
5000|$|RFC 5711 - Node Behavior upon Originating and Receiving Resource Reservation <b>Protocol</b> (RSVP) Path <b>Error</b> Messages ...|$|R
40|$|This paper {{presents}} {{a case study}} of integration of compression techniques within a satellite image communication component of an actual tactical weather information dissemination system. The paper describes history and requirements of the project, and discusses the information flow, request/reply <b>protocols,</b> <b>error</b> handling, and, especially, system integration issues: specification of compression parameters and the place and time for compressor/decompressor plug-ins. A case for a non-uniform compression of satellite imagery is presented, and its implementation in the current system id demonstrated. The paper gives special attention to challenges of moving the system towards the use of standard, non-proprietary protocols (smtp and [URL] and new technologies (OpenDoc), and reports the ongoing work in this direction...|$|R
50|$|Note {{that it is}} also {{possible}} to define a randomized <b>protocol</b> with one-sided <b>error,</b> and the complexity is defined similarly.|$|R
40|$|This paper {{describes}} RapidIO, a {{high performance}} low pin count packet switched system level interconnect architecture. The interconnect architecture {{is intended to}} be an open standard which addresses the needs of a variety of applications from embedded infrastructure to desktop computing. Applications include interconnecting microprocessors, memory, and memory mapped I/O devices in networking equipment, storage subsystems, and general purpose computing platforms. This interconnect is intended primarily as an intra-system interface, allowing chip to chip and board to board communications at giga-byte per second performance levels. Supported programming models include globally shared distributed memory and message-passing. In its simplest form, the interface can be implemented in an FPGA end point. The interconnect architecture deÞnes a protocol independent of a physical implementation. The physical features of an implementation utilizing the interconnect are deÞned by the requirements of the implementation, such as I/O signalling levels, interconnect topology, physical layer <b>protocol,</b> <b>error</b> detection, etc. The interconnect is deÞned as a layered architecture which allows scalability and future enhancements while maintaining compatibility. ...|$|E
40|$|Abstract. We {{consider}} the formal verification of the cache coherence protocol of the Stanford FLASH multiprocessor for N processors. The proof uses the SMV proof assistant, a proof {{system based on}} symbolic model checking. The proof process is described step by step. The protocol model is derived from an earlier proof of the FLASH protocol, using the PVS system, allowing a direct comparison between the two methods. 1 Introduction The verification of cache coherence protocols was perhaps the earliest commercial application of model checking [MS 91]. Later, more efficient model checking methods were developed for this application [CD 93], and compositional methods were applied {{to show that a}} verified protocol was implemented correctly in hardware [Eir 98]. However, these techniques were unsound, {{in the sense that they}} could be applied only to fixed number N of nodes in the network, whereas in fact N had no useful upper bound. This left open the possibility that a <b>protocol</b> <b>error</b> was missed, which only manifested itself for N greater than the size verifiable by model checking...|$|E
40|$|Geographic {{protocols}} {{are very}} promising for wireless ad hoc and sensor networks {{due to the}} low state storage and low message overhead. Under certain idealized conditions, geographic routing-using a combination of greedy forwarding and face routing- {{has been shown to}} work correctly and efficiently. In this work we model and analyze the correctness of geographic routing under non-ideal realistic conditions. We present a methodology for micro-level behavioral analysis that shows that conditions that violate the unit-graph assumption of network connectivity, such as location errors, obstacles and radio irregularity, cause failure in planarization and consequently face routing. We then discuss the limitations of fixing these failures and prove that local algorithms that use only information up to a limited number of hops are not sufficient to guarantee face routing delivery under arbitrary connectivity. In addition, we analyze the effect of location errors in more detail to identify the possible <b>protocol</b> <b>error</b> scenarios and their conditions and bounds. We present results from an extensive simulation study about the effects of location errors on GPSR and GHT to quantify their performance degradation at different error ranges, distributions and error models. Based on our analysis we present a potential fix based on local information sharing that improves the performance significantly but does not remove all failures. Finally, we conclude that in order to avoid all failures under arbitrary connectivity, we need a non-local algorithm that can search or propagate information for an unlimited number of hops...|$|E
5000|$|Logical {{link control}} (LLC) layer - {{responsible}} for identifying and encapsulating network layer <b>protocols,</b> and controls <b>error</b> checking and frame synchronization.|$|R
50|$|Bathtub Plot - The {{bathtub curve}} can provide {{tremendous}} {{insight into the}} BER performance of a link under test. A bathtub curve is obtained by drawing a horizontal line across the waveform under test. The probability distribution function for signal transitions (zero crossings) from a high voltage to a low voltage or a low voltage to a high voltage is then computed. The bathtub curve is useful because it can provide a lot of insight into {{the behavior of a}} system. Apart from estimating BER, it also provides an indication for the amount of margin that is in the system. When coupled with protocol testing with the Jitterlyzer, a high margin enables engineers to quickly rule out the physical layer as a potential cause of certain <b>protocol</b> <b>errors.</b>|$|R
40|$|As {{a result}} of using Information Technology (IT) in {{different}} technological processes {{it is necessary to}} develop new application specific communication protocols. The number of application specific protocols is growing rapidly in different areas: medicine, communication, industry, power systems, computer networks, etc. <b>Protocol</b> <b>errors</b> discovered in the implementation phase are usually a consequence of inconsistent protocol design, which implies the necessity of methodology for error detection in an early design phase. This paper describes formal methods for distributed systems, especially SPIN/Promela tool for formal verification of logical consistency in distributed systems. A protocol used in power systems IEC 60870 - 5 - 101 has been verified as an example of formal verification of a distributed system. Formal specification, simulation and verification of logical consistency have been successfully done by using SPIN/Promela software...|$|R
40|$|The RapidIO ™ {{architecture}} {{was developed}} to address {{the need for a}} high-performance low pin count packet-switched system level interconnect to be used in a variety of applications as an open standard. The architecture is targeted toward networking, telecom, and high performance embedded applications. It is intended primarily as an intra-system interface, allowing chip-to-chip and board-toboard communications at Gigabyte per second performance levels. It provides a rich variety of features including high data bandwidth, low-latency capability and support for high-performance I/O devices, as well as providing globally shared memory, message passing, and software managed programming models. In its simplest form, the interface can be implemented in a FPGA end point. The interconnect defines a protocol independent of a physical implementation. The physical features of an implementation utilizing the interconnect are defined by the requirements of the implementation, such as I/O signaling levels, interconnect topology, physical layer <b>protocol,</b> <b>error</b> detection, and so forth. The architecture is intended and partitioned to allow adaptation to a multitude of applications. This ECMA Standard has been adopted by the General Assembly in February 2003. Overview of the standard This overview explains each of the three layers of the RapidIO architecture, their interrelationships, an the system and device interoperability: 1. Logical layer—The logical layer defines the overall protocol and packet formats, the types of transactions that can be carried out with RapidIO, how addressing is handled. The logical specifications are partitioned into two partitions...|$|E
40|$|Grapevine leafroll-associated virus type 3 (GLRaV- 3) is {{the major}} causative agent of grapevine leafroll disease. The disease has a major {{negative}} impact on grape production for wineries, and can cause up to 62. 8 % loss in production. Despite {{the negative impact of}} GLRaV- 3 on the grapevine industry worldwide, knowledge on the variability of the virus, which is essential for developing effective control measure of the virus in vineyards, is surprisingly scarce. To test this, six primers sets used in a one tube, one step polymerase chain reaction (PCR) protocol, together with ELISA were used to detect GLRaV- 3 virus in 135 plant samples collected from a single vineyard. As expected the more sensitive PCR detected more infected samples than ELISA. However, some samples yielded positive results with the ELISA, but negative results using PCR. This might suggest that strain variants exist. Amongst PCR results of the different primer sets, anomalous results occurred, as often a plant will yield an amplicon with one primer set, but not with another primer set. Using the entire set of 7 PCR results per sample, each plant was assigned a PCR ‘fingerprint’. This yielded 24 different fingerprints in the vineyard. Mapping the spatial distribution of given fingerprints supported the possibility that strain variants exist. However, sequencing areas incorporating the primer binding sites showed no nucleotide sequence differences, indicating that the anomalous PCR results were not due to variants, but rather to <b>protocol</b> <b>error.</b> The PCR protocol used initially was adapted to obtain more optimal detection of virus. Different extraction methods and PCR protocols were tested. It was found that using the two step RT-PCR and using a less dilute plant macerate in ELISA extraction buffer (1 : 5), yielded amplicon of the expected size from all known infected plant samples. The protocol was further optimized with regards the RT step and subsequent PCR. Since the modified protocol did detect all known infected plant samples it can be concluded that in the 135 plant samples tested no significant sequence variation in strains at the primer binding sites occurred and that the anomalous PCR results initially obtained were due to a sub-optimal extraction method. Dissertation (MSc (Microbiology)) [...] University of Pretoria, 2008. Microbiology and Plant Pathologyunrestricte...|$|E
40|$|The {{software}} interface between a UNIX/IDRIS {{system and the}} Dataway network at the Lucas Heights Research Laboratories is described. The interface gives complete control over the network {{without the need for}} a detailed knowledge of low-level <b>protocols</b> and <b>error</b> recovery mechanisms. Several examples of the use of the interface are given...|$|R
50|$|Despite these limitations, an {{extension}} to the AX.25 <b>protocol,</b> supporting forward <b>error</b> correction, {{has been created}} by the TAPR. This extension is called FX.25.|$|R
40|$|Abstract Whether or not {{parallel}} repetition {{lowers the}} error {{has been a}} fundamental question {{in the theory of}} protocols, with applications in many different areas. It is well known that parallel repetition reduces the error at an exponential rate in interactive proofs and Arthur-Merlin games. It seems to have been taken for granted that the same is true in arguments, or other proofs where the soundness only holds with respect to computationally bounded parties. We show {{that this is not the}} case. Surprisingly, parallel repetition can actually fail in this setting. We present four-round <b>protocols</b> whose <b>error</b> does not decrease under parallel repetition. This holds for any (polynomial) number of repetitions. These protocols exploit non-malleable encryption and can be based on any trapdoor permutation. On the other hand we show that for three-round <b>protocols</b> the <b>error</b> does go down exponentially fast...|$|R
40|$|This paper investigates a complexity-e#ective {{technique}} for verifying a highly distributed directory-based cache coherence protocol. We develop {{a novel approach}} called "witness strings" that combines both formal and informal verification methods to expose design errors within the cache coherence protocol and its Verilog implementation. In this approach a formal execution trace is extracted during model checking of the architectural model and re-encoded to provide the input stimulus for a logic simulation of the corresponding Verilog implementation. This approach brings confidence to system architects that the logic implementation of the coherence protocol conforms to the architectural model. The feasibility {{of this approach is}} demonstrated by using it to verify the cache coherence protocol of the Cray X 1. Using this approach we uncovered three architectural <b>protocol</b> <b>errors</b> and exposed several implementation errors by replaying the witness strings on the Verilog implementation...|$|R
