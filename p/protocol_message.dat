74|1576|Public
25|$|A message {{authentication}} code computed over the <b>Protocol</b> <b>message,</b> with additional key material included. Note that this field may be encrypted, or not included entirely, depending {{on the state of}} the connection.|$|E
5000|$|SOAP (<b>protocol)</b> <b>Message</b> Transmission Optimization Mechanism (MTOM) ...|$|E
50|$|Everyone {{can require}} <b>protocol</b> <b>message</b> extension. It {{is enough to}} propose your own RFC. It will be {{examined}} and disclosed if it respects OpenWebNet syntax.|$|E
50|$|NETCONF {{provides}} {{mechanisms to}} install, manipulate, and delete {{the configuration of}} network devices. Its operations are realized {{on top of a}} simple Remote Procedure Call (RPC) layer. The NETCONF protocol uses an Extensible Markup Language (XML) based data encoding for the configuration data as well as the <b>protocol</b> <b>messages.</b> The <b>protocol</b> <b>messages</b> are exchanged on top of a secure transport protocol.|$|R
25|$|The {{length of}} <b>Protocol</b> <b>message(s),</b> MAC and Padding, {{not to exceed}} 214 bytes (16 KiB).|$|R
30|$|At {{the same}} time, the {{proposed}} authentication algorithm is robust to random channel losses of <b>protocol</b> <b>messages.</b>|$|R
5000|$|A message {{authentication}} code computed over the <b>Protocol</b> <b>message,</b> with additional key material included. Note that this field may be encrypted, or not included entirely, depending {{on the state of}} the connection.|$|E
50|$|A SAML binding is {{a mapping}} of a SAML <b>protocol</b> <b>message</b> onto {{standard}} messaging formats and/or communications protocols. For example, the SAML SOAP binding specifies how a SAML message is encapsulated in a SOAP envelope, which itself {{is bound to}} an HTTP message.|$|E
50|$|A nested Type-Length-Value (TLV) {{format is}} used to encode all {{messages}} on the wire. Each message is composed {{of a set of}} packet headers and a <b>protocol</b> <b>message</b> that includes the name, the content (or payload), and information used to cryptographically validate the message - all contained in nested TLVs.|$|E
5000|$|Generic {{transport}} of NAS messages: Initiated by the UE or {{the network and}} used to transport <b>protocol</b> <b>messages</b> from other applications.|$|R
5000|$|The service {{grounding}} specifies {{the details}} that a client needs {{to interact with the}} service, as communication <b>protocols,</b> <b>message</b> formats, port numbers, etc.|$|R
50|$|EAP {{is not a}} wire protocol; {{instead it}} only defines <b>message</b> formats. Each <b>protocol</b> that uses EAP defines a way to {{encapsulate}} EAP <b>messages</b> within that <b>protocol's</b> <b>messages.</b>|$|R
50|$|A {{message is}} a P2PP <b>protocol</b> <b>message</b> that {{performs}} a certain function. It {{begins with a}} header followed by a sequence of type-length-value (TLV) objects. It can be either a request or a response. The response header contains a response code (see codes). They can not be combined in one message if an unreliable transport is used, due to limitations of UDP MTU.|$|E
3000|$|... is {{involved}} in the corresponding protocol session and it may respond to a <b>protocol</b> <b>message</b> or challenge. For an RFID system [...]...|$|E
40|$|Abstract—Extracting the <b>protocol</b> <b>message</b> format {{specifications}} {{of unknown}} applications from network traces {{is important for}} a variety of applications such as application protocol parsing, vulnerability discovery, and system integration. In this paper, we propose ProDecoder, a network trace based <b>protocol</b> <b>message</b> format inference system that exploits the semantics of protocol messages without the executable code of application protocols. ProDecoder is based on the key insight that the n-grams of protocol traces exhibit highly skewed frequency distribution that can be leveraged for accurate <b>protocol</b> <b>message</b> format inference. In ProDecoder, we first discover the latent relationship among n-grams by first grouping protocol messages with the same semantics and then inferring message formats by keyword based clustering and cluster sequence alignment. We implemented and evaluated ProDecoder to infer message format specifications of SMB (a binary protocol) and SMTP (a textual protocol). Our experimental results show that ProDecoder accurately parses and infers SMB protocol with 100 % precision and recall. For SMTP, ProDecoder achieves approximately 95 % precision and recall...|$|E
5000|$|Streaming Text Oriented <b>Messaging</b> <b>Protocol</b> (STOMP) - simple, text-oriented <b>message</b> <b>protocol</b> ...|$|R
2500|$|... {{requires}} no communication overhead since it only uses already needed, unmodified atomic commitment <b>protocol</b> <b>messages</b> (any such protocol; using fault tolerant atomic commitment protocols and database systems makes the CO solution fault tolerant).|$|R
5000|$|All AppleMIDI <b>protocol</b> <b>messages</b> use {{a common}} {{structure}} of 4 words of 32 bits, with a header containing two bytes with value 255, {{followed by two}} bytes describing {{the meaning of the}} message: ...|$|R
40|$|Domain Name System (DNS) IANA Considerations This {{document}} specifies Internet Assigned Numbers Authority (IANA) parameter assignment {{considerations for}} {{the allocation of}} Domain Name System (DNS) resource record types, CLASSes, operation codes, error codes, DNS <b>protocol</b> <b>message</b> header bits, and AFSDB resource recor...|$|E
40|$|International Telemetering Conference Proceedings / October 27 - 30, 1997 / Riviera Hotel and Convention Center, Las Vegas, NevadaCAPS 2. 0 {{provides}} a flexible, PC-based tool for meeting evolving data reduction and analysis requirements while supporting standardization of instrumentation data processing. CAPS 2. 0 will accept {{a variety of}} data types including raw instrumentation, binary, ASCII, and Internet <b>protocol</b> <b>message</b> data and will output Engineering Unit data to files, static or dynamic plots, and Internet <b>protocol</b> <b>message</b> exchange. Additionally, CAPS 2. 0 will input and output data {{in accordance with the}} Digital Data Standard. CAPS 2. 0 will accept multiple input sources of PCM, MIL-STD- 1553, or DDS data to create an output for every Output Product Description and Dictionary grouping specified for a particular Session. All of this functionality is performed on a PC {{within the framework of the}} Microsoft Windows 95 /NT graphical user interface...|$|E
30|$|First, the {{publication}} process {{is carried out}} {{by means of a}} web service that uses a SOAP (Simple Object Access <b>Protocol)</b> <b>message</b> to put in a register server such as UDDI (Universal Description Discovery and Integration - directory of web service interfaces described by WSDL - Web Services Description Language) services that will be published, such as user authentication service, build O/D matrix service, and consult O/D matrix service.|$|E
5000|$|... {{requires}} no communication overhead since it only uses already needed, unmodified atomic commitment <b>protocol</b> <b>messages</b> (any such protocol; using fault tolerant atomic commitment protocols and database systems makes the CO solution fault tolerant).|$|R
50|$|A {{database}} {{system has}} the Generalized autonomy property, {{if it does}} not share with any other database system any local concurrency information beyond (unmodified) atomic commit <b>protocol</b> <b>messages</b> (however any local information can be utilized).|$|R
5000|$|SIMPLE (instant <b>messaging</b> <b>protocol)</b> (Session Initiation <b>Protocol</b> for Instant <b>Messaging</b> and Presence Leveraging Extensions) ...|$|R
30|$|Atomic message translators {{transform}} {{one message}} format into an Abstract Syntax Tree (AST). An AST is a tree {{representation of the}} abstract syntactic structure of a <b>protocol</b> <b>message.</b> Each node of the tree denotes a data field of the message, and may contain metadata of the field. AST are a format commonly used in message translation and middleware technology. Atomic message translators are reused and composed in order to generate CCL message translators.|$|E
40|$|Abstract—In {{this paper}} we {{describes}} the authentication for DHCP (Dynamic Host Configuration <b>Protocol)</b> <b>message</b> which provides the efficient key management {{and reduces the}} danger replay attack without an additional packet for a replay attack. And the authentication for DHCP message supports mutual authentication and provides both entity authentication and message authentication. We applied the authentication for DHCP message to the home network environments and tested through a home gateway. Keywords—DHCP, authentication, key management, replay attack, home network. I I...|$|E
40|$|Abstract. We {{describe}} the Dolev–Yao C (DYC) cryptographic <b>protocol</b> <b>message</b> API. In addition to generating executable protocol implementations, DYC {{can be used}} to generate constraints on an attacker against the protocol. The resulting constraints can be handed to a constraint solver, which (if successful) will find an executable attack against the protocol. To our knowledge, this is the first attempt to automate the discovery of flaws with executable cryptographic protocol implementations, rather than high-level protocol specifications or simulations. ...|$|E
30|$|We {{have written}} a 12000 line multi-threaded C++ {{simulator}} that allows independent responses from various entities in the controller network. The simulation comprises a complete implementation of the entire set of <b>protocol</b> <b>messages</b> discussed in section 3.6.|$|R
40|$|This paper {{presents}} the pattern language for specification of communication protocols. The pattern language contains four levels {{which are used}} to specify communication <b>protocol</b> and its <b>messages.</b> These four levels of this pattern language are: high-level protocol specification, <b>protocol</b> structure specification, <b>message</b> specification, and detailed message specification. Several existing patterns, e. g. the Layers, are used together with new ones to specify protocol structure. Patterns for communication <b>protocol</b> <b>messages</b> are {{most important part of}} this pattern language, and also most important part of any communication protocol specification. ...|$|R
5000|$|OpenH323 - {{a library}} for the {{development}} of H.323 applications. It uses PWLib for platform independence. The library has its own ASN.1 parser that generates the classes for encoding and decoding of the <b>protocol</b> <b>messages</b> used in H.323.|$|R
40|$|Abstract. The {{importance}} of reasoning about recognizability has re-cently been stressed in finding type flaw attacks, {{in which a}} <b>protocol</b> <b>message</b> may be forged from another message. However, the problem of deciding recognizability has never been fully exploited. To fill this gap, we present a terminating procedure to decide recognizability under the stan-dard Dolev-Yao model. By incorporating the proposed procedure with Athena, a well-know security protocol verifier, our experiments succeed in finding potential type flaw attacks...|$|E
40|$|Incorrect {{implementations}} {{of network}} <b>protocol</b> <b>message</b> specifications affect the stability, security, {{and cost of}} network system development. Most implementation defects {{fall into one of}} three categories of well defined message constraints. However, the general process of constructing network protocol stacks and systems does not capture these categorical con- straints. We introduce a systems programming language with new abstractions that capture these constraints. Safe and efficient implementations of standard message handling operations are synthesized by our compiler, and whole-program analysis is used to ensure constraints are never violated. We present language examples using the OpenFlow protocol...|$|E
40|$|Domain Name System (DNS) IANA Considerations This {{document}} specifies Internet Assigned Number Authority (IANA) parameter assignment {{considerations for}} {{the allocation of}} Domain Name System (DNS) resource record types, CLASSes, operation codes, error codes, DNS <b>protocol</b> <b>message</b> header bits, and AFSDB resource record subtypes. Status of This Memo This memo documents an Internet Best Current Practice. This document {{is a product of}} the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by th...|$|E
40|$|In {{this paper}} {{we present a}} <b>message</b> <b>protocol</b> used for <b>message</b> passing between {{external}} components and a distributed programming environment. These <b>message</b> <b>protocol</b> allows structured data transfer and remote operations as function calls or signal emission. In the distributed programming environment, a new component called a Message Manager handles the incoming messages and management. This <b>message</b> <b>protocol</b> has been implemented and validated in the centaur system...|$|R
30|$|Therefore, {{the most}} {{interesting}} case is when k≤n− 2 and the adversary controls the initiator. To prove privacy we define a simulator that is given the adversary’s input and output (which includes the set of trust values) and simulates the adversary’s view of <b>protocol</b> <b>messages.</b>|$|R
50|$|A {{distributed}} algorithm {{to guarantee}} global ECO exists. As for CO, the algorithm needs only (unmodified) atomic commitment <b>protocol</b> <b>messages.</b> In order to guarantee global serializability, each database needs to guarantee also the conflict serializability {{of its own}} transactions by any (local) concurrency control mechanism.|$|R
