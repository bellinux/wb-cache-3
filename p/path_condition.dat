76|533|Public
5000|$|Negate {{the last}} <b>path</b> <b>condition</b> not already negated {{in order to}} visit a new {{execution}} path. If {{there is no such}} <b>path</b> <b>condition,</b> the algorithm terminates.|$|E
5000|$|DM Path States: The device mapper's {{view of the}} <b>path</b> <b>condition.</b> Only two {{conditions}} are possible: ...|$|E
5000|$|Instrument {{the program}} {{so that each}} {{operation}} which may affect a symbolic variable value or a <b>path</b> <b>condition</b> is logged to a trace file, {{as well as any}} error that occurs.|$|E
40|$|We {{present a}} new {{approach}} combining dynamic slicing with <b>path</b> <b>conditions</b> in dependence graphs enhanced by dynamic information collected in a program trace. While dynamic slicing can only reveal that certain dependences have been holding during program execution, the combination with dynamic <b>path</b> <b>conditions</b> reveals why, as well...|$|R
40|$|Program slicing {{combined}} with constraint solving is a pow-erful tool for software analysis. <b>Path</b> <b>conditions</b> are gener-ated for a slice or chop, which – when solved for the input variables – deliver compact “witnesses ” for dependences or illegal influences between program points. In this contribution we show {{how to make}} <b>path</b> <b>conditions</b> work for large programs. Aggressive engineering, based on interval analysis and BDDs, is shown to overcome the po-tential combinatoric explosion. Case studies and empirical data will demonstrate the usefulness of <b>path</b> <b>conditions</b> for practical program analysis. 1...|$|R
40|$|The Satisfiability Modulo Theories solver Z 3 [10] is used {{in several}} program {{analysis}} and verification tools at Microsoft Research. Some of these tools require bit-precise reasoning for accurately modeling machine arithmetic instructions. But this alone is rarely sufficient, and an integration with other theories is required. The Pex tool [20] performs program exploration of. NET programs by generating and solving <b>path</b> <b>conditions</b> corresponding to <b>paths</b> that get explored during concrete execution. The <b>path</b> <b>conditions</b> reflect directly the executed instructions, including ones involving machine arithmetic supported by the CLR. The <b>path</b> <b>conditions</b> include also operations on heaps and structures. Pex relies on Z 3 ’s ability to produce models for satisfiable <b>path</b> <b>conditions,</b> the models must reflect {{the combination of the}} involved theories: bit-vectors, arrays, and tuples. This paper describes the features of Z 3 that are used by Pex...|$|R
50|$|Since we'd {{like the}} program to follow a {{different}} execution path on the next run, we take the last <b>path</b> <b>condition</b> encountered, x ≠ 100000, and negate it, giving x = 100000. An automated theorem prover is then invoked to find values for the input variables x and y given the complete set of symbolic variable values and path conditions constructed during symbolic execution. In this case, a valid response from the theorem prover might be x = 100000, y = 0.|$|E
5000|$|Symbolic {{execution}} and automated theorem provers have {{limitations on the}} classes of constraints they can represent and solve. For example, a theorem prover based on linear arithmetic {{will be unable to}} cope with the nonlinear <b>path</b> <b>condition</b> xy = 6. Any time that such constraints arise, the symbolic execution may substitute the current concrete value of one of the variables to simplify the problem. An important part of the design of a concolic testing system is selecting a symbolic representation precise enough to represent the constraints of interest.|$|E
50|$|Back to the {{particular}} case of a Euclidean space, the spectrum of a linear operator on this space is the set of eigenvalues of its matrix, and so is a finite set. As long as the origin {{is not in the}} spectrum (the matrix is invertible), one obviously satisfies the <b>path</b> <b>condition</b> from the previous paragraph, and as such, the theory implies that ln T is well-defined. The non-uniqueness of the matrix logarithm then follows from the fact that one can choose more than one branch of the logarithm which is defined on the set of eigenvalues of a matrix.|$|E
40|$|Precisely and {{automatically}} detection of faults in programs, is a software engineering dream. Every effort {{in this regard}} takes us {{one step closer to}} realizing it. Many efforts have been taken from the people of these areas on testing, verification and debugging. We are proposing such effort for the research community of this domain is using <b>path</b> <b>conditions</b> to generate a minimal set of PLOFC (possible lines of faulty code). It's a run time method that will effectively bring the minimal possible set of faulty lines of code through the help of <b>path</b> <b>conditions</b> and some heuristics involved. In this paper we are generating possible fault locations from programs using <b>path</b> <b>conditions</b> which can put positive impact on the static analysis of programs. Further we discuss the basic ideas regarding <b>path</b> <b>conditions,</b> the theory, and first analysis results. This work is based on a previous work that uses the variable dependences for fault detection. We showed some examples to the applicable of this idea and can be useful for software verification. Comment: 9 pages and 3 figures; Safeeullah Soomro, Zahid Hussain and Ayaz Keriyo How <b>Path</b> <b>conditions</b> can help to diagnose faults from programs, Published Sindh University of Research Journal, SURJ University of Sindh, Jamshoro 2011 ISI Index and HEC Recognize...|$|R
40|$|Memory leak is {{a common}} type of defect {{that is hard to}} detect manually. Existing memory leak {{detection}} tools suffer from lack of precise interprocedural alias and <b>path</b> <b>conditions.</b> To address this problem, we present a static interprocedural analysis algorithm, which captures memory actions and <b>path</b> <b>conditions</b> precisely, to detect memory leak in C programs. Our algorithm uses path-sensitive symbolic execution to track the memory actions in different program paths guarded by <b>path</b> <b>conditions.</b> A novel analysis model called Memory State Transition Graph (MSTG) is proposed to describe the tracking process and its results. An MSTG is generated from a procedure. Nodes in an MSTG contain states of memory objects which record the function behaviors precisely. Edges in an MSTG are annotated with <b>path</b> <b>conditions</b> collected by symbolic execution. The <b>path</b> <b>conditions</b> are checked for satisfiability {{to reduce the number of}} false alarms and the path explosion. In order to do interprocedural analysis, our algorithm generates a summary for each procedure from the MSTG and applies the summary at the procedure's call sites. Our implemented tool has found several memory leak bugs in some open source programs and detected more bugs than other tools in some programs from the SPEC 2000 benchmarks. In some cases, our tool produces many false positives, but most of them are caused by the same code patterns which are easy to check. © 2011 IEEE. Memory leak {{is a common}} type of defect that is hard to detect manually. Existing memory leak detection tools suffer from lack of precise interprocedural alias and <b>path</b> <b>conditions.</b> To address this problem, we present a static interprocedural analysis algorithm, which captures memory actions and <b>path</b> <b>conditions</b> precisely, to detect memory leak in C programs. Our algorithm uses path-sensitive symbolic execution to track the memory actions in different program paths guarded by <b>path</b> <b>conditions.</b> A novel analysis model called Memory State Transition Graph (MSTG) is proposed to describe the tracking process and its results. An MSTG is generated from a procedure. Nodes in an MSTG contain states of memory objects which record the function behaviors precisely. Edges in an MSTG are annotated with <b>path</b> <b>conditions</b> collected by symbolic execution. The <b>path</b> <b>conditions</b> are checked for satisfiability to reduce the number of false alarms and the path explosion. In order to do interprocedural analysis, our algorithm generates a summary for each procedure from the MSTG and applies the summary at the procedure's call sites. Our implemented tool has found several memory leak bugs in some open source programs and detected more bugs than other tools in some programs from the SPEC 2000 benchmarks. In some cases, our tool produces many false positives, but most of them are caused by the same code patterns which are easy to check. © 2011 IEEE...|$|R
5000|$|Symbolically re-execute {{the program}} on the trace, {{generating}} a set of symbolic constraints (including <b>path</b> <b>conditions).</b>|$|R
50|$|We {{begin with}} an {{arbitrary}} choice for x and y, for example x = y = 1. In the concrete execution, line 2 sets z to 2, and the test in line 3 fails since 1 ≠ 100000. Concurrently, the symbolic execution follows the same path but treats x and y as symbolic variables. It sets z to the expression 2y and notes that, because the test in line 3 failed, x ≠ 100000. This inequality is called a <b>path</b> <b>condition</b> and must be true for all executions following the same execution path as the current one.|$|E
30|$|The <b>path</b> <b>condition</b> {{measurement}} mechanism monitors every path's transmission {{condition to}} provide additional path information for path switching. The mechanism has three parts: the original SCTP's heartbeat to measure the basic facets of the <b>path</b> <b>condition,</b> a smart path failure detection method, and path quality estimation.|$|E
3000|$|When SCTP is initiated, {{the error}} count value is zero and the <b>path</b> <b>condition</b> is [...] "active." [...] The counter value is {{incremented}} by 1 {{each time a}} packet transmission for a path times out. The <b>path</b> <b>condition</b> for [...] "inactive" [...] activates when the counter value exceeds the value of Path_Max_Retrans.|$|E
30|$|Other studies use {{complicated}} {{methods to}} adjust the congestion window size in a wireless environment to increase throughput. This study focuses on effectively identifying <b>path</b> <b>conditions.</b> Effectively identifying the <b>path</b> <b>conditions</b> enables the mechanism to rapidly switch to a secondary path when the primary path has a serious error or is in poor condition. Quality-aware SCTP not only is simple but also improves performance.|$|R
40|$|Language-based {{information}} flow control (IFC) {{is a powerful}} tool to discover security leaks in software. Most current IFC approaches are however based on nonstandard type systems. Type-based IFC is elegant, but not precise {{and can lead to}} false alarms. We present a more precise approach to IFC which exploits active research in static program analysis. Our IFC approach is based on <b>path</b> <b>conditions</b> in program dependence graphs (PDGs). PDGs are a sophisticated and powerful analysis device, and today can handle realistic programs in full C or Java. We first recapitulate a theorem connecting the classical notion of noninterference to PDGs. We then introduce <b>path</b> <b>conditions</b> in Java PDGs. <b>Path</b> <b>conditions</b> are necessary conditions for information flo...|$|R
40|$|Program Dependency Graphs and Constraint Solving can be {{combined}} to achieve {{a powerful tool for}} information flow control, allowing to check source code for security problems such as external manipulation of critical computations. The method generates <b>path</b> <b>conditions</b> for critical information flows, being conditions over the program variables necessary for flow. As all variables are existentially quantified, quantifier elimination and in particular the REDLOG system developed at Volker Weispfenning’s group, are used to solve <b>path</b> <b>conditions</b> for the input variables, thus generating witnesses for security leaks. ...|$|R
30|$|A better {{understanding}} of the <b>path</b> <b>condition</b> makes choosing a suitable path easier. Therefore, more realistic modeling of the <b>path</b> <b>condition</b> can enhance the performance of SCTP. However, standard SCTP only knows the availability of paths (i.e., heartbeat) and not their available bandwidth. Therefore, this study proposes that ICE should obtain the condition of idle paths. ICE can periodically measure the bandwidth with the congestion window method as in ordinary SCTP transmissions and can also model the available bandwidth of alternative paths for times when an alternative path becomes a better choice than the primary path. Knowing the <b>path</b> <b>condition</b> is essential for the quality-aware SCTP path management mechanism. If the <b>path</b> <b>condition</b> is measured inaccurately, then incorrect path switching decisions may be taken. Therefore, obtaining accurate path conditions and reducing the error path information are very important.|$|E
40|$|We {{provide an}} {{automatic}} method for calculating the <b>path</b> <b>condition</b> for programs with real time constraints. This method {{can be used}} for the semiautomatic verification of a unit of code in isolation, i. e., without providing the exact values of parameters with which it is called. Our method can also be used for the automatic generation of test cases for unit testing. The current generalization of the calculation of <b>path</b> <b>condition</b> for the timed case turns out to be quite tricky, since not only the selected path contributes to the <b>path</b> <b>condition,</b> but also the timing constraints of alternative choices in the code...|$|E
40|$|This paper {{presents}} an automatic method for calculating the <b>path</b> <b>condition</b> for programs with real time constraints. We model concurrent systems using timed transition systems and translate them into extended timed automata. Then an acyclic extended timed automaton is constructed and the <b>path</b> <b>condition</b> is calculated backwards over it. This method {{can be used}} for the semiautomatic verification of a unit of code in isolation, i. e., without providing the exact values of parameters with which it is called. It can also be used for test case generation for real-time systems. Such a symbolic model checking algorithm was implemented previous in the PET system [10] for untimed systems. Our method can also be used for the automatic generation of test cases for unit testing. The current generalization of the calculation of <b>path</b> <b>condition</b> for the timed case turns out to be quite tricky, since not only the selected path contributes to the <b>path</b> <b>condition,</b> but also the timing constraints of alternative choices in the code...|$|E
30|$|The {{original}} {{path management}} method for SCTP that {{is defined in}} RFC 4960 is very simple but does not effectively distinguish <b>path</b> <b>conditions</b> (e.g., active or inactive) or efficiently apply multiple destination addresses in wireless networks.|$|R
40|$|In this paper, an {{automatic}} protocol test case generator which generates both test sequence and test data is presented. The underlying model is an extended {{finite state machine}} (EFSM) and Estelle is used as the formal description language. First, test sequences are generated using a combined control and data flow testing method. A set of <b>path</b> <b>conditions</b> associated with each test sequence is obtained using symbolic execution techniques. By solving the <b>path</b> <b>conditions</b> {{as a group of}} constraints, test data are then automatically generated. A prototype system implementing the above procedures has been built. The system has been used to generate test cases for real protocols such as TP 0, FDDI and LAPB, and has been integrated in the UBC protocol testing environment...|$|R
50|$|The Rio Hondo bicycle <b>path's</b> <b>condition</b> {{and access}} have improved, due to efforts by local {{non-governmental}} organizations. These improvements include increased accessibility, construction of rest stops with water fountains and restrooms, new interpretive signs, and the planting of many California native plants in wildlife gardens and habitat restorations.|$|R
40|$|AbstractThis paper {{presents}} an automatic method for calculating the <b>path</b> <b>condition</b> for programs with real time constraints. We model concurrent systems using timed transition systems and translate them into extended timed automata. Then an acyclic extended timed automaton is constructed and the <b>path</b> <b>condition</b> is calculated backwards over it. This method {{can be used}} for semiautomatic verification of a unit of code in isolation, i. e., without providing the exact values of parameters with which it is called. It can also be used for test case generation for real-time systems. Such a symbolic model checking algorithm was implemented previous in the PET system [E. Gunter, D. Peled, Unit checking: Symbolic model checking for a unit of code, Verification: Theory and Practice 2003, Essays Dedicated to Zohar Manna on the Occasion of his 64 th Birthday, Lecture Notes in Computer Science, vol. 2772, Springer, 548 – 567] for untimed systems. Our method can also be used for the automatic generation of test cases for unit testing. The current generalization of the calculation of <b>path</b> <b>condition</b> for the timed case turns out to be quite tricky, since not only the selected path contributes to the <b>path</b> <b>condition,</b> but also timing constraints of alternative choices in the code...|$|E
30|$|When {{the path}} error type is a {{short-term}} error with high frequency, the existing SCTP mechanism cannot work successfully. This causes erroneous <b>path</b> <b>condition</b> {{estimates for the}} wireless network.|$|E
40|$|AbstractA height {{function}} h {{is defined}} for any connected poset P with no infinite chains. A regularity condition {{which we call}} the minimal <b>path</b> <b>condition</b> is also defined. It is shown that the minimal <b>path</b> <b>condition</b> {{is equivalent to the}} gradability of P if h(x) < ∞ for all x ϵ P and furthermore under these conditions h is the smallest grade for P. If P is upper or lower semimodular, then P satisfies the minimal <b>path</b> <b>condition.</b> If P is upper semimodular and l is a maximal lower bound for x, y ϵ P, then there is a minimal upper bound u for x, y such that h(x) + h(y) ⩾ h(l) + h(u). It is shown that a poset P can be characterized by binary operations U, ℓ on the power set of P which generalize the usual inf and sup for lattices. A structure theorem for upper and lower semimodular posets is proved and some results are obtained concerning modular pairs in a poset. Finally, some applications of the above theory are given for digraphs...|$|E
40|$|We {{extend a}} {{previously}} proposed symbolic model transformation property prover for the DSLTrans transformation language. The original prover generated {{the set of}} <b>path</b> <b>conditions</b> (i. e., symbolic transformation executions), and verified atomic contracts (constraints on input-output model relations) on these <b>path</b> <b>conditions.</b> The prover evaluated atomic contracts to yield either true or false for the transformation when run on any input model. In this paper we extend the prover such that it can verify atomic contracts and more complex properties composed of atomic contracts. Besides demonstrating our prover on a simple transformation, we use it to verify different kinds of properties of an industrial transformation. Experiments on this transformation using our prover show a speed-up in verification run-time by two orders of magnitude over another verification tool that we evaluated in previous research...|$|R
40|$|AbstractPower scaling is {{combined}} with Cesáro summation, and necessary and sufficient local conditions are given for the resulting matrix sequence JN(T) to converge. It is shown that this convergence {{is closely related to}} <b>path</b> <b>conditions</b> on the one hand as well as suitable bilinear consistency conditions on the other hand...|$|R
40|$|Symbolic {{execution}} is {{a powerful}} static program analysis technique {{that has been used}} for the automated generation of test inputs. Directed Automated Random Testing (DART) is a dynamic variant of symbolic execution that initially uses random values to execute a program and collects symbolic <b>path</b> <b>conditions</b> during the execution. These conditions are then used to produce new inputs to execute the program along different paths. It has been argued that DART can handle situations where classical static symbolic execution fails due to incompleteness in decision procedures and its inability to handle external library calls. We propose here a technique that mitigates these previous limitations of classical symbolic execution. The proposed technique splits the generated <b>path</b> <b>conditions</b> into (a) constraints that can be solved by a decision procedure and (b) complex non-linear constraints with uninterpreted functions to represent external library calls. The solutions generated from the decision procedure are used to simplify the complex constraints and the resulting <b>path</b> <b>conditions</b> are checked again for satisfiability. We also present heuristics that can further improve our technique. We show how our technique can enable classical symbolic execution to cover paths that other dynamic symbolic execution approaches cannot cover. Our method has been implemented within the Symbolic PathFinder tool and has been applied to several examples, including two from the NASA domain. © 2011 ACM. Conference Pape...|$|R
30|$|This study {{proposes a}} new and {{effective}} path management mechanism for wireless networks called quality-aware SCTP. This mechanism uses cycle counting—rather than single counting as in standard SCTP—to detect path failures. Cycle counting improves on the original path failure detection method in a wireless environment because it effectively identifies the <b>path</b> <b>condition.</b> The ICE mechanism in QA-SCTP can effectively estimate the path quality and provides information for path switching decisions. Experimental results under NS 2 demonstrated that QA-SCTP performs better than standard SCTP, because it actively switches when the primary path is still active and passively switches when the <b>path</b> <b>condition</b> deteriorates and is inactive.|$|E
40|$|This paper {{discusses}} {{the design of}} dynamic curvature steering control for autonomous vehicle. The lateral control and longitudinal control are discussed in this paper. The controller is designed based on the dynamic curvature calculation to estimate the <b>path</b> <b>condition</b> and modify the vehicle speed and steering wheel angle accordingly. In this paper, the simulation results are presented to show the capability of the controller to track the reference path. The controller is able to predict the path and modify the vehicle speed to suit the <b>path</b> <b>condition.</b> The effectiveness of the controller is shown in this paper whereby identical performance is achieved with the benchmark but with extra curvature adaptation capabilites...|$|E
40|$|In {{this paper}} we {{describe}} {{a new class}} of orderings—associative path orderings—for proving termination of associative-commutative term rewriting systems. These orderings are based on the concept of simplification orderings and extend the well-known recursive path orderings to E - congruence classes, where E is an equational theory consisting of associativity and commutativity axioms. Associative path orderings are applicable to term rewriting systems for which a precedence ordering on the set of operator symbols can be defined that satisfies a certain condition,the associative <b>path</b> <b>condition.</b> The precedence ordering can often be derived from the structure of the reduction rules. We include termination proofs for various term rewriting systems (for rings,boolean algebra,etc.) and, in addition, point out ways to handle situations where the associative <b>path</b> <b>condition</b> is too restrictive...|$|E
40|$|Abstract: The {{performance}} of multi-homed transport protocols tolerant of network failure is studied. It evaluates the {{performance of}} different retransmission policies combined with path failure detection thresholds, infinite or finite receive buffers for various path bandwidths, delays and loss rate conditions through stream control transmission protocol simulation. The results show that retransmission policies perform differently with different path failure detection threshold configurations. It identifies that retransmission of all data on an alternate path with the path failure detection threshold set to zero performs the best in symmetric <b>path</b> <b>conditions</b> but its performance degrades acutely in asymmetric <b>path</b> <b>conditions</b> even when the alternate path delay is shorter than the primary path delay. It illustrates that retransmission of all data on the same path with the path failure detection threshold set to one or zero gives the most stable performance in all path configurations. ...|$|R
40|$|The {{purpose of}} this study was to examine the impact of four {{incentive}} paths on third-graders’ reading vocabulary and comprehension achievement and recreational and academic reading attitude. 120 third-grade students were assigned to one of four incentive <b>path</b> treatment <b>conditions.</b> Data were analyzed using ANCOVA with LSD post hoc comparisons. An effect size of. 09 was calculated using a partial ŋ 2 (eta squared) statistic. Findings indicated that the four incentive <b>path</b> treatment <b>conditions</b> did not differentially impact student vocabulary, comprehension, and recreational reading. A significant difference for students’ academic reading attitude was identified across the four incentive <b>path</b> treatment <b>conditions...</b>|$|R
40|$|The {{need and}} {{emergence}} of location based services {{have increased the}} demand for appropriate localisation methods. Ultra-wide band radios are attractive in such application due to their properties such as low multipath interference and high penetration. However, a number of challenges exist while designing an indoor localisation system including location errors caused by undetected direct <b>path</b> and multipath <b>conditions.</b> This paper reports our experiences in designing an indoor localisation method for 2 D and 3 D environments focussing in particular on undetected direct <b>path</b> <b>conditions...</b>|$|R
