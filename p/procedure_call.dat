777|3432|Public
5|$|CAPS {{entreprise}} and Pathscale {{are also}} coordinating {{their effort to}} make hybrid multi-core parallel programming (HMPP) directives an open standard called OpenHMPP. The OpenHMPP directive-based programming model offers a syntax to efficiently offload computations on hardware accelerators and to optimize data movement to/from the hardware memory. OpenHMPP directives describe remote <b>procedure</b> <b>call</b> (RPC) on an accelerator device (e.g. GPU) or more generally a set of cores. The directives annotate C or Fortran codes to describe two sets of functionalities: the offloading of procedures (denoted codelets) onto a remote device and the optimization of data transfers between the CPU main memory and the accelerator memory.|$|E
25|$|Threaded DPC , {{conversely}} to {{an ordinary}} DPC (Deferred <b>Procedure</b> <b>Call),</b> decreases the system latency improving {{the performance of}} time-sensitive applications, such as audio or video playback.|$|E
25|$|Network Services: Give {{access to}} the various {{networking}} abilities of the operating system. Its subcomponents include NetBIOS, Winsock, NetDDE, remote <b>procedure</b> <b>call</b> (RPC) and many more. This component resides in netapi32.dll on 32-bit Windows.|$|E
5000|$|Remote <b>procedure</b> <b>calls</b> used {{in modern}} {{operating}} systems trace their roots {{back to the}} RC 4000 multiprogramming system, which used a request-response communication protocol for process synchronization. The idea of treating network operations as remote <b>procedure</b> <b>calls</b> goes {{back at least to}} the 1970s in early ARPANET documents. In 1978, Per Brinch Hansen proposed Distributed Processes, a language for distributed computing based on [...] "external requests" [...] consisting of <b>procedure</b> <b>calls</b> between processes.|$|R
5000|$|Support for interprocess {{communication}} and remote <b>procedure</b> <b>calls.</b>|$|R
5000|$|By {{the same}} token, <b>procedure</b> <b>calls</b> {{correspond}} to function application.|$|R
25|$|Divide-and-conquer {{algorithms}} {{are naturally}} implemented as recursive procedures. In that case, the partial sub-problems {{leading to the}} one currently being solved are automatically stored in the <b>procedure</b> <b>call</b> stack. A recursive function is a function that calls itself within its definition.|$|E
25|$|In late 1981 {{and early}} 1982 Sassenrath took an {{academic}} leave to do atmospheric physics research for National Science Foundation at Amundsenâ€“Scott South Pole Station. Upon returning, Sassenrath {{reached an agreement}} with HP to pursue independent research into new areas of computing, including graphical user interfaces and remote <b>procedure</b> <b>call</b> methods of distributed computing.|$|E
25|$|JSON-RPC is {{a remote}} <b>procedure</b> <b>call</b> (RPC) {{protocol}} built on JSON, {{as a replacement}} for XML-RPC or SOAP. It is a simple protocol that defines only a handful of data types and commands. JSON-RPC lets a system send notifications (information to the server that does not require a response) and multiple calls to the server that can be answered out of order.|$|E
5000|$|Consider an {{expression}} involving conventional remote <b>procedure</b> <b>calls,</b> such as: ...|$|R
5000|$|The GSSAPI {{describes}} about 45 <b>procedure</b> <b>calls.</b> Significant ones include: ...|$|R
5000|$|Routed RPC: {{supports}} routed (not only point-to-point) Remote <b>Procedure</b> <b>Calls.</b>|$|R
25|$|Among PARC's {{distinguished}} {{researchers were}} three Turing Award winners: Butler W. Lampson (1992), Alan Kay (2003), and Charles P. Thacker (2009). The Association for Computing Machinery (ACM) Software System Award recognized the Alto system in 1984, Smalltalk in 1987, InterLisp in 1992, and the remote <b>procedure</b> <b>call</b> in 1994. Lampson, Kay, Bob Taylor, and Charles P. Thacker received the National Academy of Engineering's prestigious Charles Stark Draper Prize in 2004 {{for their work}} on the Alto.|$|E
25|$|Another {{solution}} to the library issue comes from using completely separate executables (often in some lightweight form) and calling them using a remote <b>procedure</b> <b>call</b> (RPC) over a network to another computer. This approach maximizes operating system re-use: the code needed to support the library is the same code being used to provide application support and security for every other program. Additionally, such systems do not require the library to exist on the same machine, but can forward the requests over the network.|$|E
25|$|The Windows Executive {{services}} {{make up the}} low-level kernel-mode portion, and {{are contained}} in the file NTOSKRNL.EXE. It deals with I/O, object management, security and process management. These are divided into several subsystems, among which are Cache Manager, Configuration Manager, I/O Manager, Local <b>Procedure</b> <b>Call</b> (LPC), Memory Manager, Object Manager, Process Structure and Security Reference Monitor (SRM). Grouped together, the components can be called Executive services (internal name Ex). System Services (internal name Nt), i.e., system calls, are implemented at this level, too, except very few that call directly into the kernel layer for better performance.|$|E
5000|$|... saga::rpc - {{interface}} for remote <b>procedure</b> <b>calls</b> {{client and}} servers ...|$|R
40|$|The most {{important}} goal in hard real-time systems is {{to guarantee that}} all timing constraints are satisfied. Even though object-based techniques (which contain reusable software components) are used to manage the complexity in the software development process of such systems, execution efficiency {{may have to be}} sacrificed, due to the large number of <b>procedure</b> <b>calls</b> and contention for accessing software components. These issues are addressed by the following parallelizing techniques: (a) converting potentially inefficient <b>procedure</b> <b>calls</b> to a source of concurrency via asynchronous remote <b>procedure</b> <b>calls</b> (ARPC) (b) replicating (or cloning) software components to reduce the contention...|$|R
50|$|Declare a new {{variable}} in the <b>procedure</b> (<b>called</b> L for reference).|$|R
25|$|The {{three top}} layers in the OSI model, i.e. the {{application}} layer, the presentation layer and the session layer, are not distinguished separately in the TCP/IP model which only has an application layer above the transport layer. While some pure OSI protocol applications, such as X.400, also combined them, {{there is no}} requirement that a TCP/IP protocol stack must impose monolithic architecture above the transport layer. For example, the NFS application protocol runs over the eXternal Data Representation (XDR) presentation protocol, which, in turn, runs over a protocol called Remote <b>Procedure</b> <b>Call</b> (RPC). RPC provides reliable record transmission, so it can safely use the best-effort UDP transport.|$|E
25|$|Assignment statements, in {{imperative}} paradigm, {{perform an}} operation on information located in memory and store {{the results in}} memory for later use. High-level imperative languages, in addition, permit the evaluation of complex expressions, which may consist {{of a combination of}} arithmetic operations and function evaluations, and the assignment of the resulting value to memory. Looping statements (as in while loops, do while loops, and for loops) allow a sequence of statements to be executed multiple times. Loops can either execute the statements they contain a predefined number of times, or they can execute them repeatedly until some condition changes. Conditional branching statements allow a sequence of statements to be executed only if some condition is met. Otherwise, the statements are skipped and the execution sequence continues from the statement following them. Unconditional branching statements allow an execution sequence to be transferred to another part of a program. These include the jump (called goto in many languages), switch, and the subprogram, subroutine, or <b>procedure</b> <b>call</b> (which usually returns to the next statement after the call).|$|E
2500|$|There was no {{division}} instruction (but various division subroutines were supplied) {{and no way}} {{to directly}} load a number into the accumulator (a [...] "sTore and zero accumulator" [...] instruction followed by an [...] "Add" [...] instruction were necessary for this). [...] There was no unconditional jump instruction, nor was there a <b>procedure</b> <b>call</b> instruction- it {{had not yet been}} invented.|$|E
50|$|Logo {{allows for}} recursion, the process where a <b>procedure</b> <b>calls</b> itself.|$|R
50|$|When validating an XML Signature, a <b>procedure</b> <b>called</b> Core Validation is followed.|$|R
5000|$|The <b>procedure</b> <b>calling</b> {{sequence}} {{works as}} follows: The call is introduced with ...|$|R
2500|$|The basic {{language}} construct is the unit. A unit {{may be a}} formula, an enclosed clause, a routine text or one of several technically needed constructs (assignation, jump, skip, nihil). The technical term enclosed clause unifies some of the inherently bracketing constructs known as block, do statement, switch statement in other contemporary languages. When keywords are used, generally the reversed character sequence of the introducing [...] keyword is used for terminating the enclosure, e.g. ( [...] if ~ then ~ else ~ fi, case ~ in ~ out ~ esac, for ~ while ~ do ~ od [...] ). This [...] syntax was reused by Stephen Bourne in the common Unix Bourne shell. An expression may also yield a multiple value, which is constructed from other values by a collateral clause. This construct just looks like the parameter pack of a <b>procedure</b> <b>call.</b>|$|E
5000|$|GridRPC: Grid Remote <b>Procedure</b> <b>Call</b> designs OGF {{recommendations}} for a grid-enabled, remote <b>procedure</b> <b>call</b> (RPC) mechanism.|$|E
50|$|A Protected <b>Procedure</b> <b>Call</b> (PPC) is a {{messaging}} facility wherein {{messages are}} sent and received using <b>procedure</b> <b>call</b> interfaces. They are a core {{component of the}} K42 operating system.|$|E
5000|$|RPC: {{supports}} Remote <b>Procedure</b> <b>Calls</b> {{out of the}} box (no extension required).|$|R
50|$|A call graph (also {{known as}} a call multigraph) is a control flow graph, which {{represents}} calling relationships between subroutines in a computer program. Each node represents a procedure and each edge (f, g) indicates that <b>procedure</b> f <b>calls</b> <b>procedure</b> g. Thus, a cycle in the graph indicates recursive <b>procedure</b> <b>calls.</b>|$|R
50|$|If damaged, {{the tympanic}} {{membrane}} can be repaired in a <b>procedure</b> <b>called</b> tympanoplasty.|$|R
50|$|Open Network Computing (ONC) Remote <b>Procedure</b> <b>Call</b> (RPC) is {{a remote}} <b>procedure</b> <b>call</b> system. ONC was {{originally}} developed by Sun Microsystems in the 1980s {{as part of}} their Network File System project, and is sometimes referred to as Sun RPC.|$|E
50|$|The Local <b>Procedure</b> <b>Call</b> (LPC, often also {{referred}} to as Lightweight <b>Procedure</b> <b>Call</b> or Local Inter-Process Communication) is an internal, undocumented inter-process communication facility provided by the Microsoft Windows NT kernel for lightweight IPC between processes on the same computer. As of Windows Vista, LPC has been rewritten as Advanced Local <b>Procedure</b> <b>Call</b> (ALPC) in order to provide a high-speed scalable communication mechanism required to efficiently implement User-Mode Driver Framework (UMDF), whose user-mode parts require an efficient communication channel with UMDF's components in the executive.|$|E
5000|$|Open Network Computing Remote <b>Procedure</b> <b>Call,</b> by Sun Microsystems ...|$|E
5000|$|Key/value pairs (encoded in HTTP GET query strings, {{to perform}} remote <b>procedure</b> <b>calls)</b> ...|$|R
50|$|A non-surgical <b>procedure</b> <b>called,</b> Angioplasty, {{could be}} done to help dilate the narrowed arteries.|$|R
5000|$|The Origin of Concurrent Programming: From Semaphores to Remote <b>Procedure</b> <b>Calls</b> (editor, 2002, [...] ) ...|$|R
