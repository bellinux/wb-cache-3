0|16|Public
50|$|The PDS-1's {{built-in}} minicomputer {{was needed}} for responding to user keyboard and light pen interactions quickly, without delays in talking to a remote timeshared large computer for help. The minicomputer's main task was to build and modify the display list as needed for the next refresh cycle. For text and 2-D line graphics this was easy and did not involve much computing. To minimize costs, Imlac designed their own simple minicomputer with as few registers and logic gates as possible. It was a single-accumulator machine much like a DEC PDP-8, except using 16-bit instructions and data instead of 12 bits. There were no integer multiply/divide instructions, no floating point instructions, no microprogramming, no virtual addressing, and no cache. The single form of address modification was via indirect address pointers held in memory. Certain <b>pointer</b> <b>cells</b> would auto-increment when used. Stack operations were not supported.|$|R
50|$|The locks-and-keys {{approach}} represents pointers as ordered pairs (key, address) {{where the}} key is an integer value. Heap-dynamic variables are represented as the storage for the variable plus a cell for an integer lock value. When a variable is allocated, a lock value is created and placed both into the variable's cell and into the <b>pointer's</b> key <b>cell.</b> Every access to the pointer compares these two values, and access is allowed only if the values match.|$|R
40|$|Great {{concern has}} been {{demonstrated}} by different aeronautic operators {{about the effects of}} electromagnetic interference in avionics and electronic equipments of airplanes, due to the use of portable electronic devices (PEDs), which can be easily carried by the passengers. Among the suspect devices, there are laptops and palmtops, audio recorders and reproducers, electronic games and toys, laser <b>pointers,</b> <b>cell</b> phones, communication radios and pagers. Uncouplings or automatic pilot deviations, mistaken indications in displays and, even, the unadverted disconnection of the avionics or variations not commanded in the control surfaces are flaws attributed to these devices. In spite of suffering critics, several regulation agencies in aeronautics, all over the world, have prohibited the use of these portable devices, specially in the critical phases of the flight landing and take off. Nevertheless, its getting bigger the passengers desire of using, uninterruptely, laptops and cell phones, what makes necessary the adoption of safety procedures to satisfy this demand. Besides the concern over these dangerous effects, there are yet, doubts over the topic, and, therefore, its indicated the need of more investigations over these phenomenons. In this work, we relate the main accomplished experiments with the intent to clarify how the PEDs, more specifically the cell phones, cause an undesirable electromagnetic interference...|$|R
5000|$|... ++ Cell c0 = 2> +++++ Cell c1 = 5Start your loops {{with your}} <b>cell</b> <b>pointer</b> on the loop counter (c1 in our case)< + Add 1 to c0> - Subtract 1 from c1 End your loops with the <b>cell</b> <b>pointer</b> on the loop counterAt this point our program has added 5 to 2 leaving 7 in c0 and 0 in c1BUT we cannot output this {{value to the}} {{terminal}} since it's not ASCII encoded!To display the ASCII character [...] "7" [...] we must add 48 to the value 7!48 = 6 * 8 so let's use another loop to help us!++++ ++++ c1 = 8 {{and this will be}} our loop counter again+++ +++ Add 6 to c0> - Subtract 1 from c1< [...] Print out c0 which has the value 55 which translates to [...] "7"! ...|$|R
5000|$|... is little-used. IBM {{documentation}} {{described it}} as [...] "inactive", and the key's purpose was a mystery even to keyboard manufacturers. In modern software, typing text usually causes previous text to scroll {{off the top of}} the screen or window. Some old programs could disable this and restart at the top of the window when scroll lock was pressed. The advantage is that the entire screenful of text does not shift, making it easier to read. Scroll Lock was also used to lock the cursor on its line and scroll the work area under it. In spreadsheets such as Microsoft Excel, it locks the <b>cell</b> <b>pointer</b> on the current cell, allowing the user to use the arrow keys to move the view window without moving the <b>cell</b> <b>pointer.</b> On some consoles (such as the Linux console), it prevents scrolling of messages until another key combination is pressed. Many hardware KVM switches use Scroll Lock to switch between the devices they control.|$|R
40|$|Abstract. Most {{previous}} {{work on the}} semantics of higher-order programs with local state involves complex storage modeling with <b>pointers</b> and memory <b>cells,</b> complicated categorical constructions, or reasoning {{in the presence of}} context. In this paper we show how a relatively simple relational semantics can be used to avoid these complications. We provide a natural relational semantics for a programming language with higher-order functions. The semantics is purely compositional, with all contextual considerations completely encapsulated in the state. We show several equivalence proofs using this semantics based on examples of Meyer and Sieber (1988). ...|$|R
40|$|A {{new model}} called global {{cellular}} automata (GCA) will be introduced. The new model preserves the good {{features of the}} cellular automata but overcomes its restrictions. In the GCA the cell state consists of a data eld and additional pointers. Via these <b>pointers,</b> each <b>cell</b> has read access to any other cell in the cell eld, and the pointers may be changed from generation to generation. Compared to the cellular automata the neighbourhood is dynamic and diers from cell to cell. For many applications parallel algorithms can be found straight forward and can directly be mapped on this new model. As the model is also massive parallel in a simple way, it can eciently be supported by hardware. 1 Motivation The classical cellular automata model (CA) can be characterised by the following features The CA consists of a n{dimensional eld of cells. Each cell can be identi ed by its coordinates. The neighbours are xed and are dened by relative coordinates. Each cell has local [...] ...|$|R
40|$|Much {{work has}} been done on the {{semantics}} of programs with local state. Most of this work involves complex storage modeling with <b>pointers</b> and memory <b>cells,</b> complicated categorical constructions, and reasoning in the presence of context. We show how a relatively simple relational semantics can be used to avoid these complications. We provide a natural relational semantics for a programming language with higherorder functions. We define a purely compositional semantics based on binary and ternary relations such that all contextual considerations are completely encapsulated in the state. We show several equivalence proofs using this semantics based on examples of Meyer and Sieber (1988) ...|$|R
50|$|The memory {{organization}} of the SECD machine {{is similar to the}} model used by most functional language interpreters: a number of memory cells, each of which can hold either an atom (a simple value, for example 13), or represent an empty or non-empty list. In the latter case, the <b>cell</b> holds two <b>pointers</b> to other <b>cells,</b> one representing the first element, the other representing the list except for the first element. The two pointers are traditionally named car and cdr respectively—but the more modern terms head and tail are often used instead. The different types of values that a cell can hold are distinguished by a tag. Often different types of atoms (integers, strings, etc.) are distinguished as well.|$|R
40|$|Most {{previous}} {{work on the}} semantics of programs with local state involves complex storage modeling with <b>pointers</b> and memory <b>cells,</b> complicated categorical constructions, or reasoning {{in the presence of}} context. In this paper, we explore the extent to which relational semantics and axiomatic reasoning in the style of Kleene algebra can be used to avoid these complications. We provide (i) a fully compositional relational semantics for a first-order programming language with a construct for local variable scoping; and (ii) an equational proof system based on Kleene algebra with tests for proving equivalence of programs in this language. We show that the proof system is sound and complete relative to the underlying equational theory without local scoping. We illustrate the use of the system with several examples...|$|R
40|$|In 1979, Ron Brachman {{discussed}} a classification {{of the various}} primitives used by KR systems at that time. He argued {{that they could be}} grouped in four levels, ranging from the implementational to the linguistic level (Fig. 1). Each level corresponds to an explicit set of primitives offered to the knowledge engineer. At the implementational level, primitives are merely <b>pointers</b> and memory <b>cells,</b> which allow us to construct data structures with no a priori semantics. At the logical level, primitives are propositions, predicates, logical functions and operators, which are given a formal semantics in terms of relations among objects in the real world. No particular assumption is made however as to the nature of such relations: classical predicate logic is a general, uniform, neutral formalism, and the user is free to adapt it to its own representation purposes. At t...|$|R
40|$|To {{formulate}} data structures {{suited to}} numerical problems like selfadapting multilevel algorithms for {{the solution of}} partial differential equations, several data constructs, conditions and attributes are necessary. These constructs are offered by languages like C++ and Fortran 90. A selection of features which seem to be useful in programming modern algorithms are derived types to formulate complex data structures, dynamic memory management for the selfadaptive refinement and recoarsing of the grid, <b>pointer</b> to relate <b>cells</b> with their children, parent element and neighbours, some array contructs, and interfaces for the definition and overloading of operators suited to the defined data structures. We were mainly interested in the newly developed programming language Fortran 90. Therefore we worked with the first release of the CF 90 programming environment. This paper gives an impression of how using some single Fortran 90 features does influence {{the speed of a}} program. (orig.) Available from TIB Hannover: RO 7298 (20) / FIZ - Fachinformationszzentrum Karlsruhe / TIB - Technische InformationsbibliothekSIGLEDEGerman...|$|R
40|$|Techniques for the {{verification}} of elementary properties of pointer programs are highly desirable. Programming with pointers is error–prone with potential pitfalls such as dereferencing null pointers {{and the creation}} of memory leaks. So far, the field of pointer analysis has focused primarily on sequential programs. But pointer programming becomes even more vulnerable in a concurrent setting where threads can be dynamically created, and where data structures such as linked lists are manipulated and inspected by several threads. We present an approach to model checking of concurrent programs that operate on singly–linked lists. To the best of our knowledge, it is the first work which combines unbounded creation of pointer–manipulating threads with an expressive logic. Moreover existing approaches that support reasoning about dynamic data structures make use of non–standard logics, advanced model–checking procedures or extended versions of Hoare logics with accompanying deduction techniques. In contrast, the approach advocated in this paper stays within the realm of traditional (linear–time) model checking. This facilitates the usage of standard model checkers for validating temporal properties addressing absence of memory leaks, dereferencing of null pointers, dynamic creation of cells, and simple and position– dependent aliasing. Our approach is illustrated by considering a simple concurrent programming language that besides the usual control structures offers primitives for thread creation, <b>pointer</b> manipulation, <b>cell</b> creation and destruction, and (guarded) atomic regions that allow concurrency control constructs such as test–and–set primitives and monitors. It is worth mentioning that the restriction to singly–linked pointer structures, which we share with many publications in the field var x, y; proc main(01 new(x); 02 spawn(server) ...|$|R
40|$|We {{show that}} the {{fragment}} of BI used as an assertion language for mutable data structures is strongly-expressive {{in the sense of}} Cook and Oppen. 1 Introduction An assertion language is strongly expressive if it is able to express all RE relations over the data structures of the programming language [CO 75]. To do this, it is sucient to {{show that the}} language can code the computation of an arbitrary single-tape Turing machine. We show that the fragment of BI used as an assertion language for mutable data structures is strongly-expressive. The programming language is a simple pointer language with Lisp-like commands to create and access cons cells. We will restrict the size of cons cells to 2 : the rst car of the cell will usually contain an expression, the cdr will usually contain a <b>pointer</b> to another <b>cell.</b> The assertion language consists of BI with a points-to relation, !. E ! (F; G) means that E points to a cell in the heap whose car is F and cdr G. There are 3 types of variables [...] ...|$|R
40|$|Abstract. We {{introduce}} a new data structure called symlist based on an idea of Tarjan [17]. A symlist is a doubly linked list without any directional information encoded into its cells. In a symlist the two <b>pointers</b> in each <b>cell</b> have no fixed meaning like previous or next in standard lists. Besides the common operations on doubly linked lists, symlists support the reversal of a list and the insertion of a (reversed) symlist into another one, both in constant time. This is an improvement over common implementations, e. g., the Stl class list, where reversal needs linear time. A typical application of symlists is storing the children of a so called Qnode in a PQ-tree, a data structure used in linear time graph planarity testing algorithms. We show that a straightforward implementation of Tarjan’s idea [17] leads to an anomaly when inserting a new element and provide a simple solution to avoid it. Finally, we present an implementation of symlists with iterators {{that is similar to}} the Stl class list and its iterators. ...|$|R
40|$|In {{the heap}} {{model in which}} garbage {{collectors}} usually operate, the heap is an array of cells. Each cell contains either a non-pointer, to be ignored, or a pointer to a block of cells somewhere in the heap, called an object. The objects do not overlap. In addition, {{there are a bunch}} of cells not in the heap, called the root set. It is possible to determine from a cell whether it contains a pointer or not, and it is possible to determine from a pointer how long the object pointed to is. The goal of a garbage collector is to preserve all structures that are accessible through a chain of deferences starting at the root set, while reclaiming any storage not thus accessible. Such accessible storage is called live. In copying garbage collection, the best technique for most applications, a new heap is constructed, all live objects are copied to this new heap, and pointers are updated to reflect the new locations [2, 4]. Here we consider the addition of a new kind of value to be permitted in <b>cells,</b> namely <b>pointers</b> to single <b>cells.</b> These single cells may be inside objects that are referenced by the usual pointers to objects. For historical reasons, these <b>pointers</b> to single <b>cells</b> are called locatives. Locatives are similar to Pascal pointers, in that the only operations that can be performed on a locative are to deference it or to alter the contents of the cell it points to. 1 In Pascal, pointers can not be constructed to arbitrary components of structures; but such pointers can be constructed in most other Algol descended languages, such as Modula or ADA. Some lisp systems, such as ZetaLisp [7] and T [6], incorporate locatives into copying garbage collectors by having a special routine that allows a pointer to the surrounding object to be recovered from a locative. This allows locatives to exist at the expense of never reclaiming the storage occupied by an otherwise unreferenced object containing a cell pointed to by a locative. Also, requiring the ability to recover a pointer to the surrounding object from a locative constrains and complicates memory formats, as in garbage collectors for C [3]. In the next section we will develop an algorithm that reclaims the otherwise unreferenced cells of objects containing cells pointed to by locatives, thus alleviating these difficulties...|$|R

