134|169|Public
25|$|For example, {{the global}} IPv4 address 192.0.2.4 has the {{corresponding}} 6to4 prefix 2002:c000:0204::/48. This gives a <b>prefix</b> <b>length</b> of 48 bits, which leaves {{room for a}} 16-bit subnet field and 64 bit host addresses within the subnets.|$|E
25|$|The RFC 950 {{specification}} recommended reserving the subnet values {{consisting of}} all zeros (see above) and all ones (broadcast), {{reducing the number}} of available subnets by two. However, due to the inefficiencies introduced by this convention it was abandoned for use on the public Internet, and is only relevant when dealing with legacy equipment that does not implement CIDR. The only reason not to use the all-zeroes subnet is that it is ambiguous when the <b>prefix</b> <b>length</b> is not available. RFC 950 itself did not make the use of the zero subnet illegal; it was however considered best practice by engineers.|$|E
5000|$|The Jaro-Winkler {{distance}} uses a prefix scale [...] {{which gives}} more favourable ratings to strings that match {{from the beginning}} for a set <b>prefix</b> <b>length</b> [...]|$|E
5000|$|Source & {{destination}} IP masks (<b>prefix</b> <b>lengths</b> in the CIDR notation) ...|$|R
5000|$|The {{class name}} the {{function}} belongs to, again, with a <b>prefixed</b> <b>length.</b>|$|R
30|$|The {{performance}} of MIHT-v 6 {{is similar in}} all cases because it groups routes by keys in Priority Tries (PTs), rather than <b>prefix</b> <b>lengths</b> (as in the Bloom filters approach). In other words, the number of distinct <b>prefix</b> <b>lengths</b> in the forwarding table does not directly affect the {{performance of}} MIHT. The Bloomfwd-v 6 on the Intel Phi 7250 attained a throughput of up to 182.75 Mlps, and as presented {{there is a strong}} variation in performance as the number of CPE levels used is varied. The choice of the CPE levels is complex and involves many aspects such as caching capabilities and its effects on FPR, which requires an experimental evaluation for its adequate choice.|$|R
50|$|Longest prefix match (also called Maximum <b>prefix</b> <b>length</b> match) {{refers to}} an {{algorithm}} used by routers in Internet Protocol (IP) networking to select an entry from a forwarding table.|$|E
5000|$|Jaro-Winkler {{distance}} uses a prefix scale [...] {{which gives}} more favourable ratings to strings that match {{from the beginning}} for a set <b>prefix</b> <b>length</b> [...] Given two strings [...] and , their Jaro-Winkler distance [...] is: ...|$|E
50|$|For example, {{the global}} IPv4 address 192.0.2.4 has the {{corresponding}} 6to4 prefix 2002:c000:0204::/48. This gives a <b>prefix</b> <b>length</b> of 48 bits, which leaves {{room for a}} 16-bit subnet field and 64 bit host addresses within the subnets.|$|E
40|$|As two {{important}} operations in data cleaning, similarity join and similarity search have {{attracted much attention}} recently. Existing methods to support similarity join usually adopt a prefix-filtering-based framework. They select a prefix of each object and prune object pairs whose prefixes have no overlap. We have an observation that <b>prefix</b> <b>lengths</b> have sig-nificant effect on the performance. Different <b>prefix</b> <b>lengths</b> lead to significantly different performance, and prefix filter-ing does not always achieve high performance. To address this problem, {{in this paper we}} propose an adaptive frame-work to support similarity join. We propose a cost model to judiciously select an appropriate prefix for each object. To efficiently select prefixes, we devise effective indexes. We ex-tend our method to support similarity search. Experimental results show that our framework beats the prefix-filtering-based framework and achieves high efficiency...|$|R
5000|$|Prefixing {{it with a}} cyclic <b>prefix</b> of <b>length</b> , the OFDM symbol {{obtained}} is: ...|$|R
5000|$|The {{advantage}} of this format {{is that it can}} speed up parsing {{due to the fact that}} the exact length of each message is explicitly stated, rather than forcing the parser to search for delimiters. Length-prefixed JSON is also well-suited for TCP applications, where a single [...] "message" [...] may be divided into arbitrary chunks, because the <b>prefixed</b> <b>length</b> tells the parser exactly how many bytes to expect before attempting to parse a JSON string.|$|R
5000|$|Prefix {{doubling}} algorithms {{are based}} on a strategy of [...] The idea is to find prefixes that honor the lexicographic ordering of suffixes. The assessed <b>prefix</b> <b>length</b> doubles in each iteration of the algorithm until a prefix is unique and provides the rank of the associated suffix.|$|E
50|$|The maximum <b>prefix</b> <b>length</b> is an {{optional}} field. When not defined, the AS is only authorised to advertise exactly the prefix specified. Any more specific {{announcement of the}} prefix will be considered invalid. This {{is a way to}} enforce aggregation and prevent hijacking through the announcement of a more specific prefix.|$|E
50|$|The {{encoding}} used {{to store}} the common <b>prefix</b> <b>length</b> itself varies from application to application. Typical techniques are storing the value as a single byte; delta encoding, which stores only {{the change in the}} common prefix length; and various universal codes. It may be combined with other general lossless data compression techniques such as entropy encoding and dictionary coders to compress the remaining suffixes.|$|E
30|$|Due to {{its regular}} data structures, the Bloom filters {{algorithm}} exposes multiple opportunities for parallelism. For instance, in [17] {{it was suggested}} a parallel search over {{the two sets of}} Bloom filters/hash tables and the DLA (associated with the different <b>prefix</b> <b>lengths)</b> for a given input address, which is mentioned to be appropriate for hardware implementations. In this strategy, a final pass is performed to verify if a match occurs in any of these data structures and to select the next hop. The same approach could be used for a software-based parallelization by dispatching a thread to search each data structure. However, IPv 4 prefix databases have the well-known characteristic that prefixes are not uniformly distributed in the range of valid <b>prefix</b> <b>lengths</b> and, as a consequence, {{it is more likely that}} a match occurs to <b>prefixes</b> within <b>lengths</b> that concentrate most of the addresses, i.e., the set of Bloom filter and hash table that stores 24 -bit prefixes. Therefore, computing all Bloom filters in parallel may not be efficient because, most of the times, the results from the data structures associated with <b>prefix</b> <b>lengths</b> smaller or greater than 24 bits will not be used. Instead, it is more compute efficient to sequentially query the Bloom filters and the DLA. The other option for TLP, which is used in our approach, is to perform the parallel lookup computation for multiple addresses by assigning one or multiple addresses to each computing thread available. In this way, we can carry out the processing of each address using the compute efficient algorithm, while we are still able to improve the system throughput by computing the lookup for multiple addresses concurrently. This is possible because the processing of addresses is independent and, as such, there is no synchronization across the computation performed for different addresses. The implementation of the parallelization at this level employed the Open Multi-Processing API (OpenMP) [26], which was used to annotate the main algorithm loop that iterates over the input addresses to find their next hops. The specific OpenMP settings used, which led to the better results, were the dynamic scheduler with chunk size of one.|$|R
50|$|Compared to JSON, BSON is {{designed}} to be efficient both in storage space and scan-speed. Large elements in a BSON document are <b>prefixed</b> with a <b>length</b> field to facilitate scanning. In some cases, BSON will use more space than JSON due to the <b>length</b> <b>prefixes</b> and explicit array indices.|$|R
40|$|Abstract—The multi-zone cache {{is a new}} {{architecture}} for IP address caches {{that has}} been shown to have significantly better performance than standard single zone caches in this application. This new architecture presents three more degrees of freedom when specifying a design, in addition {{to the size of the}} cache. These are the number of zones, the size of each zone, and the range of <b>prefix</b> <b>lengths</b> of the addresses cached in each zone. In this paper we present analytical models that can be used to make decisions about these values...|$|R
5000|$|In this definition, [...] is the {{starting}} and [...] any non-terminal. The already derived input , and yet unread [...] and [...] are strings of terminals. The Greek letters , [...] and [...] represent any string of both terminals and non-terminals (possibly empty). The <b>prefix</b> <b>length</b> corresponds to the lookahead buffer size, and the definition says that this buffer is enough to distinguish between any two derivations of different words.|$|E
5000|$|In some cases, routers have {{insufficient}} {{amounts of}} main memory {{to hold the}} full global BGP table. A simple work-around is to perform input filtering, thus limiting the local route database to {{a subset of the}} global table. [...] This can be done by filtering on <b>prefix</b> <b>length</b> (eliminating all routes for prefixes longer than a given value), on AS count, or on some combination of the two; security is the most important point for this.|$|E
50|$|The RFC 950 {{specification}} recommended reserving the subnet values {{consisting of}} all zeros (see above) and all ones (broadcast), {{reducing the number}} of available subnets by two. However, due to the inefficiencies introduced by this convention it was abandoned for use on the public Internet, and is only relevant when dealing with legacy equipment that does not implement CIDR. The only reason not to use the all-zeroes subnet is that it is ambiguous when the <b>prefix</b> <b>length</b> is not available. RFC 950 itself did not make the use of the zero subnet illegal; it was however considered best practice by engineers.|$|E
5000|$|A {{probability}} measure [...] {{of the set}} of path with the common <b>prefix</b> of <b>length</b> [...] {{is equal to the}} product of transitions probabilitites along the prefix of the path: ...|$|R
40|$|All global routing {{protocols}} use hierarchies to allow scaling {{to a world}} wide community while keeping the routing database size manageable. Databases of variable <b>length</b> <b>prefixes</b> are {{a powerful tool for}} providing this in a flexible manner, but require a Longest Prefix Matching algorithm. In this paper, we report a fundamentally new solution that is both algorithmically interesting and practical. Our scheme is based on doing binary search on hash tables orga-nized by <b>prefix</b> <b>lengths,</b> and scales very well as address and routing table sizes increase: independent of the table size, it requires a worst case time of hash lookups. With the current In-ternet Protocol, which uses 32 bit addresses, at most 5 hash lookups are needed; for the upcoming 128 bit addresses of the next gener-ation Internet Protocol (IPv 6), 7 lookups suffice. Several refine...|$|R
40|$|This memo {{provides}} {{information for the}} Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited. Copyright Notice Copyright (C) The Internet Society (2003). All Rights Reserved. In some cases, the operational decision may be to use IPv 6 / 127 <b>prefix</b> <b>lengths,</b> especially on point-to-point links between routers. Under certain situations, this may lead to one router claiming both addresses due to subnet-router anycast being implemented. This document discusses the issue and offers a couple of solutions to the problem; nevertheless, / 127 should be avoided between two routers. 1...|$|R
50|$|Router {{configuration}} rules {{may contain}} static routes. A static route minimally has a destination address, a <b>prefix</b> <b>length</b> or subnet mask, and a definition where to send packets for the route. That definition {{can refer to}} a local interface on the router, or a next-hop address that {{could be on the}} far end of a subnet to which the router is connected. The next-hop address could also be on a subnet that is directly connected, and, before the router can determine if the static route is usable, it must do a recursive lookup of the next hop address in the local routing table. If the next-hop address is reachable, the static route is usable, but if the next-hop is unreachable, the route is ignored.|$|E
50|$|The prefix {{portion of}} the UTI code should be a unique code for the code issueing authority. Ideally, the prefix would have reused the Legal Entity Identifier (LEI) of the entity issueing the UTI. LEI codes are used across the {{financial}} reporting regimes in the U.S. (Dodd-Frank) and Europe (EMIR / MiFID). However, the LEI code length of 20 characters represented a problem for many systems, which in practice limited the usable <b>prefix</b> <b>length</b> to 10 characters. In June 2013, ISDA working groups suggested that the characters 7 through 16 of the 20 character global LEI number should {{be used as the}} UTI prefix. This would have led to clashes between UTIs generated for different organisations having the same characters 7 through 16 in their LEIs. Now the recommended best practice entails a 10 character UTI Prefix, algorithmically derived from an entity’s 20 character LEI using hash algorithms.|$|E
40|$|Abstract — Prefix-Randomized Query-Tree (PRQT) {{protocol}} {{has been}} proposed for multiple tag identification in RFID systems. The optimal performance of PRQT can be achieved with a proper choice of the initial <b>prefix</b> <b>length</b> according to the tag set size. In this paper, we propose an initial <b>prefix</b> <b>length</b> adaptation algorithm for PRQT protocol when the tag set size is unknown before identification. The algorithm starts with the setting of a small initial <b>prefix</b> <b>length</b> l followed by the polling of all 2 l prefixes. The initial <b>prefix</b> <b>length</b> is then increased repeatedly until the collision ratio satisfies a prescribed condition. We derive the optimal increment step size and the respective sequence of decision thresholds. Simulation results show that PRQT with initial <b>prefix</b> <b>length</b> adaptation can significantly reduce the expected tag read time for all range of tag set size {{when compared to the}} use of Query-Tree protocol. Index Terms — RFID, anti-collision, prefix. I...|$|E
3000|$|... [...]. To remove {{inter-block}} interference, a cyclic prefix {{is added}} {{at the beginning}} of the transmitted vectors at the source node. Let dwcpdenote the transmitted vector with cyclic <b>prefix,</b> the <b>length</b> of which is [...]...|$|R
40|$|Using 127 -Bit IPv 6 Prefixes on Inter-Router Links On inter-router {{point-to-point}} links, it is useful, {{for security}} and other reasons, to use 127 -bit IPv 6 prefixes. Such a practice parallels {{the use of}} 31 -bit prefixes in IPv 4. This document specifies the motivation for, and usages of, 127 -bit IPv 6 <b>prefix</b> <b>lengths</b> on inter-router point-to-point links. Status of This Memo This is an Internet Standards Track document. This document {{is a product of}} the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by th...|$|R
50|$|LCP array: Contains {{the maximum}} <b>length</b> <b>prefix</b> match between two {{consecutive}} suffixes, {{after they are}} sorted lexicographically.|$|R
3000|$|... {{which is}} a {{function}} of system’s parameters: number of subcarriers, number of users, and cyclic <b>prefix</b> <b>length.</b>|$|E
30|$|IP tunnel {{is created}} between the router(s) and the gateway. The <b>prefix</b> <b>length</b> of / 64 is assigned.|$|E
40|$|In this paper, a semi-blind {{time domain}} {{equalization}} technique is proposed for general MIMO-OFDM systems. The received OFDM symbols are shifted {{by more than}} or equal to the cyclic <b>prefix</b> <b>length</b> and a blind equalizer is designed to completely suppress both inter-carrier interference (ICI) and inter-symbol interference (ISI) using second-order statistics of the shifted received OFDM symbols. Only a one-tap equalizer is needed to detect the time domain signals from the blind equalizer output with the aid of one pilot OFDM symbol. The technique is applicable irrespective of whether the cyclic <b>prefix</b> <b>length</b> is longer than, equal to, or shorter than the channel length. Computer simulations show that the proposed technique outperforms the existing ones and it is robust against the number of shifts in excess of the cyclic <b>prefix</b> <b>length.</b> © 2006 IEEE. link_to_subscribed_fulltex...|$|E
5000|$|Send the JSON objects <b>prefixed</b> {{with their}} <b>length</b> {{and rely on}} a {{streaming}} parser to extract them.|$|R
3000|$|... are the {{transmitted}} {{data symbols}} at the n th subcarrier of the k th OFDM block. These data symbols {{are assumed to}} be independent identically distributed (i.i.d), D is the cyclic <b>prefix</b> (CP) <b>length,</b> and m ↦ g(m) is the pulse shaping filter.|$|R
30|$|Another crucial {{optimization}} we {{have implemented}} for IPv 6 {{is the use}} of CPE {{to reduce the number of}} required sets of Bloom filters and hash tables in the algorithm. This technique consists of expanding every prefix of a shorter length to multiple, equivalent, prefixes of a greater length, so that the number of distinct <b>prefix</b> <b>lengths</b> and, consequently, filters and hash tables, is reduced. In IPv 4, as previously discussed, we used CPE to expand prefixes into two groups: G 1 ∈ [21 – 24] and G 2 ∈ [25 – 32]. After the CPE, G 1 has only 24 -bit prefixes and G 2 has only 32 -bit prefixes, and two sets of Bloom filters and hash tables are allocated to store these prefixes.|$|R
