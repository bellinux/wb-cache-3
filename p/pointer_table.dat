10|23|Public
5000|$|The RAM is {{accessed}} at 3.072 MHz, with accesses multiplexed {{between the}} S-SMP (...) and the DSP (...) [...] This RAM {{is used to}} store the S-SMP code and stack, the audio samples and <b>pointer</b> <b>table,</b> and the DSP's echo buffer.|$|E
50|$|On x86-64 {{processors}} {{in native}} long mode, the address translation scheme uses PAE but adds a fourth table, the 512-entry page-map level 4 table, and extends the page directory <b>pointer</b> <b>table</b> to 512 entries {{instead of the}} original 4 entries it has in protected mode. Currently 48 bits of virtual page number are translated, giving a virtual address space of up to 256 TB.In the page table entries, in the original specification, 40 bits of physical page number are implemented.|$|E
5000|$|Because {{memory was}} a scarce resource, {{the authors of}} the Mac OS decided to take {{advantage}} of the unused byte in each address. The original Memory Manager (up until the advent of System 7) placed flags in the high 8 bits of each 32-bit pointer and handle. Each address contained flags such as [...] "locked", [...] "purgeable", or [...] "resource", which were stored in the master <b>pointer</b> <b>table.</b> When used as an actual address, these flags were masked off and ignored by the CPU.|$|E
40|$|International audienceThis paper {{presents}} {{the design of}} a GaAs VLSI implementation of an efficient table lookup algorithm to be used for label translation in a 2. 5 Gb/s ATM system. The algorithm is based on searching and uses <b>pointer</b> <b>tables</b> to guarantee a memory hit in less than 6 tries, corresponding to a conversion time of less than 170 ns in the current implementation. The label translator chip was implemented in a 0. 6 Âµm high-speed, low-power GaAs MESFET technology to meet the conversion time requirement and to reduce overall system power and complexity. The chip requires 4 Mbit of external SRAM supporting up to 30. 000 simultaneous connections...|$|R
5000|$|C {{does not}} have dynamic dispatch, {{so it must be}} {{implemented}} manually in some form. Often an enum is used to identify the subtype of an object. Dynamic dispatch can be done by looking up this value in a function <b>pointer</b> branch <b>table.</b> Here is a simple example in C: ...|$|R
40|$|Abstract. Modern {{object-oriented}} programming languages such as C++ provide convenient abstractions and data encapsulation mechanisms for software developers. However, these features also complicate testing and static analysis {{of programs that}} utilize {{object-oriented programming}} concepts. In particular, the C++ language exhibits features such as multiple inheritance, static and dynamic typecasting that make static analyzers for C++ quite hard to implement. In this paper, we present an approach where static analysis is performed by lowering the original C++ program into a semantically equivalent C program. However, unlike existing translation mechanisms that utilize complex pointer arithmetic operations, virtual-base offsets, virtual-function <b>pointer</b> <b>tables,</b> and calls to run-time libraries to model C++ features, our translation is targeted towards making static program analyzers for C++ easier to write and provide more precise results. We have implemented our ideas in a framework for C++ called CILpp that {{is analogous to the}} popular C Intermediate Language (CIL) framework. We evaluate the effectiveness of our translation in a bug finding tool that uses abstract interpretation and model checking. The bug finding tool uncovered several previously unknown bugs in C++ open source projects. ...|$|R
50|$|A video {{controller}} implementing a text mode usually uses two distinct areas of memory. Character memory or a pattern table contains a raster font in use, where each character {{is represented by}} a dot matrix (a matrix of bits), so the character memory could {{be considered as a}} three-dimensional bit array. Display matrix (a text buffer, screen buffer, or nametable) tracks which character is in each cell. In the simple case the display matrix can be just a matrix of code points (so named character <b>pointer</b> <b>table),</b> but it usually stores for each character position not only a code, but also attributes.|$|E
5000|$|Enabling PAE (by setting bit 5, , of {{the system}} {{register}} [...] ) causes major changes to this scheme. By default, the size of each page remains as 4 KB. Each entry in the page table and page directory becomes 64 bits long (8 bytes), instead of 32 bits, to allow for additional address bits. However, the size of each table does not change, so both table and directory now have only 512 entries. Because this allows only {{one half of the}} entries of the original scheme, an extra level of hierarchy has been added, so CR3 now points physically to a Page Directory <b>Pointer</b> <b>Table,</b> a short table containing four pointers to page directories.|$|E
50|$|The 64-bit {{addressing}} mode ("long mode") is a superset of Physical Address Extensions (PAE); because of this, page sizes may be 4 KB (212 bytes) or 2 MB (221 bytes). Long mode also supports page sizes of 1 GB (230 bytes). Rather than the three-level page table system used by systems in PAE mode, systems running in long mode use four levels of page table: PAE's Page-Directory <b>Pointer</b> <b>Table</b> is extended from 4 entries to 512, {{and an additional}} Page-Map Level 4 (PML4) Table is added, containing 512 entries in 48-bit implementations. In implementations providing larger virtual addresses, this latter table would either grow to accommodate sufficient entries to describe the entire address range, up to a theoretical maximum of 33,554,432 entries for a 64-bit implementation, or be over ranked by a new mapping level, such as a PML5. A full mapping hierarchy of 4 KB pages for the whole 48-bit space would take {{a bit more than}} 512 GB of RAM (about 0.195% of the 256 TB virtual space).|$|E
50|$|The Kenngruppenbuch {{consisted}} of two main parts. The first half {{consisted of}} the Column List (German:Spaltenliste) which consisted of all 17,576 of trigrams (Kenngruppen), divided into 733 numbered columns of 24 trigrams displayed in random order. The second half consists of the group list (German:Gruppenlist) where the trigrams are sorted in alphabetical order. After each trigam are 2 numbers, the first giving {{the number of the}} column in the Spaltenliste in which the trigram occurs, the second giving the position of the trigram in the column. The <b>table</b> <b>pointer,</b> or <b>table</b> selection chart (German:Tauschtafelplan) told the operator which column of a given table was used to select the required trigrams. By means of the Assignation list (German:Zuteilungsliste) told the radio man which table he should use for a particular cipher net. Large keys would be given several blocks of columns, small keys as few as 10.|$|R
5000|$|This class stores the {{database}} name and its tables.The main functions are: char *name (...) //get {{the database}} name char *name(char *dbname); //set the database name void new_tab(char *tabname); //create a new table table *get_tab(char *tabname); //return the <b>pointer</b> to the <b>table</b> ...|$|R
5000|$|C++ Technical Report 1 (TR1) is {{the common}} name for ISO/IEC TR 19768, C++ Library Extensions, which was a {{document}} proposing additions to the C++ standard library for the C++03 language standard. The additions include regular expressions, smart <b>pointers,</b> hash <b>tables,</b> and random number generators. TR1 was not a standard itself, but rather a draft document. However, most of its proposals {{became part of the}} later official standard, C++11. Before C++11 was standardized, vendors used this document as a guide to create extensions. The report's goal was [...] "to build more widespread existing practice for an expanded C++ standard library." ...|$|R
5000|$|...------------- {{interpreter}} --------------------------------------------* SR R14,R14 ********* Set R14=0 CALC IC R14,INPUT1 * calc * put EBCDIC byte into lo order bits (24-31) of R14 IC R14,CT1X(R14) * * use EBCDIC {{value as}} index on table 'CT1X' {{to get new}} index SLL R14,2 * * multiply index by 4 (additional instruction) FOUND L R15,CT1(R14) ********* get pointer to subroutine using index (0,4, 8 etc.) BALR R14,R15 Perform the sub-routine ("CALL" [...] and return or Default) B END go terminate this program * --------------- additional translate table (EBCDIC --> <b>pointer</b> <b>table</b> INDEX) 256 bytes----* CT1X DC 12AL1(00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00) 12 identical sets of 16 bytes of x'00' * representing X'00 - x'BF' DC AL1(00,01,00,00,04,00,00,00,00,00,00,00,00,00,00,00) [...].x'C0' - X'CF' DC AL1(00,00,00,00,03,00,00,00,00,00,00,00,00,00,00,00) [...].x'D0' - X'DF' DC AL1(00,00,02,00,00,00,00,00,00,00,00,00,00,00,00,00) [...].x'E0' - X'EF' DC AL1(00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00) [...].x'F0' - X'FF' * the assembler {{can be used to}} automatically calculate the index values and make the values more user friendly * (for e.g. '01' could be replaced with the symbolic expression 'PADD-CT1X/4' in table CT1X above) * modified CT1 (index now based on 0,1,2,3,4 not 0,4,8,12,16 to allow all 256 variations) CT1 DC A(DEFAULT) index =00 START of Control Table (4 byte address constants) PADD DC A(ADD) =01 PSUB DC A(SUBTRACT) =02 PMUL DC A(MULTIPLY) =03 PDIV DC A(DIVIDE) =04 * the rest of the code remains the same as the 2nd example ...|$|E
5000|$|To handle 64 {{different}} input values, approximately 85 {{lines of}} source code (or less) are required (mainly single line table entries) whereas multiple 'compare and branch' would require around 128 lines (the {{size of the}} binary is also almost halved - despite the additional 256 byte table required to extract the 2nd index). * ------------------ interpreter --------------------------------------------* SR R14,R14 ********* Set R14=0 CALC IC R14,INPUT1 * calc * put EBCDIC byte into lo order bits (24-31) of R14 IC R14,CT1X(R14) * * use EBCDIC value as index on table 'CT1X' to get new index FOUND L R15,CT1(R14) ********* get pointer to subroutine using index (0,4, 8 etc.) BALR R14,R15 Perform the sub-routine ("CALL" [...] and return or Default) B END go terminate this program * --------------- additional translate table (EBCDIC --> <b>pointer</b> <b>table</b> INDEX) 256 bytes----* CT1X DC 12AL1(00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00) 12 identical sets of 16 bytes of x'00 * representing X'00 - x'BF' DC AL1(00,04,00,00,16,00,00,00,00,00,00,00,00,00,00,00) [...].x'C0' - X'CF' DC AL1(00,00,00,00,12,00,00,00,00,00,00,00,00,00,00,00) [...].x'D0' - X'DF' DC AL1(00,00,08,00,00,00,00,00,00,00,00,00,00,00,00,00) [...].x'E0' - X'EF' DC AL1(00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00) [...].x'F0' - X'FF' * the assembler {{can be used to}} automatically calculate the index values and make the values more user friendly * (for e.g. '04' could be replaced with the symbolic expression 'PADD-CT1' in table CT1X above) * modified CT1 (added a default action when index = 00, single dimension, full 31 bit address) CT1 DC A(DEFAULT) index =00 START of Control Table (4 byte address constants) PADD DC A(ADD) =04 PSUB DC A(SUBTRACT) =08 PMUL DC A(MULTIPLY) =12 PDIV DC A(DIVIDE) =16 * the rest of the code remains the same as first example ...|$|E
40|$|In {{this study}} a new {{approach}} is proposed for partitioning and storing data cube efficiently. The new method partition the storage of the cube into multiple tables and uses a <b>pointer</b> <b>table</b> to link attribute combinations to attribute values. Experiments on synthetic and real data sets show that the required storage for the new method is about 60 % of that required for flat table cube. Also the proposed approach {{has the advantage of}} fast access to the attribute values. Also it supports fast roll up and drill down without the need of any indexes for the attribute values...|$|E
50|$|The next example below {{illustrates}} how {{a similar effect}} can be achieved in languages that do not support pointer definitions in data structures but do support indexed branching to a subroutine - contained within a (0-based) array of subroutine <b>pointers.</b> The <b>table</b> (CT2) is used to extract the index (from 2nd column) to the pointer array (CT2P). If pointer arrays are not supported, a SWITCH statement or equivalent {{can be used to}} alter the control flow to one of a sequence of program labels (e.g.: case0,case1,case2,case3,case4) which then either process the input directly, or else perform a call (with return) to the appropriate subroutine (default,Add,Subtract,Multiply or Divide,..) to deal with it.|$|R
5000|$|Typically, the {{compiler}} {{creates a}} separate vtable for each class. When an object is created, a pointer to this vtable, called the virtual <b>table</b> <b>pointer,</b> vpointer or VPTR, is added as a hidden {{member of this}} object. As such, the compiler must also generate [...] "hidden" [...] code in the constructors of each class to initialize a new object's vpointer to the address of its class's vtable.|$|R
50|$|C++ compilers {{typically}} implement {{dynamic dispatch}} with a data structure called a virtual table (vtable) {{that defines the}} message-to-method mapping for a given class (C++ as such has no notion of a vtable). Instances of that type will then store a <b>pointer</b> to this <b>table</b> {{as part of their}} instance data. This is complicated when multiple inheritance is used. Since C++ does not support late binding, the virtual table in a C++ object cannot be modified at run-time, which limits the potential set of dispatch targets to a finite set chosen at compile time.|$|R
30|$|The {{handover}} between domains is {{not defined}} in PMIPv 6, but the movement between domains is frequent, {{according to the}} development of transportation, and diversification into mobile devices. The mobility of Inter-domain causes high handover delay, packet loss and signaling overhead, according to the fast-moving of the MN. For this reason, two methods of a pointer forwarding scheme are proposed. First, when MN moves inter domain, make a pointer forwarding chain between the domains (LMA). The PMIPv 6 handover between domains is not clearly defined. This is because of the not defined part of the information sharing of the home network prefix (HNP), when the MN moves from pLMA to nLMA. However, when MN enters from pLMA to nLMA area, nLMA, to run the connection (LMA of the CN another), based on the information of HNP received from pLMA, by running the binding update to request HNP information to pLMA, must perform a binding update. This is the point of the packet loss and handover delay, according to heavy signaling overhead occurring. So pointer forwarding between pLMA and nLMA is supposed to set, and LMA (the distance between pLMA and nLMA) is much shorter than sending a binding update to CN (LMA connected to MN). This can reduce the high signaling overhead of the binding update that occurs during the movement of the LMA in the PMIPv 6 network environment. The pointer forwarding scheme maintains a <b>pointer</b> <b>table</b> (PT) per each LMA. Each PT consists of four fields: ID 1, ID 2, CURRENT. The ID 1 field is composed of MN-HoA that is connected to the first, ID 2 field is composed of MN-ID and CURRENT field uses LMAA (LMA address) of pLMA. But, the NEXT field is composed of LMAA (LMA address) of nLMA, to move next. For example, if the value of the NEXT field is NULL, then the value of CURRENT field is LMAA of LMA, so this means that MN stays in the CURRENT LMA.|$|E
5000|$|Given a query , {{check if}} it is {{completely}} contained inside a block, {{in which case the}} answer is stored in table [...] If the query spans exactly one or more blocks, then the answer is found in table [...] Otherwise, use the <b>pointer</b> stored in <b>table</b> [...] at position , where [...] are the indices of the blocks that contain respectively [...] and , to find the table [...] that contains the positions of the mode for these blocks and use the position to find the mode in [...] This can be done in constant time.|$|R
50|$|The subroutines may be coded {{either in}} the same {{language}} as the interpreter itself or any other supported program language (provided that suitable inter-language 'Call' linkage mechanisms exist). The choice of language for the interpreter and/or subroutines will usually depend upon how portable {{it needs to be}} across various platforms. There may be several versions of the interpreter to enhance the portability of a control table. A subordinate control <b>table</b> <b>pointer</b> may optionally substitute for a subroutine pointer in the 'action' column(s) if the interpreter supports this construct, representing a conditional 'drop' to a lower logical level, mimicking a conventional structured program structure.|$|R
5000|$|Token {{threaded}} code uses {{lists of}} 8 or 12-bit indexes to a <b>table</b> of <b>pointers.</b> Token threaded code is notably compact, without much special effort by a programmer. It is usually half to three-fourths {{the size of}} other threaded-codes, which are themselves a quarter to an eighth the size of compiled code. The <b>table's</b> <b>pointers</b> can either be indirect or direct. Some Forth compilers produce token threaded code. Some programmers consider the [...] "p-code" [...] generated by some Pascal compilers, {{as well as the}} bytecodes used by [...]NET, Java, BASIC and some C compilers, to be token-threading.|$|R
5000|$|The terms [...] "{{personal}} web site", [...] "personal home page", [...] "home page" [...] or [...] "homepage" [...] {{are also}} {{used to refer to}} personal web pages. These terms do not usually refer to just a single [...] "page" [...] or HTML file, but to a collection of webpages and related files under a common URL or Web address. In strictly technical terms, a site's actual home page (index page) often only contains sparse content with some catchy introductory material and serves mostly as a <b>pointer</b> or <b>table</b> of contents to the more content-rich pages inside, such as rÃ©sumÃ©s, family, hobbies, family genealogy, a web log/diary ("blog"), opinions, online journals and diaries or other writing, examples of written work, digital audio sound clips, digital video clips, digital photos, or information about a user's other interests. [...] Many personal pages only include information of interest to friends and family of the author. However, some webpages set up by hobbyists or enthusiasts of certain subject areas can be valuable topical web directories.|$|R
30|$|After the {{firmware}} operations, the kernel is uncompressed {{and loaded}} by the bootloader (GNU GRUB in our experiment). Linux kernel modules and drivers are then loaded and initialized. DMAR is configured {{by one of}} these drivers. The Intel IOMMU driver creates the translation structures and writes them in the main DRAM. It builds the address translation domains and device to domain mapping before copying the root <b>table</b> <b>pointer</b> into the associated register. Finally, the driver activates DMAR by setting the TE bit of the GCMD Register. Let us note that these structures are stored in memory in areas not protected by any security mechanism.|$|R
5000|$|The {{memory mapped}} access method {{is very easy}} to use; each device has its own 4KB space and each device's info is {{accessible}} through a simple array devbusdevicefunction so that 256MB of physical contiguous space is [...] "stolen" [...] for this use (256bus * 32dev *8func *4k = 256MB). The messy thing is how to find the base physical address of that array. On Intel machines for example you have to walk through BIOS/ACPI tables to get this info. Basically you have to start searching for first table in bios area (0xF0000:0xFFFFF) looking for this ASCII signature [...] "RSD PTR [...] " [...] (8 bytes). This <b>table</b> stores the <b>pointer</b> to XSDT <b>table</b> ...|$|R
50|$|A cursor is {{a logical}} <b>pointer</b> within a <b>table</b> index. The cursor may be {{positioned}} on a record, before the first record, after the last record or even between records. If a cursor is positioned before or after a record, there is no current record. It is possible to have multiple cursors into the same table index. Many record and column operations {{are based on the}} cursor position. Cursor position can be moved sequentially by Move operations or directly using index keys with Seek operations. Cursors can also be moved to a fractional position within an index. In this way, the cursor can be quickly moved to a thumb bar position. This operation is performed with the same speed as a Seek operation. No intervening data must be accessed.|$|R
40|$|Jasmine/C is a C-based {{database}} proqramninq {{language that}} allows the handling of persistent objects in Jasmine databases. The language is used to write methods for objects and application programs. Both navigational and associative access to objects are supported. Dot notation is used for Jasmine/C queries. Attributes of different (but linked) objects are concatenated in SQL-like queries free of from-clauses. This allows the joining of objects without explicit join-predicates. Several new features are introduced into the architecture of Jasmine. Memory KB is a memory-based database where each object is accessed via a pointer. Tuples in XDE (the lower layer of Jasmine), when in database buffers, can also be accessed via <b>pointers.</b> NF 2 <b>tables</b> are supported for clustering values for multiple-valued attributes; these allow faster execution of Jasmine/C programs. 1...|$|R
40|$|Dendroecological studies began 20 {{years ago}} at the Phytoecological Laboratory of the Na-tional Agronomic Research Institute in France (INRA). Large surveys have been carried out in several {{geographical}} regions and forests allowing the study of radial growth of individual trees during the past 150 years. This contribution focuses on the analysis of pointer years and summarizes the results ob-tained for 8 species (Fagus sylvatica, Quercus petraea, Quercus robur, Fraxinus excelsior, Abies alba, Pinus uncinata, Pinus sylvestris, Picea abies) and 12 regions (with an average of 500 analysed trees for each study). This first dataset is supplemented by the data collected on 40 sites and 5 species of the French Permanent Network for the Monitoring of Forest Ecosystems (RENECOFOR â European Network â Level II plots). The frequency and amplitude of pointer years are discussed according to the species and the sampling areas. A multivariate analysis of the sites x <b>pointer</b> years <b>table</b> allows an ordi-nation of species according to their sensitivity to climatic factors. Fagus sylvatica seems to be the most âsensitiveâ species to inter-annual climatic variations whatever its location and, for the whole sample, regional and species effects are pointed out. The number of pointer years observed in a given stand is strongly correlated with the average site dryness, clearly showing that spatial variations of drought control tree radial growth. We finally analyse the interannual correlation between water stress variations and pointer years...|$|R
40|$|Page <b>table</b> <b>pointer</b> caches are a {{hardware}} supplement for TLBs that cache pointers to pages of page table entries rather than page table entries themselves. A PTPC traps and handles most TLB misses in hardware with low overhead (usually a single memory access). PTPC misses are filled in software, allowing {{for an easy}} hardware implementation, similar in structure to a TLB. Since each PTPC entry refers to an entire page of page table entries, even a small PTPC maps {{a large amount of}} address space and achieves a very high hit rate. The primary goal of a PTPC is to lower TLB miss handling penalties. The combination of a TLB with a small PTPC provides good performance even in situations where standard TLBs alone perform badly (large workloads or multimedia applications). The advantage of this design is that we can continue to use small fixed size pages with standard TLBs. Since PTPCs use traditional page table structures and page sizes, they are very simple to implement in hardware and requir [...] ...|$|R
40|$|AbstractâSeveral {{defenses}} {{have increased}} the cost of tradi-tional, low-level attacks that corrupt control data, e. g. return addresses saved on the stack, to compromise program execution. In response, creative adversaries have begun circumventing these defenses by exploiting programming errors to manipulate <b>pointers</b> to virtual <b>tables,</b> or vtables, of C++ objects. These attacks can hijack program control flow whenever a virtual method of a corrupted object is called, potentially allowing the attacker to gain complete control of the underlying system. In this paper we present SAFEDISPATCH, a novel defense to prevent such vtable hijacking by statically analyzing C++ programs and inserting sufficient runtime checks to ensure that control flow at virtual method call sites cannot be arbitrarily influenced by an attacker. We implemented SAFEDISPATCH as a Clang++/LLVM extension, used our enhanced compiler to build a vtable-safe version of the Google Chromium browser, and measured the performance overhead of our approach on popular browser benchmark suites. By carefully crafting a handful of optimizations, {{we were able to}} reduce average runtime overhead to just 2. 1 %. I...|$|R
40|$|In this paper, {{we focus}} on a class of buffer {{overflow}} vulnerabilities that occur due to the 2 Ì 2 placement new 2 Ì 72 Ì 7 expression in C++. 2 Ì 2 Placement new 2 Ì 72 Ì 7 facilitates placement of an object/array at a specific memory location. When appropriate bounds checking is not in place, object overflows may occur. Such overflows can lead to stack as well as heap/data/bss overflows, which can be exploited by attackers in order {{to carry out the}} entire range of attacks associated with buffer overflow. Unfortunately, buffer overflows due to 2 Ì 2 placement new 2 Ì 72 Ì 7 have neither been studied in the literature nor been incorporated in any tool designed to detect and/or address buffer overflows. In this paper, we show how the 2 Ì 2 placement new 2 Ì 72 Ì 7 expression in C++ can be used to carry out buffer overflow attacks - on the stack as well as heap/data/bss. We show that overflowing objects and arrays {{can also be used to}} carry out virtual <b>table</b> <b>pointer</b> subterfuge, as well as function and variable pointer subterfuge. Moreover, we show how 2 Ì 2 placement new 2 Ì 2 can be used to leak sensitive information, and how denial of service attacks can be carried out via memory leakage...|$|R
40|$|First {{the basic}} {{definition}} of information as a selection from {{a set of}} possibilities resp. domain is recalled. This also applies to digital information. The bits of digital information are parts of number sequences which represent a selection from a set of possibilities resp. domain. For faultless conversation sender and receiver of information must have the same definition of the domain (e. g. of language vocabulary). Up to now {{the definition of the}} domain and of its elements is derived from context and knowledge. The internet provides an additional important possibility: A link to a conjoint uniform definition of the domain at unique location on the internet. The associated basic information structure is called "Domain Vector" (DV) and has the structure "UL (of the domain definition) plus sequence of numbers". The "UL" is not only "Uniform Locator" of the domain definition. It also identifies a certain kind of information for later comparison and search. It can be a Uniform Resource Locator (URL) or an abbreviated equivalent, e. g. a hierarchic numeric pointer or a short local <b>pointer</b> to a <b>table</b> with global internet pointers. The DV structure can be used as general carrier of information which is language independent and more precise than language. A domain which contains DVs is called "Domain Space" (DS) and is defined as metric space. This allows similarity search according to user defined criteria, so that any kind of definable information can be made comparable and searchable according to user selected (relevant) and objectifiable (globally uniform) criteria. DS definitions can be reused in new DS definitions. Their elements, the DVs, are automatically globally uniformly identified and defined. Obviously such conjoint definition of comparable information has great potential. It also can avoid interoperability problems and redundant programming and so save high costs. Comment: 15 pages, 4 figure...|$|R
40|$|This Research is {{constituted}} by phenomenon which enough tickle researcher natural existence. Mass media and inseparable caricature generally. Attend cartoon him or caricature become oasis {{in the middle}} of news bombardir of actual lifted. As real as cartoon and caricature is matter leaving for back, even cannot be told is a same. Cartoon more is emphasizing at of comedy element and depiction of illustration do not experience of "distortion", but caricature is a more emphasizing picture of element "in disorder" in its illustration. Intrude such is depiction to something given by payload more and sold on element of satire (certain satire people). But in so many cartoon mass media and caricature assumed by same thing. Pakarti is one of them. a cartoon community of indonesia, but if us see its depiction there many there are caricature picture compared to cartoon. Panji Koming more is precise referred as by caricature compared to cartoon, but G. M Sudharta (drawer) alone mention cartoonist itâs self is not caricaturist. This represent matter which lame. Researcher interest to study caricature which there are in is serial of book prohibited is impecunious of composition of Eko Prasetyo, because this book according to researcher " success" article converge (text) with caricature picture. This matter become to differ of the book is other. Though this book adapting a story many quantitative data "weight" what it is true circulating many at medium print. Kompas, Swa, Gatra, Republika, etc. The data if without "help" caricature will felt is saturated. Furthermore in meaning caricature in the book namely Pauper Prohibited by School (January, 2005), Pauper Without Subsidy (April, 2005) and also Pauper Prohibited by Pain (April, 2005) we need to pay attention meaning hidden at aspect "seen". Interest of researcher do not desist there, hereinafter researcher more interest to comment caricature which framing pauper action, because according to researcher, not many people which is concern to marginal majority clan. Caricaturist in illustrating impecunious people face really interesting. Pauper emerge in frame concerning, and according to caricaturist require to feel pity for. Researcher formulate the problem of how sign meaning and message at caricature having element lame, dissonant, barst and also in book prohibited is impecunious, and also why marking which implied in 31 caricature meant that way? To easy to mean sign which implied in caricature, researcher use analysis of semiotic property of Charles Sanders Pierce pursuant to icon, index, and symbol of Roland Barthes about konotasi, myth, and to strengthen analysis, researcher use what is in caricature in is serial of book prohibited impecunious there are culture code namely, hermeunitika, semantic, symbolic, naration, and cultural. By using analysis above, researcher can catch meaning at the opposite of between the line meaning of caricature. Namely sign which emerge is caricature in impecunious prohibited serial is always depicted with oposition of element "rich", this matter of researcher assess to confirm pauper to be remain to and impecunious always is. Furthermore of pauper being construct through some element supporting namely in all day long its of pauper always used shirts, short pants, have singlet, slipper footgear to nip frequent even do not use footgear. its Face expression is always embosomed by sorrow, hopeless, and any accept everthing that happened. Work of pauper framed to embosom shoe polish, flank labour, TKI, farmer, seller of tempe fry, beggar, PKL. This Matter is later then re-confirmed that pauper only "can" have bicycle transportation appliance of kebo bike. Important sign emerging later then is that pauper easy to once dumbweed-provote-even to the reason of absurd even if. Researcher caricature study the first time use approach of Pierce through tables, what is in the caricature there are icon, and index of symbol. Being easy to be made by <b>pointer</b> in the <b>tables</b> which later will be explained again with approach of Barthes conotation through culture code and myth. Conotation will emerge at third aspect, first aspect and Secondness emerge in perception of caricature and also writing of pointer. Thirdness is final aspect of caricature study which is researcher lean at culture code and myth. Dissonant text content namely caricaturist "framing" pauper figure which is easy to be cheated even with reason of illogical. Created of caricature "impecunious" with character "rich" frequent so many, this matter solely researcher what have show above utilizing to confirm pauper really impecunious. From researcher data analysis give practical suggestion namely depiction in pauper book without subsidy of peniliti assess have precisely, but at book hereinafter if with comic illustration, hence got by situation is reader in meaning repsentasi of this problem of which is lifted (pass/through) caricature less precise. Do not only fulfilling requirement of market, but in representated of is problem of which is lifted as real as passing real correct caricature of caricature is precise matter. Concerning place setting must strenghtened again with other supporter instrument, do not just sit side by side (among/between) the rich and the just impecunious, for example. While suggestion of academic expected study of to semiotic at caricature can be expostulated is furthermore, so that add exchequer of discourse about difference of cartoon and caricature so to be used in " scope" correct...|$|R

