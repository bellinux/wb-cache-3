0|429|Public
5000|$|Automatically Defined Functions and Automatically <b>Defined</b> <b>Macros</b> ...|$|R
5000|$|... errno.h, a header file in C that <b>defines</b> <b>macros</b> for {{reporting}} errors ...|$|R
5000|$|The header file also <b>defines</b> <b>macros</b> that {{expand to}} integer {{constants}} {{that represent the}} error codes. The C standard library only requires three to be defined: ...|$|R
5000|$|All valid Java {{programs}} are also valid AspectJ programs, but AspectJ lets <b>programmers</b> <b>define</b> special constructs called aspects. Aspects can contain several entities unavailable to standard classes. These are: ...|$|R
50|$|<b>Macros</b> are <b>defined</b> by the defmacro macro. The special {{operator}} macrolet {{allows the}} definition of local (lexically scoped) macros. It is also possible to <b>define</b> <b>macros</b> for symbols using define-symbol-macro and symbol-macrolet.|$|R
50|$|The {{definition}} section <b>defines</b> <b>macros</b> {{and imports}} header files written in C. It {{is also possible}} to write any C code here, which will be copied verbatim into the generated source file.|$|R
5000|$|... errno.h is a header file in the {{standard}} library of the C programming language. It <b>defines</b> <b>macros</b> for reporting and retrieving error conditions through error codes stored in a static memory location called [...] (short for [...] "error number").|$|R
5000|$|Cole <b>defined</b> <b>Macro</b> Life as [...] "life squared per cell", i.e. [...] "Macro Life is to man {{what man}} {{is to the}} cell". Zebrowski, in the novel, regards Macrolife as an open-ended, {{expansive}} union of organic, cybernetic and machine intelligences (human and alien) with spacefaring as its means of dissemination.|$|R
5000|$|The <b>programmer</b> <b>defines</b> a type {{class by}} specifying {{a set of}} {{function}} or constant names, together with their respective types, that must exist for every type that belongs to the class. In Haskell, types can be parameterized; a type class [...] intended to contain types that admit equality would be declared in the following way: ...|$|R
2500|$|<b>Programmers</b> may <b>define</b> {{their own}} {{exceptions}} by deriving from the [...] class.|$|R
5000|$|<b>Programmers</b> {{typically}} <b>define</b> a XUL interface {{as three}} discrete sets of components: ...|$|R
2500|$|<b>Define</b> a <b>macro</b> to {{implement}} a variant of [...] "if" [...] with a multi-expression ...|$|R
50|$|A nonpreemptive {{multitasking}} {{system is}} very similar to the simple control loop scheme, except that the loop is hidden in an API. The <b>programmer</b> <b>defines</b> a series of tasks, and each task gets its own environment to “run” in. When a task is idle, it calls an idle routine, usually called “pause”, “wait”, “yield”, “nop” (stands for no operation), etc.|$|R
5000|$|... <b>defines</b> a <b>macro</b> {{introducing}} the ford (EXPR EXPR) EXPR syntax {{and can be}} used like ...|$|R
50|$|Besides those {{mentioned}} in the table above, a <b>programmer</b> can <b>define</b> pointers, user-defined types and unions.|$|R
50|$|An XML {{framework}} is a Software framework that implements features {{to aid the}} programmer in creating applications with all data produced in XML. The <b>programmer</b> <b>defines</b> and produces pure data in XML format and the framework transforms the document to any format desired. One code, one XML and several transformations like XHTML, SVG, WML, Excel or Word format, or other document type may result.|$|R
5000|$|SequenceL is {{strictly}} evaluated (like Lisp), statically typed with type inference (like Haskell), {{and uses a}} combination of infix and prefix operators that resemble standard, informal mathematical notation (like C, Pascal, Python, etc.). It is a purely declarative language, meaning that a <b>programmer</b> <b>defines</b> functions, in the mathematical sense, without giving instructions for their implementation. For example, the mathematical definition of matrix multiplication is as follows: ...|$|R
40|$|TPS is a card-based word {{processor}} {{for use with}} the IBM OS/MVT operating system. TPS commands are imbedded in the free-format text input stream. User <b>defined</b> <b>macros</b> (with arguments) and a report generator macro library, (TPSLIB) provide automated formatting facilities similiar to those available from a competent technical typist. This report is a primer for TPS and TPSLIB; appendices provide detailed reference information and examples. (Author) [URL]...|$|R
50|$|Other {{reducers}} {{can be used}} {{to construct}} linked lists or strings, and <b>programmers</b> can <b>define</b> custom reducers.|$|R
50|$|Another way is by <b>defining</b> a {{symbolic}} <b>macro.</b> Many high-level programming languages, and many assemblers, offer a macro facility where the <b>programmer</b> can <b>define,</b> generally {{at the beginning}} of a source file or in a separate definition file, names for different values. A preprocessor then replaces these names with the appropriate values before compiling, resulting in something functionally identical to using literals, with the speed advantages of immediate mode. Because it can be difficult to maintain code where all values are written literally, if a value is used in any repetitive or non-obvious way, it is often done as a macro.|$|R
50|$|By using a {{user-defined}} copy constructor the <b>programmer</b> can <b>define</b> {{the behavior}} {{to be performed}} when an object is copied.|$|R
50|$|Using this datatype the <b>programmer</b> has <b>defined</b> a {{variable}} called v_address and loaded it {{with data from}} the ADDRESS table.|$|R
2500|$|Both Common Lisp and Scheme {{also support}} the backquote {{operator}} (termed quasiquote in Scheme), entered with the [...] character (grave accent). This {{is almost the}} same as the plain quote, except it allows expressions to be evaluated and their values interpolated into a quoted list with the comma [...] unquote and comma-at [...] splice operators. If the variable [...] has the value [...] then [...] evaluates to , while [...] evaluates to [...] The backquote is most often used in <b>defining</b> <b>macro</b> expansions.|$|R
5000|$|The game {{world is}} defined via a {{dedicated}} language, named DXW (DimensioneX World) format. The syntax lets the <b>programmer</b> to <b>define</b> rooms, doors/links, items, characters.|$|R
5000|$|Looping is then {{possible}} by <b>defining</b> a <b>macro</b> which (conditionally) reinvokes itself. A simple factorial {{of the top}} of the stack might be implemented as: ...|$|R
30|$|Using {{high-level}} scalable models, a <b>programmer</b> <b>defines</b> {{only the}} high-level logic of an application while hides the low-level details {{that are not}} essential for application design, including infrastructure-dependent execution details. A programmer is assisted in application definition and application performance depends on the compiler that analyzes the application code and optimizes its execution on the underlying infrastructure. On the other hand, low-level scalable models allow programmers to interact directly with computing and storage elements composing the underlying infrastructure and thus define the applications parallelism directly.|$|R
5000|$|In general, the widths and {{representation}} scheme implemented {{for any given}} platform are chosen based on the machine architecture, with some consideration given to the ease of importing source code developed for other platforms. The width of the int type varies especially widely among C implementations; it often corresponds to the most [...] "natural" [...] word size for the specific platform. The standard header limits.h <b>defines</b> <b>macros</b> for the minimum and maximum representable values of the standard integer types as implemented on any specific platform.|$|R
40|$|Monads {{are widely}} used in Haskell for {{modeling}} computational effects, but defining monads remains a daunting challenge. Since every part of a monad’s definition depends on its computational effects, programmers cannot leverage the common behavior of all monads easily and thus must build from scratch each monad that models a new computational effect. I propose the Unimo framework which allows <b>programmers</b> to <b>define</b> monads and monad transformers in a modular manner. Unimo contains a heavily parameterized observer function which enforces the monad laws, and <b>programmers</b> <b>define</b> a monad by invoking the observer function with arguments that specify the computational effects of the monad. Since Unimo provides the common behavior of all monads in a reusable form, programmers {{no longer need to}} rebuild the semantic boilerplate for each monad and can instead focus on the more interesting and rewarding task of modeling the desired computational effects...|$|R
3000|$|Basically, all Quartz {{programs}} {{can be reduced to}} the following set of basic statements, which can be used to <b>define</b> further <b>macro</b> statements as syntactic sugar: [...]...|$|R
50|$|Most {{languages}} have a fixed set {{of statements}} {{defined by the}} language, {{but there have been}} experiments with extensible languages that allow the <b>programmer</b> to <b>define</b> new statements.|$|R
40|$|Abstract—This tool demo paper {{describes}} a tool called XToF {{which is being}} developed through a collaboration between the University of Victoria, the University of Namur and the Univer-sity of Waterloo. The purpose of the tool is to let <b>programmers</b> <b>define,</b> maintain, visualise and exploit precise traceability links between a feature diagram and the code base of a software product line. The resulting tool supports automated configuration of a Java or C code base and is minimally intrusive with respect to development practices. Index Terms—tool demo; software product line; feature dia-gram; tagging; programming language; C; Jav...|$|R
50|$|The {{practical}} use of advice functions is generally to modify or otherwise extend {{the behavior of}} functions which cannot be easily modified or extended. The Emacspeak Emacs-addon makes extensive use of advice: it must modify thousands of existing Emacs modules and functions such that it can produce audio output for the blind corresponding to the visual presentation, {{but it would be}} infeasible to copy all of them and redefine them to produce audio output in addition to their normal outputs; so, the Emacspeak <b>programmers</b> <b>define</b> advice functions which run before and after.|$|R
5000|$|A {{programmer}} {{can make}} any type [...] {{a member of}} a given type class [...] by using an instance declaration that defines implementations of all of 's methods for the particular type [...] For instance, if a <b>programmer</b> <b>defines</b> a new data type , they may then make this new type an instance of [...] by providing an equality function over values of type [...] in whatever way they see fit. Once they have done this, they may use the function [...] on , that is, lists of elements of type [...]|$|R
50|$|When {{starting}} a PBASIC file, the <b>programmer</b> <b>defines</b> {{the version of}} the BASIC Stamp and the version of PBASIC that will be used. Variables and constants are usually declared first thing in a program. The DO LOOP, FOR NEXT loop, IF and ENDIF, and some standard BASIC commands {{are part of the}} language, but many commands like PULSOUT, HIGH, LOW, DEBUG, and FREQOUT are native to PBASIC and are used for special purposes that are not available in traditional BASIC (such as having the Basic Stamp ring a piezoelectric speaker, for example).|$|R
50|$|The <b>programmer</b> {{can also}} <b>define</b> custom data types in resources.|$|R
50|$|SIGHUP can be handled. That is, <b>programmers</b> can <b>define</b> {{the action}} {{they want to}} occur upon {{receiving}} a SIGHUP, such as calling a function, ignoring it, or restoring the default action.|$|R
