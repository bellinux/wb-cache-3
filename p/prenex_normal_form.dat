73|10000|Public
2500|$|Many identities can be proved, which {{establish}} equivalences between particular formulas. These identities {{allow for}} rearranging formulas by moving quantifiers across other connectives, and {{are useful for}} putting formulas in <b>prenex</b> <b>normal</b> <b>form.</b> Some provable identities include: ...|$|E
2500|$|Because every formula has a <b>prenex</b> <b>normal</b> <b>form,</b> every formula in the {{language}} of second-order arithmetic is [...] or [...] for some [...] [...] Because meaningless quantifiers can be added to any formula, once a formula is given the classification [...] or [...] for some [...] it will be given the classifications [...] and [...] for all [...] greater than [...]|$|E
2500|$|Many {{common rules}} of {{inference}} are only valid when {{the domain of}} discourse is required to be nonempty. One example is the rule stating that [...] implies [...] when x is not a free variable in [...] This rule, {{which is used to}} put formulas into <b>prenex</b> <b>normal</b> <b>form,</b> is sound in nonempty domains, but unsound if the empty domain is permitted.|$|E
40|$|The Propositional CalculusPropositional Connectives. Truth TablesTautologies Adequate Sets of Connectives An Axiom System for the Propositional Calculus Independence. Many-Valued LogicsOther AxiomatizationsFirst-Order Logic and Model TheoryQuantifiersFirst-Order Languages and Their Interpretations. Satisfiability and Truth. ModelsFirst-Order TheoriesProperties of First-Order Theories Additional Metatheorems and Derived Rules Rule C Completeness Theorems First-Order Theories with EqualityDefinitions of New Function Letters and Individual Constants <b>Prenex</b> <b>Normal</b> <b>Forms</b> Isomorphism of Interpretat...|$|R
40|$|Abstract. The paper {{considers}} the strong bisimilarity/similarity check-ing problems for CCSµ and CCS!, two typical variants of CCS. The strong bisimilarity of the CCSµ/CCS! processes {{is shown to}} be Π 01 -complete, even when the processes are restricted to the restriction <b>prenex</b> <b>normal</b> <b>forms.</b> The strong bisimilarity between a CCS!/CCSµ process and a fixed regular process is also shown to be Π 01 -complete. The paper also estab-lishes the decidability of the similarity problem of a regular process by a CCS! process. ...|$|R
40|$|Abstract. We {{present the}} {{framework}} [q]bfGen {{which allows the}} declar-ative specification of random models for generating SAT and QSAT formulas not necessarily in (<b>prenex)</b> conjunctive <b>normal</b> <b>form.</b> To this end, [q]bfGen realizes a generic formula generator which creates formula instances by interpreting the random model specification expressed in XML. Consequently, the implementation of specific random formula gen-erators becomes obsolete, because our framework subsumes their func-tionality. ...|$|R
2500|$|Because every {{formula is}} {{equivalent}} to a formula in <b>prenex</b> <b>normal</b> <b>form,</b> every formula with no set quantifiers is assigned at least one classification. [...] Because redundant quantifiers {{can be added to}} any formula, once a formula is assigned the classification [...] or [...] it will be assigned the classifications [...] and [...] for every m greater than n. [...] The most important classification assigned to a formula is thus the one with the least n, because this is enough to determine all the other classifications.|$|E
5000|$|Every formula in {{classical}} logic {{is equivalent to}} a formula in <b>prenex</b> <b>normal</b> <b>form.</b> For example, if , , and [...] are quantifier-free formulas with the free variables shown thenis in <b>prenex</b> <b>normal</b> <b>form</b> with matrix , whileis logically equivalent but not in <b>prenex</b> <b>normal</b> <b>form.</b>|$|E
50|$|Every {{formula is}} {{equivalent}} to a formula in <b>prenex</b> <b>normal</b> <b>form,</b> where we first write quantification on variable on second order and then a FO-formula in <b>prenex</b> <b>normal</b> <b>form.</b>|$|E
40|$|Abstract. We present DepQBF 0. 1, a new search-based solver for {{quantified}} boolean formulae (QBF). It integrates compact dependency graphs {{to overcome}} the restrictions imposed by linear quantifier prefixes of QBFs in <b>prenex</b> conjunctive <b>normal</b> <b>form</b> (PCNF). DepQBF 0. 1 was placed first in the main track of QBFEVAL’ 10 in a score-based ranking. We provide a general system overview and describe selected orthogonal features such as restarts and removal of learnt constraints. ...|$|R
40|$|We present DepQBF 0. 1, a new search-based solver for {{quantified}} boolean formulae (QBF). It integrates compact dependency graphs {{to overcome}} the restrictions imposed by linear quantifier prefixes of QBFs in <b>prenex</b> conjunctive <b>normal</b> <b>form</b> (PCNF). DepQBF 0. 1 was placed first in the main track of QBFEVAL’ 10 in a score-based ranking. We provide a general system overview and describe selected orthogonal features such as restarts and removal of learnt constraints. Keywords: QBF solving, DPLL, dependency schemes, restart...|$|R
40|$|This paper {{describes}} a decision procedure for disjunctions of conjunctions of anti-prenex <b>normal</b> <b>forms</b> of pure first-order logic (FOLDNFs) {{that do not}} contain ∨ {{within the scope of}} quantifiers. The disjuncts of these FOLDNFs are equivalent to <b>prenex</b> <b>normal</b> <b>forms</b> whose quantifier-free parts are conjunctions of atomic and negated atomic formulae (= Herbrand formulae). In contrast to the usual algorithms for Herbrand formulae, neither skolemization nor unification algorithms with function symbols are applied. Instead, a procedure is described that rests on nothing but equivalence transformations within pure first-order logic (FOL). This procedure involves the application of a calculus for negative <b>normal</b> <b>forms</b> (the NNF-calculus) with A A ∧ A (= ∧I) as the sole rule that increases the complexity of given FOLDNFs. The described algorithm illustrates how, in the case of Herbrand formulae, decision problems can be solved through a systematic search for proofs that reduce the number of applications of the rule ∧I to a minimum in the NNF-calculus. In the case of Herbrand formulae, it is even possible to entirely abstain from applying ∧I. Finally, it is shown how the described procedure can be used within an optimized general search for proofs of contradiction and what kind of questions arise for a ∧I-minimal proof strategy {{in the case of a}} general search for proofs of contradiction. Comment: 30 pages, 2 figure...|$|R
5000|$|Every first-order {{formula is}} logically {{equivalent}} (in classical logic) to some formula in <b>prenex</b> <b>normal</b> <b>form.</b> There are several conversion rules {{that can be}} recursively applied to convert a formula to <b>prenex</b> <b>normal</b> <b>form.</b> The rules depend on which logical connectives appear in the formula.|$|E
50|$|Gödel's {{proof of}} his {{completeness}} theorem for first-order logic presupposes that all formulae have been recast in <b>prenex</b> <b>normal</b> <b>form.</b>|$|E
5000|$|Notice that in <b>Prenex</b> <b>normal</b> <b>form</b> the Quantifier Rank of φ {{is exactly}} the number of quantifiers {{appearing}} in φ.|$|E
40|$|Inductive Logic Programming {{considers}} {{almost exclusively}} universally quantified theories. To add expressiveness {{we should consider}} general <b>prenex</b> conjunctive <b>normal</b> <b>forms</b> (PCNF) with existential variables. ILP mostly uses learning with refinement operators. To extend refinement operators to PCNF, we should first extend substitutions to PCNF. If one substitutes an existential variable in a formula, one often obtains a specialization rather than a generalization. In this article we define substitutions to specialise a given PCNF and a weakly complete downward refinement operator. Based on this operator, we have implemented a simple learning system PCL on some type of PCNF. status: publishe...|$|R
40|$|Abstract. A {{certificate}} of (un) satisfiability for a quantified Boolean formula (QBF) represents concrete assignments to the variables, which act as witnesses for its truth value. Certificates are highly requested for practical applications of QBF like formal verification and model checking. We present an integrated {{set of tools}} realizing resolution-based certificate extraction for QBF in <b>prenex</b> conjunctive <b>normal</b> <b>form.</b> Starting from resolution proofs produced by the solver DepQBF, we describe the workflow consisting of proof checking, certificate extraction, and certificate checking. We implemented the steps of that workflow in stand-alone tools and carried out comprehensive experiments. Our results demonstrate the practical applicability of resolution-based certificate extraction. ...|$|R
40|$|Copyright 2008 Elsevier B. V., All rights reserved. The {{majority}} of the currently available solvers for quantified Boolean formulas (QBFs) process input formulas only in <b>prenex</b> conjunctive <b>normal</b> <b>form.</b> However, the natural representation of practicably relevant problems in terms of QBFs usually results in formulas which {{are not in a}} specific <b>normal</b> <b>form.</b> Hence, in order to evaluate such QBFs with available solvers, suitable normal-form translations are required. In this paper, we report experimental results comparing different prenexing strategies on a class of structured benchmark problems. The problems under consideration encode the evaluation of nested counterfactuals over a prepositional knowledge base, and span the entire polynomial hierarchy. The results show that different prenexing strategies influence the evaluation time in different ways across different solvers. In particular, some solvers are robust to the chosen strategies while others are not...|$|R
5000|$|Moving to <b>prenex</b> <b>normal</b> <b>form,</b> we {{get that}} the oracle machine halts on input n {{if and only if}} the {{following}} formula is satisfied: ...|$|E
50|$|Disregarding empty structures, every {{formula is}} {{equivalent}} to a formula in <b>prenex</b> <b>normal</b> <b>form</b> (where all quantifiers are written first, followed by a quantifier-free formula).|$|E
5000|$|It is {{the set of}} {{sentences}} that, when written in <b>prenex</b> <b>normal</b> <b>form,</b> have an [...] quantifier prefix and do not contain any function symbols.|$|E
40|$|Abstract. Given a {{quantified}} {{boolean formula}} (QBF) in <b>prenex</b> conjunctive <b>normal</b> <b>form,</b> {{we consider the}} problem of identifying variable dependencies. In related work, a formal definition of dependencies has been suggested based on quantifier prefix reordering: two variables are independent if swapping them in the prefix does not change satisfiability of the formula. Instead of the general case, {{we focus on the}} sets of depending existential variables for all universal variables which are relevant particularly for expansion-based QBF solvers. We present an approach for efficiently computing existential dependency sets by means of a directed connection relation over variables and demonstrate how this relation can be compactly represented as a tree using a union-find data structure. Experimental results show the effectiveness of our approach. ...|$|R
40|$|AbstractWe {{show that}} the {{decision}} problem for the class C 0 of all closed universal Horn formulae in <b>prenex</b> conjunctive <b>normal</b> <b>form</b> of extended Skolem arithmetic without equality (i. e. first order formulae built up from the multiplication sign, constants for the natural numbers and free occuring predicate symbols) is exponentially time bounded equivalent to the reachability problem for Petri nets if restricted to the class of formulae with (a) only monadic predicate symbols, with (b) only binary disjunctions in the quantifier free matrix and (c) without terms containing a variable more than once. We show that leaving {{out one of the}} restrictions (a) to (c) yields classes of formulae whose decision problem can assume any prescribed recursively enumerable complexity in terms of many-one degrees of unsolvability...|$|R
40|$|Inductive Logic Programming {{considers}} {{almost exclusively}} universally quantied theories. To add expressiveness, <b>prenex</b> conjunctive <b>normal</b> <b>forms</b> (PCNF) with existential variables {{should also be}} considered. ILP mostly uses learning with refinement operators. To extend refinement operators to PCNF, we should first do so with substitutions. However, applying a classic substitution to a PCNF with existential variables, one often obtains a generalization rather than a specialization. In this article we define substitutions that specialize a given PCNF and a weakly complete downward refinement operator. Moreover, we analyze the complexities of this operator in different types of languages and search spaces. In this way we lay a foundation for learning systems on PCNF. Based on this operator, we have implemented a simple learning system PCL on some type of PCNF. learning;PCNF;completeness;refinement;substitutions...|$|R
50|$|Some proof calculi {{will only}} {{deal with a}} theory whose {{formulae}} are written in <b>prenex</b> <b>normal</b> <b>form.</b> The concept is essential for developing the arithmetical hierarchy and the analytical hierarchy.|$|E
50|$|The second {{sentence}} has {{the same}} truth value but follows the restricted syntax. Assuming fully quantified Boolean formulas to be in <b>prenex</b> <b>normal</b> <b>form</b> is a frequent feature of proofs.|$|E
50|$|SO {{is equal}} to Polynomial hierarchy, more {{precisely}} we have that formula in <b>prenex</b> <b>normal</b> <b>form</b> where existential and universal of second order alternate k times are the kth level of the polynomial hierarchy.|$|E
40|$|Given a {{quantified}} {{boolean formula}} (QBF) in <b>prenex</b> conjunctive <b>normal</b> <b>form</b> (PCNF), {{we consider the}} problem of identifying variable dependencies. In related work, a formal definition of dependencies has been suggested based on quantifier prefix reordering: two variables are independent if swapping them in the prefix does not change satisfiability of the formula. Instead of the general case, {{we focus on the}} sets of depending existential variables for all universal variables. This is relevant particularly for expansion-based QBF solvers. We present an approach for efficiently computing existential dependency sets by means of a directed connection relation over variables and demonstrate how this relation can be compactly represented as a tree using a union-find data structure. Experimental results show the effectiveness of our approach. Keywords: Quantified Boolean Formulae, QBF, expansion, dependencies...|$|R
40|$|Various {{problems}} in AI {{can be solved}} by translating them into a quantified boolean formula (QBF) and evaluating the resulting encoding. In this approach, a QBF solver {{is used as a}} black box in a rapid implementation of a more general reasoning system. Most of the current solvers for QBFs require formulas in <b>prenex</b> conjunctive <b>normal</b> <b>form</b> as input, which makes a further translation necessary, since the encodings are usually not in a specific <b>normal</b> <b>form.</b> This additional step increases the number of variables in the formula or disrupts the formula’s structure. Moreover, {{the most important part of}} this transformation, prenexing, is not deterministic. In this paper, we focus on an alternative way to process QBFs without these drawbacks and implement a solver, qpro, which is able to handle arbitrary formulas. To this end, we extend algorithms for QBFs to the nonnormal form case and compare qpro with the leading normal-form provers on problems from the area of AI...|$|R
40|$|Q-resolution is a proof {{system for}} {{quantified}} Boolean formulas (QBFs) in <b>prenex</b> conjunctive <b>normal</b> <b>form</b> (PCNF) which underlies search-based QBF solvers with clause and cube learning (QCDCL). With the aim to derive and learn stronger clauses and cubes {{earlier in the}} search, we generalize the axioms of the Q-resolution calculus resulting in an exponentially more powerful proof system. The generalized axioms introduce an interface of Q-resolution to any other QBF proof system allowing for the direct combination of orthogonal solving techniques. We implemented {{a variant of the}} Q-resolution calculus with generalized axioms in the QBF solver DepQBF. As two case studies, we apply integrated SAT solving and resource-bounded QBF preprocessing during the search to heuristically detect potential axiom applications. Experiments with application benchmarks indicate a substantial performance improvement. Comment: (minor fixes) camera-ready version + appendix; to appear in the proceedings of SAT 2016, LNCS, Springe...|$|R
5000|$|Every {{formula of}} th order is {{equivalent}} to a formula in <b>prenex</b> <b>normal</b> <b>form,</b> where we first write quantification over variable of th order and then a formula of order [...] in normal form.|$|E
5000|$|A {{formula of}} the {{predicate}} calculus is in <b>prenex</b> <b>normal</b> <b>form</b> {{if it is}} written as a string of quantifiers (referred to as the prefix) followed by a quantifier-free part (referred to as the matrix).|$|E
5000|$|... {{where every}} {{variable}} {{falls within the}} scope of some quantifier. By introducing dummy variables, any formula in <b>prenex</b> <b>normal</b> <b>form</b> can be converted into a sentence where existential and universal quantifiers alternate. Using the dummy variable , ...|$|E
40|$|Abstract. Many search-based QBF solvers {{implementing}} the DPLL algorithm for QBF (QDPLL) process formulae in <b>prenex</b> conjunctive <b>normal</b> <b>form</b> (PCNF). The quantifier prefix of PCNFs {{often results in}} strong variable dependencies which can influence solver performance negatively. A common approach to overcome this problem is to reconstruct quantifier structure e. g. by quantifier trees. Dependency schemes are a generalization of quantifier trees {{in the sense that}} more general dependency graphs can be obtained. So far, dependency graphs have not been applied in QBF solving. In this work we consider the problem of efficiently integrating dependency graphs in QDPLL. Thereby we generalize related work on integrating quantifier trees. By analyzing the core parts of QDPLL, we report on modifications necessary to profit from general dependency graphs. In comprehensive experiments we show that QDPLL using a particular dependency graph, despite of increased overhead, outperforms classical QDPLL relying on quantifier prefixes of PCNFs. ...|$|R
40|$|The famous archetypical NP-complete problemof Boolean satisfiability (SAT) and its PSPACE-complete {{generalization}} of quantified Boolean satisfiability (QSAT) have become central declara-tive programming paradigms through which real-world instances of various computationally hard {{problems can be}} efficiently solved. This success has been achieved through several breakthroughs in practical implementations of decision procedures for SAT and QSAT, that is, in SAT and QSAT solvers. Here, simplification techniques for conjunctive <b>normal</b> <b>form</b> (CNF) for SAT and for <b>prenex</b> conjunctive <b>normal</b> <b>form</b> (PCNF) for QSAT—the standard input formats of SAT and QSAT solvers—have recently proven very effective in increasing solver efficiency when applied before (i. e., in preprocessing) or during (i. e., in inprocessing) satisfiability search. In this article, we develop and analyze clause elimination procedures for pre- and inprocessing. Clause elimination procedures form a family of (P) CNF formula simplification techniques which remove clauses that have specific (in practice polynomial-time) redundancy properties while main-taining the satisfiability status of the formulas. Extending known procedures such as tautology, subsumption, and blocked clause elimination, we introduce novel elimination procedures base...|$|R
40|$|We {{present an}} {{experimental}} study {{of the effects of}} alternation bias in the evaluation of quantified Boolean formula (QBF) solvers. Alternation bias in a set of QBFs in <b>prenex</b> conjunctive <b>normal</b> <b>form</b> (PCNF) is caused by an overrepresentation of PCNFs with a certain number of quantifier alternations. Using the QBFEVAL' 16 benchmarks, we show empirically that the performance of solvers based on different solving paradigms substantially varies on classes of PCNFs defined by their numbers of alternations. Thus alternation bias might result in solver rankings that are biased with respect to solving paradigms that perform well on overrepresented instances. Our results motivate the development of methods for a balanced evaluation of orthogonal paradigms that perform well on underrepresented instances. This is necessary to showcase the broad range of existing solving paradigms for practical QBF applications and to help potential users to choose a good solver for their application. Comment: 8 pages + appendi...|$|R
