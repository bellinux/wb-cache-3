20|265|Public
2500|$|Stephen Kleene {{notes that}} any of the six {{inequality}} restrictions on the range of the variable y is permitted, i.e. [...] "y < z", [...] "y ≤ z", [...] "w < y < z", [...] "w < y ≤ z", [...] "w ≤ y < z", [...] "w ≤ y ≤ z". [...] "When the indicated range contains no y such that R(y) , the value of the [...] "μy" [...] expression is the cardinal number of the range"(p.nbsp&226); this is why the default [...] "z" [...] appears in the definition above. As shown below, the bounded mu operator [...] "μyy" [...] is defined in terms of two primitive recursive functions called the finite sum Σ and finite product Π, a <b>predicate</b> <b>function</b> that [...] "does the test" [...] and a representing function that converts { t, f } to { 0, 1 }.|$|E
5000|$|Matrix: In {{contemporary}} usage, PM 's matrix is (at {{least for}} propositional functions), a truth table, i.e., all truth-values of a propositional or <b>predicate</b> <b>function.</b>|$|E
5000|$|... ❋13.01. x = y =def ∀f:(f(x) → f(y)) ("This {{definition}} {{states that}} x and y {{are to be}} called identical when every <b>predicate</b> <b>function</b> satisfied by x is satisfied by y" ...|$|E
2500|$|The spatial <b>predicate</b> <b>functions</b> {{that can}} be derived (expressed by masks) from DE-9IM include: ...|$|R
40|$|This paper {{reports on}} the form and the logical {{semantics}} of inductive definitions in the wide-spectrum design language COLD-K. It is shown how and when predicate definitions of the form the smallest P satisfying property A(P) can be transformed into monotonic <b>predicate</b> <b>functions</b> with P as their least fixpoint...|$|R
40|$|Abstract. This paper {{reports on}} the form and the logical {{semantics}} of inductive definitions in the wide-spectrum design language COLD-K. It is shown how and when predicate definitions of the form the smallest P satisfying property A(P) can be transformed into monotonic <b>predicate</b> <b>functions</b> with P as their least fixpoint. This paper reports on aninterestingaspect of {{the design of the}} language COLD-K: the form of inductive definitions of <b>predicates</b> and <b>functions.</b> COLD-K (Common Object-oriented Language for Design, K stands for kernel) is a-wider spectrum design language developed at Philip...|$|R
5000|$|... {{in which}} Jane {{is the subject}} {{referent}} argument and λx.x hurt x is the <b>predicate</b> <b>function</b> (a lambda abstraction) with the lambda notation and x indicating both the semantic subject and the semantic object of sentence as being bound. This returns the semantic interpretation JANE hurt JANE with JANE being the same person.|$|E
5000|$|The {{following}} code demonstrates this:result := a > b ifTrue:'greater' [...] ifFalse:'less or equal' Blocks {{are also}} used to implement user-defined control structures, enumerators, visitors, pluggable behavior and many other patterns.For example:| aString vowels |aString := 'This is a string'.vowels := aString select: | aCharacter isVowel.In the last line, the string is sent the message select: with an argument that is a code block literal. The code block literal {{will be used as}} a <b>predicate</b> <b>function</b> that should answer true if and only if an element of the String {{should be included in the}} Collection of characters that satisfy the test represented by the code block that is the argument to the [...] "select:" [...] message.|$|E
40|$|Role is {{semantic}} (by mean) for {{function and}} semantic content function (as balance for formal content function, category). Role is low grade after function and category. Prosesif role is syntactic role to <b>predicate</b> <b>function,</b> generally is polymorfemic verb by affix meN-, ber-, and ber-an in semantic content meaning ‘process’...|$|E
5000|$|Extensions by {{unconstrained}} <b>predicate</b> or <b>function</b> {{symbols are}} conservative.|$|R
5000|$|SQL:2003-14 {{defines the}} basic datatype, mappings, <b>predicates</b> and <b>functions.</b>|$|R
5000|$|Function B: {0,1}n → {0,1} is a hard-core <b>predicate</b> for <b>function</b> ƒ if ...|$|R
40|$|The {{article is}} {{concerned}} with English action verbs as key elements of academic English writing. Due to cognitive and semantic characteristics, verbs in the <b>predicate</b> <b>function,</b> by contrast with deverbative suffixal nouns and adjectives as parts of nominal predicates, convey the meaning of written message more concisely. The article is provided with verb classifications aimed at systematizing the information about verbs and developing a conscious approach to choosing verbs in the writing process. Syntactic transformation, limitation of passive voice forms, substitution of action verbs for stative verbs, adjectives and nouns entail perfecting the second language student writing skills...|$|E
40|$|Presence {{of shadow}} in an image often causes {{problems}} in computer vision {{applications such as}} object recognition and image segmentation. This paper proposes a method to detect the shadow from a single image using fuzzy split and merge approach. Split and merge is a classical algorithm used in image segmentation. <b>Predicate</b> <b>function</b> in the classical approach {{is replaced by a}} Fuzzy predicate in the proposed approach. The method follows a top down approach of recursively splitting an image into homogeneous quadtree blocks, followed by a bottom up approach by merging adjacent unique regions. The method has been compared with previous approaches and found to be better in performance in terms of accuracy...|$|E
40|$|Content-based publish-subscribe is an {{efficient}} communication paradigm that supports dynamic, many-to-many data dissemination in a distributed environment. A publish-subscribe system deployed over a wide-area net- work must handle information dissemination across distinct authoritative domains and heterogeneous platforms. Such an environment raises serious security concerns. This paper describes a practical scheme that preserves confidentiality against eavesdroppers for private content-based publish-subscribe systems over public networks. In this scheme, publications and subscriptions are encrypted, while the publish-subscribe infrastructure {{is able to}} make correct routing decisions based on encrypted publications and subscriptions. Plaintexts are not revealed in the infrastructure {{for the purpose of}} security and efficiency. This scheme efficiently supports interval-matching as a <b>predicate</b> <b>function</b> for subscriptions. The security of this scheme is analyzed, and further improved by several techniques...|$|E
30|$|There {{are also}} symbols of <b>predicates</b> and <b>functions</b> (including constants) {{denoting}} relations and functions independent of situations.|$|R
40|$|Abstract. This paper {{aimed to}} build an {{ontology}} of aircraft carrier geographic information, defined ontology’s constants, <b>predicates,</b> <b>functions</b> about aircraft carrier geographic information, and proposed a series of competency questions which could be solved by this ontology. Paper presented disjoint axioms, simple axioms and complex axioms of this ontology around these competency questions, and proved {{the consistency of the}} carrier ontology by examples. Finally, paper gave the answers for competency questions...|$|R
5000|$|Unlike Common Lisp, {{and many}} dialects of Lisp, the Scheme dialect {{does not have}} a nil value which works this way; the {{functions}} [...] and [...] may not be applied to an empty list; Scheme application code therefore has to use the [...] or [...] <b>predicate</b> <b>functions</b> to sidestep this situation, even in situations where very similar Lisp would not need to distinguish the empty and non-empty cases thanks to the behavior of [...]|$|R
40|$|Predicate {{constraint}} solving technique {{is an important}} method of automatic test data generation. By analyzing the properties and disadvantages of predicate {{constraint solving}} technique, three theorems are proposed and proved. Based on them, a new approach on automatic test data generation is presented. The linear predicate on a given path is used directly to construct the linear constraint system. Only the linear arithmetic representation for nonlinear <b>predicate</b> <b>function</b> is required to compute. Theoretical analysis and practical testing show: for the linear path, the initial input and the iteration are not required. The path is feasible if the linear constraint system can be solved, and {{the values of the}} input variables obtained are the desired test data. Otherwise, the path is infeasible. Considering the nonlinear path, test data can also be obtained by a number of iterations, or it can be guaranteed that the path is infeasible to a great extent...|$|E
40|$|A {{constrained}} {{pseudo random}} function (PRF) behaves like a standard PRF, {{but with the}} added feature that the (master) secret key holder, having secret key K, can produce a constrained key, Kf, that allows {{for the evaluation of}} the PRF on a subset of the domain as determined by a <b>predicate</b> <b>function</b> f within some family F. While previous constructions gave constrained PRFs for poly-sized circuits, all reductions for such functionality were based in the selective model of security where an attacker declares which point he is attacking before seeing any constrained keys. In this paper we give new constrained PRF constructions for circuits that have polynomial reductions to indistinguishability obfuscation in the random oracle model. Our solution is constructed from two recently emerged primitives: an adaptively secure Attribute-Based Encryption (ABE) for circuits and a Universal Parameters as introduced by Hofheinz et al. Both primitives are constructible from indistin-guishability obfuscation (iO) (and injective pseudorandom generators) with only polynomial loss...|$|E
40|$|It is only {{recently}} that investigators have started attempting {{to find out}} why a sizeable text such as a novella or a novel should be interpreted by the reader as a single whole and not as a set of unconnected sentences, paragraphs, and chapters- in other words, what makes a text be regarded as a coherent text. The starting-point in this investigation was the structural point of view: a grammatical phenomen is not investigated in isolation, but in the context of other grammatical phenomena. In this investigation of the function of the predicate in the text we therefore first had to form a notion of the sentence and of how it functions as an utterance, an then of how the predicate functions within the sentence; next of the relation between a single sentence and a text of more than one sentence, and finally of how the <b>predicate</b> <b>function</b> within such a text. [...] . Zie: Conclusion...|$|E
2500|$|The {{adjective}} [...] "first-order" [...] distinguishes first-order logic from higher-order {{logic in}} which there are predicates having <b>predicates</b> or <b>functions</b> as arguments, or in which one or both of <b>predicate</b> quantifiers or <b>function</b> quantifiers are permitted. In first-order theories, predicates are often associated with sets. In interpreted higher-order theories, predicates may be interpreted as sets of sets.|$|R
40|$|We {{describe}} a novel logic, called HiLog, {{and show that}} it provides a more suitable basis for logic programming than does traditional predicate logic. HiLog has a higher-order syntax and allows arbitrary terms to appear in places where <b>predicates,</b> <b>functions</b> and atomic formulas occur in predicate calculus. But its semantics is first-order and admits a sound and complete proof procedure. Applications of HiLog are discussed, including DCG grammars, higher-order and modular logic programming, and deductive databases...|$|R
40|$|Abstract. We study <b>predicate</b> {{selection}} <b>functions</b> (also {{known as}} splitting rules) for structural decision trees and propose two improvements to existing schemes. The first is in classification learning, where we reconsider {{the use of}} accuracy as a <b>predicate</b> selection <b>function</b> and show that, on practical grounds, it is a better alternative to other commonly used functions. The second is in regression learning, where we consider the standard mean squared error measure and give a predicate pruning result for it. ...|$|R
40|$|In the Indonesian {{language}} {{there is}} one type of sentence, that sentence inversion. Inversion sentence is sentence structure subject precedes <b>predicate</b> <b>function</b> (P-S). Based {{on the results of}} data analysis, there are several types of sequence patterns syntactic function contained in the phrase inversion Indonesian namely (1) PS, (2) POS, (3) P-Pel-S, (4) PO-Pel-S, (5) PS with Specification, (6) POS with Description, (7) P-Pel-S with the description, and (8) PO-Pel-S with a description. Also there are different types of sentences in the sentences Indonesian inversion which consists of: (1) sentence declarative inversion which is divided into two types of patterns that can be converted into the S-P and type that can not be converted into P-S; (2) The inversion of interrogative sentences are divided into two inversions interrogative sentences that require yes or no answers and inversion interrogative sentences that require answers explanatory; (3) sentence inversion imperative which is divided into two inversions imperative sentences with active diathesis and passive sentences with inversion imperative diathesis; and (4) the sentence exlasamative...|$|E
40|$|Abstract- Testing the {{software}} is very important phase in software development life cycle. So to test {{the software}} automatically {{is the best way}} to test the software because it consume less time where testing software manually is consuming process. To test the software automatically, test case generation is the best way. One way to generate the test cases is with the help of UML diagrams. In this paper we study the various techniques to generate the test cases from the UML diagrams to test the software automatically. Different tools are used to generate the UML diagrams. A new method is also proposed which will help in testing software automatically by generating test cases. Techniques in which different approaches are used like model based approach, novel approach. approach in which genetic algorithm is implemented as data mining technique are used to generate the test cases automatically, function minimization technique used for finding the minimum <b>predicate</b> <b>function.</b> The different tools like AGEDIS, TGV and GOTCHA are used for test generation. These approaches have been proposed to bring out all possible test cases of given object diagram. Index terms: object diagrams, test cases, UML, genetic algorithm, data mining, tabu search algorithm. I...|$|E
40|$|Abstract. Support for the modular {{composition}} of code {{is important to}} the task of constructing large programs. In the logic programming setting, it is desirable that such capabilities be realized through mechanisms that have a basis in logic. We describe here an approach for doing this that is a simplification and a rationalization of features previously supported in the Teyjus implementation of the λProlog language. Within this scheme, a module corresponds to a block of code whose external view is mediated by a signature. The notion of hiding that is imposed by a signature corresponds at a logical level to the existential quantification of <b>predicate,</b> <b>function</b> and constant names. Modules may interact through a mechanism known as accumulation that translates into conjoining the clause definitions in them, with the proviso that the scope of the existential quantifiers associated with signatures be respected. We discuss these features at a pragmatic level and also describe additional statically checkable compiler directives that are useful in practical programming. While the module capabilities we present can be implemented via the device of inlining accumulated modules, it is important in practice to allow for separate compilation. We discuss the challenges that realizing such a capability poses for the compilation and loading processes and we outline a scheme that overcomes them. ...|$|E
40|$|AbstractWe {{describe}} a novel logic, called HiLog, {{and show that}} it provides a more suitable basis for logic programming than does traditional predicate logic. HiLog has a higher-order syntax and allows arbitrary terms to appear in places where <b>predicates,</b> <b>functions,</b> and atomic formulas occur in predicate calculus. But its semantics is first-order and admits a sound and complete proof procedure. Applications of HiLog are discussed, including DCG grammars, higher-order and modular logic programming, and deductive databases...|$|R
40|$|The {{article in}} {{question}} {{deals with the}} comparative analysis of the semantico-syntactic structure of the non-elementary sentence with Ukrainian Participle and French Gerund {{from the standpoint of}} the second <b>predicate</b> <b>functioning.</b> It has been confirmed that the secondary predication in a simple non-elementary sentence structure is fulfilled while participation of three main components: primary predicate, subject and secondary predicate. The main second predicate semantic types as well as the factors and preconditions of the secondary predication realization have been distinguished and outlined...|$|R
5000|$|... #Subtitle level 3: Converting <b>predicates</b> to numeric <b>functions</b> ...|$|R
40|$|Abstract. The {{ability to}} compose code in a modular fashion is {{important}} to the construction of large programs. In the logic programming setting, it is desirable that such capabilities be realized through logic-based devices. We describe here an approach for doing this that is a simplification and a rationalization of features previously supported in the Teyjus implementation of the λProlog language. Within this scheme, a module corresponds to a block of code whose external view is mediated by a signature. Thus, signatures impose a form of hiding that is explained, at the logical level, via existential quantifications over <b>predicate,</b> <b>function</b> and constant names. Module interaction is based on accumulation, a mechanism that translates into conjoining the clause definitions in them while respecting the scopes of existential quantifiers arising from signature interpretation. Our first contribution is to show that this simple device for statically structuring name spaces suffices for realizing features related to code scoping for which the dynamic control of predicate definitions was earlier considered necessary. The module capabilities we present have previously been implemented in the Teyjus system via the compile-time inlining of accumulated modules. This approach has the drawback of not supporting separate compilation. Our second contribution is a scheme that allows each distinct module to be compiled separately, moving the task of inlining to a later, complementary linking process. ...|$|E
40|$|Change in {{language}} {{will be an}} inevitable fact. All living languages are in perpetual state of changes, including English. One sort of language changes {{is related to the}} grammar of the language. An example of components of grammar in English is predicative construction. The predicative construction consists of at least one verb; be it lexical verb or functional verb. Hence, verb is a prominent category in an English construction; when there is no lexical verb, there will be functional verb, copula be, occupying the <b>predicate</b> <b>function.</b> It is evident, then, that copula be is prominent in English grammar. Considering its importance, there are oodles number of research on copula be, especially the syntactic and semantic analyses. Rather, there have been merely a small number of them focusing on the diachronic aspect. Basically, studying copula be diachronically could provide examples of language change as the nature of a living language. Furthermore, {{it will be able to}} depict the characteristics of English language. Based on the previous explanation, thus, this paper aims at describing the historical development of copula be by analyzing Old and Middle English texts. Even though the texts are limited to particular dialect(s) of English, this study is expected to give clear and comprehensive examples of language change in English and the characteristics of English language over a period of time...|$|E
40|$|The {{ability to}} compose code in a modular fashion is {{important}} to the construction of large programs. In the logic programming setting, it is desirable that such capabilities be realized through logic-based devices. We present here an approach to doing this that is a supported in the Teyjus implementation of the λProlog language. Within this scheme, a module corresponds to a block of code whose external view is mediated by a signature. Thus, signatures impose a form of hiding that is explained logically via existential quantifications over <b>predicate,</b> <b>function</b> and constant names. Modules interact through the mechanism of accumulation that translates into conjoining the clauses in them while respecting the scopes of existential quantifiers introduced by signatures. We show that this simple device for statically structuring name spaces suffices for realizing features related to code scoping for which the dynamic control of predicate definitions was earlier considered necessary. While a compile-time inlining of accumulated modules that respects quantifier scoping can be used to realize the module capabilities we present in a transparently correct way, such an approach has the drawback of not supporting separate compilation. We show how this approach can be refined into a scheme that allows each distinct module to be compiled separately, with the effect of inlining being realized by a subsequent linking process...|$|E
40|$|A new {{knowledge-based}} {{security protocol}} verification approach is proposed in this paper. A number of <b>predicates,</b> <b>functions,</b> assumptions and rules {{are used to}} infer the knowledge of participating principals. These items are implemented with Isabelle, which enables mechanical proving. This approach can prove protocols concerning interleaving protocol sessions and can prove the correctness of a medium-sized security protocol {{in a couple of}} seconds. The mechanical proofs of a number of important secure properties and then of the correctness of the Needham-Schroeder-Lowe protocol are given as examples to show the effectiveness of this method. ...|$|R
5000|$|The {{definition}} theorem {{states that}} a <b>predicate</b> (or <b>function</b> or constant) is implicitly definable if {{and only if}} it is explicitly definable. Further explanation is provided under Beth definability ...|$|R
5000|$|This {{definition}} allows <b>predicates</b> (i.e. <b>functions</b> returning logical values) {{to directly}} act as if-clauses. A function returning a Boolean, {{which is then}} applied to two parameters, returns either the first or the second parameter: ...|$|R
