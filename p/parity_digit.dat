2|27|Public
50|$|A multidimensional parity-check code (MDPC) is {{a simple}} type of error {{correcting}} code that operates by arranging the message into a multidimensional grid, and calculating a <b>parity</b> <b>digit</b> for each row and column. In general, an n-dimensional parity scheme can correct n/2 errors.|$|E
5000|$|... 42 (6*7) areas {{making up}} the right group of 6 digits. This can be further {{subdivided}} into 6 subgroups, each consisting of seven areas. The subgroups encode digits 8-13. Digits 8-13 are all encoded with even <b>parity.</b> <b>Digit</b> 13 is the check digit.|$|E
5000|$|<b>Parity</b> <b>digits</b> {{are then}} {{calculated}} by summing each column and row separately: ...|$|R
50|$|The {{receiver}} can {{see that}} the first row and also the first column add up incorrectly. Using this knowledge and the assumption that only one error occurred, the receiver can correct the error. In order to handle two errors, a 4-dimensional scheme would be required, at the cost of more <b>parity</b> <b>digits.</b>|$|R
5000|$|The UPC-A's {{left-hand}} side digits (the digits {{to the left}} of the M (middle) guard pattern) have odd parity, which means the total width of the black bars is an odd number of modules, on the contrary, the right-hand side <b>digits</b> have even <b>parity.</b> Consequently, a UPC scanner can determine whether it is scanning a symbol from left-to-right or from right-to-left (the symbol is upside-down). After seeing a S (start) or E (end) guard pattern (they are the same, bar-space-bar, whichever direction they are read), the scanner will first see odd <b>parity</b> <b>digits,</b> if scanning left-to-right, or even <b>parity</b> <b>digits,</b> if scanning right-to-left. With the parity/direction information, an upside-down symbol will not confuse the scanner. When confronted with an upside-down symbol, the scanner may simply ignore it (many scanners alternate left-to-right and right-to-left scans, so they will read the symbol on a subsequent pass) or recognize the digits and put them in the right order. There is another property in the digit encoding. The right-hand side digits are the optical inverse of the {{left-hand side}} digits, i.e. black bars are turned into white spaces and vice versa. For example, the left-hand side [...] "4" [...] is space×1 - bar×1 - space×3 - bar×2, meanwhile the right-hand side [...] "4" [...] is bar×1 - space×1 - bar×3 - space×2.|$|R
5000|$|<b>Parity</b> for the <b>digits</b> {{from left}} and right group: OEOOEE EEEEEE (O = Odd parity, E = Even parity).|$|R
5000|$|The {{first digit}} in the EAN code: the {{combination}} of <b>parities</b> of the <b>digits</b> in the left group indirectly encodes the first digit 4.|$|R
40|$|A {{fixed length}} code is called {{immutable}} if no codeword {{can be transformed}} into another codeword by using only a restricted set of symbol changes. Immutablecodes are used to prevent undetectable updates of information stored over write-once memories [14]. In this paper we consider immutablecodes on the alphabet Q={ 0, [...] ., q− 1 }. We prove that a maximum size immutablecode of block length n {{can be obtained by}} taking the set of all vectors in Q^n of weight ⌈n(q− 1) ⧸ 2 ⌉. Furthermore, we propose an encoding rule to map information sequences of length k into codewords of an immutablecode of length k+p. The number k of information digits and the number p of <b>parity</b> <b>digits</b> must satisfy the inequality k≤ 2 (q^p− 1) ⧸(q− 1) −p. The proposed encoding algorithm has computational complexity O(k) ...|$|R
40|$|The paper {{presents}} {{lower and}} upper bounds {{on the number}} of <b>parity</b> check <b>digits</b> required for a linear code that detects solid bursts of length $b$ or less and simultaneously any $e$ or less random errors. An example of such a code is also provided. Further, codes capable of detecting and simultaneously correcting such errors have also been dealt with...|$|R
40|$|Majority-logic {{decoding}} {{is attractive}} for three reasons: (I) It can be simply implemented; (2) the decoding delay is short; and (3) its performance, while suboptimal, is always superior to bounded distance decoding. For these reasons, majoritylogic decodable cyclic codes are very suitable for error control in high speed digital data transmission systems. Among the majority-logic decodable codes, the one-step decodable codes can be most easily implemented; they employ a single majority-logic gate. In this paper we study {{a class of}} one-step majority-logic decodable cyclic codes. First, we describe these codes in a simple manner. Second, a way of jinding the orthogonal polynomials for decoding these codes is presented. Third, we show that for a given error correction capability, {{the ratio of the}} number of <b>parity</b> <b>digits</b> to the code length goes to zero as the code length increases. For error correction Capabilities of the form 2 &quot;- I or 2 &quot;, we determine the dimensions of the codes exactly. 1...|$|R
50|$|The <b>parity</b> check <b>digit</b> is {{calculated}} as follows: Each number digit is multiplied by two {{to the power}} of labels's position minus two. Thus the first digit (second line) is multiplied by 1, the second by 2, the third by 4, the fourth by 8 and so on, until the 10th which is multiplied by 512. The sum of all these numbers modulo 11 is the check digit.|$|R
40|$|Abstract. There {{are three}} {{standard}} weight functions on a linear code viz. Hamming weight, Lee weight, and Euclidean weight. Euclidean weight function {{is useful in}} connection with the lattice constructions [2] where the minimum norm of vectors in the lattice is related to the min-imum Euclidean weight of the code. In this paper, we obtain an upper bound over the number of <b>parity</b> check <b>digits</b> for Euclidean weight codes detecting and correcting burst errors. 1...|$|R
50|$|Checksum schemes include <b>parity</b> bits, check <b>digits,</b> and {{longitudinal}} redundancy checks. Some checksum schemes, {{such as the}} Damm algorithm, the Luhn algorithm, and the Verhoeff algorithm, {{are specifically}} designed to detect errors commonly introduced by humans in writing down or remembering identification numbers.|$|R
40|$|Error-locating codes (EL codes), first {{proposed}} by J. K. Wolf and B. Elspas in 1963, {{have the potential}} to be used to identify the faulty module for fault isolation and reconfiguration in fault-tolerant computer systems. This paper proposes a new class of EL codes suitable for systems with periodic errors. The authors obtain lower and upper bounds on the number of <b>parity</b> check <b>digits</b> required for a linear code that detects and locates errors which are periodic in nature. An illustration of such a code is also provided...|$|R
40|$|The paper {{discusses}} {{weight distribution}} of periodic errors {{and then the}} optimal case on bounds of <b>parity</b> check <b>digits</b> for (n=n 1 +n 2, k) linear codes over GF(q) that corrects all periodic errors of order r in the first block of length n 1 and all periodic errors of order s in the second block of length n 2 and no others. Further, we extend the study to the case when the errors are {{in the form of}} periodic errors of order r (and s) or more in the two subblocks...|$|R
40|$|Abstract. Hamming Code is {{the oldest}} and the most {{commonly}} used single error correcting and double errors detecting code. For implication, it is constructed over the field GF(2). For each r ≥ 2, there is a [n, k, 3] Hamming Code where = 2 − 1 and. A message word of length k is encoded using a generating matrix G into a codeword of length n. This amounts to inserting r <b>parity</b> check <b>digits</b> into the message word. The positions of the <b>parity</b> check <b>digits</b> in the codeword are called the check positions of the code (with respect to G). A received word is then r n k = 2 r − r − 1 th th th decoded using a parity check matrix H. If the check positions of the code are in the 1, 2,, r i i i � th th th coordinates of the codeword, then the i 1, i 2, �, ir rows of H are called the check rows of the code. We proved in this paper that for any parity check matrix of a Hamming Code, there exists a generating matrix G of the code, such that the check rows of the code are linearly independent. We believe that this fact is contained implicitly in a paper of Hamming [7] but we cannot find any explicit proof in existing literature. Using the above fact, we construct a 2 EC-AUED code. 1...|$|R
40|$|An array code/linear array code is a subset/subspace, respectively, of {{the linear}} space mathrmMat_m chi s (F_q), {{the space of}} all m chi s {{matrices}} with entries froma finite field F_q endowed with a non-Hamming metric known as the RT-metric or ρ-metric or m -metric. In this paper, we obtain a sufficient lower bound {{on the number of}} <b>parity</b> check <b>digits</b> required to achieve minimum ρ-distance at least d in linear array codes using an algorithmic approach. The bound has been justified by an example. Using this bound, we also obtain a lower bound on the number B_q (m chi s, d) where B_q(m chi s, d) is the largest number of code matrices possiblein a linear array code V subseteq mathrmMat_m chi s (Fq) having minimum ρ-distance at least d...|$|R
50|$|Mobiles would {{originate}} calls {{by sending}} a burst of connect tone, to which the base station responded with a burst of seize tone. The mobile would then respond with its identification, consisting of its area code and last four digits of the phone number sent at 20 pulses per second, just as in inward dialing but {{with the addition of}} rudimentary <b>parity</b> checking. <b>Digits</b> are formed with a pulsetrain of alternating tones, either connect and silence (for odd digits) or connect and guard (for even digits). When the base station received the calling party's identification, it would send dialtone to the mobile. The user would then use the rotary dial, which would send the dialed digits as an alternating 10 pps pulse train (originally, directly formed by the rotary dial) of connect and guard tones.|$|R
40|$|This Demonstration shows fractal-like {{patterns}} in the generalized <b>digit</b> <b>parity</b> of selected integer sequences. The concept of binary parity can be generalized for non-negative integers and for all positive integer bases by the definition: sum of digits of in base (mod). Plotting these results in two dimensions sometimes produces interesting patterns. This Demonstration provides a window to view a subset of each pattern by allowing the setting of starting values and ranges for n and b...|$|R
40|$|AbstractIn this paper, we obtain bounds on {{the number}} of <b>parity</b> check <b>digits</b> for Lee weight codes {{correcting}} errors of Lee weight 1, errors of Lee weight 2 or less, errors of Lee weight 3 or less and errors of Lee weight 4 or less over Zq (q⩾ 5, a prime) respectively. We also examine these bounds with equality to check for perfect codes and have shown the existence of perfect codes correcting errors of Lee weight 1 over Z 5 and perfect codes correcting errors of Lee weight 2 or less over Z 13. We have also shown the nonexistence of perfect codes correcting errors of Lee weight 2 or less over Zq when q= 4 n+ 3 (q prime) and correcting errors of Lee weight 3 or less and errors of Lee weight 4 or less over Zq (5 ⩽q⩽ 97, a prime). We further conjecture that there does not exist a perfect code correcting errors of Lee weight t or less (t⩾ 3) over Zq (q⩾ 5, a prime) ...|$|R
40|$|Abstract. In coding theory, {{several kinds}} of errors which depend {{on the nature of}} the {{communication}} channel are to be dealt with and accordingly codes are constructed to detect and correct such errors. Burst, CT-burst and solid burst errors are common in many communication channels. Different types of linear codes have been developed to deal with such errors. It is also quite possible that in communication more than one type of error occur simultaneously. The code which is developed to deal with one type of error may or may not be able to deal with the other type of error. The paper presents the minimum number of burst/CT-burst errors that will be detected by a b-SBEC code. A lower bound on <b>parity</b> check <b>digits</b> for such code is obtained. Further, the paper presents the number of solid burst errors that will be gone detected/undetected by a cyclic code. By a b-SBEC code, we mean a linear code that corrects all solid bursts of length b or less. 1. Introduction an...|$|R
40|$|In this study, {{structure}} of fault tolerance adder based on Radix 2 Signed Digital (SD) representation is proposed. The “carry-free” {{property of the}} SD adder that faults impact limited to a few digits {{can be used to}} fault detection which is based on parity checking assumed single fault set. Using an encoding scheme to get the <b>parity</b> value of <b>digits</b> involved in computing, this parity values can be exploited to check the circuit. An error information register is set to store the checking results and the bits of the register indicate the corresponding units faulty or not. According to the fault type, recomputation or reconfiguration is used to error correction. The hardware overhead appending Fault-Tolerant is about 120 % and the maximum combinational path delay of the proposed adder is constant with the increase of operands...|$|R
5000|$|Digits were {{represented}} internally using excess-3 ("XS3") {{binary coded decimal}} (BCD) arithmetic with six bits per digit using the same value as the digits of the alphanumeric character set (and one <b>parity</b> bit per <b>digit</b> for error checking), allowing 11-digit signed magnitude numbers. But {{with the exception of}} one or two machine instructions, UNIVAC was considered by programmers to be a decimal machine, not a binary machine, and the binary representation of the characters was irrelevant. If a non-digit character was encountered in a position during an arithmetic operation the machine passed it unchanged to the output, and any carry into the non-digit was lost. (Note, however, that a peculiarity of UNIVAC I's addition/subtraction circuitry was that the [...] "ignore", space, and minus characters were occasionally treated as numeric, with values of -3, -2, and -1 respectively, and the apostrophe, ampersand, and left parenthesis were occasionally treated as numeric, with values 10, 11, and 12.) ...|$|R
40|$|Abstract Cognitive {{theories}} of emotional disorders predict that individuals suffering from an emotional disorder exhibit increased interference for stimuli that are idiosyncratic to their disorder (Williams, Mathews, & MacLeod, 1996). However, due to inconsistent results, there is debate {{as to whether}} attention disrupting effects for negative information occur in depression. Suitability of experimental stimuli employed to elicit attentional biases is a commonly cited limitation that {{may have contributed to}} these inconsistencies. The present investigation was designed to examine the influence of rumination on the operation of attentional biases in depression using a digit-parity task. Depressed and never-depressed participants were required to make a speeded judgement about the <b>parity</b> of two <b>digits</b> flanking a to-be-ignored centrally presented word. Depressed individuals displayed longer digit-parity response times for depression-relevant words relative to never-depressed individuals. Furthermore, depressed individuals displayed the longest digit-parity response times for word stimuli relevant to the idiosyncratic content of their ruminative thoughts. These findings highlight the importance of studying the idiosyncratic content of each depressed individuals ruminative themes when investigating attentional biases within this population...|$|R
40|$|This report {{presents}} {{data from}} {{two versions of}} the task switching procedure in which the separate influence of stimulus repetitions, response key repetitions, conceptual response repetitions, cue repetitions, task repetitions, and congruency are considered. Experiment 1 used a simple alternating runs procedure with <b>parity</b> judgments of <b>digits</b> and consonant/ vowel decisions of letters as the two tasks. Results revealed sizable effects of stimulus and response repetitions, and controlling for these effects reduced the switch cost. Experiment 2 was a cued version of the task switch paradigm with parity and magnitude judgments of digits as the two tasks. Results again revealed large effects of stimulus and response repetitions, in addition to cue repetition effects. Controlling for these effects again reduced the switch cost. Congruency did not interact with our novel "unbiased" measure of switch costs. We discuss how the task switch paradigm might {{be thought of as a}} more complex version of the feature integration paradigm and propose an episodic learning account of the effect. We further consider to what extent appeals to higher-order control processes might be unnecessary and propose that controls for feature integration biases should be standard practice in task switching experiments...|$|R
40|$|Perceived {{duration}} {{has been}} shown to be positively related to task-irrelevant, nontemporal stimulus magnitude. To account for this finding, Walsh's (2003) A Theory of Magnitude (ATOM) model suggests that magnitude of time is not differentiated from magnitude of other nontemporal stimulus characteristics and collectively processed by a generalized magnitude system. In Experiment 1, we investigated the combined effects of stimulus size and numerical quantity, as two nontemporal stimulus dimensions covered by the ATOM model, on duration judgments. Participants were required to reproduce the duration of target intervals marked by Arabic digits varying in physical size and numerical value. While the effect of stimulus size was effectively moderated by target duration, the effect of numerical value appeared to require attentional resources directed to the numerical value in order to become effective. Experiment 2 was designed to further elucidate the mediating influence of attention on the effect of numerical value on duration judgments. An effect of numerical value was only observed when participants' attention was directed to digit value, but not when participants were required to pay special attention to <b>digit</b> <b>parity.</b> While the ATOM model implies a common metrics and generalized magnitude processing for time, size, and quantity, the present findings provided converging evidence for the notion of two qualitatively different mechanisms underlying the effects of nontemporal stimulus size and numerical value on duration judgments. Furthermore, our data challenge the implicit common assumption that the effect of numerical value on duration judgments represents a continuously increasing function of digit magnitude...|$|R
40|$|For decades, emotion {{researchers}} have debated {{a series of}} {{issues related to the}} influence of emotionally laden information on the way in which people process and remember information. The present investigation was designed to experimentally test both general (Experiment 1 and 2) and person-specific (Experiment 3) influences of emotionally laden words on attention and memory using a digit-parity task in which participants were asked to make a speeded judgement about the <b>parity</b> of two <b>digits</b> flanking a to-be-ignored, centrally presented word. In Experiment 1, when a sexual, threat, school, or neutral word was presented between the digits, only the sexual words, rated high in arousal value by study participants, disrupted digit-parity performance producing longer digit-parity response times relative to all other word categories. Sexual words were also recalled more often by study participants in a surprise free recall task. Mirroring attention and memory results, an evaluation of skin conductance responses (SCRs) demonstrated that participants showed enhanced SCRs for the sexual words relative to all other word categories. Furthermore, when the sexual words were parsed into positive and negative word categories (Experiment 2), trials in which a sex-negative word was presented between the digits produced the longest digit-parity response times. Participants recalled more sex-negative words than any other word category. Importantly, participants’ taboo ratings predicted attention and memory results. Finally, when words relevant to participants’ fears were presented between the digits, digit-parity response times slowed relative to when a fear-irrelevant word was presented between the digits. Memory and skin conductance data provide converging evidence – participants recalled and produced larger skin conductance responses for fear-relevant words compared to fear irrelevant words...|$|R
40|$|Nowadays, the {{information}} is formed of analog replaced by digital signals. No matter images, videos, audios and even daily necessities, they are all digitalized for convenient use and quick recognition. Thus a good coding scheme plays a more and more important role. Especially in the respect of message transition, to ensure {{the integrity of the}} transition information is a deeply concerned issue. In the classical coding theory, one considers only the error type, substitution (1 → 0, 0 → 1), of the transition channel and applies the uniform codes to ensure the decodability, detectability and correctability of the transition messages. Unfortunately, the errors of the transition channel are not always synchronous. There exist asynchronous errors such as deletions and insertions, thus, the coding schemes and properties proposed in the classical coding theory are not suitable. As a general approach to discuss the decodability, detectability and correctability of the transition messages, a model of abstract channel with substitutions (σ), deletions (δ) and insertions (ι) are investigated by Konstantinidis. He further proposes the concepts of singleton-detecting and (γ,＊) -detecting codes applied for the transition channel inclusive of combinations of three basic errors. Besides, the properties of -decoding and -correcting codes are studied in [13]. In our research, we first define the -detecting codes for the transition channel and further discuss the relations of (γ,＊) -detecting, γ-decoding, γ-correcting and γ-detecting codes. The next we study the properties of the code 1 n 0 n with n ≥ 1 for the channel δ(m,N). Finally, a convenient approach to construct a δ(m,N) -detecting code is proposed. 1 Introduction 1 1. 1. Preface [...] 1 1. 2. Basic coding schemes [...] . 1 1. 2. 1. Huffman coding scheme [...] 1 1. 2. 2. Decimal coding scheme [...] 3 1. 2. 3. <b>Parity</b> check <b>digit</b> scheme [...] 5 1. 3. Classical coding theorem [...] . 6 1. 3. 1. Decodability of codes [...] 6 1. 3. 2. t-error-detecting codes [...] 8 1. 3. 3. t-error-correcting codes [...] . 9 1. 4. Motivation [...] 10 1. 5. Organization [...] 11 2 Preliminary [...] 13 2. 1. Basic notation [...] 13 2. 2. Properties of codes [...] . 14 2. 3. Channels [...] 18 3 Properties of γ-Detecting Codes [...] 21 3. 1. Definitions [...] . 21 3. 2. Relation of γ-detecting and (γ,＊) -detecting codes [...] 22 3. 3. Relations of γ-detectability, γ-decodability and γ-correctability [...] . 24 3. 3. 1. Relation of γ-detectability and γ-decodability [...] . 24 3. 3. 2. Relation of γ-detectability and γ-correctability [...] . 25 3. 3. 3. Relation of γ-decodability and γ-correctability [...] . 26 4 Channel-Detecting Codes [...] 29 4. 1. Properties of δ(m,N) -detecting codes in 1 + 0 + [...] 29 4. 2. A method constructing a δ(m,N) -detecting code [...] . 36 5 Concluding Remarks [...] . 38 Referrences [...] 4...|$|R

