3|900|Public
40|$|Starting from an ATN-grammar and {{translation}} rules assigning {{expressions of}} a predicate cal-culus language to {{the symbols of}} the grammar one can produce an attribute grammar for the trans-lation of natural language sentences (here Ger-man) into expressions of the <b>predicate</b> <b>calculus</b> <b>language.</b> The paper illustrates {{that this can be}} done in a straightforward way and outlines fur-ther improvements of the resulting attribute grammar...|$|E
40|$|Database {{programming}} languages provide powerful telationai {{structures and}} operators based on, for exampb, first-order <b>predicate</b> <b>calculus.</b> <b>Language</b> Constructs for database programming, including a tmnsaction concepC requite thsrefof’e a predttteorbnted approach to con~m~lcy c~ntrool. A predicative optimistic concunency control is presented that attacks problems inhefwt in predtcate locking. Oniy those conflicts that achrally occurred between tnurractions Srs detected, and well-known query evaluation algorithms en 9 applied instead of algorithms testing the diijointneas of certain m&icted cbsses of pmdiites. For that reason, {{this approach is}} an elegant solution to the phantom problem. 1 Introduction: Programmer 6 are Afrald of Phantoms Data in a database are often subject to integrity constraints that require, one way or another, that statements ate execute...|$|E
40|$|AbstractWe {{describe}} {{one component}} of a “hybrid” Knowledge Representation Language (KRL) used {{for the development of}} Large Knowledge Bases (LKBs). This hybrid language involves two different aspects, the “descriptive” and the “definitional”. The representation of the elementary events occurring in the real world (descriptive data = “Snoopy is Charlie Brown's beagle”) is organized around “semantic predicates” (with “roles” and “arguments”); this gives rise to units called “predicative occurrences”. The single predicative occurrences can be combined using logical, causal etc., relationships, giving rise to complex conceptual constructions (“binding occurrences”). “Abstract” conceptual units (“templates”) which describe the expected properties of the “concrete” predicative and binding occurrences are placed in a specialization hierarchy (H_TEMP) characterized by the inheritance of properties and behaviours; the concrete “occurrences” constitute the “leaves” of this hierarchy. On the other hand, the “classes” representing the “general categories” of all the basic entities of the application domain which appear in the predicative occurrences are defined in terms of their own specialization hierarchy, H_CLASS (this is definitional data = “A beagle is a sort of hound / a hound is a dog … ”); the concrete “instances” of the defined classes are the “leaves” of this second hierarchy. The “definitional component” is not discussed in this article. The main difference between this KRL and other recent “hybrid” languages is that the “descriptive component” is not a first order <b>predicate</b> <b>calculus</b> <b>language,</b> but a highly structured semantic network...|$|E
50|$|We {{work with}} first-order <b>predicate</b> <b>calculus.</b> Our <b>languages</b> allow constant, {{function}} and relation symbols. Structures consist of (non-empty) domains and {{interpretations of the}} relevant symbols as constant members, functions or relations over that domain.|$|R
40|$|Summary. The {{aim is to}} {{construct}} a language for the classical <b>predicate</b> <b>calculus.</b> The <b>language</b> {{is defined as a}} subset of the language constructed in [7]. Well-formed formulas of this language are defined and some usual connectives and quantifiers of [7], [1] are accordingly. We prove inductive and definitional schemes for formulas of our language. Substitution for individual variables in formulas of the introduced language is defined. This definition is borrowed from [6]. For such purpose some auxiliary notation and propositions are introduced...|$|R
40|$|In this paper, {{we present}} a {{complete}} design framework for an adaptive multiple agent fuzzy constraintbased controller based on fuzzy penumbra constraint processing in each fuzzy constraint subnetwork collaborating with a connected constraint network and its corresponding semantic modeling in a firstorder <b>predicate</b> <b>calculus</b> (FOPC) <b>language,</b> with application to a complex hydraulic system. The concept of "multiple agent" and "fuzzy constraint subnetwork" in a complex control system is introduced and some basic definitions of penumbra fuzzy constraint processing in a constraint subnetwork and the collaboration with an overall connected constraint network and its semantic modeling are addressed. As a result, a human agent interacts with system agents and allows the constraints to be added or deleted on-line according to the constraints imposed from the outside environment. Near-optimal system performance is accomplished by restricting all the penumbra constraints to be satisfied in each con [...] ...|$|R
40|$|I {{present a}} method for {{reasoning}} about spatial relationships {{on the basis of}} entailments in propositional logic. Formalisms for representing topological and other spatial information (e. g. [2] [10] [11]) have generally employed the 1 st-order <b>predicate</b> <b>calculus.</b> Whilst this <b>language</b> is much more expressive than 0 -order (propositional) calculi it is correspondingly harder to reason with. Hence, by encoding spatial relationships in a propositional representation automated reasoning becomes more effective. I specify representations in both classical and intuitionistic propositional logic, which [...] - together with well-defined meta-level reasoning algorithms [...] - provide for efficient reasoning about a large class of spatial relations. 1 INTRODUCTION This work has developed out of research done by Randell, Cui and Cohn (henceforth RCC) on formalising spatial and temporal concepts used in describing physical situations [11]. A set of classical 1 st-order logic axioms has been formulated in whi [...] ...|$|R
40|$|We {{propose a}} {{language}} which can express every computable query. The language is syntactically {{based on the}} first-order <b>predicate</b> <b>calculus,</b> but semantically is interpreted as post-conditions, unlike the customary <b>calculus</b> query <b>languages.</b> The language has a capability to restrict itself to reasonable queries, accepting criteria of reasonability as a parameter...|$|R
5000|$|Monadic <b>predicate</b> <b>calculus</b> can be {{contrasted with}} polyadic <b>predicate</b> <b>calculus,</b> which allows {{relation}} symbols that take {{two or more}} arguments.|$|R
5000|$|In {{mathematical}} logic Frege's propositional calculus {{was the first}} axiomatization of propositional calculus. It was invented by Gottlob Frege, who also invented <b>predicate</b> <b>calculus,</b> in 1879 {{as part of his}} second-order <b>predicate</b> <b>calculus</b> (although Charles Peirce was the first to use the term [...] "second-order" [...] and developed his own version of the <b>predicate</b> <b>calculus</b> independently of Frege).|$|R
50|$|The {{absence of}} polyadic {{relation}} symbols severely restricts {{what can be}} expressed in the monadic <b>predicate</b> <b>calculus.</b> It is so weak that, unlike the full <b>predicate</b> <b>calculus,</b> it is decidable—there is a decision procedure that determines whether a given formula of monadic <b>predicate</b> <b>calculus</b> is logically valid (true for all nonempty domains). Adding a single binary relation symbol to monadic logic, however, results in an undecidable logic.|$|R
40|$|In this paper, a {{complete}} design framework for an adaptive multiple agent fuzzy constraint-based controller based on fuzzy penumbra constraint processing in each fuzzy constraint subnetwork collaborated by a connected constraint network and its corresponding semantic modeling in a first-order <b>predicate</b> <b>calculus</b> (FOPC) <b>language</b> applied {{in a complex}} hydraulic system are presented. The concept of "multiple agent" and "fuzzy constraint subnetwork" in a complex control system is introduced and some basic definitions of penumbra fuzzy constraint processing in a constraint subnetwork and the collaboration with an overall connected constraint network and its semantic modeling are addressed. The partitioning of a complex problem into subproblems is performed by employing a "multiple agent" concept. In this concept, the decomposition of a complex system is based on assigning each agent specific objects subjected to the constraints to act on. This idea contribute significantly to the domain of problem with great complexity {{due to the fact}} of collaboration of each agent and the assertion and deletion of its constraints that occur in the world model. As the result, a human agent interacts with system agents and allows the constraints to be added or deleted on-line according to the constraints imposed from outside environment. An optimal system performance is accomplished by restricting all the penumbra constraints to be satisfied in each constraint subnetwork simultaneously which are interconnected as a results of constraints that exist between each of them. Following the principle of constraint satisfaction and fuzzy local propagation reasoning, each individual system agent is now constrained to behave in a certain fashion as dictated by the overall constraint network. In addition, [...] ...|$|R
40|$|The paper focusses on {{the logical}} {{backgrounds}} of the Dijkstra-Scholten program development style for correct programs. For proving the correctness {{of a program}} (i. e. {{the fact that the}} program satisfies its specifications), one often uses a special form of <b>predicate</b> <b>calculus</b> in this style of programming. We call this the Dijkstra-Scholten (DS) <b>predicate</b> <b>calculus,</b> since [DS 90] is the first place in which it is described. DS <b>predicate</b> <b>calculus</b> can be conceived of as a logically sound and complete manipulation technique for dealing with logical formulas which also contain programming variables. We relate DS <b>predicate</b> <b>calculus</b> to the classical logical formalism, by contrasting its syntax, derivation rules and semantics to the classical framework. We also comment on two abstractions of DS predicate calculus: the set-theoretical and the algebraic approach. In doing so, we give DS <b>predicate</b> <b>calculus</b> and its abstract variants a firm basis, {{on a par with the}} foundations of the well-known first order logic. Such a comparison of DS <b>predicate</b> <b>calculus</b> and classical logic has not yet been sufficiently elaborated before. We conclude our paper with a number of examples showing that the, up to now, unsatisfactory presentation of DS <b>predicate</b> <b>calculus</b> and some of its features (such as the square brackets notation) has led to errors and fallacies in the literature...|$|R
40|$|The Hybrid <b>Predicate</b> <b>Calculus</b> (HPC) is {{a hybrid}} logical system that {{incorporates}} a fairly conventional rst-order <b>predicate</b> <b>calculus,</b> {{but that also}} include elements of modal logic and relational algebra. A special eort {{has been made to}} produce a (syntactically and semantically) well-integrated whole, rather than just a disjoint union...|$|R
5000|$|... #Subtitle level 3: Extension to first-order <b>predicate</b> <b>calculus</b> with {{equality}} ...|$|R
50|$|A <b>predicate</b> <b>calculus</b> {{will usually}} {{include all the}} same rules as a propositional calculus, with the {{addition}} of quantifiers such that if we take Φ to be a formula of propositional logic and α as a variable then we can take (α)Φ and (α)Φ each to be formulas of our <b>predicate</b> <b>calculus.</b>|$|R
50|$|We axiomatize <b>predicate</b> <b>calculus</b> without {{equality}} (sometimes confusingly called without identity), i.e. {{there are}} no special axioms expressing the properties of (object) equality as a special relation symbol. After the basic form of the theorem has been proved, it will be easy to extend it {{to the case of}} <b>predicate</b> <b>calculus</b> with equality.|$|R
5000|$|... can be notated in the <b>language</b> of monadic <b>predicate</b> <b>calculus</b> as ...|$|R
40|$|The present {{paper is}} part of a large {{research}} programme investigating the nature and properties of the predicate logic inherent in natural language. The general hypothesis is that natural speakers start off with a basic-natural logic, based on natural cognitive functions, including the basic-natural way of dealing with plural objects. As culture spreads, functional pressure leads to greater generalization and mathematical correctness, yielding ever more refined systems until the apogee of standard modern predicate logic. Four systems of <b>predicate</b> <b>calculus</b> are considered: Basic-Natural <b>Predicate</b> <b>Calculus</b> (BNPC), Aritsotelian-Abelardian <b>Predicate</b> <b>Calculus</b> (AAPC), Aritsotelian-Boethian <b>Predicate</b> <b>Calculus</b> (ABPC), also known as the classic Square of Opposition, and Standard Modern <b>Predicate</b> <b>Calculus</b> (SMPC). (ABPC is logically faulty owing to its Undue Existential Import (UEI), but that fault is repaired by the addition of a presuppositional component to the logic.) All four systems are checked against seven natural logical intuitions. It appears that BNPC scores best (five out of seven), followed by ABPC (three out of seven). AAPC and SMPC finish ex aequo with two out of seven. 1. The programme This tentative and exploratory paper is about a topic that has not been broached i...|$|R
5000|$|Abstract {{machines}} for logic programming languages. These {{are based on}} <b>predicate</b> <b>calculus.</b>|$|R
50|$|Using modern <b>predicate</b> <b>calculus,</b> {{we quickly}} {{discover}} that the statement is ambiguous.|$|R
5000|$|Database for {{beliefs about}} the world, {{represented}} using first order <b>predicate</b> <b>calculus.</b>|$|R
5000|$|... #Subtitle level 2: Gödel (1930): The {{first order}} <b>predicate</b> <b>calculus</b> is {{complete}} ...|$|R
40|$|It is {{well known}} to be {{impossible}} to tile with dominoes a checkerboard with two opposite corners deleted. This fact is readily stated in the first order <b>predicate</b> <b>calculus,</b> but the usual proof which involves a parity and counting argument does not readily translate into <b>predicate</b> <b>calculus.</b> We conjecture that this problem {{will be very difficult}} for programmed proof procedures,...|$|R
40|$|Linear {{logic is}} a {{refinement}} of classical and intuitionistic logic. Instead of emphasizing truth, as in classical logic, or proof, as in intuitionistic logic, linear logic emphasizes {{the role of}} formulas as resources. Logic, or at least proof-theory, is focused on formal proof systems: intuitionistic <b>predicate</b> <b>calculus,</b> classical <b>predicate</b> <b>calculus,</b> arithmetics, higher order calculi, and a wealth of similar consistent and structure...|$|R
5000|$|The {{ability to}} prove {{completeness}} for <b>predicate</b> <b>calculus</b> {{when it is}} expressed in this way.|$|R
50|$|In this approach, {{a formula}} in first-order logic (<b>predicate</b> <b>calculus)</b> is {{represented}} by a labeled graph.|$|R
5000|$|... 153 Marcel Guillaume, Les tableaux sémantiques du calcul des prédicats {{restreint}} (semantic tableaux in <b>predicate</b> <b>calculus)</b> ...|$|R
5000|$|Inferences in term logic {{can all be}} {{represented}} in the monadic <b>predicate</b> <b>calculus.</b> For example the syllogism ...|$|R
40|$|Many query {{languages}} {{are currently being}} proposed for specifying XML document retrievals. The expressive power and usefulness of these query languages is really based on their embedded formalisms and intended XML document applications. The emerging MPEG- 7 multimedia standard uses XML Schema:Datatypes for multimedia content descriptions and has posed an interesting challenge to XML query language design for XML document retrievals. Most XML query language proposals have limitations in specifying queries {{for this type of}} XML documents. In this paper, we have identified some critical specification issues in MPEG- 7 XML queries and propose an XML query language, MMDOC-QL with multimedia query constructs. MMDOC-QL is based on a logic formalism, called path <b>predicate</b> <b>calculus.</b> In this path <b>predicate</b> <b>calculus,</b> the atomic logic formulas are element predicates rather than relation <b>predicates</b> in relational <b>calculus.</b> In this path <b>calculus</b> query <b>language,</b> queries in this calculus are equivalent to finding all proofs to existential closure of logical assertions in the form of path predicates that the tree document elements must satisfy. Spatial, temporal and visual datatypes and relationships can also be described in this formalism for content retrieval. A Logic Approach for MPEG- 7 XML Document Querie...|$|R
50|$|This section {{describes}} the propositional and <b>predicate</b> <b>calculus,</b> {{and gives the}} basic properties of classes, relations, and types.|$|R
5000|$|In particular, simple {{sentences}} that employ notions of [...] "all", [...] "some", [...] "a few", [...] "one of", etc. are {{treated by the}} <b>predicate</b> <b>calculus.</b> Along with the new function symbolism [...] "F(x)" [...] two new symbols are introduced: ∀ (For all), and ∃ (There exists ..., At least one of ... exists, etc.). The <b>predicate</b> <b>calculus,</b> but not the propositional calculus, can establish the formal validity of the following statement: ...|$|R
40|$|Abstract-The {{purpose of}} this {{correspondence}} is to present an approach for verifying that explicitly stated integrity constraints are not violated by certain transactions. We utilize a relational model wherein constraints are given in a language based on fthe first-order <b>predicate</b> <b>calculus.</b> Transactions are written {{in terms of a}} Pascal-likehost language with embedded first-order <b>predicate</b> <b>calculus</b> capabilities allowing queries and updates. The technique for proving consistency of the transactions is based upon the Hoare axiomatic approach. We illustrate the method by means of an explicit example of a database updated by four types of transaction. A generalized transaction consistency verifier embodying this approach would considerably enhance transaction programming in a relational database management system. Index Terms-Consistency, correctness proof, integrity constraint, <b>predicate</b> <b>calculus,</b> relational database, transaction. I...|$|R
50|$|C. L. Hamblin 1973: A felicitous {{fragment}} of the <b>predicate</b> <b>calculus.</b> Notre Dame Journal of Formal Logic. 14: 433-446.|$|R
5000|$|The Cyc {{project has}} its own {{ontology}} language called CycL, based on first-order <b>predicate</b> <b>calculus</b> with some higher-order extensions.|$|R
40|$|We {{report on}} a {{computer}} tutor for the semantics of the Prolog subset of <b>predicate</b> <b>calculus.</b> It gives students statements in English to represent in a single line of Prolog, parses their answers, and compares the parses to the parses of correct answers. The tutor focuses on the correct choice of predicates, variables, and links between expressions. Students seem to learn <b>predicate</b> <b>calculus</b> better using the tutor than with paper and pencil exercises...|$|R
