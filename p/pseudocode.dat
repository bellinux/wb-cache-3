832|51|Public
25|$|The {{algorithm}} may {{be expressed}} in the following <b>pseudocode.</b>|$|E
25|$|Algorithms can be {{expressed}} in many kinds of notation, including natural languages, <b>pseudocode,</b> flowcharts, drakon-charts, programming languages or control tables (processed by interpreters). Natural language expressions of algorithms tend to be verbose and ambiguous, and are rarely used for complex or technical algorithms. <b>Pseudocode,</b> flowcharts, drakon-charts and control tables are structured ways to express algorithms that avoid many of the ambiguities common in natural language statements. Programming languages are primarily intended for expressing algorithms {{in a form that}} can be executed by a computer, but are often used as a way to define or document algorithms.|$|E
25|$|For {{the above}} {{algorithm}} to correctly re-heapify the array, the node at index i and its two direct children must violate the heap property. If they do not, the algorithm will fall through with no {{change to the}} array. The down-heap operation (without the preceding swap) {{can also be used}} to modify the value of the root, even when an element is not being deleted. In the <b>pseudocode</b> above, what starts with // is a comment. Note that A is an array (or list) that starts being indexed from 1 up to length(A), according to the <b>pseudocode.</b>|$|E
30|$|In this “Appendix” {{we provide}} details and <b>pseudocodes</b> of the {{numerical}} procedure described in “CreditMetrics approach” section.|$|R
30|$|The <b>pseudocodes</b> of the {{following}} algorithms were adapted from [36]. Before the execution of these algorithms, the respective number of blocks (as well as their sizes) used to help on the parallelization of their procedures are determined.|$|R
30|$|We adapt {{standard}} methodologies for the deduplication of datasets [36, 37] to our specific case. Here we {{only give}} {{an overview of}} the working of the algorithm. For a more detailed description and the <b>pseudocodes,</b> see Ref. [33].|$|R
25|$|The only {{difficult}} step {{in implementing}} the Schulze method is computing the strongest path strengths. However, this is a well-known problem in graph theory sometimes called the widest path problem. One simple way to compute the strengths therefore is {{a variant of the}} Floyd–Warshall algorithm. The following <b>pseudocode</b> illustrates the algorithm.|$|E
25|$|Optimal routing. In this {{application}} one {{is interested in}} finding the path with the maximum flow between two vertices. This means that, rather than taking minima as in the <b>pseudocode</b> above, one instead takes maxima. The edge weights represent fixed constraints on flow. Path weights represent bottlenecks; so the addition operation above is replaced by the minimum operation.|$|E
25|$|When {{manipulating}} linked lists in-place, {{care must}} be taken to not use values that you have invalidated in previous assignments. This makes algorithms for inserting or deleting linked list nodes somewhat subtle. This section gives <b>pseudocode</b> for adding or removing nodes from singly, doubly, and circularly linked lists in-place. Throughout we will use null to refer to an end-of-list marker or sentinel, which may be implemented in a number of ways.|$|E
30|$|Treatment of imprecise and alias values. In this sub-layer {{words that}} denote imprecise values (i.e., words that {{represent}} value ranges) and aliases (i.e., words for referring to numerical values, such as noon, dozen, third) are detected and dealt with. Algorithms 2 and 3 show the <b>pseudocodes</b> (as implemented) that describe the general structure of this functionality sub-layer.|$|R
40|$|We {{discuss a}} variety of {{iterative}} methods {{that are based on}} the Arnoldi process for solving large sparse symmetric indefinite linear systems. We describe the SYMMLQ and SYMMQR methods, as well as generalizations and modifications of them. Then, we cover the Lanczos/MSYMMLQ and Lanczos/MSYMMQR methods, which arise from a double linear system. We present <b>pseudocodes</b> for these algorithms...|$|R
40|$|This paper {{presents}} {{the development and}} application of the p-adaptive BIEM version in elastostatics. The basic concepts underlying the p-adaptive technique are summarized and discussed. Some Pascal <b>pseudocodes</b> which show the way how such a technique can be implemented easily in microcomputers are also provided. Both the applicability and {{the accuracy of the}} method proposed here are illustrated through a numerical example...|$|R
25|$|The {{following}} is {{a simple way to}} implement the algorithm in <b>pseudocode.</b> Arrays are zero-based and swap is used to exchange two elements of the array. Movement 'down' means from the root towards the leaves, or from lower indices to higher. Note that during the sort, the largest element {{is at the root of}} the heap at a, while at the end of the sort, the largest element is in a.|$|E
25|$|In the {{following}} {{the most commonly}} used (μ/μw, λ)-CMA-ES is outlined, where in each iteration step a weighted combination of the μ best out of λ new candidate solutions is used to update the distribution parameters. The main loop consists of three main parts: 1) sampling of new solutions, 2) re-ordering of the sampled solutions based on their fitness, 3) update of the internal state variables based on the re-ordered samples. A <b>pseudocode</b> of the algorithm looks as follows.|$|E
25|$|Finally, we {{actually}} don't need uDummy because it's there {{just to put}} all unmatched vertices of U in queue when BFS starts. That we can do as just as initialization. The vDummy can be appended in U for convenience in many implementations and initialize default pairing for all V to point to vDummy. That way, if final vertex in V doesn't have any matching vertex in U then we finally end at vDummy which {{is the end of}} our augmented path. In above <b>pseudocode</b> vDummy is denoted as Nil.|$|E
40|$|We provide {{parallel}} matrix-vector multiply routines for 1 D and 2 D partitioned sparse {{square and}} rectangular matrices. We clearly give pseu-docodes that perform necessary initializations for parallel execution. We show how to maximize overlapping between communication and compu-tation through the proper usage of compressed sparse row and compressed sparse column formats of the sparse matrices. We give <b>pseudocodes</b> for multiplication routines which benefit from such overlaps...|$|R
5000|$|The PM Exam is a multiple-choice {{examination}} {{that runs}} 150 minutes. It covers {{knowledge and skills}} required by individuals {{who were able to}} implement <b>pseudocodes</b> and flowcharts. It will require skills in debugging and ability to trace the output of a structured program. Total score is 1000 and each question has its own weight depending on its difficulty. 600 points is the passing score.|$|R
30|$|To {{solve the}} problem (i.e., DTO-MROD) {{described}} in the “Problem formulation” section, we propose a centralized heuristic algorithm for scene (c) of Fig. 1, which could be divided into the three subroutines (i.e., the preselection for the first relay, the preselection for the second relay, and the relay verification, which are executed at the eNB one after another). The corresponding <b>pseudocodes</b> are given in Algorithm  1 ~ 3.|$|R
25|$|Some {{languages}} offer a for-loop {{that acts}} as if processing all iterations in parallel, such as the for all keyword in FORTRAN 95 which has the interpretation that all right-hand-side expressions are evaluated before any assignments are made, as distinct from the explicit iteration form. For example, in the for statement in the following <b>pseudocode</b> fragment, when calculating the new value for A(i), except for the first (with i = 2) the reference to A(i - 1) will obtain the new value that had been placed there in the previous step. In the for all version, however, each calculation refers only to the original, unaltered A.|$|E
500|$|Implementations of the {{algorithm}} may {{be expressed in}} <b>pseudocode.</b> For example, the division-based version may be programmed as ...|$|E
500|$|In practice, {{computational}} addition may {{be achieved}} via XOR and AND bitwise logical operations {{in conjunction with}} bitshift operations {{as shown in the}} <b>pseudocode</b> below. Both XOR and AND gates are straightforward to realize in digital logic allowing the realization of full adder circuits which in turn may be combined into more complex logical operations. In modern digital computers, integer addition is typically the fastest arithmetic instruction, yet it has the largest impact on performance, since it underlies all floating-point operations as well as such basic tasks as address generation during memory access and fetching instructions during branching. To increase speed, modern designs calculate digits in parallel; these schemes go by such names as carry select, carry lookahead, and the Ling pseudocarry. Many implementations are, in fact, hybrids of these last three designs. Unlike addition on paper, addition on a computer often changes the addends. On the ancient abacus and adding board, both addends are destroyed, leaving only the sum. The influence of the abacus on mathematical thinking was strong enough that early Latin texts often claimed that in the process of adding [...] "a number to a number", both numbers vanish. In modern times, the ADD instruction of a microprocessor often replaces the augend with the sum but preserves the addend. In a high-level programming language, evaluating [...] does not change either a or b; if the goal is to replace a with the sum this must be explicitly requested, typically with the statement [...] Some languages such as C or C++ allow this to be abbreviated as [...]|$|E
3000|$|The {{function}} named goertzel_classic.m {{realizes the}} standard Goertzel algorithm for k ∈ Z; the generalized (and shortened) algorithm for k ∈ ℝ is {{implemented in the}} function goertzel_general_shortened.m. The structure of the functions corresponds to the <b>pseudocodes</b> in Figures 3 and 4. Indexing the vector elements, however, starts with [...] " 1 " [...] in Matlab, which differs from our theoretical description, where it starts with [...] " 0 ".|$|R
40|$|Understanding Molecular Simulation: From Algorithms to Applications {{explains}} the physics behind the ""recipes"" of molecular simulation for materials science. Computer simulators are continuously confronted with {{questions concerning the}} choice of a particular technique for a given application. A wide variety of tools exist, so the choice of technique requires a good understanding of the basic principles. More importantly, such understanding may greatly improve the efficiency of a simulation program. The implementation of simulation methods is illustrated in <b>pseudocodes</b> and their practi...|$|R
40|$|Abstract—The {{theory of}} digital {{topology}} {{is used in}} many different image processing and computer graphics algorithms. Most of the existing theories apply to uniform cartesian grids, {{and they are not}} readily extensible to new algorithms targeting at adaptive cartesian grids. This article provides a rigorous extension of the classical digital topology framework for adaptive octree grids, including the characterization of adjacency, connected components, and simple points. Motivating examples, proofs of the major propositions, and algorithm <b>pseudocodes</b> are provided. Keywords—Digital topology, adaptive octree grid, simple point characterization. ...|$|R
2500|$|The {{following}} <b>pseudocode</b> {{illustrates a}} straightforward way to compute g: ...|$|E
2500|$|That is, in <b>pseudocode,</b> the {{algorithm}} performs the following steps: ...|$|E
2500|$|<b>Pseudocode</b> of the {{complete}} algorithm follows, where the arrays are zero-based: ...|$|E
40|$|We {{present the}} {{software}} design principles, algorithms, and utilities {{of a general}} weighted grammar library, the GRM Library, {{that can be used}} in a variety of applications in text, speech, and biosequence processing. Several of the algorithms and utilities of this library are described, including in some cases their <b>pseudocodes</b> and pointers to their use in applications. The algorithms and the utilities were designed to support a wide variety of semirings and the representation and use of large grammars and automata of several hundred million rules or transitions...|$|R
40|$|We study a method, Extra Chance Generalized Hybrid Monte Carlo, {{to avoid}} {{rejections}} in the Hybrid Monte Carlo method and related algorithms. In {{the spirit of}} delayed rejection, whenever a rejection would occur, extra work is done to find a fresh proposal that, hopefully, may be accepted. We present experiments that clearly indicate that the additional work per sample {{carried out in the}} extra chance approach clearly pays in terms {{of the quality of the}} samples generated. Comment: 13 pages, 8 figures (including 1 diagram, 3 <b>pseudocodes),</b> 1 table, updated (corrections, typos and new appendix...|$|R
30|$|The {{paper is}} {{organized}} as follows. Next section evaluates the probability constraint for right truncated Gaussian probability distribution and construct the deterministic convex counterpart of the chance constraint. The next section presents the CreditMetrics approach {{to estimate the}} forward market value of loans. The formulation of the optimization model based on the chance constraint of CRAR is structured and presented. We conduct a numerical example and illustrate the proposed method by a hypothetical example. Results and Concluding remarks are presented in the last section. Details and <b>pseudocodes</b> of the numerical procedure described in “CreditMetrics approach” section are given in “Appendix”.|$|R
2500|$|Typical <b>pseudocode</b> for {{creating}} Fig. 7 (to fit the molecule exactly to the screen): ...|$|E
2500|$|A for-loop can be {{converted}} into an equivalent while-loop by incrementing a counter variable directly. The following <b>pseudocode</b> illustrates this technique: ...|$|E
2500|$|Agoston’s book {{contains}} {{a description of}} HSV and HSL, and algorithms in <b>pseudocode</b> for converting to each from RGB, and back again.|$|E
40|$|This paper {{presents}} a guided and deep introduction to Viral Systems (VS), a novel bio-inspired methodology {{based on a}} natural biological process taking part when the organism has to give a response to an external infection. VS {{has proven to be}} very efficient when dealing with problems of high complexity. The paper discusses on the foundations of viral systems, presents the main <b>pseudocodes</b> that need to be implemented and illustrates the methodology application. A comparison between VS and other metaheuristics, as well between different VS approaches is presented. Finally trends and new research opportunities are presented for this bio-inspired methodolog...|$|R
40|$|We have {{discussed}} the multidimensional parallel computation for pseudo arc-length moving mesh schemes, and the schemes {{can be used to}} capture the strong discontinuity for multidimensional detonations. Different from the traditional Euler numerical schemes, the problems of parallel schemes for pseudo arc-length moving mesh schemes include diagonal processor communications and mesh point communications, which are illustrated by the schematic diagram and key <b>pseudocodes.</b> Finally, the numerical examples are given to show that the pseudo arc-length moving mesh schemes are second-order convergent and can successfully capture the strong numerical strong discontinuity of the detonation wave. In addition, our parallel methods are proved effectively and the computational time is obviously decreased...|$|R
40|$|This paper {{presents}} {{for the first}} time a robust exact line-search method based on a full pseudospectral (PS) numerical scheme employing orthogonal polynomials. The proposed method takes on an adaptive search procedure and combines the superior accuracy of Chebyshev PS approximations with the high-order approximations obtained through Chebyshev PS differentiation matrices (CPSDMs). In addition, the method exhibits quadratic convergence rate by enforcing an adaptive Newton search iterative scheme. A rigorous error analysis of the proposed method is presented along with a detailed set of <b>pseudocodes</b> for the established computational algorithms. Several numerical experiments are conducted on one- and multi-dimensional optimization test problems to illustrate the advantages of the proposed strategy. Comment: 26 pages, 6 figures, 2 table...|$|R
