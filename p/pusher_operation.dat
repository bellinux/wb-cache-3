1|345|Public
5000|$|In a pusher configuration, {{the force}} {{provided}} by the propeller is pushing towards the engine, rather than away. To convert a tractor engine and propeller combination to <b>pusher</b> <b>operation</b> it {{is not sufficient to}} simply turn the engine and propeller round, since the propeller would continue to [...] "pull" [...] driving the aircraft to the rear. Assuming the engine cannot be run in the reverse direction, the [...] "handedness" [...] of the propeller must be reversed. The loads on the thrust race (bearings that prevent fore and aft movement of the crankshaft) are also reversed, because the pusher propeller is pushing into the engine rather than pulling away from it as in a tractor. Some modern engines designed for light aircraft are fitted with a thrust race suitable for both [...] "pushing" [...] and [...] "pulling", but others require a different part depending in which sense they are operating. Power-plant cooling design is more complex than for the tractor configuration, where the propeller forces air through the system.|$|E
5000|$|... #Caption: Amortized Analysis of the <b>Push</b> <b>operation</b> for a Dynamic Array ...|$|R
40|$|AbstractLet D be a digraph and X⊆V(D). By pushingX we mean {{reversing}} each arc of D with {{exactly one}} end in X. Klostermeyer proved {{that it is}} NP-complete to decide if a given digraph can be made acyclic using the <b>push</b> <b>operation.</b> Here we characterize, in terms of forbidden subdigraphs, the multipartite tournaments which can be made acyclic (resp. ordinary, unidirectional) using the <b>push</b> <b>operation.</b> This implies {{that the problem of}} deciding if a given multipartite tournament can be made acyclic (resp. ordinary, unidirectional) using the <b>push</b> <b>operation</b> and, if so, finding a suitable subset of vertices to push, is solvable in polynomial time...|$|R
5000|$|The <b>push</b> <b>operation</b> adds {{an element}} and {{increments}} the top index, after checking for overflow: ...|$|R
25|$|This <b>push,</b> <b>Operation</b> Nomad-Polar, {{was to be}} {{the last}} major United Nations {{offensive}} of the war.|$|R
50|$|A <b>Push</b> <b>operation</b> takes {{constant}} {{time and}} increases Φ by 1, so its amortized time is constant.|$|R
40|$|Camion's theorem {{states that}} a tournament is strong if {{and only if}} it has a Hamilton cycle. We prove that an {{orientation}} of the square of a cycle can be made strong using the vertex <b>push</b> <b>operation</b> (when a vertex is pushed, the direction of each of its incident arcs is reversed) {{if and only if}} it can be made to have a Hamilton cycle using the vertex <b>push</b> <b>operation...</b>|$|R
40|$|Let D be a digraph and X ~ V(D). By pushing X we mean {{reversing}} {{the orientation of}} each arc of D with exactly one end in X. Klostermeyer proved that it is NP-complete to decide if a given digraph can be made acyclic using the <b>push</b> <b>operation.</b> By contrast, Huang, MacGillivray, and Wood showed {{that the problem of}} deciding if a given multipartite tournament can be made acyclic using the <b>push</b> <b>operation</b> is solvable in polynomial time. We define a digraph to be nearly-acyclic if it is obtained from an acyclic digraph by substituting a (directed) triangle or a single vertex for each vertex of the acyclic digraph. It is shown that it is NPcomplete to decide if a given digraph can be made nearly-acyclic using the <b>push</b> <b>operation.</b> In this paper, we characterize, in terms of forbidden subtournaments, the tournaments which can be made nearly-acyclic by pushing. This implies that the problem of deciding if a given tournament can be made nearly-acyclic using the <b>push</b> <b>operation</b> is solvable in polynomial time. ...|$|R
50|$|In {{order to}} bound the time {{complexity}} of the algorithm, we must analyze the number of <b>push</b> and relabel <b>operations</b> which occur within the main loop. The numbers of relabel, saturating push and nonsaturating <b>push</b> <b>operations</b> are analyzed separately.|$|R
5000|$|The <b>push</b> <b>operation</b> applies on an {{admissible}} out-arc [...] of {{an active}} node [...] in [...] It moves [...] units of flow from [...] to [...]|$|R
40|$|The {{emergence}} of mobile computing provides {{the ability to}} access information {{at any time and}} place. However, as mobile computing environments have inherent factors like power, storage, asymmetric communication cost, and bandwidth limitations, efficient query processing and minimum query response time are definitely of great interest. This survey groups a variety of query optimization and processing mechanisms in mobile databases into two main categories, namely: (i) query processing strategy, and (ii) caching management strategy. Query processing includes both pull and <b>push</b> <b>operations</b> (broadcast mechanisms). We further classify <b>push</b> <b>operation</b> into on-demand broadcast and periodic broadcast. <b>Push</b> <b>operation</b> (on-demand broadcast) relates to designing techniques that enable the server to accommodate multiple requests so that the request can be processed efficiently. <b>Push</b> <b>operation</b> (periodic broadcast) corresponds to data dissemination strategies. In this scheme, several techniques to improve the query performance by broadcasting data to a population of mobile users are described. A caching management strategy defines a number of methods for maintaining cached data items in clients' local storage. This strategy considers critical caching issues such as caching granularity, caching coherence strategy and caching replacement policy. Finally, this survey concludes with several open issues relating to mobile query optimization and processing strategy...|$|R
50|$|The tag {{added by}} a tag <b>push</b> <b>{{operation}}</b> becomes a new outer tag.The tag {{to be removed}} by a tag pop operation is the current outer tag.|$|R
5000|$|... #Caption: Bi-level New Jersey Transit train {{led by a}} cab {{car with}} quarter-point and end doors. Note how the cab car makes the train less {{aerodynamic}} in <b>push</b> <b>operation.</b>|$|R
40|$|An {{oriented}} graph is a directed graph without any cycle of length at most 2. To push a vertex of a directed graph is {{to reverse the}} orientation of the arcs incident to that vertex. Klostermeyer and MacGillivray defined push graphs which are equivalence class of {{oriented graph}}s with respect to vertex <b>pushing</b> <b>operation.</b> They studied the homomorphism of the equivalence classes of oriented graphs with respect to <b>push</b> <b>operation.</b> In this article, we further study the same topic and answer some of the questions asked in the above mentioned work. The anti-twinned graph of an oriented graph is obtained by adding and pushing a copy of each of its vertices. In particular, we show that two oriented graphs are in a push relation if and only if they have isomorphic anti-twinned graphs. Moreover, we study oriented homomorphisms of outerplanar graphs with girth at least five, planar graphs and planar graphs with girth at least eight with respect to the <b>push</b> <b>operation...</b>|$|R
5000|$|For a <b>push</b> <b>operation</b> on an {{admissible}} arc , it may add an arc [...] to , {{where it}} may also remove the arc [...] from , where it effectively removes the constraint [...]|$|R
50|$|Popping {{the stack}} {{is simply the}} inverse of pushing. The topmost item in the stack is removed and the stack pointer is updated, in the {{opposite}} order of that used in the <b>push</b> <b>operation.</b>|$|R
5000|$|... a <b>push</b> <b>operation,</b> {{in which}} a data item is placed at the {{location}} pointed to by the stack pointer, and the address in the stack pointer is adjusted {{by the size of}} the data item; ...|$|R
5000|$|The relabel {{operation}} {{can increase}} [...] by at most [...] A saturating push on [...] activates [...] {{if it was}} inactive before the push, increasing [...] by at most [...] Hence, the total contribution of all saturating <b>pushes</b> <b>operations</b> to [...] is at most [...] A nonsaturating push on [...] always deactivates , {{but it can also}} activate [...] as in a saturating push. As a result, it decreases [...] by at least [...] Since relabels and saturating pushes increase , the total number of nonsaturating pushes must make up the difference of [...] This results in a time bound of [...] for the nonsaturating <b>push</b> <b>operations.</b>|$|R
5000|$|In a <b>push</b> <b>operation</b> a new {{label is}} pushed {{on top of}} the {{existing}} label, effectively [...] "encapsulating" [...] the packet in another layer of MPLS. This allows hierarchical routing of MPLS packets. Notably, this is used by MPLS VPNs.|$|R
50|$|The third rule form, {{the push}} rule, {{should be pointed}} out, as it differs from the pop rule in {{requiring}} that all <b>push</b> <b>operations</b> introduce at least one new terminal symbol to the derivation string. Without this constraint, the class of grammars would be Type-0 and thus Turing Complete.|$|R
5000|$|A <b>push</b> <b>operation</b> {{that causes}} [...] to reach [...] {{is called a}} saturating push since it uses up all the {{available}} capacity of the residual arc. Otherwise, all of the excess at the node is pushed across the residual arc. This is called an unsaturating or non-saturating push.|$|R
30|$|Policies are {{instantiated}} {{by means}} of a pull or a <b>push</b> <b>operation</b> invoked on the Queries API (as shown in Fig.  7) resulting in the instantiation of either: i) a location policy as the one presented in Fig.  9, or ii) a notification policy as the one presented in Fig.  10.|$|R
5000|$|The push-relabel {{algorithm}} uses a nonnegative integer valid labeling function {{which makes}} use of distance labels, or heights, on nodes to determine which arcs should be selected for the <b>push</b> <b>operation.</b> This labeling function is denoted by [...] This function must satisfy the following conditions {{in order to be}} considered valid: ...|$|R
5000|$|The {{algorithm}} starts {{by creating}} a residual graph, initialising the preflow values to zero and performing a set of saturating <b>push</b> <b>operations</b> on residual arcs exiting the source, [...] Similarly, the labels are initialised such that the label at the source {{is the number of}} nodes in the graph, , and all other nodes are given a label of zero. Once the initialisation is complete the algorithm repeatedly performs either the <b>push</b> or relabel <b>operations</b> against active nodes until no applicable operation can be performed.|$|R
50|$|Mason {{received}} his B.S., M.S., and Ph.D. {{degrees from the}} Massachusetts Institute of Technology in 1976, 1978, and 1982, respectively. His M.S. Thesis Compliance and Force Control for Computer Control led Manipulators was advised by Berthold K. P. Horn, and his Ph.D. thesis Manipulator Grasping and <b>Pushing</b> <b>Operations</b> was advised by Tomas Lozano-Perez and Berthold K. P. Horn.|$|R
40|$|AbstractGiven a digraph D and {{a subset}} X of {{vertices}} of D, pushing X in D means reversing {{the orientation of}} all arcs with exactly one end in X. We continue the study of deciding whether a digraph can be made acyclic using the <b>push</b> <b>operation,</b> focussing on special classes of well-structured digraphs. It is proved that the problem remains NP-complete even when restricted to the class of bipartite digraphs (i. e., oriented bipartite graphs). We characterize, in terms of two forbidden subdigraphs, the chordal digraphs which can be made acyclic using the <b>push</b> <b>operation,</b> and {{show that there is}} no similar characterization for the family of chordal bipartite digraphs. A polynomial algorithm, based on 2 -SAT, for solving the problem for a subclass of the chordal bipartite digraphs is given. Finally, a characterization in terms of a finite number of forbidden subdigraphs, of the acyclically pushable bipartite permutation digraphs is given...|$|R
40|$|AbstractWe combine two {{topics in}} {{directed}} graphs {{which have been}} studied separately, vertex pushing and homomorphisms, by studying homomorphisms of equivalence classes of oriented graphs under the <b>push</b> <b>operation.</b> Some theory of these mappings is developed and {{the complexity of the}} associated decision problems is determined. These results are then related to oriented colorings. Informally, the pushable chromatic number of an oriented graph G is the minimum value of the oriented chromatic number of any digraph obtainable from G using the <b>push</b> <b>operation.</b> The pushable chromatic number is used to give tight upper and lower bounds on the oriented chromatic number. The complexity of deciding if the pushable chromatic number of a given oriented graph is at most a fixed positive integer k is determined. It is proved that the pushable chromatic number of a partial 2 -tree is at most four. Finally, the complexity of deciding if the oriented chromatic number of a given oriented graph is at most a fixed positive integer k is determined...|$|R
40|$|Given a digraph D and {{a subset}} X of {{vertices}} of D, pushing X in D means reversing {{the orientation of}} all arcs with exactly one end in X. It is known {{that the problem of}} deciding whether a given digraph can be made acyclic using the <b>push</b> <b>operation</b> is NP-complete for general digraphs, and polynomial time solvable for multipartite tournaments. Here, we continue the study of deciding whether a digraph is acyclically pushable, focussing on special classes of well-structured digraphs. It is proved that the problem remains NP-complete even when restricted to the class of bipartite digraphs (i. e., oriented bipartite graphs) and we characterize, in terms of two forbidden subdigraphs, the chordal digraphs which can be made acyclic using the <b>push</b> <b>operation.</b> An infinite family of chordal bipartite digraphs which are not acyclically pushable is described. A polynomial algorithm, based on 2 -SAT, for solving the problem for a subclass of the chordal bipartite digraphs is given. Finally, a [...] ...|$|R
5000|$|... 27/1: Locomotives {{converted}} in 1971-1973 for <b>push</b> pull <b>operation,</b> renumbered back to 27/0 after 1982.|$|R
50|$|The 218.4 {{locomotives}} {{capable of}} <b>push</b> pull <b>operation</b> {{were to be}} used with double decker passenger coaches.|$|R
50|$|In general if we {{consider}} an arbitrary number of pushes n + 1 to an array of size n, we notice that <b>push</b> <b>operations</b> take constant time except for the last one which takes O(n) time to perform the size doubling operation. Since there were n + 1 operations total we can take the average of this and find that pushing elements onto the dynamic array takes: , constant time.|$|R
40|$|We {{address the}} problem of {{detecting}} and pushing stationary objects in a planar environment by using an environment-embedded sensor network and a simple mobile robot. The stationary sensors are used to detect pushable objects. The robot pushes a detected object based on pose information obtained from the sensors over a wireless network. We show that the accuracy of the <b>push</b> <b>operation</b> is correlated to the number of sensors used to determine object pose...|$|R
50|$|On 2 July 2009, 2nd LAR, as the {{southern}} <b>push</b> of <b>Operation</b> Khanjar, entered Khan Neshin village with the village elders' permission.|$|R
5000|$|The {{algorithm}} {{maintains the}} condition that [...] is a valid labeling during its execution. This can be proven true by examining {{the effects of the}} <b>push</b> and relabel <b>operations</b> on the label function [...] The relabel operation increases the label value by the associated minimum plus one which will always satisfy the [...] constraint. The <b>push</b> <b>operation</b> can send flow from [...] to [...] if [...] This may add [...] to [...] and may delete [...] from [...] The addition of [...] to [...] will not affect the valid labeling since [...] The deletion of [...] from [...] removes the corresponding constraint since the valid labeling property [...] only applies to residual arcs in [...]|$|R
40|$|For {{more than}} a decade {{peer-to-peer}} networking technologies have met with huge success among Internet users, with peer-to-peer traffic already accounting for the largest part of the Internet's total traffic. Peer-to-peer networks have been extensively studied in recent years as an important supporting technology for state-of-the art applications, such as Live Video Streaming and Video-on-Demand. In this work the case of video-on-demand applications over BitTorrent-like unstructured peer-to-peer networks is considered. As a rule, unstructured peer-to-peer networks are pull-based, whereas push-based operation has been associated mostly with structured, tree-based p 2 p network topologies. While earlier studies maintained the pull-based nature of unstructured networks, recent ones have been investigating the combined use of pull and <b>push</b> <b>operations,</b> aiming at making more efficient use of the available bandwidth. Inspired by such hybrid approaches, this paper proposes a different use for push/pull protocols, uplink allocation based on user actions (i. e. random seek behavior) in video-on-demand applications. In a nutshell, this work proposes the employment of user-triggered <b>push</b> <b>operations</b> to prioritize content pre-fetching for the seemingly more popular parts for the users watching a video, thus increasing replication of such parts across the swarm. © 2014 IEEE...|$|R
50|$|On 18 June 2009, Marines from 2nd Battalion, 8th Marines (2/8), {{as part of}} the {{northern}} <b>push</b> of <b>Operation</b> Khanjar, entered Garmsir Province.|$|R
