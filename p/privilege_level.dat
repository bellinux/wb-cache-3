146|92|Public
25|$|Assigning {{privilege}} {{levels to}} each segment. Segment with lower <b>privilege</b> <b>level</b> cannot access the segment with higher <b>privilege</b> <b>level.</b>|$|E
25|$|The IOPL can {{be changed}} using POPF(D) and IRET(D) only when the current <b>privilege</b> <b>level</b> is Ring 0.|$|E
25|$|The {{real mode}} {{programs}} in 8086 are executed at level 0 (highest <b>privilege</b> <b>level)</b> whereas virtual mode in 8086 executes all programs at level 3.|$|E
50|$|The Exec {{contains}} all the code {{in the system}} that is allowed to run at the highest <b>privilege</b> <b>levels.</b> There are no mechanisms for other code to be promoted to those <b>privilege</b> <b>levels.</b>|$|R
2500|$|While the x86 {{architecture}} supports {{four different}} <b>privilege</b> <b>levels</b> (numbered 0 to 3), {{only the two}} extreme <b>privilege</b> <b>levels</b> are used. Usermode programs are run with CPL 3, and the kernel runs with CPL 0. These two levels are {{often referred to as}} [...] "ring 3" [...] and [...] "ring 0", respectively. Such a design decision had been done to achieve code portability to RISC platforms that only support two <b>privilege</b> <b>levels,</b> though this breaks compatibility with OS/2 applications that contain I/O privilege segments that attempt to directly access hardware.|$|R
2500|$|... (Order Number 243192) Chapter 4 Protection; section 4.5 <b>Privilege</b> <b>levels.</b> (pdf) ...|$|R
25|$|MIPS III added a {{supervisor}} <b>privilege</b> <b>level</b> {{in between the}} existing kernel and user privilege levels. This feature only affected the implementation-defined System Control Processor (Coprocessor 0).|$|E
25|$|It is not {{necessary}} to use all four privilege levels, because the current Operating Systems like Windows, Linux, etc. mostly are using Paging mechanism and Paging only has one bit to specify the <b>privilege</b> <b>level</b> which is either Supervisor or User (U/S Bit). Windows NT uses the two-level system.|$|E
25|$|The Windows kernel is {{designed}} so that device drivers have the same <b>privilege</b> <b>level</b> as the kernel itself. In turn, device drivers are expected to not modify or patch core system structures within the kernel. In x86 editions of Windows, Windows does not enforce this expectation that drivers not patch the kernel. But because the expectation is not enforced on x86 systems, some programs, notably certain security and antivirus programs, were designed to perform needed tasks through loading drivers that modified core kernel structures.|$|E
30|$|Access control {{makes use}} of {{authentication}} and authorization mechanisms in order to verify the identity of network entities and enforce distinct <b>privilege</b> <b>levels</b> for each. This countermeasure is approached in two different manners in the literature, namely Trusted Virtual Domains and sandboxes. While these approaches {{are closely related to}} the notion of controlled execution domains, note that access control is performed {{in order to ensure that}} entities are granted the appropriate <b>privilege</b> <b>levels.</b>|$|R
50|$|Project MAC at MIT, {{working with}} GE and Bell Labs, {{developed}} Multics, which introduced {{the concept of}} ringed security <b>privilege</b> <b>levels.</b>|$|R
25|$|General Electric and MIT {{developed}} General Electric Comprehensive Operating Supervisor (GECOS), which {{introduced the}} concept of ringed security <b>privilege</b> <b>levels.</b> After acquisition by Honeywell it was renamed General Comprehensive Operating System (GCOS).|$|R
25|$|Special gates between {{rings are}} {{provided}} to allow an outer ring to access an inner ring's resources in a predefined manner, {{as opposed to}} allowing arbitrary usage. Correctly gating access between rings can improve security by preventing programs from one ring or <b>privilege</b> <b>level</b> from misusing resources intended for programs in another. For example, spyware running as a user program in Ring 3 should be prevented from turning on a web camera without informing the user, since hardware access should be a Ring 1 function reserved for device drivers. Programs such as web browsers running in higher numbered rings must request access to the network, a resource restricted to a lower numbered ring.|$|E
25|$|The Virtual Machine Manager (VMM) is the 32-bit {{protected}} mode kernel {{at the core}} of Windows 9x. Its primary responsibility is to create, run, monitor and terminate virtual machines. The VMM provides services that manage memory, processes, interrupts and protection faults. The VMM works with virtual devices (loadable kernel modules, which consist mostly of 32-bit ring 0 or kernel mode code, but may include other types of code, such as a 16-bit real mode initialisation segment) to allow those virtual devices to intercept interrupts and faults to control the access that an application has to hardware devices and installed software. Both the VMM and virtual device drivers run in a single, 32-bit, flat model address space at <b>privilege</b> <b>level</b> 0 (also called ring 0). The VMM provides multi-threaded, preemptive multitasking. It runs multiple applications simultaneously by sharing CPU (central processing unit) time between the threads in which the applications and virtual machines run.|$|E
25|$|The {{protected}} mode of the 80286 was not utilized until {{many years after}} its release, {{in part because of}} the high cost of adding extended memory to a PC, but also because of the need for software to support the large user base of 8086 PCs. For example, in 1986 the only program that made use of it was VDISK, a RAM disk driver included with PC DOS 3.0 and 3.1. A DOS could utilize the additional RAM available in {{protected mode}} (extended memory) either via a BIOS call (INT 15h, AH=87h), as a RAM disk, or as emulation of expanded memory. The difficulty lay in the incompatibility of older real-mode DOS programs with protected mode. They simply could not natively run in this new mode without significant modification. In protected mode, memory management and interrupt handling were done differently than in real mode. In addition, DOS programs typically would directly access data and code segments that did not belong to them, as real mode allowed them to do without restriction; in contrast, the design intent of protected mode was to prevent programs from accessing any segments other than their own unless special access was explicitly allowed. While it was possible to set up a protected-mode environment that allowed all programs access to all segments (by putting all segment descriptors into the GDT and assigning them all the same <b>privilege</b> <b>level),</b> this undermined nearly all of the advantages of protected mode except the extended (24-bit) address space. The choice that OS developers faced was either to start from scratch and create an OS that would not run the vast majority of the old programs, or to come up with a version of DOS that was slow and ugly (i.e., ugly from an internal technical viewpoint) but would still run a majority of the old programs. Protected mode also did not provide a significant enough performance advantage over the 8086-compatible real mode to justify supporting its capabilities; actually, except for task switches when multitasking, it actually yielded only a performance disadvantage, by slowing down many instructions through a litany of added privilege checks. In protected mode, registers were still 16-bit, and the programmer was still forced to use a memory map composed of 64kB segments, just like in real mode.|$|E
30|$|MinPL and MaxPL are {{the numbers}} between 0 and 1, and where MinPL â‰¤ MaxPL, respectively, denote the minimum and maximum <b>privilege</b> <b>levels</b> {{of a given}} role. Expiration time {{is the time when}} the {{certificate}} becomes invalid and must be renewed.|$|R
50|$|Working of {{hardware-based}} security: A {{hardware device}} allows a user to log in, log out and set different <b>privilege</b> <b>levels</b> by doing manual actions. The device uses biometric technology to prevent malicious users from logging in, logging out, and changing <b>privilege</b> <b>levels.</b> The {{current state of}} a user of the device is read by controllers in peripheral devices such as hard disks. Illegal access by a malicious user or a malicious program is interrupted based on {{the current state of}} a user by hard disk and DVD controllers making illegal access to data impossible. Hardware-based access control is more secure than protection provided by the operating systems as operating systems are vulnerable to malicious attacks by viruses and hackers. The data on hard disks can be corrupted after a malicious access is obtained. With hardware-based protection, software cannot manipulate the user <b>privilege</b> <b>levels.</b> It is impossible for a hacker or a malicious program to gain access to secure data protected by hardware or perform unauthorized privileged operations. This assumption is broken only if the hardware itself is malicious or contains a backdoor. The hardware protects the operating system image and file system privileges from being tampered. Therefore, a completely secure system can be created using a combination of hardware-based security and secure system administration policies.|$|R
50|$|Intel SGX {{is a set}} of CPU code {{instructions}} from Intel that allows user-level code to allocate private regions of memory, called enclaves, that are protected from processes running at higher <b>privilege</b> <b>levels.</b> Intel designed SGX to be useful for implementing secure remote computation, secure browsing, and digital rights management (DRM).|$|R
500|$|Privilege (SP, JP, ZP): A {{ranking system}} based on one's class year which determines what traditions an Aggie student is allowed to perform. The {{privilege}} levels are, SP, JP, and ZPs: sophomore, junior, and senior privileges, respectively. Freshmen have [...] "fish privileges". In the Corps, one's <b>privilege</b> <b>level</b> has an enormous effect on a cadet's lifestyle. Some rules like wildcatting or whooping extend to non-regs.|$|E
2500|$|The IOPL (I/O <b>Privilege</b> <b>level)</b> flag is a flag {{found on}} all IA-32 {{compatible}} x86 CPUs. [...] It occupies bits 12 and 13 in the FLAGS register. [...] In protected mode and long mode, {{it shows the}} I/O <b>privilege</b> <b>level</b> of the current program or task. [...] The Current <b>Privilege</b> <b>Level</b> (CPL) (CPL0, CPL1, CPL2, CPL3) of the task or program must be {{less than or equal}} to the IOPL in order for the task or program to access I/O ports.|$|E
2500|$|... "To assist virtualization, VT and Pacifica {{insert a}} new <b>privilege</b> <b>level</b> beneath Ring 0. Both add nine new machine code {{instructions}} that only work at [...] "Ring -1," [...] {{intended to be}} used by the hypervisor. [...] " ...|$|E
30|$|There {{might be}} some roles that {{routinely}} need to make mission-critical updates and these updates might give the role a bad reputation. Therefore, such crucial roles will have high minimum <b>privilege</b> <b>levels</b> {{so that they can}} do their job even with low reputation scores. However, extra precautions have to be taken to protect such roles from compromise.|$|R
50|$|CPU modes (also called {{processor}} modes, CPU states, CPU <b>privilege</b> <b>levels</b> {{and other}} names) are operating modes {{for the central}} processing unit of some computer architectures that place restrictions on the type and scope of operations that can be performed by certain processes being run by the CPU. This design allows the operating system to run with more privileges than application software.|$|R
5000|$|Real mode, {{also called}} real address mode, is an {{operating}} mode of all x86-compatible CPUs. Real mode {{is characterized by}} a 20-bit segmented memory address space (giving exactly 1 MiB of addressable memory) and unlimited direct software access to all addressable memory, I/O addresses and peripheral hardware. Real mode provides no support for memory protection, multitasking, or code <b>privilege</b> <b>levels.</b>|$|R
2500|$|A <b>privilege</b> <b>level</b> in the x86 and x86-64 {{instruction}} sets {{controls the}} access {{of the program}} currently running on the processor to resources such as memory regions, I/O ports, and special instructions. [...] There are 4 privilege levels ranging from 0 {{which is the most}} privileged, to 3 which is least privileged. [...] Most modern operating systems use level 0 for the kernel/executive, and use level 3 for application programs. [...] Any resource available to level n is also available to levels 0 to n, so the privilege levels are [...] "rings". When a lesser privileged process tries to access a higher privileged process, a General Protection Fault is reported by the OS.|$|E
2500|$|Ultimately, since device {{drivers have}} the same <b>privilege</b> <b>level</b> as the kernel itself, it is {{impossible}} to completely prevent drivers from bypassing Kernel Patch Protection and then patching the kernel. KPP does however present a significant obstacle to successful kernel patching. With highly obfuscated code and misleading symbol names, KPP employs security through obscurity to hinder attempts to bypass it. Periodic updates to KPP also make it a [...] "moving target", as bypass techniques that may work for a while are likely to break with the next update. Since its creation in 2005, Microsoft has so far released two major updates to KPP, each designed to break known bypass techniques in previous versions.|$|E
2500|$|Ultimately, {{the purpose}} of {{distinct}} operating modes for the CPU is to provide hardware protection against accidental or deliberate corruption of the system environment (and corresponding breaches of system security) by software. Only [...] "trusted" [...] portions of system software are allowed to execute in the unrestricted environment of kernel mode, and then, in paradigmatic designs, only when absolutely necessary. All other software executes {{in one or more}} user modes. If a processor generates a fault or exception condition in a user mode, in most cases system stability is unaffected; if a processor generates a fault or exception condition in kernel mode, most operating systems will halt the system with an unrecoverable error. When a hierarchy of modes exists (ring-based security), faults and exceptions at one <b>privilege</b> <b>level</b> may destabilize only the higher-numbered privilege levels. Thus, a fault in Ring 0 (the kernel mode with the highest privilege) will crash the entire system, but a fault in Ring 2 will only affect rings 3 and beyond and Ring 2 itself, at most.|$|E
50|$|The GDT {{can hold}} {{things other than}} segment {{descriptors}} as well. Every 8-byte entry in the GDT is a descriptor, but these can be Task State Segment (or TSS) descriptors, Local Descriptor Table (LDT) descriptors, or Call Gate descriptors. The last ones, Call Gates, are particularly important for transferring control between x86 <b>privilege</b> <b>levels</b> although this mechanism is not used on most modern operating systems.|$|R
50|$|In {{protected}} mode, {{there are}} four <b>privilege</b> <b>levels</b> or rings, numbered from 0 to 3, with ring 0 being the most privileged and 3 being the least. The use of rings allows for system software to restrict tasks from accessing data, call gates or executing privileged instructions. In most environments, the operating system and some device drivers run in ring 0 and applications run in ring 3.|$|R
50|$|The {{architecture}} of most modern processors, {{with the exception}} of some embedded systems, involves a security model. For example, the rings model specifies multiple <b>privilege</b> <b>levels</b> under which software may be executed: a program is usually limited to its own address space so that it cannot access or modify other running programs or the operating system itself, and is usually prevented from directly manipulating hardware devices (e.g. the frame buffer or network devices).|$|R
5000|$|Assigning Privilege {{levels to}} each segment. Segment with lower <b>privilege</b> <b>level</b> cannot access the segment with higher <b>privilege</b> <b>level.</b>|$|E
5000|$|... where CPL is {{the current}} <b>privilege</b> <b>level</b> (found in the lower 2 bits of the CS register), RPL is the {{requested}} <b>privilege</b> <b>level</b> from the segment selector, and DPL is the descriptor <b>privilege</b> <b>level</b> of the segment (found in the descriptor). All privilege levels are integers in the range 0-3, where the lowest number corresponds to the highest privilege.|$|E
5000|$|When {{returning}} to a non-canonical address using , AMD64 processors execute the general protection fault handler in <b>privilege</b> <b>level</b> 3, while on Intel 64 processors it is executed in <b>privilege</b> <b>level</b> 0.|$|E
50|$|Nirvana {{can be used}} {{to control}} access to data by setting up {{specific}} access control lists by user, group etc. using user-defined metadata attributes (Project, Study, etc.) and by setting access <b>privilege</b> <b>levels</b> where users assigned higher levels can see more information than others assigned lower levels. Nirvana supports single sign-on and access by integrating with the Lightweight Directory Access Protocol (LDAP) and Active Directory, using Challenge-response authentication, Grid Security Infrastructure (GSI), and Kerberos. Data can only be viewed and modified by users authorized to do so.|$|R
40|$|The {{main goal}} of this thesis was to detect hide {{resources}} in GNU/Linux operating systems and analyse tools so called rootkits, which are used to hide system resources. This thesis is devided into two parts, theoretical and practical one. Theoretic part focusses on resource managment, representation, <b>privilege</b> <b>levels</b> and system calls. Practical part covers design and implementation of an abstract detector. Each new detection method is implemented as a plugin. Some of those methods are realized as linux kernel modules. The usability of the detector is compared against real rootkits...|$|R
30|$|This {{certificate}} {{is signed}} by the administrator and given to the user, say John, who is assigned a role of major. All the majors have the same maximum and minimum <b>privilege</b> <b>levels.</b> John can carry this certificate on a smart card, or this certificate {{can be linked to}} John's login credentials so that it becomes active whenever John logs in to a machine. That machine then becomes a node with the Node ID given by John's certificate. In this way, the certificate is not linked with any particular machine, rather with the user himself who is free to switch machines in the network.|$|R
