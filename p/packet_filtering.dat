308|402|Public
25|$|A {{firewall}} is {{an integrated}} collection of security measures {{designed to prevent}} unauthorized electronic access to a networked computer system. At AT Bell Labs, William Cheswick and Steven M. Bellovin were continuing their research in <b>packet</b> <b>filtering</b> and co-invented a working model for their own company based upon their original first generation architecture of a firewall.|$|E
25|$|The OpenDataPlane project (ODP) is an open-source, {{cross-platform}} set {{of application}} programming interfaces (APIs) for the networking data plane. OpenDataPlane implementations for several processors, including ARM, Intel x86, MIPS and Power have existed since September 2014. Most recently Virtual Open Systems has demonstrated VOSYSwitch connecting chained VNFs, with the virtualized infrastructure implementing an OpenFastPath web server behind an OpenDataPlane enabled <b>packet</b> <b>filtering</b> firewall.|$|E
25|$|ACK {{scanning}} {{is one of}} {{the more}} unusual scan types, as it does not exactly determine whether the port is open or closed, but whether the port is filtered or unfiltered. This is especially good when attempting to probe for the existence of a firewall and its rulesets. Simple <b>packet</b> <b>filtering</b> will allow established connections (packets with the ACK bit set), whereas a more sophisticated stateful firewall might not.|$|E
40|$|<b>Packet</b> <b>filters</b> {{are widely}} adopted {{security}} technologies that provide strong security defenses to a network. However, despite their strength they also pose a danger with {{a false sense}} of security. In this paper, we assess <b>packet</b> <b>filter</b> technology to provide an increased understanding of their limitations. We describe shortcomings around design, administration, and performance of <b>packet</b> <b>filters</b> and how these shortcomings decrease the e#ectiveness of <b>packet</b> <b>filters.</b> While operatorsf <b>packet</b> <b>filters</b> might be able to address these shortcomings by practicing defense in depth and breadth, we also present research opportunities to continue to improve <b>packet</b> <b>filter</b> technology...|$|R
40|$|Abstract—Multiple <b>packet</b> <b>filters</b> serving {{different}} purposes (e. g., firewalling, QoS) and different virtual routers are often deployed {{on a single}} physical router. The HyperCuts decision tree is one efficient data structure for performing <b>packet</b> <b>filter</b> matching in software. Constructing a separate HyperCuts decision tree for each <b>packet</b> <b>filter</b> is not memory efficient. A natural alternative is to construct shared HyperCuts decision trees to more efficiently support multiple <b>packet</b> <b>filters.</b> However, we experimentally show that naively classifying <b>packet</b> <b>filters</b> into shared HyperCuts decision trees may significantly increase the memory consumption and {{the height of the}} trees. To help decide which subset of <b>packet</b> <b>filters</b> should share a HyperCuts decision tree, we first identify a number of important factors that collectively impact the efficiency of the resulted shared HyperCuts decision tree. Based on the identified factors, we then propose to use machine learning techniques to predict whether any pair of <b>packet</b> <b>filters</b> should share a tree. Given the pair-wise prediction matrix, a greedy heuristic algorithm is used to classify <b>packets</b> <b>filters</b> into a number of shared HyperCuts decision trees. Our experiments using both real <b>packets</b> <b>filters</b> and synthetic <b>packet</b> <b>filters</b> show that the shared HyperCuts decision trees consume considerably less memory. Index Terms—Packet <b>filter,</b> <b>packet</b> classification, data structure, virtual router, HyperCuts. I...|$|R
50|$|PF (<b>Packet</b> <b>Filter,</b> {{also written}} pf) is a BSD {{licensed}} stateful <b>packet</b> <b>filter,</b> a central piece of software for firewalling. It {{is comparable to}} netfilter (iptables), ipfw and ipfilter.|$|R
25|$|Some of {{the most}} {{significant}} and most discussed security features included with Windows Vista include User Account Control, Kernel Patch Protection, BitLocker Drive Encryption, Mandatory Integrity Control, Digital Rights Management, TCP/IP stack security improvements, Address Space Layout Randomization and Encrypting File System and cryptography improvements. Additionally, Windows Vista includes a range of parental controls, which give owners of a computer a set of tools to limit what other accounts on a computer can do, and an improved Windows Firewall which supports both inbound and outbound <b>packet</b> <b>filtering,</b> IPv6 connection filtering and more detailed configurable rules and policies.|$|E
5000|$|Outbound <b>packet</b> <b>filtering,</b> {{reflecting}} increasing {{concerns about}} spyware and viruses {{that attempt to}} [...] "phone home".|$|E
50|$|CHAOS was {{the first}} openMosix {{distribution}} to provide IPSEC and IP <b>packet</b> <b>filtering</b> to the cluster node, enabling authentication and encryption for inter-node communications, and enabling <b>packet</b> <b>filtering</b> to prevent non-cluster devices from accessing the vulnerable openMosix communications ports. These security controls allowed the cluster builder to utilise desktop computers in semi-trusted networks with minimal risk to cluster integrity, thus {{increasing the number of}} resources available for inclusion within the cluster.|$|E
40|$|<b>Packet</b> <b>filters</b> are a {{mechanism}} for efficiently demultiplexing network packets to application endpoints. There is currently no general, formal specification method for <b>packet</b> <b>filters</b> that allows for easy or efficient composition of specifications. In this paper we present an automatic approach that achieves all of these goals. We approach <b>packet</b> <b>filter</b> specification as a language recognition problem: each filter is represented by a context-free grammar, whose language is the set of <b>packets</b> the <b>filter</b> should accept. Thus, <b>packet</b> <b>filters</b> can be formulated through a general, well defined specification; further, the grammar-based approach simplifies filter composition, which is essential where scalability is important. However <b>packet</b> <b>filters</b> based on standard LR parsing techniques suffer from poor performance: they touch every portion of the input, they check input bit by bit, they occupy large amount of space. We present new optimizations to LR parsing that enable our automatic approach to [...] ...|$|R
40|$|Abstract-As {{communication}} technology advances, network capacity grows exponentially in recent years. The performance of network monitoring tools {{is getting more}} critical as they must process much lager number of packets in a unit of time than ever before. A common core component in any network monitoring tools is a <b>packet</b> <b>filter</b> which processes every packet header and passes those <b>packets</b> matching some <b>filter</b> rules to user spaces for further processing. In this paper, a <b>packet</b> <b>filter</b> architecture called <b>Packet</b> <b>Filter</b> Cache (PFC) is proposed to improve the performance of existing <b>packet</b> <b>filters.</b> The PFC architecture adds a filter rule cache before an existing <b>packet</b> <b>filter.</b> Instead of caching instruction set as in Warm cache, the filter rule cache stores the hash value of a filter rule as a hash table entry that can be searched in one memory access. By {{taking advantage of the}} hash lookup speed, PFC can boost filtering performance by using only small cache size. Moreover, PFC also caches unmatched packet flows to achieve high hit rate. Since PFC is only a cache mechanism added before a traditional <b>packet</b> <b>filter,</b> it does not need to re-engineer existing filter module and hence can be applied on most <b>packet</b> <b>filters.</b> Simulation shows PFC can improve the processing time about four times at cache hit rate of 70 %...|$|R
40|$|This paper {{describes}} a methodology for configuring a <b>packet</b> <b>filter,</b> {{which is one}} of the components of a firewall system. It takes into consideration non-obvious security nuances of the TCP/IP protocol stack that may be overlooked by system administrators. The methodology uses the TCP/IP protocol suite' s layered architecture as the guide for the composition of the <b>packet</b> <b>filter</b> rule set. It uses the IP Chains <b>packet</b> <b>filter</b> to demonstrate a practical example...|$|R
50|$|Stateful packet {{inspection}} (SPI), {{also referred}} to as dynamic <b>packet</b> <b>filtering,</b> is a security feature often included in business networks.|$|E
50|$|The {{blue team}} {{must always be}} mindful of the network perimeter, {{including}} traffic flow, <b>packet</b> <b>filtering,</b> proxy firewalls, and intrusion detection systems.|$|E
50|$|For instance; <b>Packet</b> <b>filtering</b> -firewall, content-control software, Quota Management {{systems and}} Quality of service (QoS) systems are good {{examples}} of where controls can be made dependent upon authentication.|$|E
40|$|This paper {{describes}} a new <b>packet</b> <b>filter</b> mechanism that efficiently dispatches incoming network packets {{to one of}} multiple endpoints, for example address spaces. Earlier <b>packet</b> <b>filter</b> systems iteratively applied each installed filter against every incoming packet, resulting in high processing overhead whenever multiple filters existed. Our new <b>packet</b> <b>filter</b> provides an associative match function that enables similar but not identical filters to be combined together into a single filter. The filter mechanism, which we call the Mach <b>Packet</b> <b>Filter</b> (MPF), has been implemented for the Mach 3. 0 operating system and {{is being used to}} support endpoint-based protocol processing, whereby each address space implements its own suite of network protocols. With large numbers of registered endpoints, MPF outperforms the earlier BSD <b>Packet</b> <b>Filter</b> (BPF) by over a factor of four. MPF also allows a filter program to dispatch fragmented packets, which was quite difficult with previous filter mechanisms...|$|R
40|$|This report {{presents}} the study, {{design and implementation}} of a firewall, in particular {{a major component of}} a firewall: the dynamic <b>packet</b> <b>filter.</b> A <b>packet</b> <b>filter</b> may be static or dynamic. A dynamic <b>packet</b> <b>filter</b> checks on the fly the outgoing IP packets from a computer and then allows incoming packets to get through the <b>packet</b> <b>filter</b> if the <b>packets</b> are from the same computer as the outgoing packets were sent to. There is currently no dynamic <b>packet</b> <b>filters</b> on the Linux operating system which has been chosen to be the development and test environment due to the source code availability. Some performance measurements have also been obtained to show that a safe system does not necessarily have to be very slow. This might otherwise be of some concern, as there is a trade-off between the security and the performance of the system. 1. Introduction The need for network communication is large, and seems to be growing if judging the ever growing numbers of connected hosts to the Internet, th [...] ...|$|R
40|$|Building in securityFirewall {{varieties}} Protect vulnerable machines; compensatefor {{impossibility of}} securing internal networks. 1. <b>Packet</b> <b>filters.</b> Cheap, fast, stateless. Filter based on source/dest addresses, port numbers. Built into routers. Drawbacks: prevent some protocols (plain FTP, maybeUDP), dynamicport assignment (RPC). Firewall varieties Protect vulnerable machines; compensatefor impossibility of securing internal networks. 1. <b>Packet</b> <b>filters.</b> Cheap, fast, stateless. Filter based on source/dest addresses, port numbers. Built into routers. Drawbacks: prevent some protocols (plain FTP, maybeUDP), dynamicport assignment (RPC). 2. Dynamic <b>packet</b> <b>filters.</b> Statefulfilters; allow more protocols by parsing commandstreams, portmappermessages, UDP protocols,“port knocking”. Drawback: complexity. Firewall varieties Protect vulnerable machines; compensatefor impossibility of securing internal networks. 1. <b>Packet</b> <b>filters.</b> Cheap, fast, stateless. Filter based on source/dest addresses, port numbers. Built into routers. Drawbacks: prevent some protocols (plain FTP, maybeUDP), dynamicport assignment (RPC). 2. Dynamic <b>packet</b> <b>filters.</b> Statefulfilters; allow more protocols by parsing commandstreams, portmappermessages, UDP protocols,“port knocking”. Drawback: complexity. 3. Application gateways. Each app has dedicated program at firewall which {{acts as a}} relay/proxy. SMTP and HTTP work well. Drawback: gateways for each app; bottlenecks. Firewall varieties Protect vulnerable machines; compensatefor impossibility of securing internal networks. 1. <b>Packet</b> <b>filters.</b> Cheap, fast, stateless. Filter based on source/dest addresses, port numbers. Built into routers. Drawbacks: prevent some protocols (plain FTP, maybeUDP), dynamicport assignment (RPC). 2. Dynamic <b>packet</b> <b>filters.</b> Statefulfilters; allow more protocols by parsing commandstreams, portmappermessages, UDP protocols,“port knocking”. Drawback: complexity. 3. Application gateways. Each app has dedicated program at firewall which acts as a relay/proxy. SMTP and HTTP work well. Drawback: gateways for each app; bottlenecks...|$|R
5000|$|Implementations of IEEE 802.1X suites often allow <b>packet</b> <b>filtering</b> {{rules to}} be {{installed}} explicitly by an AAA server based on dynamically learned information about clients, including the MAC address.|$|E
50|$|The {{device to}} which the default route points is often called the default gateway, and it often carries out other {{functions}} such as <b>packet</b> <b>filtering,</b> firewalling, or proxy server operations.|$|E
5000|$|... {{can make}} use of {{checking}} the connection's information such as states, statuses and more to make <b>packet</b> <b>filtering</b> rules more powerful and easier to manage. The most common states are: ...|$|E
5000|$|Manage {{hardware}} <b>packet</b> <b>filters</b> in the on-board network adapter.|$|R
40|$|A <b>packet</b> <b>filter</b> is a {{programmable}} {{selection criterion}} for classifying or selecting packets from a packet stream in a generic, reusable fashion. Previous work on <b>packet</b> <b>filters</b> falls roughly into two categories, namely those efforts that investigate flexible and extensible filter abstractions but sacrifice performance, {{and those that}} focus on low-level, optimized filtering representations but sacrifice flexibility. Applications like network monitoring and intrusion detection, however, require both high-level expressiveness and raw performance. In this paper, we propose a fully general <b>packet</b> <b>filter</b> framework that affords both {{a high degree of}} flexibility and good performance. In our framework, a <b>packet</b> <b>filter</b> is expressed in a high-level language that is compiled into a highly efficient native implementation. The optimization phase of the compiler uses a flowgraph set relation called edge dominators and the novel application of an optimization technique that we call "redundant predicate [...] ...|$|R
40|$|Protect {{vulnerable}} machines; {{compensate for}} impossibility of securing internal networks. 1. <b>Packet</b> <b>filters.</b> Cheap, fast, stateless. Filter based on source/dest addresses, port numbers. Built into routers. Drawbacks: prevent some protocols (plain FTP, maybe UDP), dynamic port assignment (RPC). Firewall varieties Protect vulnerable machines; compensate for impossibility of securing internal networks. 1. <b>Packet</b> <b>filters.</b> Cheap, fast, stateless. Filter based on source/dest addresses, port numbers. Built into routers. Drawbacks: prevent some protocols (plain FTP, maybe UDP), dynamic port assignment (RPC). 2. Dynamic <b>packet</b> <b>filters.</b> Stateful filters; allow more protocols by parsing command streams, portmapper messages, UDP protocols, “port knocking”. Drawback: complexity. Firewall varietie...|$|R
5000|$|Outbound <b>packet</b> <b>filtering,</b> {{reflecting}} increasing {{concerns about}} spyware and viruses {{that attempt to}} [...] "phone home". Outbound rules are configured using the management console. Notifications are not shown however for outbound connections.|$|E
50|$|As of 2012, {{one report}} {{suggests}} that, contrary to general {{opinion about the}} lack of BCP 38 deployment, some 80% of the Internet (by various measures) were already applying anti-spoofing <b>packet</b> <b>filtering</b> in their networks.|$|E
50|$|<b>Packet</b> <b>filtering</b> {{alone is}} not {{regarded}} as providing enough protection. In order to effectively block peer-to-peer-related network traffic, {{what is needed is}} a firewall that does application filtering, which can be regarded as an extension to stateful packet inspection. Stateful packet inspection can determine what type of protocol is being sent over each port, but application-level filters look at what a protocol is being used for. For example, an application-level filter might {{be able to tell the}} difference between HTTP traffic used to access a Web page and HTTP traffic used for file sharing, whereas a firewall that is only performing <b>packet</b> <b>filtering</b> would treat all HTTP traffic equally.|$|E
40|$|<b>Packet</b> <b>filters</b> are {{security}} devices that connect multiple packet-based networks and provide access control between them. The security policy enforced by a <b>packet</b> <b>filter</b> is specified {{as a set}} of rules, called an access list, that describes what types of network packets should be allowed to pass from one network to another, and what types should be discarded. These rules are expressed in terms of the values of the fields of the packet headers. The semantics of an access list dictate that the first rule that matches a packet determines the action taken by the <b>packet</b> <b>filter.</b> Traditiona...|$|R
40|$|Abstract. <b>Packet</b> <b>filters</b> have {{traditionally}} been used to shield IP net-works from known attack flows, ususally within firewall systems connect-ing trusted and non-trusted network segments. As IP networks grow and tend to connect {{to more and more}} neighbor networks with unknown trust status, carrier-grade operators in particular are beginning to experience raising costs due to increasingly complex filter configurations that have to be applied to their networks, in order to maintain a desired security level. In this paper, we present a discussion on the general properties of distributed <b>packet</b> <b>filter</b> configurations and an algorithm for a sim-plified compilation of anticipatory static <b>packet</b> <b>filter</b> configurations in heterogenous IP networks...|$|R
50|$|Administrators {{configure}} port forwarding in the gateway's operating system. In Linux kernels, this {{is achieved}} by <b>packet</b> <b>filter</b> rules in the iptables or netfilter kernel components. BSD and Mac OS X operating systems prior to Yosemite (OS 10.10.X) implement it in the Ipfirewall (ipfw) module while and Mac OS X operating systems beginning with Yosemite implement it in the <b>Packet</b> <b>Filter</b> (pf) module.|$|R
5000|$|Beyond {{computational}} geometry, [...] and [...] apply fractional cascading in {{the design}} of data structures for fast <b>packet</b> <b>filtering</b> in internet routers. [...] use fractional cascading as a model for data distribution and retrieval in sensor networks.|$|E
50|$|In September 2013, HP {{announced}} that it entered the next-generation firewall market with {{a new line of}} TippingPoint firewalls. The new line extends TippingPoint's existing intrusion prevention system (IPS) appliances with traditional stateful <b>packet</b> <b>filtering</b> and application control.|$|E
5000|$|Network ingress {{filtering}} is a <b>packet</b> <b>filtering</b> {{technique used}} by many Internet service providers {{to try to prevent}} source address spoofing of Internet traffic, and thus indirectly combat various types of net abuse by making Internet traffic traceable to its source.|$|E
40|$|This report {{describes}} Proof-Carrying Code, {{a software}} mechanism {{that allows a}} host system to determine with certainty that {{it is safe to}} execute a program supplied by an untrusted source. For this to be possible, the untrusted code supplier must provide with the code a safety proof that attests to the code's safety properties. The code consumer can easily and quickly validate the proof without using cryptography and without consulting any external agents. In order to gain preliminary experience with proof-carrying code, we have performed a series of case studies. In one case study, we write safe assembly-language network <b>packet</b> <b>filters.</b> These filters can be executed with no run-time overhead, beyond a one-time cost of 1 to 3 milliseconds for validating the attached proofs. The net result is that our <b>packet</b> <b>filters</b> are formally guaranteed to be safe and are faster than <b>packet</b> <b>filters</b> created using Berkeley <b>Packet</b> <b>Filters,</b> Software Fault Isolation, or safe languages such as Modula- 3. In [...] ...|$|R
40|$|The use of <b>packet</b> <b>filters</b> has {{increased}} considerably {{due to the}} growth of Internet users and network services. A number of header fields must be examined by the filter, causing delay for each packet processed. The problem is compounded when considering multiple filters across a network. To maximize network performance, it would be desirable to minimize the number of <b>packet</b> <b>filters</b> for each path across a domain. Due to the interactions of rules between filters, the underlying network topology and the actions of dynamic routing protocols, it is computationally infeasible to implement this strategy by collectively considering all <b>packet</b> <b>filters</b> across the network. A simpler approach is the elimination of a filter by merging two filters on a common network segment. This work presents a novel <b>packet</b> <b>filter</b> merging algorithm using decision diagrams. A large number of practical and simulated experimental results are provided to demonstrate the effectiveness of the technique and possible enhancements are considered in the conclusion. The results show an average 20...|$|R
40|$|A <b>packet</b> <b>filter</b> is a {{programmable}} {{selection criterion}} for classify-ing or selecting packets from a packet stream in a generic, reusable fashion. Previous work on <b>packet</b> <b>filters</b> falls roughly into two cate-gories, namely those efforts that investigate flexible and extensible filter abstractions but sacrifice performance, {{and those that}} focus on low-level, optimized filtering representations but sacrifice flex-ibility. Applications like network monitoring and intrusion detec-tion, however, require both high-level expressiveness and raw per-formance. In this paper, we propose a fully general <b>packet</b> <b>filter</b> framework that affords both {{a high degree of}} flexibility and good performance. In our framework, a <b>packet</b> <b>filter</b> is expressed in a high-level language that is compiled into a highly efficient native implementation. The optimization phase of the compiler uses a flowgraph set relation called edge dominators and the novel appli-cation of an optimization technique that we call “redundant predi-cate elimination, ” in which we interleave partial redundancy elim-ination, predicate assertion propagation, and flowgraph edge elim-ination to carry out the filter predicate optimization. Our resulting packet-filtering framework, which we call BPF+, derives from the BSD <b>packet</b> <b>filter</b> (BPF), and includes a filter program translator, a byte code optimizer, a byte code safety verifier to allow code to mi-grate across protection boundaries, and a just-in-time assembler to convert byte codes to efficient native code. Despite the high degree of flexibility afforded by our generalized framework, our perfor-mance measurements show that our system achieves performance comparable to state-of-the-art <b>packet</b> <b>filter</b> architectures and better than hand-coded filters written in C. ...|$|R
