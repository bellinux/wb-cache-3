122|198|Public
25|$|Significant {{complications}} to all {{theories are}} {{posed by the}} Old Novgorod dialect, known particularly since the 1950s, which has no application of the second regressive palatalization and only <b>partial</b> <b>application</b> of the progressive palatalization (to *k and sometimes *g, but not to *x).|$|E
25|$|The {{advantage}} to this design {{is that the}} brake is not being applied to slow the vehicle, it is simply clutching {{the second set of}} gears in or out. This means it does not dissipate energy, except in the brief period it is being applied or released. Smoother steering can be accomplished by <b>partial</b> <b>application</b> of the brake, but then it begins to dissipate energy like the braked differential. The main disadvantage is {{that there is only one}} turning radius. Like the standard differential solution, these systems are also subject to self-turning when travelling over terrain.|$|E
2500|$|There are {{a number}} of {{overseas}} member state territories which are legally part of the EU, but have certain exemptions based on their remoteness. These [...] "outermost regions" [...] have <b>partial</b> <b>application</b> of EU law and in some cases are outside of Schengen or the EU VAT area—however they are legally within the EU. They all use the euro as their currency.|$|E
40|$|This paper {{describes}} {{a proposal to}} incorporate finite domain constraints in a functional logic system. The proposal integrates functions, higher-order patterns, <b>partial</b> <b>applications,</b> non-determinism, logical variables, currying, types, lazyness, domain variables, constraints and finite domain propagators...|$|R
5000|$|... #Subtitle level 2: Contrast with <b>partial</b> {{function}} <b>application</b> ...|$|R
5000|$|In contrast, <b>partial</b> {{function}} <b>application</b> {{refers to}} the process of fixing a number of arguments to a function, producing another function of smaller arity. Given the definition of [...] above, we might fix (or 'bind') the first argument, producing a function of type [...] Evaluation of this function might be represented as [...] Note that the result of <b>partial</b> function <b>application</b> in this case is a function that takes two arguments.|$|R
2500|$|The Australian {{government}} provides {{services through}} the Christmas Island Administration and the Department of Infrastructure and Regional Development. Under the federal government's Territories Law Reform Act 1992, which came into force on 1 July 1992, Western Australian laws {{are applied to}} Christmas Island [...] "so far as {{they are capable of}} applying in the territory"; non-application or <b>partial</b> <b>application</b> of such laws is at the discretion of the federal government. The act also gives Western Australian courts judicial power over Christmas Island. Christmas Island remains constitutionally distinct from Western Australia, however; {{the power of the state}} to legislate for the territory is delegated by the federal government. The kind of services typically provided by a state government elsewhere in Australia are provided by departments of the Western Australian government, and by contractors, with the costs met by the federal government. Aunicameral Shire of Christmas Island with nine seats provides local government services and is elected by popular vote to serve four-year terms. Elections are held every two years, with four or five of the members standing for election.|$|E
50|$|Currying {{is related}} to, {{but not the}} same as <b>partial</b> <b>application.</b> In practice, the {{programming}} technique of closures can be used to perform <b>partial</b> <b>application</b> and a kind of currying, by hiding arguments in an environment that travels with the curried function.|$|E
5000|$|Explicit <b>partial</b> <b>application</b> with [...] since version 2.5, and [...] since version 2.6.|$|E
50|$|This {{example is}} {{somewhat}} flawed, in that currying, while similar to <b>partial</b> function <b>application,</b> {{is not the}} same (see below).|$|R
40|$|In {{this paper}} {{we will show}} how to embed {{functional}} concepts in an imperative host language in a natural way. This is achieved by interpreting functional programs as specifications of imperative programs. We will introduce a refined notion of laziness, which allows us to interpret lazy computations as special constructors, which encapsulate the suspended computation. Even higher-order concepts can be represented efficiently, if we restrict the possibility to use <b>partial</b> <b>applications.</b> Essentially, we disallow the use of sequences of <b>partial</b> <b>applications</b> as hidden data structures. By considering a setting in which the unit of translation is a module, this approach {{is the key to}} an integration of the functional programming paradigm and the imperative programming paradigm on a module level. Functional components of the resulting hybrid module architectures may use and may be used by imperative components without need for special interlanguage interfaces. Beside the `best of both worlds', this concept ooeers the possibility to migrate `module by module' from purely imperative systems to hybrid systems and to do rapid prototyping using functional modules. Experimental results with a prototype version of a translator will show that we can compete with traditional functional languages like Haskell...|$|R
40|$|International audienceFunction uncurrying is an {{important}} optimization for the efficient execution of functional programming languages. This optimization replaces curried functions by uncur-ried, multiple-argument functions, while preserving the ability to evaluate <b>partial</b> <b>applications.</b> First-order uncurrying (where curried functions are optimized only in the static scopes of their definitions) is well understood and implemented by many compilers, but its extension to higher-order functions (where uncurrying can also be performed on parameters and results of higher-order functions) is challenging. This article develops a generic framework that expresses higher-order uncurrying optimizations as type-directed insertion of coercions, and prove its correctness. The proof uses step-indexed logical relations and was entirely mechanized using the Coq proof assistant...|$|R
5000|$|Clojure {{implements}} <b>partial</b> <b>application</b> {{using the}} [...] function defined in its core library.|$|E
5000|$|The {{practical}} {{motivation for}} <b>partial</b> <b>application</b> is that very often the functions obtained by supplying some {{but not all}} of the arguments to a function are useful; for example, many languages have a function or operator similar to [...] <b>Partial</b> <b>application</b> makes it easy to define these functions, for example by creating a function that represents the addition operator with 1 bound as its first argument.|$|E
5000|$|In the simply-typed lambda {{calculus}} with function and product types (λ→,&times;) <b>partial</b> <b>application,</b> currying and uncurrying {{can be defined}} as: ...|$|E
3000|$|... energy {{production}} monitoring. In this test, each PV module {{was connected to}} the AC grid through a micro-inverter and the actual working condition (in term of AC and DC voltage), current and power were measured. The period of <b>partial</b> shading <b>application</b> was taken into account.|$|R
40|$|This article {{describes}} the added support in FXSL 2. 0 for writing higher-order functions in XSLT 2. 0 based on new fundamental XPath 2. 0 /XSLT 2. 0 features such as the sequence datatype, strong typing and writing functions natively in XSLT. FXSL 2. 0 makes nearly all standard XPath 2. 0 /XSLT 2. 0 functions and operators higher-order by providing in the FXSL namespace the definition of their identically named higher-order wrappers and <b>partial</b> <b>applications.</b> The author argues that in effect, this makes XSLT 2. 0 + FXSL a higher-order strongly-typed functional programming system. This paper demonstrates how based on the even higher degree of abstraction and code reuse many challenging problems have now more compact or even one-line solutions...|$|R
5000|$|This is a <b>partial</b> list of <b>applications</b> that {{generate}} [...]bak files (in some cases as an optional configuration setting): ...|$|R
5000|$|An {{interesting}} {{operation on}} functions was <b>partial</b> <b>application,</b> (sometimes {{referred to as}} [...] "currying"). In <b>partial</b> <b>application</b> some number of the rightmost arguments of the function (which {{would be the last}} ones placed on the stack before the function is involved) were frozen to given values, to produce a new function of fewer arguments, which is a closure of the original function. For instance, consider a function for computing general second-degree polynomials: ...|$|E
5000|$|Scala {{implements}} optional <b>partial</b> <b>application</b> with placeholder, e.g. [...] returns an incrementing function. Scala {{also support}} multiple parameter lists as currying, e.g.|$|E
5000|$|In {{computer}} science, <b>partial</b> <b>application</b> (or {{partial function}} application) {{refers to the}} process of fixing a number of arguments to a function, producing another function of smaller arity. Given a function , we might fix (or 'bind') the first argument, producing a function of type [...] Evaluation of this function might be represented as [...] Note that the result of partial function application in this case is a function that takes two arguments. <b>Partial</b> <b>application</b> is sometimes (incorrectly) called currying, which is a related, but distinct concept.|$|E
5000|$|Edward Kofler - Linear <b>Partial</b> Information with <b>Applications.</b> Proceedings of ISFL 1997 (International Symposium on Fuzzy Logic), Zurich, 1997, p. 235-239.|$|R
40|$|We {{propose a}} new {{spreadsheet}} paradigm which incorporates many functional programming {{features such as}} higher-order functions, a strong type system, curried <b>partial</b> <b>applications,</b> referential transparency and lazy evaluation. It also incorporates many object-oriented programming features such as a class hierarchy, inheritance, overloading, overriding, subsumption, and dynamic despatch on a distinguished object. 1 Introduction Despite many advances in programming languages since the late 1970 s, the spreadsheet paradigm has changed little in this time. Although some advances have been made (for example, working with multiple worksheets, defining name bindings, making spreadsheets available as components, and linking cells to other components), the central computational model remains unaltered. We believe that many benefits {{can be derived from}} radically updating the spreadsheet computational model, whilst retaining the essence of the spreadsheet user interface. By incorporating fu [...] ...|$|R
40|$|Abstract. We {{present an}} {{automated}} approach to verifying termination of higher-order functional programs. Our approach adopts the idea {{from the recent}} work on termination verification via transition invariants (a. k. a. binary reachability anal-ysis), and is fully automated. Our approach is able to soundly handle the subtle aspects of higher-order programs, including <b>partial</b> <b>applications,</b> indirect calls, and ranking functions over function closure values. In contrast to the previous approaches to automated termination verification for functional programs, our approach is sound and complete, relative to the soundness and completeness of the underlying reachability analysis and ranking function inference. We have im-plemented a prototype of our approach for {{a subset of the}} OCaml language, and we have confirmed that it is able to automatically verify termination of some non-trivial higher-order programs. ...|$|R
50|$|The C++ {{standard}} library provides bind(function, args..) {{to return}} a function object that {{is the result of}} <b>partial</b> <b>application</b> of the given arguments to the given function.|$|E
50|$|In {{languages}} such as ML and Haskell {{functions are}} defined in curried form by default. Supplying {{fewer than the}} total number of arguments is referred to as <b>partial</b> <b>application.</b>|$|E
5000|$|<b>Partial</b> <b>application</b> {{can be seen}} as {{evaluating}} a curried {{function at}} a fixed point, e.g. given [...] and [...] then [...] or simply [...] where [...] curries f's first parameter.|$|E
40|$|Abstract. The {{spreadsheet}} {{is one of}} {{the most}} successful computer ap-plications. This popularity derives from an intuitive user interface which both closely mimics traditional bookkeeping and allows non-programmers to develop simple numerical applications. Unfortunately, the current user interface is frustrating and limiting: we believe that the computational model can be simplied to improve usability for non-programmers, ex-tended to provide additional functionality, redesigned to facilitate reuse (to improve performance and integrity), and embedded in an environ-ment which supports a spreadsheet inheritance hierarchy. We propose a new spreadsheet paradigm which incorporates many functional pro-gramming features such as higher-order functions, a strong type system, curried <b>partial</b> <b>applications,</b> referential transparency and lazy evaluation. It also incorporates many object-oriented programming features such as a class hierarchy, inheritance, overloading, overriding, subsumption, and dynamic despatch on a distinguished object. ...|$|R
5000|$|Currying and <b>partial</b> {{function}} <b>application</b> {{are often}} conflated. [...] One {{of the significant}} differences between the two is that a call to a partially applied function returns the result right away, not another function down the currying chain; this distinction can be illustrated clearly for functions whose arity is greater than two.|$|R
40|$|Abstract. Bernie Pope {{introduced}} {{the idea of}} representing functional values as finite maps instead of <b>partial</b> <b>applications</b> into algorithmic debugging of higher-order functional languages. He implemented it in his Haskell debugger Buddha. Here we give an implementation-independent formal definition of algorithmic debugging for both representation in a single framework, even though the computation trees for the two representations have rather different structures. On this basis we prove the soundness of algorithmic debugging with finite maps. Our model shows how a single implementation can support both forms of algorithmic debugging. The proof exposed that algorithmic debugging with finite maps does not handle arbitrary functional programs, but in current practice the problematic ones are excluded by Haskell’s type system. Both model and proof suggests variations of algorithmic debugging with finite maps and thus are tools for further improvement of this form of debugging. ...|$|R
5000|$|The terms [...] and [...] are {{sometimes}} called {{the positive and negative}} Shannon cofactors, respectively, of [...] with respect to [...] These are functions, computed by restrict operator, [...] and [...] (see valuation (logic) and <b>partial</b> <b>application).</b>|$|E
50|$|Curried {{functions}} {{may be used}} in any {{programming language}} that supports closures; however, uncurried functions are generally preferred for efficiency reasons, since the overhead of <b>partial</b> <b>application</b> and closure creation can then be avoided for most function calls.|$|E
5000|$|In {{languages}} with first-class functions one {{can define}} , [...] and [...] to perform currying and <b>partial</b> <b>application</b> explicitly. This might incur a greater run-time overhead {{due to the}} creation of additional closures, while Haskell can use more efficient techniques.|$|E
40|$|Carrying {{capacity}} is often pragmatically, theoretically {{as well as}} purely intuitively considered as a concept {{in the context of}} tourism sustainability. The carrying capacity application has the greatest potential in protected areas, in frequently visited cultural and natural attractions, and in relation to sustaining of the lifestyle of the local community and tourism destination potential in general. Despite its importance, <b>partial</b> <b>applications,</b> determination of basic theoretical principles, and specifying connection to the other theoretical concepts in tourism (particularly destination life cycle, LAC concept, visitors management), there still is a rightful opinion of some authors suggesting that there is no consistent theory of tourism carrying capacity. This theory would be the base for sophisticated practical carrying capacity applications. This paper is therefore focused on introduction of the theoretical concept of carrying capacity, which can be discussed and possibly further elaborated...|$|R
40|$|Recent {{trends in}} {{programming}} language implementation are moving {{more and more}} towards “managed” runtime environments. These offer many ben- efits, including static and dynamic type checking, security, profiling, bounds checking and garbage collection. The Common Language Infrastructure (CLI) is Microsoft’s attempt to define a managed runtime environment. However, since it was designed with more mainstream languages in mind, including C] and C++, CLI proves restrictive when compiling functional languages. More specifically, for compilers such as GHC, which compiles Haskell, the CLI provides little support for lazy evaluation, currying (<b>partial</b> <b>applications)</b> and static type checking. The CLI does not provide any way of representing a computation in an evaluated and non-evaluated form. It does not allow functions to directly manipulate the runtime stack, and it restricts static typing in various forms; including subsumption over function types. In this thesis, we describe a new compilation method that removes the need for runtime argument checks. Runtime argument checking is required to ensure proper reduction semantics in situations where the arity of a function may be statically unknown. We introduce {{a new set of}} annotations, called operational types, which provide an abstract model of reduction. From these operational annotations we can construct a transformation, called lambda doping, which saturates all <b>partial</b> <b>applications,</b> removing the need for run- time argument checks. This enables the CLI to support an eager, curried, higher order functional language. We also describe a type inference algorithm that infers universally quan- tified types with implicit widening coercions. We show that we can easily include the generation of operational typings from type inference. We restrict type inference to simple extensions of the usual unification algorithm, given by Hindley-Milner, so that inference is immediately applicable to most com- mercial functional languages. We also develop a set of transformations which demonstrate {{that for the most part}} inferred types can be readily mapped to the CLI. Finally, we develop a practical implementation of a higher-order, curried eager functional language, called Mondrian...|$|R
40|$|The {{chemical}} {{universe of}} molecules reachable from {{a set of}} start compounds by iterative application of {{a finite number of}} reactions is usually so vast, that sophisticated and efficient exploration strategies are required to cope with the combinatorial complexity. A stringent analysis of (bio) chemical reaction networks, as approximations of these complex chemical spaces, forms the foundation for the understanding of functional relations in Chemistry and Biology. Graphs and graph rewriting are natural models for molecules and reactions. Borrowing the idea of partial evaluation from functional programming, we introduce <b>partial</b> <b>applications</b> of rewrite rules. A framework for the specification of exploration strategies in graph-rewriting systems is presented. Using key examples of complex reaction networks from carbohydrate chemistry we demonstrate the feasibility of this high-level strategy framework. While being designed for chemical applications, the framework {{can also be used to}} emulate higher-level transformation models such as illustrated in a small puzzle game...|$|R
