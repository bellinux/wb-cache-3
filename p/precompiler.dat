79|5|Public
5000|$|Gaalop <b>Precompiler</b> http://www.gaalop.de/ <b>Precompiler</b> {{based on}} Gaalop {{integrated}} with CMake.|$|E
5000|$|Cobol-IT is now distributing a COBOL <b>precompiler</b> for PostgreSQL ...|$|E
5000|$|... {{embedding}} RDO {{statements in}} the source file then running it through a <b>precompiler</b> ...|$|E
5000|$|Several <b>precompilers</b> or code {{generators}} exist, {{to produce}} source code in Plex-C from higher level languages or graphical models. These can generate Plex-C from: ...|$|R
5000|$|Pro*PL/I was not {{released}} with Oracle8. The Pro*PL/I Supplement to the Oracle <b>Precompilers</b> Guide, however, {{continued to make}} appearances in the Oracle Documentation Library until release 11g. As of release 12c, the Pro*PL/I {{has been removed from}} the Oracle Documentation Library.|$|R
5000|$|Less (sometimes stylized as LESS) is {{a dynamic}} style sheet {{language}} that can be compiled into Cascading Style Sheets (CSS) and run on the client side or server side.Designed by Alexis Sellier, Less is influenced by Sass and has influenced the newer [...] "SCSS" [...] syntax of Sass, which adapted its CSS-like block formatting syntax. Less is open source. Its first version was written in Ruby; however, in the later versions, use of Ruby has been deprecated and replaced by JavaScript. The indented syntax of Less is a nested metalanguage, as valid CSS is valid Less code with the same semantics. Less provides the following mechanisms: variables, nesting, mixins, operators and functions; {{the main difference between}} Less and other CSS <b>precompilers</b> being that Less allows real-time compilation via less.js by the browser.|$|R
5000|$|APRE is an {{embedded}} SQL <b>precompiler</b> {{provided by}} Altibase Corp. for its DBMS server.|$|E
50|$|The SQL <b>precompiler</b> allows current RPG {{developers}} {{to take advantage}} of IBM's cost-based SQE (SQL Query Engine). With the traditional F-Spec approach a developer had to identify a specific access path to a data set, now they can implement standard embedded SQL statements directly in the program. When compiled, the SQL <b>precompiler</b> transforms the invalid embedded SQL statements into valid RPG statements that call the database manager programs that ultimately implement the query request.|$|E
50|$|Pro*C (also {{known as}} Pro*C/C++) is an {{embedded}} SQL programming language used by Oracle Database database management systems. Pro*C uses either C or C++ as its host language. During compilation, the embedded SQL statements are interpreted by a <b>precompiler</b> {{and replaced by}} C or C++ function calls to their respective SQL library. The output from the Pro*C <b>precompiler</b> is standard C or C++ code that is then compiled by any one of several C or C++ compilers into an executable.|$|E
40|$|This {{document}} {{describes an}} approach to support network applications, that is client-server applications with a dynamic number of short-lived clients, within the original Ada 95 distributed systems model. The conformance of this concept with the Ada Standard is verified. An implementation based on GLADE, the implementation for the GNAT compiler of Annex E of the Ada Reference Manual, is presented, highlighting the necessary modifications to the configuration language and the run-time system. Keywords: Ada 95, Distributed Systems, Client-Server Architectures, GNAT, GLADE, Replication 1 Introduction As distributed systems are {{getting more and more}} widespread, many programming languages provide libraries or <b>precompilers</b> to facilitate the creation of distributed applications. Ada 95 goes even a step further by incorporating a model for programming distributed systems into the language itself. A normal Ada program can easily be cut into pieces, distributed and executed on multiple machine [...] ...|$|R
40|$|Abstract. In {{this report}} a {{simulation}} tool that assists the user when constructing continuous simulation models will be described. The simulation tool {{can be used}} for constructing simulation pro grammes that are executed with the runtime executive DYSIM 86 which applies a modular approach. This approach makes it pos sible to split a model into several modules. The simulation tool introduces one more level of modularity. In this level a module is constructed from submodules that are taken from a library. A submodule consists of a submodel for a component in the complete model. The simulation tool consists of two <b>precompilers</b> that work on the two different levels of modularity. The library is complete ly open to the user so it is possible to extend it. This is done by a routine which is also part of the simulation tool. The simulation tool is demonstrated by simulating a part of...|$|R
50|$|Ahead-of-time {{compilation}} (AOT) {{refers to}} the more classic method of using an <b>precompiler</b> to generate a set of native instructions which do not change during the runtime of the program. Because aggressive compiling and optimizing can take time, a precompiled program may launch faster than one which relies on JIT alone for execution. JVM implementations have mitigated this startup cost by initial interpreting to speed launch times, until native code fragments can be generated by JIT.|$|E
50|$|Blocks can be nested - i.e. {{because a}} block is an {{executable}} statement, it can appear in another block wherever an executable statement is allowed. A block can {{be submitted to}} an interactive tool (such as SQL*Plus) or embedded within an Oracle <b>Precompiler</b> or OCI program. The interactive tool or program runs the block once. The block is not stored in the database, and for that reason, it is called an anonymous block (even {{if it has a}} label).|$|E
50|$|Version 6 saw the {{introduction}} of separately compilable procedures with parameters. In 1976, Stephen J. Garland added structured programming features to create Dartmouth SBASIC, a <b>precompiler</b> which produced version 6 output (and which {{formed the basis of}} ANSI BASIC). In 1979 Kemeny and Kurtz released an ANSI BASIC compiler as the seventh and final version of BASIC at Dartmouth before leaving the college to concentrate on the further development of ANSI BASIC in the form of True BASIC.|$|E
50|$|Seed7 {{is based}} on MASTER, an {{extensible}} programming language described in the diploma and doctoral theses of Thomas Mertes. Most of the original ideas of MASTER, such as user defined statements and operators, {{can be found in}} Seed7. A <b>precompiler,</b> to translate MASTER to Pascal, was proposed, but unimplemented, in the original project. In 1989, development began on an interpreter for MASTER, named HAL. In 2005, the MASTER and HAL projects were released as open source under the Seed7 project name. Since then new versions have been released every two or three weeks. As of version 2013-09-08 the Seed7 project contains more than 300,000 source lines of code and several hundred pages of documentation.|$|E
5000|$|GLBasic {{started as}} an {{interpreted}} language with 2D commands (GL stands for Graphics Language). It now uses the GCC compiler for many different platforms to achieve fast, native code results. The GLBasic <b>precompiler</b> [...] "GPC" [...] converts the simple BASIC language into C++ code and compiles it later. Thus, the user can extend GLBasic using the INLINE command to mix C/C++ code directly with GLBasic source code. Due to this, GLBasic can easily access third-party dynamic libraries on all platforms.The GLBasic SDK {{comes with an}} IDE, debugger and a graphics engine built on OpenGL (or OpenGL ES) for the platforms Windows, Linux, Mac OS X, iOS and WebOS. For handheld devices (Windows Mobile, GP2X and GP2X Wiz), GLBasic uses its own close-to-hardware routines for fast graphics.|$|E
5000|$|... vJass {{is a set}} of user-made {{extensions}} to JASS. It introduces {{object-oriented programming}} features to the language, such as structs, encapsulation, and polymorphism. Strictly speaking, vJass does not add anything to the JASS library but instead mostly uses JASS arrays and integers used as their indices. The extension relies on a custom-made compiler that compiles vJass code to strict JASS code. In this manner, no additional mods for either the World Editor program or Warcraft III are required, and maps made using vJass code are fully compatible with any copy of the game, even those without the compiler. The most convenient tool for this purpose is the Jass NewGen Pack (JNGP), which includes several enhancements for the Warcraft III world editor including a vJass <b>precompiler.</b>|$|E
40|$|Extension and {{improvements}} made to SFTRAN, a structured-programming language are discussed. This improved language is implemented as a <b>precompiler</b> that translates from SFTRAN to FORTRAN. The SFTRAN language {{and its use}} are described. Time-Sharing System (TSS) command procedures were implemented that eliminate the complications of dealing with extra files and processing steps which {{the use of a}} <b>precompiler</b> would otherwise require. These command procedures are described and their use is illustrated by examples...|$|E
40|$|Research on a <b>precompiler</b> {{solution}} is described for the moving target compiler problem encountered {{when trying to}} run parallel simulation algorithms on several microcomputers. The <b>precompiler</b> is under development at NASA-Lewis for simulating jet engines. Since the behavior of any component of a jet engine, e. g., the fan inlet, rear duct, forward sensor, etc., depends on the previous behaviors and not the current behaviors of other components, the behaviors can be modeled on different processors provided the outputs of the processors reach other processors in appropriate time intervals. The simulator works in compute and transfer modes. The Ada procedure sets for the behaviors of different components are divided up and routed by the <b>precompiler,</b> which essentially receives a multitasking program. The subroutines are synchronized after each computation cycle...|$|E
40|$|Extensions and {{improvements}} {{were made to}} SFTRAN, a structured programming language. This language was implemented as a <b>precompiler</b> that translates from SFTRAN to FORTRAN. It was available to batch and conversational users of the UNIVAC 1100 computer system. The SFTRAN language and its use are described. In addition, conversational time-sharing system command subroutines were implemented that eliminated the complications of dealing with extra files and processing steps {{that the use of}} a <b>precompiler</b> would otherwise require. These command subroutines are reported, and their use is illustrated by examplesIssued Apr. 1978. Includes bibliographical references (p. 41). Extensions {{and improvements}} were made to SFTRAN, a structured programming language. This language was implemented as a <b>precompiler</b> that translates from SFTRAN to FORTRAN. It was available to batch and conversational users of the UNIVAC 1100 computer system. The SFTRAN language and its use are described. In addition, conversational time-sharing system command subroutines were implemented that eliminated the complications of dealing with extra files and processing steps that the use of a <b>precompiler</b> would otherwise require. These command subroutines are reported, and their use is illustrated by examplesMode of access: Internet...|$|E
40|$|Highly modular, {{object-oriented}} software systems require support from programming languages to produce reusable code. Pascal lacks such features that easily propagate type definitions and routines from one module to another, such as MODU LA- 2 or ADA. This paper describes a Pascal extension which includes directives to mark data defini-tions and operations as externally visible. A <b>precompiler</b> which handles import directives translates the source into the compiler-specific Pascal syntax. This <b>precompiler</b> {{has been successfully}} used for five years in education and research. ...|$|E
40|$|This paper {{presents}} linguistic primitives for publish/subscribe programming using {{events and}} objects. We integrate our primitives into a strongly typed objectoriented language through four mechanisms: (1) serialization, (2) multiple subtyping, (3) closures, and (4) deferred code evaluation. We illustrate our primitives through Java, showing {{how we have}} overcome its respective lacks. A <b>precompiler</b> transforms statements based on our publish/subscribe primitives into calls to specifically generated typed adapters, which resemble the typed stubs and skeletons generated by the rmic <b>precompiler</b> for remote method invocations in Java. ...|$|E
40|$|Our {{research}} {{is concerned with}} compiler-independent, efficient and convenient garbage collection for C++. Most collectors proposed for C++ have either been implemented in a library or in a compiler. As an intermediate step between those two, this paper proposes using precompilation techniques to augment a C++ source program with code to allow mostly type-accurate garbage collection. There are two key <b>precompiler</b> transformations. The first is automatic generation of smart pointer classes. The <b>precompiler</b> defines the smart pointer classes and the user utilizes them instead of raw pointers. These smart pointers supply functionality that allows the collector to locate the root set for collection. The second transformation augments the C++ program with code that allows the garbage collector to locate internal pointers within objects. This paper describes the <b>precompiler</b> and the garbage collector. The paper includes a brief (1500 word) survey of related techniques. 1 Introduction The lack [...] ...|$|E
40|$|Efficient {{algorithms}} for automatic differentiation {{with several}} variables and high orders are presented. The algorithms are geared towards sparse vectors, which {{is particularly important}} {{in this case and}} allows significant savings in computer time. Besides the mere computation of derivatives, algorithms for the efficient composition and inversion of functions with sparse derivatives are discussed. The algorithms are implemented in a FORTRAN library. The library can be utilized by a <b>precompiler</b> that transforms FORTRAN into code to perform the desired automatic differentiation task. The <b>precompiler</b> allows passing of variables into subroutines and functions and allows the user to provide functions. Besides the use with the <b>precompiler,</b> the routines can be accessed from a dedicated language environment. The language has the flavor of PASCAL, but provides object oriented features and nonlinear optimization at the language level. The tools have been used in numerous cases for the computati [...] ...|$|E
40|$|The BCS Interactive Graphics System (BIG System) {{approach}} to graphics was presented, {{along with several}} significant engineering applications. The BIG System <b>precompiler,</b> the graphics support library, and the function requirements of graphics applications are discussed. It was concluded that graphics standardization and a device independent code can be developed to assure maximum graphic terminal transferability...|$|E
40|$|Abstract The {{focus of}} the this work is a {{simplified}} integration of algorithms expressed in Geometric Algebra (GA) in modern high level computer languages, namely C++, OpenCL and CUDA. A high runtime performance in terms of GA is achieved using symbolic simplification and code generation by a <b>Precompiler</b> that is directly integrated into CMake-based build toolchains. ...|$|E
40|$|This paper {{presents}} linguistic primitives for publish /subscribe programming using {{events and}} objects. We integrate our primitives into a strongly typed objectoriented language through four mechanisms: (1) serialization, (2) multiple subtyping, (3) closures, and (4) deferred code evaluation. We illustrate our primitives through Java, showing {{how we have}} overcome its respective lacks. A <b>precompiler</b> transforms statements based on our publish/subscribe primitives into calls to specifically generated typed adapters, which resemble the typed stubs and skeletons generated by the rmic <b>precompiler</b> for remote method invocations in Java. Categories and Subject Descriptors C. 2 [Computer Systems Organization]: Computer Communication; C. 2. 4 [Computer Communication Networks]: Distributed Systems [...] -distributed applications; D. 3 [Software]: Programming Languages; D. 3. 3 [Programming Languages]: Language Constructs and Features [...] -concurrent programming structures General Terms Distributed Programming Keywords Java, type, publish/subscribe, event, linguistic support # This work is partially supported by Agilent Laboratories and Lombard Odier & Co. + Christian is currently visiting the Swiss Federal Institute of Technology in Lausanne. 1...|$|E
40|$|Communication in {{and with}} sensor {{networks}} often lacks of exchangeability. Furthermore handling communication data formats during sensor node programming is often complex and programming errors {{can result in}} unstable programs. In this poster we introduce the easy to use programming framework XOBESensorNetwork, which provides the direct use of XML in a sensor node programming language, while ensuring stable and space-, time- and energy-efficient programs handling XML data. 1. XOBE for Sensor Networks Using XML in sensor networks encourages the interchangeability {{of different types of}} sensors and systems, e. g. making it easy to interconnect a sensor network to the WWW. In this poster we introduce XOBESensorNetwork 1 a programming environment, which helps developers using XML within sensor network programming and encourages simple query possibilities using XML query languages. XOBESensorNetwork is integrated into an existing sensor node programming language as a <b>precompiler</b> as shown in figure 1. With XOBESensorNetwork we ensure transparency by integrating the possibility of directly using XML within the programming language. The XOBESensorNetwork prototype is beeing developed for the BTnode sensor node platform. Therefore it integrates XML into C, which is a wide spread programming language for sensor nodes. By using the XOBESensorNetwork <b>precompiler</b> the developer does not have to handle XML within the C Code manually. Using the keyword xml at variable declaration defines using an xml variable, where plain XML can be assigned to. The XOBESensorNetwork <b>precompiler</b> automatically transforms the assignment into correct C code using efficiency optimized transformation rules. In general XML documents generated at runtime must be validated dynamically. This is a problem because i...|$|E
40|$|Abstract The {{focus of}} this work is a {{simplified}} integration of algorithms expressed in Geometric Algebra (GA) into modern high level computer languages, namely C++, OpenCL and CUDA. A high runtime performance in terms of GA is achieved using symbolic simplification and code generation by a <b>precompiler</b> that is directly integrated into CMake-based build toolchains. Finally, we demonstrate how to in-terface our technology with Mathematicaâ€™s OpenCLLink. ...|$|E
40|$|This paper {{describes}} Gemini, {{a framework}} for easy writing of certain classes of distributed computations. Its users can structure the computation using the notion of distributed cooperatives, consisting of farms and worker processes. The farms are interconnected by channels, which serve as distributed data reservoirs and allow simple load balancing. The framework consists of a C-language library, associated infrastructure (servers) and supporting tools (<b>precompiler,</b> monitor etc.) ...|$|E
40|$|A FORTRAN <b>precompiler,</b> AUGMENT, is used {{to develop}} {{packages}} for nonstandard arithmetics. It renders the source code more lucid, reduces the number of lines of code in a nonstandard arithmetic package, facilitates modification, and decreases the problems of transporting such a package to another host system. AUGMENT is briefly described and its use {{in the construction of}} the interval package is discussed. Other applications of AUGMENT are also included...|$|E
40|$|We {{present a}} model of the data {{structure}} domain that is expressed in terms of the GenVoca domain modeling concepts [Bat 91]. We show how familiar data structures can be encapsulated as realms of plug-compatible, symmetric, and reusable components, and we show how complex data structures can be formed from their composition. The target application of our research is a <b>precompiler</b> for specifying and generating customized data structures...|$|E
40|$|Object-oriented {{programming}} languages lack high-level {{support for}} platform-independent service interactions. In Java, for instance, {{the burden of}} guaranteeing sustainable interoperability is put entirely on the programmer. Java Remote Method Invocation requires its invocation targets to be remote Java objects, so Web Services and other targets can never be invoked without verbose interactions with specialized library classes. This lack of transparency forces programmers to consider heterogeneity problems over and over again, even though interoperability is ideally a middleware responsibility. Moreover, by mixing business logic with non-functional concerns, the source code is obfuscated, which decreases code comprehensibility and maintainability. In this paper, we show that interoperability in Java applications can be achieved without compromising transparency. We describe a Java extension and focus on how this language enables a <b>precompiler</b> to transparently inject the boilerplate code that realizes interoperable service interactions. Deferring interoperability provisioning to such a <b>precompiler</b> allows programmers {{to focus on the}} implementation of the business logic without being distracted by heterogeneity issues occurring in the service architecture in which their application will eventually be deployed. status: publishe...|$|E
40|$|Executing long-running {{parallel}} {{applications in}} Opportunistic Grid environments composed of heterogeneous, shared user workstations, is a daunting task. Machines may fail, become unaccessible, or may switch from idle to busy unexpectedly, compromising {{the execution of}} applications. A mechanism for fault-tolerance that supports these heterogeneous architectures is an important requirement for such a system. In this paper, we describe the support for fault-tolerant execution of BSP parallel applications on heterogeneous, shared workstations. A <b>precompiler</b> instruments application source code to save state periodically into checkpoint files. In case of failure, {{it is possible to}} recover the stored state from these files. Generated checkpoints are portable and can be recovered in a machine of different architecture, with data representation conversions being performed at recovery time. The <b>precompiler</b> also modifies BSP parallel applications to allow execution on a Grid composed of machines with different architectures. We implemented a monitoring and recovering infrastructure in the InteGrade Grid middleware. Experimental results evaluate the overhead incurred and the viability of using this approach in a Grid environment. 1...|$|E
40|$|Hunmorph: {{open source}} word {{analysis}} Common tasks involving orthographic words include spellchecking, stemming, morphological analysis, and morphological synthesis. To enable significant reuse of the language-specific resources across all such tasks, we have extended the functionality {{of the open}} source spellchecker MySpell, yielding a generic word analysis library, the runtime layer of the hunmorph toolkit. We added an offline resource management component, hunlex, which complements the efficiency of our runtime layer with a high-level description language and a configurable <b>precompiler.</b> ...|$|E
40|$|Research into runtime {{checking}} {{of programs}} mainly {{concentrates on the}} Design by Contract concept, as proposed by Meyer for the programming language Eiffel. The goal is here to check whether a program fulfills certain conditions in certain states, i. e method entry and exit points. Jass (Java with assertions) [1] tries to extend this to behavioural properties by adding trace assertion for dynamical checking (Jass 2). But the Jass approach is a <b>precompiler</b> attempt, so we cannot handle programs without its source code...|$|E
