2|1127|Public
40|$|Imitative {{learning}} and learning by observation are social mechanisms that allow a robot to acquire knowledge {{from a human}} or another robot. However {{to be able to}} obtain skills in this way the robot faces many complex issues, one of which is that of finding solutions to the correspondence problem. Evolutionary predecessors to observational imitation may have been self-imitation where an agent avoids the complexities of the correspondence problem by {{learning and}} replicating actions it has experienced through the manipulation of its body. We investigate how a robotic control and teaching system using self-imitation can be constructed with reference to psychological models of motor control and ideas from social scaffolding seen in animals. Within these scaffolded environments sets of competencies can be built by constructing hierarchical state/action memory maps of the robot's interaction within that environment. The scaffolding process provides a mechanism to enable learning to be scaled up. The resulting system allows a human trainer to teach a robot new skills and modify skills that the robot may possess. Additionally the system allows the robot to notify the trainer when it is being taught skills it already has in its repertoire and to direct and focus its attention and sensor resources to relevant parts of the skill being executed. We argue that these mechanisms may be a first step towards the transformation from self-imitation to observational imitation. The system is validated on a physical pioneer robot that is taught using self-imitation to track, follow and point to a <b>patterned</b> <b>object...</b>|$|E
40|$|When two visual targets, T 1 and T 2, are {{presented}} in rapid succession, detection or identification of T 2 is almost universally de-graded by the requirement to attend to T 1 (the attentional blink, or AB). One interesting exception occurs when T 1 is a brief gap in a continu-ous letter stream and the task is to discriminate its duration. One hy-pothesized explanation for this exception is that an AB is triggered only by attention to a <b>patterned</b> <b>object.</b> The results reported here eliminate this hypothesis. Duration judgments produced no AB whether the judged duration concerned a short gap in the letter stream (Experiment 1) or a letter presented for slightly longer than others (Experiment 2). When iden-tification of an identical longer letter T 1 was required (Experiment 3), rather than a duration judgment, the AB was reestablished. Direct percep-tual judgments of letter streams with gaps embedded showed that whereas brief gaps result in the percept of a single, briefly hesitating stream, longer gaps result in the percept of two separate streams with a sepa-rating pause. Correspondingly, an AB was produced in Experiment 4, when participants were required to judge the duration of longer T 1 gaps. We propose that, like spatially separated objects, temporal events are parsed into discrete, hierarchically organized events. An AB is trig-gered only when a new attended event is defined, either when a long pause creates a new perceived stream (Experiment 4) or when atten-tion shifts from the stream to the letter level (Experiment 3). The rapid serial visual presentation (RSVP) attentional blink (AB) paradigm is a well-established means of investigating the temporal limi...|$|E
3000|$|Enterprise Application Architecture Patterns hasSubcategories Data Source Architectural <b>Patterns,</b> <b>Object</b> Relational Behavioural <b>Patterns,</b> <b>Object</b> Relational Metadata Mapping <b>Patterns,</b> <b>Object</b> Relational Structural <b>Patterns</b> [...]...|$|R
30|$|Generally, {{clustering}} algorithms {{divide up}} a data set into clusters (or groups), where similar <b>pattern</b> <b>objects</b> {{are assigned to}} the same cluster whereas dissimilar <b>pattern</b> <b>objects</b> should belong to different clusters. In real applications, however, there is very often no sharp boundary between clusters, so that fuzzy clustering is often more suitable.|$|R
40|$|This Essay is {{response}} to the general question that I put to myself: How should I, an outsider to the topic, go about rationalising the notion of pattern and its dynamics when the <b>pattern</b> <b>objects</b> come from the vegetation? To facilitate succinct discussion of a very broad and intertwined topic, the Essay breaks down the pattern paradigm into three parts. The first part {{is concerned with the}} conceptual universe defined by the <b>pattern</b> <b>objects,</b> scale dependences, and order-chaos convolutions. The second part deals with the description of pattern and its evolution through time. The third, {{in the manner of a}} number of short comments, takes up pattern epidemiology, the Art of revealing cause and effect, extent, and significance...|$|R
5000|$|Prototype <b>pattern</b> creates <b>objects</b> by cloning an {{existing}} object.|$|R
5000|$|Fowler, Martin: Analysis <b>Patterns,</b> Reusable <b>object</b> models, Addison-Wesley Longman, 1997[...]|$|R
40|$|Term {{matching}} {{has become}} one of the most important primitive operations for symbolic computation. This paper describes the extension of the object-oriented symbolic computation system AlgBench with pattern matching and unification facilities. The various <b>pattern</b> <b>objects</b> are organized in subclasses of the class of the composite expressions. This leads to a clear design and to a distributed implementation of the pattern matcher in the subclasses. New <b>pattern</b> <b>object</b> classes can consequently be added easily to the system. Huet's and our simple mark and retract algorithm for standard unification as well as Stickel's algorithm for associative commutative unification have been implemented in an objectoriented style. Unifiers are selected at runtime. We extend Mathematica's type-constrained pattern matching by taking into account inheritance information from a user-defined hierarchy of object types. The argument unification is basically instance variable unification. The improvement of the [...] ...|$|R
5000|$|Abstract factory <b>pattern</b> groups <b>object</b> {{factories}} {{that have a}} common theme.|$|R
5000|$|Factory method <b>pattern</b> creates <b>objects</b> without {{specifying the}} exact class to create.|$|R
5000|$|Singleton <b>pattern</b> restricts <b>object</b> {{creation}} for a {{class to}} only one instance.|$|R
40|$|This paper details {{experiments}} in which neural network controllers were evolved in simulation that allowed a simple panning camera head to track <b>patterned</b> <b>objects</b> moving against similarly patterned backgrounds in reality. It {{begins with a}} discussion of minimal simulations: fast-running, easy-to-build simulations for the evolution of real robot controllers (Jakobi, 1998 a; Jakobi, 1998 b). The minimal simulation with which the motion-tracking controllers were evolved (along {{with the rest of the}} evolutionary machinery) is then described. Experimental results are offered in which an evolved controller was downloaded onto a simple panning camera head and satisfactorily tracked two very differently <b>patterned</b> <b>objects</b> as they moved against similarly patterned backgrounds in a random fashion. 1. Introduction Various different types of simulation have been used in the past to evolve controllers for robots: in (Jakobi et al., 1995), an empirically verified model of the underlying physics was co [...] ...|$|R
50|$|Joe teaches Agile Methods, Architecture, Design <b>Patterns,</b> <b>Object</b> Design, Refactoring, Being Agile at Quality, and Testing in {{industrial}} settings. Additionally Joe has been providing assessments and evaluations, consulting and mentoring {{people on the}} above mentioned concepts, along with assisting agile teams in successfully building and deploying various systems. Â His work has also included deploying frameworks and Domain-Specific Languages for some of his clients.|$|R
40|$|Pattern {{matching}} is {{an abstraction}} mechanism that can greatly simplify source code. We present functional-style pattern matching for C++ implemented as a library, called Mach 7 1. All the patterns are user-definable, {{can be stored}} in variables, passed among functions, and allow the use of class hierarchies. As an example, we implement common patterns used in functional languages. Our approach to pattern matching is based on compile-time composition of <b>pattern</b> <b>objects</b> through concepts. This is superior (in terms of performance and expressiveness) to approaches based on run-time composition of polymorphic <b>pattern</b> <b>objects.</b> In particular, our solution allows mapping functional code based on pattern matching directly into C++ and produces code that is only a few percent slower than hand-optimized C++ code. The library uses an efficient type switch construct, further extending it to multiple scrutinees and general patterns. We compare the performance of pattern matching to that of double dispatch and open multi-methods in C++...|$|R
5000|$|An [...] "object-box" [...] (or cell) on {{the ends}} of the reflectors can hold {{selected}} objects to be viewed in the reflected pattern. Colorful transparent shapes (for instance pieces of glass or colored fluids moving in transparent containers) to create beautiful <b>patterns.</b> <b>Objects</b> smaller than the aperture create a spotted appearance of the <b>pattern.</b> Larger opaque <b>objects</b> and darker colors don't transmit much light and are usually avoided. If objects, fragments and/or liquids are loosely placed inside the cell and tumble when the cell is rotated, motion and change of colors and shapes can be introduced into the viewed pattern.|$|R
2500|$|Shape Recognition Technology (SRT) {{in people}} counter systems {{differentiating}} human beings (head and shoulder <b>patterns)</b> from <b>objects</b> ...|$|R
5000|$|Factories {{are used}} in various design patterns, {{specifically}} in creational patterns such as the Design <b>pattern</b> <b>object</b> library. Specific recipes {{have been developed to}} implement them in many languages. For example, several [...] "GoF patterns", like the [...] "Factory method pattern", the [...] "Builder" [...] or even the [...] "Singleton" [...] are implementations of this concept. The [...] "Abstract factory pattern" [...] instead is a method to build collections of factories.|$|R
40|$|In this paper, {{we study}} {{the problem of}} {{recognizing}} events in personal photo albums. In consumer photo collections or on-line photo communities, photos are usually organized in al-bums according to their events. However, interpreting photo albums {{is more complicated than}} the traditional problem of understanding single photos, because albums generally ex-hibit much more varieties than single image. To solve this challenge, we propose a novel representation, called Com-positional <b>Object</b> <b>Pattern,</b> which characterizes <b>object</b> level <b>pattern</b> conveying much richer semantic than low level visual feature. To interpret the rich semantics in albums, we mine frequent <b>object</b> <b>patterns</b> in the training set, and then rank them by their discriminating power. The album feature is then set as the frequencies of these frequent and discrimi-native <b>patterns,</b> called Compositional <b>Object</b> <b>Pattern</b> Fre-quency(COPF). We show with experimental result that our algorithm is capable of recognizing holidays with accuracy higher than other methods...|$|R
40|$|This paper {{describes}} a <b>pattern</b> for <b>object</b> sharing across different address spaces. The pattern {{is intended for}} applications where collaborators on clients across a network work closely together. The Simple Shared <b>Object</b> <b>pattern</b> allows distributed applications to create, modify and delete shared objects on a corresponding server. The clients have copies of shared objects they use in their own address spaces. All modifications made to the primary copies on the server are propagated to clients having copies in their address spaces. The pattern is not designed for high traffic communication between concurrent running applications. Rather, it is designed for applications where some objects have to be shared across a network and where shared objects have to be synchronised and informed whenever a shared object changes. 1 Intent The Simple Shared <b>Object</b> <b>pattern</b> allows <b>object</b> sharing across networks. The primary instance of a shared object will exist in the address space of a server program; [...] ...|$|R
50|$|Pools {{can also}} be used for objects, in which context a pool refers to a design pattern for {{implementing}} pools in object-oriented languages, such as in the <b>object</b> pool <b>pattern.</b> <b>Objects</b> themselves hold no external resources and only occupy memory, although an already created object avoids the memory allocation required on object creation. Object pools are useful when the cost of object creation is high, but in certain situations this simple object pooling may not be efficient and could in fact decrease performance.|$|R
50|$|There are {{two major}} kinds of {{exhibitions}} in the FestivalâChrysanthemum-planting contest and Chrysanthemum modelling, in which chrysanthemums are piled up or arranged into <b>patterns</b> or <b>objects.</b>|$|R
50|$|This {{library is}} a {{high-level}} abstractions of the Join <b>Pattern</b> using <b>objects</b> and generics. Channels are special delegate values from some common Join object (instead of methods).|$|R
50|$|Another {{example of}} active <b>object</b> <b>pattern</b> in Java.|$|R
50|$|Creational design {{patterns}} are further categorized into Object-creational patterns and Class-creational patterns, where Object-creational <b>patterns</b> deal with <b>Object</b> creation and Class-creational patterns deal with Class-instantiation. In greater details, Object-creational patterns defer {{part of its}} object creation to another <b>object,</b> while Class-creational <b>patterns</b> defer its <b>object</b> creation to subclasses.|$|R
5|$|From the Iron Age {{there are}} more {{extensive}} examples of <b>patterned</b> <b>objects</b> and gold work. Evidence of the wider La TÃ¨ne culture includes the Torrs Pony-cap and Horns. The Stirling torcs demonstrate common styles found in Scotland and Ireland and continental workmanship. One {{of the most impressive}} items from this period is the boar's head fragment of the Deskford carnyx. From the first century CE, as Rome carried out a series of occupations, there are Roman artifacts like the Cramond Lioness and Roman influence on material culture can be seen in local stone carvings.|$|R
2500|$|PDF {{supports}} {{several types}} of patterns. The simplest is the tiling pattern in which a piece of artwork is specified to be drawn repeatedly. This may be a colored tiling pattern, with the colors specified in the <b>pattern</b> <b>object,</b> or an uncolored tiling pattern, which defers color specification to the time the pattern is drawn. Beginning with PDF 1.3 {{there is also a}} shading pattern, which draws continuously varying colors. There are seven types of shading pattern of which the simplest are the axial shade (Type 2) and radial shade (Type 3).|$|R
50|$|From the Iron Age {{there are}} more {{extensive}} examples of <b>patterned</b> <b>objects</b> and gold work. Evidence of the wider La TÃ¨ne culture includes the Torrs Pony-cap and Horns. The Stirling torcs demonstrate common styles found in Scotland and Ireland and continental workmanship. One {{of the most impressive}} items from this period is the boar's head fragment of the Deskford carnyx. From the first century CE, as Rome carried out a series of occupations, there are Roman artifacts like the Cramond Lioness and Roman influence on material culture can be seen in local stone carvings.|$|R
40|$|Abstract. Symmetry, {{jointly with}} their âoppositeâ, Antisymmetry, may be {{considered}} as {{two sides of the}} same coin: total symmetry, or total asymmetry, relative to a <b>pattern</b> <b>object,</b> without intermediate situations. But this dychotomical classification suffer a lack of necessary and realistic grades. For this reason, it is convenient the introduction of âshade regionsâ, modulating the degrees (a fuzzy concept). So, we analyze here the Asymmetry Problem, with its different attempts of description (from the Physics, by techniques as Group Theory), searching an efficient algorithm, by the introduction of Asymmetry/Symmetr...|$|R
5000|$|PDF {{supports}} {{several types}} of patterns. The simplest is the tiling pattern in which a piece of artwork is specified to be drawn repeatedly. This may be a colored tiling pattern, with the colors specified in the <b>pattern</b> <b>object,</b> or an uncolored tiling pattern, which defers color specification to the time the pattern is drawn. Beginning with PDF 1.3 {{there is also a}} shading pattern, which draws continuously varying colors. There are seven types of shading pattern of which the simplest are the axial shade (Type 2) and radial shade (Type 3).|$|R
40|$|Extrastriate {{visual cortex}} of the ventral-posterior suprasylvian gyrus (vPS cortex) of freely {{behaving}} cats was reversibly deactivated with cooling {{to determine its}} role in performance on a battery of simple or masked two-dimensional pattern discriminations, and three-dimensional object discriminations. Deactivation of vPS cortex by cooling profoundly impaired {{the ability of the}} cats to recall the difference between all previously learned <b>pattern</b> and <b>object</b> discriminations. However, the cats' ability to learn or relearn <b>pattern</b> and <b>object</b> discriminations while vPS was deactivated depended upon the nature of the <b>pattern</b> or <b>object</b> and the cats' prior level of exposure to them. During cooling of vPS cortex, the cats could neither learn the novel object discriminations nor relearn a highly familiar masked or partially occluded pattern discrimination, although they could relearn both the highly familiar <b>object</b> and simple <b>pattern</b> discriminations. These cooling-induced deficits resemble those induced by cooling of the topologically equivalent inferotemporal cortex of monkeys and provides evidence that the equivalent regions contribute to visual processing in similar ways...|$|R
5000|$|Builder <b>pattern</b> {{constructs}} complex <b>objects</b> by separating {{construction and}} representation.|$|R
50|$|Nullable type {{implementations}} usually {{adhere to}} the null <b>object</b> <b>pattern.</b>|$|R
40|$|The central {{topic of}} this study is to {{investigate}} three- and four-place predicate in Yaqui, which are characterized by having multiple object arguments. As with other Southern Uto-Aztecan languages, it has been said that Yaqui follows the Primary/Secondary <b>Object</b> <b>pattern</b> (Dryer 1986). Actually, Yaqui presents three patterns: verbs like nenka âsellâ follow the directâindirect <b>object</b> <b>pattern,</b> verbs like miika âgiveâ follow the primary <b>object</b> <b>pattern,</b> and verbs like chijakta âsprinkleâ follow the locative alternation pattern; the primary <b>object</b> <b>pattern</b> is the exclusive one found with derived verbs. This paper shows that the contrast between direct object and primary object languages is not absolute but rather one of degree, and hence two âobjectâ selection principles are needed to explain this mixed system. The two principles are not limited to Yaqui but are found in other languages as well, including English...|$|R
50|$|In {{software}} engineering, behavioral {{design patterns}} are design patterns that identify common communication <b>patterns</b> between <b>objects</b> and realize these patterns. By doing so, these patterns increase flexibility {{in carrying out}} this communication.|$|R
40|$|Hotspot is {{a special}} kind of {{clustered}} pattern. Like general clustered <b>patterns,</b> <b>objects</b> in the hotspot regions have high similarity in comparison to one another, and are quite dissimilar to all the objects outside the hotspot. One important feature that distinguish hotspot from general cluster is that the objects in the hotspot area are more active compared to all the others (density, appearance, etc). Hotspot discovery/detection in spatial data mining is a process of finding certain spatial regions where more events are likely to happen, or more objects are likely to appear, in comparison to the other areas...|$|R
5000|$|... normal {{formation}} of non-face memories (e.g. places, <b>objects,</b> <b>patterns,</b> words, etc.) ...|$|R
