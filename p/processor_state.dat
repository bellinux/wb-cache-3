88|195|Public
25|$|Windows Vista allows {{fine-grained}} {{control over}} power settings such as setting the {{power saving mode}} for wireless adapters, USB selective suspend, PCI Express link state power management, <b>processor</b> <b>state</b> etc., and also allows configuring power settings for specific scenarios such as sharing media files, giving a presentation, during adaptive display mode and while indexing files.|$|E
25|$|Windows XP further {{improved}} {{support for}} hibernation. Hibernation and resumption are much faster as memory pages are compressed using an improved algorithm; compression is overlapped with disk writes, unused memory pages are freed and DMA transfers are used during I/O. hiberfil.sys contains further information including <b>processor</b> <b>state.</b> This file was documented by a security researcher Matthieu Suiche during Black Hat Briefings 2008 who {{also provided a}} computer forensics framework to manage and convert this file into a readable memory dump. The compression algorithm was later documented by Microsoft as well.|$|E
25|$|Each multi-threaded MIPS core {{can support}} {{up to two}} VPEs (Virtual Processing Elements) which share a single {{pipeline}} {{as well as other}} hardware resources. However, since each VPE includes a complete copy of the <b>processor</b> <b>state</b> as seen by the software system, each VPE appears as a complete standalone processor to an SMP Linux operating system. For more fine-grained thread processing applications, each VPE is capable of supporting up to nine TCs allocated across two VPEs. The TCs share a common execution unit but each has its own program counter and core register files so that each can handle a thread from the software.|$|E
50|$|In <b>processor</b> <b>states</b> P1 and P2, 16 GPRs were available; in State P3, 6 GPRs were available, {{while in}} State P4, 5 GPRs were available. An {{interrupt}} status register and interrupt mask register were provided {{in each of}} the four <b>processor</b> <b>states.</b> The one set of floating-point registers was available to all <b>processor</b> <b>states.</b>|$|R
25|$|User {{configurable}} system cooling policy, {{minimum and}} maximum <b>processor</b> <b>states.</b>|$|R
50|$|This 32-bit {{register}} either controls and/or reports {{several important}} <b>processor</b> <b>states.</b>|$|R
2500|$|The 68000 is also {{unable to}} easily support virtual memory, which {{requires}} {{the ability to}} trap and recover from a failed memory access. The 68000 does provide a bus error exception {{which can be used}} to trap, but it does not save enough <b>processor</b> <b>state</b> to resume the faulted instruction once the operating system has handled the exception. Several companies did succeed in making 68000-based Unix workstations with virtual memory that worked by using two 68000 chips running in parallel on different phased clocks. When the [...] "leading" [...] 68000 encountered a bad memory access, extra hardware would interrupt the [...] "main" [...] 68000 to prevent it from also encountering the bad memory access. This interrupt routine would handle the virtual memory functions and restart the [...] "leading" [...] 68000 in the correct state to continue properly synchronized operation when the [...] "main" [...] 68000 returned from the interrupt.|$|E
50|$|The 18 series {{implemented}} shadow, registers which save {{several important}} registers during an interrupt, providing hardware support for automatically saving <b>processor</b> <b>state</b> when servicing interrupts.|$|E
5000|$|C2 (often {{known as}} Stop-Clock) {{is a state}} where the {{processor}} maintains all software-visible state, but may take longer to wake up. This <b>processor</b> <b>state</b> is optional.|$|E
500|$|An October 2008 Gartner {{report on}} the Tukwila <b>processor,</b> <b>stated</b> that [...] "...the future roadmap for Itanium looks as strong as that of any RISC peer like Power or SPARC." ...|$|R
50|$|Once an OSPM-compatible {{operating}} system activates ACPI, it takes exclusive {{control of all}} aspects of power management and device configuration. The OSPM implementation must expose an ACPI-compatible environment to device drivers, which exposes certain system, device and <b>processor</b> <b>states.</b>|$|R
25|$|Removal {{of support}} for legacy <b>processor</b> {{performance}} <b>state</b> interfaces.|$|R
5000|$|<b>Processor</b> <b>state</b> (context), such as {{the content}} of {{registers}} and physical memory addressing. The state is typically stored in computer registers when the process is executing, and in memory otherwise.|$|E
50|$|One of {{the bits}} in the <b>processor</b> <b>state</b> word (see below) {{indicates}} that the processor is accessing data from the stack. Using this signal, {{it is possible to}} implement a separate stack memory space. However, this feature was seldom used.|$|E
50|$|Because LOADALL did {{not perform}} any checks on the {{validity}} of the data loaded into processor registers, it was possible to load a <b>processor</b> <b>state</b> that could not be normally entered, such as using real mode (PE=0) together with paging (PG=1) on 386-class CPUs.|$|E
50|$|English Electric System 4 (1965) - the System 4-50 and System 4-70 {{were based}} on the RCA Spectra 70 series, built under licence. The latter were almost the same as IBM System /360 range, differing only in their {{real-time}} facilities, with four <b>processor</b> <b>states</b> and multiple sets of general-purpose registers.|$|R
5000|$|... <b>processor</b> {{contains}} <b>state</b> {{information for}} one processor {{in the system}} ...|$|R
25|$|More {{flexible}} use of {{the available}} range of <b>processor</b> performance <b>states</b> through system power policy.|$|R
50|$|<b>Processor</b> <b>state</b> as {{captured}} on a stack at an interrupt contains the {{information needed to}} both return control to the interrupted activity and to determine the type of the interrupt. Interrupts may occur {{in the middle of}} long instructions and the state deals with that possibility.|$|E
50|$|Error {{detection}} and recovery is emphasized, with error-correcting code (ECC) on L2 and L3 caches and buffers, and extensive parity checking elsewhere; in all over 20,000 error checkers on the chip. <b>Processor</b> <b>state</b> is buffered {{in a way}} that allows precise core retry for almost all hardware errors.|$|E
50|$|In {{the event}} that a branch causes a {{pipeline}} bubble after incorrect instructions have entered the pipeline, {{care must be taken}} to prevent any of the wrongly-loaded instructions from having any effect on the <b>processor</b> <b>state</b> excluding energy wasted processing them before they were discovered to be loaded incorrectly.|$|E
5000|$|Improved ACPI <b>processor</b> {{performance}} <b>states</b> for multi-core <b>processors</b> {{beginning with}} Windows XP Service Pack 2.|$|R
40|$|The control {{space of}} a digital process {{can be viewed as}} a {{projection}} of the state space of the <b>processor.</b> This <b>state</b> space may be an interpretation of some underlying (perhaps physical) <b>processor's</b> <b>state</b> space. A control operator is a projection of a process step: the portion which specifies the 'next control state'. A set of elementary control structures is defined and used as a common basis for comparing the control structures in a microcomputer and several programming languages. The relationship of this view of control to several areas of computer science research is notedNaval Electronics Laboratory Center[URL] in part by the Naval Electronics Laboratory Center under Work Request WR- 2 - 9104 dated 26 April 1972. N...|$|R
25|$|The static {{use of any}} linear {{throttle}} {{state on}} systems that are not capable of <b>processor</b> performance <b>states.</b>|$|R
50|$|In addition, the System Management Mode (SMM) (the same mode {{introduced}} with i386SL) {{was included}} with this processor. The system management mode {{makes it possible}} to shut down the processor without losing data. To achieve this, the <b>processor</b> <b>state</b> is saved in an area of static RAM (SMRAM).|$|E
50|$|The {{operating}} system holds {{most of this}} information about active processes in data structures called process control blocks. Any subset of the resources, typically at least the <b>processor</b> <b>state,</b> {{may be associated with}} each of the process' threads in {{operating system}}s that support threads or child (daughter) processes.|$|E
5000|$|C3 (often {{known as}} Sleep) {{is a state}} where the {{processor}} {{does not need to}} keep its cache coherent, but maintains other state. Some processors have variations on the C3 state (Deep Sleep, Deeper Sleep, etc.) that differ in {{how long it takes to}} wake the processor. This <b>processor</b> <b>state</b> is optional.|$|E
40|$|A new multirate sampled-data {{control law}} {{structure}} is defined {{and a new}} parameter-optimization-based synthesis algorithm for that structure is introduced. The synthesis algorithm {{can be applied to}} multirate, multiple-input multiple-output, sampled-data control laws having a prescribed dynamic order and structure, and a priori specified sampling/update rates for all sensors, <b>processor</b> <b>states,</b> and control inputs. The synthesis algorithm is applied to design two-input, two-output tip position controllers of various dynamic orders for a sixth-order, two-link robot arm model...|$|R
50|$|Processor {{affinity}} {{takes advantage}} of the fact that remnants of a process that was run on a given processor may remain in that <b>processor's</b> <b>state</b> (for example, data in the cache memory) after another process was run on that processor. Scheduling that process to execute on the same processor improves its performance by reducing performance-degrading events such as cache misses. A practical example of processor affinity is executing multiple instances of a non-threaded application, such as some graphics-rendering software.|$|R
40|$|The {{advanced}} variable size scalable architecture {{has many}} features that present significant verification challenges to ensure correct implementation. This paper describes a functional verification system and methodology {{to address the}} requirements of correct verification of the PalmDSPCore ®. In particular, the paper presents an efficient tool and methodology to generate random assembly tests, {{in accordance with the}} dynamic change of the <b>processor’s</b> <b>states.</b> It describes both random and pseudo-random scenarios and describes how to feedback this process {{to be sure that the}} Device Under Test (DUT) was adequately tested...|$|R
5000|$|Practically speaking, {{there may}} be {{exceptions}} for which not enough status information about an exception is available, {{in which case the}} processor may raise a special exception, called an [...] "imprecise" [...] exception. Imprecise exceptions cannot occur in non-OoOE implementations, as <b>processor</b> <b>state</b> is changed only in program order (see RISC Pipeline Exceptions).|$|E
50|$|Windows Vista allows {{fine-grained}} {{control over}} power settings such as setting the {{power saving mode}} for wireless adapters, USB selective suspend, PCI Express link state power management, <b>processor</b> <b>state</b> etc., and also allows configuring power settings for specific scenarios such as sharing media files, giving a presentation, during adaptive display mode and while indexing files.|$|E
50|$|So {{for example}} a JTAG host might HALT the core, {{entering}} Debug Mode, and then read CPU registers using ITR and DCC. After saving <b>processor</b> <b>state,</b> it could write those registers with whatever values it needs, then execute arbitrary algorithms on the CPU, accessing memory and peripherals to help characterize the system state. After the debugger performs those operations, {{the state may}} be restored and execution continued using the RESTART instruction.|$|E
50|$|Motorola 68000 (address is {{represented}} in 24 bits). Could {{have one or two}} autoincrement register operands. The 68010+ resolved the problem by saving the <b>processor's</b> internal <b>state</b> on bus or address errors.|$|R
40|$|This paper answers several {{questions}} of centralized Kalman-Filters in multi-sensor fusion, fault detection and isolation in sensors, optimal control in linear-quadratic Gaussian problem, an algorithm in fuzzy based approach to adaptive Kalman-Filtering additionally in multi-state multi-sensor fusion. Generally, Kalman-Filters comprise {{a number of}} types and topologies depending on use and computing complexity of applied <b>processors.</b> <b>State</b> estimation provided by a Kalman-Filter is crucial in this thesis. Kalman-Filter performs optimal estimation of an unknown system state through filters behavior. This thesis supposes some models of promising linear Kalman-Filter simulated beyond MATLAB and Simulink program especially utilized {{in the fields of}} steering-controls or navigations, etc...|$|R
40|$|The {{analysis}} of the worst-case execution time (WCET) requires detailed knowledge of the program behavior. In practice {{it is still not}} possible to obtain all needed information automatically. In this paper we present {{the current state of the}} art of WCET analysis and point to the main problems to be solved. The most eminent problem is the state problem, i. e., the precise determination of possible <b>processor</b> <b>states</b> at different program locations. The path problem refers to the fact that current tools are not able to calculate all (in) feasible paths automatically. We discuss how the main open problems manifest themselves in static and in measurement-based WCET analysis methods...|$|R
