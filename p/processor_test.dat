4|330|Public
40|$|To build {{high-performance}} {{network devices}} with holistic security protection, {{a large number}} of algorithms have been proposed. However, multi-core implementation of the existing algorithms suffers from three limitations: performance instability, datastructure heterogeneity, and hardware dependency. In this paper, we propose three principles for effective network processing on multi-core network processors. To verify the effectiveness of these principles, algorithms for two typical network processing tasks are redesigned and implemented on the Cavium Octeon 3860 network <b>processor.</b> <b>Test</b> results show that our schemes achieve superior performance in comparison with existing best-known algorithms...|$|E
40|$|SUMMARY This paper proposes an {{efficient}} methodology of delay fault testing of processor cores using their instruction sets. These test vectors {{can be applied}} in the functional mode of operation, hence, self-testing of processor core becomes possible for path delay fault testing. The proposed approach uses a graph theoretic model (represented as an Instruction Execution Graph) of the datapath and a finite state machine model of the controller {{for the elimination of}} functionally untestable paths at the early stage without looking into the circuit details and extraction of constraints for the paths that can potentially be tested. Parwan and DLX processors are used to demonstrate the effectiveness of our method. key words: <b>processor</b> <b>test,</b> delay fault testing, software-based self-test, at-speed test 1...|$|E
40|$|Abstract – Learning about Computer Engineering is {{a highly}} {{constructive}} process. At our department, computer engineering encompasses three courses and a laboratory session. In order to successfully learn the subject, the students should have hands-on experience with tools. While tools to program (compilers, interpreters, development environments) are widely available for free on the internet, the situation is different for computer engineering. To learn the foundations of digital design, a tool to design and simulate digital circuits is needed. To master microprocessors and microcontrollers, access to assemblers and simulators is needed. To master computer architecture, access to an architectural simulator is needed. The laboratory session requires either an extended on-campus phase or necessitates web access to the devices (<b>processor</b> <b>test</b> cards, oscilloscopes, etc) in the lab. We present an overview of our efforts {{in the last five}} years, through which we have provided students with web access to all the tools and devices above...|$|E
25|$|According to Sophie Wilson, all the <b>processors</b> <b>tested</b> at {{that time}} {{performed}} about the same, with about a 4Mbit/second bandwidth.|$|R
40|$|Several constant-time {{parallel}} algorithms for {{fault diagnosis}} {{have been given}} for the classical static-fault model. We extend those algorithms to tolerate intermittent faults. 1. Static Fault Diagnosis Imagine a robot surveying a nuclear accident. As it collects data in radioactive hot spots, its processors tend to get fried. Before too many processors fail, the robot retreats to a safe spot in order to heal. During the healing process, the robot’s <b>processors</b> <b>test</b> each other and communicate test results (some correct, some incorrect) to an external controller in a very safe location {{as far as possible}} from the accident. The controller determines which processors are really faulty and sends instructions to deactivate them. Then the robot may return to its mission. The robot’s “healing ” process is called system level fault diagnosis, as proposed initially by Preparata, Metze, and Chien [9]. In their model, when a good <b>processor</b> <b>tests</b> another <b>processor</b> it reports the testee’s status correctly to the controller. But when a faulty <b>processor</b> <b>tests</b> another <b>processor</b> it may report the testee’s status correctly or incorrectly. Such testing protocols have been usefully implemented, see [4, 3]...|$|R
50|$|The Ada Conformity Assessment Test Suite (ACATS) is {{the test}} suite used for Ada <b>processor</b> {{conformity}} <b>testing.</b>|$|R
40|$|The {{authors have}} {{constructed}} a wavelet processing board that implements a 14 -level wavelet transform. The board uses a high-speed, analog-to-digital (A/D) converter, a hardware queue, and five fixed-point {{digital signal processing}} (DSP) chips in a parallel pipeline architecture. All five processors are independently programmable. The board is designed as a general purpose engine for instrumentation applications requiring near real-time wavelet processing or multiscale filtering. The present application is the processing engine of a magnetic field monitor that covers 305 Hz through 5 MHz. The monitor {{is used for the}} detection of peak values of magnetic fields in nuclear power plants. This paper describes the design, development, simulation, and testing of the system. Specific issues include the conditioning of real-world signals for wavelet processing, practical trade-offs between queue length and filter length, selection of filter coefficients, simulation of a 14 -octave filter bank, and limitations imposed by a fixed-point <b>processor.</b> <b>Test</b> results from the completed wavelet board are included...|$|E
40|$|Consider {{a set of}} processors, V, {{that can}} {{communicate}} with each other. Assume that each processor can be either "good" or "faulty". Also assume that the processors {{can be used to}} test each other. We provide a parallel algorithm that determines which processors are good and which are faulty in 32 rounds of testing, provided that a strict majority of the processors are good. 1. Introduction Consider a set of processors, V, that can communicate with each other. Assume that each processor can be either "good" or "faulty". Also assume that the processors can be used to test each other. If a good <b>processor</b> <b>tests</b> a good <b>processor,</b> it outputs "good"; if a good <b>processor</b> <b>tests</b> a faulty <b>processor,</b> it outputs "faulty"; we make no assumptions about the output of faulty processors. The fault diagnosis problem is to determine which processors are good, and which are faulty. This model was introduced by Preparata, Metze, and Chien [12]. They observed that fault diagnosis is possible in general onl [...] ...|$|R
5000|$|... (Optional) <b>Processor</b> {{stability}} <b>test,</b> normally {{runs for}} one hour, {{can also be}} run {{for a minimum of}} 1 minute or a maximum of seven days, to identify whether the system becomes unstable for use after fine-tuning under full-loading condition. Tests include: integer (integer units) calculations and stack operations <b>test</b> for each <b>processor</b> core, floating-point (128-bit FPU) calculations <b>test</b> for each <b>processor</b> core, calculation <b>test</b> (Phenom <b>processors</b> only), MCA registers checking test ...|$|R
40|$|In {{this paper}} we {{designed}} {{a new type}} of Random number generator by using shift registers and LUT with D-FF as input to it. The algorithm used to generate random numbers is realized using simple xor circuit and implemented on a Virtex II FPGA from Xilinx. This designed block indicate a good sequence of random numbers which is used in high-speed data <b>processor,</b> <b>Testing</b> Instruments, Finding Laser Range, Timeof-flight mass spectrometry experiments etc. The randomness of this type of RNG is tested using NIST statistical test and this method has produced good results...|$|R
40|$|International audienceThis paper {{presents}} a software-based approach for testing IEEE 1500 -compliant SoCs. In the proposed approach, the test program {{is no more}} executed by the external-traditional tester but by the SoC itself. The novel feature {{is the use of}} a dedicated <b>test</b> <b>processor</b> called T-Proc embedded onto the SoC to test the components. Under the control of the embedded SoC microprocessor, the <b>test</b> <b>processor</b> executes the <b>test</b> programs stored in the outside external memory, through a functional embedded external RAM controller interface. Using the ITC 02 SoC benchmarks a comparison is done between T-Proc and a classical bus-based test strategy...|$|R
40|$|Attention {{is given}} to current {{activities}} in the Embedded Data Processor and Portable Computer Technology testbed configurations {{that are part of}} the Advanced Data Systems Architectures Testbed at the Information Sciences Division at NASA Ames Research Center. The Embedded Data <b>Processor</b> <b>Testbed</b> evaluates advanced microprocessors for potential use in mission and payload applications within the Space Station Freedom Program. The Portable Computer Technology (PCT) Testbed integrates and demonstrates advanced portable computing devices and data system architectures. The PCT Testbed uses both commercial and custom-developed devices to demonstrate the feasibility of functional expansion and networking for portable computers in flight missions...|$|R
40|$|Embedded <b>processor</b> <b>testing</b> {{techniques}} {{based on}} the execution of self-test routines, have been recently proposed as an effective alternative to classical hardware Built-In Self Test. Software-based self-testing provides atspeed testing capability and does not add hardware or performance penalties. It efficiently partitions the testing task between external testers and internal processor resources. In this paper we analyze {{the application of a}} softwarebased self-testing methodology to different implementations of a complex embedded processor architecture. We demonstrate that such a methodology provides high test quality in different processor implementations with low test development and low test application costs. ...|$|R
500|$|The S4-based {{generation}} of Snapdragon SoCs began shipping to product manufacturers with the MSM8960 in February 2012. In benchmark tests by Anandtech, the MSM8960 had better performance {{than any other}} <b>processor</b> <b>tested.</b> In an overall system benchmark, the 8960 obtained a score of [...] 907, compared to 528 and 658 for the Galaxy Nexus and HTC Rezound respectively. In a Quadrant benchmark test, which assesses raw processing power, a dual-core Krait processor had a score of 4,952, whereas the quad-core Tegra 3 was just under 4,000. The quad-core version, APQ8064, was made available in July 2012. It was the first Snapdragon SoC to use Qualcomm's Adreno 320 graphics processing unit (GPU).|$|R
40|$|We {{describe}} a new clinical laboratory instrument, the Abbott AXSYM, which provides random- and continu-ous-access testing for immunoassays, 20 onboard re-agents, primary tube sampling, and a throughput of 80 to 120 tests per hour. The AxSYM incorporates three sepa-rate analytical technologies for processing immunoas-says: microparticle enzyme immunoassay, fluorescence polarization immunoassay, and a novel technology known as ion-capture immunoassay. The system incorporates both common and technology-specific subsystems con-trolled by a real-time software scheduling <b>processor.</b> <b>Tests</b> can be processed in one- or two-step sandwich or competitive formats, with variable pipethng steps, incuba-tion periods, optical read formats, and wash sequences. Menu capabilities include tests for hepatitis, retrovirus...|$|R
50|$|The S4-based {{generation}} of Snapdragon SoCs began shipping to product manufacturers with the MSM8960 in February 2012. In benchmark tests by Anandtech, the MSM8960 had better performance {{than any other}} <b>processor</b> <b>tested.</b> In an overall system benchmark, the 8960 obtained a score of 907, compared to 528 and 658 for the Galaxy Nexus and HTC Rezound respectively. In a Quadrant benchmark test, which assesses raw processing power, a dual-core Krait processor had a score of 4,952, whereas the quad-core Tegra 3 was just under 4,000. The quad-core version, APQ8064, was made available in July 2012. It was the first Snapdragon SoC to use Qualcomm's Adreno 320 graphics processing unit (GPU).|$|R
40|$|Great {{numerical}} complexity is {{a characteristic}} of synthetic aperture radar (SAR) image synthesis algorithms that poses a particularly serious problem for real-time application. Advances in the operating speed and density of the field programmable gate arrays (FPGA) have allowed many high-end signal processing applications to be solved in commercially available hardware. A real-time SAR image processor was designed and implemented with the commercial off the shelf (COTS) hardware. The hardware {{was based on the}} Xilinx Virtex 5 FPGA devices. Under the assumption of squinted SAR geometry and range migration effect present the SAR image synthesis algorithm was developed and implemented. The results of the <b>processor</b> <b>tests</b> conducted with simulated and real raw SAR signals are presented in the paper...|$|R
40|$|Consider {{a set of}} n {{processors}} {{that can}} communicate with each other. Assume that each processor can be either "good" or "faulty". Also assume that the <b>processors</b> can <b>test</b> each other. We consider how to use parallel testing rounds to identify the faulty processors, given an upper bound t on their number. We prove that 4 rounds are necessary and sufficient when 2 p 2 n t 0 : 03 n (for n sufficiently large). Furthermore, at least 5 rounds are necessary when t 0 : 49 n (for n sufficiently large), and 10 rounds are sufficient when t ! 0 : 5 n (for all n). (It {{is well known that}} no general solution is possible when t 0 : 5 n.) 1 Introduction Imagine a robot surveying a nuclear accident. As it collects data in radioactive hot spots, its processors tend to get fried. Before too many processors fail, the robot retreats to a safe spot in order to heal. During the healing process, the robot's <b>processors</b> <b>test</b> each other and communicate test results (some correct, some incorrect) to an external contro [...] ...|$|R
40|$|Spaceflight and {{planetary}} exploration place severe {{constraints on the}} available bandwidth for downlinking large hyperspectral images. In addition, communications with spacecraft often occur intermittently, so mission-relevant hyperspectral data must wait for analysis on the ground before it can inform spacecraft activity planning. Onboard endmember detection can help alleviate these problems. It enables novelty detection and target identification for scheduling followup activities such as additional observation by narrow field of view instruments. Additionally, endmember analysis can facilitate data summary for downlink. This work describes a planned experiment of selective downlink by the EO- 1 autonomous spacecraft. Here an efficient superpixel endmember detection algorithm keeps to the limited computational constraints of the flight <b>processor.</b> <b>Tests</b> suggest the procedure could enable significant improvements in downlink efficiency...|$|R
50|$|The current {{version of}} XBRL is 2.1, with errata corrections. A {{conformance}} suite is available to <b>test</b> <b>processors</b> of XBRL documents.|$|R
40|$|Explicit-multi-threading (XMT) is a {{parallel}} programming approach for exploiting on-chip parallelism. Its fine-grained SPMD programming model {{is suitable for}} many computing intensive applications. In this paper, we present {{a parallel}} gate level logic simulation algorithm and study its implementation on an XMT <b>processor.</b> The <b>test</b> results show that hundreds-fold speedup can be achieved...|$|R
40|$|A {{solid state}} boron- ion {{implanted}} silicon Charged Particle Detector (CPD) was designed, built, and tested {{as one of}} the payloads for a Stanford University/Lockheed Martin Cubesat (10 cm cube, 1 Kg) project intended for a low earth orbit. Design drivers to be discussed will include cost, size, mass and schedule. Two detectors were utilized with shielding to allow for two separate energy ranges to be detected. Stanford Research Institute facilities were used for testing. Design considerations will be discussed relating to tuning of the electronics for various low earth orbit altitudes, along with matching voltage requirements for the electronics with a low power, 3. 7 Volt spacecraft bus (1 watt). Other payloads include a developmental sun sensor and Honeywell 3 axis solid state magnetometer. Overall cubesat development will also be discussed, including structure, communications, power, and <b>processor.</b> <b>Testing</b> techniques and current results will be shown for this ongoing project...|$|R
40|$|Abstract—Embedded <b>processor</b> <b>testing</b> {{techniques}} {{based on}} the execution of self-test programs have been recently proposed as an effective alternative to classic external tester-based testing and pure hardware built-in self-test (BIST) approaches. Software-based self-testing is a nonintrusive testing approach and provides at-speed testing capability without any hardware or performance overheads. In this paper, we first present a high-level, functional component-oriented, software-based self-testing methodology for embedded processors. The proposed methodology aims at high structural fault coverage with low test development and test application cost. Then, we validate {{the effectiveness of the}} proposed methodology as a low-cost alternative over structural software-based self-testing methodologies based on automatic test pattern generation and pseudorandom testing. Finally, we demonstrate the effectiveness and efficiency of the proposed methodology by completely applying it on two different processor implementations of a popular RISC instruction set architecture including several gate-level implementations. Index Terms—Embedded processors, processor self-testing, software-based self-testing, low-cost testing. ...|$|R
40|$|Abstract. <b>Processor</b> <b>testing</b> {{approaches}} {{based on}} the execution of self-test programs have been recently proposed as an effective alternative to classic external tester-based testing and pure hardware built-in self-test (BIST) approaches. Software-based self-testing is a non-intrusive testing approach that embeds a “software tester ” {{in the form of}} a self-test program in the processor on-chip memory. It has the potential to provide high quality at-speed testing using low-cost external ATE without any hardware or performance overheads. In this thesis, we introduce a high-level, software-based self-testing methodology for embedded processors and microprocessors. The proposed methodology aims at high structural fault coverage with low test development and test application cost. We demonstrate the effectiveness and efficiency of the proposed methodology by completely applying it on several processor benchmarks with scaling complexity, implementing different implementations of a popular RISC instruction set architecture with several gate-level implementations. 1...|$|R
40|$|Abstract—This paper {{presents}} a high-level automatic test instruction generation (HATIG) technical that allows, {{for the first}} time, to test the scheduling unit of an out-of-order superscalar processor. This technique leverages on existing bounded model checking tools in order to generate software-based self-testing programs from a global EFSM model of the <b>processor</b> under <b>test.</b> The experimental results have demonstrated {{the efficiency of the}} proposed technique...|$|R
50|$|The server {{supported}} {{up to six}} 3.5 inch SATA or SAS {{hot swap}} hard disk drives. Upgrades to the server included conversion options to eight 2.5 inch hard disk drives or four 3.5 inch hard disk drives with an internal tape drive with external storage arrays. Power consumption was recorded as being 45W on standby, 203W with the OS on idle, and 289W with the <b>processor’s</b> capabilities <b>tested</b> intensively.|$|R
40|$|The ALLSPD- 3 D Computational Fluid Dynamics {{code for}} {{reacting}} flow simulation was {{run on a}} set of benchmark test cases to determine its parallel efficiency. These test cases included non-reacting and reacting flow simulations with varying numbers of <b>processors.</b> Also, the <b>tests</b> explored the effects of scaling the simulation with the number of processors in addition to distributing a constant size problem over an increasing number of <b>processors.</b> The <b>test</b> cases were run on a cluster of IBM RS/ 6000 Model 590 workstations with ethemet and ATM networking plus a shared memory SGI Power Challenge L workstation. The results indicate that the network capabilities significantly influence the parallel efficiency, i. e., a shared memory machine is fastest and ATM networking provides acceptable performance. The limitations of ethernet greatly hamper the rapid calculation of flows using ALLSPD...|$|R
40|$|This paper {{presents}} scalability {{and communication}} performance results for {{a cluster of}} PCs running Linux with the GM communication library, a cluster of PCs running Windows NT with the HPVM communication library, a Cray T 3 E- 600, an IBM SP and a SGI Origin 2000. Both PC clusters were using a Myrinet network. Six communication tests using MPI routines were run {{for a variety of}} message sizes and numbers of <b>processors.</b> The <b>tests</b> wer...|$|R
40|$|In {{this paper}} a novel {{approach}} for injecting Single Event Upsets, (SEU), by means of direct memory access, (DMA), mechanisms is presented. The system consists in a PC based control unit that generates DMA requests randomly in time to a board containing the <b>processor</b> under <b>test,</b> and a test unit. Experimentation performed on a digital signal processor intended {{to be used in}} a satellite project illustrates the potentialities of the proposed approach...|$|R
40|$|Abstract:- In this paper, {{we present}} LODAP, a log data {{preprocessor}} which {{is able to}} extract user sessions starting from the requests stored in the log file of a Web site. LODAP is composed of several modules. A data cleaning module cleans the log file by removing useless records in order to retain only relevant requests encoding the user navigational behaviour. The data structuration module groups the remained requests in user sessions, by using a time-based method. Finally, the data filtering module considerably reduces the size of data concerning the extracted user sessions by deleting the least visited pages and the uninteresting sessions. In addition, a data summarization module creates reports which represent information summaries mined from the analyzed log file and containing the results provided by each module of LODAP. The implemented tool {{is characterized by a}} wizard-based interface which guides the analyst during the preprocessing of the log data through a sequence of “ panels”. Each panel is a graphical window which offers a basic functionality of the <b>processor.</b> <b>Tests</b> on the log files of a specific Web site show that the LODAP tool can effectively reduce the log dataset size and identify significant user sessions...|$|R
40|$|This thesis investigates and {{demonstrates}} the successful integration of object oriented approach with concurrent programming. It demonstrates that transputers coupled with virtual channels {{can provide an}} effective and efficient coarse grained object oriented programming environment. A methodology for concurrent object oriented design is developed and explained. This methodology is used to develop an application program using the virtual channel router, which mimics the transputer T 9000 and its virtual channel <b>processor.</b> <b>Testing</b> is then carried out to validate and demonstrate the working of the application developed. The design developed is thereafter mapped onto a programming environment wherein broadcast communication is used and mimics a shared memory model instead of point to point communication in a distributed memory model. This is first done using BSP Occam and then Occam 3. An assessment {{of the advantages of}} object orientation and parallel processing on transputer T 9000 is then concluded based on the research done during the design, implementation and testing stages. The thesis has validated that object oriented concepts can be successfully implemented on transputer - occam thereby achieving an efficient and effective medium grained parallel objects...|$|R
40|$|This is {{a journal}} paper {{published}} in IEEE Transactions on Computers[© IEEE]. It {{is also available}} at: [URL] Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must {{be obtained from the}} IEEE. This paper presents a detailed analysis of the behavior of a novel fault-tolerant 32 -bit embedded CPU as compared to a default (non-fault-tolerant) implementation of the same processor during a fault injection campaign of single and double faults. The fault-tolerant <b>processor</b> <b>tested</b> is characterized by per-cycle voting of microarchitectural and the flop-based architectural states, redundancy at the pipeline level, and a distributed voting scheme. Its fault-tolerant behavior is characterized for three different workloads from the automotive application domain. The study proposes statistical methods for both the single and dual fault injection campaigns and demonstrates the fault-tolerant capability of both processors in terms of fault latencies, the probability of fault manifestation, and the behavior of latent faults...|$|R
40|$|Software-Based Self-Test (SBST) is {{increasingly}} used for <b>testing</b> <b>processor</b> cores embedded in SoCs, mainly {{because it allows}} at-speed, low-cost testing, while requiring limited (if any) hardware modifications to the original design. However, the method requires effective techniques for generating suitable test programs and for monitoring the results. In the case of <b>processor</b> core <b>testing,</b> a particularly complex module to test is the cache controller, due to its limited accessibility and observability. In this {{paper we propose a}} hybrid methodology that exploits an Infrastructure Intellectual Property (I-IP) to complement an SBST algorithm for testing the data and instruction cache controllers of embedded processors in SoCs. In particular, the I-IP may be programmed to monitor the system buses and generate the appropriate feedback about the correct result of the executed programs (in terms of obtained hit or miss operations). The effectiveness of the proposed methodology is evaluated resorting to a sample SoC design. I...|$|R
40|$|Embedded test within {{integrated}} systems allows to overcome {{some of the}} difficulties found when testing using only an external tester. The reutilization of a reconfigurable FPGA-like block that may exist in certain SoC systems, enables the implementation of on-chip <b>test</b> <b>processors</b> highly optimized to meet the specific requirements of the test procedure for each block. The fast reconfiguration of SRAM-based FPGA blocks allows sharing the same physical area among the set of different circuits that {{may be necessary to}} implement the on-chip test suite of the whole system. This paper addresses the high level generation of specific programmable <b>processors</b> for <b>testing</b> different blocks within {{integrated systems}}, taking advantage of such existing programmable resources. The work presented herein proposes a methodology and a set of automation tools to enable the automatic generation of dedicated custom processor architectures for specific test operations, as well as the corresponding test programs. This facility can be seen as disposing of a highly flexible and optimised embedded tester, supplied as an intellectual property (IP) module and its software. The approach being proposed is based in the implementation of a <b>test</b> <b>processor</b> as an Application Specific Instruction-Set Processor (ASIP), whose set of conventional and dedicated instructions are automatically derived from a software specification of the test operation to be implemented. The actual configuration of the <b>test</b> <b>processor</b> is determined by the type of instructions the test designer uses in the test program. The processor¿s instruction set is configured automatically from the source code of the program to be run, in order to include only the exact instructions required for that task. The generation of a <b>test</b> <b>processor</b> starts with a software specification of the test operation to be performed. Presently, this specification is done using a program written in an assembly level language whose instruction set comprises all the general purpose instructions supported by the processor core, plus an extra set of complex instructions that are responsible for the operation of the peripheral specific blocks. From this specification, a custom programmable processor is generated as a set of synthesisable HDL modules, including the identification of peripheral blocks associated to specific instructions, and the set of constrains and assignments required to instantiate and map these modules onto the FPGA. These descriptions are then forwarded to the specific FPGA technology mapping and implementation tools, to create an application-specific processor that includes only the instructions referred in the source code...|$|R
3000|$|... [...]) is {{assigned}} to the sequencing cycles of each processor. The algorithm subsequently applies hypercube transformations as dictated {{by the type of}} matrix, the stage of matrix factorization and the number of dispatched <b>processors.</b> It <b>tests</b> optimality to determine the type of scan of matrix elements to be applied and evaluates parameters such as pitch and memory optimal queue length, to be defined subsequently, it accesses the pilot elements and their satellites, proceeding to the parallel dispatch and sequencing of the processing elements.|$|R
40|$|International audienceThe massive {{integration}} of several functionalities leads to increased test times/test data volume. Additionally, test content for more advanced fault models increase the tester memory requirements. On the positive side, {{the presence of}} many cores in a system provides the opportunity of core testing each other. In this paper we evaluate the opportunity to use AES crypto- <b>processors</b> as <b>test</b> pattern generators. Several experiences are conducted on LFSRs and AES cores in order to compare their ability to generate pseudo-random test sequences...|$|R
