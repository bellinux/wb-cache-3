79|145|Public
5000|$|The current <b>process</b> <b>ID</b> is {{provided}} by a [...] system call, or as a variable [...] in shell. The <b>process</b> <b>ID</b> of a parent process is obtainable by a [...] system call.|$|E
5000|$|Under Microsoft Windows {{operating}} systems, {{one can get}} {{the current}} process' ID using [...] API, and ID of other processes using [...] API. Internally, <b>process</b> <b>ID</b> is called a client ID, and is allocated from the same namespace as thread IDs, so these two never overlap. The so-called System Idle Process is given <b>process</b> <b>ID</b> 0, and System Process is given <b>process</b> <b>ID</b> 4. In some versions of Windows, process and thread identifiers are all multiples of 4, {{but it is not}} part of the specification.|$|E
5000|$|Under Linux, {{the maximum}} <b>process</b> <b>ID</b> {{is given by}} the pseudo-file [...]|$|E
5000|$|To display active TCP {{connections}} and the <b>process</b> <b>IDs</b> every 5 seconds, type the following command (works on NT based systems only, or Windows 2000 with hotfix): ...|$|R
5000|$|The AIX and Solaris {{versions}} of nohup have a [...] option that modifies a running process to ignore future SIGHUP signals. Unlike the above-described [...] builtin of bash, [...] accepts <b>process</b> <b>IDs.</b>|$|R
5000|$|The Unix command fuser {{is used to}} show which {{processes}} are using a specified file, file system, or unix socket. For example, to check <b>process</b> <b>IDs</b> and users accessing a USB drive:$ fuser -m -u /mnt/usb1/mnt/usb1: 1347c(root) 1348c(guido) 1349c(guido) ...|$|R
5000|$|... kill, which sends signals {{processes}} by <b>process</b> <b>ID</b> instead of by pattern-matching against the name.|$|E
5000|$|... {{each process}} knows its own <b>process</b> <b>id</b> and address, {{and that of}} every other process.|$|E
50|$|We {{can use the}} a SW Snapshot {{object of}} size n to {{construct}} a MWMR register. The linearization order is as follows. Order WRITE operations by t-values. If several WRITEs have the same t-value, order the operation with small <b>process</b> <b>ID</b> in front. Insert READs right after WRITE whose value they return, breaking ties by <b>process</b> <b>ID</b> and if still tied, break tie by start time.|$|E
40|$|Table S 1 : Explanation note: Supplementary {{metadata}} for specimens {{used for}} both morphological and genetic analyses; Museum and Sample IDs are specimen identifiers, BOLD <b>Process</b> <b>IDs</b> are unique codes automatically generated for each record on BOLD, GenBank Accession NOs represent sequence identifiers...|$|R
50|$|The {{sleep and}} displaysleep can show an imposed value of 0 (disabled) {{together}} {{with a list of}} <b>process</b> <b>IDs</b> that impose this value. These are processes such as backup programs which need the machine to stay awake, for example until the backup is finished.|$|R
50|$|Under Plan 9 from Bell Labs, {{the kill}} program does not {{actually}} perform this termination, {{nor does it}} take <b>process</b> <b>IDs.</b> Rather, it takes the actual names of processes and outputs the commands for rc, the shell used by Plan 9, to kill the process.|$|R
50|$|There are two tasks with {{specially}} distinguished process IDs: swapper or sched has <b>process</b> <b>ID</b> 0 and {{is responsible}} for paging, and is actually part of the kernel rather than a normal user-mode process. <b>Process</b> <b>ID</b> 1 is usually the init process primarily responsible for starting and shutting down the system. Originally, <b>process</b> <b>ID</b> 1 was not specifically reserved for init by any technical measures: it simply had this ID as a natural consequence {{of being the first}} process invoked by the kernel. More recent Unix systems typically have additional kernel components visible as 'processes', in which case PID 1 is actively reserved for the init process to maintain consistency with older systems.|$|E
5000|$|... pgrep is a {{command-line}} utility initially {{written for}} use with the Solaris 7 operating system by Mike Shapiro. It has since been available in illumos and reimplemented for the Linux and BSDs (DragonFly BSD, FreeBSD, NetBSD, and OpenBSD). It searches for all the named processes that can be specified as extended regular expression patterns, and—by default—returns their <b>process</b> <b>ID.</b> Alternatives include pidof (finds <b>process</b> <b>ID</b> given a program name) and ps.|$|E
5000|$|A {{process can}} be sent a SIGTERM signal in four ways (the <b>process</b> <b>ID</b> is '1234' in this case): ...|$|E
40|$|GUID: Arctos {{globally}} {{unique identifiers}} for the arthropod samples. Cluster label: illumina labels of centroid sequence clusters. Read count: cluster read counts. Process id: BOLD <b>process</b> <b>IDs</b> for matched database sequences. Similarity: similarity value from VSearch search. BIN: BOLD Barcode Index Numbers. Nucleotides: cluster centroid sequences...|$|R
50|$|Namespaces are {{a feature}} of the Linux kernel that isolate and {{virtualize}} system resources of a collection of processes. Examples of resources that can be virtualized include <b>process</b> <b>IDs,</b> hostnames, user IDs, network access, interprocess communication, and filesystems. Namespaces are a fundamental aspect of containers on Linux.|$|R
30|$|Equation (9) {{shows the}} {{principle}} of the <b>process</b> in <b>ID.</b>|$|R
5000|$|... pstree, for UNIX to {{find the}} child process (pstree PID, where PID is the <b>process</b> <b>id</b> of the process).|$|E
5000|$|Rubys global {{variables}} are distinguished by a [...] sigil. A number of predefined globals exist, for instance [...] {{is the current}} <b>process</b> <b>ID.</b>|$|E
5000|$|... if the token queue [...] is nonempty {{after this}} update, it pops a <b>process</b> <b>ID</b> [...] from [...] and sends the token to ...|$|E
5000|$|The {{system call}} [...] {{is used to}} create a new session {{containing}} a single (new) process group, with the current process as both the session leader and the process group leader of that single process group. Process groups are identified by a positive integer, the <b>process</b> group <b>ID,</b> which is the process identifier of the process that is (or was) the process group leader. Process groups need not necessarily have leaders, although they always begin with one. Sessions are identified by the <b>process</b> group <b>ID</b> of the session leader. POSIX prohibits the change of the <b>process</b> group <b>ID</b> of a session leader.|$|R
40|$|Sample {{information}} for specimens {{included in this}} study. : Explanation note: <b>Process</b> <b>IDs</b> are sequence identifiers in BOLD; Sample IDs are specimen identifiers; BINs are Barcode Identification Numbers in BOLD. Details of collecting data, images, sequences, and trace files for the barcoded specimens {{are available in the}} public BOLD dataset "DS-LECARY", accessed at dx. doi. org/ 10. 5883 /DS-LECARY...|$|R
50|$|Process Monitor {{monitors}} and records all actions attempted against the Microsoft Windows Registry. Process Monitor {{can be used}} to detect failed attempts to read and write registry keys. It also allows for filtering on specific keys, <b>processes,</b> <b>process</b> <b>IDs,</b> and values. In addition it shows how applications use files and DLLs, detects some critical errors in system files and more.|$|R
50|$|Task {{managers}} can display currently running services (processes) {{as well as}} those that were stopped. They can display information about the services (such as <b>Process</b> <b>ID</b> and group) if known.|$|E
5000|$|If P has {{the highest}} <b>process</b> <b>id,</b> it sends a Victory message to all other {{processes}} and becomes the new Coordinator. Otherwise, P broadcasts an Election message to all other processes with higher process IDs than itself.|$|E
50|$|In {{distributed}} computing, {{the bully}} algorithm {{is a method}} for dynamically electing a coordinator or leader {{from a group of}} distributed computer processes. The process with the highest <b>process</b> <b>ID</b> number from amongst the non-failed processes is selected as the coordinator.|$|E
5000|$|In Windows Vista and Windows 7, a [...] "Services" [...] tab in Windows Task Manager {{includes}} {{a list of}} services and their groups and <b>Process</b> <b>IDs</b> (PIDs); right-clicking on a svchost instance in the Task Manager and selecting [...] "Go to Services(s)" [...] also switches {{to the list of}} services and additionally selects the services running under the corresponding svchost instance.|$|R
50|$|Common {{resource}} handles are file descriptors, network sockets, database connections, process identifiers (PIDs), and job <b>IDs.</b> <b>Process</b> <b>IDs</b> and job IDs are explicitly visible integers, while file descriptors and sockets (which {{are often}} implemented {{as a form}} of file descriptor) are represented as integers, but are typically considered opaque. In traditional implementations, file descriptors are indices into a (per-process) file descriptor table, thence a (system-wide) file table.|$|R
50|$|The PID {{namespace}} provides processes with {{an independent}} set of <b>process</b> <b>IDs</b> (PIDs) from other namespaces. PID namespaces are nested, meaning {{when a new}} process is created {{it will have a}} PID for each namespace from its current namespace up to the initial PID namespace. Hence the initial PID namespace is able to see all processes, albeit with different PIDs than other namespaces will see processes with.|$|R
50|$|The doors {{system also}} {{provides}} a way for clients and servers to get information about each other. For example, a server can check the client's user credentials or <b>process</b> <b>ID</b> {{to decide whether the}} client is allowed to do something.|$|E
5000|$|In a {{multiprocess}} or multithreaded environment, {{it might}} be necessary to attach the <b>process</b> <b>ID</b> (PID) or any other unique ID to the timestamp {{so that it is}} possible to differentiate between events [...] and [...] which may occur simultaneously in different processes.|$|E
50|$|The page table {{holds the}} mapping between a virtual address of a page and {{the address of}} a {{physical}} frame. There is also auxiliary information about the page such as a present bit, a dirty or modified bit, address space or <b>process</b> <b>ID</b> information, amongst others.|$|E
5000|$|In Unix and Unix-like {{operating}} systems, [...] is {{a command}} {{used to send}} a signal to a process. By default, the message sent is the termination signal, which requests that the process exit. But kill {{is something of a}} misnomer; the signal sent may {{have nothing to do with}} process killing. The [...] command is a wrapper around the [...] system call, which sends signals to processes or process groups on the system, referenced by their numeric <b>process</b> <b>IDs</b> (PIDs) or <b>process</b> group <b>IDs</b> (PGIDs). [...] is always provided as a standalone utility as defined by the POSIX standard. However, most shells have built-in [...] commands that may slightly differ from it.|$|R
50|$|At the {{operating}} system level, many processes are pending at a time but the CPU can handle only one process at a single instance in time. Therefore, priorities are associated to each process. Then the processes are sent to the CPU according to the highest priority by using sorted array of <b>process</b> <b>IDs.</b> Here, <b>processes</b> got sorted depending upon their priorities and then CPU is allocated to them. The process having the highest priority takes first position in sorted array. Hence priority-wise system processes scheduling is done.|$|R
30|$|The Monitor Host Group (monitorHostGroup) stores {{information}} about monitored processes, including IP addresses (ipAddr), port numbers (portNumber), <b>process</b> <b>IDs</b> (processID), state (statusHost), number of false detections (falseDetection), heartbeat interval required (reqFreq), an {{estimation of the}} probabilistic behavior of message delays (V_D), message loss probability (P_L), QoS parameters (current_TD, current_TM and current_TMR) these parameters are continuously updated and are used to check whether any QoS requirement has been broken (e.g., current_TD >TD_U), among others. Objects of the monitorHostGroup trigger and execute process monitoring. For instance, they can start threads that receive heartbeat messages and compute timeouts.|$|R
