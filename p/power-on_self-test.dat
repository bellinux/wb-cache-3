34|0|Public
25|$|DDR3 memory utilises serial {{presence}} detect. Serial presence detect (SPD) is {{a standardized}} way to automatically access {{information about a}} computer memory module, using a serial interface. It is typically used during the <b>power-on</b> <b>self-test</b> for automatic configuration of memory modules.|$|E
2500|$|Unlike the IBM PC, {{which uses}} 8 kB of system ROM for <b>power-on</b> <b>self-test</b> (POST) and basic input/output system (BIOS), the Mac ROM is {{significantly}} larger (64 kB) and holds key OS code. Much {{of the original}} Mac ROM was coded by Andy Hertzfeld, {{a member of the}} original Macintosh team. He was able to conserve precious ROM space by writing routines in assembly language code optimized with [...] "hacks," [...] or clever programming tricks. In addition to the ROM, he also coded the kernel, the Macintosh Toolbox, and some of the desktop accessories (DAs). The icons of the operating system, which represent folders and application software, were designed by Susan Kare, who later designed the icons for Microsoft Windows 3.0. Bruce Horn and Steve Capps wrote the Macintosh Finder, {{as well as a number}} of Macintosh system utilities.|$|E
5000|$|... #Caption: IBM Personal System/2 Model 30 286. <b>Power-on</b> <b>self-test,</b> bootstrapping, {{power-off}} ...|$|E
50|$|There {{were other}} {{significant}} innovations in the Q-Bus lineup. For example, a system {{variant of the}} PDP-11/03 introduced full system <b>Power-on</b> <b>self-test</b> (POST).|$|E
5000|$|Access (preboot) {{hardware}} asset information, {{such as a}} component's {{manufacturer and}} model, which is updated every time the system goes through <b>power-on</b> <b>self-test</b> (POST).|$|E
50|$|A <b>power-on</b> <b>self-test</b> (POST) is {{a process}} {{performed}} by firmware or software routines immediately after a computer or other digital electronic device is powered on.|$|E
50|$|Simple {{standard}} diagnostic plug-in {{boards for}} computers are available that display numeric codes {{to assist in}} identifying issues detected during the <b>power-on</b> <b>self-test</b> executed automatically during system startup.|$|E
50|$|In computing, a POST card is a plug-in {{interface}} card that displays progress and error codes generated during <b>power-on</b> <b>self-test</b> (POST) of a computer. It {{is used to}} troubleshoot computers that do not start up.|$|E
50|$|DDR3 memory utilises serial {{presence}} detect. Serial presence detect (SPD) is {{a standardized}} way to automatically access {{information about a}} computer memory module, using a serial interface. It is typically used during the <b>power-on</b> <b>self-test</b> for automatic configuration of memory modules.|$|E
5000|$|Perform a {{hardware}} inventory by uploading the remote PC's hardware asset list (platform, baseboard management controller, BIOS, processor, memory, disks, portable batteries, field replaceable units, and other information). Hardware asset information is updated {{every time the}} system runs through <b>power-on</b> <b>self-test</b> (POST).|$|E
50|$|By {{pressing}} the Delete key during <b>power-on</b> <b>self-test</b> when a prompt is displayed, the BIOS setup utility program is invoked. Some earlier AMIBIOS versions {{also included a}} cut-down version of the AMIDIAG utility that AMI also sold separately, but most later AMI BIOSes do not include this program as the BIOS DMI already incorporates detailed diagnostics.|$|E
50|$|When an {{ordinary}} modern computer is turned on, it starts {{by doing a}} <b>power-on</b> <b>self-test</b> (POST). Since about the mid-1990s, this process includes automatically configuring the hardware currently present. SPD is a memory hardware feature {{that makes it possible}} for the computer to know what memory is present, and what timings to use to access the memory.|$|E
5000|$|Function Keys {{are also}} heavily {{used in the}} BIOS interface. Generally during the <b>power-on</b> <b>self-test,</b> BIOS access can be gained by hitting either a {{function}} key or the delete key. In the BIOS keys can have different purposes depending on the BIOS. However, [...] is the de facto standard for save and exit which saves all changes and restarts the system.|$|E
50|$|Some {{models of}} the Aspire One use an Intel 945GSE chipset which only {{supports}} 2 GB of RAM. Installing memory modules larger than 2 GB has caused the Aspire to fail the <b>power-on</b> <b>self-test.</b> Model 522, featuring the AMD Fusion C-50 chip, {{has been reported to}} work with 4 GB installed (although the included Windows 7 Starter edition has an artificially imposed 2 GB limit).|$|E
50|$|If {{the system}} has just been powered up or the reset button was pressed ("cold boot"), the full <b>power-on</b> <b>self-test</b> (POST) is run. If Ctrl+Alt+Delete was pressed ("warm boot"), a special flag value is stored in {{nonvolatile}} BIOS memory ("CMOS") before the processor is reset, and after the reset the BIOS startup code detects this flag and does not run the POST. This saves the time otherwise used to detect and test all memory.|$|E
5000|$|In some {{computer}} terminals, the ASCII {{character code}} 7, bell character, outputs an audible beep. The beep is also sometimes used {{to notify the}} user when the BIOS is not working or there is some other error during the start up process, often during the <b>power-on</b> <b>self-test</b> (POST). [...] A beep is also made when holding down too many keys at the same time, as the computer often cannot handle the processes.|$|E
5000|$|Windows 8 {{defaults}} to a [...] "hybrid boot" [...] mode; {{when the}} operating system is shut down, it hibernates the kernel, allowing for a faster boot on the subsequent startup. These improvements are further compounded by using all processor cores during startup by default. To create a more seamless transition between the <b>Power-on</b> <b>self-test</b> and Windows startup process, manufacturers' logos can now be shown on the Windows boot screen on compatible systems with UEFI.|$|E
50|$|Built-In-Self-Test {{is used to}} make faster, less-expensive {{integrated}} circuit manufacturing tests. The IC has a function that verifies all or {{a portion of the}} internal functionality of the IC. In some cases, this is valuable to customers, as well. For example, a BIST mechanism is provided in advanced fieldbus systems to verify functionality. At a high level this can be viewed similar to the PC BIOS's <b>power-on</b> <b>self-test</b> (POST) that performs a self-test of the RAM and buses on power-up.|$|E
50|$|During powerup, the BIOS {{firmware}} displays an ID string in the lower-left-hand {{corner of}} the screen. This ID string comprises various pieces {{of information about the}} firmware, including when it was compiled, what configuration options were selected, the OEM license code, and the targeted chipset and motherboard. There are 3 ID string formats, the first for older AMIBIOS, and the second and third for the newer AMI Hi-Flex ("high flexibility") BIOS. These latter are displayed when the Insert key is pressed during <b>power-on</b> <b>self-test.</b>|$|E
50|$|The ROM BIOS {{starts the}} {{execution}} at the physical memory address FFFF0h. During this phase, BIOS first executes <b>Power-on</b> <b>self-test</b> (POST), then checks {{the existence of}} boot disk on A drive. If it is {{not found in the}} A drive, the ROM BIOS checks for a hard disk. If the computer has a Plug and Play BIOS, in addition: BIOS checks RAM for I/O port addresses, interrupt lines, and DMA channels for Plug and Play devices, disables found devices, creates maps of used and unused resources and re-enables devices.|$|E
50|$|The system BIOS ROMs {{must be at}} {{the upper}} end of the address space because the CPU {{starting}} address is fixed by the design of the processor. The starting address is loaded into the program counter of the CPU after a hardware reset and must have a defined value that endures after power is interrupted to the system. On reset or power up, the CPU loads the address from the system ROM and then jumps to a defined ROM location to begin executing the system <b>power-on</b> <b>self-test,</b> and eventually load an operating system.|$|E
5000|$|Medical devices test {{themselves}} to assure their continued safety. Normally {{there are two}} tests. A <b>power-on</b> <b>self-test</b> (POST) will perform a comprehensive test. Then, a periodic test will assure that the device has not become unsafe since the power-on self test. Safety-critical devices normally define a [...] "safety interval", {{a period of time}} too short for injury to occur. The self test of the most critical functions normally is completed at least once per safety interval. The periodic test is normally a subset of the power-on self test.|$|E
50|$|On modern {{general purpose}} computers, the boot up process can take tens of seconds, or even minutes, and {{typically}} involves performing a <b>power-on</b> <b>self-test,</b> locating and initializing peripheral devices, and then finding, loading and starting an operating system. The process of hibernating or sleeping {{does not involve}} booting. Minimally, some embedded systems do not require a noticeable boot sequence to begin functioning and when turned on may simply run operational programs that are stored in ROM. All computing systems are state machines, and a reboot {{may be the only}} method to return to a designated zero-state from an unintended, locked state.|$|E
50|$|The {{boot process}} can be {{considered}} complete when the computer is ready {{to interact with the}} user, or the operating system is capable of running system programs or application programs. Typical modern personal computers boot in about one minute, of which about 15 seconds are taken by a <b>power-on</b> <b>self-test</b> (POST) and a preliminary boot loader, and the rest by loading the operating system and other software. Time spent after the operating system loading can be considerably shortened to as little as 3 seconds by bringing the system up with all cores at once, as with coreboot. Large servers may take several minutes to boot and start all their services.|$|E
50|$|Upon starting, an IBM-compatible {{personal}} computer's x86 CPU executes, in real mode, {{the instruction}} located at reset vector (the physical memory address FFFF0h on 16-bit x86 processors and FFFFFFF0h on 32-bit and 64-bit x86 processors), usually {{pointing to the}} BIOS entry point inside the ROM. This memory location typically contains a jump instruction that transfers execution {{to the location of}} the BIOS start-up program. This program runs a <b>power-on</b> <b>self-test</b> (POST) to check and initialize required devices such as DRAM and the PCI bus (including running embedded ROMs). The most complicated step is setting up DRAM over SPI, made more difficult by the fact that at this point memory is very limited.|$|E
5000|$|The PC {{speaker is}} used during <b>power-on</b> <b>self-test</b> (POST) {{sequence}} to indicate errors during the boot process. Since it is active before the graphics card, {{it can be}} used to communicate [...] "beep codes" [...] related to problems that prevent the much more complex initialization of the graphics card to take place. For example, the Video BIOS usually cannot activate a graphics card unless working RAM is present in the system, while beeping the speaker is doable with just ROM and the CPU registers. Usually, different error codes will be signaled by specific beeping patterns, such as e.g. [...] "one beep; pause; three beeps; pause; repeat". These patterns are specific to the BIOS manufacturer and are usually documented in the technical manual of the motherboard.|$|E
50|$|Most modern PCs {{store their}} {{recovery}} {{data on a}} hard drive partition rather than on bundled CD-ROMs or DVDs. Recovery partitions are typically accessed by using a specific key combination during or after the computer's <b>power-on</b> <b>self-test.</b> Recovery partitions carry advantages over disc-based solutions, including a faster recovery process (as the data is directly on the hard drive and no disc swapping is needed), and less cost to the OEM as {{they do not need}} to ship recovery media with the computer. However, if the hard drive fails, is fully reformatted, or is replaced, the recovery partition will be lost. Some third-party software, like AOMEI OneKey Recovery has the function to create a factory recovery partition and one key system backup and restore for Windows PC and Server.|$|E
5000|$|For example, on a PC with Windows XP {{installed}} on the hard drive, the user could set the boot order to the one given above, and then insert a Linux Live CD {{in order to try}} out Linux without having to install an operating system onto the hard drive. This is an example of dual booting, in which the user chooses which operating system to start after the computer has performed its <b>Power-on</b> <b>self-test</b> (POST). In this example of dual booting, the user chooses by inserting or removing the CD from the computer, but it is more common to choose which operating system to boot by selecting from a BIOS or UEFI boot menu, by using the computer keyboard; the boot menu is typically entered by pressing [...] or [...] keys during the POST.|$|E
5000|$|Unlike the IBM PC, {{which uses}} 8 kB of system ROM for <b>power-on</b> <b>self-test</b> (POST) and basic input/output system (BIOS), the Mac ROM is {{significantly}} larger (64 kB) and holds key OS code. Much {{of the original}} Mac ROM was coded by Andy Hertzfeld, {{a member of the}} original Macintosh team. He was able to conserve precious ROM space by writing routines in assembly language code optimized with [...] "hacks," [...] or clever programming tricks. In addition to the ROM, he also coded the kernel, the Macintosh Toolbox, and some of the desktop accessories (DAs). The icons of the operating system, which represent folders and application software, were designed by Susan Kare, who later designed the icons for Microsoft Windows 3.0. Bruce Horn and Steve Capps wrote the Macintosh Finder, {{as well as a number}} of Macintosh system utilities.|$|E
50|$|According to Jones, Landes, Tittel (2002), Cooper (2002), Tulloch (2002) and Soper (2004), on IBM PC {{compatible}} platform, a cold boot is a {{boot process}} in which the computer starts from a powerless state. All except Tulloch (2002) also mention that in cold boot, system performs a <b>power-on</b> <b>self-test</b> (POST). In addition to the power switch, Cooper (2002) and Soper (2004) also state that reset button may commence a cold reboot. Jones, Landes, Tittel (2002) contradicts this assertion and states that a reset button may commence either a cold or warm reboot, depending on the system. Microsoft Support article 102228 also confers that although the reset button is designed to perform a cold reboot, it may not disconnect the power to the motherboard - a state that does not correspond to the cold boot definition given above. According to Jones, Landes, Tittel (2002), both the operating system and third-party software can initiate a cold boot; the restart command in Windows 9x initiates a cold reboot, unless Shift key is held.|$|E
5000|$|The BIOS of the {{original}} IBM PC XT had no interactive user interface. Error codes or messages were displayed on the screen, or coded series of sounds were generated to signal errors when the <b>power-on</b> <b>self-test</b> (POST) had not proceeded {{to the point of}} successfully initializing a video display adapter. Options on the IBM PC and XT were set by switches and jumpers on the main board and on peripheral cards. Starting around the mid-1990s, it became typical for the BIOS ROM to include a [...] "BIOS configuration utility" [...] (BCU) or [...] "BIOS setup utility", accessed at system power-up by a particular key sequence. This program allowed the user to set system configuration options, of the type formerly set using DIP switches, through an interactive menu system controlled through the keyboard. In the interim period, IBM-compatible PCsincluding the IBM ATheld configuration settings in battery-backed RAM and used a bootable configuration program on disk, not in the ROM, to set the configuration options contained in this memory. The disk was supplied with the computer, and if it was lost the system settings could not be changed. The same applied in general to computers with an EISA bus, for which the configuration program was called an EISA Configuration Utility (ECU).|$|E
40|$|IEEE 1687 (IJTAG) {{has been}} {{developed}} to enable flexible and automated access to {{the increasing number of}} embedded instruments in today's integrated circuits. These instruments enable efficient post-silicon validation, debugging, wafer sort, package test, burn-in, bring-up and manufacturing test of printed circuit board assemblies, <b>power-on</b> <b>self-test,</b> and in-field test. Current paper presents an overview of challenges as well as selected examples in the following topics around IEEE 1687 networks: (1) design to efficiently access the embedded instruments, (2) verification to ensure correctness, and (3) fault management at functions performed in-field through the product's life time...|$|E
40|$|IEEE 1687 enables {{flexible}} {{access to}} the embedded (on-chip) instruments that are needed for post-silicon validation, debugging, wafer sort, package test, burn-in, printed circuit board bring-up, {{printed circuit board assembly}} manufacturing test, <b>power-on</b> <b>self-test,</b> and in-field test. At any of these scenarios, the instruments are accessed differently, and at a given scenario the instruments are accessed differently over time. It means the IEEE 1687 network needs to be frequently reconfigured from accessing one set of instruments to accessing a different set of instruments. Due to the need of frequent reconfiguration of the IEEE 1687 network it is important to (1) minimize the run-time for the algorithm finding the new reconfiguration, and (2) generate scan vectors with minimized access time. In this paper we model the reconfiguration problem using Boolean Satisfiability Problem (SAT). Compared to previous works we show significant reduction in run-time and we ensure minimal access time for the generated scan vectors...|$|E
40|$|It {{is common}} to embed {{instruments}} when developing integrated circuits (ICs). These instruments are accessed at post-silicon validation, debugging, wafer sort, package test, burn-in, printed circuit board bring-up, {{printed circuit board assembly}} manufacturing test, <b>power-on</b> <b>self-test,</b> and operator-driven in-field test. At any of these scenarios, it is of interest to access some but not all of the instruments. IEEE 1149. 1 - 2013 and IEEE 1687 propose Test Access Port based (TAP-based) mechanisms to design flexible scan networks such that any combination of instruments can be accessed from outside of the IC. Previous works optimize TAP-based scan networks for one scenario with a known number of accesses. However, at design time, it is difficult to foresee all needed scenarios and the exact number of accesses to instruments. Moreover, the number of accesses might change due to late design changes, addition/exclusion of tests, and changes of constraints. In this paper, we analyze and compare seven IEEE 1687 compatible network design approaches in terms of instrument access time, hardware overhead, and robustness. Given the similarities between IEEE 1149. 1 - 2013 and IEEE 1687, the conclusions are also applicable to IEEE 1149. 1 - 2013 networks...|$|E

