5|43|Public
40|$|In this paper, an {{efficient}} error {{analysis of a}} real-time vision-based pointing system is proposed. We use two cameras to implement the pointing system according to a sim-plified 3 D reconstruction scheme {{which is based on}} image feature extraction, homography, and 3 D geometry. To that end, we study the relationship between image noises and the ultimate reconstruction errors, and develop efficient methods to find the error range of the latter given a range of the former. Experimental results show that the proposed approach can find the error range satisfactorily. Accordingly, users of similar pointing systems can get more robust pointing results by selecting a special <b>pointer</b> <b>location,</b> or possibly a special pair of cameras, that will result in minimal range of pointing error...|$|E
40|$|Mixed Presence Groupware (MPG) {{supports}} both co-located {{and distributed}} participants working over a shared visual workspace. It does so by connecting multiple single-display groupware workspaces together through a shared data structure. Our implementation and observations of MPG systems exposes two problems: {{the first is}} display disparity, where connecting heterogeneous displays introduces issues in how people are seated around the workspace and how workspace artifacts are oriented; the second problem is presence disparity, where the perceived presence of collaborators is markedly different depending on whether they are co-located or remote. Presence disparity is likely caused by inadequate consequential communication between remote participants, which in turn disrupts group collaborative and communication dynamics. To mitigate display and presence disparity problems, we determine virtual seating positions and replace conventional telepointers with digital arm shadows that extend from a person’s {{side of the table}} to their <b>pointer</b> <b>location.</b> ACM Classification: H. 5. 3 (Groups and organizational interfaces – Computer supported cooperative work). 1...|$|E
40|$|Spatial Keyframing {{offers a}} {{compelling}} approach for interactive control of 3 D characters, as user motion directly controls {{the timing of}} an animated interpolation among a set of target poses [Igarashi et al. 2005]. In the original system, the user sets up a collection of target icons with associated character poses in a two dimensional control space that is overlaid with an interactive rendering of the 3 D character. Mouse <b>pointer</b> <b>location</b> in this control space defines a multi–target pose interpolation, allowing navigation to become a form of interactive character animation. We are investigating tech-niques for using 3 D control spaces (Figure 1), as the extra dimen-sion provides more freedom in terms of specifying motions among the target poses, similar to how 2 D control provides more poten-tial motions than a one–dimensional slider that transitions through a fixed sequence of poses. This presents control difficulties, how-ever, as mouse motion and traditional displays are inherently two...|$|E
50|$|Power users {{would often}} switch off the {{always-on}} menu, {{leaving it to}} be displayed at the mouse <b>pointer's</b> <b>location</b> when the right mouse button was pressed. The same implementation is used by GNUstep and conforming apps, though applications written for the host operating system or another toolkit will use the menu scheme appropriate to that OS or toolkit.|$|R
5000|$|... beginning: mov A,string <b>pointer</b> Put <b>location</b> {{of first}} {{character}} of source string in register A mov B,string <b>pointer</b> Put <b>location</b> of first character of destination string in register Bloop: movs B,A Copy 16 bytes at address in register A to address in register B, then increment A and B by 16 jnz loop If the zero flag isn't set then we haven't {{reached the end}} of the string, so go back and copy some more.end: If we didn't loop then we must have finished, so carry on with something else.|$|R
5000|$|... beginning: mov A,string <b>pointer</b> Put <b>location</b> {{of first}} {{character}} of source string in register A mov B,string <b>pointer</b> Put <b>location</b> of first character of destination string in register Bloop: mov C,A Copy byte at address in register A to register C mov B,C Copy byte in register C {{to the address}} in register B inc A Increment the address in register A {{to point to the}} next byte inc B Increment the address in register B to point to the next byte cmp C,#0 Compare the data we just copied to 0 (string end marker) jnz loop If it wasn't 0 then we have more to copy, so go back and copy the next byteend: If we didn't loop then we must have finished, so carry on with something else.|$|R
40|$|OPPS is a window-based {{graphics}} {{tool that}} provides easy and fast on-screen WYSIWYG editing capabilities. It has a canvas area which displays a full {{image of the}} schedule being edited. The canvas contains a header area (for text) and a schedule area (for plotting graphic representations of milestone objects in a flexible timeline). The OPPS tool is object-oriented, but it is unique in its capability for creating objects that have date attributes. Each object on the screen can {{be treated as a}} unit for moving, editing, etc. There is a mouse interface for simple control of <b>pointer</b> <b>location.</b> The user can position objects to pixel resolution, but objects with an associated date are positioned automatically in their correct timeline position in the schedule area. The schedule area has horizontal lines across the page with capabilities for multiple pages and for editing the number of lines per page and the line grid. The text on a line can be edited and a line can be moved with all objects on the line moving with it. The timeline display can be edited to plot any time period in a variety of formats from Fiscal Year to Calendar Year and days to years. Text objects and image objects (rasterfiles and icons) can be created for placement anywhere on the page. Milestone event objects with a single associated date (and optional text and milestone symbol) and activity objects with start and end dates (and an optional completion date) have unique editing panels for entering data. A representation for schedule slips is also provided. A milestone schedule can be saved to an ASCII file on another computer to be read by OPPS. The program can also print a schedule to a PostScript file. This program is not intended to replace a commercial scheduling/project management program. It does not provide the capability for defining dependencies between activities; dates must be provided manually. However, because OPPS has an ASCII file interface it can be used in conjunction with a project management tool to produce schedules with a quality appearance. OPPS is written in C-language and runs under Sunview on a Sun Workstation with SunOS 4. 0 or higher. Memory requirements are 375 K main memory and 1. 5 Mb free disk space. There is a binary included for Sun 4 computers. OPPS was developed in 1990 and version 2. 2 was released in 1991. OPPS is a copyrighted work with all copyright vested in NASA. SunOS, Sunview, and Sun 4 are trademarks of Sun Microsystems, Inc. Sun Workstation is a registered trademark of Sun Microsystems, Inc. PostScript is a trademark of Adobe Systems Incorporated...|$|E
40|$|XOPPS is a window-based {{graphics}} {{tool for}} scheduling and project planning that provides easy and fast on-screen WYSIWYG editing capabilities. It has a canvas area which displays the full {{image of the}} schedule being edited. The canvas contains a header area for text and a schedule area for plotting graphic representations of milestone objects in a flexible timeline. XOPPS is object-oriented, but it is unique in its capability for creating objects that have date attributes. Each object on the screen can {{be treated as a}} unit for moving, editing, etc. There is a mouse interface for simple control of <b>pointer</b> <b>location.</b> The user can position objects to pixel resolution, but objects with an associated date are positioned automatically in their correct timeline position in the schedule area. The schedule area has horizontal lines across the page with capabilities for multiple pages and for editing the number of lines per page and the line grid. The text on a line can be edited and a line can be moved with all objects on the line moving with it. The timeline display can be edited to plot any time period in a variety of formats from Fiscal year to Calendar Year and days to years. Text objects and image objects (rasterfiles and icons) can be created for placement anywhere on the page. Milestone event objects with a single associated date (and optional text and milestone symbol) and activity objects with start and end dates (and an optional completion date) have unique editing panels for entering data. A representation for schedule slips is also provided with the capability to automatically convert a milestone event to a slip. A milestone schedule on another computer can be saved to an ASCII file to be read by XOPPS. The program can print a schedule to a PostScript file. Dependencies between objects can also be displayed on the chart through the use of precedence lines. This program is not intended to replace a commercial scheduling/project management program. Because XOPPS has an ASCII file interface it can be used in conjunction with a project management tool to produce schedules with a quality appearance. XOPPS is written in C-language for Sun series workstations running SunOS. This package requires MIT's X Window System, Version 11 Revision 4, with OSF/Motif 1. 1. A sample executable is included. XOPPS requires 375 K main memory and 1. 5 Mb free disk space for execution. The standard distribution medium is a. 25 inch streaming magnetic tape cartridge in UNIX tar format. XOPPS was developed in 1992, based on the Sunview version of OPPS (NPO- 18439) developed in 1990. It is a copyrighted work with all copyright vested in NASA...|$|E
40|$|Garbage {{collection}} {{tables for}} finding pointers on the stack {{can be represented}} in 20 - 25 % of the space previously reported. Live pointer information is often the same at many call sites because there are few pointers live across most call sites. This allows live pointer information to be represented compactly by a small index into a table of descriptions of <b>pointer</b> <b>locations.</b> The mapping from program counter values to those small indexes can be represented compactly using several techniques. The techniques all assign numbers to call sites and use those numbers to index an array of small indexes. One technique is to represent an array of return addresses by using a two-level table with 16 -bit offsets. Another technique {{is to use a}} sparse array of return addresses and interpolate the exact number via disassembly of the executable code. 1...|$|R
5000|$|Sends the FS-Zone1 and FS-Zone2 data {{containing}} imported <b>pointers</b> to the <b>location</b> of {{the root}} directory as recorded in the last active Primary Volume Descriptor ...|$|R
50|$|Another way {{to defer}} {{reclamation}} {{is to use}} one or more hazard pointers, which are <b>pointers</b> to <b>locations</b> that otherwise cannot appear in the list. Each hazard pointer represents an intermediate state of an in-progress change; {{the presence of the}} pointer assures further synchronization Lea. Hazard pointers are lock-free, but can only track at most two elements for being in-use.|$|R
50|$|The {{locations}} {{of all other}} fields in the frame can be defined relative either {{to the top of}} the frame, as negative offsets of the stack pointer, or relative {{to the top of the}} frame below, as positive offsets of the frame <b>pointer.</b> The <b>location</b> of the frame pointer itself must inherently be defined as a negative offset of the stack pointer.|$|R
5000|$|... a <b>pointer</b> to the <b>location</b> {{in memory}} where the array {{elements}} begin (this is normally {{identical to the}} location of the first (or zeroeth) element of the array, and the rest follow contiguously).|$|R
5000|$|Indirect {{threading}} uses <b>pointers</b> to <b>locations</b> {{that in turn}} {{point to}} machine code. The indirect pointer may be followed by operands which are stored in the indirect [...] "block" [...] rather than storing them repeatedly in the thread. Thus, indirect code is often more compact than direct-threaded code, but the indirection also typically makes it slower, though still usually faster than bytecode interpreters. Where the handler operands include both values and types, the space savings over direct-threaded code may be significant. Older FORTH systems typically produce indirect-threaded code.|$|R
25|$|The first {{reserved}} sector (logical sector 0) is the Boot Sector (also called Volume Boot Record {{or simply}} VBR). It includes an area called the BIOS Parameter Block (BPB) which contains some basic file system information, in particular its type and <b>pointers</b> to the <b>location</b> {{of the other}} sections, and usually contains the operating system's boot loader code.|$|R
40|$|Program {{understanding}} {{activities are}} more difficult for programs written in languages (such as C) that heavily make use of pointers for data structure manipulation, because the programmer needs to build a mental model of the memory use and of the <b>pointers</b> to its <b>locations.</b> <b>Pointers</b> also pose additional problems to the tools supporting program understanding, since they introduce additional dependences {{that have to be}} accounted for. This paper extends the flow insensitive context insensitive points-to analysis algorithm proposed by Steensgaard, to cover arbitrary combinations of pointer dereferences, array subscripts and field selections. It exhibits interesting properties, among which scalability resulting from the low complexity and good performances. The results of the analysis are valuable by themselves, as their graphical display represents the points-to links between locations. They are also integrated with other program understanding techniques like, e. g., call graph construction, slicing, plan recognition and architectural recovery. The use of this algorithm in the framework of the program understanding environment CANTO is discussed...|$|R
40|$|Much {{work has}} been done on the {{development}} of laser pointers as interaction devices. Typically a camera captures images of a display surface and extracts a laser <b>pointer</b> dot <b>location.</b> This location is processed and used as a cursor position. Little of this work, however, has been aimed at the practical details of implementing such a system. We discuss the design of such a tracking system, focusing on key practical implementation details. In particular we present a robust and efficient dot detection algorithm that allows us to use our system under a variety lighting conditions, and allows us {{to reduce the amount of}} image parsing required to find a laser position by an order of magnitude...|$|R
50|$|Ink is a 2009 American {{science fiction}} fantasy film, written and {{directed}} by Jamin Winans, starring Chris Kelly, Quinn Hunchar and Jessica Duffy. It was produced by Winans's own independent production company, Double Edge Films, with Kiowa K. Winans, and shot by cinematographer Jeff <b>Pointer</b> in <b>locations</b> around Denver, Colorado. The film premiered at the Santa Barbara International Film Festival on January 23, 2009, and has screened in Denver, the Cancun Film Festival (where it won the Best International Feature award), Rams Head Onstage in Baltimore and in a number of independent movie houses in cities around the US. The film was widely circulated in peer-to-peer networks, which led to its commercial success.|$|R
50|$|Once {{a device}} has {{established}} an IP address, {{the next step}} in UPnP networking is discovery. The UPnP discovery protocol is known as the Simple Service Discovery Protocol (SSDP). When a device is added to the network, SSDP allows that device to advertise its services to control points on the network. This is achieved by sending SSDP alive messages. When a control point is added to the network, SSDP allows that control point to actively search for devices of interest on the network or listen passively to the SSDP alive messages of device. The fundamental exchange is a discovery message containing a few essential specifics about the device or one of its services, for example, its type, identifier, and a <b>pointer</b> (network <b>location)</b> to more detailed information.|$|R
50|$|All of {{the items}} are linked in a single list (or array) of <b>pointers</b> to memory <b>locations,</b> and are stored in RAM. Each address in an array points to an {{individual}} line in the memory. That line is then returned if it is similar to other lines. Neurons are utilized as address decoders and encoders, {{similar to the way}} neurons work in the brain, and return items from the array that match or are similar.|$|R
40|$|Abstract. Pointer {{information}} {{is a prerequisite}} for most program analyses, and inclusion-based, i. e. Andersen-style, pointer analysis is widely used to compute such information. However, current inclusion-based analyses can have prohibitive costs in time and space, especially for programs with millions of lines of code. We present a suite of offline optimizations that exploit <b>pointer</b> and <b>location</b> equivalence to shrink the input to the subsequent pointer analysis without affecting precision, dramatically reducing both analysis time and memory consumption. Using a suite of six open-source C programs ranging in size from 169 K to 2. 17 M LOC, we demonstrate that our techniques on average improve analysis time by 1. 3 – 2. 7 × and reduce memory consumption by 3. 2 – 6. 9 × over the best current techniques. ...|$|R
40|$|In this work, {{we present}} a {{hardware}} implementation of the encryption algorithm YAEA. The basic notion behind this encryption technique is a sequential search in a random binary file for an octet that represents the ASCII number of the plain-text character. Recording the location of this octet, one is able to assemble a file of near or far <b>pointers</b> to the <b>locations</b> of various octets. Rather inaccurately, we call this file the ciphered text. However, this file contains only <b>pointers</b> to the <b>locations</b> of the searched octets. Since there is negligible correlation between the pointer file and the plain-text characters, the method, we believe, is robust against any type of cipher attacks. The hardware implementation utilizes Field Programmable Gate Array Technology (FPGA) and the hardware description language VHDL to conclude the realization. The basic micro-architecture of the encryption processor consists of a random binary number generator, an encryption-processing unit and a specially designed sequential memory unit. Furthermore, we demonstrate the results of various performance tests that we have carried out on the architecture. These tests were performed taking into considerations certain real-time applications. KEYWORDS...|$|R
40|$|A {{method for}} using dual indices to support query expansion, relevance/non-relevance models, blind/relevance {{feedback}} and an intelligent search interface, the method comprising: accessing an inverted index {{to obtain an}} initial retrieval of results {{in response to a}} query, and to generate a rank list of the results, the results referring to information units (IUs) where the query occurs; and determining a number of "N" IUs in the results that are assumed to be relevant by accessing a forward index; wherein the forward index and inverted index have <b>pointers</b> to <b>locations</b> in the IUs where terms of the query occur, and the forward index retrieves a term frequency vector of the IU or a set of contexts of the IU. Department of ComputingUS 8775410; US 8775410 B 2; US 8775410 B 2; US 8, 775, 410; US 8, 775, 410 B 2; 8775410; Appl. No. 14 / 137, 150 U...|$|R
40|$|Abstract. Array-Range Analysis computes at compile {{time the}} range of {{possible}} index values for each array-index expression in a program. This information {{can be used to}} detect potential out-of-bounds array accesses and to identify non-aliasing array accesses. In a language like C, where arrays can be accessed indirectly via pointers, and where pointer arithmetic is allowed, range analysis must be extended to compute {{the range of}} possible values for each pointer dereference. This paper describes a Pointer-Range Analysis algorithm that computes a safe approximation of the set of memory locations that may be accessed by each pointer dereference. To properly account for non-trivial aspects of C, including pointer arithmetic and type-casting, a range representation is described that separates the identity of a <b>pointer’s</b> target <b>location</b> from its type; this separation allows a concise representation of pointers to multiple arrays, and precise handling of mismatched-type pointer arithmetic. ...|$|R
40|$|This paper {{proposes a}} hybrid {{approach}} to enhanced data security using special matrices {{in conjunction with}} Steganography. The special matrices are used for mapping the actual characters to numbers which are actually <b>pointers</b> to the <b>location</b> {{of the characters in}} the matrices. The generated numbers corresponding to each character of the message are embedded in the image pixels at the least significant bit position prior to transmission. The change of LSB values of the image pixels do not distort the image significantly, allowing for undetected transmission of any message to its intended receiver...|$|R
50|$|In an {{inverted}} file or inverted index, {{the contents of}} the data are used as keys in a lookup table, and the values in the table are <b>pointers</b> to the <b>location</b> of each instance of a given content item. This is also the logical structure of contemporary database indexes, which might only use the contents from a particular columns in the lookup table. The inverted file data model can put indexes in a second set of files next to existing flat database files, in order to efficiently directly access needed records in these files.|$|R
50|$|The primary {{trade-off}} {{being made}} in using a semi-structured database model is that queries cannot be made as efficiently as in a more constrained structure, {{such as in the}} relational model. Typically the records in a semi-structured database are stored with unique IDs that are referenced with <b>pointers</b> to their <b>location</b> on disk. This makes navigational or path-based queries quite efficient, but for doing searches over many records (as is typical in SQL), it is not as efficient because it has to seek around the disk following pointers.|$|R
50|$|The 1851 census {{is seen as}} one of the key {{sources for}} British genealogical {{research}} of the nineteenth century. The information about the relationship of individuals to the head of household enables relationships between people to be established accurately. Furthermore, the inclusion of exact ages and details of each person's place of birth, provides the researcher with a <b>pointer</b> to the <b>location</b> of birth or baptism records. In many cases, this allows the researcher to pin-down the parish of birth with relative ease: in other cases, the situation is not so simple.|$|R
5000|$|In {{computer}} science, a pointer is a {{programming language}} object, whose value refers to (or [...] "points to") another value stored elsewhere in the computer memory using its memory address. A <b>pointer</b> references a <b>location</b> in memory, and obtaining the value stored at that location is known as dereferencing the pointer. As an analogy, a page number in a book's index {{could be considered a}} pointer to the corresponding page; dereferencing such a pointer would be done by flipping to the page with the given page number and reading the text found on the indexed page.|$|R
5000|$|The {{standard}} way {{of implementing}} lists, originating with the programming language Lisp, {{is to have}} each element of the list contain both its value and a <b>pointer</b> indicating the <b>location</b> of the next element in the list. This results in either a linked list or a tree, {{depending on whether the}} list has nested sublists. Some older Lisp implementations (such as the Lisp implementation of the Symbolics 3600) also supported [...] "compressed lists" [...] (using CDR coding) which had a special internal representation (invisible to the user). Lists can be manipulated using iteration or recursion. The former is often preferred in imperative programming languages, while the latter is the norm in functional languages.|$|R
30|$|For {{clarity of}} explanation, {{a group of}} 3 {{butterfly}} stages will {{be defined as a}} Set as shown in Figure 10. After Set 1 and 2, the 8 outputs of each thread are locally 8 -bit, bit reversed like that of an 8 -point FFT, but the outputs of Set 3 are globally, 512 -bit, bit reversed. The simplest method of storing the computed data from Sets 1 and 2 in shared memory was to use similarly bit reversed <b>location</b> <b>pointers</b> so as to store data back in ordered form. In order to achieve this, a point of reference for the data was required. Throughout computation all data access was referenced relative to its original location in the input data.|$|R
40|$|We {{investigated}} how conceptually informative (referent preview) and conceptually uninformative (<b>pointer</b> to referent’s <b>location)</b> {{visual cues}} affect structural choice during English transitive sentence production. Cueing the Agent or the Patient prior to presenting the target event reliably predicted {{the likelihood of}} selecting this referent as the sentential Subject, triggering, correspondingly, the choice between active and passive voice. Importantly, {{there was no difference}} in the magnitude of the general Cueing effect between the informative and uninformative cueing conditions, suggesting that attentionally driven structural selection relies on a direct automatic mapping mechanism from attentional focus to the Subject’s position in a sentence. This mechanism is, therefore, independent of accessing semantic, and possibly lexical, information about the cued referent provided by referent preview...|$|R
40|$|AbstractÐFor a PCS {{network to}} {{effectively}} deliver services to its mobile users, {{it must have}} {{an efficient way to}} keep track of the mobile users. The location management fulfills this task through location registration and paging. To reduce the signaling traffic, many schemes such as Local Anchor (LA) scheme, per-user caching scheme and pointer forwarding scheme have been proposed in the past. In this paper, we present a new location management scheme which intends to mitigate the signaling traffic as well as reduce the tracking delay in the PCS systems. In this strategy, we choose a set of VLRs traversed by users as the Mobility Agents (MA), which form another level of management in order to make some registration signaling traffic localized. The idea is as follows: Instead of always updating to the HLR, which would become the bottleneck otherwise, many location updates are carried out in the mobility agents. Thus, the two-level pointer forwarding scheme is designed to reduce the signaling traffic: Pointers can be set up between VLRs as the traditional pointer forwarding scheme and can also be set up between MAs. The numerical results show that this strategy can significantly reduce the network signaling traffic for users with low CMR without increasing much of the call setup delay. Index TermsÐPCS networks, mobility management, <b>pointer</b> forwarding, <b>location</b> management. æ...|$|R
40|$|Real world {{programs}} (in languages like C) heavily {{make use}} of pointers. Program understanding activities are thus made more difficult, since pointers affect the memory locations that are referenced in a statement, and also the functions called by a statement, when function pointers are used. The programmer needs to build a mental model of the memory use and of the <b>pointers</b> to its <b>locations,</b> in order to comprehend the functionalities of the system. This paper presents an efficient flow insensitive context insensitive points-to analysis algorithm capable {{of dealing with the}} features of the C code. It is extremely promising with regard to scalability, because of the low complexity. The results are valuable by themselves, as their graphical display represents the pointsto links between locations. They are also integrated with other program understanding techniques like, e. g., call graph construction, slicing, plan recognition and architectural recovery. ...|$|R
40|$|Abstract—This paper {{introduces}} a dynamic hierarchical database architecture for location management in personal communications service (PCS) networks. The proposed scheme allows the dynamic adjustments of user location information distribution {{based on the}} mobility and calling patterns of the mobile terminals (MT’s). A unique distribution strategy is determined for each MT, and <b>location</b> <b>pointers</b> are set up at selected remote locations which indicate the current location of the MT’s. This method effectively reduces the signaling and database access overhead for location registration and call delivery. Besides, the required processing is handled by a distributed network of directory registers and centralized coordination is not necessary. The functions of the other network elements, such as the home location register (HLR) and the visitor location registers (VLR’s), remain primarily unchanged. This greatly facilitates the deployment of this scheme in current PCS networks. Index Terms—Call delivery, directory register, home location register (HLR), location registration, visitor location register (VLR). I...|$|R
40|$|In {{this paper}} we study an {{important}} problem in multimedia database, namely, the automatic extraction of indexing information from raw data based on video contents. The goal {{of our research}} project {{is to develop a}} prototype system for automatic indexing of sports videos. The novelty of our work is that we propose to integrate speech understanding and image analysis algorithms for extracting information. The main thrust of this work comes from the observation that in news or sports video indexing, usually speech analysis is more efficient in detecting events than image analysis. Therefore, in our system, the audio processing modules are first applied to locate candidates in the whole data. This information is passed to the video processing modules, which further analyze the video. The final products of video analysis are in the form of <b>pointers</b> to the <b>locations</b> of interesting events in a video. Our algorithms have been tested extensively with real TV programs, and results are presented a [...] ...|$|R
