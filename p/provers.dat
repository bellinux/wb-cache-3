2350|4240|Public
25|$|Examples of {{knowledge}} representation formalisms include semantic nets, systems architecture, frames, rules, and ontologies. Examples of automated reasoning engines include inference engines, theorem <b>provers,</b> and classifiers.|$|E
25|$|Most purely {{functional}} programming languages (notably Miranda and its descendents, including Haskell), and the proof languages of theorem <b>provers,</b> use lazy evaluation, {{which is essentially}} the same as call by need. This is like normal order reduction, but call by need manages to avoid the duplication of work inherent in normal order reduction using sharing. In the example given above, (λx.xx) ((λx.x)y) reduces to ((λx.x)y) ((λx.x)y), which has two redexes, but in call by need they are represented using the same object rather than copied, so when one is reduced the other is too.|$|E
2500|$|Automated theorem <b>provers</b> {{are also}} used to {{implement}} formal verification in computer science. [...] In this setting, theorem <b>provers</b> are used to verify the correctness of programs and of hardware such as processors {{with respect to a}} formal specification. Because such analysis is time-consuming and thus expensive, it is usually reserved for projects in which a malfunction would have grave human or financial consequences.|$|E
40|$|Abstract. Watson is a {{general-purpose}} {{system for}} formal reasoning. It is an interactive equational higher-order theorem <b>prover.</b> The higher-order logic {{supported by the}} <b>prover</b> is distinctive in being type free (it is a safe variant of Quine’s NF). Watson allows the development of automated proof strategies, which are represented and stored by the <b>prover</b> {{in the same way}} as theorems. The mathematical foundations of the <b>prover</b> and the way these are presented to a user are discussed. The paper also contains discussions of experiences with the <b>prover</b> and relations of the <b>prover</b> to other systems...|$|R
40|$|Terrorist Fraud: Here the dishonest <b>prover</b> {{provides}} some limited {{help to the}} adversary, such that the adversary is able to authenticate to the honest verifier. However, the <b>prover</b> should not forward any information that allows the adversary to authenticate without the <b>prover's</b> help. Intuitively, a terrorist fraud attack is successful if the adversary is successful in authenticating with the <b>prover's</b> help, but not without it.|$|R
40|$|Abstract. We have {{developed}} an automated con uence <b>prover</b> for term rewriting systems (TRSs). This paper presents theoretical and technical ingredients {{that have been used}} in our <b>prover.</b> A distinctive feature of our <b>prover</b> is incorporation of several divide{and{conquer criteria such as those for commutative (Toyama, 1988), layer-preserving (Ohlebusch, 1994) and persistent (Aoto & Toyama, 1997) combinations. For a TRS to which direct con uence criteria do not apply, the <b>prover</b> decomposes it into components and tries to apply direct con uence criteria to each component. Then the <b>prover</b> combines these results to infer the (non-) con uence of the whole system. To the best of our knowledge, an auto-mated con uence <b>prover</b> based on such an approach has been unknown. ...|$|R
2500|$|The {{programming}} language Prolog [...] {{was developed in}} 1972 by Alain Colmerauer. It emerged from a collaboration between Colmerauer in Marseille and Robert Kowalski in Edinburgh. Colmerauer was working on natural language understanding, using logic to represent semantics and using resolution for question-answering. During the summer of 1971, Colmerauer and Kowalski discovered that the clausal form of logic {{could be used to}} represent formal grammars and that resolution theorem <b>provers</b> could be used for parsing. They observed that some theorem <b>provers,</b> like hyper-resolution, behave as bottom-up parsers and others, like SL-resolution (1971), behave as top-down parsers.|$|E
2500|$|The related area of {{automated}} proof verification uses {{computer programs}} {{to check that}} human-created proofs are correct. [...] Unlike complicated automated theorem <b>provers,</b> verification systems may be small enough that their correctness can be checked both by hand and through automated software verification. This validation of the proof verifier is needed to give confidence that any derivation labeled as [...] "correct" [...] is actually correct.|$|E
2500|$|Thus, {{a subset}} of FOL can be both easier to use and more {{practical}} to implement. This was a driving motivation behind rule-based expert systems. IF-THEN rules provide {{a subset of}} FOL but a very useful one that is also very intuitive. [...] The history {{of most of the}} early AI knowledge representation formalisms; from databases to semantic nets to theorem <b>provers</b> and production systems can be viewed as various design decisions on whether to emphasize expressive power or computability and efficiency.|$|E
50|$|Nqthm is a theorem <b>prover</b> {{sometimes}} referred to as the Boyer-Moore theorem <b>prover.</b> It was a precursor to ACL2.|$|R
40|$|We {{extend a}} {{previously}} proposed symbolic model transformation property <b>prover</b> for the DSLTrans transformation language. The original <b>prover</b> generated {{the set of}} path conditions (i. e., symbolic transformation executions), and verified atomic contracts (constraints on input-output model relations) on these path conditions. The <b>prover</b> evaluated atomic contracts to yield either true or false for the transformation when run on any input model. In this paper we extend the <b>prover</b> such that it can verify atomic contracts and more complex properties composed of atomic contracts. Besides demonstrating our <b>prover</b> on a simple transformation, we use it to verify different kinds of properties of an industrial transformation. Experiments on this transformation using our <b>prover</b> show a speed-up in verification run-time by two orders of magnitude over another verification tool that we evaluated in previous research...|$|R
40|$|We {{present the}} first {{implementation}} of a theorem <b>prover</b> which runs on a smart card. The <b>prover</b> is written in Java and implements a dual tableau calculus. Due to the limited resources available on current smart cards, the <b>prover</b> is restricted to propositional classical logic. It can be easily extended to full first-order logic. The potential applications for our <b>prover</b> lie {{within the context of}} security related functions based on trusted devices such as smart cards...|$|R
50|$|Under the hood, GNATprove {{uses the}} Why3 {{intermediate}} language and VC Generator, and the CVC4, Z3, and Alt-Ergo theorem <b>provers</b> to discharge VCs. Use of other <b>provers</b> (including interactive proof checkers) {{is also possible}} through other components of the Why3 toolset.|$|E
50|$|While {{somewhat}} {{eclipsed by}} attention to and progress in Resolutiontheorem <b>provers,</b> Model Elimination {{has continued to}} attract theattention of researchers and software developers. Today there are several theorem <b>provers</b> under active development {{that are based on}} the Model Elimination procedure.|$|E
50|$|Theorem <b>provers</b> use {{automated}} reasoning {{techniques to}} determine proofs of mathematical theorems. They {{may also be}} used to verify existing proofs. In addition to academic use, typical applications of theorem <b>provers</b> include verification of the correctness of integrated circuits, software programs, engineering designs, etc.|$|E
40|$|Abstract. In {{this paper}} {{we present a}} theorem <b>prover</b> called CondLean for normal propositional {{conditional}} logics CK, CK+ID, CK+MP and CK+MP+ID. The theorem <b>prover</b> implements some sequent calculi for these logics recently introduced. The theorem <b>prover</b> is delveloped following the methodology of Lean-TAP and it is implemented in SICStus Prolog. The theorem <b>prover</b> also comprises a graphical user interface implemented in JAVA language. CondLean can be downloaded at the site www. di. unito. it/ ~ olivetti/CONDLEAN/...|$|R
50|$|Prover9 is an {{automated}} theorem <b>prover</b> for First-order and equational logic developed by William McCune. Prover9 is the successor of the Otter theorem <b>prover.</b>|$|R
40|$|We present Leo, a {{resolution}} based theorem <b>prover</b> for classical higher-order logic. It {{can be employed}} as both an fully automated theorem <b>prover</b> and an interactive theorem <b>prover.</b> Leo has been implemented {{as part of the}} Ωmega environment [23] and has been integrated with the Ωmega proof assistant. Higher-order resolution proofs developed with Leo can be displayed and communicated to the user via Ωmega’s graphical user interface Loui. The Leo system has recently been successfully coupled with a first-order resolution theorem <b>prover</b> (Bliksem) ...|$|R
50|$|A quantum {{interactive}} proof {{with two}} competing <b>provers</b> is a generalization {{of the single}} prover quantum interactive proof system. It can be modelled by zero-sum refereed games where Alice and Bob are the competing <b>provers,</b> and the referee is the verifier. The referee {{is assumed to be}} computationally bounded (polynomial size quantum circuit), whereas Alice and Bob can be computationally unrestricted. Alice, Bob and the referee receive a common string, and after fixed rounds of interactions (exchanging quantum information between the <b>provers</b> and the referee), the referee decides whether Alice wins or Bob wins.|$|E
5000|$|... #Subtitle level 2: Quantum Interactive Proof with Competing <b>Provers</b> ...|$|E
5000|$|Water Draws, LLC is a pipe prover {{calibrating}} company. They {{trouble shoot}} and repair pipe <b>provers</b> also. They design pipe <b>provers</b> for accurate flow rate and meter size positive displacement or turbine meters. Water Draws, LLC service the pipe {{industry in the}} Gulf of Mexico and throughout the United States. http://waterdrawsllc.com/index.html ...|$|E
40|$|Summary. In {{this paper}} we present an eective <b>prover</b> for mbC, a minimal in-consistency logic. The mbC logic is a paraconsistent {{logic of the}} family of logics of formal inconsistency. Paraconsistent logics have several {{philosophical}} motivations as well as many applications in Articial Intelligence such as in belief revision, inconsis-tent knowledge reasoning, and logic programming. We have implemented the KEMS <b>prover</b> for mbC, a theorem <b>prover</b> based on the KE tableau method for mbC. We show here that the proof system on which this <b>prover</b> is based is sound, complete and analytic. To evaluate the KEMS <b>prover</b> for mbC, we devised four families of mbC-valid formulas and we present here the rst benchmark results using these families. ...|$|R
40|$|AbstractIn {{presenting}} specifications and specification {{properties to}} a theorem <b>prover,</b> {{there is a}} tension between convenience for the user and convenience for the theorem <b>prover.</b> A choice of specification formulation that is most natural to a user {{may not be the}} ideal formulation for reasoning about that specification in a theorem <b>prover.</b> However, when the theorem <b>prover</b> is being integrated into a system development framework, a desirable goal of the integration is {{to make use of the}} theorem <b>prover</b> as easy as possible for the user. In such a context, it is possible to have the best of both worlds: specifications that are natural for a system developer to write in the language of the development framework, and representations of these specifications that are well matched to the reasoning techniques provided in the <b>prover.</b> In a tactic-based <b>prover,</b> these reasoning techniques include the use of tactics (or strategies) that can rely on certain structural elements in the theorem <b>prover's</b> representation of specifications. This paper illustrates how translation techniques used in integrating PVS into the TIOA (Timed Input/Output Automata) system development framework produce PVS specifications structured to support development of PVS strategies that implement reasoning steps appropriate for proving TIOA specification properties...|$|R
40|$|We {{describe}} the superposition-based theorem <b>prover</b> E. E {{is a sound}} and complete <b>prover</b> for clausal first order logic with equality. Important properties of the <b>prover</b> include strong redundancy elimination criteria, the DISCOUNT loop proof procedure, a very flexible interface for specifying search control heuristics, and an efficient inference engine. We also discuss strength and weaknesses of the system...|$|R
50|$|A typical liquid custody {{transfer}} skid includes multiple flowmeters and meter <b>provers.</b> <b>Provers</b> {{are used to}} calibrate meters in-situ and are performed frequently; typically before, during, and after a batch transfer for metering assurance. A {{good example of this}} is a Lease Automatic Custody Transfer(LACT) unit in a crude oil production facility.|$|E
50|$|Automated theorem <b>provers</b> {{are also}} used to {{implement}} formal verification in computer science. In this setting, theorem <b>provers</b> are used to verify the correctness of programs and of hardware such as processors {{with respect to a}} formal specification. Because such analysis is time-consuming and thus expensive, it is usually reserved for projects in which a malfunction would have grave human or financial consequences.|$|E
50|$|Automated {{reasoning}} {{has been}} most commonly used to build automated theorem <b>provers.</b> Oftentimes, however, theorem <b>provers</b> require some human guidance to be effective and so more generally qualify as proof assistants. In some cases such <b>provers</b> {{have come up with}} new approaches to proving a theorem. Logic Theorist {{is a good example of}} this. The program came up with a proof for one of the theorems in Principia Mathematica that was more efficient (requiring fewer steps) than the proof provided by Whitehead and Russell. Automated reasoning programs are being applied to solve a growing number of problems in formal logic, mathematics and computer science, logic programming, software and hardware verification, circuit design, and many others. The TPTP (Sutcliffe and Suttner 1998) is a library of such problems that is updated on a regular basis. There is also a competition among automated theorem <b>provers</b> held regularly at the CADE conference (Pelletier, Sutcliffe and Suttner 2002); the problems for the competition are selected from the TPTP library.|$|E
40|$|The program {{described}} in this document aims to enable an extensible theorem <b>prover</b> using the resolution method. All the components in the <b>prover,</b> except the core engine, are modular and can be easily re-implemented or extended. For some of the components in {{the first version of}} the <b>prover,</b> simple default implementations were created while for others more advance...|$|R
5000|$|Validity: Validity {{requires}} that the success probability of a knowledge extractor [...] in extracting the witness, given oracle access to a possibly malicious <b>prover</b> , {{must be at least}} as high as the success probability of the <b>prover</b> [...] in convincing the verifier. This Property guarantees that no <b>prover</b> that doesn't know the witness can succeed in convincing the verifier.|$|R
40|$|Abstract. Properties are proved about INSTANCE, a theorem <b>prover</b> module {{that recognizes}} that a formula {{is a special}} case and/or an {{alphabetic}} variant of another formula, and about INSURER, another theorem <b>prover</b> module that decomposes a problem, represented by a formula, into independent subproblems, using a conjunction. The main result of INSTANCE is soundness; the main result of INSURER is a maximum decomposition into subproblems (with some provisos). Experimental results show that a connection graph theorem <b>prover</b> extended with these modules {{is more effective than}} the resolution-based connection graph theorem <b>prover</b> alone...|$|R
5000|$|Calibration using in-place or mobile <b>provers</b> for liquid, or master-meter for liquid or gas; and ...|$|E
50|$|This notation, {{besides being}} used in some {{automated}} theorem <b>provers,</b> sometimes appears in catalogs of proofs.|$|E
5000|$|Jessie verifies {{properties}} in a deductive manner. Jessie {{relies on the}} Why or Why3 back-end to enable proof obligations {{to be sent to}} automatic theorem <b>provers</b> like Z3, Simplify, Alt-Ergo or interactive theorem <b>provers</b> like Coq or Why. Using Jessie, an implementation of bubble-sort or a toy e-voting system can be proved to satisfy their respective specifications. It uses a separation memory model inspired by separation logic.|$|E
40|$|The rst {{step towards}} a wide-coverage tableau <b>prover</b> for natural logic is presented. We {{describe}} an automatized method for obtaining Lambda Logical Forms from surface forms and use this method with an implemented <b>prover</b> {{to hunt for}} new tableau rules in textual entailment data sets. The collected tableau rules are presented and their usage is also exemplified in several tableau proofs. The performance of the <b>prover</b> is evaluated against the development data sets. The evaluation results show an extremely high precision above 97 % of the <b>prover</b> along with a decent recall around 40 %...|$|R
50|$|The {{cognitive}} trapdoor {{game has}} three groups involved in it: a machine verifier, a human <b>prover,</b> and a human observer. The goal {{of each group}} is, human <b>prover</b> has to input the PIN by answering the questions posed by the machine verifier while the observer tries to observe {{the interaction between the}} machine verifier and the human <b>prover</b> to know the PIN. A token is assigned to the <b>prover</b> as a unique identification by an authentic channel to prove his/her own identity. As the <b>prover</b> needs to authenticate themself in it is not easy for the observer to remember the whole login process unless the observer had a recording device. The cognitive trapdoor mechanism is resistant to direct shoulder surfing but not against the recording shoulder surfing.|$|R
40|$|Proof {{reconstruction}} is {{a technique}} that combines an interactive theorem <b>prover</b> and an automatic one in a sound way, so that users benefit from the expressiveness of the first tool and the automation of the latter. We present an implementation of proof reconstruction for first-order logic and set-theoretical constructions between the interactive theorem <b>prover</b> Isabelle and the automatic SMT <b>prover</b> haRVey. ...|$|R
