1|158|Public
40|$|The {{purposes}} of this study were (1) to compare perceptions of school climate measured by 10 subscales of the NASSP School Climate Survey and student satisfaction measured by 8 subscales of the Student Satisfaction Survey of language-minority students to those of non-language-minority students and (2) to investigate whether students' perceptions of school climate, student satisfaction, gender, or language group affected students' academic achievement. The sample population included ninth-grade students at Nogales High School. Students were classified as second-language learners according to the district's Identification, Assessment, and Program Placement flow chart. The study used four independent predictors of reading and math achievement: language group, gender, school climate, and student satisfaction. A multiple regression analysis tested relationships between the <b>predicated</b> <b>variable</b> and independent predictors. The Pearson product-moment correlation determined the relationship between student satisfaction and perception of school climate. A two-way analysis of variance (ANOVA) distinguished whether satisfaction and perceptions of school climate were different for second-language learners and non-second-language learners and whether there was a difference in satisfaction and perceptions of school climate by gender among second-language learners and non-second-language learners. The findings of this study indicated a moderate correlation between student satisfaction and perceptions of school climate. Statistically significant differences were found by language group for student satisfaction and for satisfaction by gender among non-second-language learners. No statistically significant differences were found by language group for school climate, for gender among second-language learners for satisfaction or school climate, or between perceptions of school climate for boys and girls among non-second-language learners. The parameter estimates showed that gender, school climate, and language group were significant independent predictors of reading achievement, while student satisfaction was not. Language group was the only significant independent predictor of mathematics achievement...|$|E
5000|$|In the metavariable sense, a <b>predicate</b> <b>variable</b> {{can be used}} {{to define}} an axiom schema. <b>Predicate</b> <b>variables</b> should be {{distinguished}} from predicate constants, which could be represented either with a different (exclusive) set of predicate letters, or by their own symbols which really do have their own specific meaning in their domain of discourse: e.g[...]|$|R
40|$|Abstract. In {{this paper}} we {{take up the}} study of Henkin quantifiers with boolean {{variables}} [4] also known as partially ordered connectives [19]. We consider first-order formulae prefixed by partially ordered connectives, denoted D, on finite structures. We characterize D as a fragment of second-order existential logic Σ 1 1 ♥ whose formulae do not allow for existential variables being argument of <b>predicate</b> <b>variables.</b> We show that Σ 1 1 ♥ harbors a strict hierarchy induced by the arity of <b>predicate</b> <b>variables</b> {{and that it is}} not closed under complementation, by means of a game-theoretical argument. Admitting for at most one existential variable to appear as the argument of a <b>predicate</b> <b>variable</b> already yields a logic coinciding with full Σ 1 1, thus we show...|$|R
2500|$|For example, P(x) is a <b>predicate</b> <b>variable</b> of valence 1. One {{possible}} {{interpretation is}} [...] "x is a man".|$|R
50|$|In first-order logic, a <b>predicate</b> <b>variable</b> is a <b>predicate</b> letter {{which can}} {{stand for a}} {{relation}} (between terms) but {{which has not been}} specifically assigned any particular relation (or meaning). In first-order logic (FOL) they can be more properly called metalinguistic variables. In higher-order logic, <b>predicate</b> <b>variables</b> correspond to propositional variables which can stand for well-formed formulas of the same logic, and such variables can be quantified by means of (at least) second-order quantifiers.|$|R
50|$|The {{relational}} model's central idea is {{to describe}} a database {{as a collection of}} predicates over a finite set of <b>predicate</b> <b>variables,</b> describing constraints on the possible values and combinations of values. The content of the database at any given time is a finite (logical) model of the database, i.e. a set of relations, one per <b>predicate</b> <b>variable,</b> such that all predicates are satisfied. A request for information from the database (a database query) is also a predicate.|$|R
2500|$|Q(x,y) is a <b>predicate</b> <b>variable</b> of valence 2. Possible interpretations include [...] "x {{is greater}} than y" [...] and [...] "x {{is the father of}} y".|$|R
40|$|I {{describe}} an algorithm which when given a sentence Γ involving universally quantified <b>predicate</b> <b>variables,</b> first reduces this sentence {{to a normal}} form Γ and then, if Γ satisfies certain extra restrictions, eliminates the <b>predicate</b> <b>variables</b> of Γ to produce a predicate-free equivalent of Γ. This process may involve the introduction of skolem functions {{but in many cases}} does not (and so produces a more elementary version of Γ). The algorithm eliminates the <b>predicate</b> <b>variables</b> by witnessing them with certain definable predicates. The choice of these predicates is guided by the shape of the normal form Γ. The algorithm was initially designed to deal with modal correspondence problems. In this respect it is an extension of Sahlqvist's algorithm which produces first order equivalents of a wide class of modal formulas. The algorithm is illustrated by several examples from modal logic. 1 Introduction Many interesting properties of structures c [...] ...|$|R
25|$|Several {{researchers}} have extended logic programming with higher-order programming features derived from higher-order logic, such as <b>predicate</b> <b>variables.</b> Such languages include the Prolog extensions HiLog and λProlog.|$|R
5000|$|If {{letters are}} used for {{predicate}} constants {{as well as for}} <b>predicate</b> <b>variables,</b> then {{there has to be a}} way of distinguishing between them. For example, letters W, X, Y, Z could be designated to represent <b>predicate</b> <b>variables,</b> whereas letters A, B, C,..., U, V could represent predicate [...] "constants". If these letters are not enough, then numerical subscripts can be appended, e.g. X1, X2, X3,... However, if the <b>predicate</b> <b>variables</b> are not perceived (or defined) as belonging to the vocabulary of the predicate calculus, then they are predicate metavariables, whereas the rest of the predicate letters are just called [...] "predicate letters". The metavariables are thus understood to be used to code for axiom schemata and theorem schemata (derived from the axiom schemata). Whether the [...] "predicate letters" [...] are constants or variables is a subtle point: they are not constants in the same sense that [...] are predicate constants, or that [...] are numerical constants.|$|R
50|$|Turned E (∃) is {{a symbol}} based upon the letter E. It is used to {{represent}} existential quantification in predicate logic. When it appears in a formula together with a <b>predicate</b> <b>variable,</b> they {{are referred to as}} an existential quantifier.|$|R
40|$|AbstractGeneralized {{inductive}} definitions give a way {{of defining}} a predicate as the least solution P of the equation P↔A[P] where a <b>predicate</b> <b>variable</b> P may occur in a formula A[P] positively. This paper gives aq-realizability interpretation of generalized inductive definitions and proves the soundness of the interpretation...|$|R
40|$|The {{formal system}} in which the Peano’s axioms hold for numbers and there are quantifications over <b>predicate</b> <b>variables</b> is said to be {{classical}} analysis. In this system the real numbers are definable by predicators as certain sets of rational numbers and universal and existential statements about real numbers are formalizable. The formal system of elementary analysis is the subsystem of classical analysis which is restricted to the comprehension axioms for only elementary predicators in which no quantifiers over <b>predicate</b> <b>variables</b> are contained. And the ω-consistency of a formal system is a stronger property than the simple consistency of the system. We show that a normal form theorem for the formal system of elementary analysis which implies the ω-consistency of the system is proved by applying transfinite induction up to εε 1. 数についてペアノの公理系が成り立ち、述語変数に対する量化が存在する形式的体系は古典解析と呼ばれている。この体系では実数は有理数のある種の集合として述語子で定義され、実数についての全称および存在命題が形式化可能である。初等解析の形式的体系とは古典解析の部分体系であって、その中に述語変数に対する量化子が含まれていないような初等述語子にだけ内包公理を制限したものである。また、ある形式的体系のω無矛盾性はその体系の単なる無矛盾性よりも強い性質である。その体系自身のω無矛盾性を導ける初等解析の形式的体系についてのある標準形定理がεε 1 までの超限帰納法を用いて証明されることを示す...|$|R
30|$|With Shenzhen City, {{a typical}} rapid {{urbanization}} area in China {{or even in}} the whole world, as the case, this study aims to simulate multiple land use dynamics by combining Monte Carlo approach to CA-ANN model, and to choose appropriate model parameters with sensitivity analysis on <b>predicating</b> <b>variables,</b> neighborhood size and cell size.|$|R
5000|$|... is a {{database}} model based on first-order predicate logic. Its core {{idea is to}} describe {{a database}} {{as a collection of}} predicates over a finite set of <b>predicate</b> <b>variables,</b> describing constraints on the possible values and combinations of values.The power of the relational data model lies in its mathematical foundations and a simple user-level paradigm.|$|R
5000|$|Three vertex {{labeling}} functions init, inv, {{and flow}} that assign to each control mode [...] three predicates. Each initial condition init is a <b>predicate</b> whose free <b>variables</b> are from [...] Each invariant condition inv is a <b>predicate</b> whose free <b>variables</b> are from [...] Each flow condition flow is a <b>predicate</b> whose free <b>variables</b> are from [...]|$|R
2500|$|In logic, the {{parameters}} passed to (or operated on by) an open predicate are called parameters by some authors (e.g., Prawitz, [...] "Natural Deduction"; Paulson, [...] "Designing a theorem prover"). Parameters locally defined within the <b>predicate</b> are called <b>variables.</b> This extra distinction pays off when defining substitution (without this distinction special provision {{must be made}} to avoid variable capture). Others (maybe most) just call parameters passed to (or operated on by) an open <b>predicate</b> <b>variables,</b> and when defining substitution have to distinguish between free variables and bound variables.|$|R
5000|$|It {{is usually}} denoted by the turned A (∀) logical {{operator}} symbol, which, when used {{together with a}} <b>predicate</b> <b>variable,</b> is called a universal quantifier ("∀x", [...] "∀(x)", or sometimes by [...] "(x)" [...] alone). Universal quantification is distinct from existential quantification ("there exists"), which asserts that the property or relation holds only {{for at least one}} member of the domain.|$|R
40|$|In {{the paper}} {{electromagnetic}} signals distinguished by their discrete modulation of spatial distributions of fields and amplitudes are considered. Amplitudes of the impulses {{play a role}} of predicates and discrete spatial distributions of fields serve as <b>predicate</b> <b>variables.</b> Designed electronic gates are different by parallelism of the signal processing and allow to create a predicate processor for artificial intellect applications. Comment: 3 pages, 4 Figure...|$|R
50|$|If <b>{{predicate}}</b> <b>variables</b> {{are also}} {{allowed to be}} bound to predicate letters which are unary or have higher arity, and when such letters represent propositional functions, such that {{the domain of the}} arguments is mapped to a range of different propositions, and when such variables can be bound by quantifiers to such sets of propositions, then the result is a higher-order predicate calculus, or higher-order logic.|$|R
50|$|The symbol ∀ has {{the same}} shape as a capital turned A, sans-serif. It is used to {{represent}} universal quantification in predicate logic. When it appears in a formula together with a <b>predicate</b> <b>variable,</b> they {{are referred to as}} a universal quantifier. In traffic engineering it is used to represent flow, the number of units (vehicles) passing a point in a unit of time.|$|R
40|$|We {{report on}} a {{computer}} tutor for the semantics of the Prolog subset of predicate calculus. It gives students statements in English to represent in a single line of Prolog, parses their answers, and compares the parses to the parses of correct answers. The tutor focuses on the correct choice of <b>predicates,</b> <b>variables,</b> and links between expressions. Students seem to learn predicate calculus better using the tutor than with paper and pencil exercises...|$|R
40|$|In {{the present}} article {{a study of the}} finite model theory of Henkin quantifiers with boolean {{variables}} [5], a. k. a. partially ordered connectives [28], is undertaken. The logic of first-order formulae prefixed by partially ordered connectives, denoted D, is considered on finite structures. D is characterized as a fragment of second-order exis-tential logic Σ 1 1; the formulae of the relevant fragment do not allow existentially quantified variables as arguments of <b>predicate</b> <b>variables.</b> Using this characterization result, D is shown to harbor a strict hierarchy induced by the arity of <b>predicate</b> <b>variables.</b> Further, D is shown to capture NP over linearly ordered structures, and not to be closed under complementation. We conclude with a comparison between the logics D and Σ 1 1 on several metatheoretical properties. ∗ The authors gratefully acknowledge Peter van Emde Boas, Lauri Hella, and the referees for their contributions to earlier versions of the paper. Work was partly done while participating to the Logic and Algorithms program at Isaac Newton Institute in Cambridge, UK; we wish to express our gratitude for the support we received. This paper is based on [29, 30]. 1...|$|R
5000|$|In {{predicate}} logic, {{a universal}} quantification {{is a type}} of quantifier, a logical constant which is interpreted as [...] "given any" [...] or [...] "for all". It expresses that a propositional function can be satisfied by every member of a domain of discourse. In other words, it is the predication of a property or relation to every member of the domain. It asserts that a predicate within the scope of a universal quantifier is true of every value of a <b>predicate</b> <b>variable.</b>|$|R
30|$|In SFC, all {{the fields}} are optional, {{but at least}} one of them should be filled. In other words, the user does not have to {{complete}} all the fields every time. For example, if the user types only the subject, then the system automatically creates variables for the property and the object. If the user wants to create a query similar to the example shown in Fig.  3, then he/she does not have to input the <b>predicate</b> <b>variable.</b> If he/she leaves the property field empty the system will automatically add a new variable property.|$|R
40|$|IEEE Frontiers in Education Conference, San Juan, PR, November 10 - 13, 1999 We {{report on}} a {{computer}} tutor for the semantics of the Prolog subset of predicate calculus. It gives students statements in English to represent in a single line of Prolog, parses their answers, and compares the parses to the parses of correct answers. The tutor focuses on the correct choice of <b>predicates,</b> <b>variables,</b> and links between expressions. Tests show that students learn predicate calculus significantly better using the tutor than with paper and pencil exercises...|$|R
5000|$|In {{predicate}} logic, {{an existential}} quantification {{is a type}} of quantifier, a logical constant which is interpreted as [...] "there exists", [...] "there is at least one", or [...] "for some". Some sources use the term existentialization to refer to existential quantification. It is usually denoted by the turned E (∃) logical operator symbol, which, when used together with a <b>predicate</b> <b>variable,</b> is called an existential quantifier ("∃x" [...] or [...] "∃(x)"). Existential quantification is distinct from universal quantification ("for all"), which asserts that the property or relation holds for all members of the domain.|$|R
5000|$|McCabe {{showed that}} the cyclomatic {{complexity}} of any structured program with only one entrance point and one exit point {{is equal to the}} number of decision points (i.e., [...] "if" [...] statements or conditional loops) contained in that program plus one. However, this is true only for decision points counted at the lowest, machine-level instructions. Decisions involving compound predicates like those found in high-level languages like [...] should be counted in terms of <b>predicate</b> <b>variables</b> involved, i.e. in this example one should count two decision points, because at machine level it is equivalent to [...]|$|R
40|$|Abstract. In recent years, a {{great deal}} of {{attention}} has been devoted to logics of common-sense reasoning. Among the candidates proposed, circumscription has been perceived as an elegant mathematical technique for modeling non-monotonic reasoning, but dicult to apply in practice. The major reason for this is the second-order nature of circumscription axioms and the diculty in nding proper substitutions of predicate expressions for <b>predicate</b> <b>variables.</b> One solution to this problem is to compile, where possible, second-order formulas into equivalent rst-order formulas. Although some progress has been made using this approach, the results are not as strong as one might desire and they are isolated in nature. In this article, we provide a general method which can be used in an algorithmic manner to reduce certain circumscription axioms to rst-order formulas. The algorithm takes as input an arbitrary second-order formula and either returns as output an equivalent rst-order formula, or terminates with failure. The class of second-order formulas, and analogously the class of circumscriptive theories which can be reduced, provably subsumes those covered by existing results. We demonstrate the generality of the algorithm using circumscriptive theories with mixed quantiers (some involving Skolemization), variable constants, non-separated formulas, and formulas with n-ary <b>predicate</b> <b>variables.</b> In addition, we analyze the strength of the algorithm, compare it with existing approaches, and provide formal subsumption results...|$|R
40|$|In recent years, a {{great deal}} of {{attention}} has been devoted to logics of "commonsense" reasoning. Among the candidates proposed, circumscription has been perceived as an elegant mathematical technique for modeling nonmonotonic reasoning, but di cult to apply in practice. The major reason for this is the 2 nd-order nature of circumscription axioms and the di culty in nding proper substitutions of predicate expressions for <b>predicate</b> <b>variables.</b> One solution to this problem is to compile, where possible, 2 nd-order formulas into equivalent 1 st-order formulas. Although some progress has been made using this approach, the results are not as strong as one might desire and they are isolated in nature. In this article, we provide a general method which can be used in an algorithmic manner to reduce circumscription axioms to 1 st-order formulas. The algorithm takes as input an arbitrary 2 nd-order formula and either returns as output an equivalent 1 st-order formula, or terminates with failure. The class of 2 nd-order formulas, and analogously the class of circumscriptive theories which can be reduced, provably subsumes those covered by existing results. We demonstrate the generality of the algorithm using circumscriptive theories with mixed quanti ers (some involving Skolemization), variable constants, non-separated formulas, and formulas with n-ary <b>predicate</b> <b>variables.</b> In addition, we analyze the strength of the algorithm and compare it with existing approaches providing formal subsumption results...|$|R
40|$|We {{consider}} {{the problem of}} verification condition generation for Abadi and Leino's program logic (AL) for objects. We provide an algorithm which to a given judgement J in AL computes a formula in first-order fixpoint logic such that {{is equivalent to the}} existence of a proof of J in AL. Moreover, we show that if J is sufficiently annotated, e. g., with loop invariants, then will be purely first-order. The verification condition summarises the mathematical content of a correctness proof in AL while hiding all syntactic detail. We hope that in the presence of appropriate lemmas it will in many cases be possible to delegate the task of proving to a semi-automatic theorem prover so that program verification in AL would essentially amount to formulating appropriate invariants and lemmas. An object-oriented version of Euclid's algorithm looks promising in this direction. The steps of the algorithm are as follows: (1) infer a typing derivation D of J. (2) Turn D into a skeleton proof of J which contains <b>predicate</b> <b>variables</b> in place of actual assertions. (3) Conjoin all logical side-conditions appearing in this skeleton and existentially quantify all <b>predicate</b> <b>variables.</b> The resulting second-order formula is equivalent to the existence of a proof. (4) Apply simplification rules to obtain the desired formula in fixpoint logic or perhaps in pure first-order logic. Keywords verification condition generator, program verification, formal methods, object 1...|$|R
40|$|Ambient logics {{have been}} {{proposed}} to describe properties for mobile agents which may evolve over {{time as well as}} space. So far there still lacks a satisfactory approach to introducing recursion into such logics, due to subtle interactions between recursion and first-oder quantification. In this paper we take the challenging task to extend an ambient logic with xpoints, yielding a predicate-based µ-calculus in which fixpoint formulas are formed using <b>predicate</b> <b>variables.</b> We also develop an algorithm for model checking mobile ambients against formulas of the logic, providing the first decidability result for a spatial logic with recursion...|$|R
40|$|An {{algorithm}} is presented which eliminates second-order quantiers over <b>predicate</b> <b>variables</b> in formulae of type 9 P 1;...; Pn where is an arbitrary formula of first-order predicate logic. The resulting formula {{is equivalent to}} the original formula [...] if the algorithm terminates. The algorithm can for example be applied to do interpolation, to eliminate the second-order quantiers in circumscription, to compute the correlations between structures and power structures, to compute semantic properties corresponding to Hilbert axioms in non classical logics and to compute model theoretic semantics for new logics. An earlier version of the paper has been published in [GO 92 b]...|$|R
40|$|This article {{argues that}} {{currently}} the largest gap between human and machine learning is learning algorithms’ inability to perform deep transfer, that is, generalize from one domain to another domain containing different objects, classes, properties, and relations. We argue that second-order Markov logic is ideally suited {{for this purpose}} and propose an approach based on it. Our algorithm discovers structural regularities in the source domain {{in the form of}} Markov logic formulas with <b>predicate</b> <b>variables</b> and instantiates these formulas with predicates from the target domain. Our approach has successfully transferred learned knowledge among molecular biology, web, and social network domains. status: publishe...|$|R
50|$|FOLFP and FOPFP are two logics {{without any}} predicates, {{apart from the}} {{equality}} <b>predicates</b> between <b>variables</b> and the letters predicates. They are equal respectively to relational-P and FO(PFP) is relational-PSPACE, the classes P and PSPACE over relational machines.|$|R
5000|$|Output: On success returns a {{generalized}} {{version of the}} Reacts <b>predicate</b> whose <b>variables</b> range over the equivalence classes and a new Class predicate which is like Has-Quality having a name-class instead of substance name: (Has-Quality {class-name} quality {value}) ...|$|R
